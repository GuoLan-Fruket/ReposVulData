{"index": 5772, "cve_id": "CVE-2021-21433", "cwe_id": ["CWE-94", "CWE-78"], "cve_language": "Python", "cve_description": "Discord Recon Server is a bot that allows you to do your reconnaissance process from your Discord. Remote code execution in version 0.0.1 would allow remote users to execute commands on the server resulting in serious issues. This flaw is patched in 0.0.2.", "cvss": "8.8", "publish_date": "April 9, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "26e2a084679679cccdeeabbb6889ce120eff7e50", "commit_message": "Fixing Command Injection Issues.", "commit_date": "2021-02-25T10:32:33Z", "project": "demon1a/discord-recon", "url": "https://api.github.com/repos/DEMON1A/Discord-Recon/commits/26e2a084679679cccdeeabbb6889ce120eff7e50", "html_url": "https://github.com/DEMON1A/Discord-Recon/commit/26e2a084679679cccdeeabbb6889ce120eff7e50", "windows_before": [{"commit_id": "a6996fb801df313173453084525cdb3973a89c0b", "commit_date": "Thu Feb 25 12:26:52 2021 +0200", "commit_message": "Create SECURITY.md", "files_name": ["SECURITY.md"]}, {"commit_id": "a41a2778678bb651ef088fb4340f17318d180dea", "commit_date": "Thu Feb 25 02:54:59 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "29b07b8978866710742ecefd9c924b5564b9ea00", "commit_date": "Thu Feb 25 02:54:01 2021 +0200", "commit_message": "Update setting.example.py", "files_name": ["setting.example.py"]}, {"commit_id": "a941783f9179c4ff3b2526d63c0b20e5121564f1", "commit_date": "Thu Feb 25 02:53:38 2021 +0200", "commit_message": "Update setting.py", "files_name": ["setting.py"]}, {"commit_id": "5879a7fcb57fda76af915e984bd002ffc7dd9cc1", "commit_date": "Thu Feb 25 02:53:07 2021 +0200", "commit_message": "Adding Smuggler Support!", "files_name": ["app.py"]}, {"commit_id": "bb3263b70bc162cddbfe977949e628f4cba08036", "commit_date": "Tue Feb 23 06:39:24 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "dfbff3c2795daba7e9cde2fb785ddfddee987ff6", "commit_date": "Tue Feb 23 00:29:20 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "3c38be00a3f384b64c3d0452ec34e211db77d87e", "commit_date": "Tue Feb 23 00:26:08 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "1931dae97948fade9af35359f4a07cb3597c1a3f", "commit_date": "Tue Feb 23 00:25:10 2021 +0200", "commit_message": "Update fileSize.py", "files_name": ["assets/fileSize.py"]}, {"commit_id": "6221d1aa2576b37767b1db12a607511cc880e1c3", "commit_date": "Tue Feb 23 00:24:44 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "a761ffd47f2ba100a8185f13b71a7537ae0f0298", "commit_date": "Mon Feb 22 09:46:49 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "19e28ad6a75854e80a4324d12808dcec5426942b", "commit_date": "Mon Feb 22 09:46:23 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "8519fd8597ab7ae7a7ea4c10a54e0141b20e155e", "commit_date": "Mon Feb 22 09:26:40 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "23100b5bf571d49ea2a1ed42fe27055dfe56e140", "commit_date": "Mon Feb 22 09:24:09 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "e942805df4d8681c2ebdf0e3ffea55a4dfd87d37", "commit_date": "Mon Feb 22 09:21:38 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "388d45e984f36b2d19be4d0ba4ba018221afaa40", "commit_date": "Mon Feb 22 09:21:09 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "d7393d0cd47c31adfb2c4dcbdceda5cedd707206", "commit_date": "Mon Feb 22 09:19:33 2021 +0200", "commit_message": "Create filesUploader.py", "files_name": ["assets/filesUploader.py"]}, {"commit_id": "a5430db1e197389c3c471ef2dc20a7fde2643250", "commit_date": "Mon Feb 22 09:19:16 2021 +0200", "commit_message": "Create fileSize.py", "files_name": ["assets/fileSize.py"]}, {"commit_id": "6fa4e7b370e2c7673c233537952a5b163a70d702", "commit_date": "Mon Feb 22 09:18:50 2021 +0200", "commit_message": "Rename random.py to randomStrings.py", "files_name": ["assets/randomStrings.py"]}, {"commit_id": "3283ff31918f76ebef706945be855fa4c1e40bb0", "commit_date": "Mon Feb 22 09:18:31 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "a6dff588cb73ec7c040853f50e266973105f0852", "commit_date": "Sun Feb 21 10:43:33 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "80a25e736080b56d4677145fc9e86b1776c96c1c", "commit_date": "Sun Feb 21 10:42:12 2021 +0200", "commit_message": "Update clean.sh", "files_name": ["clean.sh"]}, {"commit_id": "0881190bd520ad2a7ce8f4299de82836f38f9ebc", "commit_date": "Sun Feb 21 10:35:52 2021 +0200", "commit_message": "Update resolvedParser.py", "files_name": ["assets/resolvedParser.py"]}, {"commit_id": "20d98a653ea081d134689d12320afd23e6e1a0c2", "commit_date": "Sun Feb 21 10:35:34 2021 +0200", "commit_message": "Update logsParser.py", "files_name": ["assets/logsParser.py"]}, {"commit_id": "74c3b25d7a3d3be8d6ab743df5be0f91039d8bf3", "commit_date": "Sun Feb 21 10:31:24 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "be00b76518e0d7b95841efdd6458638036fce888", "commit_date": "Sun Feb 21 10:29:02 2021 +0200", "commit_message": "Create clean.sh", "files_name": ["clean.sh"]}, {"commit_id": "d52f0530db62ae39df5d67ab53648a0f92ad5bab", "commit_date": "Sun Feb 21 07:11:02 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "4ce88e5dd1217add21ee798fd3d98bbf3a8eddf8", "commit_date": "Sun Feb 21 07:09:56 2021 +0200", "commit_message": "Create resolvedParser.py", "files_name": ["assets/resolvedParser.py"]}, {"commit_id": "a27c061869149d6a035f2305473e03fb3cf23406", "commit_date": "Sun Feb 21 07:09:18 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "47a6e4aba43f2eabed78afb5d0198a9dc3cd588d", "commit_date": "Sun Feb 21 07:08:59 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "d68c727db21e046fe85b199c79a59e1f9316bb9d", "commit_date": "Sun Feb 21 07:07:49 2021 +0200", "commit_message": "Create .github", "files_name": ["data/subjack/.github"]}, {"commit_id": "42e4add79d5eb449b2684f6587ae0b07daf6b569", "commit_date": "Sun Feb 21 07:07:26 2021 +0200", "commit_message": "Create .github", "files_name": ["data/hosts/.github"]}, {"commit_id": "8d0033b4263117ac83907f3e61ec0892070d7301", "commit_date": "Sun Feb 21 06:19:05 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "b940ac88411a34c2a7b168ca8af807d2a463c25a", "commit_date": "Sat Feb 20 07:45:50 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "d06642f53a3577c3d84ad4dc323b111c7b9b6534", "commit_date": "Sat Feb 20 07:26:46 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "c2282c99cf6b7f711a7ebbdbe13940f0307a81a5", "commit_date": "Sat Feb 20 07:26:26 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "41c33b1a2c1b7a7ec9eccfe5da3fdd6766774f0c", "commit_date": "Sat Feb 20 07:25:40 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "484a24b141fa0ca249a7b6825e2f79e8fb1ccbce", "commit_date": "Sat Feb 20 06:46:11 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "093c52f9d8d7f512ff6ad8714e2d7d46d239089c", "commit_date": "Sat Feb 20 06:26:31 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "018880826353c0c303f7038db3dde3e183b4af48", "commit_date": "Sat Feb 20 06:16:04 2021 +0200", "commit_message": "Update logsParser.py", "files_name": ["assets/logsParser.py"]}, {"commit_id": "c79348ed4828121bbdb086a477381078bba92982", "commit_date": "Sat Feb 20 06:15:22 2021 +0200", "commit_message": "Update logsParser.py", "files_name": ["assets/logsParser.py"]}, {"commit_id": "3c7d71f89d0cf6452728130182d609b8b8ebe66a", "commit_date": "Sat Feb 20 06:12:02 2021 +0200", "commit_message": "Create logs.easy", "files_name": ["data/logs/logs.easy"]}, {"commit_id": "b0baf30186ab54b2a07a1d53c0455b35b46c1a40", "commit_date": "Sat Feb 20 06:11:20 2021 +0200", "commit_message": "Update logsParser.py", "files_name": ["assets/logsParser.py"]}, {"commit_id": "aee5bdb0d66a1a038de716dc3e6da03259b97810", "commit_date": "Sat Feb 20 05:37:39 2021 +0200", "commit_message": "Delete logs.easy", "files_name": ["data/logs/logs.easy"]}, {"commit_id": "5a9a14f9215b6fb4c07c7d6a09a192c43140e980", "commit_date": "Sat Feb 20 05:37:31 2021 +0200", "commit_message": "Create .github", "files_name": ["data/logs/.github"]}, {"commit_id": "483ffacd56cc883fad27034fc44cb488edd1d117", "commit_date": "Sat Feb 20 05:32:51 2021 +0200", "commit_message": "Create FUNDING.yml", "files_name": [".github/FUNDING.yml"]}, {"commit_id": "76e93377e87566889bcc8a3854683063ab256fd6", "commit_date": "Sat Feb 20 05:31:59 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "53207adf0e59cb8c3ef8f71536a8146982e4d1b3", "commit_date": "Sat Feb 20 05:04:39 2021 +0200", "commit_message": "Update setting.py", "files_name": ["setting.py"]}, {"commit_id": "e97931808fb12e3896d862e6e9f7248b2859c602", "commit_date": "Sat Feb 20 05:04:23 2021 +0200", "commit_message": "Create setting.example.py", "files_name": ["setting.example.py"]}, {"commit_id": "cef56c593cdab9ef7333c46f8aadc11926c73795", "commit_date": "Sat Feb 20 05:02:44 2021 +0200", "commit_message": "Create setting.py", "files_name": ["setting.py"]}, {"commit_id": "6ef65d0a6a57d68dca81dad46be4a9eca3b0e5c8", "commit_date": "Sat Feb 20 05:01:00 2021 +0200", "commit_message": "Create .github", "files_name": ["messages/.github"]}, {"commit_id": "2ca528fb1d24b089826fa08d0e89b634c7bb5359", "commit_date": "Sat Feb 20 05:00:34 2021 +0200", "commit_message": "Create .github", "files_name": ["data/subdomains/.github"]}, {"commit_id": "9b06a6847508c199269b5933f5390109d4dd7471", "commit_date": "Sat Feb 20 05:00:01 2021 +0200", "commit_message": "Create logs.easy", "files_name": ["data/logs/logs.easy"]}, {"commit_id": "ebf9c7d784d1aa0efe0a2aea02cfb1a5e8b90a8d", "commit_date": "Sat Feb 20 04:59:38 2021 +0200", "commit_message": "Add files via upload", "files_name": ["app.py", "assets/CommandInjection.py", "assets/Duplicates.py", "assets/getIp.py", "assets/logsParser.py", "assets/random.py", "assets/removeColors.py", "assets/removeString.py"]}, {"commit_id": "fb2880f3046b0d3eba28b883e420a0d85e18b5c1", "commit_date": "Sat Feb 20 04:56:42 2021 +0200", "commit_message": "Initial commit", "files_name": ["LICENSE", "README.md"]}], "windows_after": [{"commit_id": "073288fc44245f67de6fb7d2e211b915f0b939e2", "commit_date": "Thu Feb 25 12:45:28 2021 +0200", "commit_message": "Update SECURITY.md", "files_name": ["SECURITY.md"]}, {"commit_id": "19edcc3a534d5114d098bcbe10f3cce3c1795ae9", "commit_date": "Thu Feb 25 12:59:19 2021 +0200", "commit_message": "Fixing Recon Graber Variables Overwrite.", "files_name": ["app.py"]}, {"commit_id": "73a33b514dd0828a314a205e899b84160bd9864c", "commit_date": "Sun Apr 4 06:34:45 2021 +0200", "commit_message": "Extra layer of subdomains validation.", "files_name": ["assets/subdomainsFilter.py"]}, {"commit_id": "edc7ca246767d13f0b083b9097c9fee1aa338046", "commit_date": "Sun Apr 4 06:35:11 2021 +0200", "commit_message": "Update app.py", "files_name": ["app.py"]}, {"commit_id": "58ef231d0ba2bef2af61d454da41e1c5127ae572", "commit_date": "Wed Apr 7 09:49:15 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "aba848201dfe8c33f1ee2e9ef7ec05d3c8e4f1e1", "commit_date": "Thu Apr 8 19:09:20 2021 +0200", "commit_message": "Update setting.py", "files_name": ["setting.py"]}, {"commit_id": "6cfe7e90969fa817fd7ee5ee8df42e909314530e", "commit_date": "Thu Apr 8 19:37:07 2021 +0200", "commit_message": "Update setting.example.py", "files_name": ["setting.example.py"]}, {"commit_id": "8892591007819fd413ef58457741f7bc2a2d364f", "commit_date": "Mon Apr 19 22:21:54 2021 +0200", "commit_message": "Block arguments.", "files_name": ["assets/CommandInjection.py"]}, {"commit_id": "3ab969edeeab64de8457e99810e17f39236ad138", "commit_date": "Mon Apr 19 22:25:43 2021 +0200", "commit_message": "Fixing dirsearch extensions", "files_name": ["app.py"]}, {"commit_id": "aabb35ad1079cf1f199d69ff41ee878dfbb2524f", "commit_date": "Mon Apr 19 22:31:27 2021 +0200", "commit_message": "Updating security policy", "files_name": ["SECURITY.md"]}, {"commit_id": "a6e1324dc6fc7ae3515430607bab588a6b6193fe", "commit_date": "Mon Apr 19 22:32:09 2021 +0200", "commit_message": "Rename clean.sh to bash/clean.sh", "files_name": ["bash/clean.sh"]}, {"commit_id": "5fdfbdab86fd2ca91203c0dd7bffb9149455a30c", "commit_date": "Mon Apr 19 22:32:48 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "4e39ba5a0b0f3096349c7ee96b36f84418ebe130", "commit_date": "Mon Apr 19 22:49:36 2021 +0200", "commit_message": "Fixing file overwrite", "files_name": ["setting.py"]}, {"commit_id": "0f3a1c298b02ab9978f7a74b645ffdf10b431373", "commit_date": "Wed Apr 21 03:46:34 2021 +0200", "commit_message": "Fixing URL validation errors", "files_name": ["assets/CommandInjection.py"]}, {"commit_id": "94ad9ff666ad7af586bda4ca242aec8b37fbba49", "commit_date": "Wed Apr 21 03:55:05 2021 +0200", "commit_message": "Fixing LFI on recon command", "files_name": ["app.py"]}, {"commit_id": "16206b1e4e03433312917589bbb8b01ddf930fb1", "commit_date": "Wed Apr 21 03:56:31 2021 +0200", "commit_message": "Edit broken LFI fix.", "files_name": ["app.py"]}, {"commit_id": "9edc9e9e4d2976719355867d09042883d69ef202", "commit_date": "Wed Apr 21 04:22:06 2021 +0200", "commit_message": "Temporary fix for LFI/RCE", "files_name": ["assets/CommandInjection.py"]}, {"commit_id": "c1294dd7d4918ce557417fec0bffd1a1fcc2d73c", "commit_date": "Wed Apr 21 04:27:14 2021 +0200", "commit_message": "Update CommandInjection.py", "files_name": ["assets/CommandInjection.py"]}, {"commit_id": "f3d5c08140f3c1b044473cbf56630c4c3d82eb8c", "commit_date": "Wed Apr 21 04:40:24 2021 +0200", "commit_message": "Adding second layer of parameters protection", "files_name": ["app.py"]}, {"commit_id": "b06aa658e3e7b6ac907a30740c587d7a53ae616b", "commit_date": "Wed Apr 21 05:17:56 2021 +0200", "commit_message": "Linking nuclei with notify", "files_name": ["app.py"]}, {"commit_id": "4ba0880b7959d568e8372d4d40bd1b18ffba2a53", "commit_date": "Wed Apr 21 05:28:56 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "4cc88a574fcd8cdfb048487ef0c5641d9323e6e6", "commit_date": "Wed Apr 21 05:29:13 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "c6e44364a103b0c6f26f5d0c759840fc374927fd", "commit_date": "Wed Apr 21 05:29:44 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "c4448798e8d15e482535b8f5f3629ee7fb6199ea", "commit_date": "Wed Apr 21 15:28:36 2021 +0200", "commit_message": "Adding security section", "files_name": ["README.md"]}, {"commit_id": "8aeeb76456193c777d1280e9f442f7476ca0ef2c", "commit_date": "Wed Apr 21 15:29:08 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "dbe05df6209451225e3ff9e46ccf3ae19e5d5e50", "commit_date": "Sun Apr 25 15:43:20 2021 +0200", "commit_message": "Add new version.", "files_name": ["SECURITY.md"]}, {"commit_id": "140815b2e38af3db00e61fcc3111e0af896320ea", "commit_date": "Sun Apr 25 15:44:44 2021 +0200", "commit_message": "Update SECURITY.md", "files_name": ["SECURITY.md"]}, {"commit_id": "b496c65f94b4882b45d8010f658e9adc7f36de09", "commit_date": "Sun Apr 25 15:54:34 2021 +0200", "commit_message": "Add nuclei info config.", "files_name": ["setting.py"]}, {"commit_id": "8a705acfc2a4095f53223fa2b1928bb8c47ff1bb", "commit_date": "Sun Apr 25 15:54:55 2021 +0200", "commit_message": "Add nuclei info config.", "files_name": ["setting.example.py"]}, {"commit_id": "e30c1c2d1a55cec30bf437aa67ecec55a12ecc14", "commit_date": "Sun Apr 25 15:55:47 2021 +0200", "commit_message": "Add nuclei info remover", "files_name": ["app.py"]}, {"commit_id": "a9c356134befb7f1ffd6767c916f3ea9cdf33d94", "commit_date": "Thu Apr 29 16:33:29 2021 +0200", "commit_message": "Update and rename .github to .gitkeep", "files_name": ["data/hosts/.github", "data/hosts/.gitkeep"]}, {"commit_id": "3fcb7273d31935500a3fec924995e40f30964109", "commit_date": "Thu Apr 29 16:34:01 2021 +0200", "commit_message": "Delete .github", "files_name": ["data/logs/.github"]}, {"commit_id": "f8b026134243f032d4a3294532617728fe1efcde", "commit_date": "Thu Apr 29 16:34:18 2021 +0200", "commit_message": "Update and rename .github to .gitkeep", "files_name": ["data/subdomains/.github", "data/subdomains/.gitkeep"]}, {"commit_id": "6b4e45db9e34c6f8af2c42185177194b48a5c2bc", "commit_date": "Thu Apr 29 16:34:40 2021 +0200", "commit_message": "Update and rename .github to .gitkeep", "files_name": ["data/subjack/.github", "data/subjack/.gitkeep"]}, {"commit_id": "c91818a8aab45c59bcbff0d749a310a2e623d6af", "commit_date": "Thu Apr 29 16:52:29 2021 +0200", "commit_message": "Disallow arguments on whois command", "files_name": ["app.py"]}, {"commit_id": "c132c8c5654cd6885f7b5e1427356848bcc187b0", "commit_date": "Thu Apr 29 16:57:14 2021 +0200", "commit_message": "Update security section", "files_name": ["README.md"]}, {"commit_id": "54cceaf2d88e2c753c1831a58ae2f4a90ababbe1", "commit_date": "Fri May 7 12:42:27 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "776a96312f124f46551beb50256203441cc49a81", "commit_date": "Sat May 8 21:55:45 2021 +0200", "commit_message": "Exception handler for wrong commands.", "files_name": ["app.py"]}, {"commit_id": "9ce431f6977d847203563ea6edc197558d2dbe01", "commit_date": "Sat May 8 21:56:42 2021 +0200", "commit_message": "Reverting changes that disable argument protection", "files_name": ["app.py"]}, {"commit_id": "c6b66bdda315005b3fe6d18532c382455cd3443b", "commit_date": "Sat May 8 23:13:57 2021 +0200", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "3a918def4e0cc611c14b018c3f050357dda3b1b1", "commit_date": "Sat May 8 23:14:41 2021 +0200", "commit_message": "Compile module for discord-recon", "files_name": ["assets/pyExecute.py"]}, {"commit_id": "bbb0e6ac9b7e0cdd3d23c414e882617e7324658a", "commit_date": "Sat May 8 23:15:19 2021 +0200", "commit_message": "Add PYTHON_COMPILE option", "files_name": ["setting.py"]}, {"commit_id": "ced55373d2a740d8c2fb272f233a883e8c1bd132", "commit_date": "Sat May 8 23:15:37 2021 +0200", "commit_message": "Add PYTHON_COMPILE option", "files_name": ["setting.example.py"]}, {"commit_id": "714cb44f9adb00e224beabcd31177f2c2b5debb4", "commit_date": "Sat May 8 23:16:21 2021 +0200", "commit_message": "Add compile command to execute python", "files_name": ["app.py"]}, {"commit_id": "89f786dec28238c21da8e56f5f627533e5c58bf3", "commit_date": "Sat May 8 23:17:25 2021 +0200", "commit_message": "Adding compile command", "files_name": ["README.md"]}, {"commit_id": "9b576a1d5af867d7a71356b5534bf6da364807ac", "commit_date": "Sun May 9 00:32:38 2021 +0200", "commit_message": "Adding tools bash installer", "files_name": ["bash/installer.sh"]}, {"commit_id": "d9bae59f921d33b929b7a5e6596892aa82c36eec", "commit_date": "Sun May 9 00:32:57 2021 +0200", "commit_message": "Remove development comment", "files_name": ["bash/installer.sh"]}, {"commit_id": "68ac4aeadebee535c576f6f3345b72a97c061ab7", "commit_date": "Sun May 9 00:34:03 2021 +0200", "commit_message": "Default tools paths", "files_name": ["setting.py"]}, {"commit_id": "c8067d9c93ffbd05e73f7aae4acf955216717527", "commit_date": "Sun May 9 00:34:26 2021 +0200", "commit_message": "Default tools paths", "files_name": ["setting.example.py"]}, {"commit_id": "6c0a3c005025e467772c7c77118d3a5eb099a1b8", "commit_date": "Sun May 9 00:34:30 2021 +0200", "commit_message": "Default tools paths", "files_name": ["f22bbba2d98cb13897e1a2b27d812f81167f8904 - Sun May 9 00:35:23 2021 +0200 : Arjun new version support", "app.py"]}, {"commit_id": "3cf4ee70e7a2a84d0df332b4844ab23ee302a569", "commit_date": "Sun May 9 00:44:51 2021 +0200", "commit_message": "Adding SETUP Section", "files_name": ["README.md"]}, {"commit_id": "346049a8257c0a25c37b7c60b5c755a5b1c89382", "commit_date": "Sun May 9 00:45:34 2021 +0200", "commit_message": "Fix Typo", "files_name": ["README.md"]}, {"commit_id": "eae7e56e75e3ffc8f1b539b30210e0aa0231a4f7", "commit_date": "Sun May 9 00:51:08 2021 +0200", "commit_message": "Add ParamSpider to credits", "files_name": ["README.md"]}, {"commit_id": "41d3ac920f3b9409d93a5dd8682e2b35b7b16054", "commit_date": "Sun May 9 00:53:38 2021 +0200", "commit_message": "Update Support Message", "files_name": ["README.md"]}, {"commit_id": "6507a8e4b0b5d71c54808a08980e482878f8b05b", "commit_date": "Sun May 9 03:12:19 2021 +0200", "commit_message": "Rename setting.py to settings.py", "files_name": ["settings.py"]}, {"commit_id": "2a3788c4c2fd7007f57a09ddc1e104fca80ccaa2", "commit_date": "Sun May 9 03:12:33 2021 +0200", "commit_message": "Rename setting.example.py to settings.example.py", "files_name": ["settings.example.py"]}, {"commit_id": "6121ebd173daa0eb087338ed1e2d27eb7a355363", "commit_date": "Sun May 9 03:13:08 2021 +0200", "commit_message": "Update settings import", "files_name": ["app.py"]}, {"commit_id": "33517e53cfe5a7fdc36cf95384c76461b422fc1a", "commit_date": "Sun May 9 03:22:33 2021 +0200", "commit_message": "Import python compile module", "files_name": ["app.py"]}, {"commit_id": "004290f6f4ebb8b57b80a9c323b32675cb5d6bfc", "commit_date": "Sun May 9 03:49:43 2021 +0200", "commit_message": "Add commands logger module", "files_name": ["assets/commandsLogger.py"]}, {"commit_id": "db0d2c1265aafa3555d30ecc50d078d633ed553a", "commit_date": "Sun May 9 03:50:27 2021 +0200", "commit_message": "Fix messages issues, adding commands logging", "files_name": ["app.py"]}, {"commit_id": "8b6303a59fc528e5ec4dcb408c183c25ae9f0818", "commit_date": "Sun May 9 15:17:14 2021 +0200", "commit_message": "Fix typo", "files_name": ["README.md"]}, {"commit_id": "3d2e6203ce8e19587bcc2696a2fa5ca2bd046df6", "commit_date": "Sun May 9 15:52:09 2021 +0200", "commit_message": "Adding missing setup info", "files_name": ["README.md"]}, {"commit_id": "099c7d227aa93a4532e99677efa83544f0e75f96", "commit_date": "Sun May 9 22:45:35 2021 +0200", "commit_message": "Update logger format", "files_name": ["assets/commandsLogger.py"]}, {"commit_id": "2c9b87799f280d9e3a7560b2bbbd19289a3ececb", "commit_date": "Wed May 12 21:20:41 2021 +0200", "commit_message": "Remove old arjun code", "files_name": ["app.py"]}, {"commit_id": "028477c59755a4fbbff804cb731db65b501644a0", "commit_date": "Wed May 12 21:21:21 2021 +0200", "commit_message": "Remove old arjun code", "files_name": []}], "parents": [{"commit_id_before": "a6996fb801df313173453084525cdb3973a89c0b", "url_before": "https://api.github.com/repos/DEMON1A/Discord-Recon/commits/a6996fb801df313173453084525cdb3973a89c0b", "html_url_before": "https://github.com/DEMON1A/Discord-Recon/commit/a6996fb801df313173453084525cdb3973a89c0b"}], "details": [{"raw_url": "https://github.com/DEMON1A/Discord-Recon/raw/26e2a084679679cccdeeabbb6889ce120eff7e50/app.py", "code": "import discord , subprocess , datetime\nfrom discord.ext import commands\nfrom setting import *\nfrom os import path , getcwd , chdir\n\nfrom assets import CommandInjection\nfrom assets import getIp\nfrom assets import randomStrings\nfrom assets import removeColors\nfrom assets import Duplicates\nfrom assets import removeString\nfrom assets import logsParser\nfrom assets import resolvedParser\nfrom assets import fileSize\nfrom assets import filesUploader\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems: logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems: resolvedItems = {}\n\n# Commands\n@Client.command()\nasync def exec(ctx , *, argument):\n    for ADMIN in ADMINS:\n        if str(ctx.message.author) == ADMIN:\n            try:\n                Process = subprocess.Popen(f'{argument}' , shell=True , executable=\"/bin/bash\" , stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                Results = Process.communicate()[0].decode('UTF-8')\n                if len(Results) > 2000:\n                    RandomStr = randomStrings.Genrate()\n\n                    with open(f'messages/{RandomStr}' , 'w') as Message:\n                        Message.write(Results); Message.close()\n                        await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n                else:\n                    if Results != '': await ctx.send(f'```{Results}```')\n                    else: await ctx.send(f\"**The Command You Performed Didn't Return an Output.**\")\n            except Exception as e:\n                print(\"Exception Happened!\")\n                if DEBUG == True: await ctx.send(f'Python Error: **{str(e)}**')\n                else: await ctx.send(\"**Your Command Returned an Error.**\")\n            return None\n        else: pass\n    await ctx.send(f\"**You're Not Authorized To Make Commands To The Server.**\")\n\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Results = subprocess.check_output([f'nslookup {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'whois {argument}'] , shell=True).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Whois Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Whois Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'dig {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(\"**Dig Results:**\")\n    await ctx.send(f\"```{Output}```\")\n    await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    Message = getIp.getIp(Domain=argument)\n    await ctx.send(Message)\n\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n    \n    Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n    \n    Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'python3 arjun.py -u {argument}' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n    Output = removeString.removeString('Processing' , Output=Output)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    chdir(MainPath)\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Waybackurls Results: {URL_}\")\n            else:\n                await ctx.send(\"**Waybackurls Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Assetfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Findomain Results: {URL_}\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = removeColors.Remove(Text=Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"ParamSpider Results: {URL_}\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/')\n            Data = open(Path).read().rstrip()\n            Data = removeColors.Remove(Text=Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Message)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Recon Results: {URL_}\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\n@Client.command()\nasync def subdomains(ctx , * , argument):\n    global logsItems, resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    '''\n    Subdomains collections gonna use three tools\n    subfinder, findomain, assetfinder\n\n    it won't use amass until we upgrade the server. if you're a developer\n    and you want to add amass. i guess you know what todo.\n    '''\n\n    await ctx.send(f\"**Collecting Subdomains For {argument}, Gonna Send You It When It's Done**\")\n\n    # global paths\n    findomainPath = TOOLS['findomain']\n\n    # findomain Subdomains\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    findomainResults = Process.communicate()[0].decode('UTF-8')\n\n    # assetfinder Subdomains\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    assetfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # subfinder Subdomains\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # filter duplicates\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = Duplicates.Duplicates(Subdomains=allSubdomains)\n\n    # saving subdomains\n    fileName = randomStrings.Genrate()\n    resolvedName = randomStrings.Genrate()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains); subdomainsFile.close()\n\n    # add resolved into logs\n    resolvedParser.resolvedWriter(Target=argument , fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    # validate subdomains\n    Process = subprocess.Popen(f\"cat data/hosts/{resolvedName} | httpx -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n\n    # saving httpx results\n    with open(f'data/subdomains/{fileName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults); subdomainsFile.close()\n\n    # add results into logs\n    logsParser.logsWriter(Target=argument , fileName=fileName)\n    logsItems[argument] = fileName\n\n    # send httpx results\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subdomains For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Getting Subdomains Information (titles , status-codes, web-servers) for {argument} using httpx.**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = removeColors.Remove(Text=httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Httpx Results For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    Process = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    nucleiResults = Process.communicate()[0].decode('UTF-8')\n    nucleiResults = removeColors.Remove(Text=nucleiResults)\n\n    if nucleiResults == '':\n        await ctx.send(f\"**Nuclei Couldn't Find Issue On {argument}**\")\n    elif len(nucleiResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(nucleiResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Nuclei Results: {URL_}\")\n            else:\n                await ctx.send(\"**Nuclei Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Nuclei Results For {argument}:**\")\n        await ctx.send(f'```{nucleiResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = randomStrings.Genrate()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    Process = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjackResults = Process.communicate()[0].decode('UTF-8')\n    subjackResults = removeColors.Remove(Text=subjackResults)\n\n    if subjackResults == '':\n        await ctx.send(f\"**Subjack Couldn't Find Issue On {argument}**\")\n    elif len(subjackResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjackResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjack Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjack Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjack Results For {argument}:**\")\n        await ctx.send(f'```{subjackResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjsResults = Process.communicate()[0].decode('UTF-8')\n\n    if subjsResults == '':\n        await ctx.send(f\"**Subjs Couldn't Find Issue On {argument}**\")\n    elif len(subjsResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjsResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjs Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjs Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjs Results For {argument}:**\")\n        await ctx.send(f'```{subjsResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = removeColors.Remove(Text=smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Smuggler Results: {URL_}\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = ', '.join(targetsList)\n    await ctx.send(f\"**We Have Subdomains For: {targetsMessage}**\")\n\n@Client.command()\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n\n        await ctx.send(f\"**There's {str(resolvedLength)} Live Hosts For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n\n        await ctx.send(f\"**There's {str(subdomainsLength)} Valid Subdomains For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_member_join(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Joined The Server.\")\n\n@Client.event\nasync def on_member_remove(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Left The Server.\")\n\n@Client.event\nasync def on_ready():\n    Dates = datetime.datetime.now()\n    Message = f\"**ReconServer Started To Work On {Dates.year}-{Dates.month}-{Dates.day}**\"\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(Message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n", "code_before": "import discord , subprocess , datetime\nfrom discord.ext import commands\nfrom setting import *\nfrom os import path , getcwd , chdir\n\nfrom assets import CommandInjection\nfrom assets import getIp\nfrom assets import randomStrings\nfrom assets import removeColors\nfrom assets import Duplicates\nfrom assets import removeString\nfrom assets import logsParser\nfrom assets import resolvedParser\nfrom assets import fileSize\nfrom assets import filesUploader\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems: logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems: resolvedItems = {}\n\n# Commands\n@Client.command()\nasync def exec(ctx , *, argument):\n    for ADMIN in ADMINS:\n        if str(ctx.message.author) == ADMIN:\n            try:\n                Process = subprocess.Popen(f'{argument}' , shell=True , executable=\"/bin/bash\" , stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                Results = Process.communicate()[0].decode('UTF-8')\n                if len(Results) > 2000:\n                    RandomStr = randomStrings.Genrate()\n\n                    with open(f'messages/{RandomStr}' , 'w') as Message:\n                        Message.write(Results); Message.close()\n                        await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n                else:\n                    if Results != '': await ctx.send(f'```{Results}```')\n                    else: await ctx.send(f\"**The Command You Performed Didn't Return an Output.**\")\n            except Exception as e:\n                print(\"Exception Happened!\")\n                if DEBUG == True: await ctx.send(f'Python Error: **{str(e)}**')\n                else: await ctx.send(\"**Your Command Returned an Error.**\")\n            return None\n        else: pass\n    await ctx.send(f\"**You're Not Authorized To Make Commands To The Server.**\")\n\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Results = subprocess.check_output([f'nslookup {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'whois {argument}'] , shell=True).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Whois Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Whois Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'dig {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(\"**Dig Results:**\")\n    await ctx.send(f\"```{Output}```\")\n    await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    Message = getIp.getIp(Domain=argument)\n    await ctx.send(Message)\n\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'python3 arjun.py -u {argument}' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n    Output = removeString.removeString('Processing' , Output=Output)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    chdir(MainPath)\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Waybackurls Results: {URL_}\")\n            else:\n                await ctx.send(\"**Waybackurls Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Assetfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Findomain Results: {URL_}\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = removeColors.Remove(Text=Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"ParamSpider Results: {URL_}\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/')\n            Data = open(Path).read().rstrip()\n            Data = removeColors.Remove(Text=Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Message)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Recon Results: {URL_}\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\n@Client.command()\nasync def subdomains(ctx , * , argument):\n    global logsItems, resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    '''\n    Subdomains collections gonna use three tools\n    subfinder, findomain, assetfinder\n\n    it won't use amass until we upgrade the server. if you're a developer\n    and you want to add amass. i guess you know what todo.\n    '''\n\n    await ctx.send(f\"**Collecting Subdomains For {argument}, Gonna Send You It When It's Done**\")\n\n    # global paths\n    findomainPath = TOOLS['findomain']\n\n    # findomain Subdomains\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    findomainResults = Process.communicate()[0].decode('UTF-8')\n\n    # assetfinder Subdomains\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    assetfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # subfinder Subdomains\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # filter duplicates\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = Duplicates.Duplicates(Subdomains=allSubdomains)\n\n    # saving subdomains\n    fileName = randomStrings.Genrate()\n    resolvedName = randomStrings.Genrate()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains); subdomainsFile.close()\n\n    # add resolved into logs\n    resolvedParser.resolvedWriter(Target=argument , fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    # validate subdomains\n    Process = subprocess.Popen(f\"cat data/hosts/{resolvedName} | httpx -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n\n    # saving httpx results\n    with open(f'data/subdomains/{fileName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults); subdomainsFile.close()\n\n    # add results into logs\n    logsParser.logsWriter(Target=argument , fileName=fileName)\n    logsItems[argument] = fileName\n\n    # send httpx results\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subdomains For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Getting Subdomains Information (titles , status-codes, web-servers) for {argument} using httpx.**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = removeColors.Remove(Text=httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Httpx Results For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    Process = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    nucleiResults = Process.communicate()[0].decode('UTF-8')\n    nucleiResults = removeColors.Remove(Text=nucleiResults)\n\n    if nucleiResults == '':\n        await ctx.send(f\"**Nuclei Couldn't Find Issue On {argument}**\")\n    elif len(nucleiResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(nucleiResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Nuclei Results: {URL_}\")\n            else:\n                await ctx.send(\"**Nuclei Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Nuclei Results For {argument}:**\")\n        await ctx.send(f'```{nucleiResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = randomStrings.Genrate()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    Process = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjackResults = Process.communicate()[0].decode('UTF-8')\n    subjackResults = removeColors.Remove(Text=subjackResults)\n\n    if subjackResults == '':\n        await ctx.send(f\"**Subjack Couldn't Find Issue On {argument}**\")\n    elif len(subjackResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjackResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjack Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjack Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjack Results For {argument}:**\")\n        await ctx.send(f'```{subjackResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjsResults = Process.communicate()[0].decode('UTF-8')\n\n    if subjsResults == '':\n        await ctx.send(f\"**Subjs Couldn't Find Issue On {argument}**\")\n    elif len(subjsResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjsResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjs Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjs Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjs Results For {argument}:**\")\n        await ctx.send(f'```{subjsResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = removeColors.Remove(Text=smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Smuggler Results: {URL_}\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = ', '.join(targetsList)\n    await ctx.send(f\"**We Have Subdomains For: {targetsMessage}**\")\n\n@Client.command()\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n\n        await ctx.send(f\"**There's {str(resolvedLength)} Live Hosts For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n\n        await ctx.send(f\"**There's {str(subdomainsLength)} Valid Subdomains For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_member_join(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Joined The Server.\")\n\n@Client.event\nasync def on_member_remove(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Left The Server.\")\n\n@Client.event\nasync def on_ready():\n    Dates = datetime.datetime.now()\n    Message = f\"**ReconServer Started To Work On {Dates.year}-{Dates.month}-{Dates.day}**\"\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(Message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n", "patch": "@@ -95,6 +95,10 @@ async def ip(ctx , *, argument):\n \n @Client.command()\n async def dirsearch(ctx , *, argument):\n+    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n+        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n+        return\n+    \n     Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)\n     await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n     Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n@@ -115,6 +119,10 @@ async def dirsearch(ctx , *, argument):\n \n @Client.command()\n async def arjun(ctx , *, argument):\n+    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n+        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n+        return\n+    \n     Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)\n     await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n     await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")", "file_path": "files/2021_4/622", "file_language": "py", "file_name": "app.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.lang.security.audit.subprocess-shell-true.subprocess-shell-true                         \n          Found 'subprocess' function 'Popen' with 'shell=True'. This is dangerous because this call  \n          will spawn the command using a shell process. Doing so propagates current shell settings and\n          variables, which makes it much easier for a malicious actor to execute commands. Use        \n          'shell=False' instead.                                                                      \n          Details: https://sg.run/J92w                                                                \n\n           \u25b6\u25b6\u2506 Autofix \u25b6 subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' ,                               \n  shell=False,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)                                                          \n          100\u2506 Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' ,                               \n  shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)                                                           "]]}, "target": 1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
