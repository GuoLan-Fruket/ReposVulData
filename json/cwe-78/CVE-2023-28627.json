{"index": 10853, "cve_id": "CVE-2023-28627", "cwe_id": ["CWE-78"], "cve_language": "Python", "cve_description": "pymedusa is an automatic video library manager for TV Shows. In versions prior 1.0.12 an attacker with access to the web interface can update the git executable path in /config/general/ > advanced settings with arbitrary OS commands. An attacker may exploit this vulnerability to take execute arbitrary OS commands as the user running the pymedusa program. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "cvss": "8.8", "publish_date": "March 27, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "66d4be8f0872bd5ddcdc5c5a58cb014d22834a45", "commit_message": "Ensure that git_path is a valid file (#11138)\n\n* Ensure that git_path is a valid file\r\n\r\n* Update github_updater.py", "commit_date": "2023-02-22T10:23:45Z", "project": "pymedusa/medusa", "url": "https://api.github.com/repos/pymedusa/Medusa/commits/66d4be8f0872bd5ddcdc5c5a58cb014d22834a45", "html_url": "https://github.com/pymedusa/Medusa/commit/66d4be8f0872bd5ddcdc5c5a58cb014d22834a45", "windows_before": [{"commit_id": "d44ae910b2e6e94db608ee74221d1ce230118651", "commit_date": "Thu Feb 16 13:44:36 2023 +0100", "commit_message": "Encode NZBGet username, password and host (#11129)", "files_name": ["medusa/clients/nzb/nzbget.py"]}, {"commit_id": "831b848b5f573a85fbdb13d47431e5e417805b4a", "commit_date": "Sun Jan 22 15:36:41 2023 +0100", "commit_message": "Avoid exception when the filepart can't match a season (#11105)", "files_name": ["medusa/name_parser/rules/rules.py"]}, {"commit_id": "1064d7b9345170c4862d59951666b379f529ccea", "commit_date": "Sat Jan 14 18:04:14 2023 +0100", "commit_message": "Merge pull request #11100 from pymedusa/sync-ma-dev", "files_name": ["a80631ae72c9a8a8ef3e262b6ef1999a2c7213a3 - Sat Jan 14 17:49:52 2023 +0100 : Update changelog", "CHANGELOG.md"]}, {"commit_id": "ca8f0d5103d97c9f05f890f1f7fbb2157bee2068", "commit_date": "Sat Jan 14 17:48:49 2023 +0100", "commit_message": "yarn dev", "files_name": ["themes/dark/assets/css/bootstrap-formhelpers.min.css", "themes/dark/assets/css/browser.css", "themes/dark/assets/css/country-flags.css", "themes/dark/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/dark/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/dark/assets/css/print.css", "themes/dark/assets/css/style.css", "themes/dark/assets/css/themed.css", "themes/dark/assets/css/vender.min.css", "themes/dark/assets/css/vendors.css", "themes/dark/assets/js/apibuilder.js", "themes/dark/assets/js/app.js", "themes/dark/assets/js/browser.js", "themes/dark/assets/js/index.js", "themes/dark/assets/js/lib/bootstrap-formhelpers.min.js", "themes/dark/assets/js/medusa-runtime.js", "themes/dark/assets/js/notifications.js", "themes/dark/assets/js/vender.js", "themes/dark/assets/js/vender.min.js", "themes/dark/assets/js/vendors.js", "themes/dark/assets/js/vendors~date-fns.js", "themes/light/assets/css/bootstrap-formhelpers.min.css", "themes/light/assets/css/browser.css", "themes/light/assets/css/country-flags.css", "themes/light/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/light/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/light/assets/css/print.css", "themes/light/assets/css/style.css", "themes/light/assets/css/themed.css", "themes/light/assets/css/vender.min.css", "themes/light/assets/css/vendors.css", "themes/light/assets/js/apibuilder.js", "themes/light/assets/js/app.js", "themes/light/assets/js/browser.js", "themes/light/assets/js/index.js", "themes/light/assets/js/lib/bootstrap-formhelpers.min.js", "themes/light/assets/js/medusa-runtime.js", "themes/light/assets/js/notifications.js", "themes/light/assets/js/vender.js", "themes/light/assets/js/vender.min.js", "themes/light/assets/js/vendors.js", "themes/light/assets/js/vendors~date-fns.js"]}, {"commit_id": "b9292f9d786e90a3aa0ba9a9ebdfebe4e0c5297e", "commit_date": "Sat Jan 14 17:42:26 2023 +0100", "commit_message": "Merge pull request #11099 from pymedusa/release/release-1.0.11", "files_name": ["bd3b61294e399024c231612b75e0e34b4f55c5a1 - Sat Jan 14 17:33:06 2023 +0100 : Bump version", "medusa/common.py"]}, {"commit_id": "89d3a5c9a8d77a037b17842a5aa290f52eef2b05", "commit_date": "Sat Jan 14 17:32:22 2023 +0100", "commit_message": "Update changelog", "files_name": ["CHANGELOG.md"]}, {"commit_id": "f1c72914f21ccb90f068adb9ffccc5c95b21410f", "commit_date": "Sat Jan 14 17:28:12 2023 +0100", "commit_message": "yarn build", "files_name": ["themes/dark/assets/css/bootstrap-formhelpers.min.css", "themes/dark/assets/css/browser.css", "themes/dark/assets/css/country-flags.css", "themes/dark/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/dark/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/dark/assets/css/print.css", "themes/dark/assets/css/style.css", "themes/dark/assets/css/themed.css", "themes/dark/assets/css/vender.min.css", "themes/dark/assets/css/vendors.css", "themes/dark/assets/js/apibuilder.js", "themes/dark/assets/js/app.js", "themes/dark/assets/js/browser.js", "themes/dark/assets/js/index.js", "themes/dark/assets/js/lib/bootstrap-formhelpers.min.js", "themes/dark/assets/js/medusa-runtime.js", "themes/dark/assets/js/medusa-runtime.js.map", "themes/dark/assets/js/notifications.js", "themes/dark/assets/js/vender.js", "themes/dark/assets/js/vender.min.js", "themes/dark/assets/js/vendors.js", "themes/dark/assets/js/vendors~date-fns.js", "themes/light/assets/css/bootstrap-formhelpers.min.css", "themes/light/assets/css/browser.css", "themes/light/assets/css/country-flags.css", "themes/light/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/light/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/light/assets/css/print.css", "themes/light/assets/css/style.css", "themes/light/assets/css/themed.css", "themes/light/assets/css/vender.min.css", "themes/light/assets/css/vendors.css", "themes/light/assets/js/apibuilder.js", "themes/light/assets/js/app.js", "themes/light/assets/js/browser.js", "themes/light/assets/js/index.js", "themes/light/assets/js/lib/bootstrap-formhelpers.min.js", "themes/light/assets/js/medusa-runtime.js", "themes/light/assets/js/medusa-runtime.js.map", "themes/light/assets/js/notifications.js", "themes/light/assets/js/vender.js", "themes/light/assets/js/vender.min.js", "themes/light/assets/js/vendors.js", "themes/light/assets/js/vendors~date-fns.js"]}, {"commit_id": "ac1b9f1c6d4f4afd8f4d831aef4af1e0963f6717", "commit_date": "Fri Jan 13 17:25:23 2023 +0100", "commit_message": "Change missing directory log level to debug (#11098)", "files_name": ["medusa/tv/episode.py"]}, {"commit_id": "f36db2f2d9928ac029d5dd011e79cc500e1be74e", "commit_date": "Fri Dec 30 13:43:50 2022 -0600", "commit_message": "Fix parsing for shows that have year in the title (#11081)", "files_name": ["medusa/name_parser/rules/rules.py", "tests/test_guessit.yml"]}, {"commit_id": "3f55529ecac607f2c8b3b4065f0c085a32f9ad5d", "commit_date": "Fri Dec 30 11:41:34 2022 +0100", "commit_message": "Put showid search results on top. (#11084)", "files_name": ["themes-default/slim/src/components/new-show-search.vue", "themes/dark/assets/js/medusa-runtime.js", "themes/light/assets/js/medusa-runtime.js"]}, {"commit_id": "2da799790eebe830805957416bddec035360d0e2", "commit_date": "Thu Dec 15 11:43:21 2022 +0100", "commit_message": "Merge pull request #11060 from pymedusa/sync-ma-dev", "files_name": ["b048e203f61df304cf254c227453d31856fa1588 - Thu Dec 15 11:37:35 2022 +0100 : Update CHANGELOG.md", "CHANGELOG.md"]}, {"commit_id": "f44fe43bcd933684858787b6c9a5c39b873f32f8", "commit_date": "Thu Dec 15 11:33:27 2022 +0100", "commit_message": "yarn dev", "files_name": ["themes/dark/assets/css/bootstrap-formhelpers.min.css", "themes/dark/assets/css/browser.css", "themes/dark/assets/css/country-flags.css", "themes/dark/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/dark/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/dark/assets/css/print.css", "themes/dark/assets/css/style.css", "themes/dark/assets/css/themed.css", "themes/dark/assets/css/vender.min.css", "themes/dark/assets/css/vendors.css", "themes/dark/assets/js/apibuilder.js", "themes/dark/assets/js/app.js", "themes/dark/assets/js/browser.js", "themes/dark/assets/js/index.js", "themes/dark/assets/js/lib/bootstrap-formhelpers.min.js", "themes/dark/assets/js/medusa-runtime.js", "themes/dark/assets/js/notifications.js", "themes/dark/assets/js/vender.js", "themes/dark/assets/js/vender.min.js", "themes/dark/assets/js/vendors.js", "themes/dark/assets/js/vendors~date-fns.js", "themes/light/assets/css/bootstrap-formhelpers.min.css", "themes/light/assets/css/browser.css", "themes/light/assets/css/country-flags.css", "themes/light/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/light/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/light/assets/css/print.css", "themes/light/assets/css/style.css", "themes/light/assets/css/themed.css", "themes/light/assets/css/vender.min.css", "themes/light/assets/css/vendors.css", "themes/light/assets/js/apibuilder.js", "themes/light/assets/js/app.js", "themes/light/assets/js/browser.js", "themes/light/assets/js/index.js", "themes/light/assets/js/lib/bootstrap-formhelpers.min.js", "themes/light/assets/js/medusa-runtime.js", "themes/light/assets/js/notifications.js", "themes/light/assets/js/vender.js", "themes/light/assets/js/vender.min.js", "themes/light/assets/js/vendors.js", "themes/light/assets/js/vendors~date-fns.js"]}, {"commit_id": "0b9b58d184ae4fc5467f3474d452f888dfbaac10", "commit_date": "Thu Dec 15 10:50:20 2022 +0100", "commit_message": "Merge pull request #11059 from pymedusa/release/release-1.0.10", "files_name": ["6db29a4ff40631c55d662d4dea997274b23bf359 - Thu Dec 15 01:03:08 2022 +0100 : Update changelog", "CHANGELOG.md"]}, {"commit_id": "33fbb807fb5b6d4d6d1cd7c3ff3d93bc2ec0a79b", "commit_date": "Thu Dec 15 00:57:29 2022 +0100", "commit_message": "Bump version", "files_name": ["medusa/common.py"]}, {"commit_id": "758ed9bd2bd2a906c57888ab5c933b61af10adbf", "commit_date": "Thu Dec 15 00:57:17 2022 +0100", "commit_message": "yarn dev", "files_name": ["themes/dark/assets/css/bootstrap-formhelpers.min.css", "themes/dark/assets/css/browser.css", "themes/dark/assets/css/country-flags.css", "themes/dark/assets/css/lib/jquery-ui-1.10.4.custom.min.css", "themes/dark/assets/css/lib/jquery.qtip-2.2.1.min.css", "themes/dark/assets/css/print.css", "themes/dark/assets/css/style.css", "themes/dark/assets/css/themed.css", "themes/dark/assets/css/vender.min.css", "themes/dark/assets/css/vendors.css", "themes/dark/assets/js/apibuilder.js", "themes/dark/assets/js/app.js", "themes/dark/assets/js/browser.js", "themes/dark/assets/js/index.js", "themes/dark/assets/js/lib/bootstrap-formhelpers.min.js", "themes/dark/assets/js/medusa-runtime.js", "themes/dark/assets/js/notifications.js", "themes/dark/assets/js/vender.js", "themes/dark/assets/js/vender.min.js", "themes/dark/assets/js/vendors.js", "themes/dark/assets/js/vendors~date-fns.js", "themes/light/assets/css/bootstrap-formhelpers.min.css"]}], "windows_after": [{"commit_id": "dfcbdc12ca8b22adb8ce931dbb508bc4a3829fef", "commit_date": "Wed Feb 22 11:40:37 2023 +0100", "commit_message": "Update Mako", "files_name": ["ext/mako/__init__.py", "ext/mako/_ast_util.py", "ext/mako/ast.py", "ext/mako/cache.py", "ext/mako/cmd.py", "ext/mako/codegen.py", "ext/mako/compat.py", "ext/mako/exceptions.py", "ext/mako/ext/autohandler.py", "ext/mako/ext/babelplugin.py", "ext/mako/ext/beaker_cache.py", "ext/mako/ext/extract.py", "ext/mako/ext/linguaplugin.py", "ext/mako/ext/preprocessors.py", "ext/mako/ext/pygmentplugin.py", "ext/mako/ext/turbogears.py", "ext/mako/filters.py", "ext/mako/lexer.py", "ext/mako/lookup.py", "ext/mako/parsetree.py", "ext/mako/pygen.py", "ext/mako/pyparser.py", "ext/mako/runtime.py", "ext/mako/template.py", "ext/mako/testing/__init__.py", "ext/mako/testing/_config.py", "ext/mako/testing/assertions.py", "ext/mako/testing/config.py", "ext/mako/testing/exclusions.py", "ext/mako/testing/fixtures.py", "ext/mako/testing/helpers.py", "ext/mako/util.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "065d3a15dc1aba32f44cca77af8eaad40562b717", "commit_date": "Wed Feb 22 11:44:38 2023 +0100", "commit_message": "Update markdown2", "files_name": ["ext/markdown2.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "89516ec43e248187dbde0995abad68563c661b09", "commit_date": "Wed Feb 22 11:49:26 2023 +0100", "commit_message": "Update PyJWT", "files_name": ["ext/jwt/__init__.py", "ext/jwt/algorithms.py", "ext/jwt/api_jwk.py", "ext/jwt/api_jws.py", "ext/jwt/api_jwt.py", "ext/jwt/exceptions.py", "ext/jwt/help.py", "ext/jwt/jwk_set_cache.py", "ext/jwt/jwks_client.py", "ext/jwt/utils.py", "ext/jwt/warnings.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "ad4a2c54da19cff5b44160283c52b289c4bda347", "commit_date": "Wed Feb 22 11:50:01 2023 +0100", "commit_message": "Update CacheControl", "files_name": ["ext/cachecontrol/__init__.py", "ext/cachecontrol/_cmd.py", "ext/cachecontrol/adapter.py", "ext/cachecontrol/cache.py", "ext/cachecontrol/caches/__init__.py", "ext/cachecontrol/caches/file_cache.py", "ext/cachecontrol/caches/redis_cache.py", "ext/cachecontrol/compat.py", "ext/cachecontrol/controller.py", "ext/cachecontrol/filewrapper.py", "ext/cachecontrol/heuristics.py", "ext/cachecontrol/serialize.py", "ext/cachecontrol/wrapper.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "20d2d61fb163f40f6b863beca31186ab4bf6ac74", "commit_date": "Wed Feb 22 11:55:31 2023 +0100", "commit_message": "Update jsonrpclib-pelix & trakt", "files_name": ["ext/jsonrpclib/SimpleJSONRPCServer.py", "ext/jsonrpclib/__init__.py", "ext/jsonrpclib/config.py", "ext/jsonrpclib/history.py", "ext/jsonrpclib/jsonclass.py", "ext/jsonrpclib/jsonlib.py", "ext/jsonrpclib/jsonrpc.py", "ext/jsonrpclib/threadpool.py", "ext/jsonrpclib/utils.py", "ext/readme.md", "ext/trakt/__init__.py", "ext/trakt/calendar.py", "ext/trakt/core.py", "ext/trakt/errors.py", "ext/trakt/movies.py", "ext/trakt/people.py", "ext/trakt/sync.py", "ext/trakt/tv.py", "requirements.txt"]}, {"commit_id": "ea3b00ac8b0d4604f015d75eea89fa1eff3a27fd", "commit_date": "Wed Feb 22 11:57:33 2023 +0100", "commit_message": "Update feedparser", "files_name": ["ext/feedparser/__init__.py", "ext/feedparser/api.py", "ext/feedparser/datetimes/__init__.py", "ext/feedparser/datetimes/asctime.py", "ext/feedparser/datetimes/greek.py", "ext/feedparser/datetimes/hungarian.py", "ext/feedparser/datetimes/iso8601.py", "ext/feedparser/datetimes/korean.py", "ext/feedparser/datetimes/perforce.py", "ext/feedparser/datetimes/rfc822.py", "ext/feedparser/datetimes/w3dtf.py", "ext/feedparser/encodings.py", "ext/feedparser/exceptions.py", "ext/feedparser/html.py", "ext/feedparser/http.py", "ext/feedparser/mixin.py", "ext/feedparser/namespaces/_base.py", "ext/feedparser/namespaces/admin.py", "ext/feedparser/namespaces/cc.py", "ext/feedparser/namespaces/dc.py", "ext/feedparser/namespaces/georss.py", "ext/feedparser/namespaces/itunes.py", "ext/feedparser/namespaces/mediarss.py", "ext/feedparser/namespaces/psc.py", "ext/feedparser/parsers/loose.py", "ext/feedparser/parsers/strict.py", "ext/feedparser/sanitizer.py", "ext/feedparser/sgml.py", "ext/feedparser/urls.py", "ext/feedparser/util.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "f2d88b4dfdeac6c17a34b7c19f3093978b62711c", "commit_date": "Wed Feb 22 11:58:02 2023 +0100", "commit_message": "Update dogpile.cache", "files_name": ["ext/dogpile/__init__.py", "ext/dogpile/cache/api.py", "ext/dogpile/cache/backends/memcached.py", "ext/dogpile/cache/backends/redis.py", "ext/dogpile/cache/proxy.py", "ext/dogpile/util/compat.py", "ext/dogpile/util/readwrite_lock.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "c0ac818ac8690ebf989702417be97d33569bc33e", "commit_date": "Wed Feb 22 12:07:33 2023 +0100", "commit_message": "Update contextlib2 & requests", "files_name": ["ext/contextlib2.py", "ext/contextlib2/__init__.py", "ext/contextlib2/__init__.pyi", "ext/contextlib2/py.typed", "ext/readme.md", "ext/requests/__init__.py", "ext/requests/__version__.py", "ext/requests/_internal_utils.py", "ext/requests/adapters.py", "ext/requests/api.py", "ext/requests/auth.py", "ext/requests/certs.py", "ext/requests/compat.py", "ext/requests/cookies.py", "ext/requests/exceptions.py", "ext/requests/help.py", "ext/requests/hooks.py", "ext/requests/models.py", "ext/requests/packages.py", "ext/requests/sessions.py", "ext/requests/status_codes.py", "ext/requests/structures.py", "ext/requests/utils.py", "requirements.txt"]}, {"commit_id": "25edcd43b359e0534ad5190c0b03b772d0716b48", "commit_date": "Wed Feb 22 12:10:07 2023 +0100", "commit_message": "Update python-dateutil", "files_name": ["ext/dateutil/_version.py", "ext/dateutil/easter.py", "ext/dateutil/parser/_parser.py", "ext/dateutil/parser/isoparser.py", "ext/dateutil/rrule.py", "ext/dateutil/tz/tz.py", "ext/dateutil/utils.py", "ext/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz", "ext/dateutil/zoneinfo/rebuild.py", "ext/readme.md", "requirements.txt"]}, {"commit_id": "e81604df34a9a81098ff70f1dbb696b2a9a5da25", "commit_date": "Wed Feb 22 12:17:21 2023 +0100", "commit_message": "Update beautifulsoup4", "files_name": ["ext/_yaml/__init__.py", "ext/bs4/__init__.py", "ext/bs4/builder/__init__.py", "ext/bs4/builder/_html5lib.py", "ext/bs4/builder/_htmlparser.py", "ext/bs4/builder/_lxml.py", "ext/bs4/dammit.py", "ext/bs4/diagnose.py", "ext/bs4/element.py", "ext/bs4/formatter.py", "ext/bs4/tests/__init__.py", "ext/bs4/tests/test_builder.py", "ext/bs4/tests/test_builder_registry.py", "ext/bs4/tests/test_dammit.py", "ext/bs4/tests/test_docs.py", "ext/bs4/tests/test_element.py", "ext/bs4/tests/test_formatter.py", "ext/bs4/tests/test_html5lib.py"]}], "parents": [{"commit_id_before": "d44ae910b2e6e94db608ee74221d1ce230118651", "url_before": "https://api.github.com/repos/pymedusa/Medusa/commits/d44ae910b2e6e94db608ee74221d1ce230118651", "html_url_before": "https://github.com/pymedusa/Medusa/commit/d44ae910b2e6e94db608ee74221d1ce230118651"}], "details": [{"raw_url": "https://github.com/pymedusa/Medusa/raw/66d4be8f0872bd5ddcdc5c5a58cb014d22834a45/medusa%2Fupdater%2Fgithub_updater.py", "code": "# coding=utf-8\n\nfrom __future__ import unicode_literals\n\nimport logging\nimport os\nimport platform\nimport re\nimport subprocess\nimport sys\n\nfrom medusa import app, notifiers\nfrom medusa.logger.adapters.style import BraceAdapter\nfrom medusa.updater.update_manager import UpdateManager\n\nfrom six import text_type\n\n\nERROR_MESSAGE = ('Unable to find your git executable. Set git executable path in Advanced Settings '\n                 'OR shutdown application and delete your .git folder and run from source to enable updates.')\n\nlog = BraceAdapter(logging.getLogger(__name__))\nlog.logger.addHandler(logging.NullHandler())\n\n\nclass GitUpdateManager(UpdateManager):\n    def __init__(self):\n        super(GitUpdateManager, self).__init__()\n        self._git_path = self._find_working_git()\n        self.github_org = self.get_github_org()\n        self.github_repo = self.get_github_repo()\n        self.branch = self._find_installed_branch()\n\n        self._cur_commit_hash = None\n        self._newest_commit_hash = None\n        self._num_commits_behind = 0\n        self._num_commits_ahead = 0\n\n    def __str__(self):\n        return 'GitHub Updater'\n\n    @property\n    def current_commit_hash(self):\n        return self._cur_commit_hash\n\n    @property\n    def newest_commit_hash(self):\n        return self._newest_commit_hash\n\n    @property\n    def current_version(self):\n        self.update_commit_hash()\n        cur_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._cur_commit_hash))[0]\n        if cur_version:\n            return cur_version.lstrip('v')\n\n    @property\n    def newest_version(self):\n        self.update_newest_commit_hash()\n        new_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._newest_commit_hash))[0]\n        if new_version:\n            return new_version.lstrip('v')\n\n    @property\n    def commits_behind(self):\n        return self._num_commits_behind\n\n    @property\n    def commits_ahead(self):\n        return self._num_commits_ahead\n\n    def _find_working_git(self):\n        test_cmd = 'version'\n        main_git = app.GIT_PATH or 'git'\n\n        log.debug(u'Checking if we can use git commands: {0} {1}', main_git, test_cmd)\n        _, _, exit_status = self._run_git(main_git, test_cmd)\n\n        if exit_status == 0:\n            log.debug(u'Using: {0}', main_git)\n            return main_git\n        else:\n            log.debug(u'Not using: {0}', main_git)\n\n        # trying alternatives\n        alternative_git = []\n\n        # osx people who start sr from launchd have a broken path, so try a hail-mary attempt for them\n        if platform.system().lower() == 'darwin':\n            alternative_git.append('/usr/local/git/bin/git')\n\n        if platform.system().lower() == 'windows':\n            if main_git != main_git.lower():\n                alternative_git.append(main_git.lower())\n\n        if alternative_git:\n            log.debug(u'Trying known alternative git locations')\n\n            for cur_git in alternative_git:\n                log.debug(u'Checking if we can use git commands: {0} {1}', cur_git, test_cmd)\n                _, _, exit_status = self._run_git(cur_git, test_cmd)\n\n                if exit_status == 0:\n                    log.debug(u'Using: {0}', cur_git)\n                    return cur_git\n                else:\n                    log.debug(u'Not using: {0}', cur_git)\n\n    def _run_git(self, git_path, args):\n        output = err = exit_status = None\n\n        if not git_path:\n            git_path = self._find_working_git()\n            if git_path:\n                self._git_path = git_path\n            else:\n                # Warn user only if he has version check enabled\n                if app.VERSION_NOTIFY:\n                    log.warning(u\"No git specified, can't use git commands\")\n                    app.NEWEST_VERSION_STRING = ERROR_MESSAGE\n                exit_status = 1\n                return output, err, exit_status\n\n        if git_path != 'git' and not os.path.isfile(git_path):\n            log.warning(u\"Invalid git specified, can't use git commands\")\n            exit_status = 1\n            return output, err, exit_status\n\n        # If we have a valid git remove the git warning\n        # String will be updated as soon we check github\n        app.NEWEST_VERSION_STRING = None\n        cmd = git_path + ' ' + args\n\n        try:\n            log.debug(u'Executing {cmd} with your shell in {dir}', {'cmd': cmd, 'dir': app.PROG_DIR})\n            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                 shell=True, cwd=app.PROG_DIR)\n            output, err = p.communicate()\n            exit_status = p.returncode\n\n            # Convert bytes to string in python3\n            if isinstance(output, (bytes, bytearray)):\n                output = output.decode('utf-8')\n\n            if output:\n                output = output.strip()\n\n        except OSError:\n            log.info(u\"Command {cmd} didn't work\", {'cmd': cmd})\n            exit_status = 1\n\n        if exit_status == 0:\n            log.debug(u'{cmd} : returned successful', {'cmd': cmd})\n\n        elif exit_status == 1:\n            if output:\n                if 'stash' in output:\n                    log.warning(u\"Enable 'git reset' in settings or stash your changes in local files\")\n                else:\n                    log.warning(u'{cmd} returned : {output}', {'cmd': cmd, 'output': output})\n            else:\n                log.warning(u'{cmd} returned no data', {'cmd': cmd})\n\n        elif exit_status == 128:\n            log.warning('{cmd} returned ({status}) : {output}',\n                        {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        elif exit_status == 129:\n            if 'unknown option' in output and 'set-upstream-to' in output:\n                log.info(\"Can't set upstream to origin/{0} because you're running an old version of git.\"\n                         '\\nPlease upgrade your git installation to its latest version.', app.BRANCH)\n            else:\n                log.warning('{cmd} returned ({status}) : {output}',\n                            {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        else:\n            log.warning(u'{cmd} returned : {output}. Treat as error for now', {'cmd': cmd, 'output': output})\n            exit_status = 1\n\n        return output, err, exit_status\n\n    def update_commit_hash(self):\n        \"\"\"Attempt to set the hash of the currently installed version of the application.\n\n        Uses git to get commit version.\n        \"\"\"\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse HEAD')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.warning(u\"Output doesn't look like a hash, not using it\")\n                return False\n\n            self._cur_commit_hash = cur_commit_hash\n            app.CUR_COMMIT_HASH = cur_commit_hash\n            return True\n\n        return False\n\n    def update_newest_commit_hash(self):\n        # update remote origin url\n        self.update_remote_origin()\n\n        # Configure local branch with upstream\n        self.set_upstream_branch()\n\n        # get all new info from github\n        output, _, exit_status = self._run_git(self._git_path, 'fetch --prune {0}'.format(app.GIT_REMOTE))\n        if not exit_status == 0:\n            log.warning(u\"Unable to contact github, can't check for update\")\n            return False\n\n        # get latest commit_hash from remote\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse --verify --quiet \"@{upstream}\"')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.debug(u\"Output doesn't look like a hash, not using it\")\n                return False\n            else:\n                self._newest_commit_hash = cur_commit_hash\n                return True\n        else:\n            log.debug(u\"git didn't return newest commit hash\")\n            return False\n\n    def _find_installed_branch(self):\n        branch_info, _, exit_status = self._run_git(self._git_path, 'symbolic-ref -q HEAD')\n        if exit_status == 0 and branch_info:\n            branch = branch_info.strip().replace('refs/heads/', '', 1)\n            if branch:\n                app.BRANCH = branch\n                return branch\n        return ''\n\n    def check_for_update(self):\n        \"\"\"Use git commands to check if there is a newer version that the provided commit hash.\"\"\"\n        self.update_commit_hash()\n        self.update_newest_commit_hash()\n\n        # get number of commits behind and ahead (option --count not supported git < 1.7.2)\n        output, _, exit_status = self._run_git(self._git_path, 'rev-list --left-right \"@{upstream}\"...HEAD')\n        if exit_status == 0 and output:\n            try:\n                self._num_commits_behind = int(output.count('<'))\n                self._num_commits_ahead = int(output.count('>'))\n            except Exception:\n                log.debug(u\"git didn't return numbers for behind and ahead, not using it\")\n                return False\n\n        log.debug(u'cur_commit = {0}, newest_commit = {1}, num_commits_behind = {2}, num_commits_ahead = {3}',\n                  self._cur_commit_hash, self._newest_commit_hash, self._num_commits_behind, self._num_commits_ahead)\n\n    def need_update(self):\n        if self.branch != self._find_installed_branch():\n            log.debug(u'Branch checkout: {0}->{1}', self._find_installed_branch(), self.branch)\n            return True\n\n        try:\n            self.check_for_update()\n        except Exception as e:\n            log.warning(u\"Unable to contact github, can't check for update: {0!r}\", e)\n            return False\n\n        if self._num_commits_behind > 0 or self._num_commits_ahead > 0:\n            self._set_update_text()\n            return True\n\n        return False\n\n    def _set_update_text(self):\n        if self._num_commits_behind > 0 or self._is_hard_reset_allowed():\n            base_url = 'http://github.com/' + self.github_org + '/' + self.github_repo\n            if self._newest_commit_hash:\n                url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash\n            else:\n                url = base_url + '/commits/'\n\n            newest_text = 'There is a <a href=\"' + url + '\" onclick=\"window.open(this.href); return false;\">newer version available</a> '\n            newest_text += \" (you're \" + text_type(self._num_commits_behind) + ' commit'\n            if self._num_commits_behind > 1:\n                newest_text += 's'\n            newest_text += ' behind'\n            if self._num_commits_ahead > 0:\n                newest_text += ' and {ahead} commit{s} ahead'.format(ahead=self._num_commits_ahead,\n                                                                     s='s' if self._num_commits_ahead > 1 else '')\n            newest_text += ') &mdash; <a href=\"' + self.get_update_url() + '\">Update Now</a>'\n\n        elif self._num_commits_ahead > 0:\n            newest_text = u'Local branch is ahead of {0}. Automatic update not possible'.format(self.branch)\n            log.warning(newest_text)\n        else:\n            return\n\n        app.NEWEST_VERSION_STRING = newest_text\n\n    def can_update(self):\n        \"\"\"Return whether update can be executed.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        # Version 0.4.6 is the last version which will run on python 2.7.13.\n        if sys.version_info.major == 2:\n            return False\n\n        return self._num_commits_ahead <= 0 or self._is_hard_reset_allowed()\n\n    def update(self):\n        \"\"\"Call git pull origin <branch> in order to update the application.\n\n        Returns a bool depending on the call's success.\n        \"\"\"\n        # update remote origin url\n        self.update_remote_origin()\n\n        # remove untracked files and performs a hard reset on git branch to avoid update issues\n        if self._is_hard_reset_allowed():\n            self.reset()\n\n        # Executing git clean before updating\n        self.clean()\n\n        current_branch = self._find_installed_branch()\n        if self.branch == current_branch:\n            _, _, exit_status = self._run_git(self._git_path, 'pull -f {0} {1}'.format(app.GIT_REMOTE, self.branch))\n        else:\n            log.warning(\n                u\"Couldn't determine current branch or current branch {current}\"\n                u\" doesn't match desired branch {desired}.\\n\"\n                u'Checkout the desired branch or try again later.', {\n                    'current': current_branch,\n                    'desired': self.branch\n                })\n            return False\n\n        # Executing git clean after updating\n        self.clean()\n\n        if exit_status == 0:\n            self.update_commit_hash()\n            # Notify update successful\n            if app.NOTIFY_ON_UPDATE:\n                try:\n                    notifiers.notify_git_update(app.CUR_COMMIT_HASH or '')\n                except Exception:\n                    log.debug(u'Unable to send update notification. Continuing the update process')\n            return True\n\n        return False\n\n    @staticmethod\n    def _is_hard_reset_allowed():\n        \"\"\"Return whether git hard reset is allowed or not.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        return app.GIT_RESET and (not app.GIT_RESET_BRANCHES or\n                                  app.BRANCH in app.GIT_RESET_BRANCHES)\n\n    def clean(self):\n        \"\"\"Call git clean to remove all untracked files.\n\n        It only affects source folders and libX and extX folders,\n        to prevent deleting untracked user data not known by .gitignore\n\n        :return:\n        :rtype: int\n        \"\"\"\n        folders = (app.LIB_FOLDER, app.LIB2_FOLDER, app.LIB3_FOLDER, app.EXT_FOLDER,\n                   app.EXT2_FOLDER, app.EXT3_FOLDER, app.SRC_FOLDER, app.STATIC_FOLDER) + app.LEGACY_SRC_FOLDERS\n        _, _, exit_status = self._run_git(self._git_path, 'clean -d -f -x {0}'.format(' '.join(folders)))\n\n        return exit_status\n\n    def reset(self):\n        \"\"\"Call git reset --hard to perform a hard reset.\"\"\"\n        _, _, exit_status = self._run_git(self._git_path, 'reset --hard {0}/{1}'.format(app.GIT_REMOTE, app.BRANCH))\n        if exit_status == 0:\n            return True\n\n    def list_remote_branches(self):\n        # update remote origin url\n        self.update_remote_origin()\n        app.BRANCH = self._find_installed_branch()\n\n        branches, _, exit_status = self._run_git(self._git_path, 'ls-remote --heads {0}'.format(app.GIT_REMOTE))\n        if exit_status == 0 and branches:\n            return re.findall(r'refs/heads/(.*)', branches)\n        return []\n\n    def update_remote_origin(self):\n        self._run_git(self._git_path, 'config remote.{0}.url {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n        self._run_git(self._git_path, 'config remote.{0}.pushurl {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n\n    def set_upstream_branch(self):\n        self._run_git(self._git_path, 'branch {0} --set-upstream-to origin/{1}'.format(app.BRANCH, app.BRANCH))\n", "code_before": "# coding=utf-8\n\nfrom __future__ import unicode_literals\n\nimport logging\nimport platform\nimport re\nimport subprocess\nimport sys\n\nfrom medusa import app, notifiers\nfrom medusa.logger.adapters.style import BraceAdapter\nfrom medusa.updater.update_manager import UpdateManager\n\nfrom six import text_type\n\n\nERROR_MESSAGE = ('Unable to find your git executable. Set git executable path in Advanced Settings '\n                 'OR shutdown application and delete your .git folder and run from source to enable updates.')\n\nlog = BraceAdapter(logging.getLogger(__name__))\nlog.logger.addHandler(logging.NullHandler())\n\n\nclass GitUpdateManager(UpdateManager):\n    def __init__(self):\n        super(GitUpdateManager, self).__init__()\n        self._git_path = self._find_working_git()\n        self.github_org = self.get_github_org()\n        self.github_repo = self.get_github_repo()\n        self.branch = self._find_installed_branch()\n\n        self._cur_commit_hash = None\n        self._newest_commit_hash = None\n        self._num_commits_behind = 0\n        self._num_commits_ahead = 0\n\n    def __str__(self):\n        return 'GitHub Updater'\n\n    @property\n    def current_commit_hash(self):\n        return self._cur_commit_hash\n\n    @property\n    def newest_commit_hash(self):\n        return self._newest_commit_hash\n\n    @property\n    def current_version(self):\n        self.update_commit_hash()\n        cur_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._cur_commit_hash))[0]\n        if cur_version:\n            return cur_version.lstrip('v')\n\n    @property\n    def newest_version(self):\n        self.update_newest_commit_hash()\n        new_version = self._run_git(self._git_path, 'describe --tags --abbrev=0 {0}'.format(\n            self._newest_commit_hash))[0]\n        if new_version:\n            return new_version.lstrip('v')\n\n    @property\n    def commits_behind(self):\n        return self._num_commits_behind\n\n    @property\n    def commits_ahead(self):\n        return self._num_commits_ahead\n\n    def _find_working_git(self):\n        test_cmd = 'version'\n\n        if app.GIT_PATH:\n            main_git = '\"' + app.GIT_PATH + '\"'\n        else:\n            main_git = 'git'\n\n        log.debug(u'Checking if we can use git commands: {0} {1}', main_git, test_cmd)\n        _, _, exit_status = self._run_git(main_git, test_cmd)\n\n        if exit_status == 0:\n            log.debug(u'Using: {0}', main_git)\n            return main_git\n        else:\n            log.debug(u'Not using: {0}', main_git)\n\n        # trying alternatives\n        alternative_git = []\n\n        # osx people who start sr from launchd have a broken path, so try a hail-mary attempt for them\n        if platform.system().lower() == 'darwin':\n            alternative_git.append('/usr/local/git/bin/git')\n\n        if platform.system().lower() == 'windows':\n            if main_git != main_git.lower():\n                alternative_git.append(main_git.lower())\n\n        if alternative_git:\n            log.debug(u'Trying known alternative git locations')\n\n            for cur_git in alternative_git:\n                log.debug(u'Checking if we can use git commands: {0} {1}', cur_git, test_cmd)\n                _, _, exit_status = self._run_git(cur_git, test_cmd)\n\n                if exit_status == 0:\n                    log.debug(u'Using: {0}', cur_git)\n                    return cur_git\n                else:\n                    log.debug(u'Not using: {0}', cur_git)\n\n    def _run_git(self, git_path, args):\n        output = err = exit_status = None\n\n        if not git_path:\n            git_path = self._find_working_git()\n            if git_path:\n                self._git_path = git_path\n            else:\n                # Warn user only if he has version check enabled\n                if app.VERSION_NOTIFY:\n                    log.warning(u\"No git specified, can't use git commands\")\n                    app.NEWEST_VERSION_STRING = ERROR_MESSAGE\n                exit_status = 1\n                return output, err, exit_status\n\n        # If we have a valid git remove the git warning\n        # String will be updated as soon we check github\n        app.NEWEST_VERSION_STRING = None\n        cmd = git_path + ' ' + args\n\n        try:\n            log.debug(u'Executing {cmd} with your shell in {dir}', {'cmd': cmd, 'dir': app.PROG_DIR})\n            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                 shell=True, cwd=app.PROG_DIR)\n            output, err = p.communicate()\n            exit_status = p.returncode\n\n            # Convert bytes to string in python3\n            if isinstance(output, (bytes, bytearray)):\n                output = output.decode('utf-8')\n\n            if output:\n                output = output.strip()\n\n        except OSError:\n            log.info(u\"Command {cmd} didn't work\", {'cmd': cmd})\n            exit_status = 1\n\n        if exit_status == 0:\n            log.debug(u'{cmd} : returned successful', {'cmd': cmd})\n\n        elif exit_status == 1:\n            if output:\n                if 'stash' in output:\n                    log.warning(u\"Enable 'git reset' in settings or stash your changes in local files\")\n                else:\n                    log.warning(u'{cmd} returned : {output}', {'cmd': cmd, 'output': output})\n            else:\n                log.warning(u'{cmd} returned no data', {'cmd': cmd})\n\n        elif exit_status == 128:\n            log.warning('{cmd} returned ({status}) : {output}',\n                        {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        elif exit_status == 129:\n            if 'unknown option' in output and 'set-upstream-to' in output:\n                log.info(\"Can't set upstream to origin/{0} because you're running an old version of git.\"\n                         '\\nPlease upgrade your git installation to its latest version.', app.BRANCH)\n            else:\n                log.warning('{cmd} returned ({status}) : {output}',\n                            {'cmd': cmd, 'status': exit_status, 'output': output})\n\n        else:\n            log.warning(u'{cmd} returned : {output}. Treat as error for now', {'cmd': cmd, 'output': output})\n            exit_status = 1\n\n        return output, err, exit_status\n\n    def update_commit_hash(self):\n        \"\"\"Attempt to set the hash of the currently installed version of the application.\n\n        Uses git to get commit version.\n        \"\"\"\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse HEAD')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.warning(u\"Output doesn't look like a hash, not using it\")\n                return False\n\n            self._cur_commit_hash = cur_commit_hash\n            app.CUR_COMMIT_HASH = cur_commit_hash\n            return True\n\n        return False\n\n    def update_newest_commit_hash(self):\n        # update remote origin url\n        self.update_remote_origin()\n\n        # Configure local branch with upstream\n        self.set_upstream_branch()\n\n        # get all new info from github\n        output, _, exit_status = self._run_git(self._git_path, 'fetch --prune {0}'.format(app.GIT_REMOTE))\n        if not exit_status == 0:\n            log.warning(u\"Unable to contact github, can't check for update\")\n            return False\n\n        # get latest commit_hash from remote\n        output, _, exit_status = self._run_git(self._git_path, 'rev-parse --verify --quiet \"@{upstream}\"')\n\n        if exit_status == 0 and output:\n            cur_commit_hash = output.strip()\n            if not re.match('^[a-z0-9]+$', cur_commit_hash):\n                log.debug(u\"Output doesn't look like a hash, not using it\")\n                return False\n            else:\n                self._newest_commit_hash = cur_commit_hash\n                return True\n        else:\n            log.debug(u\"git didn't return newest commit hash\")\n            return False\n\n    def _find_installed_branch(self):\n        branch_info, _, exit_status = self._run_git(self._git_path, 'symbolic-ref -q HEAD')\n        if exit_status == 0 and branch_info:\n            branch = branch_info.strip().replace('refs/heads/', '', 1)\n            if branch:\n                app.BRANCH = branch\n                return branch\n        return ''\n\n    def check_for_update(self):\n        \"\"\"Use git commands to check if there is a newer version that the provided commit hash.\"\"\"\n        self.update_commit_hash()\n        self.update_newest_commit_hash()\n\n        # get number of commits behind and ahead (option --count not supported git < 1.7.2)\n        output, _, exit_status = self._run_git(self._git_path, 'rev-list --left-right \"@{upstream}\"...HEAD')\n        if exit_status == 0 and output:\n            try:\n                self._num_commits_behind = int(output.count('<'))\n                self._num_commits_ahead = int(output.count('>'))\n            except Exception:\n                log.debug(u\"git didn't return numbers for behind and ahead, not using it\")\n                return False\n\n        log.debug(u'cur_commit = {0}, newest_commit = {1}, num_commits_behind = {2}, num_commits_ahead = {3}',\n                  self._cur_commit_hash, self._newest_commit_hash, self._num_commits_behind, self._num_commits_ahead)\n\n    def need_update(self):\n        if self.branch != self._find_installed_branch():\n            log.debug(u'Branch checkout: {0}->{1}', self._find_installed_branch(), self.branch)\n            return True\n\n        try:\n            self.check_for_update()\n        except Exception as e:\n            log.warning(u\"Unable to contact github, can't check for update: {0!r}\", e)\n            return False\n\n        if self._num_commits_behind > 0 or self._num_commits_ahead > 0:\n            self._set_update_text()\n            return True\n\n        return False\n\n    def _set_update_text(self):\n        if self._num_commits_behind > 0 or self._is_hard_reset_allowed():\n            base_url = 'http://github.com/' + self.github_org + '/' + self.github_repo\n            if self._newest_commit_hash:\n                url = base_url + '/compare/' + self._cur_commit_hash + '...' + self._newest_commit_hash\n            else:\n                url = base_url + '/commits/'\n\n            newest_text = 'There is a <a href=\"' + url + '\" onclick=\"window.open(this.href); return false;\">newer version available</a> '\n            newest_text += \" (you're \" + text_type(self._num_commits_behind) + ' commit'\n            if self._num_commits_behind > 1:\n                newest_text += 's'\n            newest_text += ' behind'\n            if self._num_commits_ahead > 0:\n                newest_text += ' and {ahead} commit{s} ahead'.format(ahead=self._num_commits_ahead,\n                                                                     s='s' if self._num_commits_ahead > 1 else '')\n            newest_text += ') &mdash; <a href=\"' + self.get_update_url() + '\">Update Now</a>'\n\n        elif self._num_commits_ahead > 0:\n            newest_text = u'Local branch is ahead of {0}. Automatic update not possible'.format(self.branch)\n            log.warning(newest_text)\n        else:\n            return\n\n        app.NEWEST_VERSION_STRING = newest_text\n\n    def can_update(self):\n        \"\"\"Return whether update can be executed.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        # Version 0.4.6 is the last version which will run on python 2.7.13.\n        if sys.version_info.major == 2:\n            return False\n\n        return self._num_commits_ahead <= 0 or self._is_hard_reset_allowed()\n\n    def update(self):\n        \"\"\"Call git pull origin <branch> in order to update the application.\n\n        Returns a bool depending on the call's success.\n        \"\"\"\n        # update remote origin url\n        self.update_remote_origin()\n\n        # remove untracked files and performs a hard reset on git branch to avoid update issues\n        if self._is_hard_reset_allowed():\n            self.reset()\n\n        # Executing git clean before updating\n        self.clean()\n\n        current_branch = self._find_installed_branch()\n        if self.branch == current_branch:\n            _, _, exit_status = self._run_git(self._git_path, 'pull -f {0} {1}'.format(app.GIT_REMOTE, self.branch))\n        else:\n            log.warning(\n                u\"Couldn't determine current branch or current branch {current}\"\n                u\" doesn't match desired branch {desired}.\\n\"\n                u'Checkout the desired branch or try again later.', {\n                    'current': current_branch,\n                    'desired': self.branch\n                })\n            return False\n\n        # Executing git clean after updating\n        self.clean()\n\n        if exit_status == 0:\n            self.update_commit_hash()\n            # Notify update successful\n            if app.NOTIFY_ON_UPDATE:\n                try:\n                    notifiers.notify_git_update(app.CUR_COMMIT_HASH or '')\n                except Exception:\n                    log.debug(u'Unable to send update notification. Continuing the update process')\n            return True\n\n        return False\n\n    @staticmethod\n    def _is_hard_reset_allowed():\n        \"\"\"Return whether git hard reset is allowed or not.\n\n        :return:\n        :rtype: bool\n        \"\"\"\n        return app.GIT_RESET and (not app.GIT_RESET_BRANCHES or\n                                  app.BRANCH in app.GIT_RESET_BRANCHES)\n\n    def clean(self):\n        \"\"\"Call git clean to remove all untracked files.\n\n        It only affects source folders and libX and extX folders,\n        to prevent deleting untracked user data not known by .gitignore\n\n        :return:\n        :rtype: int\n        \"\"\"\n        folders = (app.LIB_FOLDER, app.LIB2_FOLDER, app.LIB3_FOLDER, app.EXT_FOLDER,\n                   app.EXT2_FOLDER, app.EXT3_FOLDER, app.SRC_FOLDER, app.STATIC_FOLDER) + app.LEGACY_SRC_FOLDERS\n        _, _, exit_status = self._run_git(self._git_path, 'clean -d -f -x {0}'.format(' '.join(folders)))\n\n        return exit_status\n\n    def reset(self):\n        \"\"\"Call git reset --hard to perform a hard reset.\"\"\"\n        _, _, exit_status = self._run_git(self._git_path, 'reset --hard {0}/{1}'.format(app.GIT_REMOTE, app.BRANCH))\n        if exit_status == 0:\n            return True\n\n    def list_remote_branches(self):\n        # update remote origin url\n        self.update_remote_origin()\n        app.BRANCH = self._find_installed_branch()\n\n        branches, _, exit_status = self._run_git(self._git_path, 'ls-remote --heads {0}'.format(app.GIT_REMOTE))\n        if exit_status == 0 and branches:\n            return re.findall(r'refs/heads/(.*)', branches)\n        return []\n\n    def update_remote_origin(self):\n        self._run_git(self._git_path, 'config remote.{0}.url {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n        self._run_git(self._git_path, 'config remote.{0}.pushurl {1}'.format(app.GIT_REMOTE, app.GIT_REMOTE_URL))\n\n    def set_upstream_branch(self):\n        self._run_git(self._git_path, 'branch {0} --set-upstream-to origin/{1}'.format(app.BRANCH, app.BRANCH))\n", "patch": "@@ -3,6 +3,7 @@\n from __future__ import unicode_literals\n \n import logging\n+import os\n import platform\n import re\n import subprocess\n@@ -72,11 +73,7 @@ def commits_ahead(self):\n \n     def _find_working_git(self):\n         test_cmd = 'version'\n-\n-        if app.GIT_PATH:\n-            main_git = '\"' + app.GIT_PATH + '\"'\n-        else:\n-            main_git = 'git'\n+        main_git = app.GIT_PATH or 'git'\n \n         log.debug(u'Checking if we can use git commands: {0} {1}', main_git, test_cmd)\n         _, _, exit_status = self._run_git(main_git, test_cmd)\n@@ -126,6 +123,11 @@ def _run_git(self, git_path, args):\n                 exit_status = 1\n                 return output, err, exit_status\n \n+        if git_path != 'git' and not os.path.isfile(git_path):\n+            log.warning(u\"Invalid git specified, can't use git commands\")\n+            exit_status = 1\n+            return output, err, exit_status\n+\n         # If we have a valid git remove the git warning\n         # String will be updated as soon we check github\n         app.NEWEST_VERSION_STRING = None", "file_path": "files/2023_3/196", "file_language": "py", "file_name": "medusa/updater/github_updater.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
