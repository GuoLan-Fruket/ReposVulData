{"index": 6906, "cve_id": "CVE-2021-43837", "cwe_id": ["CWE-94", "CWE-74"], "cve_language": "Python", "cve_description": "vault-cli is a configurable command-line interface tool (and python library) to interact with Hashicorp Vault. In versions before 3.0.0 vault-cli features the ability for rendering templated values. When a secret starts with the prefix `!template!`, vault-cli interprets the rest of the contents of the secret as a Jinja2 template. Jinja2 is a powerful templating engine and is not designed to safely render arbitrary templates. An attacker controlling a jinja2 template rendered on a machine can trigger arbitrary code, making this a Remote Code Execution (RCE) risk. If the content of the vault can be completely trusted, then this is not a problem. Otherwise, if your threat model includes cases where an attacker can manipulate a secret value read from the vault using vault-cli, then this vulnerability may impact you. In 3.0.0, the code related to interpreting vault templated secrets has been removed entirely. Users are advised to upgrade as soon as possible. For users unable to upgrade a workaround does exist. Using the environment variable `VAULT_CLI_RENDER=false` or the flag `--no-render` (placed between `vault-cli` and the subcommand, e.g. `vault-cli --no-render get-all`) or adding `render: false` to the vault-cli configuration yaml file disables rendering and removes the vulnerability. Using the python library, you can use: `vault_cli.get_client(render=False)` when creating your client to get a client that will not render templated secrets and thus operates securely.", "cvss": "9.1", "publish_date": "December 16, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "HIGH", "UI": "NONE", "S": "CHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "3ba3955887fd6b7d4d646c8b260f21cebf5db852", "commit_message": "Merge pull request #198 from peopledoc/templates", "commit_date": "2021-12-15T17:15:46Z", "project": "peopledoc/vault-cli", "url": "https://api.github.com/repos/peopledoc/vault-cli/commits/3ba3955887fd6b7d4d646c8b260f21cebf5db852", "html_url": "https://github.com/peopledoc/vault-cli/commit/3ba3955887fd6b7d4d646c8b260f21cebf5db852", "windows_before": [{"commit_id": "2abe8451983548fe4ee1c3c792df4c9cf0c0cbfa", "commit_date": "Fri Oct 15 16:01:23 2021 +0200", "commit_message": "Add a fake --render/--no-render CLI option to ease upgrading", "files_name": ["vault_cli/cli.py"]}, {"commit_id": "7ec0c041ac3ade0cee7570ae48d39b3d7e5bd14e", "commit_date": "Wed Oct 13 16:35:38 2021 +0200", "commit_message": "Remove templated secrets", "files_name": ["README.rst", "docs/howto/environment.rst", "docs/howto/systemd.rst", "docs/howto/templated_secrets.rst", "docs/howto/upgrade.rst", "docs/howto_index.rst", "tests/unit/test_cli.py", "tests/unit/test_client_base.py", "vault_cli/cli.py", "vault_cli/client.py", "vault_cli/environment.py", "vault_cli/settings.py", "vault_cli/utils.py"]}, {"commit_id": "bbb4b5fb3f4a0ad6012e5d13a9e0f72f699229ba", "commit_date": "Mon Oct 18 10:06:28 2021 +0200", "commit_message": "Merge pull request #200 from peopledoc/warning", "files_name": ["6d6fbad61913805005af1fa4bb007dcc8d0b1fe3 - Fri Oct 15 18:07:48 2021 +0200 : Use a logger warning otherwise it's not displayed properly.", "tests/unit/test_client_base.py", "vault_cli/client.py"]}, {"commit_id": "a4588261abc33f5e5d379eba74d7d4852784c83f", "commit_date": "Fri Oct 15 17:13:31 2021 +0200", "commit_message": "Merge pull request #199 from peopledoc/templates-phase-1", "files_name": ["b0281ab8288a34e4805b72a926e79530aa364ce0 - Fri Oct 15 15:28:35 2021 +0200 : Add deprecation warning for using !template!", "docs/howto/templated_secrets.rst", "tests/unit/test_client_base.py", "vault_cli/client.py"]}, {"commit_id": "1de67367b0c749fe260b8a0c3217d438963444c9", "commit_date": "Mon Aug 2 10:04:44 2021 +0200", "commit_message": "Merge pull request #197 from peopledoc/elemoine", "files_name": ["759562dc46f740a66a7cb26101fb4f56224a8f50 - Mon Aug 2 10:02:48 2021 +0200 : Add @elemoine to CODEOWNERS", ".github/CODEOWNERS"]}, {"commit_id": "c0d952cbe3d5d90489040926ad8b5a431123355c", "commit_date": "Fri Jul 30 19:23:53 2021 +0200", "commit_message": "Merge pull request #196 from peopledoc/umask-0600", "files_name": ["8c781fab317b9ef6ad2bcf7957804c8c9ff09def - Fri Jul 30 17:28:28 2021 +0200 : Default umask to restrict permissions on file", "docs/howto/permissions.rst", "tests/integration/test_integration.py", "tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "75dcabde33608e66e707f60f1a24cd41ecfcf2e7", "commit_date": "Mon Jul 5 17:23:24 2021 +0200", "commit_message": "Merge pull request #194 from peopledoc/remove-old-name", "files_name": ["29e777ae88c75c1b615ad51d85bab02133738c40 - Mon Jul 5 17:21:12 2021 +0200 : Update docs/howto/upgrade.rst", "docs/howto/upgrade.rst"]}, {"commit_id": "06fd2650bface1e601a85b6adc2e41ee5297fcbd", "commit_date": "Mon Jul 5 17:16:36 2021 +0200", "commit_message": "Update docs", "files_name": ["docs/howto/templated_secrets.rst", "docs/howto/upgrade.rst", "docs/howto/write.rst"]}, {"commit_id": "7af196ff4d3b450c995c9bfeabf4b79febd72143", "commit_date": "Mon Jul 5 17:12:19 2021 +0200", "commit_message": "Remove legacy name for cli tool", "files_name": ["setup.cfg"]}, {"commit_id": "ae87b6584280ffd4d75bdd56b6c734f7bcd9e36f", "commit_date": "Mon Jul 5 17:05:26 2021 +0200", "commit_message": "Merge pull request #186 from peopledoc/env-write-185", "files_name": ["4e075d48ebf9240284c853f56f3b0461733cd0f8 - Mon Jul 5 17:04:11 2021 +0200 : Update vault_cli/cli.py", "vault_cli/cli.py"]}, {"commit_id": "13b5d3ec4444928c4cd89aff5d5de3db28ee2696", "commit_date": "Mon Jun 28 10:57:36 2021 +0200", "commit_message": "fix lint", "files_name": ["tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "e81ee4c1e94e2bf745bf23b9c01a520109d345d5", "commit_date": "Tue Jun 15 10:27:31 2021 +0200", "commit_message": "Replace vault env --path by vault env --envvar in the doc", "files_name": ["README.rst", "docs/howto/environment.rst", "docs/howto/ssh.rst", "docs/howto/systemd.rst", "docs/howto/upgrade.rst", "docs/quickstart.rst", "tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "8ad50c8b3a288fe2fcf85fd8d5d72baca46427cb", "commit_date": "Wed Jun 2 17:49:30 2021 +0200", "commit_message": "Docs", "files_name": ["docs/howto/read.rst", "docs/howto/systemd.rst"]}, {"commit_id": "7b27b9239e853b64290140c647c3c07e02679536", "commit_date": "Wed Jun 2 17:48:27 2021 +0200", "commit_message": "Add vault --file", "files_name": ["tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "85053888f330144f9a6d522421b6db1ab8ce2354", "commit_date": "Mon Jul 5 16:18:43 2021 +0200", "commit_message": "Merge pull request #192 from peopledoc/hvac", "files_name": ["33e0770c6d3f7729e4d367a4268105c5327a1c12 - Mon Jul 5 14:47:15 2021 +0200 : Fix certificates", ".gitignore", "dev-env", "server-chain.crt", "vault.cert.yml", "vault.userpass.yml"]}, {"commit_id": "30b7466f39406fc535b7345a87df9b6e721f7e15", "commit_date": "Mon Jul 5 14:45:15 2021 +0200", "commit_message": "CI test all login methods", "files_name": [".github/workflows/ci.yml"]}, {"commit_id": "82ca50e3e5a3f706e8b16c5b62f9d2fc320426bc", "commit_date": "Fri Jul 2 15:18:12 2021 +0200", "commit_message": "Fix #191: Temporary avoid newer hvac releases for certificate issues", "files_name": ["setup.cfg"]}, {"commit_id": "3904eb178817440e2e4b125ac3e5f31fc2855595", "commit_date": "Mon Jul 5 16:06:47 2021 +0200", "commit_message": "Merge pull request #193 from peopledoc/mypy", "files_name": ["313fbb844f48a482fd4b789a20cdecc291295a70 - Mon Jul 5 14:51:15 2021 +0200 : Fix mypy", "setup.cfg"]}, {"commit_id": "77fa101b3e1558b1b6de15d09734dda35afc730f", "commit_date": "Thu Jun 3 21:05:32 2021 +0200", "commit_message": "Merge pull request #190 from peopledoc/ewjoachim-patch-1", "files_name": ["3e3a6afb0d6640f5f138e6a3f7c338061db351ec - Thu Jun 3 21:05:21 2021 +0200 : Merge pull request #189 from peopledoc/refactor-env", "d440540a340069b9de15821339211a4805a57836 - Wed Jun 2 17:48:15 2021 +0200 : Add a clean error on invalid envvar format", "tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "7745c6554895b3fda4484681c927d2d9f810b909", "commit_date": "Wed Jun 2 17:47:43 2021 +0200", "commit_message": "vault env: --path is now --envvar but --path/-p is still accepted", "files_name": ["docs/howto/environment.rst", "tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "e897ec728ba703d1f255c25ee08f4e4dac8ac0b1", "commit_date": "Wed Jun 2 17:45:25 2021 +0200", "commit_message": "Refactor the split by : and =", "files_name": ["tests/unit/test_cli.py", "vault_cli/cli.py"]}, {"commit_id": "aca870087d82f491675ea1fb2a9f669d1e8f4b2a", "commit_date": "Mon Feb 8 10:27:14 2021 +0100", "commit_message": "Use pathlib to write template", "files_name": ["vault_cli/cli.py"]}, {"commit_id": "3f40dea8c662e134f4ee95097bf2b7cf99082191", "commit_date": "Wed Jun 2 18:47:07 2021 +0200", "commit_message": "Goodbye Micka\u00ebl - Remove @mgu from codeowners", "files_name": [".github/CODEOWNERS"]}, {"commit_id": "72845f93bee876ee0d8de05b5ce247a29d7c9dbb", "commit_date": "Wed Jun 2 18:47:43 2021 +0200", "commit_message": "Merge pull request #188 from peopledoc/vault-set-all-187", "files_name": ["9e6c5ffde275df534bcc5f6602b67aea68193b83 - Sat May 29 17:56:53 2021 +0200 : Fix mypy", "setup.cfg", "vault_cli/client.py", "vault_cli/metadata.py", "vault_cli/sessions.py"]}, {"commit_id": "5b6fd7604355b5ee2853433721ff19ee88bbf51a", "commit_date": "Sat May 29 17:46:50 2021 +0200", "commit_message": "Documentation", "files_name": ["docs/howto/import_export.rst", "docs/howto/write.rst", "docs/howto_index.rst"]}, {"commit_id": "1391b149b55f447eca1802bb129a9439d6661922", "commit_date": "Sat May 29 17:33:26 2021 +0200", "commit_message": "vault-cli set-all", "files_name": ["tests/unit/test_cli.py", "tests/unit/test_client_base.py", "vault_cli/cli.py", "vault_cli/client.py"]}, {"commit_id": "a5c4d6fe9177b4ac03fbe234f2f0f31597c23245", "commit_date": "Sat May 29 17:33:05 2021 +0200", "commit_message": "Improve error displaying on secret overwriting", "files_name": ["tests/unit/test_exceptions.py", "vault_cli/cli.py", "vault_cli/client.py", "vault_cli/exceptions.py"]}, {"commit_id": "3d8871a3c0eb416a0288b53fbe7fc04ba3bc2d1a", "commit_date": "Fri Dec 18 14:30:12 2020 +0100", "commit_message": "Merge pull request #183 from peopledoc/ewjoachim-patch-1", "files_name": ["2fc6df94af53f18a5142c07639801ce349404c8f - Fri Dec 18 10:01:35 2020 +0100 : CI on both PRs and the master branch", ".github/workflows/ci.yml"]}, {"commit_id": "1d79301d6edc5b44f6067bc4168554765d0f2810", "commit_date": "Thu Dec 17 21:04:50 2020 +0100", "commit_message": "Merge pull request #181 from soualid/feature/cp", "files_name": ["d99c8638bc59253ac7afe0715a3f115e1b19e734 - Tue Dec 15 14:15:34 2020 +0100 : implemented a cp function", "docs/howto/organize.rst", "tests/unit/test_cli.py", "tests/unit/test_client_base.py", "vault_cli/cli.py", "vault_cli/client.py"]}, {"commit_id": "c7cc5487423bb41386b8027371ee6f36c94c1890", "commit_date": "Thu Dec 17 09:49:23 2020 +0100", "commit_message": "Merge pull request #182 from peopledoc/fix-ci-for-forks", "files_name": ["14a8fff01c9c9423341c8ef71b121d3dfd157771 - Wed Dec 16 18:58:20 2020 +0100 : Make CI run on PRs based on forks", ".github/workflows/ci.yml"]}, {"commit_id": "7764068bf5cca4ece829c22402f8bfbb97721670", "commit_date": "Fri Nov 6 14:11:41 2020 +0100", "commit_message": "Merge pull request #180 from peopledoc/fix-release", "files_name": ["e5995b39af5e9835063a9dc9cbac8760352ed291 - Fri Nov 6 11:29:38 2020 +0100 : Fix automated release", ".github/workflows/deploy.yml", "pyproject.toml", "setup.cfg", "tests/unit/test_metadata.py"]}, {"commit_id": "f838bb1eda51f1062c646f9fdbc7ce9a99e9e646", "commit_date": "Fri Nov 6 11:15:34 2020 +0100", "commit_message": "Merge pull request #178 from peopledoc/crash-176", "files_name": ["86c12ca9911717fd513cc8a1562d587f8f6b959d - Wed Nov 4 17:13:08 2020 +0100 : Add missing test", "tests/unit/test_cli.py"]}, {"commit_id": "e578833eb68001daf34062e423e56b56bf08f000", "commit_date": "Wed Nov 4 14:33:52 2020 +0100", "commit_message": "black & mypy", "files_name": ["vault_cli/cli.py", "vault_cli/client.py", "vault_cli/environment.py", "vault_cli/exceptions.py", "vault_cli/utils.py"]}, {"commit_id": "6d8167b71766e3b9554447edcd1363d4762e77a0", "commit_date": "Mon Nov 2 16:35:40 2020 +0100", "commit_message": "Doc", "files_name": ["docs/howto/environment.rst"]}, {"commit_id": "c6fa8a026e735b5934c50b0e25268a6187570d1a", "commit_date": "Mon Nov 2 16:23:59 2020 +0100", "commit_message": "Reword exception", "files_name": ["vault_cli/exceptions.py"]}, {"commit_id": "648612aeecf57ace761af96da075050f80a12be5", "commit_date": "Thu Oct 22 14:36:01 2020 +0200", "commit_message": "Fixes client & cli inconsistency regarding error reporting", "files_name": ["tests/unit/test_cli.py", "tests/unit/test_client_base.py", "tests/unit/test_client_hvac.py", "tests/unit/test_exceptions.py", "vault_cli/cli.py", "vault_cli/client.py", "vault_cli/exceptions.py", "vault_cli/utils.py"]}, {"commit_id": "0969c57bff4c5edc7452254131ac04fae13fb6d2", "commit_date": "Mon Nov 2 13:16:38 2020 +0100", "commit_message": "Caching now applies to the whole vault client", "files_name": ["vault_cli/client.py"]}, {"commit_id": "a88cc9e4e31fd206dad1d0893cfd63687169c128", "commit_date": "Thu Oct 22 11:07:32 2020 +0200", "commit_message": "Add env --force to ensure program is always launched when the vault fails", "files_name": []}], "windows_after": [{"commit_id": "220989a336e999ba770761fcdc4e6d829d644230", "commit_date": "Thu Dec 16 12:11:23 2021 +0100", "commit_message": "Merge pull request #202 from peopledoc/sandbox", "files_name": ["63a5bb41227cdfcebba5d7382b0d8181ea1340bd - Thu Jan 6 09:21:04 2022 +0700 : Fix docker run command, -p instead of --port", "docs/quickstart.rst"]}, {"commit_id": "130895ccf2af68a94f06149dd99c4c5c4405f317", "commit_date": "Thu Jan 6 10:06:31 2022 +0100", "commit_message": "Merge pull request #203 from irvansemestanya/patch-1", "files_name": ["2958500044bb1cc0ff8d2ad0a0df9d94b96b273e - Mon Jan 17 18:26:37 2022 +0100 : Update CODEOWNERS", ".github/CODEOWNERS"]}, {"commit_id": "9a38892d7a741d10e413112fa2c3b8942f52f0d4", "commit_date": "Tue Jan 18 15:30:12 2022 +0100", "commit_message": "Merge pull request #204 from peopledoc/codeowners", "files_name": ["d72fc1493b10abd64933f1d33c110c8cbdddbade - Thu Jan 27 09:38:30 2022 +0100 : Fix mypy", "vault_cli/client.py"]}, {"commit_id": "f675c3482861dde1fae071dbd0f183493e3a586d", "commit_date": "Thu Jan 27 09:39:56 2022 +0100", "commit_message": "Merge pull request #207 from peopledoc/fix-mypy", "files_name": ["57e996c85a6632d4330b2ca769f31d13310b3db8 - Thu Jan 20 12:25:52 2022 +0100 : Switching author email to community", "setup.cfg"]}, {"commit_id": "ec1eae3c726566a6f95408ff3144b3d6c8eb6e09", "commit_date": "Thu Jan 20 12:26:55 2022 +0100", "commit_message": "Update test_metadata.py", "files_name": ["tests/unit/test_metadata.py"]}, {"commit_id": "6bea39166eaf9226b487a80fb3be7dc7ba045db6", "commit_date": "Mon Jan 24 14:33:28 2022 +0100", "commit_message": "Publish workflow should just run on tag push", "files_name": [".github/workflows/deploy.yml"]}, {"commit_id": "a34c9a1ac3b568c0379b9d4dfaaa4fa3255d3f7a", "commit_date": "Thu Jan 27 09:49:46 2022 +0100", "commit_message": "Merge pull request #205 from peopledoc/community", "files_name": ["0142476bcfda52876951f49b0990ac1d85377d3a - Thu Jan 27 10:16:35 2022 +0100 : Merge pull request #206 from peopledoc/publish-once"]}], "parents": [{"commit_id_before": "fbde0c39de13d0b825fdae8024fbb9d8219cb4af", "url_before": "https://api.github.com/repos/peopledoc/vault-cli/commits/fbde0c39de13d0b825fdae8024fbb9d8219cb4af", "html_url_before": "https://github.com/peopledoc/vault-cli/commit/fbde0c39de13d0b825fdae8024fbb9d8219cb4af"}, {"commit_id_before": "2abe8451983548fe4ee1c3c792df4c9cf0c0cbfa", "url_before": "https://api.github.com/repos/peopledoc/vault-cli/commits/2abe8451983548fe4ee1c3c792df4c9cf0c0cbfa", "html_url_before": "https://github.com/peopledoc/vault-cli/commit/2abe8451983548fe4ee1c3c792df4c9cf0c0cbfa"}], "details": [{"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/README.rst", "code": "``vault-cli``: 12-factor oriented command line tool for Hashicorp Vault\n=======================================================================\n\n.. image:: https://badge.fury.io/py/vault-cli.svg\n    :target: https://pypi.org/pypi/vault-cli\n    :alt: Deployed to PyPI\n\n.. image:: https://readthedocs.org/projects/vault-cli/badge/?version=latest\n    :target: http://vault-cli.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\n.. image:: https://github.com/peopledoc/vault-cli/workflows/CI/badge.svg\n    :target: https://github.com/peopledoc/vault-cli/actions?query=workflow%3ACI\n    :alt: Continuous Integration Status\n\n.. image:: https://codecov.io/gh/peopledoc/vault-cli/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/peopledoc/vault-cli\n    :alt: Coverage Status\n\n.. image:: https://img.shields.io/badge/License-Apache-green.svg\n    :target: https://github.com/peopledoc/vault-cli/blob/master/LICENSE\n    :alt: Apache License\n\n.. image:: https://img.shields.io/badge/Contributor%20Covenant-v1.4%20adopted-ff69b4.svg\n    :target: https://github.com/peopledoc/vault-cli/blob/master/CODE_OF_CONDUCT.md\n    :alt: Contributor Covenant\n\n``vault-cli`` is a Python 3.6+ tool that offers simple interactions to manipulate\nsecrets from `Hashicorp Vault`_. With ``vault-cli``, your secrets can be kept secret,\nwhile following `12-factor`__ principles.\n\n.. __: https://12factor.net/\n.. _`Hashicorp Vault`: https://www.vaultproject.io/\n\nSome features\n-------------\n\n- Configure once, use everywhere thanks to cascading (local, user, global) YAML\n  configuration file\n- Read, browse, write, move, delete secrets easily\n- Read multiple secrets at once, as YAML\n- Launch processes with your secrets as environment variables\n- Launch processes with ``ssh-agent`` configured from your vault\n- Write templated files with secrets inside\n\n``vault-cli`` tries to make accessing secrets both secure and painless.\n\nShowcase\n--------\n\nHere are a few things you might do with ``vault-cli``:\n\n.. code-block:: console\n\n    $ # Install:\n    $ pip install vault-cli\n\n    $ # Write a secret:\n    $ vault-cli set mysecret mykey --prompt\n    Please enter a value for key `mykey` of `mysecret`: *******\n\n    $ # Read a secret:\n    $ vault-cli get mysecret mykey\n    ohsosecret\n\n    $ # Load a secret into the environment variables:\n    $ vault-cli env --envvar mysecret -- env | grep MYSECRET\n    MYSECRET_MYKEY=ohsosecret\n\n    $ # Load an ssh key into your ssh-agent:\n    $ vault-cli ssh --key ssh_private_key -- ssh -T git@github.com\n    Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n\nState\n-----\n\nThe package is young but supported and alive. We're mindful of deprecations through\nsemantic versionning and accepting bug reports and feature requests.\n\n.. Below this line is content specific to the README that will not appear in the doc.\n.. end-of-index-doc\n\nWhere to go from here\n---------------------\n\nThe complete docs_ is probably the best place to learn about the project.\n\nIf you encounter a bug, or want to get in touch, you're always welcome to open a\nticket_.\n\n.. _docs: http://vault-cli.readthedocs.io/en/latest\n.. _ticket: https://github.com/peopledoc/vault-cli/issues/new\n", "code_before": "``vault-cli``: 12-factor oriented command line tool for Hashicorp Vault\n=======================================================================\n\n.. image:: https://badge.fury.io/py/vault-cli.svg\n    :target: https://pypi.org/pypi/vault-cli\n    :alt: Deployed to PyPI\n\n.. image:: https://readthedocs.org/projects/vault-cli/badge/?version=latest\n    :target: http://vault-cli.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\n.. image:: https://github.com/peopledoc/vault-cli/workflows/CI/badge.svg\n    :target: https://github.com/peopledoc/vault-cli/actions?query=workflow%3ACI\n    :alt: Continuous Integration Status\n\n.. image:: https://codecov.io/gh/peopledoc/vault-cli/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/peopledoc/vault-cli\n    :alt: Coverage Status\n\n.. image:: https://img.shields.io/badge/License-Apache-green.svg\n    :target: https://github.com/peopledoc/vault-cli/blob/master/LICENSE\n    :alt: Apache License\n\n.. image:: https://img.shields.io/badge/Contributor%20Covenant-v1.4%20adopted-ff69b4.svg\n    :target: https://github.com/peopledoc/vault-cli/blob/master/CODE_OF_CONDUCT.md\n    :alt: Contributor Covenant\n\n``vault-cli`` is a Python 3.6+ tool that offers simple interactions to manipulate\nsecrets from `Hashicorp Vault`_. With ``vault-cli``, your secrets can be kept secret,\nwhile following `12-factor`__ principles.\n\n.. __: https://12factor.net/\n.. _`Hashicorp Vault`: https://www.vaultproject.io/\n\nSome features\n-------------\n\n- Configure once, use everywhere thanks to cascading (local, user, global) YAML\n  configuration file\n- Read, browse, write, move, delete secrets easily\n- Read multiple secrets at once, as YAML\n- Launch processes with your secrets as environment variables\n- Launch processes with ``ssh-agent`` configured from your vault\n- Write templated files with secrets inside\n\n``vault-cli`` tries to make accessing secrets both secure and painless.\n\nShowcase\n--------\n\nHere are a few things you might do with ``vault-cli``:\n\n.. code-block:: console\n\n    $ # Install:\n    $ pip install vault-cli\n\n    $ # Write a secret:\n    $ vault-cli set mysecret mykey --prompt\n    Please enter a value for key `mykey` of `mysecret`: *******\n\n    $ # Read a secret:\n    $ vault-cli get mysecret mykey\n    ohsosecret\n\n    $ # Load a secret into the environment variables:\n    $ vault-cli env --envvar mysecret -- env | grep MYSECRET\n    MYSECRET_MYKEY=ohsosecret\n\n    $ # Load an ssh key into your ssh-agent:\n    $ vault-cli ssh --key ssh_private_key -- ssh -T git@github.com\n    Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n\nState\n-----\n\nThe package is young but supported and alive. We're mindful of deprecations through\nsemantic versionning and accepting bug reports and feature requests.\n\n.. Below this line is content specific to the README that will not appear in the doc.\n.. end-of-index-doc\n\nWhere to go from here\n---------------------\n\nThe complete docs_ is probably the best place to learn about the project.\n\nIf you encounter a bug, or want to get in touch, you're always welcome to open a\nticket_.\n\n.. _docs: http://vault-cli.readthedocs.io/en/latest\n.. _ticket: https://github.com/peopledoc/vault-cli/issues/new\n", "patch": "@@ -42,7 +42,6 @@ Some features\n - Launch processes with your secrets as environment variables\n - Launch processes with ``ssh-agent`` configured from your vault\n - Write templated files with secrets inside\n-- Combine multiple secrets into a single one (e.g. a DSN string from components)\n \n ``vault-cli`` tries to make accessing secrets both secure and painless.\n ", "file_path": "files/2021_12/193", "file_language": "rst", "file_name": "README.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/docs%2Fhowto%2Fenvironment.rst", "code": ".. _vault-env:\n\nLaunch a process with your secrets as environment variables\n===========================================================\n\nSee :ref:`env-vars` for reasons why you would want to pass configuration containing\nsecrets as environment variables.\n\n``vault-cli`` can read secrets from the vault, turn them into environment variables and\nlaunch the process of your choice with those environment variables. This is how it\nworks:\n\n.. code:: console\n\n    $ # Setting up a secret:\n    $ vault-cli set test/my_secret value=qwerty\n    Done\n\n    $ vault-cli env --envvar test/my_secret -- bash -c 'echo $MY_SECRET_VALUE'\n    qwerty\n\nEnvironment variable naming\n---------------------------\n\nA path option looks like this:\n\n.. code:: console\n\n    $ vault-cli env --envvar [path/]{root}[:key][=prefix] [--envvar ...] -- {command...}\n\n- The optional ``path/`` allows you to indicate the location of the secret(s) you want\n  to expose. If the root begins with a `/`, the ``base-path`` option will be ignored\n  (see :ref:`base-path`). This part of the path will not contribute to the environment\n  variable name.\n- The mandatory ``root`` element is either the name of a single secret object we want to\n  expose, or the root path of a \"secret directory\" containing one or more secrets we\n  want to expose recursively. The name of the environment variable starts with ``root``.\n- If ``root`` is a path to multiple secret objects, then the relative path between\n  ``root`` and each secret object will be added to the environment variable name\n- For each secret object, each key of the object will become an environment variable.\n  the key is added to the environment variable name.\n- If the flag ``--omit-single-key`` (or the environment variable\n  ``VAULT_CLI_ENV_OMIT_SINGLE_KEY``) is passed, then for each secret object, if it only\n  has one key, the name of the key will not contribute to the environment variable name.\n- You can limit a secret object to expose a single key by specifying ``:key``. In this\n  case, the environment variable name will just be the key.\n- If a ``=prefix`` is provided, it replaces the ``root`` or ``:key`` part.\n- Lastly, paths such as ``--envvar \"\"``, ``--envvar .`` or ``--envvar =prefix`` are\n  valid to express \"all the secrets under``base-path``\", although doing this can create\n  a risk of exposing more secrets than intended. A sub-path is recommended in that case.\n\nAll parts of the secret environment variable name are uppercased, special characters\n``/``, ``-`` and  `` `` (space) are changed to ``_``. If an environment variable still\ncontains characters that are not alphanumerical or ``_`` after this transformation, a\nwarning is raised, and this environment variable is skipped altogether.\n\nExample\n-------\n\nLet's consider the vault contains only the following secret:\n\n.. code:: console\n\n    $ # Setting up a secret:\n    $ vault-cli set a/b c=mysecret\n    Done\n\nThis table maps input to output. Note that there will always be a single environment\nvariable and its value will always be ``mysecret``.\n\n+---------------+-----------------------+---------------------------+\n| ``--envvar``  | ``--omit-single-key`` | environment variable name |\n+---------------+-----------------------+---------------------------+\n| ``a``         | False                 | ``A_B_C``                 |\n+---------------+-----------------------+---------------------------+\n| ``a``         | True                  | ``A_B``                   |\n+---------------+-----------------------+---------------------------+\n| ``a=D``       | False                 | ``D_B_C``                 |\n+---------------+-----------------------+---------------------------+\n| ``a=D``       | True                  | ``D_B``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b``       | False                 | ``B_C``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b``       | True                  | ``B``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b=D``     | False                 | ``D_C``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b=D``     | True                  | ``D``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b:c``     | True or False         | ``C``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b:c=D``   | True or False         | ``D``                     |\n+---------------+-----------------------+---------------------------+\n\nRecommended setup\n-----------------\n\nWhat we recommend as the ideal setup is the following:\n\n- Application uses a prefix for all its environment variables (say ``MYAPP``)\n- All the secrets of the application are put under a common path named like the prefix\n  (say ``myapp``)\n- Each secret is named like its corresponding environment variable (for\n  ``MYAPP_GITHUB_TOKEN`` you'll set ``myapp/github_token value=...``)\n- Each secret object usually holds a single key inside, whose value is a string, and\n  ``--omit-single-key`` is used\n- Groups of related configuration parameters are in the same secret\n  object (say you now have ``MYAPP_GITHUB_TOKEN`` and ``MYAPP_GITHUB_URL``, you'll set\n  ``myapp/github token=... url=...``)\n\nYour call would look like:\n\n.. code:: console\n\n    $ vault-cli env --omit-single-key --envvar myapp -- myapp\n\nIgnoring errors\n---------------\n\nBy default, ``vault-cli`` will not launch you program if an error happens during secrets\ncollection. You can pass ``--force`` to ensure that your program will be launched,\neven if it will be missing some secrets.\n\n.. code:: console\n\n    $ vault-cli env --envvar myapp --force -- myapp\n", "code_before": ".. _vault-env:\n\nLaunch a process with your secrets as environment variables\n===========================================================\n\nSee :ref:`env-vars` for reasons why you would want to pass configuration containing\nsecrets as environment variables.\n\n``vault-cli`` can read secrets from the vault, turn them into environment variables and\nlaunch the process of your choice with those environment variables. This is how it\nworks:\n\n.. code:: console\n\n    $ # Setting up a secret:\n    $ vault-cli set test/my_secret value=qwerty\n    Done\n\n    $ vault-cli env --envvar test/my_secret -- bash -c 'echo $MY_SECRET_VALUE'\n    qwerty\n\nEnvironment variable naming\n---------------------------\n\nA path option looks like this:\n\n.. code:: console\n\n    $ vault-cli env --envvar [path/]{root}[:key][=prefix] [--envvar ...] -- {command...}\n\n- The optional ``path/`` allows you to indicate the location of the secret(s) you want\n  to expose. If the root begins with a `/`, the ``base-path`` option will be ignored\n  (see :ref:`base-path`). This part of the path will not contribute to the environment\n  variable name.\n- The mandatory ``root`` element is either the name of a single secret object we want to\n  expose, or the root path of a \"secret directory\" containing one or more secrets we\n  want to expose recursively. The name of the environment variable starts with ``root``.\n- If ``root`` is a path to multiple secret objects, then the relative path between\n  ``root`` and each secret object will be added to the environment variable name\n- For each secret object, each key of the object will become an environment variable.\n  the key is added to the environment variable name.\n- If the flag ``--omit-single-key`` (or the environment variable\n  ``VAULT_CLI_ENV_OMIT_SINGLE_KEY``) is passed, then for each secret object, if it only\n  has one key, the name of the key will not contribute to the environment variable name.\n- You can limit a secret object to expose a single key by specifying ``:key``. In this\n  case, the environment variable name will just be the key.\n- If a ``=prefix`` is provided, it replaces the ``root`` or ``:key`` part.\n- Lastly, paths such as ``--envvar \"\"``, ``--envvar .`` or ``--envvar =prefix`` are\n  valid to express \"all the secrets under``base-path``\", although doing this can create\n  a risk of exposing more secrets than intended. A sub-path is recommended in that case.\n\nAll parts of the secret environment variable name are uppercased, special characters\n``/``, ``-`` and  `` `` (space) are changed to ``_``. If an environment variable still\ncontains characters that are not alphanumerical or ``_`` after this transformation, a\nwarning is raised, and this environment variable is skipped altogether.\n\nExample\n-------\n\nLet's consider the vault contains only the following secret:\n\n.. code:: console\n\n    $ # Setting up a secret:\n    $ vault-cli set a/b c=mysecret\n    Done\n\nThis table maps input to output. Note that there will always be a single environment\nvariable and its value will always be ``mysecret``.\n\n+---------------+-----------------------+---------------------------+\n| ``--envvar``  | ``--omit-single-key`` | environment variable name |\n+---------------+-----------------------+---------------------------+\n| ``a``         | False                 | ``A_B_C``                 |\n+---------------+-----------------------+---------------------------+\n| ``a``         | True                  | ``A_B``                   |\n+---------------+-----------------------+---------------------------+\n| ``a=D``       | False                 | ``D_B_C``                 |\n+---------------+-----------------------+---------------------------+\n| ``a=D``       | True                  | ``D_B``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b``       | False                 | ``B_C``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b``       | True                  | ``B``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b=D``     | False                 | ``D_C``                   |\n+---------------+-----------------------+---------------------------+\n| ``a/b=D``     | True                  | ``D``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b:c``     | True or False         | ``C``                     |\n+---------------+-----------------------+---------------------------+\n| ``a/b:c=D``   | True or False         | ``D``                     |\n+---------------+-----------------------+---------------------------+\n\nRecommended setup\n-----------------\n\nWhat we recommend as the ideal setup is the following:\n\n- Application uses a prefix for all its environment variables (say ``MYAPP``)\n- All the secrets of the application are put under a common path named like the prefix\n  (say ``myapp``)\n- Each secret is named like its corresponding environment variable (for\n  ``MYAPP_GITHUB_TOKEN`` you'll set ``myapp/github_token value=...``)\n- Each secret object usually holds a single key inside, whose value is a string, and\n  ``--omit-single-key`` is used\n- Groups of related configuration parameters are in the same secret\n  object (say you now have ``MYAPP_GITHUB_TOKEN`` and ``MYAPP_GITHUB_URL``, you'll set\n  ``myapp/github token=... url=...``)\n\nYour call would look like:\n\n.. code:: console\n\n    $ vault-cli env --omit-single-key --envvar myapp -- myapp\n\nIgnoring errors\n---------------\n\nBy default, ``vault-cli`` will not launch you program if an error happens during secrets\ncollection. You can pass ``--force`` to ensure that your program will be launched,\neven if it will be missing some secrets.\n\n.. code:: console\n\n    $ vault-cli env --envvar myapp --force -- myapp\n", "patch": "@@ -124,8 +124,3 @@ even if it will be missing some secrets.\n .. code:: console\n \n     $ vault-cli env --envvar myapp --force -- myapp\n-\n-.. warning::\n-\n-    Even if just a single key for a secret produces an error (e.g. a template rendering\n-    error), the whole secret will be missing.", "file_path": "files/2021_12/194", "file_language": "rst", "file_name": "docs/howto/environment.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/docs%2Fhowto%2Fsystemd.rst", "code": ".. _SystemD:\n\nIntegrate with SystemD\n======================\n\nGoals\n-----\n\nOne of the aims of having a vault is to protect your secrets and monitor\naccess. This can be defeated if you copy the secrets from the vault in a\nlocal file on the disk (especially if you don\u2019t precisely control who\ncan access your file).\n\nAdditionally one of the popular methods of configuring application in\nthe cloud-era is through environment variables.\n\nVault-cli aims at helping you launch your application with the secrets\nit needs without writing them on disk. This page lists a few scenarios\nthat may be useful.\n\nLet\u2019s assume the value you need to pass is the value you get with:\n\n.. code:: console\n\n   $ vault-cli get mysecret value\n   ohsosecret\n\nPassing secrets through environment\n-----------------------------------\n\nThe first thing you need to figure out is if the process you\u2019re trying\nto integrate supports configuration through environment variables.\n\n-  This may be something they tell upfront in their documentation.\n-  This may be something that can be achieved through specific\n   configuration tools. For example, tools that let you write\n   configuration in Python files (Sentry_) or in dedicated languages like\n   RainerScript (rsyslog_).\n-  This maybe something that is not well documented but that still\n   exists. Official docker images for the application may be using those\n   variables, like for Datadog_.\n-  (And in many cases, this is just not possible)\n\n.. _Sentry: https://docs.sentry.io/server/config/\n.. _rsyslog: https://www.rsyslog.com/doc/v8-stable/rainerscript/index.html\n.. _Datadog: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables\n\nAssuming you have identified the proper enviroment variable, we will\nlaunch the program through ``vault-cli env``. Let\u2019s launch it as a one-off:\n\n.. code:: console\n\n   $ vault-cli env --envvar mysecret:value -- myprogram\n\nThis will make a variable named ``VALUE`` available to ``myprogram``.\nSee the :ref:`vault-cli env <vault-env>` dedicated page for more details on how you can\nfine-tune the environment variable names, recursively load secrets as environment\nvariables etc.\n\nNow, let\u2019s integrate this with systemd. First, look at the existing\nExecStart command:\n\n.. code:: console\n\n   $ systemctl cat myprogram.service\n   [Service]\n   ...\n   ExecStart=myprogram --options\n   ...\n\nWe\u2019ll create an override file that will change ExecStart to wrap it in\n``vault-cli``:\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   ExecStart=\n   ExecStart=vault-cli env --envvar mysecret:value=MYVAR -- myprogram --options\n\nThe empty ``ExecStart=`` tells SystemD to ignore the previous command to\nlaunch and only launch the following one.\n\nSave and quit the file. Load you new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\nWriting secrets to files on the filesystem before start\n-------------------------------------------------------\n\nIn some cases, you will need to have a file in the filesystem that\ncontains directly the secret. This is often the case with private keys.\n\nOur strategy will be to mount a `RAM drive`__ when our process\nstart, and have our drive be accessible only for the current process.\nThe drive will disappear when the process terminates, and nothing will\nbe written on disk.\n\n.. __: https://en.wikipedia.org/wiki/RAM_drive\n\nIn this case, we\u2019ll also create a service override file. We'll add a wrapper\narount our program like before.\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   TemporaryFileSystem=/private\n   ExecStart=vault-cli env --file mysecret:key=/private/path/to/secret/file -- myprogram --options\n\nSave and quit the file. Load your new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\nYou will need to configure ``myprogram`` to look for your\nsecret file at ``/private/path/to/secret/file``.\n\nIf you need several files, you can add more ``--file`` flags, as\nmany times as needed.\n\n.. note::\n\n    If you want to use ``ssh`` within your program, and it supports reading the key from\n    ``ssh-agent``, rather than writing the private key to the disk, you may want to have\n    a look at the dedicated :ref:`ssh` feature.\n\nBake secrets into a complex configuration file\n----------------------------------------------\n\n.. warning::\n\n   It's been reported__ that this approach doesn't work as intended. It's left\n   for inspiration, but as of today, ``ExecStartPre`` cannot write to the\n   private filesystem created by ``TemporaryFileSystem`` in  way that ``ExecStart``\n   can later read. Please refer to the ticket for workarounds.\n\n   .. __: https://github.com/peopledoc/vault-cli/issues/185\n\nIn some cases, the program you want to launch doesn\u2019t accept\nconfiguration through environment but only through configuration files.\nYou could be tempted to use the method above, but the configuration file\nmixes secrets and a lot of other information that should not be stored\nin the vault. In this case, you need a way to write your configuration\nfile without secrets on disk and, at the last moment, to bake the\nsecrets into the file. To do that we\u2019ll use ``vault-cli template``.\n\nSee the dedicated :ref:`template` documentation for detailed use of ``vault-cli\ntemplate``.\n\nThe integration strategy will depend of several factors:\n\n- Does``myprogram`` expect to read its configuration file at a specific location?\n- Does it accept an arbitrary configuration path?\n- Does the folder containing the configuration contain other\n  files or just that configuration file?\n\nWe will be using a ``TemporaryFileSystem`` like above, but this option\ncan only be used to make a folder, not a single file. If the\nconfiguration can be read anywhere or if the whole folder can be\noverridden, then it\u2019s the easier path. Otherwise, you may want to create\na symbolic link in place of your configuration file, that will be pointing to\nyour temporary file system.\n\nLet\u2019s assume that ``myprogram`` will read its configuration at\n``/private/myprogram.conf``, through customization of the configuration file path or\nthrough a symbolic link in the standard configuration file location.\n\nThe systemd configuration will be close to our previous case:\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   TemporaryFileSystem=/private\n   ExecStartPre=vault-cli template --input=/etc/myprogram/myprogram.conf.j2 --output=/private/myprogram.conf\n\nSave and quit the file. Load you new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\n``vault_cli`` as a python lib\n-----------------------------\n\nFinally, if the program is made with Python and you control it, another solution can be\nto use ``vault_cli`` on the Python side, and load your secrets when your process starts.\nThis does not follow :ref:`12-factor` methodologies, and it means your program will be\nstrongly coupled with the vault, which will make development more complicated.\n\nSee :ref:`library`.\n", "code_before": ".. _SystemD:\n\nIntegrate with SystemD\n======================\n\nGoals\n-----\n\nOne of the aims of having a vault is to protect your secrets and monitor\naccess. This can be defeated if you copy the secrets from the vault in a\nlocal file on the disk (especially if you don\u2019t precisely control who\ncan access your file).\n\nAdditionally one of the popular methods of configuring application in\nthe cloud-era is through environment variables.\n\nVault-cli aims at helping you launch your application with the secrets\nit needs without writing them on disk. This page lists a few scenarios\nthat may be useful.\n\nLet\u2019s assume the value you need to pass is the value you get with:\n\n.. code:: console\n\n   $ vault-cli get mysecret value\n   ohsosecret\n\nPassing secrets through environment\n-----------------------------------\n\nThe first thing you need to figure out is if the process you\u2019re trying\nto integrate supports configuration through environment variables.\n\n-  This may be something they tell upfront in their documentation.\n-  This may be something that can be achieved through specific\n   configuration tools. For example, tools that let you write\n   configuration in Python files (Sentry_) or in dedicated languages like\n   RainerScript (rsyslog_).\n-  This maybe something that is not well documented but that still\n   exists. Official docker images for the application may be using those\n   variables, like for Datadog_.\n-  (And in many cases, this is just not possible)\n\n.. _Sentry: https://docs.sentry.io/server/config/\n.. _rsyslog: https://www.rsyslog.com/doc/v8-stable/rainerscript/index.html\n.. _Datadog: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables\n\nAssuming you have identified the proper enviroment variable, we will\nlaunch the program through ``vault-cli env``. Let\u2019s launch it as a one-off:\n\n.. code:: console\n\n   $ vault-cli env --envvar mysecret:value -- myprogram\n\nThis will make a variable named ``VALUE`` available to ``myprogram``.\nSee the :ref:`vault-cli env <vault-env>` dedicated page for more details on how you can\nfine-tune the environment variable names, recursively load secrets as environment\nvariables etc.\n\nNow, let\u2019s integrate this with systemd. First, look at the existing\nExecStart command:\n\n.. code:: console\n\n   $ systemctl cat myprogram.service\n   [Service]\n   ...\n   ExecStart=myprogram --options\n   ...\n\nWe\u2019ll create an override file that will change ExecStart to wrap it in\n``vault-cli``:\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   ExecStart=\n   ExecStart=vault-cli env --envvar mysecret:value=MYVAR -- myprogram --options\n\nThe empty ``ExecStart=`` tells SystemD to ignore the previous command to\nlaunch and only launch the following one.\n\nSave and quit the file. Load you new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\nWriting secrets to files on the filesystem before start\n-------------------------------------------------------\n\nIn some cases, you will need to have a file in the filesystem that\ncontains directly the secret. This is often the case with private keys.\n\nOur strategy will be to mount a `RAM drive`__ when our process\nstart, and have our drive be accessible only for the current process.\nThe drive will disappear when the process terminates, and nothing will\nbe written on disk.\n\n.. __: https://en.wikipedia.org/wiki/RAM_drive\n\nIn this case, we\u2019ll also create a service override file. We'll add a wrapper\narount our program like before.\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   TemporaryFileSystem=/private\n   ExecStart=vault-cli env --file mysecret:key=/private/path/to/secret/file -- myprogram --options\n\nSave and quit the file. Load your new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\nYou will need to configure ``myprogram`` to look for your\nsecret file at ``/private/path/to/secret/file``.\n\nIf you need several files, you can add more ``--file`` flags, as\nmany times as needed.\n\n.. note::\n\n    If you want to use ``ssh`` within your program, and it supports reading the key from\n    ``ssh-agent``, rather than writing the private key to the disk, you may want to have\n    a look at the dedicated :ref:`ssh` feature.\n\nBake secrets into a complex configuration file\n----------------------------------------------\n\n.. warning::\n\n   It's been reported__ that this approach doesn't work as intended. It's left\n   for inspiration, but as of today, ``ExecStartPre`` cannot write to the\n   private filesystem created by ``TemporaryFileSystem`` in  way that ``ExecStart``\n   can later read. Please refer to the ticket for workarounds.\n\n   .. __: https://github.com/peopledoc/vault-cli/issues/185\n\nIn some cases, the program you want to launch doesn\u2019t accept\nconfiguration through environment but only through configuration files.\nYou could be tempted to use the method above, but the configuration file\nmixes secrets and a lot of other information that should not be stored\nin the vault. In this case, you need a way to write your configuration\nfile without secrets on disk and, at the last moment, to bake the\nsecrets into the file. To do that we\u2019ll use ``vault-cli template``.\n\nSee the dedicated :ref:`template` documentation for detailed use of ``vault-cli\ntemplate``.\n\nThe integration strategy will depend of several factors:\n\n- Does``myprogram`` expect to read its configuration file at a specific location?\n- Does it accept an arbitrary configuration path?\n- Does the folder containing the configuration contain other\n  files or just that configuration file?\n\nWe will be using a ``TemporaryFileSystem`` like above, but this option\ncan only be used to make a folder, not a single file. If the\nconfiguration can be read anywhere or if the whole folder can be\noverridden, then it\u2019s the easier path. Otherwise, you may want to create\na symbolic link in place of your configuration file, that will be pointing to\nyour temporary file system.\n\nLet\u2019s assume that ``myprogram`` will read its configuration at\n``/private/myprogram.conf``, through customization of the configuration file path or\nthrough a symbolic link in the standard configuration file location.\n\nThe systemd configuration will be close to our previous case:\n\n.. code:: console\n\n   $ sudo systemctl edit myprogram.service\n   # opens a new file for edition\n   [Service]\n   TemporaryFileSystem=/private\n   ExecStartPre=vault-cli template --input=/etc/myprogram/myprogram.conf.j2 --output=/private/myprogram.conf\n\nSave and quit the file. Load you new configuration file with:\n\n.. code:: console\n\n   $ sudo systemctl daemon-reload\n   $ sudo systemctl restart myprogram.service\n\n``vault_cli`` as a python lib\n-----------------------------\n\nFinally, if the program is made with Python and you control it, another solution can be\nto use ``vault_cli`` on the Python side, and load your secrets when your process starts.\nThis does not follow :ref:`12-factor` methodologies, and it means your program will be\nstrongly coupled with the vault, which will make development more complicated.\n\nSee :ref:`library`.\n", "patch": "@@ -18,14 +18,6 @@ Vault-cli aims at helping you launch your application with the secrets\n it needs without writing them on disk. This page lists a few scenarios\n that may be useful.\n \n-If the value you need to pass is directly a secret that is stored in the\n-vault, perfect. Otherwise, you may want to create a `templated\n-value`__\n-to recreate your secret value by combining static strings and other\n-secrets.\n-\n-.. __: https://github.com/peopledoc/vault-cli/#create-a-templated-value\n-\n Let\u2019s assume the value you need to pass is the value you get with:\n \n .. code:: console", "file_path": "files/2021_12/195", "file_language": "rst", "file_name": "docs/howto/systemd.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/fbde0c39de13d0b825fdae8024fbb9d8219cb4af/docs%2Fhowto%2Ftemplated_secrets.rst", "code": "Make a secret point to dynamic content\n======================================\n\n.. warning::\n\n    This feature will be removed from Vault-CLI in the next major version.\n\nWith ``vault-cli``, it's possible to have secret values be Jinja2_ templates. This is\nuseful if you have multiple related secrets that you would like to retrieve as a single\nstring.\n\n.. _Jinja2: https://jinja.palletsprojects.com/en/2.11.x/\n\n.. note::\n\n    This is a pure ``vault-cli`` feature, built on top of vault. Do not expect this\n    to be interoperable with other vault clients.\n\n.. warning::\n\n    ``vault-cli`` takes the assumption that untrusted parties cannot store arbitrary\n    secrets in your vault, and access those secrets, otherwise it would be trivial to\n    use a templated value that would return other secrets. If you really want to use the\n    vault this way, please make sure to use either the ``--no-render`` flag, the\n    ``render: no`` configuration file option or the ``VAULT_CLI_RENDER=false``\n    environment variable.\n\n.. note::\n\n    Templated secrets rendering work like ``vault-cli template``. See :ref:`template`.\n\nCreate and read a templated secret\n----------------------------------\n\nTemplated secrets start with the special prefix ``!template!``. Vault-cli recongizes\nthis and will evaluate the rest of the value as a Jinja2 template.\n\nThe template context includes a ``vault(path: str)`` function that returns the secret\nobject stored at path. Individual values can be accessed by simply reading attributes on\nthe secret object:\n\n.. code:: console\n\n   $ vault-cli set service username=foo password=bar host=example.com\n   $ vault-cli set shortcut dsn='!template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/'\n   $ vault-cli get shortcut dsn\n   proto://foo:bar@example.com/\n   $ vault-cli --no-render get shortcut dsn\n   !template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/\n\nVariable rendering can be recursive as long as there is no loop (a uses b, b uses a)\n\nIncluding a templated secret in an Ansible YAML file\n----------------------------------------------------\n\nThe following is relevant only if your setup includes Ansible_.\n\nAnsible is based on running Jinja2 on YAML files. Consider a YAML object looking like:\n\n.. code:: yaml\n\n    ---\n    template: !template!{{ vault(\"path\").key }}\n\nThe ``!template`` part will be interpreted as an unknown YAML directive. The\n``{{ vault(\"path\").key }}`` will be interpreted by Ansible's Jinja2, which will crash\nbecause Ansible doesn't have a ``vault`` function in its context.\n\nUsing ``!unsafe``, a real Ansible YAML directive this time, we can instruct Ansible\nto leave the rest of the value as-is, and not run Jinja2 on it:\n\n.. code:: yaml\n\n    - name: Add templated secrets\n      command: vault-cli set {{ item.path }} '{{ item.key }}={{ item.template }}'\n      loop:\n        - path: path/one\n          key: mykey\n          template: !unsafe '!template!{{ vault(\"path\").key }}\n        - path: path/two\n          key: otherkey\n          template: !unsafe '!template!{{ vault(\"/otherpath\").somekey }}'\n\n.. _Ansible: https://www.ansible.com/\n", "code_before": "Make a secret point to dynamic content\n======================================\n\n.. warning::\n\n    This feature will be removed from Vault-CLI in the next major version.\n\nWith ``vault-cli``, it's possible to have secret values be Jinja2_ templates. This is\nuseful if you have multiple related secrets that you would like to retrieve as a single\nstring.\n\n.. _Jinja2: https://jinja.palletsprojects.com/en/2.11.x/\n\n.. note::\n\n    This is a pure ``vault-cli`` feature, built on top of vault. Do not expect this\n    to be interoperable with other vault clients.\n\n.. warning::\n\n    ``vault-cli`` takes the assumption that untrusted parties cannot store arbitrary\n    secrets in your vault, and access those secrets, otherwise it would be trivial to\n    use a templated value that would return other secrets. If you really want to use the\n    vault this way, please make sure to use either the ``--no-render`` flag, the\n    ``render: no`` configuration file option or the ``VAULT_CLI_RENDER=false``\n    environment variable.\n\n.. note::\n\n    Templated secrets rendering work like ``vault-cli template``. See :ref:`template`.\n\nCreate and read a templated secret\n----------------------------------\n\nTemplated secrets start with the special prefix ``!template!``. Vault-cli recongizes\nthis and will evaluate the rest of the value as a Jinja2 template.\n\nThe template context includes a ``vault(path: str)`` function that returns the secret\nobject stored at path. Individual values can be accessed by simply reading attributes on\nthe secret object:\n\n.. code:: console\n\n   $ vault-cli set service username=foo password=bar host=example.com\n   $ vault-cli set shortcut dsn='!template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/'\n   $ vault-cli get shortcut dsn\n   proto://foo:bar@example.com/\n   $ vault-cli --no-render get shortcut dsn\n   !template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/\n\nVariable rendering can be recursive as long as there is no loop (a uses b, b uses a)\n\nIncluding a templated secret in an Ansible YAML file\n----------------------------------------------------\n\nThe following is relevant only if your setup includes Ansible_.\n\nAnsible is based on running Jinja2 on YAML files. Consider a YAML object looking like:\n\n.. code:: yaml\n\n    ---\n    template: !template!{{ vault(\"path\").key }}\n\nThe ``!template`` part will be interpreted as an unknown YAML directive. The\n``{{ vault(\"path\").key }}`` will be interpreted by Ansible's Jinja2, which will crash\nbecause Ansible doesn't have a ``vault`` function in its context.\n\nUsing ``!unsafe``, a real Ansible YAML directive this time, we can instruct Ansible\nto leave the rest of the value as-is, and not run Jinja2 on it:\n\n.. code:: yaml\n\n    - name: Add templated secrets\n      command: vault-cli set {{ item.path }} '{{ item.key }}={{ item.template }}'\n      loop:\n        - path: path/one\n          key: mykey\n          template: !unsafe '!template!{{ vault(\"path\").key }}\n        - path: path/two\n          key: otherkey\n          template: !unsafe '!template!{{ vault(\"/otherpath\").somekey }}'\n\n.. _Ansible: https://www.ansible.com/\n", "patch": "@@ -1,84 +0,0 @@\n-Make a secret point to dynamic content\n-======================================\n-\n-.. warning::\n-\n-    This feature will be removed from Vault-CLI in the next major version.\n-\n-With ``vault-cli``, it's possible to have secret values be Jinja2_ templates. This is\n-useful if you have multiple related secrets that you would like to retrieve as a single\n-string.\n-\n-.. _Jinja2: https://jinja.palletsprojects.com/en/2.11.x/\n-\n-.. note::\n-\n-    This is a pure ``vault-cli`` feature, built on top of vault. Do not expect this\n-    to be interoperable with other vault clients.\n-\n-.. warning::\n-\n-    ``vault-cli`` takes the assumption that untrusted parties cannot store arbitrary\n-    secrets in your vault, and access those secrets, otherwise it would be trivial to\n-    use a templated value that would return other secrets. If you really want to use the\n-    vault this way, please make sure to use either the ``--no-render`` flag, the\n-    ``render: no`` configuration file option or the ``VAULT_CLI_RENDER=false``\n-    environment variable.\n-\n-.. note::\n-\n-    Templated secrets rendering work like ``vault-cli template``. See :ref:`template`.\n-\n-Create and read a templated secret\n-----------------------------------\n-\n-Templated secrets start with the special prefix ``!template!``. Vault-cli recongizes\n-this and will evaluate the rest of the value as a Jinja2 template.\n-\n-The template context includes a ``vault(path: str)`` function that returns the secret\n-object stored at path. Individual values can be accessed by simply reading attributes on\n-the secret object:\n-\n-.. code:: console\n-\n-   $ vault-cli set service username=foo password=bar host=example.com\n-   $ vault-cli set shortcut dsn='!template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/'\n-   $ vault-cli get shortcut dsn\n-   proto://foo:bar@example.com/\n-   $ vault-cli --no-render get shortcut dsn\n-   !template!proto://{{ vault(\"service\").username }}:{{ vault(\"service\").password }}@{{ vault(\"service\").host }}/\n-\n-Variable rendering can be recursive as long as there is no loop (a uses b, b uses a)\n-\n-Including a templated secret in an Ansible YAML file\n-----------------------------------------------------\n-\n-The following is relevant only if your setup includes Ansible_.\n-\n-Ansible is based on running Jinja2 on YAML files. Consider a YAML object looking like:\n-\n-.. code:: yaml\n-\n-    ---\n-    template: !template!{{ vault(\"path\").key }}\n-\n-The ``!template`` part will be interpreted as an unknown YAML directive. The\n-``{{ vault(\"path\").key }}`` will be interpreted by Ansible's Jinja2, which will crash\n-because Ansible doesn't have a ``vault`` function in its context.\n-\n-Using ``!unsafe``, a real Ansible YAML directive this time, we can instruct Ansible\n-to leave the rest of the value as-is, and not run Jinja2 on it:\n-\n-.. code:: yaml\n-\n-    - name: Add templated secrets\n-      command: vault-cli set {{ item.path }} '{{ item.key }}={{ item.template }}'\n-      loop:\n-        - path: path/one\n-          key: mykey\n-          template: !unsafe '!template!{{ vault(\"path\").key }}\n-        - path: path/two\n-          key: otherkey\n-          template: !unsafe '!template!{{ vault(\"/otherpath\").somekey }}'\n-\n-.. _Ansible: https://www.ansible.com/", "file_path": "files/2021_12/196", "file_language": "rst", "file_name": "docs/howto/templated_secrets.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/docs%2Fhowto%2Fupgrade.rst", "code": "Upgrade ``vault-cli`` from previous version\n===========================================\n\nFrom 2.x to 3.x\n~~~~~~~~~~~~~~~\n\nTemplated values (``!template!{{ vault(\"a\").b }}``) aren't supported anymore.\nIf you were using those, you will get a warning starting on ``vault-cli~=2.2.1``.\n\nOn 3.x, a ``--render/--no-render`` flag is still available but it does nothing.\n\nFrom 1.x to 2.x\n~~~~~~~~~~~~~~~\n\nSwitch command name from ``vault`` to ``vault-cli`` if you're using it.\n\nFrom 0.x to 1.x\n~~~~~~~~~~~~~~~\n\nThis version includes some breaking changes about key-value mapping\nmanagement. In the previous versions of vault-cli, there was an implicit\nkey ``value`` that was used everywhere. The goal was to provide a path\n<-> value abstraction. But it was hiding the path <-> key/value mapping\nreality of vault\u2019s kv engine.\n\nIn this release we removed the implicit ``value`` key in order to\nexpose a key/value mapping instead of a single value. Most of the\ncommands have been updated in order to add the key parameter.\n\nA new option ``--omit-single-key`` was added to ``vault-cli env`` in order\nto ignore the key when the variable names are built and there is only\none key in the mapping. This option case simplify your migration as\nthere won\u2019t be an additional ``_VALUE`` suffix added to your environment\nvariables names.\n\n.. note::\n\n    Since 1.0, the official CLI name has switched from ``vault`` to ``vault-cli``\n    but ``vault`` is kept for backwards compatibility. Because ``vault-cli 0.x`` was\n    only compatible with the name ``vault``, the examples below are written with\n    ``vault``\n    After 2.0, command ``vault`` has disappeared.\n\nThe following list shows how to update your commands:\n\n.. code:: sh\n\n   (old) vault set path/to/creds xxx\n   (new) vault set path/to/creds value=xxx\n\n   (old) vault get path/to/creds\n   (new) vault get path/to/creds value\n\n   (old) vault env --envvar path/to/creds=FOO -- env  # FOO=xxx\n   (new) vault env --envvar path/to/creds=FOO -- env  # FOO_VALUE=xxx\n   (new) vault env --envvar path/to/creds:value=FOO -- env  # FOO=xxx\n   (new) vault env --omit-single_key --envvar path/to/creds=FOO -- env  # FOO=xxx\n\nThe default output of ``vault get-all`` has also changed and is now flat\nby default (this behavior is controlled with the ``--flat/--no-flat``\nflags).\n\n.. code:: sh\n\n   $ vault set a/b secret=xxx\n   $ vault set a/c secret=xxx\n   $ vault get-all a\n   ---\n   a/b:\n     secret: xxx\n   a/c:\n     secret: xxx\n   $ vault get-all --no-flat a\n   ---\n   a:\n     b:\n       secret: xxx\n     c:\n       secret: xxx\n", "code_before": "Upgrade ``vault-cli`` from previous version\n===========================================\n\nFrom 2.x to 3.x\n~~~~~~~~~~~~~~~\n\nTemplated values (``!template!{{ vault(\"a\").b }}``) aren't supported anymore.\nIf you were using those, you will get a warning starting on ``vault-cli~=2.2.1``.\n\nOn 3.x, a ``--render/--no-render`` flag is still available but it does nothing.\n\nFrom 1.x to 2.x\n~~~~~~~~~~~~~~~\n\nSwitch command name from ``vault`` to ``vault-cli`` if you're using it.\n\nFrom 0.x to 1.x\n~~~~~~~~~~~~~~~\n\nThis version includes some breaking changes about key-value mapping\nmanagement. In the previous versions of vault-cli, there was an implicit\nkey ``value`` that was used everywhere. The goal was to provide a path\n<-> value abstraction. But it was hiding the path <-> key/value mapping\nreality of vault\u2019s kv engine.\n\nIn this release we removed the implicit ``value`` key in order to\nexpose a key/value mapping instead of a single value. Most of the\ncommands have been updated in order to add the key parameter.\n\nA new option ``--omit-single-key`` was added to ``vault-cli env`` in order\nto ignore the key when the variable names are built and there is only\none key in the mapping. This option case simplify your migration as\nthere won\u2019t be an additional ``_VALUE`` suffix added to your environment\nvariables names.\n\n.. note::\n\n    Since 1.0, the official CLI name has switched from ``vault`` to ``vault-cli``\n    but ``vault`` is kept for backwards compatibility. Because ``vault-cli 0.x`` was\n    only compatible with the name ``vault``, the examples below are written with\n    ``vault``\n    After 2.0, command ``vault`` has disappeared.\n\nThe following list shows how to update your commands:\n\n.. code:: sh\n\n   (old) vault set path/to/creds xxx\n   (new) vault set path/to/creds value=xxx\n\n   (old) vault get path/to/creds\n   (new) vault get path/to/creds value\n\n   (old) vault env --envvar path/to/creds=FOO -- env  # FOO=xxx\n   (new) vault env --envvar path/to/creds=FOO -- env  # FOO_VALUE=xxx\n   (new) vault env --envvar path/to/creds:value=FOO -- env  # FOO=xxx\n   (new) vault env --omit-single_key --envvar path/to/creds=FOO -- env  # FOO=xxx\n\nThe default output of ``vault get-all`` has also changed and is now flat\nby default (this behavior is controlled with the ``--flat/--no-flat``\nflags).\n\n.. code:: sh\n\n   $ vault set a/b secret=xxx\n   $ vault set a/c secret=xxx\n   $ vault get-all a\n   ---\n   a/b:\n     secret: xxx\n   a/c:\n     secret: xxx\n   $ vault get-all --no-flat a\n   ---\n   a:\n     b:\n       secret: xxx\n     c:\n       secret: xxx\n", "patch": "@@ -1,6 +1,14 @@\n Upgrade ``vault-cli`` from previous version\n ===========================================\n \n+From 2.x to 3.x\n+~~~~~~~~~~~~~~~\n+\n+Templated values (``!template!{{ vault(\"a\").b }}``) aren't supported anymore.\n+If you were using those, you will get a warning starting on ``vault-cli~=2.2.1``.\n+\n+On 3.x, a ``--render/--no-render`` flag is still available but it does nothing.\n+\n From 1.x to 2.x\n ~~~~~~~~~~~~~~~\n ", "file_path": "files/2021_12/197", "file_language": "rst", "file_name": "docs/howto/upgrade.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/docs%2Fhowto_index.rst", "code": ".. _how-to:\n\nHow-to...\n=========\n\n.. toctree::\n    :maxdepth: 1\n\n    howto/configure\n    howto/authenticate\n    howto/read\n    howto/write\n    howto/environment\n    howto/template\n    howto/ssh\n    howto/systemd\n    howto/organize\n    howto/base_path\n    howto/permissions\n    howto/safe_write\n    howto/secret_with_dash\n    howto/import_export\n    howto/library\n    howto/test\n    howto/troubleshooting\n    howto/lookup\n    howto/upgrade\n", "code_before": ".. _how-to:\n\nHow-to...\n=========\n\n.. toctree::\n    :maxdepth: 1\n\n    howto/configure\n    howto/authenticate\n    howto/read\n    howto/write\n    howto/environment\n    howto/template\n    howto/ssh\n    howto/systemd\n    howto/organize\n    howto/base_path\n    howto/permissions\n    howto/safe_write\n    howto/secret_with_dash\n    howto/import_export\n    howto/library\n    howto/test\n    howto/troubleshooting\n    howto/lookup\n    howto/upgrade\n", "patch": "@@ -12,7 +12,6 @@ How-to...\n     howto/write\n     howto/environment\n     howto/template\n-    howto/templated_secrets\n     howto/ssh\n     howto/systemd\n     howto/organize", "file_path": "files/2021_12/198", "file_language": "rst", "file_name": "docs/howto_index.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/tests%2Funit%2Ftest_cli.py", "code": "import logging\nimport os\nimport tempfile\n\nimport click\nimport pytest\nimport yaml\n\nimport vault_cli\nfrom vault_cli import cli, exceptions, settings\n\n# To debug cli_runner.invoke, add the argument \"catch_exceptions=False\"\n\n\ndef test_options(cli_runner, mocker):\n    client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n    mocker.patch(\n        \"vault_cli.settings.read_file\", side_effect=lambda x: \"content of {}\".format(x)\n    )\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--base-path\",\n            \"bla\",\n            \"--ca-bundle\",\n            \"yay\",\n            \"--login-cert\",\n            \"puc\",\n            \"--login-cert-key\",\n            \"prc\",\n            \"--password-file\",\n            \"b\",\n            \"--token-file\",\n            \"c\",\n            \"--url\",\n            \"https://foo\",\n            \"--username\",\n            \"user\",\n            \"--verify\",\n            \"list\",\n        ],\n    )\n\n    assert result.exit_code == 0, result.output\n    _, kwargs = client.call_args\n    assert set(kwargs) == {\n        \"base_path\",\n        \"ca_bundle\",\n        \"login_cert\",\n        \"login_cert_key\",\n        \"password\",\n        \"safe_write\",\n        \"token\",\n        \"url\",\n        \"username\",\n        \"verify\",\n    }\n    assert kwargs[\"base_path\"] == \"bla\"\n    assert kwargs[\"ca_bundle\"] == \"yay\"\n    assert kwargs[\"login_cert\"] == \"puc\"\n    assert kwargs[\"login_cert_key\"] == \"prc\"\n    assert kwargs[\"password\"] == \"content of b\"\n    assert kwargs[\"token\"] == \"content of c\"\n    assert kwargs[\"url\"] == \"https://foo\"\n    assert kwargs[\"username\"] == \"user\"\n    assert kwargs[\"verify\"] is True\n\n\n@pytest.fixture\ndef vault_with_token(vault):\n    vault.token = \"token\"\n    vault.freeze_settings = True\n    return vault\n\n\ndef test_list(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo\": {\"value\": \"yay\"}, \"baz\": {\"value\": \"ho\"}}\n    result = cli_runner.invoke(cli.cli, [\"list\"])\n\n    assert result.output == \"baz\\nfoo\\n\"\n    assert result.exit_code == 0\n\n\n@pytest.mark.parametrize(\"extra_args\", [[\"--text\"], []])\ndef test_get_text(cli_runner, vault_with_token, extra_args):\n\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\"] + extra_args)\n\n    assert result.output == \"---\\nvalue: bar\\n\"\n    assert result.exit_code == 0\n\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\"] + extra_args)\n\n    assert result.output == \"bar\\n\"\n    assert result.exit_code == 0\n\n\n@pytest.mark.parametrize(\n    \"value, output\",\n    [\n        ({\"list\": [1, 2]}, \"---\\nlist:\\n- 1\\n- 2\\n\"),\n        ({\"a\": \"b\"}, \"---\\na: b\\n\"),\n        (None, \"null\\n\"),\n    ],\n)\ndef test_get_text_special_cases(cli_runner, vault_with_token, value, output):\n\n    vault_with_token.db = {\"a\": value}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\"])\n\n    assert result.output == output\n    assert result.exit_code == 0\n\n\ndef test_get_yaml(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\", \"--yaml\"])\n\n    assert result.output == \"--- bar\\n...\\n\"\n    assert result.exit_code == 0\n\n\ndef test_get_all_no_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"--no-flat\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a\": {\"baz\": {\"value\": \"bar\"}, \"foo\": {\"value\": \"yay\"}}\n    }\n    assert result.exit_code == 0\n\n\ndef test_get_all_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a/baz\": {\"value\": \"bar\"},\n        \"a/foo\": {\"value\": \"yay\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_set(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr=b\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"attr\": \"b\"}}\n\n\ndef test_set_without_value(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr\"])\n\n    assert result.exit_code == 2\n    assert \"Expecting 'key=value' arguments.\" in result.stdout\n\n\ndef test_set_arg_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"value=-\"], input=\"yeah\")\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"yeah\"}}\n\n\ndef test_set_stdin(cli_runner, vault_with_token):\n    # Just checking that yaml and stdin are not incompatible\n    result = cli_runner.invoke(\n        cli.cli, [\"set\", \"--file=-\", \"a\"], input=yaml.safe_dump({\"b\": \"c\"})\n    )\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}\n\n\ndef test_set_with_both_prompt_and_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"value\", \"--file=-\", \"a\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}\n\n\ndef test_set_with_both_yaml_and_multiple_values(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--yaml\", \"a\", \"b\", \"c\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}\n\n\ndef test_set_prompt(cli_runner, mocker, vault_with_token):\n\n    prompt = mocker.patch(\"click.prompt\")\n    prompt.return_value = \"b\"\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"a\", \"value\"])\n    # test for prompt function\n    prompt.assert_called_with(\n        \"Please enter a value for key `value` of `a`\", hide_input=True\n    )\n\n    # Correctly stored secret.\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"b\"}}\n\n\ndef test_set_yaml(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--file=-\", \"a\"], input='{\"b\": \"c\"}')\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}\n\n\n@pytest.mark.parametrize(\n    \"args, expected\",\n    [\n        # no safe-write by default\n        ([\"set\", \"a\", \"value=b\"], \"b\"),\n        # same, but explicit\n        ([\"--unsafe-write\", \"set\", \"a\", \"value=b\"], \"b\"),\n        # safe-write but with force\n        ([\"--safe-write\", \"set\", \"--force\", \"a\", \"value=b\"], \"b\"),\n        # safe-write but the written value is equal to the current value\n        ([\"--safe-write\", \"set\", \"a\", \"value=c\"], \"c\"),\n    ],\n)\ndef test_set_overwrite_valid(cli_runner, vault_with_token, args, expected):\n\n    vault_with_token.db = {\"a\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, args)\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": expected}}\n\n\n@pytest.mark.parametrize(\n    \"args\",\n    [\n        # safe-write\n        [\"--safe-write\", \"set\", \"a\", \"value=b\"],\n        # no-force\n        [\"set\", \"--no-force\", \"a\", \"value=b\"],\n    ],\n)\ndef test_set_overwrite_safe_invalid(cli_runner, vault_with_token, args):\n\n    vault_with_token.safe_write = \"--safe-write\" in args\n    vault_with_token.db = {\"a\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, args)\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a\": {\"value\": \"c\"}}\n\n\ndef test_set_mix_secrets_folders(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b/c\", \"value=d\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}}\n\n\ndef test_set_mix_folders_secrets(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b\", \"value=c\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b/c\": {\"value\": \"d\"}}\n\n\ndef test_set_all(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a/b: {\"c\": \"d\"}\"\"\")\n\n    assert result.exit_code == 0\n    assert result.stdout.strip() == \"Done\"\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_set_all_wrong_type(cli_runner, vault_with_token):\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"[1, 2, 3]\"\"\")\n    assert result.exit_code != 0\n    error = \"Error: Mapping expected format is a mapping of paths to secret objects\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {}\n\n\ndef test_set_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"set-all\", \"--no-force\"], input=\"\"\"a/b: {\"c\": \"e\"}\"\"\"\n    )\n    assert result.exit_code != 0\n    error = (\n        \"Error: Secret already exists at a/b for key: c\\nUse -f to force overwriting\"\n    )\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_set_all_mix(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a: {\"e\": \"f\"}\"\"\")\n\n    assert result.exit_code != 0\n    error = \"Error: Cannot create a secret at 'a' because it is already a folder containing a/b\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_delete(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a\": {\"value\": \"foo\"}, \"b\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"delete\", \"a\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"b\": {\"value\": \"bar\"}}\n\n\ndef test_env(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ_VALUE\"] == \"yo\"\n\n\ndef test_env_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    exec_command.assert_not_called()\n\n\ndef test_env_envvar_format_error(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \":foo\", \"--\", \"echo\", \"yay\"]\n    )\n\n    assert result.exit_code != 0\n    assert \"Cannot omit the path if a filter key is provided\" in result.output\n\n\ndef test_env_error_force_sub_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()\n\n\ndef test_env_error_force_main_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_list_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()\n\n\ndef test_env_prefix(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo=prefix\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"PREFIX_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_USER\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_PASSWORD\"] == \"xxx\"\n\n\ndef test_env_filter_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(\n        cli.cli,\n        [\n            \"env\",\n            \"--envvar\",\n            \"foo/baz:user=MYNAME\",\n            \"--envvar\",\n            \"foo/baz:password\",\n            \"--\",\n            \"echo\",\n            \"yay\",\n        ],\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"MYNAME\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PASSWORD\"] == \"xxx\"\n\n\ndef test_env_omit_single_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"password\": \"yo\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--omit-single-key\", \"--\", \"echo\", \"yay\"]\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ\"] == \"yo\"\n\n\ndef test_env_file(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", f\"foo/bar:value={path}\", \"--\", \"echo\", \"yay\"]\n    )\n    assert path.read_text() == \"yay\\n\"\n\n\ndef test_env_file_format_error(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", \"foo/bar\", \"--\", \"echo\", \"yay\"]\n    )\n    assert result.exit_code != 0\n    assert \"expects both a vault path and a filesystem path\" in result.output\n\n\ndef test_env_file_yaml(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli,\n        [\"env\", \"--file\", f\"foo/bar={path}\", \"--\", \"echo\", \"yay\"],\n    )\n    assert path.read_text() == \"---\\nvalue: yay\\n\"\n\n\ndef test_main(environ, mocker):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n\n    cli.main()\n\n    mock_cli.assert_called_with()\n    assert set({\"LC_ALL\": \"C.UTF-8\", \"LANG\": \"C.UTF-8\"}.items()) <= set(environ.items())\n\n\ndef test_main_askpass(environ, mocker, capsys):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n    environ.update({\"VAULT_CLI_SSH_PASSPHRASE\": \"foo\"})\n\n    cli.main()\n\n    out = capsys.readouterr().out.strip()\n    assert out == \"foo\"\n\n    mock_cli.assert_not_called()\n\n\ndef test_load_config_no_config(mocker):\n    ctx = mocker.Mock()\n    cli.load_config(ctx, None, \"no\")\n\n    assert ctx.default_map == {}\n\n\n@pytest.mark.parametrize(\n    \"value, expected\",\n    [(\"bla\", [\"bla\"]), (None, [\"./vault.yml\", \"~/.vault.yml\", \"/etc/vault.yml\"])],\n)\ndef test_load_config(mocker, value, expected):\n    ctx = mocker.Mock()\n    build = mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"a\": \"b\"}\n    )\n    cli.load_config(ctx, None, value)\n\n    assert ctx.default_map == {\"a\": \"b\"}\n    build.assert_called_with(*expected)\n\n\n@pytest.mark.parametrize(\n    \"config, environ, expected\",\n    [\n        # Empty does not crash or what\n        ({}, {}, {}),\n        # Irrelevant keys are not copied over\n        ({\"a\": \"b\"}, {\"c\", \"d\"}, {}),\n        # Relevant keys is copied from first dict\n        ({\"password\": \"e\"}, {}, {\"password\": \"e\"}),\n        ({\"token\": \"f\"}, {}, {\"token\": \"f\"}),\n        # Relevant keys is copied from second dict\n        ({}, {\"VAULT_CLI_PASSWORD\": \"h\"}, {\"password\": \"h\"}),\n        ({}, {\"VAULT_CLI_TOKEN\": \"i\"}, {\"token\": \"i\"}),\n        # Second dict has priority\n        ({\"password\": \"l\"}, {\"VAULT_CLI_PASSWORD\": \"m\"}, {\"password\": \"m\"}),\n        ({\"token\": \"n\"}, {\"VAULT_CLI_TOKEN\": \"o\"}, {\"token\": \"o\"}),\n    ],\n)\ndef test_extract_special_args(config, environ, expected):\n    result = cli.extract_special_args(config, environ)\n\n    assert set(result) == {\"password\", \"token\"}\n    # remove None\n    result = {key: value for key, value in result.items() if value is not None}\n\n    assert result == expected\n\n\ndef test_set_verbosity(mocker):\n    basic_config = mocker.patch(\"logging.basicConfig\")\n\n    cli.set_verbosity(1)\n\n    basic_config.assert_called_with(level=logging.INFO)\n\n\ndef test_dump_config(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--config-file=/dev/null\",\n            \"--base-path=mybase/\",\n            \"--token-file=-\",\n            \"dump-config\",\n        ],\n        input=\"some-token\",\n    )\n\n    expected_settings = settings.DEFAULTS._as_dict()\n    expected_settings.update(\n        {\"base_path\": \"mybase/\", \"token\": \"some-token\", \"verbose\": 0, \"umask\": \"0o066\"}\n    )\n\n    output = yaml.safe_load(result.output)\n\n    assert output == expected_settings\n\n\ndef test_delete_all(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\ny\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: y\",\n        \"Deleted 'foo/baz'\",\n    ]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0\n\n\ndef test_delete_all_cancel(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\nn\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: n\",\n        \"Aborted!\",\n    ]\n    assert vault_with_token.db == {\"foo/baz\": {\"value\": \"yo\"}}\n    assert result.exit_code != 0\n\n\ndef test_delete_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\", \"--force\"])\n\n    assert result.output.splitlines() == [\"Deleted 'foo/bar'\", \"Deleted 'foo/baz'\"]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0\n\n\ndef test_mv(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Move 'd/e' to 'a/e'\", \"Move 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_mv_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0\n\n\ndef test_mv_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0\n\n\ndef test_mv_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_mv_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Copy 'd/e' to 'a/e'\", \"Copy 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_cp_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0\n\n\ndef test_cp_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_template_from_stdin(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli, [\"template\", \"-\"], input=\"Hello {{ vault('a/b').value }}\"\n    )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"\n\n\ndef test_template_from_file(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(mode=\"w+\") as fp:\n        fp.write(\"Hello {{ vault('a/b').value }}\")\n        fp.flush()\n        result = cli_runner.invoke(\n            cli.cli, [\"template\", fp.name], catch_exceptions=False\n        )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"\n\n\ndef test_template_from_file_with_include(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as template_file:\n        with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as include_file:\n            template_file.write(\n                \"Hello {{ vault('a/b').value }}\\n{% include('\"\n                + os.path.basename(include_file.name)\n                + \"') %}\"\n            )\n            template_file.flush()\n            include_file.write(\"Hello all\")\n            include_file.flush()\n\n            result = cli_runner.invoke(\n                cli.cli, [\"template\", template_file.name], catch_exceptions=False\n            )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\\nHello all\"\n\n\ndef test_lookup_token(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"lookup-token\"])\n\n    assert result.exit_code == 0\n    assert yaml.safe_load(result.stdout)[\"data\"][\"expire_time\"].startswith(\n        \"2100-01-01T00:00:00\"\n    )\n\n\ndef test_handle_errors(cli_runner):\n    @cli.handle_errors()\n    def inner():\n        raise exceptions.VaultException(\"foo\") from ValueError(\"bar\")\n\n    with pytest.raises(click.ClickException) as exc_info:\n        inner()\n\n    assert str(exc_info.value) == \"VaultException: foo\\nValueError: bar\"\n\n\ndef test_version(cli_runner):\n    result = cli_runner.invoke(cli.cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert result.stdout.startswith(\"vault-cli \" + vault_cli.__version__)\n    assert result.stdout.endswith(\"License: Apache Software License\\n\")\n\n\ndef test_ssh(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b:value\", \"--\", \"env\"])\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=None)\n    exec_command.assert_called_with(command=(\"env\",))\n\n\ndef test_ssh_passphrase(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\", \"passphrase\": \"d\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b:passphrase\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=\"d\")\n    exec_command.assert_called_with(command=(\"env\",))\n\n\ndef test_ssh_wrong_format_key(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b\", \"--\", \"env\"])\n\n    assert result.exit_code > 0\n\n\ndef test_ssh_wrong_format_passphrase(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code > 0\n\n\n@pytest.mark.parametrize(\"input, output\", [(\"022\", 0o22), (\"0o123\", 0o123)])\ndef test_parse_octal(input, output):\n    assert cli.parse_octal(input) == output\n\n\n@pytest.mark.parametrize(\n    \"input, output\",\n    [\n        (None, None),\n        (0o22, \"0o022\"),\n        (0o123, \"0o123\"),\n        (0o12345, \"0o12345\"),\n        (0, \"0o000\"),\n    ],\n)\ndef test_repr_octal(input, output):\n    assert cli.repr_octal(input) == output\n\n\ndef test_ensure_str():\n    assert cli.ensure_str(\"foo\", \"bar\") == \"foo\"\n\n\ndef test_ensure_str_wrong():\n    with pytest.raises(exceptions.VaultWrongType):\n        cli.ensure_str(1, \"bar\")\n\n\n@pytest.mark.parametrize(\n    \"input, output\",\n    [\n        (\"aa:bb=cc\", (\"aa\", \"bb\", \"cc\")),\n        (\"aa:bb\", (\"aa\", \"bb\", \"\")),\n        (\"aa=cc\", (\"aa\", \"\", \"cc\")),\n        (\"aa\", (\"aa\", \"\", \"\")),\n        (\":bb=cc\", (\"\", \"bb\", \"cc\")),\n        (\"=cc\", (\"\", \"\", \"cc\")),\n        (\":bb\", (\"\", \"bb\", \"\")),\n        (\"\", (\"\", \"\", \"\")),\n    ],\n)\ndef test_get_env_parts(input, output):\n    assert cli.get_env_parts(input) == output\n", "code_before": "import logging\nimport os\nimport tempfile\n\nimport click\nimport pytest\nimport yaml\n\nimport vault_cli\nfrom vault_cli import cli, exceptions, settings\n\n# To debug cli_runner.invoke, add the argument \"catch_exceptions=False\"\n\n\ndef test_options(cli_runner, mocker):\n    client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n    mocker.patch(\n        \"vault_cli.settings.read_file\", side_effect=lambda x: \"content of {}\".format(x)\n    )\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--base-path\",\n            \"bla\",\n            \"--ca-bundle\",\n            \"yay\",\n            \"--login-cert\",\n            \"puc\",\n            \"--login-cert-key\",\n            \"prc\",\n            \"--password-file\",\n            \"b\",\n            \"--token-file\",\n            \"c\",\n            \"--url\",\n            \"https://foo\",\n            \"--username\",\n            \"user\",\n            \"--verify\",\n            \"list\",\n        ],\n    )\n\n    assert result.exit_code == 0, result.output\n    _, kwargs = client.call_args\n    assert set(kwargs) == {\n        \"base_path\",\n        \"ca_bundle\",\n        \"login_cert\",\n        \"login_cert_key\",\n        \"password\",\n        \"safe_write\",\n        \"token\",\n        \"url\",\n        \"username\",\n        \"verify\",\n    }\n    assert kwargs[\"base_path\"] == \"bla\"\n    assert kwargs[\"ca_bundle\"] == \"yay\"\n    assert kwargs[\"login_cert\"] == \"puc\"\n    assert kwargs[\"login_cert_key\"] == \"prc\"\n    assert kwargs[\"password\"] == \"content of b\"\n    assert kwargs[\"token\"] == \"content of c\"\n    assert kwargs[\"url\"] == \"https://foo\"\n    assert kwargs[\"username\"] == \"user\"\n    assert kwargs[\"verify\"] is True\n\n\n@pytest.fixture\ndef vault_with_token(vault):\n    vault.token = \"token\"\n    vault.freeze_settings = True\n    return vault\n\n\ndef test_list(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo\": {\"value\": \"yay\"}, \"baz\": {\"value\": \"ho\"}}\n    result = cli_runner.invoke(cli.cli, [\"list\"])\n\n    assert result.output == \"baz\\nfoo\\n\"\n    assert result.exit_code == 0\n\n\n@pytest.mark.parametrize(\"extra_args\", [[\"--text\"], []])\ndef test_get_text(cli_runner, vault_with_token, extra_args):\n\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\"] + extra_args)\n\n    assert result.output == \"---\\nvalue: bar\\n\"\n    assert result.exit_code == 0\n\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\"] + extra_args)\n\n    assert result.output == \"bar\\n\"\n    assert result.exit_code == 0\n\n\n@pytest.mark.parametrize(\n    \"value, output\",\n    [\n        ({\"list\": [1, 2]}, \"---\\nlist:\\n- 1\\n- 2\\n\"),\n        ({\"a\": \"b\"}, \"---\\na: b\\n\"),\n        (None, \"null\\n\"),\n    ],\n)\ndef test_get_text_special_cases(cli_runner, vault_with_token, value, output):\n\n    vault_with_token.db = {\"a\": value}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\"])\n\n    assert result.output == output\n    assert result.exit_code == 0\n\n\ndef test_get_yaml(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\", \"--yaml\"])\n\n    assert result.output == \"--- bar\\n...\\n\"\n    assert result.exit_code == 0\n\n\ndef test_get_all_no_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"--no-flat\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a\": {\"baz\": {\"value\": \"bar\"}, \"foo\": {\"value\": \"yay\"}}\n    }\n    assert result.exit_code == 0\n\n\ndef test_get_all_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a/baz\": {\"value\": \"bar\"},\n        \"a/foo\": {\"value\": \"yay\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_set(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr=b\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"attr\": \"b\"}}\n\n\ndef test_set_without_value(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr\"])\n\n    assert result.exit_code == 2\n    assert \"Expecting 'key=value' arguments.\" in result.stdout\n\n\ndef test_set_arg_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"value=-\"], input=\"yeah\")\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"yeah\"}}\n\n\ndef test_set_stdin(cli_runner, vault_with_token):\n    # Just checking that yaml and stdin are not incompatible\n    result = cli_runner.invoke(\n        cli.cli, [\"set\", \"--file=-\", \"a\"], input=yaml.safe_dump({\"b\": \"c\"})\n    )\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}\n\n\ndef test_set_with_both_prompt_and_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"value\", \"--file=-\", \"a\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}\n\n\ndef test_set_with_both_yaml_and_multiple_values(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--yaml\", \"a\", \"b\", \"c\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}\n\n\ndef test_set_prompt(cli_runner, mocker, vault_with_token):\n\n    prompt = mocker.patch(\"click.prompt\")\n    prompt.return_value = \"b\"\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"a\", \"value\"])\n    # test for prompt function\n    prompt.assert_called_with(\n        \"Please enter a value for key `value` of `a`\", hide_input=True\n    )\n\n    # Correctly stored secret.\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"b\"}}\n\n\ndef test_set_yaml(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--file=-\", \"a\"], input='{\"b\": \"c\"}')\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}\n\n\n@pytest.mark.parametrize(\n    \"args, expected\",\n    [\n        # no safe-write by default\n        ([\"set\", \"a\", \"value=b\"], \"b\"),\n        # same, but explicit\n        ([\"--unsafe-write\", \"set\", \"a\", \"value=b\"], \"b\"),\n        # safe-write but with force\n        ([\"--safe-write\", \"set\", \"--force\", \"a\", \"value=b\"], \"b\"),\n        # safe-write but the written value is equal to the current value\n        ([\"--safe-write\", \"set\", \"a\", \"value=c\"], \"c\"),\n    ],\n)\ndef test_set_overwrite_valid(cli_runner, vault_with_token, args, expected):\n\n    vault_with_token.db = {\"a\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, args)\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": expected}}\n\n\n@pytest.mark.parametrize(\n    \"args\",\n    [\n        # safe-write\n        [\"--safe-write\", \"set\", \"a\", \"value=b\"],\n        # no-force\n        [\"set\", \"--no-force\", \"a\", \"value=b\"],\n    ],\n)\ndef test_set_overwrite_safe_invalid(cli_runner, vault_with_token, args):\n\n    vault_with_token.safe_write = \"--safe-write\" in args\n    vault_with_token.db = {\"a\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, args)\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a\": {\"value\": \"c\"}}\n\n\ndef test_set_mix_secrets_folders(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b/c\", \"value=d\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}}\n\n\ndef test_set_mix_folders_secrets(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b\", \"value=c\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b/c\": {\"value\": \"d\"}}\n\n\ndef test_set_all(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a/b: {\"c\": \"d\"}\"\"\")\n\n    assert result.exit_code == 0\n    assert result.stdout.strip() == \"Done\"\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_set_all_wrong_type(cli_runner, vault_with_token):\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"[1, 2, 3]\"\"\")\n    assert result.exit_code != 0\n    error = \"Error: Mapping expected format is a mapping of paths to secret objects\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {}\n\n\ndef test_set_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"set-all\", \"--no-force\"], input=\"\"\"a/b: {\"c\": \"e\"}\"\"\"\n    )\n    assert result.exit_code != 0\n    error = (\n        \"Error: Secret already exists at a/b for key: c\\nUse -f to force overwriting\"\n    )\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_set_all_mix(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a: {\"e\": \"f\"}\"\"\")\n\n    assert result.exit_code != 0\n    error = \"Error: Cannot create a secret at 'a' because it is already a folder containing a/b\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}\n\n\ndef test_delete(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a\": {\"value\": \"foo\"}, \"b\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"delete\", \"a\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"b\": {\"value\": \"bar\"}}\n\n\ndef test_env(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ_VALUE\"] == \"yo\"\n\n\ndef test_env_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    exec_command.assert_not_called()\n\n\ndef test_env_envvar_format_error(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \":foo\", \"--\", \"echo\", \"yay\"]\n    )\n\n    assert result.exit_code != 0\n    assert \"Cannot omit the path if a filter key is provided\" in result.output\n\n\ndef test_env_error_force_sub_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()\n\n\ndef test_env_error_force_main_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_list_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()\n\n\ndef test_env_prefix(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo=prefix\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"PREFIX_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_USER\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_PASSWORD\"] == \"xxx\"\n\n\ndef test_env_filter_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(\n        cli.cli,\n        [\n            \"env\",\n            \"--envvar\",\n            \"foo/baz:user=MYNAME\",\n            \"--envvar\",\n            \"foo/baz:password\",\n            \"--\",\n            \"echo\",\n            \"yay\",\n        ],\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"MYNAME\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PASSWORD\"] == \"xxx\"\n\n\ndef test_env_omit_single_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"password\": \"yo\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--omit-single-key\", \"--\", \"echo\", \"yay\"]\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ\"] == \"yo\"\n\n\ndef test_env_file(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", f\"foo/bar:value={path}\", \"--\", \"echo\", \"yay\"]\n    )\n    assert path.read_text() == \"yay\\n\"\n\n\ndef test_env_file_format_error(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", \"foo/bar\", \"--\", \"echo\", \"yay\"]\n    )\n    assert result.exit_code != 0\n    assert \"expects both a vault path and a filesystem path\" in result.output\n\n\ndef test_env_file_yaml(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli,\n        [\"env\", \"--file\", f\"foo/bar={path}\", \"--\", \"echo\", \"yay\"],\n    )\n    assert path.read_text() == \"---\\nvalue: yay\\n\"\n\n\ndef test_main(environ, mocker):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n\n    cli.main()\n\n    mock_cli.assert_called_with()\n    assert set({\"LC_ALL\": \"C.UTF-8\", \"LANG\": \"C.UTF-8\"}.items()) <= set(environ.items())\n\n\ndef test_main_askpass(environ, mocker, capsys):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n    environ.update({\"VAULT_CLI_SSH_PASSPHRASE\": \"foo\"})\n\n    cli.main()\n\n    out = capsys.readouterr().out.strip()\n    assert out == \"foo\"\n\n    mock_cli.assert_not_called()\n\n\ndef test_load_config_no_config(mocker):\n    ctx = mocker.Mock()\n    cli.load_config(ctx, None, \"no\")\n\n    assert ctx.default_map == {}\n\n\n@pytest.mark.parametrize(\n    \"value, expected\",\n    [(\"bla\", [\"bla\"]), (None, [\"./vault.yml\", \"~/.vault.yml\", \"/etc/vault.yml\"])],\n)\ndef test_load_config(mocker, value, expected):\n    ctx = mocker.Mock()\n    build = mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"a\": \"b\"}\n    )\n    cli.load_config(ctx, None, value)\n\n    assert ctx.default_map == {\"a\": \"b\"}\n    build.assert_called_with(*expected)\n\n\n@pytest.mark.parametrize(\n    \"config, environ, expected\",\n    [\n        # Empty does not crash or what\n        ({}, {}, {}),\n        # Irrelevant keys are not copied over\n        ({\"a\": \"b\"}, {\"c\", \"d\"}, {}),\n        # Relevant keys is copied from first dict\n        ({\"password\": \"e\"}, {}, {\"password\": \"e\"}),\n        ({\"token\": \"f\"}, {}, {\"token\": \"f\"}),\n        # Relevant keys is copied from second dict\n        ({}, {\"VAULT_CLI_PASSWORD\": \"h\"}, {\"password\": \"h\"}),\n        ({}, {\"VAULT_CLI_TOKEN\": \"i\"}, {\"token\": \"i\"}),\n        # Second dict has priority\n        ({\"password\": \"l\"}, {\"VAULT_CLI_PASSWORD\": \"m\"}, {\"password\": \"m\"}),\n        ({\"token\": \"n\"}, {\"VAULT_CLI_TOKEN\": \"o\"}, {\"token\": \"o\"}),\n    ],\n)\ndef test_extract_special_args(config, environ, expected):\n    result = cli.extract_special_args(config, environ)\n\n    assert set(result) == {\"password\", \"token\"}\n    # remove None\n    result = {key: value for key, value in result.items() if value is not None}\n\n    assert result == expected\n\n\ndef test_set_verbosity(mocker):\n    basic_config = mocker.patch(\"logging.basicConfig\")\n\n    cli.set_verbosity(1)\n\n    basic_config.assert_called_with(level=logging.INFO)\n\n\ndef test_dump_config(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--config-file=/dev/null\",\n            \"--base-path=mybase/\",\n            \"--token-file=-\",\n            \"dump-config\",\n        ],\n        input=\"some-token\",\n    )\n\n    expected_settings = settings.DEFAULTS._as_dict()\n    expected_settings.update(\n        {\"base_path\": \"mybase/\", \"token\": \"some-token\", \"verbose\": 0, \"umask\": \"0o066\"}\n    )\n\n    output = yaml.safe_load(result.output)\n\n    assert output == expected_settings\n\n\ndef test_delete_all(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\ny\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: y\",\n        \"Deleted 'foo/baz'\",\n    ]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0\n\n\ndef test_delete_all_cancel(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\nn\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: n\",\n        \"Aborted!\",\n    ]\n    assert vault_with_token.db == {\"foo/baz\": {\"value\": \"yo\"}}\n    assert result.exit_code != 0\n\n\ndef test_delete_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\", \"--force\"])\n\n    assert result.output.splitlines() == [\"Deleted 'foo/bar'\", \"Deleted 'foo/baz'\"]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0\n\n\ndef test_mv(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Move 'd/e' to 'a/e'\", \"Move 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_mv_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0\n\n\ndef test_mv_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0\n\n\ndef test_mv_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_mv_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Copy 'd/e' to 'a/e'\", \"Copy 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0\n\n\ndef test_cp_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0\n\n\ndef test_cp_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_cp_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0\n\n\ndef test_template_from_stdin(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli, [\"template\", \"-\"], input=\"Hello {{ vault('a/b').value }}\"\n    )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"\n\n\ndef test_template_from_file(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(mode=\"w+\") as fp:\n        fp.write(\"Hello {{ vault('a/b').value }}\")\n        fp.flush()\n        result = cli_runner.invoke(\n            cli.cli, [\"template\", fp.name], catch_exceptions=False\n        )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"\n\n\ndef test_template_from_file_with_include(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as template_file:\n        with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as include_file:\n            template_file.write(\n                \"Hello {{ vault('a/b').value }}\\n{% include('\"\n                + os.path.basename(include_file.name)\n                + \"') %}\"\n            )\n            template_file.flush()\n            include_file.write(\"Hello all\")\n            include_file.flush()\n\n            result = cli_runner.invoke(\n                cli.cli, [\"template\", template_file.name], catch_exceptions=False\n            )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\\nHello all\"\n\n\ndef test_lookup_token(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"lookup-token\"])\n\n    assert result.exit_code == 0\n    assert yaml.safe_load(result.stdout)[\"data\"][\"expire_time\"].startswith(\n        \"2100-01-01T00:00:00\"\n    )\n\n\ndef test_handle_errors(cli_runner):\n    @cli.handle_errors()\n    def inner():\n        raise exceptions.VaultException(\"foo\") from ValueError(\"bar\")\n\n    with pytest.raises(click.ClickException) as exc_info:\n        inner()\n\n    assert str(exc_info.value) == \"VaultException: foo\\nValueError: bar\"\n\n\ndef test_version(cli_runner):\n    result = cli_runner.invoke(cli.cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert result.stdout.startswith(\"vault-cli \" + vault_cli.__version__)\n    assert result.stdout.endswith(\"License: Apache Software License\\n\")\n\n\ndef test_ssh(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b:value\", \"--\", \"env\"])\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=None)\n    exec_command.assert_called_with(command=(\"env\",))\n\n\ndef test_ssh_passphrase(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\", \"passphrase\": \"d\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b:passphrase\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=\"d\")\n    exec_command.assert_called_with(command=(\"env\",))\n\n\ndef test_ssh_wrong_format_key(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b\", \"--\", \"env\"])\n\n    assert result.exit_code > 0\n\n\ndef test_ssh_wrong_format_passphrase(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code > 0\n\n\n@pytest.mark.parametrize(\"input, output\", [(\"022\", 0o22), (\"0o123\", 0o123)])\ndef test_parse_octal(input, output):\n    assert cli.parse_octal(input) == output\n\n\n@pytest.mark.parametrize(\n    \"input, output\",\n    [\n        (None, None),\n        (0o22, \"0o022\"),\n        (0o123, \"0o123\"),\n        (0o12345, \"0o12345\"),\n        (0, \"0o000\"),\n    ],\n)\ndef test_repr_octal(input, output):\n    assert cli.repr_octal(input) == output\n\n\ndef test_ensure_str():\n    assert cli.ensure_str(\"foo\", \"bar\") == \"foo\"\n\n\ndef test_ensure_str_wrong():\n    with pytest.raises(exceptions.VaultWrongType):\n        cli.ensure_str(1, \"bar\")\n\n\n@pytest.mark.parametrize(\n    \"input, output\",\n    [\n        (\"aa:bb=cc\", (\"aa\", \"bb\", \"cc\")),\n        (\"aa:bb\", (\"aa\", \"bb\", \"\")),\n        (\"aa=cc\", (\"aa\", \"\", \"cc\")),\n        (\"aa\", (\"aa\", \"\", \"\")),\n        (\":bb=cc\", (\"\", \"bb\", \"cc\")),\n        (\"=cc\", (\"\", \"\", \"cc\")),\n        (\":bb\", (\"\", \"bb\", \"\")),\n        (\"\", (\"\", \"\", \"\")),\n    ],\n)\ndef test_get_env_parts(input, output):\n    assert cli.get_env_parts(input) == output\n", "patch": "@@ -24,7 +24,6 @@ def test_options(cli_runner, mocker):\n             \"bla\",\n             \"--ca-bundle\",\n             \"yay\",\n-            \"--no-render\",\n             \"--login-cert\",\n             \"puc\",\n             \"--login-cert-key\",\n@@ -47,7 +46,6 @@ def test_options(cli_runner, mocker):\n     assert set(kwargs) == {\n         \"base_path\",\n         \"ca_bundle\",\n-        \"render\",\n         \"login_cert\",\n         \"login_cert_key\",\n         \"password\",\n@@ -66,7 +64,6 @@ def test_options(cli_runner, mocker):\n     assert kwargs[\"url\"] == \"https://foo\"\n     assert kwargs[\"username\"] == \"user\"\n     assert kwargs[\"verify\"] is True\n-    assert kwargs[\"render\"] is False\n \n \n @pytest.fixture", "file_path": "files/2021_12/199", "file_language": "py", "file_name": "tests/unit/test_cli.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_options(cli_runner, mocker):\n    client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n    mocker.patch(\n        \"vault_cli.settings.read_file\", side_effect=lambda x: \"content of {}\".format(x)\n    )\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--base-path\",\n            \"bla\",\n            \"--ca-bundle\",\n            \"yay\",\n            \"--login-cert\",\n            \"puc\",\n            \"--login-cert-key\",\n            \"prc\",\n            \"--password-file\",\n            \"b\",\n            \"--token-file\",\n            \"c\",\n            \"--url\",\n            \"https://foo\",\n            \"--username\",\n            \"user\",\n            \"--verify\",\n            \"list\",\n        ],\n    )\n\n    assert result.exit_code == 0, result.output\n    _, kwargs = client.call_args\n    assert set(kwargs) == {\n        \"base_path\",\n        \"ca_bundle\",\n        \"login_cert\",\n        \"login_cert_key\",\n        \"password\",\n        \"safe_write\",\n        \"token\",\n        \"url\",\n        \"username\",\n        \"verify\",\n    }\n    assert kwargs[\"base_path\"] == \"bla\"\n    assert kwargs[\"ca_bundle\"] == \"yay\"\n    assert kwargs[\"login_cert\"] == \"puc\"\n    assert kwargs[\"login_cert_key\"] == \"prc\"\n    assert kwargs[\"password\"] == \"content of b\"\n    assert kwargs[\"token\"] == \"content of c\"\n    assert kwargs[\"url\"] == \"https://foo\"\n    assert kwargs[\"username\"] == \"user\"\n    assert kwargs[\"verify\"] is True", "target": 0}, {"function": "def test_list(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo\": {\"value\": \"yay\"}, \"baz\": {\"value\": \"ho\"}}\n    result = cli_runner.invoke(cli.cli, [\"list\"])\n\n    assert result.output == \"baz\\nfoo\\n\"\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_yaml(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\", \"--yaml\"])\n\n    assert result.output == \"--- bar\\n...\\n\"\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_all_no_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"--no-flat\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a\": {\"baz\": {\"value\": \"bar\"}, \"foo\": {\"value\": \"yay\"}}\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_all_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a/baz\": {\"value\": \"bar\"},\n        \"a/foo\": {\"value\": \"yay\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_set(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr=b\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"attr\": \"b\"}}", "target": 0}, {"function": "def test_set_without_value(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr\"])\n\n    assert result.exit_code == 2\n    assert \"Expecting 'key=value' arguments.\" in result.stdout", "target": 0}, {"function": "def test_set_arg_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"value=-\"], input=\"yeah\")\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"yeah\"}}", "target": 0}, {"function": "def test_set_stdin(cli_runner, vault_with_token):\n    # Just checking that yaml and stdin are not incompatible\n    result = cli_runner.invoke(\n        cli.cli, [\"set\", \"--file=-\", \"a\"], input=yaml.safe_dump({\"b\": \"c\"})\n    )\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}", "target": 0}, {"function": "def test_set_with_both_prompt_and_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"value\", \"--file=-\", \"a\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_with_both_yaml_and_multiple_values(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--yaml\", \"a\", \"b\", \"c\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_prompt(cli_runner, mocker, vault_with_token):\n\n    prompt = mocker.patch(\"click.prompt\")\n    prompt.return_value = \"b\"\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"a\", \"value\"])\n    # test for prompt function\n    prompt.assert_called_with(\n        \"Please enter a value for key `value` of `a`\", hide_input=True\n    )\n\n    # Correctly stored secret.\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"b\"}}", "target": 0}, {"function": "def test_set_yaml(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--file=-\", \"a\"], input='{\"b\": \"c\"}')\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}", "target": 0}, {"function": "def test_set_mix_secrets_folders(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b/c\", \"value=d\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_set_mix_folders_secrets(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b\", \"value=c\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b/c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_set_all(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a/b: {\"c\": \"d\"}\"\"\")\n\n    assert result.exit_code == 0\n    assert result.stdout.strip() == \"Done\"\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_set_all_wrong_type(cli_runner, vault_with_token):\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"[1, 2, 3]\"\"\")\n    assert result.exit_code != 0\n    error = \"Error: Mapping expected format is a mapping of paths to secret objects\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"set-all\", \"--no-force\"], input=\"\"\"a/b: {\"c\": \"e\"}\"\"\"\n    )\n    assert result.exit_code != 0\n    error = (\n        \"Error: Secret already exists at a/b for key: c\\nUse -f to force overwriting\"\n    )\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_set_all_mix(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a: {\"e\": \"f\"}\"\"\")\n\n    assert result.exit_code != 0\n    error = \"Error: Cannot create a secret at 'a' because it is already a folder containing a/b\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_delete(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a\": {\"value\": \"foo\"}, \"b\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"delete\", \"a\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"b\": {\"value\": \"bar\"}}", "target": 0}, {"function": "def test_env(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ_VALUE\"] == \"yo\"", "target": 0}, {"function": "def test_env_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    exec_command.assert_not_called()", "target": 0}, {"function": "def test_env_envvar_format_error(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \":foo\", \"--\", \"echo\", \"yay\"]\n    )\n\n    assert result.exit_code != 0\n    assert \"Cannot omit the path if a filter key is provided\" in result.output", "target": 0}, {"function": "def test_env_error_force_sub_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()", "target": 0}, {"function": "def test_env_error_force_main_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_list_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()", "target": 0}, {"function": "def test_env_prefix(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo=prefix\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"PREFIX_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_USER\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_PASSWORD\"] == \"xxx\"", "target": 0}, {"function": "def test_env_filter_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(\n        cli.cli,\n        [\n            \"env\",\n            \"--envvar\",\n            \"foo/baz:user=MYNAME\",\n            \"--envvar\",\n            \"foo/baz:password\",\n            \"--\",\n            \"echo\",\n            \"yay\",\n        ],\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"MYNAME\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PASSWORD\"] == \"xxx\"", "target": 0}, {"function": "def test_env_omit_single_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"password\": \"yo\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--omit-single-key\", \"--\", \"echo\", \"yay\"]\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ\"] == \"yo\"", "target": 0}, {"function": "def test_env_file(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", f\"foo/bar:value={path}\", \"--\", \"echo\", \"yay\"]\n    )\n    assert path.read_text() == \"yay\\n\"", "target": 0}, {"function": "def test_env_file_format_error(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", \"foo/bar\", \"--\", \"echo\", \"yay\"]\n    )\n    assert result.exit_code != 0\n    assert \"expects both a vault path and a filesystem path\" in result.output", "target": 0}, {"function": "def test_env_file_yaml(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli,\n        [\"env\", \"--file\", f\"foo/bar={path}\", \"--\", \"echo\", \"yay\"],\n    )\n    assert path.read_text() == \"---\\nvalue: yay\\n\"", "target": 0}, {"function": "def test_main(environ, mocker):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n\n    cli.main()\n\n    mock_cli.assert_called_with()\n    assert set({\"LC_ALL\": \"C.UTF-8\", \"LANG\": \"C.UTF-8\"}.items()) <= set(environ.items())", "target": 0}, {"function": "def test_main_askpass(environ, mocker, capsys):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n    environ.update({\"VAULT_CLI_SSH_PASSPHRASE\": \"foo\"})\n\n    cli.main()\n\n    out = capsys.readouterr().out.strip()\n    assert out == \"foo\"\n\n    mock_cli.assert_not_called()", "target": 0}, {"function": "def test_load_config_no_config(mocker):\n    ctx = mocker.Mock()\n    cli.load_config(ctx, None, \"no\")\n\n    assert ctx.default_map == {}", "target": 0}, {"function": "def test_set_verbosity(mocker):\n    basic_config = mocker.patch(\"logging.basicConfig\")\n\n    cli.set_verbosity(1)\n\n    basic_config.assert_called_with(level=logging.INFO)", "target": 0}, {"function": "def test_dump_config(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--config-file=/dev/null\",\n            \"--base-path=mybase/\",\n            \"--token-file=-\",\n            \"dump-config\",\n        ],\n        input=\"some-token\",\n    )\n\n    expected_settings = settings.DEFAULTS._as_dict()\n    expected_settings.update(\n        {\"base_path\": \"mybase/\", \"token\": \"some-token\", \"verbose\": 0, \"umask\": \"0o066\"}\n    )\n\n    output = yaml.safe_load(result.output)\n\n    assert output == expected_settings", "target": 0}, {"function": "def test_delete_all(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\ny\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: y\",\n        \"Deleted 'foo/baz'\",\n    ]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_delete_all_cancel(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\nn\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: n\",\n        \"Aborted!\",\n    ]\n    assert vault_with_token.db == {\"foo/baz\": {\"value\": \"yo\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_delete_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\", \"--force\"])\n\n    assert result.output.splitlines() == [\"Deleted 'foo/bar'\", \"Deleted 'foo/baz'\"]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Move 'd/e' to 'a/e'\", \"Move 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_mv_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_mv_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Copy 'd/e' to 'a/e'\", \"Copy 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_cp_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_cp_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_template_from_stdin(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli, [\"template\", \"-\"], input=\"Hello {{ vault('a/b').value }}\"\n    )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"", "target": 0}, {"function": "def test_template_from_file(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(mode=\"w+\") as fp:\n        fp.write(\"Hello {{ vault('a/b').value }}\")\n        fp.flush()\n        result = cli_runner.invoke(\n            cli.cli, [\"template\", fp.name], catch_exceptions=False\n        )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"", "target": 0}, {"function": "def test_template_from_file_with_include(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as template_file:\n        with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as include_file:\n            template_file.write(\n                \"Hello {{ vault('a/b').value }}\\n{% include('\"\n                + os.path.basename(include_file.name)\n                + \"') %}\"\n            )\n            template_file.flush()\n            include_file.write(\"Hello all\")\n            include_file.flush()\n\n            result = cli_runner.invoke(\n                cli.cli, [\"template\", template_file.name], catch_exceptions=False\n            )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\\nHello all\"", "target": 0}, {"function": "def test_lookup_token(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"lookup-token\"])\n\n    assert result.exit_code == 0\n    assert yaml.safe_load(result.stdout)[\"data\"][\"expire_time\"].startswith(\n        \"2100-01-01T00:00:00\"\n    )", "target": 0}, {"function": "def test_handle_errors(cli_runner):\n    @cli.handle_errors()\n    def inner():\n        raise exceptions.VaultException(\"foo\") from ValueError(\"bar\")\n\n    with pytest.raises(click.ClickException) as exc_info:\n        inner()\n\n    assert str(exc_info.value) == \"VaultException: foo\\nValueError: bar\"", "target": 0}, {"function": "def test_version(cli_runner):\n    result = cli_runner.invoke(cli.cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert result.stdout.startswith(\"vault-cli \" + vault_cli.__version__)\n    assert result.stdout.endswith(\"License: Apache Software License\\n\")", "target": 0}, {"function": "def test_ssh(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b:value\", \"--\", \"env\"])\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=None)\n    exec_command.assert_called_with(command=(\"env\",))", "target": 0}, {"function": "def test_ssh_passphrase(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\", \"passphrase\": \"d\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b:passphrase\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=\"d\")\n    exec_command.assert_called_with(command=(\"env\",))", "target": 0}, {"function": "def test_ssh_wrong_format_key(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b\", \"--\", \"env\"])\n\n    assert result.exit_code > 0", "target": 0}, {"function": "def test_ssh_wrong_format_passphrase(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code > 0", "target": 0}, {"function": "def test_ensure_str():\n    assert cli.ensure_str(\"foo\", \"bar\") == \"foo\"", "target": 0}, {"function": "def test_ensure_str_wrong():\n    with pytest.raises(exceptions.VaultWrongType):\n        cli.ensure_str(1, \"bar\")", "target": 0}], "function_after": [{"function": "def test_options(cli_runner, mocker):\n    client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n    mocker.patch(\n        \"vault_cli.settings.read_file\", side_effect=lambda x: \"content of {}\".format(x)\n    )\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--base-path\",\n            \"bla\",\n            \"--ca-bundle\",\n            \"yay\",\n            \"--login-cert\",\n            \"puc\",\n            \"--login-cert-key\",\n            \"prc\",\n            \"--password-file\",\n            \"b\",\n            \"--token-file\",\n            \"c\",\n            \"--url\",\n            \"https://foo\",\n            \"--username\",\n            \"user\",\n            \"--verify\",\n            \"list\",\n        ],\n    )\n\n    assert result.exit_code == 0, result.output\n    _, kwargs = client.call_args\n    assert set(kwargs) == {\n        \"base_path\",\n        \"ca_bundle\",\n        \"login_cert\",\n        \"login_cert_key\",\n        \"password\",\n        \"safe_write\",\n        \"token\",\n        \"url\",\n        \"username\",\n        \"verify\",\n    }\n    assert kwargs[\"base_path\"] == \"bla\"\n    assert kwargs[\"ca_bundle\"] == \"yay\"\n    assert kwargs[\"login_cert\"] == \"puc\"\n    assert kwargs[\"login_cert_key\"] == \"prc\"\n    assert kwargs[\"password\"] == \"content of b\"\n    assert kwargs[\"token\"] == \"content of c\"\n    assert kwargs[\"url\"] == \"https://foo\"\n    assert kwargs[\"username\"] == \"user\"\n    assert kwargs[\"verify\"] is True", "target": 0}, {"function": "def test_list(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo\": {\"value\": \"yay\"}, \"baz\": {\"value\": \"ho\"}}\n    result = cli_runner.invoke(cli.cli, [\"list\"])\n\n    assert result.output == \"baz\\nfoo\\n\"\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_yaml(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"get\", \"a\", \"value\", \"--yaml\"])\n\n    assert result.output == \"--- bar\\n...\\n\"\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_all_no_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"--no-flat\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a\": {\"baz\": {\"value\": \"bar\"}, \"foo\": {\"value\": \"yay\"}}\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_get_all_flat(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/baz\": {\"value\": \"bar\"}, \"a/foo\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(cli.cli, [\"get-all\", \"a\"])\n\n    assert yaml.safe_load(result.output) == {\n        \"a/baz\": {\"value\": \"bar\"},\n        \"a/foo\": {\"value\": \"yay\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_set(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr=b\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"attr\": \"b\"}}", "target": 0}, {"function": "def test_set_without_value(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"attr\"])\n\n    assert result.exit_code == 2\n    assert \"Expecting 'key=value' arguments.\" in result.stdout", "target": 0}, {"function": "def test_set_arg_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a\", \"value=-\"], input=\"yeah\")\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"yeah\"}}", "target": 0}, {"function": "def test_set_stdin(cli_runner, vault_with_token):\n    # Just checking that yaml and stdin are not incompatible\n    result = cli_runner.invoke(\n        cli.cli, [\"set\", \"--file=-\", \"a\"], input=yaml.safe_dump({\"b\": \"c\"})\n    )\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}", "target": 0}, {"function": "def test_set_with_both_prompt_and_stdin(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"value\", \"--file=-\", \"a\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_with_both_yaml_and_multiple_values(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--yaml\", \"a\", \"b\", \"c\"])\n\n    assert result.exit_code != 0\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_prompt(cli_runner, mocker, vault_with_token):\n\n    prompt = mocker.patch(\"click.prompt\")\n    prompt.return_value = \"b\"\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--prompt\", \"a\", \"value\"])\n    # test for prompt function\n    prompt.assert_called_with(\n        \"Please enter a value for key `value` of `a`\", hide_input=True\n    )\n\n    # Correctly stored secret.\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"value\": \"b\"}}", "target": 0}, {"function": "def test_set_yaml(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"--file=-\", \"a\"], input='{\"b\": \"c\"}')\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"a\": {\"b\": \"c\"}}", "target": 0}, {"function": "def test_set_mix_secrets_folders(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b/c\", \"value=d\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_set_mix_folders_secrets(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"set\", \"a/b\", \"value=c\"])\n\n    assert result.exit_code == 1\n    assert vault_with_token.db == {\"a/b/c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_set_all(cli_runner, vault_with_token):\n\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a/b: {\"c\": \"d\"}\"\"\")\n\n    assert result.exit_code == 0\n    assert result.stdout.strip() == \"Done\"\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_set_all_wrong_type(cli_runner, vault_with_token):\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"[1, 2, 3]\"\"\")\n    assert result.exit_code != 0\n    error = \"Error: Mapping expected format is a mapping of paths to secret objects\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {}", "target": 0}, {"function": "def test_set_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"set-all\", \"--no-force\"], input=\"\"\"a/b: {\"c\": \"e\"}\"\"\"\n    )\n    assert result.exit_code != 0\n    error = (\n        \"Error: Secret already exists at a/b for key: c\\nUse -f to force overwriting\"\n    )\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_set_all_mix(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"c\": \"d\"}}\n    result = cli_runner.invoke(cli.cli, [\"set-all\"], input=\"\"\"a: {\"e\": \"f\"}\"\"\")\n\n    assert result.exit_code != 0\n    error = \"Error: Cannot create a secret at 'a' because it is already a folder containing a/b\"\n    assert result.stdout.strip() == error\n    assert vault_with_token.db == {\"a/b\": {\"c\": \"d\"}}", "target": 0}, {"function": "def test_delete(cli_runner, vault_with_token):\n\n    vault_with_token.db = {\"a\": {\"value\": \"foo\"}, \"b\": {\"value\": \"bar\"}}\n    result = cli_runner.invoke(cli.cli, [\"delete\", \"a\"])\n\n    assert result.exit_code == 0\n    assert vault_with_token.db == {\"b\": {\"value\": \"bar\"}}", "target": 0}, {"function": "def test_env(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ_VALUE\"] == \"yo\"", "target": 0}, {"function": "def test_env_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo\", \"--\", \"echo\", \"yay\"])\n\n    exec_command.assert_not_called()", "target": 0}, {"function": "def test_env_envvar_format_error(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \":foo\", \"--\", \"echo\", \"yay\"]\n    )\n\n    assert result.exit_code != 0\n    assert \"Cannot omit the path if a filter key is provided\" in result.output", "target": 0}, {"function": "def test_env_error_force_sub_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_get_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()", "target": 0}, {"function": "def test_env_error_force_main_error(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.forbidden_list_paths.add(\"foo\")\n\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--force\", \"--\", \"echo\", \"yay\"]\n    )\n\n    exec_command.assert_called()", "target": 0}, {"function": "def test_env_prefix(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(cli.cli, [\"env\", \"--envvar\", \"foo=prefix\", \"--\", \"echo\", \"yay\"])\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"PREFIX_BAR_VALUE\"] == \"yay\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_USER\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PREFIX_BAZ_PASSWORD\"] == \"xxx\"", "target": 0}, {"function": "def test_env_filter_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\n        \"foo/bar\": {\"value\": \"yay\"},\n        \"foo/baz\": {\"user\": \"yo\", \"password\": \"xxx\"},\n    }\n    cli_runner.invoke(\n        cli.cli,\n        [\n            \"env\",\n            \"--envvar\",\n            \"foo/baz:user=MYNAME\",\n            \"--envvar\",\n            \"foo/baz:password\",\n            \"--\",\n            \"echo\",\n            \"yay\",\n        ],\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"MYNAME\"] == \"yo\"\n    assert kwargs[\"environment\"][\"PASSWORD\"] == \"xxx\"", "target": 0}, {"function": "def test_env_omit_single_key(cli_runner, vault_with_token, mocker):\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"password\": \"yo\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--envvar\", \"foo\", \"--omit-single-key\", \"--\", \"echo\", \"yay\"]\n    )\n\n    _, kwargs = exec_command.call_args\n    assert kwargs[\"command\"] == (\"echo\", \"yay\")\n    assert kwargs[\"environment\"][\"FOO_BAR\"] == \"yay\"\n    assert kwargs[\"environment\"][\"FOO_BAZ\"] == \"yo\"", "target": 0}, {"function": "def test_env_file(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", f\"foo/bar:value={path}\", \"--\", \"echo\", \"yay\"]\n    )\n    assert path.read_text() == \"yay\\n\"", "target": 0}, {"function": "def test_env_file_format_error(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    result = cli_runner.invoke(\n        cli.cli, [\"env\", \"--file\", \"foo/bar\", \"--\", \"echo\", \"yay\"]\n    )\n    assert result.exit_code != 0\n    assert \"expects both a vault path and a filesystem path\" in result.output", "target": 0}, {"function": "def test_env_file_yaml(cli_runner, vault_with_token, mocker, tmp_path):\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    path = tmp_path / \"foo\"\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}}\n    cli_runner.invoke(\n        cli.cli,\n        [\"env\", \"--file\", f\"foo/bar={path}\", \"--\", \"echo\", \"yay\"],\n    )\n    assert path.read_text() == \"---\\nvalue: yay\\n\"", "target": 0}, {"function": "def test_main(environ, mocker):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n\n    cli.main()\n\n    mock_cli.assert_called_with()\n    assert set({\"LC_ALL\": \"C.UTF-8\", \"LANG\": \"C.UTF-8\"}.items()) <= set(environ.items())", "target": 0}, {"function": "def test_main_askpass(environ, mocker, capsys):\n    mock_cli = mocker.patch(\"vault_cli.cli.cli\")\n    environ.update({\"VAULT_CLI_SSH_PASSPHRASE\": \"foo\"})\n\n    cli.main()\n\n    out = capsys.readouterr().out.strip()\n    assert out == \"foo\"\n\n    mock_cli.assert_not_called()", "target": 0}, {"function": "def test_load_config_no_config(mocker):\n    ctx = mocker.Mock()\n    cli.load_config(ctx, None, \"no\")\n\n    assert ctx.default_map == {}", "target": 0}, {"function": "def test_set_verbosity(mocker):\n    basic_config = mocker.patch(\"logging.basicConfig\")\n\n    cli.set_verbosity(1)\n\n    basic_config.assert_called_with(level=logging.INFO)", "target": 0}, {"function": "def test_dump_config(cli_runner):\n    result = cli_runner.invoke(\n        cli.cli,\n        [\n            \"--config-file=/dev/null\",\n            \"--base-path=mybase/\",\n            \"--token-file=-\",\n            \"dump-config\",\n        ],\n        input=\"some-token\",\n    )\n\n    expected_settings = settings.DEFAULTS._as_dict()\n    expected_settings.update(\n        {\"base_path\": \"mybase/\", \"token\": \"some-token\", \"verbose\": 0, \"umask\": \"0o066\"}\n    )\n\n    output = yaml.safe_load(result.output)\n\n    assert output == expected_settings", "target": 0}, {"function": "def test_delete_all(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\ny\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: y\",\n        \"Deleted 'foo/baz'\",\n    ]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_delete_all_cancel(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\"], input=\"y\\nn\")\n\n    assert result.output.splitlines() == [\n        \"Delete 'foo/bar'? [y/N]: y\",\n        \"Deleted 'foo/bar'\",\n        \"Delete 'foo/baz'? [y/N]: n\",\n        \"Aborted!\",\n    ]\n    assert vault_with_token.db == {\"foo/baz\": {\"value\": \"yo\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_delete_all_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"foo/bar\": {\"value\": \"yay\"}, \"foo/baz\": {\"value\": \"yo\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"delete-all\", \"--force\"])\n\n    assert result.output.splitlines() == [\"Deleted 'foo/bar'\", \"Deleted 'foo/baz'\"]\n    assert vault_with_token.db == {}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Move 'd/e' to 'a/e'\", \"Move 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_mv_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_mv_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_mv_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"mv\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp(cli_runner, vault_with_token):\n    vault_with_token.db = {\n        \"a/b\": {\"value\": \"c\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert result.output.splitlines() == [\"Copy 'd/e' to 'a/e'\", \"Copy 'd/g' to 'a/g'\"]\n    assert vault_with_token.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/e\": {\"value\": \"f\"},\n        \"a/g\": {\"value\": \"h\"},\n        \"d/e\": {\"value\": \"f\"},\n        \"d/g\": {\"value\": \"h\"},\n    }\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_cp_overwrite_safe(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    vault_with_token.safe_write = True\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp_overwrite_force(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d/b\": {\"value\": \"f\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\", \"--force\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"f\"}, \"d/b\": {\"value\": \"f\"}}\n    assert result.exit_code == 0", "target": 0}, {"function": "def test_cp_mix_folders_secrets(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"d\", \"a\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_cp_mix_secrets_folders(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"cp\", \"a\", \"d\"])\n\n    assert vault_with_token.db == {\"a/b\": {\"value\": \"c\"}, \"d\": {\"value\": \"e\"}}\n    assert result.exit_code != 0", "target": 0}, {"function": "def test_template_from_stdin(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli, [\"template\", \"-\"], input=\"Hello {{ vault('a/b').value }}\"\n    )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"", "target": 0}, {"function": "def test_template_from_file(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(mode=\"w+\") as fp:\n        fp.write(\"Hello {{ vault('a/b').value }}\")\n        fp.flush()\n        result = cli_runner.invoke(\n            cli.cli, [\"template\", fp.name], catch_exceptions=False\n        )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\"", "target": 0}, {"function": "def test_template_from_file_with_include(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as template_file:\n        with tempfile.NamedTemporaryFile(dir=os.getcwd(), mode=\"w+\") as include_file:\n            template_file.write(\n                \"Hello {{ vault('a/b').value }}\\n{% include('\"\n                + os.path.basename(include_file.name)\n                + \"') %}\"\n            )\n            template_file.flush()\n            include_file.write(\"Hello all\")\n            include_file.flush()\n\n            result = cli_runner.invoke(\n                cli.cli, [\"template\", template_file.name], catch_exceptions=False\n            )\n\n    assert result.exit_code == 0\n    assert result.stdout == \"Hello c\\nHello all\"", "target": 0}, {"function": "def test_lookup_token(cli_runner, vault_with_token):\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"lookup-token\"])\n\n    assert result.exit_code == 0\n    assert yaml.safe_load(result.stdout)[\"data\"][\"expire_time\"].startswith(\n        \"2100-01-01T00:00:00\"\n    )", "target": 0}, {"function": "def test_handle_errors(cli_runner):\n    @cli.handle_errors()\n    def inner():\n        raise exceptions.VaultException(\"foo\") from ValueError(\"bar\")\n\n    with pytest.raises(click.ClickException) as exc_info:\n        inner()\n\n    assert str(exc_info.value) == \"VaultException: foo\\nValueError: bar\"", "target": 0}, {"function": "def test_version(cli_runner):\n    result = cli_runner.invoke(cli.cli, [\"--version\"])\n\n    assert result.exit_code == 0\n    assert result.stdout.startswith(\"vault-cli \" + vault_cli.__version__)\n    assert result.stdout.endswith(\"License: Apache Software License\\n\")", "target": 0}, {"function": "def test_ssh(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b:value\", \"--\", \"env\"])\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=None)\n    exec_command.assert_called_with(command=(\"env\",))", "target": 0}, {"function": "def test_ssh_passphrase(cli_runner, vault_with_token, mocker):\n    ensure = mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    add = mocker.patch(\"vault_cli.ssh.add_key\")\n    exec_command = mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\", \"passphrase\": \"d\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b:passphrase\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code == 0\n    ensure.assert_called_with()\n    add.assert_called_with(key=\"c\", passphrase=\"d\")\n    exec_command.assert_called_with(command=(\"env\",))", "target": 0}, {"function": "def test_ssh_wrong_format_key(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(cli.cli, [\"ssh\", \"--key\", \"a/b\", \"--\", \"env\"])\n\n    assert result.exit_code > 0", "target": 0}, {"function": "def test_ssh_wrong_format_passphrase(cli_runner, vault_with_token, mocker):\n    mocker.patch(\"vault_cli.ssh.ensure_agent\")\n    mocker.patch(\"vault_cli.ssh.add_key\")\n    mocker.patch(\"vault_cli.environment.exec_command\")\n\n    vault_with_token.db = {\"a/b\": {\"value\": \"c\"}}\n\n    result = cli_runner.invoke(\n        cli.cli,\n        [\"ssh\", \"--key\", \"a/b:value\", \"--passphrase\", \"a/b\", \"--\", \"env\"],\n    )\n\n    assert result.exit_code > 0", "target": 0}, {"function": "def test_ensure_str():\n    assert cli.ensure_str(\"foo\", \"bar\") == \"foo\"", "target": 0}, {"function": "def test_ensure_str_wrong():\n    with pytest.raises(exceptions.VaultWrongType):\n        cli.ensure_str(1, \"bar\")", "target": 0}]}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/tests%2Funit%2Ftest_client_base.py", "code": "import pytest\n\nfrom vault_cli import client, exceptions\n\n\ndef test_get_client(mocker):\n    mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"url\": \"yay\"}\n    )\n    vault_client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n\n    result = client.get_client(yo=True)\n\n    vault_client.assert_called_with(yo=True, url=\"yay\")\n    assert vault_client.return_value == result\n\n\ndef test_get_client_class():\n    assert client.get_client_class() is client.VaultClient\n\n\ndef test_vault_client_base_call_init_client():\n    called_with = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            called_with.update(kwargs)\n\n        def _authenticate_certificate(self, *args, **kwargs):\n            pass\n\n    TestVaultClient(verify=False, url=\"yay\", login_cert=\"a\", login_cert_key=\"b\").auth()\n\n    assert called_with == {\n        \"verify\": False,\n        \"url\": \"yay\",\n        \"login_cert\": \"a\",\n        \"login_cert_key\": \"b\",\n    }\n\n\n@pytest.mark.parametrize(\n    \"test_kwargs, expected\",\n    [\n        ({\"token\": \"yay\"}, [\"token\", \"yay\"]),\n        ({\"username\": \"a\", \"password\": \"b\"}, [\"userpass\", \"a\", \"b\"]),\n        ({\"login_cert\": \"a\", \"login_cert_key\": \"b\"}, [\"certificate\"]),\n    ],\n)\ndef test_vault_client_base_authenticate(test_kwargs, expected):\n    auth_params = []\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            pass\n\n        def _authenticate_token(self, token):\n            auth_params.extend([\"token\", token])\n\n        def _authenticate_certificate(self):\n            auth_params.extend([\"certificate\"])\n\n        def _authenticate_userpass(self, username, password):\n            auth_params.extend([\"userpass\", username, password])\n\n    TestVaultClient(**test_kwargs).auth()\n\n    assert auth_params == expected\n\n\ndef test_vault_client_base_username_without_password(vault):\n\n    vault.username = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\ndef test_vault_client_base_login_cert_without_key(vault):\n    vault.login_cert = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\ndef test_vault_client_base_no_auth(vault):\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\n@pytest.mark.parametrize(\n    \"verify, ca_bundle, expected\",\n    [(True, \"yay\", \"yay\"), (True, None, True), (False, \"yay\", False)],\n)\ndef test_vault_client_ca_bundle_verify(mocker, verify, ca_bundle, expected):\n\n    session_kwargs = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            session_kwargs.update(kwargs)\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        TestVaultClient(verify=verify, ca_bundle=ca_bundle).auth()\n\n    assert session_kwargs[\"verify\"] == expected\n\n\ndef test_vault_client_base_browse_recursive_secrets(vault):\n    vault.db = {\"a\": {\"value\": \"secret-a\"}, \"b/c\": {\"value\": \"secret-bc\"}}\n\n    result = list(vault._browse_recursive_secrets(\"\"))\n\n    assert result == [\"a\", \"b/c\"]\n\n\ndef test_vault_client_base_browse_recursive_secrets_single_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"secret-a\"}}\n\n    result = list(vault._browse_recursive_secrets(\"a\"))\n\n    assert result == [\"a\"]\n\n\ndef test_vault_client_base_get_all_secrets(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n    result = vault.get_all_secrets(\"a/\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n\ndef test_vault_client_base_get_all_secrets_flat(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}}\n\n\n@pytest.mark.parametrize(\n    \"input, expected\",\n    [\n        (\"a\", {\"a/c\": {\"value\": \"secret-ac\"}}),\n        (\"b\", {\"b\": {\"value\": \"secret-b\"}}),\n        (\"a/\", {\"a/c\": {\"value\": \"secret-ac\"}}),\n    ],\n)\ndef test_vault_client_base_get_secrets(vault, input, expected):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_secrets(input)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"input, expected\",\n    [(\"a\", {\"c\": {\"value\": \"secret-ac\"}}), (\"b\", {\"\": {\"value\": \"secret-b\"}})],\n)\ndef test_vault_client_base_get_secrets_relative(vault, input, expected):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_secrets(input, relative=True)\n\n    assert result == expected\n\n\ndef test_vault_client_base_delete_all_secrets_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\", generator=True)\n\n    assert next(result) == \"a/c\"\n\n    assert vault.db == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    assert next(result) == \"b\"\n\n    assert vault.db == {\"b\": {\"value\": \"secret-b\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_delete_all_secrets_no_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\")\n\n    assert result == [\"a/c\", \"b\"]\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_delete_all_secrets_trailing_slash(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}}\n\n    assert vault.delete_all_secrets(\"a/\") == [\"a/c\"]\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_context_manager(vault):\n\n    with vault as c:\n        assert c is vault\n\n\ndef test_vault_client_set_secret(vault):\n\n    vault.set_secret(\"a/b\", {\"name\": \"value\"})\n\n    assert vault.db == {\"a/b\": {\"name\": \"value\"}}\n\n\n@pytest.mark.parametrize(\n    \"safe_write, force\", [(True, False), (True, None), (False, False)]\n)\ndef test_vault_client_set_secret_overwrite_invalid(vault, safe_write, force):\n\n    vault.db = {\"a/b\": {\"value\": \"d\"}}\n    vault.safe_write = safe_write\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"value\": \"c\"}, force=force, update=False)\n\n    assert vault.db == {\"a/b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_set_secret_with_update(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    vault.set_secret(\"a/b\", {\"B\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\", \"B\": \"BB\"}}\n\n\ndef test_vault_client_set_secret_with_update_overwrite_invalid(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"A\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\"}}\n\n\n@pytest.mark.parametrize(\n    \"safe_write, force, value\",\n    [(True, True, \"c\"), (False, None, \"c\"), (True, None, \"d\")],\n)\ndef test_vault_client_set_secret_overwrite_valid(vault, safe_write, force, value):\n\n    vault.db = {\"a/b\": {\"value\": \"d\"}}\n    vault.safe_write = safe_write\n\n    vault.set_secret(\"a/b\", {\"value\": value}, force=force)\n\n    assert vault.db == {\"a/b\": {\"value\": value}}\n\n\ndef test_vault_client_set_secret_when_there_are_existing_secrets_beneath_path(vault):\n\n    vault.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"e\"})\n\n    assert vault.db == {\"a/b/c\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_set_secret_when_a_parent_is_an_existing_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"d\"})\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_set_secret_read_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_set_secret_list_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_list_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_set_secret_read_parent_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_move_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.move_secrets(\"a\", \"d\")\n\n    assert vault.db == {\"d/b\": {\"value\": \"c\"}, \"d/d\": {\"value\": \"e\"}}\n\n\ndef test_vault_client_move_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.move_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"f/d\": {\"value\": \"e\"}}\n\n\ndef test_vault_client_move_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.move_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_move_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.move_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"b\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_copy_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.copy_secrets(\"a\", \"d\")\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"d/b\": {\"value\": \"c\"},\n        \"d/d\": {\"value\": \"e\"},\n    }\n\n\ndef test_vault_client_copy_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.copy_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\n        \"f/b\": {\"value\": \"c\"},\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n    }\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"f/b\": {\"value\": \"c\"},\n        \"f/d\": {\"value\": \"e\"},\n    }\n\n\ndef test_vault_client_copy_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.copy_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_copy_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.copy_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_base_render_template(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}}\n\n    assert vault.render_template(\"Hello {{ vault('a/b').value }}\") == \"Hello c\"\n\n\n@pytest.mark.parametrize(\"template\", [\"Hello {{ vault('a/b') }}\", \"Hello {{\"])\ndef test_vault_client_base_render_template_path_not_found(vault, template):\n    with pytest.raises(exceptions.VaultRenderTemplateError):\n        vault.render_template(template)\n\n\n@pytest.mark.parametrize(\n    \"vault_contents, expected\",\n    [\n        # Secret is not a template\n        ({\"a\": {\"value\": \"b\"}}, {\"value\": \"b\"}),\n        # Secret not a string\n        ({\"a\": {\"value\": [\"yay\"]}}, {\"value\": [\"yay\"]}),\n    ],\n)\ndef test_vault_client_base_get_secret(vault, vault_contents, expected):\n    vault.db = vault_contents\n\n    assert vault.get_secret(\"a\") == expected\n\n\ndef test_vault_client_base_get_secret_multiple_keys(vault):\n    vault.db = {\"rabbitmq/creds/role\": {\"username\": \"foo\", \"password\": \"bar\"}}\n    assert vault.get_secret(\"rabbitmq/creds/role\") == {\n        \"username\": \"foo\",\n        \"password\": \"bar\",\n    }\n\n\ndef test_vault_client_base_get_secret_not_found(vault):\n    vault.db = {}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"not-existing\")\n\n\ndef test_vault_client_base_get_secret_missing_key(vault):\n    vault.db = {\"a\": {\"password\": \"xxx\"}}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"a\", key=\"username\")\n\n\ndef test_vault_client_base_lookup_token(vault):\n    assert vault.lookup_token() == {\"data\": {\"expire_time\": \"2100-01-01T00:00:00\"}}\n\n\ndef test_vault_client_base_get_secrets_error(vault, caplog):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_get_paths = {\"c\"}\n\n    assert vault.get_secrets(\"\") == {\n        \"a\": {\"value\": \"b\"},\n        \"c\": {},\n    }\n    assert caplog.record_tuples[0] == (\n        \"vault_cli.client\",\n        40,\n        \"VaultForbidden: Insufficient access for interacting with the requested \"\n        \"secret\",\n    )\n\n\ndef test_vault_client_base_get_secrets_list_forbidden(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_list_paths = {\"c\"}\n\n    assert vault.get_secrets(\"c\") == {\"c\": {\"value\": \"d\"}}\n\n\n@pytest.mark.parametrize(\n    \"method, params, expected\",\n    [\n        (\"get_secret\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"get_secret\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\"delete_secret\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"delete_secret\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\"list_secrets\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"list_secrets\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\n            \"set_secret\",\n            [\"foo\", {\"value\": \"value\"}],\n            {\"path\": \"/base/foo\", \"secret\": {\"value\": \"value\"}},\n        ),\n        (\n            \"set_secret\",\n            [\"/foo\", {\"value\": \"value\"}],\n            {\"path\": \"/foo\", \"secret\": {\"value\": \"value\"}},\n        ),\n    ],\n)\ndef test_vault_client_base_absolute_path(vault, mocker, method, params, expected):\n    mocked = mocker.patch(f\"vault_cli.testing.TestVaultClient._{method}\")\n    vault.base_path = \"base/\"\n\n    getattr(vault, method)(*params)\n    mocked.assert_called_with(**expected)\n\n\n@pytest.mark.parametrize(\"path, expected\", [(\"foo\", \"/base/foo\"), (\"/foo\", \"/foo\")])\ndef test_vault_client_base_build_full_path(vault, path, expected):\n    vault.base_path = \"base/\"\n    assert vault._build_full_path(path) == expected\n\n\n@pytest.mark.parametrize(\n    \"path, expected\",\n    [\n        (\"foo\", \"/foo/\"),\n        (\"foo/\", \"/foo/\"),\n        (\"foo//\", \"/foo/\"),\n        (\"/foo\", \"/foo/\"),\n        (\"/foo/\", \"/foo/\"),\n        (\"/foo//\", \"/foo/\"),\n    ],\n)\ndef test_vault_client_base_base_path(vault, path, expected):\n    vault.base_path = path\n    assert vault.base_path == expected\n\n\ndef test_vault_client_base_get_secret_implicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    vault.db = {\"a\": {\"value\": \"c\"}}\n    # Value was cached\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n\n\ndef test_vault_client_base_get_secret_explicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    with vault:\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n        vault.db = {\"a\": {\"value\": \"c\"}}\n        # Value not updated\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    assert vault.get_secret(\"a\") == {\"value\": \"c\"}\n\n\ndef test_vault_client_base_set_secrets(vault):\n    secrets = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\"}}\n    with vault:\n        vault.set_secrets(secrets)\n    assert vault.db == secrets\n\n\ndef test_vault_client_base_set_secrets_update(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, update=True)\n    assert vault.db == {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\", \"i\": \"j\"}}\n\n\ndef test_vault_client_base_set_secrets_force(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, force=False)\n", "code_before": "import pytest\n\nfrom vault_cli import client, exceptions\n\n\ndef test_get_client(mocker):\n    mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"url\": \"yay\"}\n    )\n    vault_client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n\n    result = client.get_client(yo=True)\n\n    vault_client.assert_called_with(yo=True, url=\"yay\")\n    assert vault_client.return_value == result\n\n\ndef test_get_client_class():\n    assert client.get_client_class() is client.VaultClient\n\n\ndef test_vault_client_base_call_init_client():\n    called_with = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            called_with.update(kwargs)\n\n        def _authenticate_certificate(self, *args, **kwargs):\n            pass\n\n    TestVaultClient(verify=False, url=\"yay\", login_cert=\"a\", login_cert_key=\"b\").auth()\n\n    assert called_with == {\n        \"verify\": False,\n        \"url\": \"yay\",\n        \"login_cert\": \"a\",\n        \"login_cert_key\": \"b\",\n    }\n\n\n@pytest.mark.parametrize(\n    \"test_kwargs, expected\",\n    [\n        ({\"token\": \"yay\"}, [\"token\", \"yay\"]),\n        ({\"username\": \"a\", \"password\": \"b\"}, [\"userpass\", \"a\", \"b\"]),\n        ({\"login_cert\": \"a\", \"login_cert_key\": \"b\"}, [\"certificate\"]),\n    ],\n)\ndef test_vault_client_base_authenticate(test_kwargs, expected):\n    auth_params = []\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            pass\n\n        def _authenticate_token(self, token):\n            auth_params.extend([\"token\", token])\n\n        def _authenticate_certificate(self):\n            auth_params.extend([\"certificate\"])\n\n        def _authenticate_userpass(self, username, password):\n            auth_params.extend([\"userpass\", username, password])\n\n    TestVaultClient(**test_kwargs).auth()\n\n    assert auth_params == expected\n\n\ndef test_vault_client_base_username_without_password(vault):\n\n    vault.username = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\ndef test_vault_client_base_login_cert_without_key(vault):\n    vault.login_cert = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\ndef test_vault_client_base_no_auth(vault):\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()\n\n\n@pytest.mark.parametrize(\n    \"verify, ca_bundle, expected\",\n    [(True, \"yay\", \"yay\"), (True, None, True), (False, \"yay\", False)],\n)\ndef test_vault_client_ca_bundle_verify(mocker, verify, ca_bundle, expected):\n\n    session_kwargs = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            session_kwargs.update(kwargs)\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        TestVaultClient(verify=verify, ca_bundle=ca_bundle).auth()\n\n    assert session_kwargs[\"verify\"] == expected\n\n\ndef test_vault_client_base_browse_recursive_secrets(vault):\n    vault.db = {\"a\": {\"value\": \"secret-a\"}, \"b/c\": {\"value\": \"secret-bc\"}}\n\n    result = list(vault._browse_recursive_secrets(\"\"))\n\n    assert result == [\"a\", \"b/c\"]\n\n\ndef test_vault_client_base_browse_recursive_secrets_single_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"secret-a\"}}\n\n    result = list(vault._browse_recursive_secrets(\"a\"))\n\n    assert result == [\"a\"]\n\n\ndef test_vault_client_base_get_all_secrets(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n    result = vault.get_all_secrets(\"a/\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n\ndef test_vault_client_base_get_all_secrets_flat(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}}\n\n\n@pytest.mark.parametrize(\n    \"input, expected\",\n    [\n        (\"a\", {\"a/c\": {\"value\": \"secret-ac\"}}),\n        (\"b\", {\"b\": {\"value\": \"secret-b\"}}),\n        (\"a/\", {\"a/c\": {\"value\": \"secret-ac\"}}),\n    ],\n)\ndef test_vault_client_base_get_secrets(vault, input, expected):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_secrets(input)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\n    \"input, expected\",\n    [(\"a\", {\"c\": {\"value\": \"secret-ac\"}}), (\"b\", {\"\": {\"value\": \"secret-b\"}})],\n)\ndef test_vault_client_base_get_secrets_relative(vault, input, expected):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_secrets(input, relative=True)\n\n    assert result == expected\n\n\ndef test_vault_client_base_delete_all_secrets_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\", generator=True)\n\n    assert next(result) == \"a/c\"\n\n    assert vault.db == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    assert next(result) == \"b\"\n\n    assert vault.db == {\"b\": {\"value\": \"secret-b\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_delete_all_secrets_no_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\")\n\n    assert result == [\"a/c\", \"b\"]\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_delete_all_secrets_trailing_slash(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}}\n\n    assert vault.delete_all_secrets(\"a/\") == [\"a/c\"]\n\n    assert vault.db == {}\n\n\ndef test_vault_client_base_context_manager(vault):\n\n    with vault as c:\n        assert c is vault\n\n\ndef test_vault_client_set_secret(vault):\n\n    vault.set_secret(\"a/b\", {\"name\": \"value\"})\n\n    assert vault.db == {\"a/b\": {\"name\": \"value\"}}\n\n\n@pytest.mark.parametrize(\n    \"safe_write, force\", [(True, False), (True, None), (False, False)]\n)\ndef test_vault_client_set_secret_overwrite_invalid(vault, safe_write, force):\n\n    vault.db = {\"a/b\": {\"value\": \"d\"}}\n    vault.safe_write = safe_write\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"value\": \"c\"}, force=force, update=False)\n\n    assert vault.db == {\"a/b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_set_secret_with_update(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    vault.set_secret(\"a/b\", {\"B\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\", \"B\": \"BB\"}}\n\n\ndef test_vault_client_set_secret_with_update_overwrite_invalid(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"A\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\"}}\n\n\n@pytest.mark.parametrize(\n    \"safe_write, force, value\",\n    [(True, True, \"c\"), (False, None, \"c\"), (True, None, \"d\")],\n)\ndef test_vault_client_set_secret_overwrite_valid(vault, safe_write, force, value):\n\n    vault.db = {\"a/b\": {\"value\": \"d\"}}\n    vault.safe_write = safe_write\n\n    vault.set_secret(\"a/b\", {\"value\": value}, force=force)\n\n    assert vault.db == {\"a/b\": {\"value\": value}}\n\n\ndef test_vault_client_set_secret_when_there_are_existing_secrets_beneath_path(vault):\n\n    vault.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"e\"})\n\n    assert vault.db == {\"a/b/c\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_set_secret_when_a_parent_is_an_existing_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"d\"})\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_set_secret_read_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_set_secret_list_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_list_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_set_secret_read_parent_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1\n\n\ndef test_vault_client_move_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.move_secrets(\"a\", \"d\")\n\n    assert vault.db == {\"d/b\": {\"value\": \"c\"}, \"d/d\": {\"value\": \"e\"}}\n\n\ndef test_vault_client_move_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.move_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"f/d\": {\"value\": \"e\"}}\n\n\ndef test_vault_client_move_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.move_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_move_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.move_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"b\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_copy_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.copy_secrets(\"a\", \"d\")\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"d/b\": {\"value\": \"c\"},\n        \"d/d\": {\"value\": \"e\"},\n    }\n\n\ndef test_vault_client_copy_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.copy_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\n        \"f/b\": {\"value\": \"c\"},\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n    }\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"f/b\": {\"value\": \"c\"},\n        \"f/d\": {\"value\": \"e\"},\n    }\n\n\ndef test_vault_client_copy_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.copy_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n\ndef test_vault_client_copy_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.copy_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"c\"}}\n\n\ndef test_vault_client_base_render_template(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}}\n\n    assert vault.render_template(\"Hello {{ vault('a/b').value }}\") == \"Hello c\"\n\n\n@pytest.mark.parametrize(\"template\", [\"Hello {{ vault('a/b') }}\", \"Hello {{\"])\ndef test_vault_client_base_render_template_path_not_found(vault, template):\n    with pytest.raises(exceptions.VaultRenderTemplateError):\n        vault.render_template(template)\n\n\n@pytest.mark.parametrize(\n    \"vault_contents, expected\",\n    [\n        # Secret is not a template\n        ({\"a\": {\"value\": \"b\"}}, {\"value\": \"b\"}),\n        # Secret not a string\n        ({\"a\": {\"value\": [\"yay\"]}}, {\"value\": [\"yay\"]}),\n    ],\n)\ndef test_vault_client_base_get_secret(vault, vault_contents, expected):\n    vault.db = vault_contents\n\n    assert vault.get_secret(\"a\") == expected\n\n\ndef test_vault_client_base_get_secret_multiple_keys(vault):\n    vault.db = {\"rabbitmq/creds/role\": {\"username\": \"foo\", \"password\": \"bar\"}}\n    assert vault.get_secret(\"rabbitmq/creds/role\") == {\n        \"username\": \"foo\",\n        \"password\": \"bar\",\n    }\n\n\ndef test_vault_client_base_get_secret_not_found(vault):\n    vault.db = {}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"not-existing\")\n\n\ndef test_vault_client_base_get_secret_missing_key(vault):\n    vault.db = {\"a\": {\"password\": \"xxx\"}}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"a\", key=\"username\")\n\n\ndef test_vault_client_base_lookup_token(vault):\n    assert vault.lookup_token() == {\"data\": {\"expire_time\": \"2100-01-01T00:00:00\"}}\n\n\ndef test_vault_client_base_get_secrets_error(vault, caplog):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_get_paths = {\"c\"}\n\n    assert vault.get_secrets(\"\") == {\n        \"a\": {\"value\": \"b\"},\n        \"c\": {},\n    }\n    assert caplog.record_tuples[0] == (\n        \"vault_cli.client\",\n        40,\n        \"VaultForbidden: Insufficient access for interacting with the requested \"\n        \"secret\",\n    )\n\n\ndef test_vault_client_base_get_secrets_list_forbidden(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_list_paths = {\"c\"}\n\n    assert vault.get_secrets(\"c\") == {\"c\": {\"value\": \"d\"}}\n\n\n@pytest.mark.parametrize(\n    \"method, params, expected\",\n    [\n        (\"get_secret\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"get_secret\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\"delete_secret\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"delete_secret\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\"list_secrets\", [\"foo\"], {\"path\": \"/base/foo\"}),\n        (\"list_secrets\", [\"/foo\"], {\"path\": \"/foo\"}),\n        (\n            \"set_secret\",\n            [\"foo\", {\"value\": \"value\"}],\n            {\"path\": \"/base/foo\", \"secret\": {\"value\": \"value\"}},\n        ),\n        (\n            \"set_secret\",\n            [\"/foo\", {\"value\": \"value\"}],\n            {\"path\": \"/foo\", \"secret\": {\"value\": \"value\"}},\n        ),\n    ],\n)\ndef test_vault_client_base_absolute_path(vault, mocker, method, params, expected):\n    mocked = mocker.patch(f\"vault_cli.testing.TestVaultClient._{method}\")\n    vault.base_path = \"base/\"\n\n    getattr(vault, method)(*params)\n    mocked.assert_called_with(**expected)\n\n\n@pytest.mark.parametrize(\"path, expected\", [(\"foo\", \"/base/foo\"), (\"/foo\", \"/foo\")])\ndef test_vault_client_base_build_full_path(vault, path, expected):\n    vault.base_path = \"base/\"\n    assert vault._build_full_path(path) == expected\n\n\n@pytest.mark.parametrize(\n    \"path, expected\",\n    [\n        (\"foo\", \"/foo/\"),\n        (\"foo/\", \"/foo/\"),\n        (\"foo//\", \"/foo/\"),\n        (\"/foo\", \"/foo/\"),\n        (\"/foo/\", \"/foo/\"),\n        (\"/foo//\", \"/foo/\"),\n    ],\n)\ndef test_vault_client_base_base_path(vault, path, expected):\n    vault.base_path = path\n    assert vault.base_path == expected\n\n\ndef test_vault_client_base_get_secret_implicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    vault.db = {\"a\": {\"value\": \"c\"}}\n    # Value was cached\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n\n\ndef test_vault_client_base_get_secret_explicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    with vault:\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n        vault.db = {\"a\": {\"value\": \"c\"}}\n        # Value not updated\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    assert vault.get_secret(\"a\") == {\"value\": \"c\"}\n\n\ndef test_vault_client_base_set_secrets(vault):\n    secrets = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\"}}\n    with vault:\n        vault.set_secrets(secrets)\n    assert vault.db == secrets\n\n\ndef test_vault_client_base_set_secrets_update(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, update=True)\n    assert vault.db == {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\", \"i\": \"j\"}}\n\n\ndef test_vault_client_base_set_secrets_force(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, force=False)\n", "patch": "@@ -1,8 +1,6 @@\n-import itertools\n-\n import pytest\n \n-from vault_cli import client, exceptions, testing\n+from vault_cli import client, exceptions\n \n \n def test_get_client(mocker):\n@@ -476,44 +474,6 @@ def test_vault_client_base_render_template_path_not_found(vault, template):\n         ({\"a\": {\"value\": \"b\"}}, {\"value\": \"b\"}),\n         # Secret not a string\n         ({\"a\": {\"value\": [\"yay\"]}}, {\"value\": [\"yay\"]}),\n-        # Secret is a template without variable expansion\n-        ({\"a\": {\"value\": \"!template!b\"}, \"b\": {\"value\": \"c\"}}, {\"value\": \"b\"}),\n-        # Secret is a template\n-        (\n-            {\"a\": {\"value\": \"!template!{{ vault('b').value }}\"}, \"b\": {\"value\": \"c\"}},\n-            {\"value\": \"c\"},\n-        ),\n-        # Secret is a dict with containing a template\n-        (\n-            {\n-                \"a\": {\"x\": \"!template!{{ vault('b').value }}\", \"y\": \"yay\"},\n-                \"b\": {\"value\": \"c\"},\n-            },\n-            {\"x\": \"c\", \"y\": \"yay\"},\n-        ),\n-        # Finite recursion\n-        (\n-            {\n-                \"a\": {\"value\": \"!template!{{ vault('b').value }}\"},\n-                \"b\": {\"value\": \"!template!{{ vault('c').value }}\"},\n-                \"c\": {\"value\": \"d\"},\n-            },\n-            {\"value\": \"d\"},\n-        ),\n-        # Infinite Recursion\n-        (\n-            {\n-                \"a\": {\"value\": \"!template!{{ vault('b').value }}\"},\n-                \"b\": {\"value\": \"!template!{{ vault('c').value }}\"},\n-                \"c\": {\"value\": \"!template!{{ vault('a').value }}\"},\n-            },\n-            {\"value\": '<recursive value \"a\">'},\n-        ),\n-        # Direct Recursion\n-        (\n-            {\"a\": {\"value\": \"!template!{{ vault('a').value }}\"}},\n-            {\"value\": '<recursive value \"a\">'},\n-        ),\n     ],\n )\n def test_vault_client_base_get_secret(vault, vault_contents, expected):\n@@ -522,23 +482,6 @@ def test_vault_client_base_get_secret(vault, vault_contents, expected):\n     assert vault.get_secret(\"a\") == expected\n \n \n-def test_vault_client_base_get_secret_deprecation_warning(vault, caplog):\n-    vault.db = {\"a\": {\"value\": \"!template!b\"}}\n-    caplog.set_level(\"WARNING\")\n-\n-    vault.get_secret(\"a\")\n-    assert \"Templated values are deprecated\" in caplog.records[0].message\n-\n-\n-def test_vault_client_base_get_secret_template_root(vault):\n-    vault.base_path = \"base\"\n-    vault.db = {\"/base/a\": {\"value\": '!template!{{ vault(\"a\").value }} yay'}}\n-\n-    # In case of erroneous caching, e.g. a different cache entry\n-    # for /base/a and base/a, we would find '<recursive value \"a\"> yay yay'\n-    assert vault.get_secret(\"/base/a\") == {\"value\": '<recursive value \"a\"> yay'}\n-\n-\n def test_vault_client_base_get_secret_multiple_keys(vault):\n     vault.db = {\"rabbitmq/creds/role\": {\"username\": \"foo\", \"password\": \"bar\"}}\n     assert vault.get_secret(\"rabbitmq/creds/role\") == {\n@@ -547,22 +490,11 @@ def test_vault_client_base_get_secret_multiple_keys(vault):\n     }\n \n \n-def test_vault_client_base_get_secret_with_dict(vault):\n-    vault.db = {\n-        \"credentials\": {\"value\": {\"username\": \"foo\", \"password\": \"bar\"}},\n-        \"dsn\": {\n-            \"value\": \"!template!proto://{{ vault('credentials')['value']['username'] }}:{{ vault('credentials').value.password }}@host\"\n-        },\n-    }\n-\n-    assert vault.get_secret(\"dsn\") == {\"value\": \"proto://foo:bar@host\"}\n-\n-\n def test_vault_client_base_get_secret_not_found(vault):\n     vault.db = {}\n \n     with pytest.raises(exceptions.VaultSecretNotFound):\n-        vault.get_secret(\"not-exiting\")\n+        vault.get_secret(\"not-existing\")\n \n \n def test_vault_client_base_get_secret_missing_key(vault):\n@@ -572,20 +504,6 @@ def test_vault_client_base_get_secret_missing_key(vault):\n         vault.get_secret(\"a\", key=\"username\")\n \n \n-def test_vault_client_base_get_secret_template_error(vault, caplog):\n-    vault.db = {\"a\": {\"key\": \"!template!{{\"}}\n-\n-    with pytest.raises(exceptions.VaultRenderTemplateError) as exc_info:\n-        vault.get_secret(\"a\")\n-\n-    assert str(exc_info.value) == 'Error while rendering secret at path \"a\"'\n-    assert (\n-        str(exc_info.value.__cause__)\n-        == 'Error while rendering secret value for key \"key\"'\n-    )\n-    assert str(exc_info.value.__cause__.__cause__) == \"Jinja2 template syntax error\"\n-\n-\n def test_vault_client_base_lookup_token(vault):\n     assert vault.lookup_token() == {\"data\": {\"expire_time\": \"2100-01-01T00:00:00\"}}\n \n@@ -672,56 +590,6 @@ def test_vault_client_base_get_secret_implicit_cache(vault):\n     assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n \n \n-class RaceConditionTestVaultClient(testing.TestVaultClient):\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-        self.counter = itertools.count()\n-\n-    def _get_secret(self, path):\n-        if path == \"a\":\n-            val = next(self.counter)\n-            return {\"b\": f\"b{val}\", \"c\": f\"c{val}\"}\n-        return super()._get_secret(path)\n-\n-\n-def test_vault_client_base_get_secret_implicit_cache_no_race_condition():\n-    # In this test we check that if a value is read several times by\n-    # a template, implicit caching makes sure we have the same value\n-    # every time.\n-\n-    # Values returned by this client keep changing\n-\n-    vault = RaceConditionTestVaultClient()\n-\n-    with vault:\n-        assert vault.get_secret(\"a\") == {\"b\": \"b0\", \"c\": \"c0\"}\n-    with vault:\n-        assert vault.get_secret(\"a\") == {\"b\": \"b1\", \"c\": \"c1\"}\n-\n-    vault.db = {\"d\": {\"value\": \"\"\"!template!{{ vault(\"a\").b }}-{{ vault(\"a\").c }}\"\"\"}}\n-\n-    # b2-c3 would be the value if caching didn't work.\n-    with vault:\n-        assert vault.get_secret(\"d\") == {\"value\": \"b2-c2\"}\n-\n-\n-def test_vault_client_base_get_secrets_implicit_cache_no_race_condition():\n-    # In this test, the same value is read twice by get-all and template\n-    # We check that 2 values are consistent\n-\n-    vault = RaceConditionTestVaultClient()\n-\n-    vault.db = {\n-        \"a\": {},\n-        \"d\": {\"value\": \"\"\"!template!{{ vault(\"a\").b }}-{{ vault(\"a\").c }}\"\"\"},\n-    }\n-\n-    assert vault.get_secrets(\"\") == {\n-        \"a\": {\"b\": \"b0\", \"c\": \"c0\"},\n-        \"d\": {\"value\": \"b0-c0\"},\n-    }\n-\n-\n def test_vault_client_base_get_secret_explicit_cache(vault):\n     vault.db = {\"a\": {\"value\": \"b\"}}\n     with vault:", "file_path": "files/2021_12/200", "file_language": "py", "file_name": "tests/unit/test_client_base.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_get_client(mocker):\n    mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"url\": \"yay\"}\n    )\n    vault_client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n\n    result = client.get_client(yo=True)\n\n    vault_client.assert_called_with(yo=True, url=\"yay\")\n    assert vault_client.return_value == result", "target": 0}, {"function": "def test_get_client_class():\n    assert client.get_client_class() is client.VaultClient", "target": 0}, {"function": "def test_vault_client_base_call_init_client():\n    called_with = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            called_with.update(kwargs)\n\n        def _authenticate_certificate(self, *args, **kwargs):\n            pass\n\n    TestVaultClient(verify=False, url=\"yay\", login_cert=\"a\", login_cert_key=\"b\").auth()\n\n    assert called_with == {\n        \"verify\": False,\n        \"url\": \"yay\",\n        \"login_cert\": \"a\",\n        \"login_cert_key\": \"b\",\n    }", "target": 0}, {"function": "def test_vault_client_base_username_without_password(vault):\n\n    vault.username = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_login_cert_without_key(vault):\n    vault.login_cert = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_no_auth(vault):\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_browse_recursive_secrets(vault):\n    vault.db = {\"a\": {\"value\": \"secret-a\"}, \"b/c\": {\"value\": \"secret-bc\"}}\n\n    result = list(vault._browse_recursive_secrets(\"\"))\n\n    assert result == [\"a\", \"b/c\"]", "target": 0}, {"function": "def test_vault_client_base_browse_recursive_secrets_single_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"secret-a\"}}\n\n    result = list(vault._browse_recursive_secrets(\"a\"))\n\n    assert result == [\"a\"]", "target": 0}, {"function": "def test_vault_client_base_get_all_secrets(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n    result = vault.get_all_secrets(\"a/\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}", "target": 0}, {"function": "def test_vault_client_base_get_all_secrets_flat(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\", generator=True)\n\n    assert next(result) == \"a/c\"\n\n    assert vault.db == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    assert next(result) == \"b\"\n\n    assert vault.db == {\"b\": {\"value\": \"secret-b\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_no_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\")\n\n    assert result == [\"a/c\", \"b\"]\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_trailing_slash(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}}\n\n    assert vault.delete_all_secrets(\"a/\") == [\"a/c\"]\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_context_manager(vault):\n\n    with vault as c:\n        assert c is vault", "target": 0}, {"function": "def test_vault_client_set_secret(vault):\n\n    vault.set_secret(\"a/b\", {\"name\": \"value\"})\n\n    assert vault.db == {\"a/b\": {\"name\": \"value\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_with_update(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    vault.set_secret(\"a/b\", {\"B\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\", \"B\": \"BB\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_with_update_overwrite_invalid(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"A\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_when_there_are_existing_secrets_beneath_path(vault):\n\n    vault.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"e\"})\n\n    assert vault.db == {\"a/b/c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_when_a_parent_is_an_existing_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"d\"})\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_read_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_set_secret_list_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_list_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_set_secret_read_parent_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_move_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.move_secrets(\"a\", \"d\")\n\n    assert vault.db == {\"d/b\": {\"value\": \"c\"}, \"d/d\": {\"value\": \"e\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.move_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"f/d\": {\"value\": \"e\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.move_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.move_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_copy_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.copy_secrets(\"a\", \"d\")\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"d/b\": {\"value\": \"c\"},\n        \"d/d\": {\"value\": \"e\"},\n    }", "target": 0}, {"function": "def test_vault_client_copy_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.copy_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\n        \"f/b\": {\"value\": \"c\"},\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n    }\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"f/b\": {\"value\": \"c\"},\n        \"f/d\": {\"value\": \"e\"},\n    }", "target": 0}, {"function": "def test_vault_client_copy_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.copy_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_copy_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.copy_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_base_render_template(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}}\n\n    assert vault.render_template(\"Hello {{ vault('a/b').value }}\") == \"Hello c\"", "target": 0}, {"function": "def test_vault_client_base_get_secret_multiple_keys(vault):\n    vault.db = {\"rabbitmq/creds/role\": {\"username\": \"foo\", \"password\": \"bar\"}}\n    assert vault.get_secret(\"rabbitmq/creds/role\") == {\n        \"username\": \"foo\",\n        \"password\": \"bar\",\n    }", "target": 0}, {"function": "def test_vault_client_base_get_secret_not_found(vault):\n    vault.db = {}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"not-existing\")", "target": 0}, {"function": "def test_vault_client_base_get_secret_missing_key(vault):\n    vault.db = {\"a\": {\"password\": \"xxx\"}}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"a\", key=\"username\")", "target": 0}, {"function": "def test_vault_client_base_lookup_token(vault):\n    assert vault.lookup_token() == {\"data\": {\"expire_time\": \"2100-01-01T00:00:00\"}}", "target": 0}, {"function": "def test_vault_client_base_get_secrets_error(vault, caplog):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_get_paths = {\"c\"}\n\n    assert vault.get_secrets(\"\") == {\n        \"a\": {\"value\": \"b\"},\n        \"c\": {},\n    }\n    assert caplog.record_tuples[0] == (\n        \"vault_cli.client\",\n        40,\n        \"VaultForbidden: Insufficient access for interacting with the requested \"\n        \"secret\",\n    )", "target": 0}, {"function": "def test_vault_client_base_get_secrets_list_forbidden(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_list_paths = {\"c\"}\n\n    assert vault.get_secrets(\"c\") == {\"c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_base_get_secret_implicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    vault.db = {\"a\": {\"value\": \"c\"}}\n    # Value was cached\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}", "target": 0}, {"function": "def test_vault_client_base_get_secret_explicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    with vault:\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n        vault.db = {\"a\": {\"value\": \"c\"}}\n        # Value not updated\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    assert vault.get_secret(\"a\") == {\"value\": \"c\"}", "target": 0}, {"function": "def test_vault_client_base_set_secrets(vault):\n    secrets = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\"}}\n    with vault:\n        vault.set_secrets(secrets)\n    assert vault.db == secrets", "target": 0}, {"function": "def test_vault_client_base_set_secrets_update(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, update=True)\n    assert vault.db == {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\", \"i\": \"j\"}}", "target": 0}, {"function": "def test_vault_client_base_set_secrets_force(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, force=False)", "target": 0}], "function_after": [{"function": "def test_get_client(mocker):\n    mocker.patch(\n        \"vault_cli.settings.build_config_from_files\", return_value={\"url\": \"yay\"}\n    )\n    vault_client = mocker.patch(\"vault_cli.client.get_client_class\").return_value\n\n    result = client.get_client(yo=True)\n\n    vault_client.assert_called_with(yo=True, url=\"yay\")\n    assert vault_client.return_value == result", "target": 0}, {"function": "def test_get_client_class():\n    assert client.get_client_class() is client.VaultClient", "target": 0}, {"function": "def test_vault_client_base_call_init_client():\n    called_with = {}\n\n    class TestVaultClient(client.VaultClientBase):\n        def _init_client(self, **kwargs):\n            called_with.update(kwargs)\n\n        def _authenticate_certificate(self, *args, **kwargs):\n            pass\n\n    TestVaultClient(verify=False, url=\"yay\", login_cert=\"a\", login_cert_key=\"b\").auth()\n\n    assert called_with == {\n        \"verify\": False,\n        \"url\": \"yay\",\n        \"login_cert\": \"a\",\n        \"login_cert_key\": \"b\",\n    }", "target": 0}, {"function": "def test_vault_client_base_username_without_password(vault):\n\n    vault.username = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_login_cert_without_key(vault):\n    vault.login_cert = \"yay\"\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_no_auth(vault):\n\n    with pytest.raises(exceptions.VaultAuthenticationError):\n        vault.auth()", "target": 0}, {"function": "def test_vault_client_base_browse_recursive_secrets(vault):\n    vault.db = {\"a\": {\"value\": \"secret-a\"}, \"b/c\": {\"value\": \"secret-bc\"}}\n\n    result = list(vault._browse_recursive_secrets(\"\"))\n\n    assert result == [\"a\", \"b/c\"]", "target": 0}, {"function": "def test_vault_client_base_browse_recursive_secrets_single_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"secret-a\"}}\n\n    result = list(vault._browse_recursive_secrets(\"a\"))\n\n    assert result == [\"a\"]", "target": 0}, {"function": "def test_vault_client_base_get_all_secrets(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}\n\n    result = vault.get_all_secrets(\"a/\")\n\n    assert result == {\"a\": {\"c\": {\"value\": \"secret-ac\"}}}", "target": 0}, {"function": "def test_vault_client_base_get_all_secrets_flat(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", \"\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.get_all_secrets(\"a\", flat=True)\n\n    assert result == {\"a/c\": {\"value\": \"secret-ac\"}}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\", generator=True)\n\n    assert next(result) == \"a/c\"\n\n    assert vault.db == {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    assert next(result) == \"b\"\n\n    assert vault.db == {\"b\": {\"value\": \"secret-b\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_no_generator(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}, \"b\": {\"value\": \"secret-b\"}}\n\n    result = vault.delete_all_secrets(\"a\", \"b\")\n\n    assert result == [\"a/c\", \"b\"]\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_delete_all_secrets_trailing_slash(vault):\n    vault.db = {\"a/c\": {\"value\": \"secret-ac\"}}\n\n    assert vault.delete_all_secrets(\"a/\") == [\"a/c\"]\n\n    assert vault.db == {}", "target": 0}, {"function": "def test_vault_client_base_context_manager(vault):\n\n    with vault as c:\n        assert c is vault", "target": 0}, {"function": "def test_vault_client_set_secret(vault):\n\n    vault.set_secret(\"a/b\", {\"name\": \"value\"})\n\n    assert vault.db == {\"a/b\": {\"name\": \"value\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_with_update(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    vault.set_secret(\"a/b\", {\"B\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\", \"B\": \"BB\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_with_update_overwrite_invalid(vault):\n\n    vault.db = {\"a/b\": {\"A\": \"AA\"}}\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secret(\"a/b\", {\"A\": \"BB\"}, force=False, update=True)\n\n    assert vault.db == {\"a/b\": {\"A\": \"AA\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_when_there_are_existing_secrets_beneath_path(vault):\n\n    vault.db = {\"a/b/c\": {\"value\": \"d\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"e\"})\n\n    assert vault.db == {\"a/b/c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_when_a_parent_is_an_existing_secret(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}}\n\n    with pytest.raises(exceptions.VaultMixSecretAndFolder):\n        vault.set_secret(\"a/b\", {\"value\": \"d\"})\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_set_secret_read_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_set_secret_list_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_list_paths.add(\"a/b\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_set_secret_read_parent_not_allowed(vault, caplog):\n\n    caplog.set_level(\"INFO\")\n\n    vault.db = {}\n    vault.forbidden_get_paths.add(\"a\")\n\n    vault.set_secret(\"a/b\", {\"value\": \"c\"})\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}}\n\n    assert len(caplog.records) == 1", "target": 0}, {"function": "def test_vault_client_move_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.move_secrets(\"a\", \"d\")\n\n    assert vault.db == {\"d/b\": {\"value\": \"c\"}, \"d/d\": {\"value\": \"e\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.move_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\"f/b\": {\"value\": \"c\"}, \"f/d\": {\"value\": \"e\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.move_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_move_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.move_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_copy_secrets(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    vault.copy_secrets(\"a\", \"d\")\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"d/b\": {\"value\": \"c\"},\n        \"d/d\": {\"value\": \"e\"},\n    }", "target": 0}, {"function": "def test_vault_client_copy_secrets_generator(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    result = vault.copy_secrets(\"a\", \"f\", generator=True)\n\n    assert next(result) == (\"a/b\", \"f/b\")\n\n    assert vault.db == {\"a/b\": {\"value\": \"c\"}, \"a/d\": {\"value\": \"e\"}}\n\n    assert next(result) == (\"a/d\", \"f/d\")\n\n    assert vault.db == {\n        \"f/b\": {\"value\": \"c\"},\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n    }\n\n    with pytest.raises(StopIteration):\n        next(result)\n\n    assert vault.db == {\n        \"a/b\": {\"value\": \"c\"},\n        \"a/d\": {\"value\": \"e\"},\n        \"f/b\": {\"value\": \"c\"},\n        \"f/d\": {\"value\": \"e\"},\n    }", "target": 0}, {"function": "def test_vault_client_copy_secrets_overwrite_safe(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.safe_write = True\n\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.copy_secrets(\"a\", \"b\")\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_copy_secrets_overwrite_force(vault):\n\n    vault.db = {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"d\"}}\n\n    vault.copy_secrets(\"a\", \"b\", force=True)\n\n    assert vault.db == {\"a\": {\"value\": \"c\"}, \"b\": {\"value\": \"c\"}}", "target": 0}, {"function": "def test_vault_client_base_render_template(vault):\n\n    vault.db = {\"a/b\": {\"value\": \"c\"}}\n\n    assert vault.render_template(\"Hello {{ vault('a/b').value }}\") == \"Hello c\"", "target": 0}, {"function": "def test_vault_client_base_get_secret_multiple_keys(vault):\n    vault.db = {\"rabbitmq/creds/role\": {\"username\": \"foo\", \"password\": \"bar\"}}\n    assert vault.get_secret(\"rabbitmq/creds/role\") == {\n        \"username\": \"foo\",\n        \"password\": \"bar\",\n    }", "target": 0}, {"function": "def test_vault_client_base_get_secret_not_found(vault):\n    vault.db = {}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"not-existing\")", "target": 0}, {"function": "def test_vault_client_base_get_secret_missing_key(vault):\n    vault.db = {\"a\": {\"password\": \"xxx\"}}\n\n    with pytest.raises(exceptions.VaultSecretNotFound):\n        vault.get_secret(\"a\", key=\"username\")", "target": 0}, {"function": "def test_vault_client_base_lookup_token(vault):\n    assert vault.lookup_token() == {\"data\": {\"expire_time\": \"2100-01-01T00:00:00\"}}", "target": 0}, {"function": "def test_vault_client_base_get_secrets_error(vault, caplog):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_get_paths = {\"c\"}\n\n    assert vault.get_secrets(\"\") == {\n        \"a\": {\"value\": \"b\"},\n        \"c\": {},\n    }\n    assert caplog.record_tuples[0] == (\n        \"vault_cli.client\",\n        40,\n        \"VaultForbidden: Insufficient access for interacting with the requested \"\n        \"secret\",\n    )", "target": 0}, {"function": "def test_vault_client_base_get_secrets_list_forbidden(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}, \"c\": {\"value\": \"d\"}}\n    vault.forbidden_list_paths = {\"c\"}\n\n    assert vault.get_secrets(\"c\") == {\"c\": {\"value\": \"d\"}}", "target": 0}, {"function": "def test_vault_client_base_get_secret_implicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    vault.db = {\"a\": {\"value\": \"c\"}}\n    # Value was cached\n    assert vault.get_secret(\"a\") == {\"value\": \"b\"}", "target": 0}, {"function": "def test_vault_client_base_get_secret_explicit_cache(vault):\n    vault.db = {\"a\": {\"value\": \"b\"}}\n    with vault:\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n        vault.db = {\"a\": {\"value\": \"c\"}}\n        # Value not updated\n        assert vault.get_secret(\"a\") == {\"value\": \"b\"}\n    assert vault.get_secret(\"a\") == {\"value\": \"c\"}", "target": 0}, {"function": "def test_vault_client_base_set_secrets(vault):\n    secrets = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\"}}\n    with vault:\n        vault.set_secrets(secrets)\n    assert vault.db == secrets", "target": 0}, {"function": "def test_vault_client_base_set_secrets_update(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, update=True)\n    assert vault.db == {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"g\": \"h\", \"i\": \"j\"}}", "target": 0}, {"function": "def test_vault_client_base_set_secrets_force(vault):\n    vault.db = {\"a\": {\"b\": \"c\"}, \"d/e/f\": {\"i\": \"j\"}}\n    with pytest.raises(exceptions.VaultOverwriteSecretError):\n        vault.set_secrets({\"d/e/f\": {\"g\": \"h\"}}, force=False)", "target": 0}]}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/vault_cli%2Fcli.py", "code": "import contextlib\nimport logging\nimport os\nimport pathlib\nimport sys\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    Mapping,\n    NoReturn,\n    Optional,\n    Sequence,\n    TextIO,\n    Tuple,\n)\n\nimport click\nimport yaml\n\nimport vault_cli\nfrom vault_cli import client, environment, exceptions, settings, ssh, types, utils\n\nlogger = logging.getLogger(__name__)\n\nCONTEXT_SETTINGS = {\n    \"help_option_names\": [\"-h\", \"--help\"],\n    \"auto_envvar_prefix\": settings.ENV_PREFIX,\n}\n\n\ndef load_config(ctx: click.Context, param: click.Parameter, value: str) -> None:\n    if value == \"no\":\n        ctx.default_map = {}\n        return\n\n    if value is None:\n        config_files = settings.CONFIG_FILES\n    else:\n        config_files = [value]\n\n    config = settings.build_config_from_files(*config_files)\n    ctx.default_map = config\n\n\ndef set_verbosity(value: int) -> None:\n    level = settings.get_log_level(verbosity=value)\n    logging.basicConfig(level=level)\n    logger.info(f\"Log level set to {logging.getLevelName(level)}\")\n\n\ndef set_umask(umask: int) -> None:\n    os.umask(umask)\n\n\n@contextlib.contextmanager\ndef handle_errors():\n    try:\n        yield\n    except exceptions.VaultException as exc:\n        raise click.ClickException(\"\\n\".join(utils.extract_error_messages(exc)))\n\n\ndef print_version(ctx, __, value):\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(f\"vault-cli {vault_cli.__version__}\")\n    click.echo(f\"License: {vault_cli.__license__}\")\n    ctx.exit()\n\n\ndef parse_octal(value: str) -> int:\n    return int(value, base=8)\n\n\ndef click_octal(_, __, value: str) -> int:\n    return parse_octal(value)\n\n\ndef repr_octal(value: Optional[int]) -> Optional[str]:\n    # #05o means octal with 5 digits (0o octal prefix included)\n    return f\"{value:#05o}\" if value is not None else None\n\n\n@click.group(context_settings=CONTEXT_SETTINGS)\n@click.pass_context\n@click.option(\n    \"--url\", \"-U\", help=\"URL of the vault instance\", default=settings.DEFAULTS.url\n)\n@click.option(\n    \"--verify/--no-verify\",\n    default=settings.DEFAULTS.verify,\n    help=\"Verify HTTPS certificate\",\n)\n@click.option(\n    \"--ca-bundle\",\n    type=click.Path(),\n    help=\"Location of the bundle containing the server certificate \"\n    \"to check against.\",\n)\n@click.option(\n    \"--login-cert\",\n    type=click.Path(),\n    help=\"Path to a public client certificate to use for connecting to vault.\",\n)\n@click.option(\n    \"--login-cert-key\",\n    type=click.Path(),\n    help=\"Path to a private client certificate to use for connecting to vault.\",\n)\n@click.option(\n    \"--token-file\",\n    \"-T\",\n    type=click.Path(),\n    help=\"File which contains the token to connect to Vault. \"\n    'Configuration file can also contain a \"token\" key.',\n)\n@click.option(\"--username\", \"-u\", help=\"Username used for userpass authentication\")\n@click.option(\n    \"--password-file\",\n    \"-w\",\n    type=click.Path(),\n    help='Can read from stdin if \"-\" is used as parameter. '\n    'Configuration file can also contain a \"password\" key.',\n)\n@click.option(\"--base-path\", \"-b\", help=\"Base path for requests\")\n@click.option(\n    \"-s\",\n    \"--safe-write/--unsafe-write\",\n    default=settings.DEFAULTS.safe_write,\n    help=\"When activated, you can't overwrite a secret without \"\n    'passing \"--force\" (in commands \"set\", \"mv\", \"cp\", etc)',\n)\n@click.option(\n    \"--render/--no-render\",\n    default=False,\n    help=\"Deprecated / unused\",\n)\n@click.option(\n    \"--umask\",\n    callback=click_octal,\n    default=\"066\",\n    help=\"Set umask for newly created files. Defaults to files with read-write \"\n    \"for owner and nothing for group & others\",\n)\n@click.option(\n    \"-v\",\n    \"--verbose\",\n    count=True,\n    help=\"Use multiple times to increase verbosity\",\n)\n@click.option(\n    \"--config-file\",\n    is_eager=True,\n    callback=load_config,\n    help=\"Config file to use. Use 'no' to disable config file. \"\n    \"Default value: first of \" + \", \".join(settings.CONFIG_FILES),\n    type=click.Path(),\n)\n@click.option(\n    \"-V\",\n    \"--version\",\n    is_flag=True,\n    callback=print_version,\n    expose_value=False,\n    is_eager=True,\n)\n@handle_errors()\ndef cli(ctx: click.Context, verbose: int, umask: int, **kwargs) -> None:\n    \"\"\"\n    Interact with a Vault. See subcommands for details.\n\n    All arguments can be passed by environment variables: VAULT_CLI_UPPERCASE_NAME\n    (including VAULT_CLI_PASSWORD and VAULT_CLI_TOKEN).\n\n    \"\"\"\n    kwargs.pop(\"render\")\n    kwargs.pop(\"config_file\")\n    set_verbosity(verbose)\n    set_umask(umask)\n\n    assert ctx.default_map  # make mypy happy\n    kwargs.update(extract_special_args(ctx.default_map, os.environ))\n\n    # There might still be files to read, so let's do it now\n    kwargs = settings.read_all_files(kwargs)\n    saved_settings = kwargs.copy()\n\n    saved_settings.update({\"verbose\": verbose, \"umask\": repr_octal(umask)})\n\n    ctx.obj = client.get_client_class()(**kwargs)  # type: ignore\n    ctx.obj.auth()\n    ctx.obj.saved_settings = saved_settings\n\n\ndef extract_special_args(\n    config: Mapping[str, Any], environ: Mapping[str, str]\n) -> Dict[str, Any]:\n    result = {}\n    for key in [\"password\", \"token\"]:\n        result[key] = config.get(key)\n        env_var_key = \"VAULT_CLI_{}\".format(key.upper())\n        if env_var_key in environ:\n            result[key] = environ.get(env_var_key)\n\n    return result\n\n\n@cli.command(\"list\")\n@click.argument(\"path\", required=False, default=\"\")\n@click.pass_obj\n@handle_errors()\ndef list_(client_obj: client.VaultClientBase, path: str):\n    \"\"\"\n    List all the secrets at the given path. Folders are listed too. If no path\n    is given, list the objects at the root.\n    \"\"\"\n    result = client_obj.list_secrets(path=path)\n    click.echo(\"\\n\".join(result))\n\n\n@cli.command(name=\"get-all\")\n@click.option(\n    \"--flat/--no-flat\",\n    default=True,\n    show_default=True,\n    help=(\"Returns the full path as keys instead of merging paths into a tree\"),\n)\n@click.argument(\"path\", required=False, nargs=-1)\n@click.pass_obj\n@handle_errors()\ndef get_all(client_obj: client.VaultClientBase, path: Sequence[str], flat: bool):\n    \"\"\"\n    Return multiple secrets. Return a single yaml with all the secrets located\n    at the given paths. Folders are recursively explored. Without a path,\n    explores all the vault.\n    \"\"\"\n    paths = list(path) or [\"\"]\n\n    result = client_obj.get_all_secrets(*paths, flat=flat)\n\n    click.echo(\n        yaml.safe_dump(result, default_flow_style=False, explicit_start=True), nl=False\n    )\n\n\n@cli.command()\n@click.pass_obj\n@click.option(\n    \"--text/--yaml\",\n    default=True,\n    help=(\n        \"Returns the value in yaml format instead of plain text.\"\n        \"If the secret is not a string, it will always be yaml.\"\n    ),\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=click.File(\"w\"),\n    help=\"File in which to write the secret. \"\n    \"If ommited (or -), write in standard output\",\n)\n@click.argument(\"name\")\n@click.argument(\"key\", required=False)\n@handle_errors()\ndef get(\n    client_obj: client.VaultClientBase,\n    text: bool,\n    output: Optional[TextIO],\n    key: Optional[str],\n    name: str,\n):\n    \"\"\"\n    Return a single secret value.\n    \"\"\"\n    secret = client_obj.get_secret(path=name, key=key)\n    force_yaml = isinstance(secret, list) or isinstance(secret, dict)\n    if text and not force_yaml:\n        if secret is None:\n            secret = \"null\"\n        click.echo(secret, file=output)\n        return\n\n    click.echo(\n        yaml.safe_dump(secret, default_flow_style=False, explicit_start=True),\n        nl=False,\n        file=output,\n    )\n\n\ndef build_kv(attributes: Sequence[str]) -> Generator[Tuple[str, str], None, None]:\n    \"\"\"\n    Converts a list of \"key=value\" to tuples (key, value).\n    If the value is \"-\" then reads the secret from stdin.\n    \"\"\"\n    for item in attributes:\n        try:\n            k, v = item.split(\"=\", 1)\n        except ValueError:\n            raise click.UsageError(\n                f\"Expecting 'key=value' arguments. '{ item }' provided.\"\n            )\n        if v == \"-\":\n            v = click.get_text_stream(\"stdin\").read()\n        yield k, v\n\n\n@cli.command(\"set\")\n@click.pass_obj\n@click.option(\n    \"--update/--clear\",\n    default=True,\n    help=\"Update the current kv mapping or replace the its content\",\n)\n@click.option(\n    \"-p\",\n    \"--prompt\",\n    is_flag=True,\n    help=\"Prompt user for values using a hidden input. Keys name are passed as arguments\",\n)\n@click.option(\n    \"--file\",\n    \"yaml_file\",\n    default=None,\n    help=\"Read key/value mapping from a file. A filename of '-' reads the standard input\",\n    type=click.File(),\n)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.argument(\"path\")\n@click.argument(\"attributes\", nargs=-1, metavar=\"[key=value...]\")\n@handle_errors()\ndef set_(\n    client_obj: client.VaultClientBase,\n    update: bool,\n    prompt: bool,\n    yaml_file: TextIO,\n    path: str,\n    attributes: Sequence[str],\n    force: Optional[bool],\n):\n    \"\"\"\n    Set a secret.\n\n    \\b\n    You can give secrets in 3 different ways:\n    - Usage: vault-cli set [OPTIONS] PATH [key=value...]\n      directly in the arguments. A value of \"-\" means that value will be read from the standard input\n    - Usage: vault-cli set [OPTIONS] PATH --prompt [key...]\n      prompt user for a values using hidden input\n    - Usage: vault-cli set [OPTIONS] PATH --file=/path/to/file\n      using a json/yaml file\n    \"\"\"\n    if bool(attributes) + bool(yaml_file) > 1:\n        raise click.UsageError(\n            \"Conflicting input methods: you can't mix --file and positional argument\"\n        )\n\n    json_value: types.JSONValue\n    if yaml_file:\n        json_value = yaml.safe_load(yaml_file)\n    elif prompt:\n        json_value = {}\n        for key in attributes:\n            json_value[key] = click.prompt(\n                f\"Please enter a value for key `{key}` of `{path}`\", hide_input=True\n            )\n    else:\n        json_value = dict(build_kv(attributes))\n\n    try:\n        client_obj.set_secret(path=path, value=json_value, force=force, update=update)\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n    click.echo(\"Done\")\n\n\n@cli.command(\"set-all\")\n@click.pass_obj\n@click.option(\n    \"--update/--clear\",\n    default=True,\n    help=\"Update the current kv mapping or replace the its content\",\n)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.argument(\n    \"yaml_file\",\n    default=\"-\",\n    type=click.File(),\n)\n@handle_errors()\ndef set_all(\n    client_obj: client.VaultClientBase,\n    update: bool,\n    force: Optional[bool],\n    yaml_file: TextIO,\n):\n    \"\"\"\n    Set multiple secrets at once from a yaml mapping.\n    \\b\n    Mapping expected format:\n    path/to/secret/a:\n        somekey: mysecret\n        otherkey: othersecret\n    path/to/secret/a:\n        yetanotherkey: [the, secret, is, a, list]\n    \"\"\"\n    secrets = yaml.safe_load(yaml_file)\n    error = \"Mapping expected format is a mapping of paths to secret objects\"\n    if not isinstance(secrets, dict) or not all(\n        isinstance(v, dict) for v in secrets.values()\n    ):\n        raise click.ClickException(error)\n\n    try:\n        client_obj.set_secrets(secrets=secrets, force=force, update=update)\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n    click.echo(\"Done\")\n\n\n@cli.command()\n@click.pass_obj\n@click.argument(\"name\")\n@click.argument(\"key\", required=False)\n@handle_errors()\ndef delete(client_obj: client.VaultClientBase, name: str, key: Optional[str]) -> None:\n    \"\"\"\n    Delete a single secret.\n    \"\"\"\n    client_obj.delete_secret(path=name, key=key)\n    click.echo(\"Done\")\n\n\n@cli.command(\"env\")\n@click.option(\n    \"-p\",\n    \"--envvar\",\n    \"--path\",\n    multiple=True,\n    help=\"\"\"\n    Load a secret from this path into one or more environment variables. Secret can be a\n    folder or single item. Pass several times to load secrets from different paths. You\n    can use --envvar mypath=prefix or --envvar mypath:key=prefix if you want to change\n    the generated names of the environment variables. --path is the original option\n    name, --envvar was added later for clarity, both work identically, and neither is\n    formerly deprecated. See command help for details.\n    \"\"\",\n)\n@click.option(\n    \"--file\",\n    multiple=True,\n    help=\"\"\"\n    Write a secret from this path into a file on the filesystem. Expected format is\n    path/in/vault[:key]=/path/in/filesystem . This option is meant to be used when\n    your command can only read its inputs from a file and not from the environment (e.g.\n    secret keys, ...). It's highly recommended to only use the option when provided with\n    a secure private temporary filesystem. Writing to a physical disk should be avoided\n    when possible. If the secret a collection (object or array), it's dumped in YAML\n    format.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--omit-single-key/--no-omit-single-key\",\n    default=False,\n    help=\"\"\"\n    When the secret has only one key, don't use that key to build the name of the\n    environment variable. This option doesn't affect --file.\n    \"\"\",\n)\n@click.option(\n    \"-f\",\n    \"--force/--no-force\",\n    default=False,\n    help=\"Run the command even if there is a problem while reading secrets\",\n)\n@click.argument(\"command\", nargs=-1, required=True)\n@click.pass_obj\n@handle_errors()\ndef env(\n    client_obj: client.VaultClientBase,\n    envvar: Sequence[str],\n    file: Sequence[str],\n    omit_single_key: bool,\n    force: bool,\n    command: Sequence[str],\n) -> NoReturn:\n    \"\"\"\n    Write secrets to disk, load secrets in environment variable, then  lauch a command.\n\n    Secrets stored as strings are loaded as-is. Secrets of any other type exported as an\n    environment variable are JSON-encoded. Secrets of any other type written to a file\n    are YAML-encoded.\n\n    LOADING ENVIRONMENT VARIABLES\n\n    If the path ends with `:key` then only one key of the mapping is used and its name is the name of the key.\n\n    By default the name is build upon the relative path to the parent of the given path (in parameter) and the name of the keys in the value mapping.\n    Let's say that we have stored the mapping `{'username': 'me', 'password': 'xxx'}` at path `a/b/c`\n\n    Using `--envvar a/b` will inject the following environment variables: B_C_USERNAME and B_C_PASSWORD\n    Using `--envvar a/b/c` will inject the following environment variables: C_USERNAME and C_PASSWORD\n    Using `--envvar a/b/c:username` will only inject `USERNAME=me` in the environment.\n\n    You can customize the variable names generation by appending `=SOME_PREFIX` to the path.\n    In this case the part corresponding to the base path is replace by your prefix.\n\n    Using `--envvar a/b=FOO` will inject the following environment variables: FOO_C_USERNAME and FOO_C_PASSWORD\n    Using `--envvar a/b/c=FOO` will inject the following environment variables: FOO_USERNAME and FOO_PASSWORD\n    Using `--envvar a/b/c:username=FOO` will inject `FOO=me` in the environment.\n    \"\"\"\n    envvars = list(envvar) or []\n    files = list(file) or []\n\n    env_secrets = {}\n\n    for path in envvars:\n        path, key, prefix = get_env_parts(path)\n        if not path and key:\n            raise click.BadOptionUsage(\n                \"envvar\", \"Cannot omit the path if a filter key is provided\"\n            )\n\n        env_updates = {}\n        env_updates = environment.get_envvars(\n            vault_client=client_obj,\n            path=path,\n            prefix=prefix,\n            omit_single_key=omit_single_key,\n            filter_key=key,\n        )\n\n        env_secrets.update(env_updates)\n\n    for file in files:\n        path, key, filesystem_path = get_env_parts(file)\n        if not (path and filesystem_path):\n            raise click.BadOptionUsage(\n                \"file\", \"--file expects both a vault path and a filesystem path\"\n            )\n        secret_obj = client_obj.get_secret(path=path, key=key or None)\n\n        if not isinstance(secret_obj, (list, dict)):\n            secret = str(secret_obj).strip() + \"\\n\"\n        else:\n            secret = yaml.safe_dump(\n                secret_obj, default_flow_style=False, explicit_start=True\n            )\n        pathlib.Path(filesystem_path).write_text(secret)\n\n    if bool(client_obj.errors) and not force:\n        raise click.ClickException(\"There was an error while reading the secrets.\")\n    environment.exec_command(command=command, environment=env_secrets)\n\n\ndef get_env_parts(value: str) -> Tuple[str, str, str]:\n    part12, _, part3 = value.partition(\"=\")\n    part1, _, part2 = part12.partition(\":\")\n    return part1, part2, part3\n\n\n@cli.command(\"dump-config\")\n@click.pass_obj\n@handle_errors()\ndef dump_config(\n    client_obj: client.VaultClientBase,\n) -> None:\n    \"\"\"\n    Display settings in the format of a config file.\n    \"\"\"\n    assert client_obj.saved_settings\n    click.echo(\n        yaml.safe_dump(\n            client_obj.saved_settings, default_flow_style=False, explicit_start=True\n        ),\n        nl=False,\n    )\n\n\n@cli.command(\"delete-all\")\n@click.option(\n    \"-f\",\n    \"--force\",\n    is_flag=True,\n    help=\"If not force, prompt for confirmation before each deletion.\",\n)\n@click.argument(\"path\", required=False, nargs=-1)\n@click.pass_obj\n@handle_errors()\ndef delete_all(\n    client_obj: client.VaultClientBase, path: Sequence[str], force: bool\n) -> None:\n    \"\"\"\n    Delete multiple secrets.\n    \"\"\"\n    paths = list(path) or [\"\"]\n\n    for secret in client_obj.delete_all_secrets(*paths, generator=True):\n        if not force and not click.confirm(text=f\"Delete '{secret}'?\", default=False):\n            raise click.Abort()\n        click.echo(f\"Deleted '{secret}'\")\n\n\n@cli.command()\n@click.argument(\"source\", required=True)\n@click.argument(\"dest\", required=True)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.pass_obj\n@handle_errors()\ndef mv(\n    client_obj: client.VaultClientBase, source: str, dest: str, force: Optional[bool]\n) -> None:\n    \"\"\"\n    Recursively move secrets from source to destination path.\n    \"\"\"\n    try:\n        for old_path, new_path in client_obj.move_secrets(\n            source=source, dest=dest, force=force, generator=True\n        ):\n            click.echo(f\"Move '{old_path}' to '{new_path}'\")\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n\n\n@cli.command()\n@click.argument(\"source\", required=True)\n@click.argument(\"dest\", required=True)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.pass_obj\n@handle_errors()\ndef cp(\n    client_obj: client.VaultClientBase, source: str, dest: str, force: Optional[bool]\n) -> None:\n    \"\"\"\n    Recursively copy secrets from source to destination path.\n    \"\"\"\n    try:\n        for old_path, new_path in client_obj.copy_secrets(\n            source=source, dest=dest, force=force, generator=True\n        ):\n            click.echo(f\"Copy '{old_path}' to '{new_path}'\")\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n\n\n@cli.command()\n@click.argument(\n    \"template\",\n    type=click.Path(exists=True, allow_dash=True, file_okay=True),\n    required=True,\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=click.File(\"w\"),\n    default=\"-\",\n    help=\"File in which to write the rendered template. \"\n    \"If ommited (or -), write in standard output\",\n)\n@click.pass_obj\n@handle_errors()\ndef template(client_obj: client.VaultClientBase, template: str, output: TextIO) -> None:\n    \"\"\"\n    Render the given template and insert secrets in it.\n\n    Rendering is done with Jinja2. A vault() function is exposed that\n    receives a path and outputs the secret at this path.\n\n    Search path (see https://jinja.palletsprojects.com/en/2.10.x/api/#jinja2.FileSystemLoader)\n    for possible Jinja2 `{% include() %}` statement is set to the template's directory.\n\n    If template is -, standard input will be read and the current working directory becomes the search path.\n\n    \"\"\"\n    if template == \"-\":\n        template_text = sys.stdin.read()\n        search_path = pathlib.Path.cwd()\n    else:\n        template_path = pathlib.Path(template)\n        template_text = template_path.read_text()\n        search_path = template_path.parent\n\n    result = client_obj.render_template(template_text, search_path=search_path)\n    output.write(result)\n\n\n@cli.command()\n@click.pass_obj\n@handle_errors()\ndef lookup_token(client_obj: client.VaultClientBase) -> None:\n    \"\"\"\n    Return information regarding the current token\n    \"\"\"\n    click.echo(\n        yaml.safe_dump(\n            client_obj.lookup_token(), default_flow_style=False, explicit_start=True\n        ),\n        nl=False,\n    )\n\n\n@cli.command(\"ssh\")\n@click.option(\n    \"--key\",\n    \"-k\",\n    help=\"Path and key of the SSH private key in the vault. Format: `path:key`.\",\n    required=True,\n)\n@click.option(\n    \"--passphrase\",\n    \"-p\",\n    help=\"Path and key of the SSH private key passphrase in the vault. Format: `path:key`.\",\n)\n@click.argument(\"command\", nargs=-1, required=True)\n@click.pass_obj\n@handle_errors()\ndef ssh_(\n    client_obj: client.VaultClientBase,\n    key: str,\n    passphrase: Optional[str],\n    command: Sequence[str],\n) -> NoReturn:\n    \"\"\"\n    Launch a command, with a configured ssh-agent running.\n\n    The ssh agent has all the keys specified as `--key` arguments.\n\n    The effect will be that any command launched through this wrapper will \"magically\"\n    (thanks to ssh-agent) be able to use the secret keys given as `--key` for their\n    ssh connections.\n    \"\"\"\n    ssh.ensure_agent()\n\n    if \":\" not in key:\n        raise click.UsageError(\"Format for private_key: `path/to/private_key:key`\")\n    private_key_name, private_key_key = key.rsplit(\":\", 1)\n    private_key_secret_obj = client_obj.get_secret(private_key_name, private_key_key)\n    private_key_secret = ensure_str(secret=private_key_secret_obj, path=key)\n\n    passphrase_secret = None\n    if passphrase:\n        if \":\" not in passphrase:\n            raise click.UsageError(\"Format for passphrase: `path/to/passphrase:key`\")\n        passphrase_name, passphrase_key = passphrase.rsplit(\":\", 1)\n        passphrase_secret_obj = client_obj.get_secret(passphrase_name, passphrase_key)\n        passphrase_secret = ensure_str(secret=passphrase_secret_obj, path=passphrase)\n\n    ssh.add_key(key=private_key_secret, passphrase=passphrase_secret)\n\n    environment.exec_command(command=command)\n\n\ndef ensure_str(secret, path) -> str:\n    if not isinstance(secret, str):\n        raise exceptions.VaultWrongType(\n            f\"secret at {path} is not a string but {type(secret)}\"\n        )\n    return secret\n\n\n# This is purposedly not called as a click subcommand, and we cannot take any argument\ndef askpass():\n    print(os.environ[ssh.SSH_PASSPHRASE_ENVVAR])\n\n\ndef main():\n    if ssh.SSH_PASSPHRASE_ENVVAR in os.environ:\n        return askpass()\n\n    # https://click.palletsprojects.com/en/7.x/python3/\n    os.environ.setdefault(\"LC_ALL\", \"C.UTF-8\")\n    os.environ.setdefault(\"LANG\", \"C.UTF-8\")\n\n    return cli()\n", "code_before": "import contextlib\nimport logging\nimport os\nimport pathlib\nimport sys\nfrom typing import (\n    Any,\n    Dict,\n    Generator,\n    Mapping,\n    NoReturn,\n    Optional,\n    Sequence,\n    TextIO,\n    Tuple,\n)\n\nimport click\nimport yaml\n\nimport vault_cli\nfrom vault_cli import client, environment, exceptions, settings, ssh, types, utils\n\nlogger = logging.getLogger(__name__)\n\nCONTEXT_SETTINGS = {\n    \"help_option_names\": [\"-h\", \"--help\"],\n    \"auto_envvar_prefix\": settings.ENV_PREFIX,\n}\n\n\ndef load_config(ctx: click.Context, param: click.Parameter, value: str) -> None:\n    if value == \"no\":\n        ctx.default_map = {}\n        return\n\n    if value is None:\n        config_files = settings.CONFIG_FILES\n    else:\n        config_files = [value]\n\n    config = settings.build_config_from_files(*config_files)\n    ctx.default_map = config\n\n\ndef set_verbosity(value: int) -> None:\n    level = settings.get_log_level(verbosity=value)\n    logging.basicConfig(level=level)\n    logger.info(f\"Log level set to {logging.getLevelName(level)}\")\n\n\ndef set_umask(umask: int) -> None:\n    os.umask(umask)\n\n\n@contextlib.contextmanager\ndef handle_errors():\n    try:\n        yield\n    except exceptions.VaultException as exc:\n        raise click.ClickException(\"\\n\".join(utils.extract_error_messages(exc)))\n\n\ndef print_version(ctx, __, value):\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(f\"vault-cli {vault_cli.__version__}\")\n    click.echo(f\"License: {vault_cli.__license__}\")\n    ctx.exit()\n\n\ndef parse_octal(value: str) -> int:\n    return int(value, base=8)\n\n\ndef click_octal(_, __, value: str) -> int:\n    return parse_octal(value)\n\n\ndef repr_octal(value: Optional[int]) -> Optional[str]:\n    # #05o means octal with 5 digits (0o octal prefix included)\n    return f\"{value:#05o}\" if value is not None else None\n\n\n@click.group(context_settings=CONTEXT_SETTINGS)\n@click.pass_context\n@click.option(\n    \"--url\", \"-U\", help=\"URL of the vault instance\", default=settings.DEFAULTS.url\n)\n@click.option(\n    \"--verify/--no-verify\",\n    default=settings.DEFAULTS.verify,\n    help=\"Verify HTTPS certificate\",\n)\n@click.option(\n    \"--ca-bundle\",\n    type=click.Path(),\n    help=\"Location of the bundle containing the server certificate \"\n    \"to check against.\",\n)\n@click.option(\n    \"--login-cert\",\n    type=click.Path(),\n    help=\"Path to a public client certificate to use for connecting to vault.\",\n)\n@click.option(\n    \"--login-cert-key\",\n    type=click.Path(),\n    help=\"Path to a private client certificate to use for connecting to vault.\",\n)\n@click.option(\n    \"--token-file\",\n    \"-T\",\n    type=click.Path(),\n    help=\"File which contains the token to connect to Vault. \"\n    'Configuration file can also contain a \"token\" key.',\n)\n@click.option(\"--username\", \"-u\", help=\"Username used for userpass authentication\")\n@click.option(\n    \"--password-file\",\n    \"-w\",\n    type=click.Path(),\n    help='Can read from stdin if \"-\" is used as parameter. '\n    'Configuration file can also contain a \"password\" key.',\n)\n@click.option(\"--base-path\", \"-b\", help=\"Base path for requests\")\n@click.option(\n    \"-s\",\n    \"--safe-write/--unsafe-write\",\n    default=settings.DEFAULTS.safe_write,\n    help=\"When activated, you can't overwrite a secret without \"\n    'passing \"--force\" (in commands \"set\", \"mv\", \"cp\", etc)',\n)\n@click.option(\n    \"--render/--no-render\",\n    default=False,\n    help=\"Deprecated / unused\",\n)\n@click.option(\n    \"--umask\",\n    callback=click_octal,\n    default=\"066\",\n    help=\"Set umask for newly created files. Defaults to files with read-write \"\n    \"for owner and nothing for group & others\",\n)\n@click.option(\n    \"-v\",\n    \"--verbose\",\n    count=True,\n    help=\"Use multiple times to increase verbosity\",\n)\n@click.option(\n    \"--config-file\",\n    is_eager=True,\n    callback=load_config,\n    help=\"Config file to use. Use 'no' to disable config file. \"\n    \"Default value: first of \" + \", \".join(settings.CONFIG_FILES),\n    type=click.Path(),\n)\n@click.option(\n    \"-V\",\n    \"--version\",\n    is_flag=True,\n    callback=print_version,\n    expose_value=False,\n    is_eager=True,\n)\n@handle_errors()\ndef cli(ctx: click.Context, verbose: int, umask: int, **kwargs) -> None:\n    \"\"\"\n    Interact with a Vault. See subcommands for details.\n\n    All arguments can be passed by environment variables: VAULT_CLI_UPPERCASE_NAME\n    (including VAULT_CLI_PASSWORD and VAULT_CLI_TOKEN).\n\n    \"\"\"\n    kwargs.pop(\"render\")\n    kwargs.pop(\"config_file\")\n    set_verbosity(verbose)\n    set_umask(umask)\n\n    assert ctx.default_map  # make mypy happy\n    kwargs.update(extract_special_args(ctx.default_map, os.environ))\n\n    # There might still be files to read, so let's do it now\n    kwargs = settings.read_all_files(kwargs)\n    saved_settings = kwargs.copy()\n\n    saved_settings.update({\"verbose\": verbose, \"umask\": repr_octal(umask)})\n\n    ctx.obj = client.get_client_class()(**kwargs)  # type: ignore\n    ctx.obj.auth()\n    ctx.obj.saved_settings = saved_settings\n\n\ndef extract_special_args(\n    config: Mapping[str, Any], environ: Mapping[str, str]\n) -> Dict[str, Any]:\n    result = {}\n    for key in [\"password\", \"token\"]:\n        result[key] = config.get(key)\n        env_var_key = \"VAULT_CLI_{}\".format(key.upper())\n        if env_var_key in environ:\n            result[key] = environ.get(env_var_key)\n\n    return result\n\n\n@cli.command(\"list\")\n@click.argument(\"path\", required=False, default=\"\")\n@click.pass_obj\n@handle_errors()\ndef list_(client_obj: client.VaultClientBase, path: str):\n    \"\"\"\n    List all the secrets at the given path. Folders are listed too. If no path\n    is given, list the objects at the root.\n    \"\"\"\n    result = client_obj.list_secrets(path=path)\n    click.echo(\"\\n\".join(result))\n\n\n@cli.command(name=\"get-all\")\n@click.option(\n    \"--flat/--no-flat\",\n    default=True,\n    show_default=True,\n    help=(\"Returns the full path as keys instead of merging paths into a tree\"),\n)\n@click.argument(\"path\", required=False, nargs=-1)\n@click.pass_obj\n@handle_errors()\ndef get_all(client_obj: client.VaultClientBase, path: Sequence[str], flat: bool):\n    \"\"\"\n    Return multiple secrets. Return a single yaml with all the secrets located\n    at the given paths. Folders are recursively explored. Without a path,\n    explores all the vault.\n    \"\"\"\n    paths = list(path) or [\"\"]\n\n    result = client_obj.get_all_secrets(*paths, flat=flat)\n\n    click.echo(\n        yaml.safe_dump(result, default_flow_style=False, explicit_start=True), nl=False\n    )\n\n\n@cli.command()\n@click.pass_obj\n@click.option(\n    \"--text/--yaml\",\n    default=True,\n    help=(\n        \"Returns the value in yaml format instead of plain text.\"\n        \"If the secret is not a string, it will always be yaml.\"\n    ),\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=click.File(\"w\"),\n    help=\"File in which to write the secret. \"\n    \"If ommited (or -), write in standard output\",\n)\n@click.argument(\"name\")\n@click.argument(\"key\", required=False)\n@handle_errors()\ndef get(\n    client_obj: client.VaultClientBase,\n    text: bool,\n    output: Optional[TextIO],\n    key: Optional[str],\n    name: str,\n):\n    \"\"\"\n    Return a single secret value.\n    \"\"\"\n    secret = client_obj.get_secret(path=name, key=key)\n    force_yaml = isinstance(secret, list) or isinstance(secret, dict)\n    if text and not force_yaml:\n        if secret is None:\n            secret = \"null\"\n        click.echo(secret, file=output)\n        return\n\n    click.echo(\n        yaml.safe_dump(secret, default_flow_style=False, explicit_start=True),\n        nl=False,\n        file=output,\n    )\n\n\ndef build_kv(attributes: Sequence[str]) -> Generator[Tuple[str, str], None, None]:\n    \"\"\"\n    Converts a list of \"key=value\" to tuples (key, value).\n    If the value is \"-\" then reads the secret from stdin.\n    \"\"\"\n    for item in attributes:\n        try:\n            k, v = item.split(\"=\", 1)\n        except ValueError:\n            raise click.UsageError(\n                f\"Expecting 'key=value' arguments. '{ item }' provided.\"\n            )\n        if v == \"-\":\n            v = click.get_text_stream(\"stdin\").read()\n        yield k, v\n\n\n@cli.command(\"set\")\n@click.pass_obj\n@click.option(\n    \"--update/--clear\",\n    default=True,\n    help=\"Update the current kv mapping or replace the its content\",\n)\n@click.option(\n    \"-p\",\n    \"--prompt\",\n    is_flag=True,\n    help=\"Prompt user for values using a hidden input. Keys name are passed as arguments\",\n)\n@click.option(\n    \"--file\",\n    \"yaml_file\",\n    default=None,\n    help=\"Read key/value mapping from a file. A filename of '-' reads the standard input\",\n    type=click.File(),\n)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.argument(\"path\")\n@click.argument(\"attributes\", nargs=-1, metavar=\"[key=value...]\")\n@handle_errors()\ndef set_(\n    client_obj: client.VaultClientBase,\n    update: bool,\n    prompt: bool,\n    yaml_file: TextIO,\n    path: str,\n    attributes: Sequence[str],\n    force: Optional[bool],\n):\n    \"\"\"\n    Set a secret.\n\n    \\b\n    You can give secrets in 3 different ways:\n    - Usage: vault-cli set [OPTIONS] PATH [key=value...]\n      directly in the arguments. A value of \"-\" means that value will be read from the standard input\n    - Usage: vault-cli set [OPTIONS] PATH --prompt [key...]\n      prompt user for a values using hidden input\n    - Usage: vault-cli set [OPTIONS] PATH --file=/path/to/file\n      using a json/yaml file\n    \"\"\"\n    if bool(attributes) + bool(yaml_file) > 1:\n        raise click.UsageError(\n            \"Conflicting input methods: you can't mix --file and positional argument\"\n        )\n\n    json_value: types.JSONValue\n    if yaml_file:\n        json_value = yaml.safe_load(yaml_file)\n    elif prompt:\n        json_value = {}\n        for key in attributes:\n            json_value[key] = click.prompt(\n                f\"Please enter a value for key `{key}` of `{path}`\", hide_input=True\n            )\n    else:\n        json_value = dict(build_kv(attributes))\n\n    try:\n        client_obj.set_secret(path=path, value=json_value, force=force, update=update)\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n    click.echo(\"Done\")\n\n\n@cli.command(\"set-all\")\n@click.pass_obj\n@click.option(\n    \"--update/--clear\",\n    default=True,\n    help=\"Update the current kv mapping or replace the its content\",\n)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.argument(\n    \"yaml_file\",\n    default=\"-\",\n    type=click.File(),\n)\n@handle_errors()\ndef set_all(\n    client_obj: client.VaultClientBase,\n    update: bool,\n    force: Optional[bool],\n    yaml_file: TextIO,\n):\n    \"\"\"\n    Set multiple secrets at once from a yaml mapping.\n    \\b\n    Mapping expected format:\n    path/to/secret/a:\n        somekey: mysecret\n        otherkey: othersecret\n    path/to/secret/a:\n        yetanotherkey: [the, secret, is, a, list]\n    \"\"\"\n    secrets = yaml.safe_load(yaml_file)\n    error = \"Mapping expected format is a mapping of paths to secret objects\"\n    if not isinstance(secrets, dict) or not all(\n        isinstance(v, dict) for v in secrets.values()\n    ):\n        raise click.ClickException(error)\n\n    try:\n        client_obj.set_secrets(secrets=secrets, force=force, update=update)\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n    click.echo(\"Done\")\n\n\n@cli.command()\n@click.pass_obj\n@click.argument(\"name\")\n@click.argument(\"key\", required=False)\n@handle_errors()\ndef delete(client_obj: client.VaultClientBase, name: str, key: Optional[str]) -> None:\n    \"\"\"\n    Delete a single secret.\n    \"\"\"\n    client_obj.delete_secret(path=name, key=key)\n    click.echo(\"Done\")\n\n\n@cli.command(\"env\")\n@click.option(\n    \"-p\",\n    \"--envvar\",\n    \"--path\",\n    multiple=True,\n    help=\"\"\"\n    Load a secret from this path into one or more environment variables. Secret can be a\n    folder or single item. Pass several times to load secrets from different paths. You\n    can use --envvar mypath=prefix or --envvar mypath:key=prefix if you want to change\n    the generated names of the environment variables. --path is the original option\n    name, --envvar was added later for clarity, both work identically, and neither is\n    formerly deprecated. See command help for details.\n    \"\"\",\n)\n@click.option(\n    \"--file\",\n    multiple=True,\n    help=\"\"\"\n    Write a secret from this path into a file on the filesystem. Expected format is\n    path/in/vault[:key]=/path/in/filesystem . This option is meant to be used when\n    your command can only read its inputs from a file and not from the environment (e.g.\n    secret keys, ...). It's highly recommended to only use the option when provided with\n    a secure private temporary filesystem. Writing to a physical disk should be avoided\n    when possible. If the secret a collection (object or array), it's dumped in YAML\n    format.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--omit-single-key/--no-omit-single-key\",\n    default=False,\n    help=\"\"\"\n    When the secret has only one key, don't use that key to build the name of the\n    environment variable. This option doesn't affect --file.\n    \"\"\",\n)\n@click.option(\n    \"-f\",\n    \"--force/--no-force\",\n    default=False,\n    help=\"Run the command even if there is a problem while reading secrets\",\n)\n@click.argument(\"command\", nargs=-1, required=True)\n@click.pass_obj\n@handle_errors()\ndef env(\n    client_obj: client.VaultClientBase,\n    envvar: Sequence[str],\n    file: Sequence[str],\n    omit_single_key: bool,\n    force: bool,\n    command: Sequence[str],\n) -> NoReturn:\n    \"\"\"\n    Write secrets to disk, load secrets in environment variable, then  lauch a command.\n\n    Secrets stored as strings are loaded as-is. Secrets of any other type exported as an\n    environment variable are JSON-encoded. Secrets of any other type written to a file\n    are YAML-encoded.\n\n    LOADING ENVIRONMENT VARIABLES\n\n    If the path ends with `:key` then only one key of the mapping is used and its name is the name of the key.\n\n    By default the name is build upon the relative path to the parent of the given path (in parameter) and the name of the keys in the value mapping.\n    Let's say that we have stored the mapping `{'username': 'me', 'password': 'xxx'}` at path `a/b/c`\n\n    Using `--envvar a/b` will inject the following environment variables: B_C_USERNAME and B_C_PASSWORD\n    Using `--envvar a/b/c` will inject the following environment variables: C_USERNAME and C_PASSWORD\n    Using `--envvar a/b/c:username` will only inject `USERNAME=me` in the environment.\n\n    You can customize the variable names generation by appending `=SOME_PREFIX` to the path.\n    In this case the part corresponding to the base path is replace by your prefix.\n\n    Using `--envvar a/b=FOO` will inject the following environment variables: FOO_C_USERNAME and FOO_C_PASSWORD\n    Using `--envvar a/b/c=FOO` will inject the following environment variables: FOO_USERNAME and FOO_PASSWORD\n    Using `--envvar a/b/c:username=FOO` will inject `FOO=me` in the environment.\n    \"\"\"\n    envvars = list(envvar) or []\n    files = list(file) or []\n\n    env_secrets = {}\n\n    for path in envvars:\n        path, key, prefix = get_env_parts(path)\n        if not path and key:\n            raise click.BadOptionUsage(\n                \"envvar\", \"Cannot omit the path if a filter key is provided\"\n            )\n\n        env_updates = {}\n        env_updates = environment.get_envvars(\n            vault_client=client_obj,\n            path=path,\n            prefix=prefix,\n            omit_single_key=omit_single_key,\n            filter_key=key,\n        )\n\n        env_secrets.update(env_updates)\n\n    for file in files:\n        path, key, filesystem_path = get_env_parts(file)\n        if not (path and filesystem_path):\n            raise click.BadOptionUsage(\n                \"file\", \"--file expects both a vault path and a filesystem path\"\n            )\n        secret_obj = client_obj.get_secret(path=path, key=key or None)\n\n        if not isinstance(secret_obj, (list, dict)):\n            secret = str(secret_obj).strip() + \"\\n\"\n        else:\n            secret = yaml.safe_dump(\n                secret_obj, default_flow_style=False, explicit_start=True\n            )\n        pathlib.Path(filesystem_path).write_text(secret)\n\n    if bool(client_obj.errors) and not force:\n        raise click.ClickException(\"There was an error while reading the secrets.\")\n    environment.exec_command(command=command, environment=env_secrets)\n\n\ndef get_env_parts(value: str) -> Tuple[str, str, str]:\n    part12, _, part3 = value.partition(\"=\")\n    part1, _, part2 = part12.partition(\":\")\n    return part1, part2, part3\n\n\n@cli.command(\"dump-config\")\n@click.pass_obj\n@handle_errors()\ndef dump_config(\n    client_obj: client.VaultClientBase,\n) -> None:\n    \"\"\"\n    Display settings in the format of a config file.\n    \"\"\"\n    assert client_obj.saved_settings\n    click.echo(\n        yaml.safe_dump(\n            client_obj.saved_settings, default_flow_style=False, explicit_start=True\n        ),\n        nl=False,\n    )\n\n\n@cli.command(\"delete-all\")\n@click.option(\n    \"-f\",\n    \"--force\",\n    is_flag=True,\n    help=\"If not force, prompt for confirmation before each deletion.\",\n)\n@click.argument(\"path\", required=False, nargs=-1)\n@click.pass_obj\n@handle_errors()\ndef delete_all(\n    client_obj: client.VaultClientBase, path: Sequence[str], force: bool\n) -> None:\n    \"\"\"\n    Delete multiple secrets.\n    \"\"\"\n    paths = list(path) or [\"\"]\n\n    for secret in client_obj.delete_all_secrets(*paths, generator=True):\n        if not force and not click.confirm(text=f\"Delete '{secret}'?\", default=False):\n            raise click.Abort()\n        click.echo(f\"Deleted '{secret}'\")\n\n\n@cli.command()\n@click.argument(\"source\", required=True)\n@click.argument(\"dest\", required=True)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.pass_obj\n@handle_errors()\ndef mv(\n    client_obj: client.VaultClientBase, source: str, dest: str, force: Optional[bool]\n) -> None:\n    \"\"\"\n    Recursively move secrets from source to destination path.\n    \"\"\"\n    try:\n        for old_path, new_path in client_obj.move_secrets(\n            source=source, dest=dest, force=force, generator=True\n        ):\n            click.echo(f\"Move '{old_path}' to '{new_path}'\")\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n\n\n@cli.command()\n@click.argument(\"source\", required=True)\n@click.argument(\"dest\", required=True)\n@click.option(\n    \"--force/--no-force\",\n    \"-f\",\n    is_flag=True,\n    default=None,\n    help=\"In case the path already holds a secret, allow overwriting it \"\n    \"(this is necessary only if --safe-write is set).\",\n)\n@click.pass_obj\n@handle_errors()\ndef cp(\n    client_obj: client.VaultClientBase, source: str, dest: str, force: Optional[bool]\n) -> None:\n    \"\"\"\n    Recursively copy secrets from source to destination path.\n    \"\"\"\n    try:\n        for old_path, new_path in client_obj.copy_secrets(\n            source=source, dest=dest, force=force, generator=True\n        ):\n            click.echo(f\"Copy '{old_path}' to '{new_path}'\")\n    except exceptions.VaultOverwriteSecretError as exc:\n        raise click.ClickException(f\"{exc}\\nUse -f to force overwriting\")\n    except exceptions.VaultMixSecretAndFolder as exc:\n        raise click.ClickException(str(exc))\n\n\n@cli.command()\n@click.argument(\n    \"template\",\n    type=click.Path(exists=True, allow_dash=True, file_okay=True),\n    required=True,\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=click.File(\"w\"),\n    default=\"-\",\n    help=\"File in which to write the rendered template. \"\n    \"If ommited (or -), write in standard output\",\n)\n@click.pass_obj\n@handle_errors()\ndef template(client_obj: client.VaultClientBase, template: str, output: TextIO) -> None:\n    \"\"\"\n    Render the given template and insert secrets in it.\n\n    Rendering is done with Jinja2. A vault() function is exposed that\n    receives a path and outputs the secret at this path.\n\n    Search path (see https://jinja.palletsprojects.com/en/2.10.x/api/#jinja2.FileSystemLoader)\n    for possible Jinja2 `{% include() %}` statement is set to the template's directory.\n\n    If template is -, standard input will be read and the current working directory becomes the search path.\n\n    \"\"\"\n    if template == \"-\":\n        template_text = sys.stdin.read()\n        search_path = pathlib.Path.cwd()\n    else:\n        template_path = pathlib.Path(template)\n        template_text = template_path.read_text()\n        search_path = template_path.parent\n\n    result = client_obj.render_template(template_text, search_path=search_path)\n    output.write(result)\n\n\n@cli.command()\n@click.pass_obj\n@handle_errors()\ndef lookup_token(client_obj: client.VaultClientBase) -> None:\n    \"\"\"\n    Return information regarding the current token\n    \"\"\"\n    click.echo(\n        yaml.safe_dump(\n            client_obj.lookup_token(), default_flow_style=False, explicit_start=True\n        ),\n        nl=False,\n    )\n\n\n@cli.command(\"ssh\")\n@click.option(\n    \"--key\",\n    \"-k\",\n    help=\"Path and key of the SSH private key in the vault. Format: `path:key`.\",\n    required=True,\n)\n@click.option(\n    \"--passphrase\",\n    \"-p\",\n    help=\"Path and key of the SSH private key passphrase in the vault. Format: `path:key`.\",\n)\n@click.argument(\"command\", nargs=-1, required=True)\n@click.pass_obj\n@handle_errors()\ndef ssh_(\n    client_obj: client.VaultClientBase,\n    key: str,\n    passphrase: Optional[str],\n    command: Sequence[str],\n) -> NoReturn:\n    \"\"\"\n    Launch a command, with a configured ssh-agent running.\n\n    The ssh agent has all the keys specified as `--key` arguments.\n\n    The effect will be that any command launched through this wrapper will \"magically\"\n    (thanks to ssh-agent) be able to use the secret keys given as `--key` for their\n    ssh connections.\n    \"\"\"\n    ssh.ensure_agent()\n\n    if \":\" not in key:\n        raise click.UsageError(\"Format for private_key: `path/to/private_key:key`\")\n    private_key_name, private_key_key = key.rsplit(\":\", 1)\n    private_key_secret_obj = client_obj.get_secret(private_key_name, private_key_key)\n    private_key_secret = ensure_str(secret=private_key_secret_obj, path=key)\n\n    passphrase_secret = None\n    if passphrase:\n        if \":\" not in passphrase:\n            raise click.UsageError(\"Format for passphrase: `path/to/passphrase:key`\")\n        passphrase_name, passphrase_key = passphrase.rsplit(\":\", 1)\n        passphrase_secret_obj = client_obj.get_secret(passphrase_name, passphrase_key)\n        passphrase_secret = ensure_str(secret=passphrase_secret_obj, path=passphrase)\n\n    ssh.add_key(key=private_key_secret, passphrase=passphrase_secret)\n\n    environment.exec_command(command=command)\n\n\ndef ensure_str(secret, path) -> str:\n    if not isinstance(secret, str):\n        raise exceptions.VaultWrongType(\n            f\"secret at {path} is not a string but {type(secret)}\"\n        )\n    return secret\n\n\n# This is purposedly not called as a click subcommand, and we cannot take any argument\ndef askpass():\n    print(os.environ[ssh.SSH_PASSPHRASE_ENVVAR])\n\n\ndef main():\n    if ssh.SSH_PASSPHRASE_ENVVAR in os.environ:\n        return askpass()\n\n    # https://click.palletsprojects.com/en/7.x/python3/\n    os.environ.setdefault(\"LC_ALL\", \"C.UTF-8\")\n    os.environ.setdefault(\"LANG\", \"C.UTF-8\")\n\n    return cli()\n", "patch": "@@ -133,8 +133,8 @@ def repr_octal(value: Optional[int]) -> Optional[str]:\n )\n @click.option(\n     \"--render/--no-render\",\n-    default=settings.DEFAULTS.render,\n-    help=\"Render templated values\",\n+    default=False,\n+    help=\"Deprecated / unused\",\n )\n @click.option(\n     \"--umask\",\n@@ -174,6 +174,7 @@ def cli(ctx: click.Context, verbose: int, umask: int, **kwargs) -> None:\n     (including VAULT_CLI_PASSWORD and VAULT_CLI_TOKEN).\n \n     \"\"\"\n+    kwargs.pop(\"render\")\n     kwargs.pop(\"config_file\")\n     set_verbosity(verbose)\n     set_umask(umask)", "file_path": "files/2021_12/201", "file_language": "py", "file_name": "vault_cli/cli.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def load_config(ctx: click.Context, param: click.Parameter, value: str) -> None:\n    if value == \"no\":\n        ctx.default_map = {}\n        return\n\n    if value is None:\n        config_files = settings.CONFIG_FILES\n    else:\n        config_files = [value]\n\n    config = settings.build_config_from_files(*config_files)\n    ctx.default_map = config", "target": 0}, {"function": "def set_verbosity(value: int) -> None:\n    level = settings.get_log_level(verbosity=value)\n    logging.basicConfig(level=level)\n    logger.info(f\"Log level set to {logging.getLevelName(level)}\")", "target": 0}, {"function": "def set_umask(umask: int) -> None:\n    os.umask(umask)", "target": 0}, {"function": "def print_version(ctx, __, value):\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(f\"vault-cli {vault_cli.__version__}\")\n    click.echo(f\"License: {vault_cli.__license__}\")\n    ctx.exit()", "target": 0}, {"function": "def parse_octal(value: str) -> int:\n    return int(value, base=8)", "target": 0}, {"function": "def click_octal(_, __, value: str) -> int:\n    return parse_octal(value)", "target": 0}, {"function": "def repr_octal(value: Optional[int]) -> Optional[str]:\n    # #05o means octal with 5 digits (0o octal prefix included)\n    return f\"{value:#05o}\" if value is not None else None", "target": 0}, {"function": "def extract_special_args(\n    config: Mapping[str, Any], environ: Mapping[str, str]\n) -> Dict[str, Any]:\n    result = {}\n    for key in [\"password\", \"token\"]:\n        result[key] = config.get(key)\n        env_var_key = \"VAULT_CLI_{}\".format(key.upper())\n        if env_var_key in environ:\n            result[key] = environ.get(env_var_key)\n\n    return result", "target": 0}, {"function": "def build_kv(attributes: Sequence[str]) -> Generator[Tuple[str, str], None, None]:\n    \"\"\"\n    Converts a list of \"key=value\" to tuples (key, value).\n    If the value is \"-\" then reads the secret from stdin.\n    \"\"\"\n    for item in attributes:\n        try:\n            k, v = item.split(\"=\", 1)\n        except ValueError:\n            raise click.UsageError(\n                f\"Expecting 'key=value' arguments. '{ item }' provided.\"\n            )\n        if v == \"-\":\n            v = click.get_text_stream(\"stdin\").read()\n        yield k, v", "target": 0}, {"function": "def get_env_parts(value: str) -> Tuple[str, str, str]:\n    part12, _, part3 = value.partition(\"=\")\n    part1, _, part2 = part12.partition(\":\")\n    return part1, part2, part3", "target": 0}, {"function": "def ensure_str(secret, path) -> str:\n    if not isinstance(secret, str):\n        raise exceptions.VaultWrongType(\n            f\"secret at {path} is not a string but {type(secret)}\"\n        )\n    return secret", "target": 0}, {"function": "def askpass():\n    print(os.environ[ssh.SSH_PASSPHRASE_ENVVAR])", "target": 0}, {"function": "def main():\n    if ssh.SSH_PASSPHRASE_ENVVAR in os.environ:\n        return askpass()\n\n    # https://click.palletsprojects.com/en/7.x/python3/\n    os.environ.setdefault(\"LC_ALL\", \"C.UTF-8\")\n    os.environ.setdefault(\"LANG\", \"C.UTF-8\")\n\n    return cli()", "target": 0}], "function_after": [{"function": "def load_config(ctx: click.Context, param: click.Parameter, value: str) -> None:\n    if value == \"no\":\n        ctx.default_map = {}\n        return\n\n    if value is None:\n        config_files = settings.CONFIG_FILES\n    else:\n        config_files = [value]\n\n    config = settings.build_config_from_files(*config_files)\n    ctx.default_map = config", "target": 0}, {"function": "def set_verbosity(value: int) -> None:\n    level = settings.get_log_level(verbosity=value)\n    logging.basicConfig(level=level)\n    logger.info(f\"Log level set to {logging.getLevelName(level)}\")", "target": 0}, {"function": "def set_umask(umask: int) -> None:\n    os.umask(umask)", "target": 0}, {"function": "def print_version(ctx, __, value):\n    if not value or ctx.resilient_parsing:\n        return\n    click.echo(f\"vault-cli {vault_cli.__version__}\")\n    click.echo(f\"License: {vault_cli.__license__}\")\n    ctx.exit()", "target": 0}, {"function": "def parse_octal(value: str) -> int:\n    return int(value, base=8)", "target": 0}, {"function": "def click_octal(_, __, value: str) -> int:\n    return parse_octal(value)", "target": 0}, {"function": "def repr_octal(value: Optional[int]) -> Optional[str]:\n    # #05o means octal with 5 digits (0o octal prefix included)\n    return f\"{value:#05o}\" if value is not None else None", "target": 0}, {"function": "def extract_special_args(\n    config: Mapping[str, Any], environ: Mapping[str, str]\n) -> Dict[str, Any]:\n    result = {}\n    for key in [\"password\", \"token\"]:\n        result[key] = config.get(key)\n        env_var_key = \"VAULT_CLI_{}\".format(key.upper())\n        if env_var_key in environ:\n            result[key] = environ.get(env_var_key)\n\n    return result", "target": 0}, {"function": "def build_kv(attributes: Sequence[str]) -> Generator[Tuple[str, str], None, None]:\n    \"\"\"\n    Converts a list of \"key=value\" to tuples (key, value).\n    If the value is \"-\" then reads the secret from stdin.\n    \"\"\"\n    for item in attributes:\n        try:\n            k, v = item.split(\"=\", 1)\n        except ValueError:\n            raise click.UsageError(\n                f\"Expecting 'key=value' arguments. '{ item }' provided.\"\n            )\n        if v == \"-\":\n            v = click.get_text_stream(\"stdin\").read()\n        yield k, v", "target": 0}, {"function": "def get_env_parts(value: str) -> Tuple[str, str, str]:\n    part12, _, part3 = value.partition(\"=\")\n    part1, _, part2 = part12.partition(\":\")\n    return part1, part2, part3", "target": 0}, {"function": "def ensure_str(secret, path) -> str:\n    if not isinstance(secret, str):\n        raise exceptions.VaultWrongType(\n            f\"secret at {path} is not a string but {type(secret)}\"\n        )\n    return secret", "target": 0}, {"function": "def askpass():\n    print(os.environ[ssh.SSH_PASSPHRASE_ENVVAR])", "target": 0}, {"function": "def main():\n    if ssh.SSH_PASSPHRASE_ENVVAR in os.environ:\n        return askpass()\n\n    # https://click.palletsprojects.com/en/7.x/python3/\n    os.environ.setdefault(\"LC_ALL\", \"C.UTF-8\")\n    os.environ.setdefault(\"LANG\", \"C.UTF-8\")\n\n    return cli()", "target": 0}]}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/vault_cli%2Fclient.py", "code": "import contextlib\nimport json\nimport logging\nimport pathlib\nfrom typing import Dict, Iterable, List, Optional, Tuple, Type, cast\n\nimport hvac  # type: ignore\nimport jinja2\nimport requests.packages.urllib3\n\nfrom vault_cli import exceptions, sessions, settings, types, utils\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_client(**kwargs) -> \"VaultClientBase\":\n    \"\"\"\n    Reads the kwargs and associates them with the\n    config files and default values to produce\n    a configured client object ready to do calls.\n\n    All parameters are optional.\n\n    Parameters\n    ----------\n\n    url : str\n        URL of the vault instance (default: https://localhost:8200)\n    verify : bool\n        Verify HTTPS certificate (default: True)\n    ca_bundle: str\n        Path to your CA bundle to check the certificate if non standard\n    base_path : str\n        Base path prepended to any requested path that doesn't start with /\n    login_cert : str\n        path to the public certificate to connect to the vault\n    login_cert_key : str\n        path to the certificate key to connect to the vault\n    token : str\n        Token to connect to Vault\n    username : str\n        Username used for userpass authentication\n    password : str\n        Path to the file containing the password for userpass authentication\n    config_file: str\n        Path to your config file, instead of the default ones\n    safe_write : bool\n        If set to True, will keep you from overwriting secrets without force=True\n\n    Returns\n    -------\n    A VaultClient object\n    \"\"\"\n    options = settings.get_vault_options(**kwargs)\n    client = get_client_class()(**options)\n    client.auth()\n    return client\n\n\ndef get_client_class() -> Type[\"VaultClientBase\"]:\n    return VaultClient\n\n\nclass VaultClientBase:\n\n    saved_settings: Optional[types.SettingsDict] = None\n\n    def __init__(\n        self,\n        url: str = settings.DEFAULTS.url,\n        verify: bool = settings.DEFAULTS.verify,\n        ca_bundle: Optional[str] = settings.DEFAULTS.ca_bundle,\n        base_path: Optional[str] = settings.DEFAULTS.base_path,\n        login_cert: Optional[str] = settings.DEFAULTS.login_cert,\n        login_cert_key: Optional[str] = settings.DEFAULTS.login_cert_key,\n        token: Optional[str] = settings.DEFAULTS.token,\n        username: Optional[str] = settings.DEFAULTS.username,\n        password: Optional[str] = settings.DEFAULTS.password,\n        safe_write: bool = settings.DEFAULTS.safe_write,\n    ):\n        self.url = url\n        self.verify: types.VerifyOrCABundle = verify\n        self.ca_bundle = ca_bundle\n        self.base_path = base_path\n        self.login_cert = login_cert\n        self.login_cert_key = login_cert_key\n        self.token = token\n        self.username = username\n        self.password = password\n        self.safe_write = safe_write\n        self.cache: Dict[str, types.JSONDict] = {}\n        self.errors: List[str] = []\n\n    @property\n    def base_path(self):\n        return self._base_path\n\n    @base_path.setter\n    def base_path(self, path: str):\n        # ensure the base_path ends with a single '/'\n        self._base_path = (f\"/{path.strip('/')}/\") if path else \"\"\n\n    def auth(self):\n        verify_ca_bundle = self.verify\n        if self.verify and self.ca_bundle:\n            verify_ca_bundle = self.ca_bundle\n\n        # Temporary workaround for https://github.com/urllib3/urllib3/issues/497\n        requests.packages.urllib3.disable_warnings()\n\n        self._init_client(\n            url=self.url,\n            verify=verify_ca_bundle,\n            login_cert=self.login_cert,\n            login_cert_key=self.login_cert_key,\n        )\n\n        if self.token:\n            self._authenticate_token(self.token)\n        elif self.login_cert:\n            if self.login_cert_key:\n                self._authenticate_certificate()\n            else:\n                raise exceptions.VaultAuthenticationError(\n                    \"Cannot use certificate file for login without key file\"\n                )\n        elif self.username:\n            if not self.password:\n                raise exceptions.VaultAuthenticationError(\n                    \"Cannot use username without password file\"\n                )\n            self._authenticate_userpass(username=self.username, password=self.password)\n\n        else:\n            raise exceptions.VaultAuthenticationError(\n                \"No authentication method supplied\"\n            )\n\n    def get_force(self, force: Optional[bool]) -> bool:\n        return force if force is not None else not self.safe_write\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        Implement this with the relevant behaviour in children classes\n        for when exiting the client used as context manager.\n        \"\"\"\n        self.cache = {}\n        self.errors = []\n\n    def _build_full_path(self, path: str) -> str:\n        if path.startswith(\"/\"):\n            # absolute path\n            return path\n        else:\n            # path relative to base_path\n            return self.base_path + path\n\n    def _browse_recursive_secrets(self, path: str) -> Iterable[str]:\n        \"\"\"\n        Given a secret or folder path, return the path of all secrets\n        under it (or the path itself)\n        \"\"\"\n        # 4 things can happen:\n        # - path is \"\", it's the root (and a folder)\n        # - path ends with /, we know it's a folder\n        # - path doesn't end with a / and yet it's a folder\n        # - path is a secret\n        folder = path.endswith(\"/\") or path == \"\"\n\n        sub_secrets = self.list_secrets(path=path)\n\n        if not folder and not sub_secrets:\n            # It's most probably a secret\n            yield path\n\n        for key in sub_secrets:\n            folder = key.endswith(\"/\")\n            key = key.rstrip(\"/\")\n            key_url = f\"{path}/{key}\" if path else key\n            if not folder:\n                yield key_url\n                continue\n\n            for sub_path in self._browse_recursive_secrets(key_url):\n                yield sub_path\n\n    def get_all_secrets(self, *paths: str, flat: bool = False) -> types.JSONDict:\n        \"\"\"\n        Takes several paths, return the nested dict of all secrets below\n        those paths\n\n        Parameters\n        ----------\n        *paths : str\n            Paths to read recursively\n        flat : bool, optional\n            Whether to return flat structure with full path as keys or nested\n            structure that looks like a tree\n\n        Returns\n        -------\n        types.JSONDict\n            {\"folder\": {\"subfolder\": {\"secret_key\": \"secret_value\"}}}\n        \"\"\"\n\n        result: types.JSONDict = {}\n\n        for path in paths:\n            path_dict = self.get_secrets(path)\n            if flat:\n                result.update(path_dict)\n            else:\n                result.update(utils.path_to_nested(path_dict))\n\n        return result\n\n    def get_secrets(\n        self, path: str, relative: bool = False\n    ) -> Dict[str, types.JSONDict]:\n        \"\"\"\n        Takes a path, return all secrets below this path\n\n        Parameters\n        ----------\n        path : str\n            Path to read recursively\n        relative: bool, optional\n            When false (default), the keys of the returned dict are the paths of the secrets\n            When true, the keys are the relative paths of the secret to `path` (`\"\"` if the secret is directly at path `path`)\n\n        Returns\n        -------\n        types.JSONDict\n            {\"folder/subfolder\": {\"secret_key\": \"secret_value\"}}\n        \"\"\"\n        path = path.rstrip(\"/\")\n        try:\n            secrets_paths = list(self._browse_recursive_secrets(path=path))\n        except exceptions.VaultAPIException:\n            # If we cannot list secrets, we can't browse them, but there's still\n            # a chance that the provided path is a single secret that we can\n            # read\n            secrets_paths = [path]\n\n        result: Dict[str, types.JSONDict] = {}\n        path_obj = pathlib.Path(path)\n        for subpath in secrets_paths:\n            if relative:\n                if subpath == path:\n                    key = \"\"\n                else:\n                    key = str(pathlib.Path(subpath).relative_to(path_obj))\n            else:\n                key = subpath\n\n            try:\n                secret = self.get_secret(path=subpath)\n                secret = cast(types.JSONDict, secret)\n                result[key] = secret\n            except exceptions.VaultAPIException as exc:\n                for message in utils.extract_error_messages(exc):\n                    logger.error(message)\n                    self.errors.append(message)\n                result[key] = {}\n\n        return result\n\n    def list_secrets(self, path: str) -> Iterable[str]:\n        \"\"\"\n        List secrets at the given path, without reading their values\n\n        Parameters\n        ----------\n        path : str\n            Folder in which to explore the secrets\n\n        Returns\n        -------\n        Iterable[str]\n            Iterable of secret names\n        \"\"\"\n        return self._list_secrets(path=self._build_full_path(path))\n\n    def get_secret(self, path: str, key: Optional[str] = None) -> types.JSONValue:\n        \"\"\"\n        Retrieve the value of a single secret\n\n        Parameters\n        ----------\n        path : str\n            Path of the secret\n\n        key : str, optional\n            If set, return only this key\n\n        Returns\n        -------\n        types.JSONValue\n            Secret value\n        \"\"\"\n        full_path = self._build_full_path(path)\n\n        assert self.cache is not None\n        try:\n            mapping = self.cache[full_path]\n        except KeyError:\n            mapping = self.cache[full_path] = self._get_secret(path=full_path)\n\n        if key is not None:\n            try:\n                secret = mapping[key]\n            except KeyError:\n                raise exceptions.VaultSecretNotFound(\n                    errors=[f\"Key '{key}' not found in secret at path '{full_path}'\"]\n                )\n        else:\n            secret = mapping\n\n        return secret\n\n    def delete_secret(self, path: str, key: Optional[str] = None) -> None:\n        \"\"\"\n        Delete a secret\n\n        Parameters\n        ----------\n        path : str\n            Path to the secret\n\n        key : str, optional\n            Do not delete the whole mapping but only this key\n\n        \"\"\"\n        if key is None:\n            self._delete_secret(path=self._build_full_path(path))\n        else:\n            # Delete only one attribute\n            try:\n                secret = self.get_secret(path)\n            except exceptions.VaultSecretNotFound:\n                # secret does not exist\n                return\n\n            try:\n                assert isinstance(secret, dict)\n                secret.pop(key)\n            except (KeyError, AssertionError):\n                # nothing to delete\n                return\n\n            if secret:\n                # update the secret with the new mapping\n                self.set_secret(path, secret, force=True)\n            else:\n                # no more entries in the mapping, delete the whole path\n                self._delete_secret(path=self._build_full_path(path))\n\n    def delete_all_secrets_iter(self, *paths: str) -> Iterable[str]:\n        for path in paths:\n            path = path.rstrip(\"/\")\n            secrets_paths = self._browse_recursive_secrets(path=path)\n            for secret_path in secrets_paths:\n                yield secret_path\n                self.delete_secret(secret_path)\n\n    def delete_all_secrets(self, *paths: str, generator: bool = False) -> Iterable[str]:\n        \"\"\"\n        If generator is True, recursively yields secret paths then deletes\n        the secrets at the given paths. If False, just delete the secrets and\n        return the list of paths.\n\n        Parameters\n        ----------\n        generator : bool, optional\n            Whether of not to yield before deletion, by default False\n\n        Returns\n        -------\n        Iterable[str]\n            Path to the deleted/to be deleted secrets\n        \"\"\"\n        iterator = self.delete_all_secrets_iter(*paths)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def copy_secrets_iter(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        delete_source: Optional[bool] = False,\n    ) -> Iterable[Tuple[str, str]]:\n\n        source_secrets = self.get_secrets(path=source)\n\n        for old_path, secret in source_secrets.items():\n            new_path = dest + old_path[len(source) :]\n            secret = source_secrets[old_path]\n\n            yield (old_path, new_path)\n\n            secret_ = cast(types.JSONDict, secret)\n            self.set_secret(new_path, secret_, force=force)\n            if delete_source:\n                self.delete_secret(old_path)\n\n    def move_secrets_iter(\n        self, source: str, dest: str, force: Optional[bool] = None\n    ) -> Iterable[Tuple[str, str]]:\n        return self.copy_secrets_iter(source, dest, force, delete_source=True)\n\n    def move_secrets(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        generator: bool = False,\n    ) -> Iterable[Tuple[str, str]]:\n        \"\"\"\n        Yield current and new paths, then move a secret or a folder\n        to a new path\n\n        Parameters\n        ----------\n        source : str\n            Path of the secret to move\n        dest : str\n            New path for the secret\n        force : Optional[bool], optional\n            Allow overwriting exiting secret, if safe_mode is True\n        generator : bool, optional\n            Whether of not to yield before move, by default False\n\n        Returns\n        -------\n        Iterable[Tuple[str, str]]\n            [(Current path, new path)]\n        \"\"\"\n        iterator = self.move_secrets_iter(source=source, dest=dest, force=force)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def copy_secrets(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        generator: bool = False,\n    ) -> Iterable[Tuple[str, str]]:\n        \"\"\"\n        Yield current and new paths, then copy a secret or a folder\n        to a new path\n\n        Parameters\n        ----------\n        source : str\n            Path of the secret to move\n        dest : str\n            New path for the secret\n        force : Optional[bool], optional\n            Allow overwriting exiting secret, if safe_mode is True\n        generator : bool, optional\n            Whether of not to yield before move, by default False\n\n        Returns\n        -------\n        Iterable[Tuple[str, str]]\n            [(Current path, new path)]\n        \"\"\"\n        iterator = self.copy_secrets_iter(source=source, dest=dest, force=force)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def render_template(\n        self,\n        template: str,\n        search_path: pathlib.Path = pathlib.Path(\".\"),\n    ) -> str:\n        \"\"\"\n        Renders a template to a string, giving it access to a `vault` function\n        that can read from the vault\n\n        Parameters\n        ----------\n        template : str\n            Jinja template string\n        render : bool, optional\n            Whether template secrets should be rendered, by default True\n        search_path: pathlib.Path object, optional\n            search path for additional Jinja2 templates, by default current working directory\n            See https://jinja.palletsprojects.com/en/2.10.x/api/#jinja2.FileSystemLoader\n\n        Returns\n        -------\n        str\n            The rendered template\n\n        Raises\n        ------\n        exceptions.VaultRenderTemplateError\n            If a secret is not found or access is forbidden\n        \"\"\"\n\n        def vault(path):\n            try:\n                return self.get_secret(path)\n            except exceptions.VaultException as exc:\n                raise exceptions.VaultRenderTemplateError(\n                    \"Error while rendering template\"\n                ) from exc\n\n        env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(search_path.as_posix()),\n            keep_trailing_newline=True,\n        )\n        try:\n            return env.from_string(template).render(vault=vault)\n        except jinja2.exceptions.TemplateSyntaxError as exc:\n            raise exceptions.VaultRenderTemplateError(\n                \"Jinja2 template syntax error\"\n            ) from exc\n\n    def set_secret(\n        self,\n        path: str,\n        value: types.JSONValue,\n        force: Optional[bool] = None,\n        update: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        Sets the value of a secret\n\n        Parameters\n        ----------\n        path : str\n            Path to the secret\n        value : types.JSONValue\n            Value of the secret\n        force : Optional[bool], optional\n            If safe_mode is True, whether to overwrite existing secret\n        update: Optional[bool], optional\n            If true then merge the value with the existing one, else overwrite it\n\n        Raises\n        ------\n        exceptions.VaultOverwriteSecretError\n            Cannot overwrite a secret if safe_mode is True and force is False\n        exceptions.VaultMixSecretAndFolder\n            Either the path is an existing folder or a parent folder is a secret\n        \"\"\"\n        assert isinstance(value, dict)\n\n        force = self.get_force(force)\n\n        try:\n            existing_value = self.get_secret(path=path)\n            assert isinstance(existing_value, dict)\n        except exceptions.VaultSecretNotFound:\n            pass\n        except exceptions.VaultForbidden:\n            logger.warning(\n                f\"Read access '{path}' forbidden: if it exists, secret will be overridden.\"\n            )\n        else:\n            # if we overwrite the whole mapping we can compare the value directly\n            # if we update the mapping, we only have to check the updated keys\n            if not update and not force and existing_value != value:\n                raise exceptions.VaultOverwriteSecretError(path=path)\n            if update and not force:\n                redefined = [\n                    key\n                    for key in (value.keys() & existing_value.keys())\n                    if existing_value[key] != value[key]\n                ]\n                if any(redefined):\n                    raise exceptions.VaultOverwriteSecretError(\n                        path=path, keys=redefined\n                    )\n\n            if update:\n                # merge value with existing_value\n                value = {**existing_value, **value}\n\n        try:\n            problematic_secrets = self.list_secrets(path=path)\n            if problematic_secrets:\n                secrets = [f\"{path}/{secret}\" for secret in problematic_secrets]\n                raise exceptions.VaultMixSecretAndFolder(\n                    f\"Cannot create a secret at '{path}' because it is already a \"\n                    f\"folder containing {', '.join(secrets)}\"\n                )\n        except exceptions.VaultForbidden:\n            logger.info(\n                f\"List '{path}' forbidden: if it exists, secret will be overridden.\"\n            )\n\n        path = path.rstrip(\"/\")\n        for parent in list(pathlib.PurePath(path).parents)[:-1]:\n            try:\n                self.get_secret(str(parent))\n            except exceptions.VaultSecretNotFound:\n                pass\n            except exceptions.VaultForbidden:\n                logger.info(\n                    f\"Read access '{parent}' forbidden: cannot check if a secret exists here.\"\n                )\n            else:\n                raise exceptions.VaultMixSecretAndFolder(\n                    f\"Cannot create a secret at '{path}' because '{parent}' already exists as a secret\"\n                )\n\n        self._set_secret(path=self._build_full_path(path), secret=value)\n\n    def set_secrets(\n        self,\n        secrets: Dict[str, types.JSONDict],\n        force: Optional[bool] = None,\n        update: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        Sets the value of multiple secrets at once. See possible exceptions\n        in\n\n        Parameters\n        ----------\n        secrets :\n            A mapping of secret path -> value, corresponding to the output\n            of `VaultClientBase.get_secrets`\n        force : Optional[bool], optional\n            If safe_mode is True, whether to overwrite existing secrets\n        update: Optional[bool], optional\n            If true then merge the value with the existing one, else overwrite it\n\n        Raises\n        ------\n        see `VaultClientBase.set_secrets`\n        \"\"\"\n        for path, value in secrets.items():\n            self.set_secret(path=path, value=value, force=force, update=update)\n\n    def _init_client(\n        self,\n        url: str,\n        verify: types.VerifyOrCABundle,\n        login_cert: Optional[str],\n        login_cert_key: Optional[str],\n    ) -> None:\n        raise NotImplementedError\n\n    def _authenticate_token(self, token: str) -> None:\n        raise NotImplementedError\n\n    def _authenticate_certificate(self) -> None:\n        raise NotImplementedError\n\n    def _authenticate_userpass(self, username: str, password: str) -> None:\n        raise NotImplementedError\n\n    def _list_secrets(self, path: str) -> Iterable[str]:\n        raise NotImplementedError\n\n    def _get_secret(self, path: str) -> Dict[str, types.JSONValue]:\n        raise NotImplementedError\n\n    def _delete_secret(self, path: str) -> None:\n        raise NotImplementedError\n\n    def _set_secret(self, path: str, secret: Dict[str, types.JSONValue]) -> None:\n        raise NotImplementedError\n\n    def lookup_token(self) -> types.JSONDict:\n        return self._lookup_token()\n\n    def _lookup_token(self) -> types.JSONDict:\n        raise NotImplementedError\n\n\n@contextlib.contextmanager\ndef handle_errors():\n    try:\n        yield\n    except json.decoder.JSONDecodeError as exc:\n        raise exceptions.VaultNonJsonResponse(errors=[str(exc)])\n    except hvac.exceptions.InvalidRequest as exc:\n        raise exceptions.VaultInvalidRequest(errors=exc.errors) from exc\n    except hvac.exceptions.Unauthorized as exc:\n        raise exceptions.VaultUnauthorized(errors=exc.errors) from exc\n    except hvac.exceptions.Forbidden as exc:\n        raise exceptions.VaultForbidden(errors=exc.errors) from exc\n    except hvac.exceptions.InternalServerError as exc:\n        raise exceptions.VaultInternalServerError(errors=exc.errors) from exc\n    except hvac.exceptions.VaultDown as exc:\n        raise exceptions.VaultSealed(errors=exc.errors) from exc\n    except hvac.exceptions.UnexpectedError as exc:\n        raise exceptions.VaultAPIException(errors=exc.errors) from exc\n    except requests.exceptions.ConnectionError as exc:\n        raise exceptions.VaultConnectionError() from exc\n\n\nclass VaultClient(VaultClientBase):\n    @handle_errors()\n    def _init_client(\n        self,\n        url: str,\n        verify: types.VerifyOrCABundle,\n        login_cert: Optional[str],\n        login_cert_key: Optional[str],\n    ) -> None:\n        self.session = sessions.Session()\n        self.session.verify = verify\n\n        cert = None\n        if login_cert and login_cert_key:\n            cert = (login_cert, login_cert_key)\n\n        self.client = hvac.Client(\n            url=url, verify=verify, session=self.session, cert=cert\n        )\n\n    def _authenticate_token(self, token: str) -> None:\n        self.client.token = token\n\n    @handle_errors()\n    def _authenticate_userpass(self, username: str, password: str) -> None:\n        self.client.auth_userpass(username, password)\n\n    @handle_errors()\n    def _authenticate_certificate(self) -> None:\n        self.client.auth_tls()\n\n    @handle_errors()\n    def _list_secrets(self, path: str) -> Iterable[str]:\n        secrets = self.client.list(path)\n        if not secrets:\n            return []\n        return sorted(secrets[\"data\"][\"keys\"])\n\n    @handle_errors()\n    def _get_secret(self, path: str) -> Dict[str, types.JSONValue]:\n        secret = self.client.read(path)\n        if not secret:\n            raise exceptions.VaultSecretNotFound(\n                errors=[f\"Secret not found at path '{path}'\"]\n            )\n        return secret[\"data\"]\n\n    @handle_errors()\n    def _delete_secret(self, path: str) -> None:\n        self.client.delete(path)\n\n    @handle_errors()\n    def _set_secret(self, path: str, secret: Dict[str, types.JSONValue]) -> None:\n        self.client.write(path, **secret)\n\n    @handle_errors()\n    def _lookup_token(self) -> types.JSONDict:\n        return self.client.lookup_token()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        super().__exit__(exc_type, exc_value, traceback)\n        self.session.__exit__(exc_type, exc_value, traceback)\n", "code_before": "import contextlib\nimport json\nimport logging\nimport pathlib\nfrom typing import Dict, Iterable, List, Optional, Tuple, Type, cast\n\nimport hvac  # type: ignore\nimport jinja2\nimport requests.packages.urllib3\n\nfrom vault_cli import exceptions, sessions, settings, types, utils\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_client(**kwargs) -> \"VaultClientBase\":\n    \"\"\"\n    Reads the kwargs and associates them with the\n    config files and default values to produce\n    a configured client object ready to do calls.\n\n    All parameters are optional.\n\n    Parameters\n    ----------\n\n    url : str\n        URL of the vault instance (default: https://localhost:8200)\n    verify : bool\n        Verify HTTPS certificate (default: True)\n    ca_bundle: str\n        Path to your CA bundle to check the certificate if non standard\n    base_path : str\n        Base path prepended to any requested path that doesn't start with /\n    login_cert : str\n        path to the public certificate to connect to the vault\n    login_cert_key : str\n        path to the certificate key to connect to the vault\n    token : str\n        Token to connect to Vault\n    username : str\n        Username used for userpass authentication\n    password : str\n        Path to the file containing the password for userpass authentication\n    config_file: str\n        Path to your config file, instead of the default ones\n    safe_write : bool\n        If set to True, will keep you from overwriting secrets without force=True\n\n    Returns\n    -------\n    A VaultClient object\n    \"\"\"\n    options = settings.get_vault_options(**kwargs)\n    client = get_client_class()(**options)\n    client.auth()\n    return client\n\n\ndef get_client_class() -> Type[\"VaultClientBase\"]:\n    return VaultClient\n\n\nclass VaultClientBase:\n\n    saved_settings: Optional[types.SettingsDict] = None\n\n    def __init__(\n        self,\n        url: str = settings.DEFAULTS.url,\n        verify: bool = settings.DEFAULTS.verify,\n        ca_bundle: Optional[str] = settings.DEFAULTS.ca_bundle,\n        base_path: Optional[str] = settings.DEFAULTS.base_path,\n        login_cert: Optional[str] = settings.DEFAULTS.login_cert,\n        login_cert_key: Optional[str] = settings.DEFAULTS.login_cert_key,\n        token: Optional[str] = settings.DEFAULTS.token,\n        username: Optional[str] = settings.DEFAULTS.username,\n        password: Optional[str] = settings.DEFAULTS.password,\n        safe_write: bool = settings.DEFAULTS.safe_write,\n    ):\n        self.url = url\n        self.verify: types.VerifyOrCABundle = verify\n        self.ca_bundle = ca_bundle\n        self.base_path = base_path\n        self.login_cert = login_cert\n        self.login_cert_key = login_cert_key\n        self.token = token\n        self.username = username\n        self.password = password\n        self.safe_write = safe_write\n        self.cache: Dict[str, types.JSONDict] = {}\n        self.errors: List[str] = []\n\n    @property\n    def base_path(self):\n        return self._base_path\n\n    @base_path.setter\n    def base_path(self, path: str):\n        # ensure the base_path ends with a single '/'\n        self._base_path = (f\"/{path.strip('/')}/\") if path else \"\"\n\n    def auth(self):\n        verify_ca_bundle = self.verify\n        if self.verify and self.ca_bundle:\n            verify_ca_bundle = self.ca_bundle\n\n        # Temporary workaround for https://github.com/urllib3/urllib3/issues/497\n        requests.packages.urllib3.disable_warnings()\n\n        self._init_client(\n            url=self.url,\n            verify=verify_ca_bundle,\n            login_cert=self.login_cert,\n            login_cert_key=self.login_cert_key,\n        )\n\n        if self.token:\n            self._authenticate_token(self.token)\n        elif self.login_cert:\n            if self.login_cert_key:\n                self._authenticate_certificate()\n            else:\n                raise exceptions.VaultAuthenticationError(\n                    \"Cannot use certificate file for login without key file\"\n                )\n        elif self.username:\n            if not self.password:\n                raise exceptions.VaultAuthenticationError(\n                    \"Cannot use username without password file\"\n                )\n            self._authenticate_userpass(username=self.username, password=self.password)\n\n        else:\n            raise exceptions.VaultAuthenticationError(\n                \"No authentication method supplied\"\n            )\n\n    def get_force(self, force: Optional[bool]) -> bool:\n        return force if force is not None else not self.safe_write\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        Implement this with the relevant behaviour in children classes\n        for when exiting the client used as context manager.\n        \"\"\"\n        self.cache = {}\n        self.errors = []\n\n    def _build_full_path(self, path: str) -> str:\n        if path.startswith(\"/\"):\n            # absolute path\n            return path\n        else:\n            # path relative to base_path\n            return self.base_path + path\n\n    def _browse_recursive_secrets(self, path: str) -> Iterable[str]:\n        \"\"\"\n        Given a secret or folder path, return the path of all secrets\n        under it (or the path itself)\n        \"\"\"\n        # 4 things can happen:\n        # - path is \"\", it's the root (and a folder)\n        # - path ends with /, we know it's a folder\n        # - path doesn't end with a / and yet it's a folder\n        # - path is a secret\n        folder = path.endswith(\"/\") or path == \"\"\n\n        sub_secrets = self.list_secrets(path=path)\n\n        if not folder and not sub_secrets:\n            # It's most probably a secret\n            yield path\n\n        for key in sub_secrets:\n            folder = key.endswith(\"/\")\n            key = key.rstrip(\"/\")\n            key_url = f\"{path}/{key}\" if path else key\n            if not folder:\n                yield key_url\n                continue\n\n            for sub_path in self._browse_recursive_secrets(key_url):\n                yield sub_path\n\n    def get_all_secrets(self, *paths: str, flat: bool = False) -> types.JSONDict:\n        \"\"\"\n        Takes several paths, return the nested dict of all secrets below\n        those paths\n\n        Parameters\n        ----------\n        *paths : str\n            Paths to read recursively\n        flat : bool, optional\n            Whether to return flat structure with full path as keys or nested\n            structure that looks like a tree\n\n        Returns\n        -------\n        types.JSONDict\n            {\"folder\": {\"subfolder\": {\"secret_key\": \"secret_value\"}}}\n        \"\"\"\n\n        result: types.JSONDict = {}\n\n        for path in paths:\n            path_dict = self.get_secrets(path)\n            if flat:\n                result.update(path_dict)\n            else:\n                result.update(utils.path_to_nested(path_dict))\n\n        return result\n\n    def get_secrets(\n        self, path: str, relative: bool = False\n    ) -> Dict[str, types.JSONDict]:\n        \"\"\"\n        Takes a path, return all secrets below this path\n\n        Parameters\n        ----------\n        path : str\n            Path to read recursively\n        relative: bool, optional\n            When false (default), the keys of the returned dict are the paths of the secrets\n            When true, the keys are the relative paths of the secret to `path` (`\"\"` if the secret is directly at path `path`)\n\n        Returns\n        -------\n        types.JSONDict\n            {\"folder/subfolder\": {\"secret_key\": \"secret_value\"}}\n        \"\"\"\n        path = path.rstrip(\"/\")\n        try:\n            secrets_paths = list(self._browse_recursive_secrets(path=path))\n        except exceptions.VaultAPIException:\n            # If we cannot list secrets, we can't browse them, but there's still\n            # a chance that the provided path is a single secret that we can\n            # read\n            secrets_paths = [path]\n\n        result: Dict[str, types.JSONDict] = {}\n        path_obj = pathlib.Path(path)\n        for subpath in secrets_paths:\n            if relative:\n                if subpath == path:\n                    key = \"\"\n                else:\n                    key = str(pathlib.Path(subpath).relative_to(path_obj))\n            else:\n                key = subpath\n\n            try:\n                secret = self.get_secret(path=subpath)\n                secret = cast(types.JSONDict, secret)\n                result[key] = secret\n            except exceptions.VaultAPIException as exc:\n                for message in utils.extract_error_messages(exc):\n                    logger.error(message)\n                    self.errors.append(message)\n                result[key] = {}\n\n        return result\n\n    def list_secrets(self, path: str) -> Iterable[str]:\n        \"\"\"\n        List secrets at the given path, without reading their values\n\n        Parameters\n        ----------\n        path : str\n            Folder in which to explore the secrets\n\n        Returns\n        -------\n        Iterable[str]\n            Iterable of secret names\n        \"\"\"\n        return self._list_secrets(path=self._build_full_path(path))\n\n    def get_secret(self, path: str, key: Optional[str] = None) -> types.JSONValue:\n        \"\"\"\n        Retrieve the value of a single secret\n\n        Parameters\n        ----------\n        path : str\n            Path of the secret\n\n        key : str, optional\n            If set, return only this key\n\n        Returns\n        -------\n        types.JSONValue\n            Secret value\n        \"\"\"\n        full_path = self._build_full_path(path)\n\n        assert self.cache is not None\n        try:\n            mapping = self.cache[full_path]\n        except KeyError:\n            mapping = self.cache[full_path] = self._get_secret(path=full_path)\n\n        if key is not None:\n            try:\n                secret = mapping[key]\n            except KeyError:\n                raise exceptions.VaultSecretNotFound(\n                    errors=[f\"Key '{key}' not found in secret at path '{full_path}'\"]\n                )\n        else:\n            secret = mapping\n\n        return secret\n\n    def delete_secret(self, path: str, key: Optional[str] = None) -> None:\n        \"\"\"\n        Delete a secret\n\n        Parameters\n        ----------\n        path : str\n            Path to the secret\n\n        key : str, optional\n            Do not delete the whole mapping but only this key\n\n        \"\"\"\n        if key is None:\n            self._delete_secret(path=self._build_full_path(path))\n        else:\n            # Delete only one attribute\n            try:\n                secret = self.get_secret(path)\n            except exceptions.VaultSecretNotFound:\n                # secret does not exist\n                return\n\n            try:\n                assert isinstance(secret, dict)\n                secret.pop(key)\n            except (KeyError, AssertionError):\n                # nothing to delete\n                return\n\n            if secret:\n                # update the secret with the new mapping\n                self.set_secret(path, secret, force=True)\n            else:\n                # no more entries in the mapping, delete the whole path\n                self._delete_secret(path=self._build_full_path(path))\n\n    def delete_all_secrets_iter(self, *paths: str) -> Iterable[str]:\n        for path in paths:\n            path = path.rstrip(\"/\")\n            secrets_paths = self._browse_recursive_secrets(path=path)\n            for secret_path in secrets_paths:\n                yield secret_path\n                self.delete_secret(secret_path)\n\n    def delete_all_secrets(self, *paths: str, generator: bool = False) -> Iterable[str]:\n        \"\"\"\n        If generator is True, recursively yields secret paths then deletes\n        the secrets at the given paths. If False, just delete the secrets and\n        return the list of paths.\n\n        Parameters\n        ----------\n        generator : bool, optional\n            Whether of not to yield before deletion, by default False\n\n        Returns\n        -------\n        Iterable[str]\n            Path to the deleted/to be deleted secrets\n        \"\"\"\n        iterator = self.delete_all_secrets_iter(*paths)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def copy_secrets_iter(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        delete_source: Optional[bool] = False,\n    ) -> Iterable[Tuple[str, str]]:\n\n        source_secrets = self.get_secrets(path=source)\n\n        for old_path, secret in source_secrets.items():\n            new_path = dest + old_path[len(source) :]\n            secret = source_secrets[old_path]\n\n            yield (old_path, new_path)\n\n            secret_ = cast(types.JSONDict, secret)\n            self.set_secret(new_path, secret_, force=force)\n            if delete_source:\n                self.delete_secret(old_path)\n\n    def move_secrets_iter(\n        self, source: str, dest: str, force: Optional[bool] = None\n    ) -> Iterable[Tuple[str, str]]:\n        return self.copy_secrets_iter(source, dest, force, delete_source=True)\n\n    def move_secrets(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        generator: bool = False,\n    ) -> Iterable[Tuple[str, str]]:\n        \"\"\"\n        Yield current and new paths, then move a secret or a folder\n        to a new path\n\n        Parameters\n        ----------\n        source : str\n            Path of the secret to move\n        dest : str\n            New path for the secret\n        force : Optional[bool], optional\n            Allow overwriting exiting secret, if safe_mode is True\n        generator : bool, optional\n            Whether of not to yield before move, by default False\n\n        Returns\n        -------\n        Iterable[Tuple[str, str]]\n            [(Current path, new path)]\n        \"\"\"\n        iterator = self.move_secrets_iter(source=source, dest=dest, force=force)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def copy_secrets(\n        self,\n        source: str,\n        dest: str,\n        force: Optional[bool] = None,\n        generator: bool = False,\n    ) -> Iterable[Tuple[str, str]]:\n        \"\"\"\n        Yield current and new paths, then copy a secret or a folder\n        to a new path\n\n        Parameters\n        ----------\n        source : str\n            Path of the secret to move\n        dest : str\n            New path for the secret\n        force : Optional[bool], optional\n            Allow overwriting exiting secret, if safe_mode is True\n        generator : bool, optional\n            Whether of not to yield before move, by default False\n\n        Returns\n        -------\n        Iterable[Tuple[str, str]]\n            [(Current path, new path)]\n        \"\"\"\n        iterator = self.copy_secrets_iter(source=source, dest=dest, force=force)\n        if generator:\n            return iterator\n        return list(iterator)\n\n    def render_template(\n        self,\n        template: str,\n        search_path: pathlib.Path = pathlib.Path(\".\"),\n    ) -> str:\n        \"\"\"\n        Renders a template to a string, giving it access to a `vault` function\n        that can read from the vault\n\n        Parameters\n        ----------\n        template : str\n            Jinja template string\n        render : bool, optional\n            Whether template secrets should be rendered, by default True\n        search_path: pathlib.Path object, optional\n            search path for additional Jinja2 templates, by default current working directory\n            See https://jinja.palletsprojects.com/en/2.10.x/api/#jinja2.FileSystemLoader\n\n        Returns\n        -------\n        str\n            The rendered template\n\n        Raises\n        ------\n        exceptions.VaultRenderTemplateError\n            If a secret is not found or access is forbidden\n        \"\"\"\n\n        def vault(path):\n            try:\n                return self.get_secret(path)\n            except exceptions.VaultException as exc:\n                raise exceptions.VaultRenderTemplateError(\n                    \"Error while rendering template\"\n                ) from exc\n\n        env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(search_path.as_posix()),\n            keep_trailing_newline=True,\n        )\n        try:\n            return env.from_string(template).render(vault=vault)\n        except jinja2.exceptions.TemplateSyntaxError as exc:\n            raise exceptions.VaultRenderTemplateError(\n                \"Jinja2 template syntax error\"\n            ) from exc\n\n    def set_secret(\n        self,\n        path: str,\n        value: types.JSONValue,\n        force: Optional[bool] = None,\n        update: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        Sets the value of a secret\n\n        Parameters\n        ----------\n        path : str\n            Path to the secret\n        value : types.JSONValue\n            Value of the secret\n        force : Optional[bool], optional\n            If safe_mode is True, whether to overwrite existing secret\n        update: Optional[bool], optional\n            If true then merge the value with the existing one, else overwrite it\n\n        Raises\n        ------\n        exceptions.VaultOverwriteSecretError\n            Cannot overwrite a secret if safe_mode is True and force is False\n        exceptions.VaultMixSecretAndFolder\n            Either the path is an existing folder or a parent folder is a secret\n        \"\"\"\n        assert isinstance(value, dict)\n\n        force = self.get_force(force)\n\n        try:\n            existing_value = self.get_secret(path=path)\n            assert isinstance(existing_value, dict)\n        except exceptions.VaultSecretNotFound:\n            pass\n        except exceptions.VaultForbidden:\n            logger.warning(\n                f\"Read access '{path}' forbidden: if it exists, secret will be overridden.\"\n            )\n        else:\n            # if we overwrite the whole mapping we can compare the value directly\n            # if we update the mapping, we only have to check the updated keys\n            if not update and not force and existing_value != value:\n                raise exceptions.VaultOverwriteSecretError(path=path)\n            if update and not force:\n                redefined = [\n                    key\n                    for key in (value.keys() & existing_value.keys())\n                    if existing_value[key] != value[key]\n                ]\n                if any(redefined):\n                    raise exceptions.VaultOverwriteSecretError(\n                        path=path, keys=redefined\n                    )\n\n            if update:\n                # merge value with existing_value\n                value = {**existing_value, **value}\n\n        try:\n            problematic_secrets = self.list_secrets(path=path)\n            if problematic_secrets:\n                secrets = [f\"{path}/{secret}\" for secret in problematic_secrets]\n                raise exceptions.VaultMixSecretAndFolder(\n                    f\"Cannot create a secret at '{path}' because it is already a \"\n                    f\"folder containing {', '.join(secrets)}\"\n                )\n        except exceptions.VaultForbidden:\n            logger.info(\n                f\"List '{path}' forbidden: if it exists, secret will be overridden.\"\n            )\n\n        path = path.rstrip(\"/\")\n        for parent in list(pathlib.PurePath(path).parents)[:-1]:\n            try:\n                self.get_secret(str(parent))\n            except exceptions.VaultSecretNotFound:\n                pass\n            except exceptions.VaultForbidden:\n                logger.info(\n                    f\"Read access '{parent}' forbidden: cannot check if a secret exists here.\"\n                )\n            else:\n                raise exceptions.VaultMixSecretAndFolder(\n                    f\"Cannot create a secret at '{path}' because '{parent}' already exists as a secret\"\n                )\n\n        self._set_secret(path=self._build_full_path(path), secret=value)\n\n    def set_secrets(\n        self,\n        secrets: Dict[str, types.JSONDict],\n        force: Optional[bool] = None,\n        update: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        Sets the value of multiple secrets at once. See possible exceptions\n        in\n\n        Parameters\n        ----------\n        secrets :\n            A mapping of secret path -> value, corresponding to the output\n            of `VaultClientBase.get_secrets`\n        force : Optional[bool], optional\n            If safe_mode is True, whether to overwrite existing secrets\n        update: Optional[bool], optional\n            If true then merge the value with the existing one, else overwrite it\n\n        Raises\n        ------\n        see `VaultClientBase.set_secrets`\n        \"\"\"\n        for path, value in secrets.items():\n            self.set_secret(path=path, value=value, force=force, update=update)\n\n    def _init_client(\n        self,\n        url: str,\n        verify: types.VerifyOrCABundle,\n        login_cert: Optional[str],\n        login_cert_key: Optional[str],\n    ) -> None:\n        raise NotImplementedError\n\n    def _authenticate_token(self, token: str) -> None:\n        raise NotImplementedError\n\n    def _authenticate_certificate(self) -> None:\n        raise NotImplementedError\n\n    def _authenticate_userpass(self, username: str, password: str) -> None:\n        raise NotImplementedError\n\n    def _list_secrets(self, path: str) -> Iterable[str]:\n        raise NotImplementedError\n\n    def _get_secret(self, path: str) -> Dict[str, types.JSONValue]:\n        raise NotImplementedError\n\n    def _delete_secret(self, path: str) -> None:\n        raise NotImplementedError\n\n    def _set_secret(self, path: str, secret: Dict[str, types.JSONValue]) -> None:\n        raise NotImplementedError\n\n    def lookup_token(self) -> types.JSONDict:\n        return self._lookup_token()\n\n    def _lookup_token(self) -> types.JSONDict:\n        raise NotImplementedError\n\n\n@contextlib.contextmanager\ndef handle_errors():\n    try:\n        yield\n    except json.decoder.JSONDecodeError as exc:\n        raise exceptions.VaultNonJsonResponse(errors=[str(exc)])\n    except hvac.exceptions.InvalidRequest as exc:\n        raise exceptions.VaultInvalidRequest(errors=exc.errors) from exc\n    except hvac.exceptions.Unauthorized as exc:\n        raise exceptions.VaultUnauthorized(errors=exc.errors) from exc\n    except hvac.exceptions.Forbidden as exc:\n        raise exceptions.VaultForbidden(errors=exc.errors) from exc\n    except hvac.exceptions.InternalServerError as exc:\n        raise exceptions.VaultInternalServerError(errors=exc.errors) from exc\n    except hvac.exceptions.VaultDown as exc:\n        raise exceptions.VaultSealed(errors=exc.errors) from exc\n    except hvac.exceptions.UnexpectedError as exc:\n        raise exceptions.VaultAPIException(errors=exc.errors) from exc\n    except requests.exceptions.ConnectionError as exc:\n        raise exceptions.VaultConnectionError() from exc\n\n\nclass VaultClient(VaultClientBase):\n    @handle_errors()\n    def _init_client(\n        self,\n        url: str,\n        verify: types.VerifyOrCABundle,\n        login_cert: Optional[str],\n        login_cert_key: Optional[str],\n    ) -> None:\n        self.session = sessions.Session()\n        self.session.verify = verify\n\n        cert = None\n        if login_cert and login_cert_key:\n            cert = (login_cert, login_cert_key)\n\n        self.client = hvac.Client(\n            url=url, verify=verify, session=self.session, cert=cert\n        )\n\n    def _authenticate_token(self, token: str) -> None:\n        self.client.token = token\n\n    @handle_errors()\n    def _authenticate_userpass(self, username: str, password: str) -> None:\n        self.client.auth_userpass(username, password)\n\n    @handle_errors()\n    def _authenticate_certificate(self) -> None:\n        self.client.auth_tls()\n\n    @handle_errors()\n    def _list_secrets(self, path: str) -> Iterable[str]:\n        secrets = self.client.list(path)\n        if not secrets:\n            return []\n        return sorted(secrets[\"data\"][\"keys\"])\n\n    @handle_errors()\n    def _get_secret(self, path: str) -> Dict[str, types.JSONValue]:\n        secret = self.client.read(path)\n        if not secret:\n            raise exceptions.VaultSecretNotFound(\n                errors=[f\"Secret not found at path '{path}'\"]\n            )\n        return secret[\"data\"]\n\n    @handle_errors()\n    def _delete_secret(self, path: str) -> None:\n        self.client.delete(path)\n\n    @handle_errors()\n    def _set_secret(self, path: str, secret: Dict[str, types.JSONValue]) -> None:\n        self.client.write(path, **secret)\n\n    @handle_errors()\n    def _lookup_token(self) -> types.JSONDict:\n        return self.client.lookup_token()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        super().__exit__(exc_type, exc_value, traceback)\n        self.session.__exit__(exc_type, exc_value, traceback)\n", "patch": "@@ -2,7 +2,7 @@\n import json\n import logging\n import pathlib\n-from typing import Dict, Iterable, List, Optional, Set, Tuple, Type, Union, cast\n+from typing import Dict, Iterable, List, Optional, Tuple, Type, cast\n \n import hvac  # type: ignore\n import jinja2\n@@ -12,9 +12,6 @@\n \n logger = logging.getLogger(__name__)\n \n-JSONRecursive = Union[types.JSONValue, utils.RecursiveValue]\n-JSONDictRecursive = Dict[str, JSONRecursive]\n-\n \n def get_client(**kwargs) -> \"VaultClientBase\":\n     \"\"\"\n@@ -49,8 +46,6 @@ def get_client(**kwargs) -> \"VaultClientBase\":\n         Path to your config file, instead of the default ones\n     safe_write : bool\n         If set to True, will keep you from overwriting secrets without force=True\n-    render : bool\n-        If set to False, templated secrets will not be rendered\n \n     Returns\n     -------\n@@ -82,7 +77,6 @@ def __init__(\n         username: Optional[str] = settings.DEFAULTS.username,\n         password: Optional[str] = settings.DEFAULTS.password,\n         safe_write: bool = settings.DEFAULTS.safe_write,\n-        render: bool = settings.DEFAULTS.render,\n     ):\n         self.url = url\n         self.verify: types.VerifyOrCABundle = verify\n@@ -94,10 +88,8 @@ def __init__(\n         self.username = username\n         self.password = password\n         self.safe_write = safe_write\n-        self.render = render\n         self.cache: Dict[str, types.JSONDict] = {}\n         self.errors: List[str] = []\n-        self._currently_fetching: Set[str] = set()\n \n     @property\n     def base_path(self):\n@@ -166,9 +158,7 @@ def _build_full_path(self, path: str) -> str:\n             # path relative to base_path\n             return self.base_path + path\n \n-    def _browse_recursive_secrets(\n-        self, path: str, render: bool = True\n-    ) -> Iterable[str]:\n+    def _browse_recursive_secrets(self, path: str) -> Iterable[str]:\n         \"\"\"\n         Given a secret or folder path, return the path of all secrets\n         under it (or the path itself)\n@@ -194,12 +184,10 @@ def _browse_recursive_secrets(\n                 yield key_url\n                 continue\n \n-            for sub_path in self._browse_recursive_secrets(key_url, render=render):\n+            for sub_path in self._browse_recursive_secrets(key_url):\n                 yield sub_path\n \n-    def get_all_secrets(\n-        self, *paths: str, render: bool = True, flat: bool = False\n-    ) -> JSONDictRecursive:\n+    def get_all_secrets(self, *paths: str, flat: bool = False) -> types.JSONDict:\n         \"\"\"\n         Takes several paths, return the nested dict of all secrets below\n         those paths\n@@ -208,8 +196,6 @@ def get_all_secrets(\n         ----------\n         *paths : str\n             Paths to read recursively\n-        render : bool, optional\n-            Whether templated secrets should be rendered, by default True\n         flat : bool, optional\n             Whether to return flat structure with full path as keys or nested\n             structure that looks like a tree\n@@ -220,10 +206,10 @@ def get_all_secrets(\n             {\"folder\": {\"subfolder\": {\"secret_key\": \"secret_value\"}}}\n         \"\"\"\n \n-        result: JSONDictRecursive = {}\n+        result: types.JSONDict = {}\n \n         for path in paths:\n-            path_dict = self.get_secrets(path, render=render)\n+            path_dict = self.get_secrets(path)\n             if flat:\n                 result.update(path_dict)\n             else:\n@@ -232,17 +218,15 @@ def get_all_secrets(\n         return result\n \n     def get_secrets(\n-        self, path: str, render: bool = True, relative: bool = False\n-    ) -> Dict[str, JSONDictRecursive]:\n+        self, path: str, relative: bool = False\n+    ) -> Dict[str, types.JSONDict]:\n         \"\"\"\n         Takes a path, return all secrets below this path\n \n         Parameters\n         ----------\n         path : str\n             Path to read recursively\n-        render : bool, optional\n-            Whether templated secrets should be rendered, by default True\n         relative: bool, optional\n             When false (default), the keys of the returned dict are the paths of the secrets\n             When true, the keys are the relative paths of the secret to `path` (`\"\"` if the secret is directly at path `path`)\n@@ -254,16 +238,14 @@ def get_secrets(\n         \"\"\"\n         path = path.rstrip(\"/\")\n         try:\n-            secrets_paths = list(\n-                self._browse_recursive_secrets(path=path, render=render)\n-            )\n+            secrets_paths = list(self._browse_recursive_secrets(path=path))\n         except exceptions.VaultAPIException:\n             # If we cannot list secrets, we can't browse them, but there's still\n             # a chance that the provided path is a single secret that we can\n             # read\n             secrets_paths = [path]\n \n-        result: Dict[str, JSONDictRecursive] = {}\n+        result: Dict[str, types.JSONDict] = {}\n         path_obj = pathlib.Path(path)\n         for subpath in secrets_paths:\n             if relative:\n@@ -275,13 +257,10 @@ def get_secrets(\n                 key = subpath\n \n             try:\n-                secret = self.get_secret(path=subpath, render=render)\n-                secret = cast(JSONDictRecursive, secret)\n+                secret = self.get_secret(path=subpath)\n+                secret = cast(types.JSONDict, secret)\n                 result[key] = secret\n-            except (\n-                exceptions.VaultAPIException,\n-                exceptions.VaultRenderTemplateError,\n-            ) as exc:\n+            except exceptions.VaultAPIException as exc:\n                 for message in utils.extract_error_messages(exc):\n                     logger.error(message)\n                     self.errors.append(message)\n@@ -305,9 +284,7 @@ def list_secrets(self, path: str) -> Iterable[str]:\n         \"\"\"\n         return self._list_secrets(path=self._build_full_path(path))\n \n-    def get_secret(\n-        self, path: str, key: Optional[str] = None, render: bool = True\n-    ) -> Union[types.JSONValue, utils.RecursiveValue]:\n+    def get_secret(self, path: str, key: Optional[str] = None) -> types.JSONValue:\n         \"\"\"\n         Retrieve the value of a single secret\n \n@@ -319,35 +296,18 @@ def get_secret(\n         key : str, optional\n             If set, return only this key\n \n-        render : bool, optional\n-            Whether to render templated secret or not, by default True\n-\n         Returns\n         -------\n         types.JSONValue\n             Secret value\n         \"\"\"\n         full_path = self._build_full_path(path)\n-        if full_path in self._currently_fetching:\n-            return utils.RecursiveValue(path)\n \n-        self._currently_fetching.add(full_path)\n+        assert self.cache is not None\n         try:\n-            assert self.cache is not None\n-            try:\n-                mapping = self.cache[full_path]\n-            except KeyError:\n-                mapping = self.cache[full_path] = self._get_secret(path=full_path)\n-\n-            if mapping and render and self.render:\n-                try:\n-                    mapping = self._render_template_dict(mapping)\n-                except exceptions.VaultRenderTemplateError as exc:\n-                    message = f'Error while rendering secret at path \"{path}\"'\n-                    raise exceptions.VaultRenderTemplateError(message) from exc\n-\n-        finally:\n-            self._currently_fetching.remove(full_path)\n+            mapping = self.cache[full_path]\n+        except KeyError:\n+            mapping = self.cache[full_path] = self._get_secret(path=full_path)\n \n         if key is not None:\n             try:\n@@ -379,7 +339,7 @@ def delete_secret(self, path: str, key: Optional[str] = None) -> None:\n         else:\n             # Delete only one attribute\n             try:\n-                secret = self.get_secret(path, render=False)\n+                secret = self.get_secret(path)\n             except exceptions.VaultSecretNotFound:\n                 # secret does not exist\n                 return\n@@ -401,7 +361,7 @@ def delete_secret(self, path: str, key: Optional[str] = None) -> None:\n     def delete_all_secrets_iter(self, *paths: str) -> Iterable[str]:\n         for path in paths:\n             path = path.rstrip(\"/\")\n-            secrets_paths = self._browse_recursive_secrets(path=path, render=False)\n+            secrets_paths = self._browse_recursive_secrets(path=path)\n             for secret_path in secrets_paths:\n                 yield secret_path\n                 self.delete_secret(secret_path)\n@@ -435,7 +395,7 @@ def copy_secrets_iter(\n         delete_source: Optional[bool] = False,\n     ) -> Iterable[Tuple[str, str]]:\n \n-        source_secrets = self.get_secrets(path=source, render=False)\n+        source_secrets = self.get_secrets(path=source)\n \n         for old_path, secret in source_secrets.items():\n             new_path = dest + old_path[len(source) :]\n@@ -517,41 +477,9 @@ def copy_secrets(\n             return iterator\n         return list(iterator)\n \n-    template_prefix = \"!template!\"\n-\n-    def _render_template_value(self, secret: types.JSONValue) -> types.JSONValue:\n-\n-        if isinstance(secret, dict):\n-            return {k: self._render_template_value(v) for k, v in secret.items()}\n-        if not isinstance(secret, str):\n-            return secret\n-\n-        if not secret.startswith(self.template_prefix):\n-            return secret\n-\n-        logger.warn(\n-            \"Templated values are deprecated and will be removed in the \"\n-            \"following major versions.\",\n-        )\n-        return self.render_template(secret[len(self.template_prefix) :])\n-\n-    def _render_template_dict(\n-        self, secrets: Dict[str, types.JSONValue]\n-    ) -> Dict[str, types.JSONValue]:\n-        result = {}\n-        for key, value in secrets.items():\n-            try:\n-                result[key] = self._render_template_value(value)\n-            except exceptions.VaultRenderTemplateError as exc:\n-                message = f'Error while rendering secret value for key \"{key}\"'\n-                raise exceptions.VaultRenderTemplateError(message) from exc\n-\n-        return result\n-\n     def render_template(\n         self,\n         template: str,\n-        render: bool = True,\n         search_path: pathlib.Path = pathlib.Path(\".\"),\n     ) -> str:\n         \"\"\"\n@@ -581,7 +509,7 @@ def render_template(\n \n         def vault(path):\n             try:\n-                return self.get_secret(path, render=render)\n+                return self.get_secret(path)\n             except exceptions.VaultException as exc:\n                 raise exceptions.VaultRenderTemplateError(\n                     \"Error while rendering template\"\n@@ -631,7 +559,7 @@ def set_secret(\n         force = self.get_force(force)\n \n         try:\n-            existing_value = self.get_secret(path=path, render=False)\n+            existing_value = self.get_secret(path=path)\n             assert isinstance(existing_value, dict)\n         except exceptions.VaultSecretNotFound:\n             pass\n@@ -675,7 +603,7 @@ def set_secret(\n         path = path.rstrip(\"/\")\n         for parent in list(pathlib.PurePath(path).parents)[:-1]:\n             try:\n-                self.get_secret(str(parent), render=False)\n+                self.get_secret(str(parent))\n             except exceptions.VaultSecretNotFound:\n                 pass\n             except exceptions.VaultForbidden:\n@@ -691,7 +619,7 @@ def set_secret(\n \n     def set_secrets(\n         self,\n-        secrets: Dict[str, JSONDictRecursive],\n+        secrets: Dict[str, types.JSONDict],\n         force: Optional[bool] = None,\n         update: Optional[bool] = None,\n     ) -> None:", "file_path": "files/2021_12/202", "file_language": "py", "file_name": "vault_cli/client.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2                     \n          Detected direct use of jinja2. If not done properly, this may bypass HTML escaping which   \n          opens up the application to cross-site scripting (XSS) vulnerabilities. Prefer using the   \n          Flask method 'render_template()' and templates with a '.html' extension in order to prevent\n          XSS.                                                                                       \n          Details: https://sg.run/RoKe                                                               \n\n          518\u2506 env = jinja2.Environment(\n          519\u2506     loader=jinja2.FileSystemLoader(search_path.as_posix()),\n          520\u2506     keep_trailing_newline=True,          521\u2506 )"]]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/vault_cli%2Fenvironment.py", "code": "import json\nimport logging\nimport os\nimport pathlib\nimport re\nfrom typing import Dict, Mapping, NoReturn, Optional, Sequence\n\nfrom vault_cli import client, exceptions, types\n\nlogger = logging.getLogger(__name__)\n\n_replaced_by_underscore = re.compile(r\"[/\\- ]\")\n_allowed_named = re.compile(r\"[A-Z0-9_]+\")\n\n\ndef _normalize(name: str) -> str:\n    \"\"\"\n    Change \" \", \"-\" and \"/\" into \"_\" in a string\n    \"\"\"\n    envvar_name = _replaced_by_underscore.sub(\"_\", name).upper()\n\n    if not _allowed_named.fullmatch(envvar_name):\n        raise exceptions.VaultInvalidEnvironmentName(envvar_name)\n\n    return envvar_name\n\n\ndef _make_env_value(value: types.JSONValue) -> str:\n    if isinstance(value, str):\n        return value\n    return json.dumps(value)\n\n\ndef full_environment(environment: Mapping[str, str]) -> Mapping[str, str]:\n    current_env = os.environ.copy()\n    current_env.update(environment)\n    return current_env\n\n\ndef exec_command(\n    command: Sequence[str], environment: Optional[Mapping[str, str]] = None\n) -> NoReturn:\n    environment = full_environment(environment or {})\n    os.execvpe(command[0], tuple(command), environment)\n\n\ndef get_envvars_for_secrets(\n    secrets: Dict[str, types.JSONDict],\n    path: str,\n    prefix: str,\n    omit_single_key: bool = False,\n) -> Dict[str, str]:\n    env_secrets = {}\n    if not prefix:\n        prefix = pathlib.Path(path).name\n\n    for subpath, values in secrets.items():\n        omit = omit_single_key and len(values) == 1\n        for key, value in values.items():\n            if omit:\n                key = \"\"\n            try:\n                env_name = _normalize(\"_\".join(e for e in (prefix, subpath, key) if e))\n            except exceptions.VaultInvalidEnvironmentName as exc:\n                logger.warning(f\"Invalid environment name {exc}, skipping secret value\")\n                continue\n            value = _make_env_value(value)\n            env_secrets[env_name] = value\n    return env_secrets\n\n\ndef get_envvars(\n    vault_client: client.VaultClientBase,\n    path: str,\n    prefix: str,\n    omit_single_key: bool,\n    filter_key: str,\n) -> Dict[str, str]:\n    if filter_key:\n        secret = vault_client.get_secret(path=path, key=filter_key)\n        return get_envvars_for_secrets(\n            path=\"\",\n            prefix=prefix,\n            secrets={\"\": {filter_key: secret}},\n            omit_single_key=bool(prefix),\n        )\n    else:\n        secrets = vault_client.get_secrets(path=path, relative=True)\n        return get_envvars_for_secrets(\n            path=path, prefix=prefix, secrets=secrets, omit_single_key=omit_single_key\n        )\n", "code_before": "import json\nimport logging\nimport os\nimport pathlib\nimport re\nfrom typing import Dict, Mapping, NoReturn, Optional, Sequence\n\nfrom vault_cli import client, exceptions, types\n\nlogger = logging.getLogger(__name__)\n\n_replaced_by_underscore = re.compile(r\"[/\\- ]\")\n_allowed_named = re.compile(r\"[A-Z0-9_]+\")\n\n\ndef _normalize(name: str) -> str:\n    \"\"\"\n    Change \" \", \"-\" and \"/\" into \"_\" in a string\n    \"\"\"\n    envvar_name = _replaced_by_underscore.sub(\"_\", name).upper()\n\n    if not _allowed_named.fullmatch(envvar_name):\n        raise exceptions.VaultInvalidEnvironmentName(envvar_name)\n\n    return envvar_name\n\n\ndef _make_env_value(value: types.JSONValue) -> str:\n    if isinstance(value, str):\n        return value\n    return json.dumps(value)\n\n\ndef full_environment(environment: Mapping[str, str]) -> Mapping[str, str]:\n    current_env = os.environ.copy()\n    current_env.update(environment)\n    return current_env\n\n\ndef exec_command(\n    command: Sequence[str], environment: Optional[Mapping[str, str]] = None\n) -> NoReturn:\n    environment = full_environment(environment or {})\n    os.execvpe(command[0], tuple(command), environment)\n\n\ndef get_envvars_for_secrets(\n    secrets: Dict[str, types.JSONDict],\n    path: str,\n    prefix: str,\n    omit_single_key: bool = False,\n) -> Dict[str, str]:\n    env_secrets = {}\n    if not prefix:\n        prefix = pathlib.Path(path).name\n\n    for subpath, values in secrets.items():\n        omit = omit_single_key and len(values) == 1\n        for key, value in values.items():\n            if omit:\n                key = \"\"\n            try:\n                env_name = _normalize(\"_\".join(e for e in (prefix, subpath, key) if e))\n            except exceptions.VaultInvalidEnvironmentName as exc:\n                logger.warning(f\"Invalid environment name {exc}, skipping secret value\")\n                continue\n            value = _make_env_value(value)\n            env_secrets[env_name] = value\n    return env_secrets\n\n\ndef get_envvars(\n    vault_client: client.VaultClientBase,\n    path: str,\n    prefix: str,\n    omit_single_key: bool,\n    filter_key: str,\n) -> Dict[str, str]:\n    if filter_key:\n        secret = vault_client.get_secret(path=path, key=filter_key)\n        return get_envvars_for_secrets(\n            path=\"\",\n            prefix=prefix,\n            secrets={\"\": {filter_key: secret}},\n            omit_single_key=bool(prefix),\n        )\n    else:\n        secrets = vault_client.get_secrets(path=path, relative=True)\n        return get_envvars_for_secrets(\n            path=path, prefix=prefix, secrets=secrets, omit_single_key=omit_single_key\n        )\n", "patch": "@@ -5,7 +5,7 @@\n import re\n from typing import Dict, Mapping, NoReturn, Optional, Sequence\n \n-from vault_cli import client, exceptions\n+from vault_cli import client, exceptions, types\n \n logger = logging.getLogger(__name__)\n \n@@ -25,7 +25,7 @@ def _normalize(name: str) -> str:\n     return envvar_name\n \n \n-def _make_env_value(value: client.JSONRecursive) -> str:\n+def _make_env_value(value: types.JSONValue) -> str:\n     if isinstance(value, str):\n         return value\n     return json.dumps(value)\n@@ -45,7 +45,7 @@ def exec_command(\n \n \n def get_envvars_for_secrets(\n-    secrets: Dict[str, client.JSONDictRecursive],\n+    secrets: Dict[str, types.JSONDict],\n     path: str,\n     prefix: str,\n     omit_single_key: bool = False,", "file_path": "files/2021_12/203", "file_language": "py", "file_name": "vault_cli/environment.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def _normalize(name: str) -> str:\n    \"\"\"\n    Change \" \", \"-\" and \"/\" into \"_\" in a string\n    \"\"\"\n    envvar_name = _replaced_by_underscore.sub(\"_\", name).upper()\n\n    if not _allowed_named.fullmatch(envvar_name):\n        raise exceptions.VaultInvalidEnvironmentName(envvar_name)\n\n    return envvar_name", "target": 0}, {"function": "def _make_env_value(value: types.JSONValue) -> str:\n    if isinstance(value, str):\n        return value\n    return json.dumps(value)", "target": 0}, {"function": "def full_environment(environment: Mapping[str, str]) -> Mapping[str, str]:\n    current_env = os.environ.copy()\n    current_env.update(environment)\n    return current_env", "target": 0}, {"function": "def exec_command(\n    command: Sequence[str], environment: Optional[Mapping[str, str]] = None\n) -> NoReturn:\n    environment = full_environment(environment or {})\n    os.execvpe(command[0], tuple(command), environment)", "target": 0}, {"function": "def get_envvars_for_secrets(\n    secrets: Dict[str, types.JSONDict],\n    path: str,\n    prefix: str,\n    omit_single_key: bool = False,\n) -> Dict[str, str]:\n    env_secrets = {}\n    if not prefix:\n        prefix = pathlib.Path(path).name\n\n    for subpath, values in secrets.items():\n        omit = omit_single_key and len(values) == 1\n        for key, value in values.items():\n            if omit:\n                key = \"\"\n            try:\n                env_name = _normalize(\"_\".join(e for e in (prefix, subpath, key) if e))\n            except exceptions.VaultInvalidEnvironmentName as exc:\n                logger.warning(f\"Invalid environment name {exc}, skipping secret value\")\n                continue\n            value = _make_env_value(value)\n            env_secrets[env_name] = value\n    return env_secrets", "target": 0}, {"function": "def get_envvars(\n    vault_client: client.VaultClientBase,\n    path: str,\n    prefix: str,\n    omit_single_key: bool,\n    filter_key: str,\n) -> Dict[str, str]:\n    if filter_key:\n        secret = vault_client.get_secret(path=path, key=filter_key)\n        return get_envvars_for_secrets(\n            path=\"\",\n            prefix=prefix,\n            secrets={\"\": {filter_key: secret}},\n            omit_single_key=bool(prefix),\n        )\n    else:\n        secrets = vault_client.get_secrets(path=path, relative=True)\n        return get_envvars_for_secrets(\n            path=path, prefix=prefix, secrets=secrets, omit_single_key=omit_single_key\n        )", "target": 0}], "function_after": [{"function": "def _normalize(name: str) -> str:\n    \"\"\"\n    Change \" \", \"-\" and \"/\" into \"_\" in a string\n    \"\"\"\n    envvar_name = _replaced_by_underscore.sub(\"_\", name).upper()\n\n    if not _allowed_named.fullmatch(envvar_name):\n        raise exceptions.VaultInvalidEnvironmentName(envvar_name)\n\n    return envvar_name", "target": 0}, {"function": "def _make_env_value(value: types.JSONValue) -> str:\n    if isinstance(value, str):\n        return value\n    return json.dumps(value)", "target": 0}, {"function": "def full_environment(environment: Mapping[str, str]) -> Mapping[str, str]:\n    current_env = os.environ.copy()\n    current_env.update(environment)\n    return current_env", "target": 0}, {"function": "def exec_command(\n    command: Sequence[str], environment: Optional[Mapping[str, str]] = None\n) -> NoReturn:\n    environment = full_environment(environment or {})\n    os.execvpe(command[0], tuple(command), environment)", "target": 0}, {"function": "def get_envvars_for_secrets(\n    secrets: Dict[str, types.JSONDict],\n    path: str,\n    prefix: str,\n    omit_single_key: bool = False,\n) -> Dict[str, str]:\n    env_secrets = {}\n    if not prefix:\n        prefix = pathlib.Path(path).name\n\n    for subpath, values in secrets.items():\n        omit = omit_single_key and len(values) == 1\n        for key, value in values.items():\n            if omit:\n                key = \"\"\n            try:\n                env_name = _normalize(\"_\".join(e for e in (prefix, subpath, key) if e))\n            except exceptions.VaultInvalidEnvironmentName as exc:\n                logger.warning(f\"Invalid environment name {exc}, skipping secret value\")\n                continue\n            value = _make_env_value(value)\n            env_secrets[env_name] = value\n    return env_secrets", "target": 0}, {"function": "def get_envvars(\n    vault_client: client.VaultClientBase,\n    path: str,\n    prefix: str,\n    omit_single_key: bool,\n    filter_key: str,\n) -> Dict[str, str]:\n    if filter_key:\n        secret = vault_client.get_secret(path=path, key=filter_key)\n        return get_envvars_for_secrets(\n            path=\"\",\n            prefix=prefix,\n            secrets={\"\": {filter_key: secret}},\n            omit_single_key=bool(prefix),\n        )\n    else:\n        secrets = vault_client.get_secrets(path=path, relative=True)\n        return get_envvars_for_secrets(\n            path=path, prefix=prefix, secrets=secrets, omit_single_key=omit_single_key\n        )", "target": 0}]}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/vault_cli%2Fsettings.py", "code": "import logging\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import Dict, Optional, Union\n\nimport yaml\n\nfrom vault_cli import exceptions, types\n\nlogger = logging.getLogger(__name__)\n\nENV_PREFIX = \"VAULT_CLI\"\n\n# Ordered by increasing priority\nCONFIG_FILES = [\"./vault.yml\", \"~/.vault.yml\", \"/etc/vault.yml\"]\n\n\nclass DEFAULTS:\n    base_path = None\n    login_cert = None\n    login_cert_key = None\n    password = None\n    token = None\n    url = \"http://localhost:8200\"\n    username = None\n    verify = True\n    ca_bundle = None\n    safe_write = False\n\n    @staticmethod\n    def _as_dict():\n        return {k: v for k, v in vars(DEFAULTS).items() if k[0] != \"_\"}\n\n\ndef read_config_file(file_path: str) -> Optional[types.SettingsDict]:\n    try:\n        with open(os.path.expanduser(file_path), \"r\") as f:\n            config = yaml.safe_load(f) or {}\n            logger.info(\n                f\"Reading yaml config file at {file_path}, \"\n                f\"contains keys: {', '.join(config)}\"\n            )\n            return config\n    except FileNotFoundError:\n        logger.debug(f\"No config file at {file_path} (skipping)\")\n    except IOError:\n        logger.warning(\n            f\"Config file exists at {file_path}, but cannot be read. \"\n            \"Have you checked permissions? (skipping)\"\n        )\n\n    return None\n\n\ndef dash_to_underscores(config: types.SettingsDict) -> types.SettingsDict:\n    # Because we're modifying the dict during iteration, we need to\n    # consolidate the keys into a list\n    return {key.replace(\"-\", \"_\"): value for key, value in config.items()}\n\n\ndef load_bool(value: str) -> bool:\n    lower_value = value.lower()\n\n    if lower_value in (\"true\", \"t\", \"1\", \"yes\", \"y\"):\n        return True\n    elif lower_value in (\"false\", \"f\", \"0\", \"no\", \"n\"):\n        return False\n\n    raise exceptions.VaultSettingsError(\"Value {} could not be interpreted as boolean\")\n\n\ndef build_config_from_env(environ: Dict[str, str]) -> types.SettingsDict:\n    result: types.SettingsDict = {}\n\n    skip_len = len(ENV_PREFIX) + 1\n\n    value: Union[str, bool]\n\n    defaults_dict = DEFAULTS._as_dict()\n\n    for key, str_value in environ.items():\n\n        if not key.startswith(ENV_PREFIX + \"_\"):\n            continue\n\n        key = key[skip_len:].lower()\n\n        if key not in defaults_dict:\n            continue\n\n        if isinstance(defaults_dict[key], bool):\n            value = load_bool(str_value)\n        else:\n            value = str_value\n\n        result[key] = value\n\n    return result\n\n\ndef read_all_files(config: types.SettingsDict) -> types.SettingsDict:\n    config = config.copy()\n\n    replace_path_with_content(config=config, setting_name=\"password\")\n    replace_path_with_content(config=config, setting_name=\"token\")\n\n    return config\n\n\ndef replace_path_with_content(config: types.SettingsDict, setting_name: str) -> None:\n    \"\"\"\n    Modifies config dict in place: reads the file at <setting_name>_file\n    and put its contents at <setting_name> instead.\n    \"\"\"\n    # Files override direct values when both are defined\n    filename = config.pop(f\"{setting_name}_file\", None)\n    if filename:\n        assert isinstance(filename, str)\n        logger.info(f\"Reading value of '{setting_name}' from file {filename}\")\n        config[setting_name] = read_file(filename)\n\n\ndef read_file(path: str) -> Optional[str]:\n    \"\"\"\n    Returns the content of the pointed file\n    \"\"\"\n    if path == \"-\":\n        return sys.stdin.read().strip()\n\n    with open(os.path.expanduser(path)) as file_handler:\n\n        return file_handler.read().strip()\n\n\n@lru_cache()\ndef build_config_from_files(*config_files: str):\n    values = DEFAULTS._as_dict()\n\n    for potential_file in config_files:\n        file_config = read_config_file(potential_file)\n        if file_config is not None:\n            file_config = dash_to_underscores(file_config)\n            file_config = read_all_files(file_config)\n            values.update(file_config)\n            break\n\n    return values\n\n\ndef get_vault_options(*, config_file: Optional[str] = None, **kwargs: types.Settings):\n    config_files = [config_file] if config_file else CONFIG_FILES\n    values = build_config_from_files(*config_files).copy()\n    values.update(build_config_from_env(os.environ.copy()))\n    values.update(kwargs)\n\n    return values\n\n\ndef get_log_level(verbosity: int) -> int:\n    \"\"\"\n    Given the number of repetitions of the flag -v,\n    returns the desired log level\n    \"\"\"\n    return {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}.get(\n        min((2, verbosity)), 0\n    )\n", "code_before": "import logging\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import Dict, Optional, Union\n\nimport yaml\n\nfrom vault_cli import exceptions, types\n\nlogger = logging.getLogger(__name__)\n\nENV_PREFIX = \"VAULT_CLI\"\n\n# Ordered by increasing priority\nCONFIG_FILES = [\"./vault.yml\", \"~/.vault.yml\", \"/etc/vault.yml\"]\n\n\nclass DEFAULTS:\n    base_path = None\n    login_cert = None\n    login_cert_key = None\n    password = None\n    token = None\n    url = \"http://localhost:8200\"\n    username = None\n    verify = True\n    ca_bundle = None\n    safe_write = False\n\n    @staticmethod\n    def _as_dict():\n        return {k: v for k, v in vars(DEFAULTS).items() if k[0] != \"_\"}\n\n\ndef read_config_file(file_path: str) -> Optional[types.SettingsDict]:\n    try:\n        with open(os.path.expanduser(file_path), \"r\") as f:\n            config = yaml.safe_load(f) or {}\n            logger.info(\n                f\"Reading yaml config file at {file_path}, \"\n                f\"contains keys: {', '.join(config)}\"\n            )\n            return config\n    except FileNotFoundError:\n        logger.debug(f\"No config file at {file_path} (skipping)\")\n    except IOError:\n        logger.warning(\n            f\"Config file exists at {file_path}, but cannot be read. \"\n            \"Have you checked permissions? (skipping)\"\n        )\n\n    return None\n\n\ndef dash_to_underscores(config: types.SettingsDict) -> types.SettingsDict:\n    # Because we're modifying the dict during iteration, we need to\n    # consolidate the keys into a list\n    return {key.replace(\"-\", \"_\"): value for key, value in config.items()}\n\n\ndef load_bool(value: str) -> bool:\n    lower_value = value.lower()\n\n    if lower_value in (\"true\", \"t\", \"1\", \"yes\", \"y\"):\n        return True\n    elif lower_value in (\"false\", \"f\", \"0\", \"no\", \"n\"):\n        return False\n\n    raise exceptions.VaultSettingsError(\"Value {} could not be interpreted as boolean\")\n\n\ndef build_config_from_env(environ: Dict[str, str]) -> types.SettingsDict:\n    result: types.SettingsDict = {}\n\n    skip_len = len(ENV_PREFIX) + 1\n\n    value: Union[str, bool]\n\n    defaults_dict = DEFAULTS._as_dict()\n\n    for key, str_value in environ.items():\n\n        if not key.startswith(ENV_PREFIX + \"_\"):\n            continue\n\n        key = key[skip_len:].lower()\n\n        if key not in defaults_dict:\n            continue\n\n        if isinstance(defaults_dict[key], bool):\n            value = load_bool(str_value)\n        else:\n            value = str_value\n\n        result[key] = value\n\n    return result\n\n\ndef read_all_files(config: types.SettingsDict) -> types.SettingsDict:\n    config = config.copy()\n\n    replace_path_with_content(config=config, setting_name=\"password\")\n    replace_path_with_content(config=config, setting_name=\"token\")\n\n    return config\n\n\ndef replace_path_with_content(config: types.SettingsDict, setting_name: str) -> None:\n    \"\"\"\n    Modifies config dict in place: reads the file at <setting_name>_file\n    and put its contents at <setting_name> instead.\n    \"\"\"\n    # Files override direct values when both are defined\n    filename = config.pop(f\"{setting_name}_file\", None)\n    if filename:\n        assert isinstance(filename, str)\n        logger.info(f\"Reading value of '{setting_name}' from file {filename}\")\n        config[setting_name] = read_file(filename)\n\n\ndef read_file(path: str) -> Optional[str]:\n    \"\"\"\n    Returns the content of the pointed file\n    \"\"\"\n    if path == \"-\":\n        return sys.stdin.read().strip()\n\n    with open(os.path.expanduser(path)) as file_handler:\n\n        return file_handler.read().strip()\n\n\n@lru_cache()\ndef build_config_from_files(*config_files: str):\n    values = DEFAULTS._as_dict()\n\n    for potential_file in config_files:\n        file_config = read_config_file(potential_file)\n        if file_config is not None:\n            file_config = dash_to_underscores(file_config)\n            file_config = read_all_files(file_config)\n            values.update(file_config)\n            break\n\n    return values\n\n\ndef get_vault_options(*, config_file: Optional[str] = None, **kwargs: types.Settings):\n    config_files = [config_file] if config_file else CONFIG_FILES\n    values = build_config_from_files(*config_files).copy()\n    values.update(build_config_from_env(os.environ.copy()))\n    values.update(kwargs)\n\n    return values\n\n\ndef get_log_level(verbosity: int) -> int:\n    \"\"\"\n    Given the number of repetitions of the flag -v,\n    returns the desired log level\n    \"\"\"\n    return {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}.get(\n        min((2, verbosity)), 0\n    )\n", "patch": "@@ -27,7 +27,6 @@ class DEFAULTS:\n     verify = True\n     ca_bundle = None\n     safe_write = False\n-    render = True\n \n     @staticmethod\n     def _as_dict():", "file_path": "files/2021_12/204", "file_language": "py", "file_name": "vault_cli/settings.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class DEFAULTS:\n    base_path = None\n    login_cert = None\n    login_cert_key = None\n    password = None\n    token = None\n    url = \"http://localhost:8200\"\n    username = None\n    verify = True\n    ca_bundle = None\n    safe_write = False\n\n    @staticmethod\n    def _as_dict():\n        return {k: v for k, v in vars(DEFAULTS).items() if k[0] != \"_\"}", "target": 0}, {"function": "def read_config_file(file_path: str) -> Optional[types.SettingsDict]:\n    try:\n        with open(os.path.expanduser(file_path), \"r\") as f:\n            config = yaml.safe_load(f) or {}\n            logger.info(\n                f\"Reading yaml config file at {file_path}, \"\n                f\"contains keys: {', '.join(config)}\"\n            )\n            return config\n    except FileNotFoundError:\n        logger.debug(f\"No config file at {file_path} (skipping)\")\n    except IOError:\n        logger.warning(\n            f\"Config file exists at {file_path}, but cannot be read. \"\n            \"Have you checked permissions? (skipping)\"\n        )\n\n    return None", "target": 0}, {"function": "def dash_to_underscores(config: types.SettingsDict) -> types.SettingsDict:\n    # Because we're modifying the dict during iteration, we need to\n    # consolidate the keys into a list\n    return {key.replace(\"-\", \"_\"): value for key, value in config.items()}", "target": 0}, {"function": "def load_bool(value: str) -> bool:\n    lower_value = value.lower()\n\n    if lower_value in (\"true\", \"t\", \"1\", \"yes\", \"y\"):\n        return True\n    elif lower_value in (\"false\", \"f\", \"0\", \"no\", \"n\"):\n        return False\n\n    raise exceptions.VaultSettingsError(\"Value {} could not be interpreted as boolean\")", "target": 0}, {"function": "def build_config_from_env(environ: Dict[str, str]) -> types.SettingsDict:\n    result: types.SettingsDict = {}\n\n    skip_len = len(ENV_PREFIX) + 1\n\n    value: Union[str, bool]\n\n    defaults_dict = DEFAULTS._as_dict()\n\n    for key, str_value in environ.items():\n\n        if not key.startswith(ENV_PREFIX + \"_\"):\n            continue\n\n        key = key[skip_len:].lower()\n\n        if key not in defaults_dict:\n            continue\n\n        if isinstance(defaults_dict[key], bool):\n            value = load_bool(str_value)\n        else:\n            value = str_value\n\n        result[key] = value\n\n    return result", "target": 0}, {"function": "def read_all_files(config: types.SettingsDict) -> types.SettingsDict:\n    config = config.copy()\n\n    replace_path_with_content(config=config, setting_name=\"password\")\n    replace_path_with_content(config=config, setting_name=\"token\")\n\n    return config", "target": 0}, {"function": "def replace_path_with_content(config: types.SettingsDict, setting_name: str) -> None:\n    \"\"\"\n    Modifies config dict in place: reads the file at <setting_name>_file\n    and put its contents at <setting_name> instead.\n    \"\"\"\n    # Files override direct values when both are defined\n    filename = config.pop(f\"{setting_name}_file\", None)\n    if filename:\n        assert isinstance(filename, str)\n        logger.info(f\"Reading value of '{setting_name}' from file {filename}\")\n        config[setting_name] = read_file(filename)", "target": 0}, {"function": "def read_file(path: str) -> Optional[str]:\n    \"\"\"\n    Returns the content of the pointed file\n    \"\"\"\n    if path == \"-\":\n        return sys.stdin.read().strip()\n\n    with open(os.path.expanduser(path)) as file_handler:\n\n        return file_handler.read().strip()", "target": 0}, {"function": "def get_vault_options(*, config_file: Optional[str] = None, **kwargs: types.Settings):\n    config_files = [config_file] if config_file else CONFIG_FILES\n    values = build_config_from_files(*config_files).copy()\n    values.update(build_config_from_env(os.environ.copy()))\n    values.update(kwargs)\n\n    return values", "target": 0}, {"function": "def get_log_level(verbosity: int) -> int:\n    \"\"\"\n    Given the number of repetitions of the flag -v,\n    returns the desired log level\n    \"\"\"\n    return {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}.get(\n        min((2, verbosity)), 0\n    )", "target": 0}], "function_after": [{"function": "class DEFAULTS:\n    base_path = None\n    login_cert = None\n    login_cert_key = None\n    password = None\n    token = None\n    url = \"http://localhost:8200\"\n    username = None\n    verify = True\n    ca_bundle = None\n    safe_write = False\n\n    @staticmethod\n    def _as_dict():\n        return {k: v for k, v in vars(DEFAULTS).items() if k[0] != \"_\"}", "target": 0}, {"function": "def read_config_file(file_path: str) -> Optional[types.SettingsDict]:\n    try:\n        with open(os.path.expanduser(file_path), \"r\") as f:\n            config = yaml.safe_load(f) or {}\n            logger.info(\n                f\"Reading yaml config file at {file_path}, \"\n                f\"contains keys: {', '.join(config)}\"\n            )\n            return config\n    except FileNotFoundError:\n        logger.debug(f\"No config file at {file_path} (skipping)\")\n    except IOError:\n        logger.warning(\n            f\"Config file exists at {file_path}, but cannot be read. \"\n            \"Have you checked permissions? (skipping)\"\n        )\n\n    return None", "target": 0}, {"function": "def dash_to_underscores(config: types.SettingsDict) -> types.SettingsDict:\n    # Because we're modifying the dict during iteration, we need to\n    # consolidate the keys into a list\n    return {key.replace(\"-\", \"_\"): value for key, value in config.items()}", "target": 0}, {"function": "def load_bool(value: str) -> bool:\n    lower_value = value.lower()\n\n    if lower_value in (\"true\", \"t\", \"1\", \"yes\", \"y\"):\n        return True\n    elif lower_value in (\"false\", \"f\", \"0\", \"no\", \"n\"):\n        return False\n\n    raise exceptions.VaultSettingsError(\"Value {} could not be interpreted as boolean\")", "target": 0}, {"function": "def build_config_from_env(environ: Dict[str, str]) -> types.SettingsDict:\n    result: types.SettingsDict = {}\n\n    skip_len = len(ENV_PREFIX) + 1\n\n    value: Union[str, bool]\n\n    defaults_dict = DEFAULTS._as_dict()\n\n    for key, str_value in environ.items():\n\n        if not key.startswith(ENV_PREFIX + \"_\"):\n            continue\n\n        key = key[skip_len:].lower()\n\n        if key not in defaults_dict:\n            continue\n\n        if isinstance(defaults_dict[key], bool):\n            value = load_bool(str_value)\n        else:\n            value = str_value\n\n        result[key] = value\n\n    return result", "target": 0}, {"function": "def read_all_files(config: types.SettingsDict) -> types.SettingsDict:\n    config = config.copy()\n\n    replace_path_with_content(config=config, setting_name=\"password\")\n    replace_path_with_content(config=config, setting_name=\"token\")\n\n    return config", "target": 0}, {"function": "def replace_path_with_content(config: types.SettingsDict, setting_name: str) -> None:\n    \"\"\"\n    Modifies config dict in place: reads the file at <setting_name>_file\n    and put its contents at <setting_name> instead.\n    \"\"\"\n    # Files override direct values when both are defined\n    filename = config.pop(f\"{setting_name}_file\", None)\n    if filename:\n        assert isinstance(filename, str)\n        logger.info(f\"Reading value of '{setting_name}' from file {filename}\")\n        config[setting_name] = read_file(filename)", "target": 0}, {"function": "def read_file(path: str) -> Optional[str]:\n    \"\"\"\n    Returns the content of the pointed file\n    \"\"\"\n    if path == \"-\":\n        return sys.stdin.read().strip()\n\n    with open(os.path.expanduser(path)) as file_handler:\n\n        return file_handler.read().strip()", "target": 0}, {"function": "def get_vault_options(*, config_file: Optional[str] = None, **kwargs: types.Settings):\n    config_files = [config_file] if config_file else CONFIG_FILES\n    values = build_config_from_files(*config_files).copy()\n    values.update(build_config_from_env(os.environ.copy()))\n    values.update(kwargs)\n\n    return values", "target": 0}, {"function": "def get_log_level(verbosity: int) -> int:\n    \"\"\"\n    Given the number of repetitions of the flag -v,\n    returns the desired log level\n    \"\"\"\n    return {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}.get(\n        min((2, verbosity)), 0\n    )", "target": 0}]}, {"raw_url": "https://github.com/peopledoc/vault-cli/raw/3ba3955887fd6b7d4d646c8b260f21cebf5db852/vault_cli%2Futils.py", "code": "from typing import Dict, Iterable\n\n\ndef path_to_nested(dict_obj: Dict) -> Dict:\n    \"\"\"\n    Transform a dict with paths as keys into a nested\n    dict\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/e\": \"f\"})\n    {\"a\": {\"b\": {\"c\": \"d\"}, \"e\": \"f\"}}\n\n    If 2 unconsistent values are detected, fails with ValueError:\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/b\": \"e\"})\n    ValueError()\n    \"\"\"\n\n    for path in list(dict_obj):\n        working_dict = dict_obj\n\n        value = dict_obj.pop(path)\n\n        *folders, subpath = path.strip(\"/\").split(\"/\")\n\n        for folder in folders:\n            sub_dict = working_dict.setdefault(folder, {})\n            if not isinstance(sub_dict, dict):\n                raise ValueError(\"Inconsistent values detected\")\n            working_dict = sub_dict\n\n        if subpath in working_dict:\n            raise ValueError(\"Inconsistent values detected\")\n        working_dict[subpath] = value\n    return dict_obj\n\n\ndef extract_error_messages(exc: BaseException) -> Iterable[str]:\n    while True:\n        exc_str = str(exc).strip()\n        yield f\"{type(exc).__name__}: {exc_str}\"\n        opt_exc = exc.__cause__ or exc.__context__\n        if not opt_exc:\n            break\n        exc = opt_exc\n", "code_before": "from typing import Dict, Iterable\n\n\ndef path_to_nested(dict_obj: Dict) -> Dict:\n    \"\"\"\n    Transform a dict with paths as keys into a nested\n    dict\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/e\": \"f\"})\n    {\"a\": {\"b\": {\"c\": \"d\"}, \"e\": \"f\"}}\n\n    If 2 unconsistent values are detected, fails with ValueError:\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/b\": \"e\"})\n    ValueError()\n    \"\"\"\n\n    for path in list(dict_obj):\n        working_dict = dict_obj\n\n        value = dict_obj.pop(path)\n\n        *folders, subpath = path.strip(\"/\").split(\"/\")\n\n        for folder in folders:\n            sub_dict = working_dict.setdefault(folder, {})\n            if not isinstance(sub_dict, dict):\n                raise ValueError(\"Inconsistent values detected\")\n            working_dict = sub_dict\n\n        if subpath in working_dict:\n            raise ValueError(\"Inconsistent values detected\")\n        working_dict[subpath] = value\n    return dict_obj\n\n\ndef extract_error_messages(exc: BaseException) -> Iterable[str]:\n    while True:\n        exc_str = str(exc).strip()\n        yield f\"{type(exc).__name__}: {exc_str}\"\n        opt_exc = exc.__cause__ or exc.__context__\n        if not opt_exc:\n            break\n        exc = opt_exc\n", "patch": "@@ -32,17 +32,6 @@ def path_to_nested(dict_obj: Dict) -> Dict:\n     return dict_obj\n \n \n-class RecursiveValue:\n-    def __init__(self, name: str):\n-        self.name = name\n-\n-    def __str__(self) -> str:\n-        return f'<recursive value \"{self.name}\">'\n-\n-    def __getitem__(self, key: str) -> str:\n-        return str(self)\n-\n-\n def extract_error_messages(exc: BaseException) -> Iterable[str]:\n     while True:\n         exc_str = str(exc).strip()", "file_path": "files/2021_12/205", "file_language": "py", "file_name": "vault_cli/utils.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def path_to_nested(dict_obj: Dict) -> Dict:\n    \"\"\"\n    Transform a dict with paths as keys into a nested\n    dict\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/e\": \"f\"})\n    {\"a\": {\"b\": {\"c\": \"d\"}, \"e\": \"f\"}}\n\n    If 2 unconsistent values are detected, fails with ValueError:\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/b\": \"e\"})\n    ValueError()\n    \"\"\"\n\n    for path in list(dict_obj):\n        working_dict = dict_obj\n\n        value = dict_obj.pop(path)\n\n        *folders, subpath = path.strip(\"/\").split(\"/\")\n\n        for folder in folders:\n            sub_dict = working_dict.setdefault(folder, {})\n            if not isinstance(sub_dict, dict):\n                raise ValueError(\"Inconsistent values detected\")\n            working_dict = sub_dict\n\n        if subpath in working_dict:\n            raise ValueError(\"Inconsistent values detected\")\n        working_dict[subpath] = value\n    return dict_obj", "target": 0}, {"function": "def extract_error_messages(exc: BaseException) -> Iterable[str]:\n    while True:\n        exc_str = str(exc).strip()\n        yield f\"{type(exc).__name__}: {exc_str}\"\n        opt_exc = exc.__cause__ or exc.__context__\n        if not opt_exc:\n            break\n        exc = opt_exc", "target": 0}], "function_after": [{"function": "def path_to_nested(dict_obj: Dict) -> Dict:\n    \"\"\"\n    Transform a dict with paths as keys into a nested\n    dict\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/e\": \"f\"})\n    {\"a\": {\"b\": {\"c\": \"d\"}, \"e\": \"f\"}}\n\n    If 2 unconsistent values are detected, fails with ValueError:\n    >>> path_to_nested ({\"a/b/c\": \"d\", \"a/b\": \"e\"})\n    ValueError()\n    \"\"\"\n\n    for path in list(dict_obj):\n        working_dict = dict_obj\n\n        value = dict_obj.pop(path)\n\n        *folders, subpath = path.strip(\"/\").split(\"/\")\n\n        for folder in folders:\n            sub_dict = working_dict.setdefault(folder, {})\n            if not isinstance(sub_dict, dict):\n                raise ValueError(\"Inconsistent values detected\")\n            working_dict = sub_dict\n\n        if subpath in working_dict:\n            raise ValueError(\"Inconsistent values detected\")\n        working_dict[subpath] = value\n    return dict_obj", "target": 0}, {"function": "def extract_error_messages(exc: BaseException) -> Iterable[str]:\n    while True:\n        exc_str = str(exc).strip()\n        yield f\"{type(exc).__name__}: {exc_str}\"\n        opt_exc = exc.__cause__ or exc.__context__\n        if not opt_exc:\n            break\n        exc = opt_exc", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
