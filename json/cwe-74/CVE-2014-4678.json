{"index": 4362, "cve_id": "CVE-2014-4678", "cwe_id": ["CWE-74"], "cve_language": "Python", "cve_description": "The safe_eval function in Ansible before 1.6.4 does not properly restrict the code subset, which allows remote attackers to execute arbitrary code via crafted instructions. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-4657.", "cvss": "9.8", "publish_date": "February 19, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "5429b85b9f6c2e640074176f36ff05fd5e4d1916", "commit_message": "Change safe_eval to a strict white list", "commit_date": "2014-06-25T19:00:21Z", "project": "ansible/ansible", "url": "https://api.github.com/repos/ansible/ansible/commits/5429b85b9f6c2e640074176f36ff05fd5e4d1916", "html_url": "https://github.com/ansible/ansible/commit/5429b85b9f6c2e640074176f36ff05fd5e4d1916", "windows_before": [{"commit_id": "49f3a794b1572eebafc79745a7e9e08e93bcefc4", "commit_date": "Wed Jun 25 10:19:46 2014 -0700", "commit_message": "Fix missing code block in playbook variables doc", "files_name": ["docsite/rst/playbooks_variables.rst"]}, {"commit_id": "779c6cb7f8d35a884c0380a43e54e38da06d3564", "commit_date": "Wed Jun 25 23:21:43 2014 +0900", "commit_message": "In the yum module example, use present/absent instead of installed/removed", "files_name": ["library/packaging/yum"]}, {"commit_id": "dfc625a7df1a903969345b21321966ebdef2dce0", "commit_date": "Wed Jun 25 15:30:34 2014 +0200", "commit_message": "apt_key clear message when downloading key returns an (http) error code", "files_name": ["library/packaging/apt_key"]}, {"commit_id": "676f0a6e7634b8010f6c1b893723d0d45cabfc27", "commit_date": "Wed Jun 25 14:00:01 2014 +0100", "commit_message": "grammar fix", "files_name": ["library/cloud/docker_image"]}, {"commit_id": "49cf5831c5bdc1482dbdce0d404a2b6466411413", "commit_date": "Wed Jun 25 14:52:00 2014 +0800", "commit_message": "support old and new versions of APIError", "files_name": ["library/cloud/docker_image"]}, {"commit_id": "dfabf2707a47367cbaf0181fed81fca82a41759a", "commit_date": "Wed Jun 25 14:20:07 2014 +0800", "commit_message": "fixes the now-incorrect module for ApiError", "files_name": ["library/cloud/docker_image"]}, {"commit_id": "b5b840267f568ee06a70abbfcbdd5deaa3b21c91", "commit_date": "Tue Jun 24 20:37:37 2014 -0400", "commit_message": "apache2_module handles multiple lines of output, fixes #7736 and #7857", "files_name": ["library/web_infrastructure/apache2_module"]}, {"commit_id": "d8a7b49b590cc8bb0fc85b12e1861a25bbf86c31", "commit_date": "Tue Jun 24 15:21:08 2014 -0500", "commit_message": "Merge branch 'inventorytree' of https://github.com/sergevanginderachter/ansible into sergevanginderachter-inventorytree", "files_name": ["19f5ce2c9c86d665466f4f82668de8e769d63aa1 - Tue Jun 3 09:34:42 2014 -0500 : Allow --vault-password-file to work with a script as well as a flat file", "bin/ansible", "bin/ansible-playbook", "docsite/rst/playbooks_vault.rst", "lib/ansible/constants.py", "lib/ansible/utils/__init__.py"]}, {"commit_id": "375edbd087afa41a7331a2638c37509bade1af1a", "commit_date": "Tue Jun 24 12:16:57 2014 -0500", "commit_message": "Check to make sure key exists in tag list before using it", "files_name": ["library/cloud/ec2_asg"]}, {"commit_id": "98f843823682f39cc38ecd0084c3d7c8e52a7406", "commit_date": "Tue Jun 24 12:28:43 2014 -0500", "commit_message": "Updating the other classes in the group module to match #7249", "files_name": ["library/system/group"]}, {"commit_id": "bdd9b4cac43db8e0572a794de5cb1ea647d478d9", "commit_date": "Tue Jun 24 12:27:31 2014 -0500", "commit_message": "Merge pull request #7249 from jfchevrette/implement-group-checking-if-state-present", "files_name": ["5951f14dcb9f006f3c9880662711c57476caf24b - Tue Jun 24 12:24:21 2014 -0500 : Merge pull request #7915 from gitaarik/devel", "e4a4152f395cdf76a0c86a6f395d7940e754449b - Tue Jun 24 12:17:44 2014 -0500 : Merge pull request #7912 from adrienbrault/patch-1", "0fee40774d189350f72803cf2a601472a0a71099 - Tue Jun 24 11:48:31 2014 -0500 : Merge pull request #7909 from Elemecca/t-apt-list", "1adb6dfa051498b70ac34b4ac12524952c126149 - Tue Jun 24 10:45:11 2014 -0500 : Remove redundant 'self.user or' added by 0f91add", "lib/ansible/runner/connection_plugins/ssh.py"]}, {"commit_id": "59d98993ebd01bf68462988c74061f69721a4055", "commit_date": "Tue Jun 24 13:45:49 2014 +0200", "commit_message": "Added examples to the command module", "files_name": ["library/commands/command"]}, {"commit_id": "1146c09f9d1475c4c5d9c6d9a51bf324329f3254", "commit_date": "Tue Jun 24 13:40:19 2014 +0200", "commit_message": "Added examples to the shell module", "files_name": ["library/commands/shell"]}, {"commit_id": "be22ed632c50c474156a9880b91f8b046c732b29", "commit_date": "Mon Jun 23 19:50:17 2014 -0700", "commit_message": "Fix typo in playbook roles doc", "files_name": ["docsite/rst/playbooks_roles.rst"]}, {"commit_id": "769ee61f66562428eac6e26785d73272eb39b5d0", "commit_date": "Mon Jun 23 17:12:19 2014 -0700", "commit_message": "Restore #6484 reverted by c751168.", "files_name": ["library/packaging/apt"]}, {"commit_id": "bbaf80322711a23dfd1ea0b85fa84e61aa9db200", "commit_date": "Mon Jun 23 16:13:29 2014 -0500", "commit_message": "Merge pull request #7176 from leucos/devel", "files_name": ["45cf1dbbc5421539c99a0b6310752278f4ff244f - Mon Jun 23 16:58:07 2014 -0400 : Fixing issue #7906 Catch any InvalidInstanceID.NotFound errors coming from the boto library when trying to find the newly created instance. When this happens We should just wait and try again.", "library/cloud/ec2"]}, {"commit_id": "0f91add86f7d30e6d895e01bbfddb93a3b5e48df", "commit_date": "Mon Jun 23 15:56:40 2014 -0500", "commit_message": "Explicitly set the user option for ssh connections", "files_name": ["lib/ansible/runner/connection_plugins/ssh.py"]}, {"commit_id": "f8bf9cdeec286888cf75325510dc2937187fd088", "commit_date": "Mon Jun 23 15:00:05 2014 -0500", "commit_message": "Handle TemplateNotFound to render more helpful error message.", "files_name": ["lib/ansible/runner/action_plugins/template.py", "lib/ansible/utils/template.py"]}, {"commit_id": "126d15cc4345dc2f6c1e1f3a4a39c8c288553cbe", "commit_date": "Mon Jun 23 10:47:22 2014 +0200", "commit_message": "Adds support for Cloudwatch detailled monitoring in ec2_lc module.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "52c7d50f1ed27112dfe32c6f7dec43ec56ee2a96", "commit_date": "Mon Jun 23 13:04:51 2014 -0500", "commit_message": "Merge pull request #6824 from sivel/make-rpm-from-release", "files_name": ["5d65c1c4a43fb5bee3fb69f5ab44950d4f694811 - Mon Jun 23 13:00:51 2014 -0500 : Merge branch 'Mbosco-patch-1' into devel", "6bd062103725beb5a693b46686449d3ed825cd89 - Mon Jun 23 12:59:12 2014 -0500 : Merge branch 'devel' of https://github.com/ansible/ansible into devel", "1702c2fd5026ad1b9a861b1bd3a05a3cc4d0afda - Mon Jun 23 12:57:13 2014 -0500 : Merge branch 'patch-1' of https://github.com/Mbosco/ansible into Mbosco-patch-1", "5ad7dcf4f0fc168a3d3407c1f6acb2437ed559a0 - Mon Jun 23 12:42:42 2014 -0500 : Merge pull request #6766 from Jmainguy/mysql_db_bug", "9564818e1eebd173dc7f886c795221d385754197 - Mon Jun 23 12:38:12 2014 -0500 : Merge branch 'fix_lineinfile_newlines' into devel", "2bfdad1e864789ccd2800c5f1a94aec22304dec7 - Mon Jun 23 12:35:08 2014 -0500 : Merge pull request #7904 from loglevel9/7903", "59c5d6292b12f0e17ea520c59d0382fb3823b96e - Mon Jun 23 12:33:30 2014 -0500 : Merge pull request #7902 from jirutka/filter-relpath", "eef05f7b3171322be2b154d5d4423fdb4eee88c3 - Mon Jun 23 12:32:01 2014 -0500 : Merge branch 'botify-labs-bug/fix-health-check-to-zero-bug/7898' into devel", "9137679e5999ae0785132a1ca096dc87b9899928 - Mon Jun 23 12:31:15 2014 -0500 : Merge branch 'bug/fix-health-check-to-zero-bug/7898' of https://github.com/botify-labs/ansible into botify-labs-bug/fix-health-check-to-zero-bug/7898", "ce41b02300d582583447c4f7886fefddae2b2a94 - Mon Jun 23 12:28:32 2014 -0500 : Merge pull request #7887 from s0x/funtoo-gathering-facts", "5d4046204b2094396a991c3164812e10c2b62efb - Mon Jun 23 12:09:02 2014 -0500 : Merge pull request #7893 from botify-labs/feature/add-launch-group-sport-support", "095dffcfc2fa7a0547aff521c9b186d929e234e9 - Mon Jun 23 11:12:57 2014 -0500 : Merge branch 'amenonsen-upgrade-release' into devel", "67fb2e653e75726109c50d89960962f0eacd2f1b - Mon Jun 23 10:35:48 2014 -0500 : Merge branch 'upgrade-release' of https://github.com/amenonsen/ansible into amenonsen-upgrade-release", "677e99e3758a8ff6c49fd0c02931fb4588bb29ed - Mon Jun 23 11:16:03 2014 -0400 : force evaluation of vars memory_mb, num_cpus to be int fixes #7903", "library/cloud/vsphere_guest"]}, {"commit_id": "726a61eb43bed5621f37930f785a6a31bc8c3e14", "commit_date": "Mon Jun 23 15:23:57 2014 +0200", "commit_message": "Add os relpath filter", "files_name": ["lib/ansible/runner/filter_plugins/core.py"]}, {"commit_id": "65a8ffef6eccace96c972e99bcc4cb777b934bc1", "commit_date": "Mon Jun 23 06:13:00 2014 -0400", "commit_message": "Merge pull request #7900 from cchurch/fix_remote_chmod", "files_name": ["1f3663b19615b34045c04bb164fd93df708d43ec - Mon Jun 23 12:09:31 2014 +0200 : Adds support for `health_check_period` and `health_check_type` in `ec2_asg` module.", "library/cloud/ec2_asg"]}, {"commit_id": "6aaad5dc9b04db161b79bad7157ae542cb86c3fd", "commit_date": "Mon Jun 23 06:09:08 2014 -0400", "commit_message": "Fix missing arg for _remote_chmod method.", "files_name": ["lib/ansible/runner/__init__.py"]}, {"commit_id": "93daebe1e28655dfe55a2a08c1abe90ba952d480", "commit_date": "Mon Jun 23 09:05:47 2014 +0200", "commit_message": "Adding support for spot instances in ansible_lc.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "9631309433c021645cd41a88538c9fc2f3b0dcf7", "commit_date": "Sun Jun 22 12:26:49 2014 -0400", "commit_message": "Update CHANGELOG.md", "files_name": ["CHANGELOG.md"]}, {"commit_id": "4acc93b665ae02c371b6460e1c34a43d16ce6ec0", "commit_date": "Sun Jun 22 11:26:27 2014 -0500", "commit_message": "Merge pull request #7889 from chrishoffman/win_group", "files_name": ["558f4d7b1a3decf3d7721071954c1b6be9152d8c - Sun Jun 22 11:24:49 2014 -0500 : Merge pull request #7886 from chrishoffman/win_service", "0dab7b014b326ed4f544f4538f5f3dea4f06f0e1 - Sun Jun 22 08:55:01 2014 -0400 : Adding win_group module", "library/windows/win_group", "library/windows/win_group.ps1"]}, {"commit_id": "f4fd9d366b947ce0c8ea99c7edb7ec862575b161", "commit_date": "Sun Jun 22 04:08:59 2014 +0200", "commit_message": "Check for empty os-release file, fixes #7885", "files_name": ["lib/ansible/module_utils/facts.py"]}, {"commit_id": "1c2d244964fea876740a6d2998b193f0c227161d", "commit_date": "Sat Jun 21 22:01:02 2014 -0400", "commit_message": "Fixing bug with stopped state", "files_name": ["library/windows/win_service.ps1"]}, {"commit_id": "844e90093b8b820a6fd2f71dc0cfca1de56c2010", "commit_date": "Sat Jun 21 21:59:53 2014 -0400", "commit_message": "Better propagation of cmdlet errors", "files_name": ["library/windows/win_service.ps1"]}, {"commit_id": "31f50692126518c1271cfabaae1d3672eff7a249", "commit_date": "Sat Jun 21 21:58:26 2014 -0400", "commit_message": "Using generic windows service for example", "files_name": ["library/windows/win_service"]}, {"commit_id": "b869f76e018c22bccdd4be48939d49d9aae4f9c1", "commit_date": "Sat Jun 21 20:06:48 2014 -0500", "commit_message": "Allow deb package installation via with_items", "files_name": ["library/packaging/apt"]}, {"commit_id": "122fff970f1fd21cd794de090aa3f49b461c43e4", "commit_date": "Sat Jun 21 11:32:08 2014 -0500", "commit_message": "Merge pull request #7880 from yuyak/fix_typo_in_apt_doc", "files_name": ["1d632d65aeefe02d30d99734d92a89d477cbeb40 - Sat Jun 21 11:31:35 2014 -0500 : Merge pull request #7881 from cchurch/devel", "3be827f1c989201cc1b4fcf44e577cad155699f0 - Sat Jun 21 11:30:11 2014 -0500 : Merge pull request #7882 from chrishoffman/win_service", "8af38ae4360c9f3d2ec670d9ff39c40f40d4895d - Sat Jun 21 11:10:49 2014 -0400 : Adding win_service module", "library/windows/win_service", "library/windows/win_service.ps1"]}, {"commit_id": "f59041871ebef806c430d4036f5eb3c9c8f1fab7", "commit_date": "Sat Jun 21 10:27:43 2014 -0400", "commit_message": "Fix typo in powershell setup module.", "files_name": ["library/windows/setup.ps1", "test/integration/roles/test_win_setup/tasks/main.yml"]}, {"commit_id": "5482208eee9f58c0e90dab2202d828f378bc9ba8", "commit_date": "Sat Jun 21 21:27:57 2014 +0800", "commit_message": "Fix typo in apt module documentation", "files_name": ["library/packaging/apt"]}, {"commit_id": "59698e7fbfe2c491043d3b19ea1beb17a5c65132", "commit_date": "Sat Jun 21 00:53:30 2014 -0500", "commit_message": "Merge pull request #7876 from chrishoffman/shell_expand_roles_path", "files_name": ["4046d1fd0d91890d1d8850d0017cad115d829edf - Fri Jun 20 19:58:52 2014 -0400 : Correct Makefile variable usage", "Makefile"]}, {"commit_id": "cf997beb07ec66060e56b6b9f98ea8bba161d171", "commit_date": "Fri Jun 20 19:22:11 2014 -0400", "commit_message": "Shell expand DEFAULT_ROLES_PATH fixes #4897", "files_name": ["lib/ansible/constants.py"]}, {"commit_id": "70abc6f6ded1a66cd692bcb93c6bbba27bca82cd", "commit_date": "Fri Jun 20 15:55:10 2014 -0500", "commit_message": "Merge pull request #7374 from hfinucane/wait_for_pipes", "files_name": ["411311495f9293d08af6a41c3c111d30e04a95d1 - Fri Jun 20 16:04:10 2014 -0400 : Updated DEB build workflow", ".gitignore", "Makefile", "packaging/debian/changelog", "packaging/debian/control"]}, {"commit_id": "1c3a654912f5058b527458eef5b94edf40ad43e4", "commit_date": "Fri Jun 20 14:26:21 2014 -0500", "commit_message": "Conditionally try to get ebs_optimized parameter from instance", "files_name": ["library/cloud/ec2"]}, {"commit_id": "38c29e1fff9231da49a9be24f61cc90cf6a9f77c", "commit_date": "Fri Jun 20 14:08:45 2014 -0500", "commit_message": "Merge branch 'issue_7368' into devel", "files_name": ["f80467e0138a1a40becc40a12e01b398b058fbdf - Fri May 30 11:52:13 2014 +0800 : ec2_vpc: Fix error when using InstanceId as a route gateway.", "library/cloud/ec2_vpc"]}, {"commit_id": "989689890275928012712892617416ba544e4354", "commit_date": "Fri Jun 20 14:00:17 2014 -0500", "commit_message": "Merge branch 'psa-exit_json' into devel", "files_name": ["1c318fa3bd662c66a35a076faa0331430b2b8c9e - Fri Jun 20 13:59:55 2014 -0500 : Merge branch 'exit_json' of https://github.com/psa/ansible into psa-exit_json", "06e0e1f770c5b7b97a5b36baf4a78c38177e3393 - Fri Jun 20 13:27:04 2014 -0500 : Merge branch 'ajsalminen-lvg_dm_names' into devel", "8e0148f0845e9aec359efe827470bcc687d43123 - Fri Jun 20 13:24:07 2014 -0500 : Merge branch 'lvg_dm_names' of https://github.com/ajsalminen/ansible into ajsalminen-lvg_dm_names", "94963290b9de4724ec363bbe1789e494189bf38b - Fri Jun 20 12:51:54 2014 -0500 : Merge pull request #6981 from aliles/fix-localhost-executable-with-flags", "d0a115972ab42a25913e3a5e554aeee9e67fc47a - Fri Jun 20 12:48:32 2014 -0500 : Merge branch 'pkit-git_fix' into devel", "1864347f4488d2728d58c6730d684a3011f291ab - Fri Jun 20 12:47:21 2014 -0500 : Merge branch 'git_fix' of https://github.com/pkit/ansible into pkit-git_fix", "cc9658463b20dd974550556834207ad0198aa83a - Fri Jun 20 11:29:22 2014 -0500 : Merge pull request #7868 from simono/patch-1", "bba4f58240faa2d10e6342cc6bd5d6e82bee1d9e - Fri Jun 20 11:14:43 2014 -0500 : Merge pull request #7856 from njharman/devel", "ca821fd5acff1a18129f15c65124f5e5be0d29cc - Fri Jun 20 11:13:08 2014 -0500 : Merge branch 'stygstra-add_name' into devel", "4d3205b75357546c4e5e287a67941cd856adb52b - Fri Jun 20 11:12:49 2014 -0500 : Update authors for modprobe module", "library/system/modprobe"]}, {"commit_id": "81dad9f3559a721391bf16ec0119928b69b0bb93", "commit_date": "Fri Jun 20 11:12:24 2014 -0500", "commit_message": "Merge branch 'add_name' of https://github.com/stygstra/ansible into stygstra-add_name", "files_name": ["87a62900657773e6912e032120b666c84d9ad03a - Thu Jun 19 17:13:25 2014 -0400 : Use the right name for the vpc_id parameter", "library/cloud/ec2_vpc"]}, {"commit_id": "32aa948dd0d26f61d09315c4f68f3861b4449397", "commit_date": "Fri Jun 20 10:12:14 2014 -0500", "commit_message": "Exclude ps1 modules from the TestModules unittest", "files_name": ["test/units/TestModules.py"]}, {"commit_id": "5fe8cf19480c44de506748e079b4418aa53fc21a", "commit_date": "Fri Jun 20 17:14:36 2014 +0200", "commit_message": "win_feature: Fix Description.", "files_name": ["library/windows/win_feature"]}, {"commit_id": "22ae21ab43c1f94807e282b7d50987af13a6a9d6", "commit_date": "Fri Jun 20 10:12:14 2014 -0500", "commit_message": "Exclude ps1 modules from the TestModules unittest", "files_name": ["test/units/TestModules.py"]}, {"commit_id": "bbba99d5451b1994bfc756076b84dc89c851db93", "commit_date": "Fri Jun 20 09:42:27 2014 -0500", "commit_message": "Merge pull request #7866 from cchurch/devel", "files_name": ["3b4adb78cb91fe15b626f8ff4217c7b4c7e3915f - Fri Jun 20 09:36:53 2014 -0500 : Add shell_plugins to packages.", "setup.py"]}, {"commit_id": "48dbb79fbeace40aed8f24a0df23bac673508cf9", "commit_date": "Fri Jun 20 00:17:49 2014 -0500", "commit_message": "Merge branch 'issue_5679_lineinfile' into fix_lineinfile_newlines", "files_name": ["3c3c710a5873900e0782b0d273d278e1185ef2a5 - Fri Jun 20 00:16:52 2014 -0500 : Merge branch 'module_safe_eval' into fix_lineinfile_newlines", "8b15788a404ad1b9b8c36597ffc19026c00eefec - Thu Jun 19 22:42:25 2014 -0500 : Merge branch 'tgolly-devel' into devel", "d8bb116c1ad066d9d7a6c04fce2b6168aa5589c7 - Thu Jun 19 22:41:58 2014 -0500 : Merge branch 'devel' of https://github.com/tgolly/ansible into tgolly-devel", "515679473847a20c9938d205218c959cd2ad6056 - Thu Jun 19 22:10:41 2014 -0500 : Merge pull request #7861 from cchurch/devel", "615f70e3f4817e98b97a78402e2b049d72f4ec40 - Thu Jun 19 21:54:21 2014 -0500 : Fix missing space in script action plugin.", "lib/ansible/runner/action_plugins/script.py"]}, {"commit_id": "4f83eb79a1d9600c4635cb249097bee1998bb171", "commit_date": "Thu Jun 19 21:39:32 2014 -0500", "commit_message": "Merge pull request #6785 from CaptTofu/openstack", "files_name": []}], "windows_after": [{"commit_id": "5ca8482d51e51b0056f231669d1ec4331cb74b5a", "commit_date": "Wed Jun 25 22:10:59 2014 +0200", "commit_message": "Fix small typographic error", "files_name": ["CONTRIBUTING.md"]}, {"commit_id": "42691685ddab76c2b7605e1390fe02b0b17da67e", "commit_date": "Wed Jun 25 16:56:30 2014 -0500", "commit_message": "Merge pull request #7935 from mscherer/patch-1", "files_name": ["a91ab1ed55e79e0800a1ffda09ac6730ade1cc0a - Wed Jun 25 16:56:53 2014 -0500 : Merge pull request #7928 from timruffles/grammar", "f6c7e345274ecf2d7264aca0648c31560278729d - Wed Jun 25 17:03:10 2014 -0500 : Merge pull request #7931 from quiver/fix-yum-module-doc", "373fa0f7225467f9a2a3e4f0e525ab3d2869b08b - Wed Jun 25 17:03:29 2014 -0500 : Merge pull request #7934 from chrishepner/patch-1", "35368e531b36c800ff6e61fc79fcd9e05794aa7d - Wed Jun 25 20:18:03 2014 -0500 : Additional fixes for safe_eval", "lib/ansible/utils/__init__.py"]}, {"commit_id": "4de8c8ebf0ce6bf972d417219d202bb4fe565f66", "commit_date": "Wed Jun 25 22:58:37 2014 -0400", "commit_message": "Update RELEASES.txt", "files_name": ["RELEASES.txt"]}, {"commit_id": "86481c891d97ea05a32f4401052dcd0c3cd72bdf", "commit_date": "Wed Jun 25 22:59:48 2014 -0400", "commit_message": "Update CHANGELOG.md", "files_name": ["CHANGELOG.md"]}, {"commit_id": "f5a4bd8af637593b7545aae993a5e631d6556aff", "commit_date": "Wed Jun 25 22:17:21 2014 -0500", "commit_message": "Backporting packaging updates from 1.6 branch", "files_name": ["packaging/debian/changelog", "packaging/rpm/ansible.spec"]}, {"commit_id": "2305ac988194abd82802ac057a6112f7b3243e78", "commit_date": "Wed Jun 25 22:27:08 2014 -0500", "commit_message": "Merge pull request #7930 from trbs/apt_key_fetch_url_failure_codes", "files_name": ["05eb6aacec2ee1bdb1318587d4a183d1e5f92019 - Wed Jun 25 22:33:22 2014 -0500 : Merge pull request #7925 from devpopol/fixes/api_error", "a58912773d463a7ffd5789e9984c5e9a18449fd4 - Thu Jun 26 14:55:16 2014 +0300 : Success exit if sync=yes and no package provided", "library/packaging/portage"]}, {"commit_id": "82c026387fac70aef6f80e1b0bd5e8bdf1887fe8", "commit_date": "Thu Jun 26 15:02:15 2014 +0300", "commit_message": "Successfull exit if sync=yes and no package provided", "files_name": ["library/packaging/portage"]}, {"commit_id": "5c959e7a204b78b0bf0028a69e0862fba52b5045", "commit_date": "Thu Jun 26 10:22:07 2014 -0500", "commit_message": "Merge pull request #7939 from PinGwynn/feature", "files_name": ["08370b3caf52dfe319374cbd361bbe52a9d9e6b6 - Wed Jun 25 18:30:38 2014 +0530 : Fixed FreeBSD ports install issue", "library/packaging/portinstall"]}, {"commit_id": "29434b06b8e749edaa233545287247081067e0cd", "commit_date": "Thu Jun 26 11:50:33 2014 -0500", "commit_message": "Merge pull request #7942 from sidred10/devel", "files_name": ["d3268d05ec0e186b40ec4604bff369d7a434c5d3 - Tue Jun 24 01:10:57 2014 -0500 : Correctly handle .repo files in zypper_repository module", "library/packaging/zypper_repository"]}, {"commit_id": "539426f612e2698b607e1179c020bf0ac95971d4", "commit_date": "Thu Jun 26 22:40:31 2014 -0500", "commit_message": "Performance tuning inventory functions for large inventories", "files_name": ["lib/ansible/inventory/__init__.py", "lib/ansible/inventory/group.py"]}, {"commit_id": "f870120b3c35d8611c37a10341c22fd5c40dc53e", "commit_date": "Fri Jun 27 03:16:12 2014 -0500", "commit_message": "Check at most 16 characters of the key. Fixes #7936", "files_name": ["library/packaging/apt_key"]}, {"commit_id": "488aec39367358e9f1d1f770a9231c26cb7e4d21", "commit_date": "Fri Jun 27 13:54:59 2014 +0400", "commit_message": "Fix unsupported regexp parameter in assemble", "files_name": ["lib/ansible/module_utils/basic.py", "lib/ansible/runner/action_plugins/assemble.py"]}, {"commit_id": "a44e322db40791e8331f9eed21415599fa261522", "commit_date": "Fri Jun 27 14:53:54 2014 +0200", "commit_message": "Use correct parameter name in error message.", "files_name": ["library/system/cron"]}, {"commit_id": "16e61dc3e2c594f71bf2ea952024e9fe897b59b6", "commit_date": "Thu Jun 26 11:19:47 2014 -0400", "commit_message": "ELB enhancements", "files_name": ["library/cloud/ec2_elb_lb"]}, {"commit_id": "6fdf77f9fedd741deda08a2cbc51412155b4d6c5", "commit_date": "Fri Jun 27 16:35:27 2014 -0400", "commit_message": "Update guides.rst", "files_name": ["docsite/rst/guides.rst"]}, {"commit_id": "e1d57d8876589525d6942837a461471f64bd53ff", "commit_date": "Sat Jun 28 00:24:16 2014 -0400", "commit_message": "now compares permissions correctly", "files_name": ["library/files/acl"]}, {"commit_id": "0a5cac5657fc03b7ec86b8ccda4c4c43fcda56ba", "commit_date": "Sat Jun 28 14:27:33 2014 +1000", "commit_message": "Fixed bug with environment path for homebrew_cask", "files_name": ["library/packaging/homebrew_cask"]}, {"commit_id": "f0a71392908074c9648a67fdc404e660b26a8fc3", "commit_date": "Sat Jun 28 13:06:40 2014 +0200", "commit_message": "Fix exec_command prototype for the plugin", "files_name": ["lib/ansible/runner/connection_plugins/libvirt_lxc.py"]}, {"commit_id": "a1af6ca0c6edaf88ad38c3aac43c48aca52e2cab", "commit_date": "Sat Jun 28 08:21:15 2014 -0700", "commit_message": "CODING_GUIDELINES: Fix typo: / => \\", "files_name": ["CODING_GUIDELINES.md"]}, {"commit_id": "e013043f4084dde56070c1a3a479b9bfc78626bb", "commit_date": "Sat Jun 28 12:36:40 2014 -0500", "commit_message": "Merge pull request #7974 from msabramo/CODING_GUIDELINES_slash_to_backslash", "files_name": ["61b107da34227977ec78f214967d3958e96775b7 - Sun Jun 29 13:09:41 2014 -0500 : Correct typo: 'manaul' to 'manual'", "docsite/rst/guide_rax.rst"]}, {"commit_id": "2d53bc41edbe78fb86e3a07c3d6690d58d8e4c4d", "commit_date": "Sun Jun 29 13:21:43 2014 -0500", "commit_message": "Merge pull request #7981 from adamnbowen/patch-1", "files_name": ["14cf3c4d2a2444a24c3329e6ed3c280e8e8ab904 - Sun Jun 29 14:32:08 2014 -0500 : Merge pull request #7972 from mscherer/fix_lxc", "7413e501a1106c7bdc1d246a3da81b6e85163765 - Sun Jun 29 16:53:52 2014 -0400 : ec2_ami_search: new EBS types", "library/cloud/ec2_ami_search"]}, {"commit_id": "379e1a49cb225c9e04a2a6c2236d8c16baa727d2", "commit_date": "Mon Jun 30 17:23:55 2014 -0400", "commit_message": "fix swap translation on 4.x openbsd with 2.5.4 python", "files_name": ["lib/ansible/module_utils/facts.py"]}, {"commit_id": "685fae4d9c8739a4027b0a18ebbed1e26c0d88a6", "commit_date": "Mon Jun 30 16:54:27 2014 -0700", "commit_message": "nova.py: Remove DOCUMENTATION block", "files_name": ["plugins/inventory/nova.py"]}, {"commit_id": "0c3d7f1bd86503adeb9183001d1ba5b4faf0a239", "commit_date": "Mon Jun 30 21:42:02 2014 -0500", "commit_message": "Correct typo: 'additioanl' -> 'additional'", "files_name": ["docsite/rst/guide_rax.rst"]}, {"commit_id": "c0da5f6bd3e12a8e66ad36db748119ff3d72d805", "commit_date": "Mon Jun 30 21:44:08 2014 -0500", "commit_message": "Correct typo: 'receords' -> 'records'", "files_name": ["docsite/rst/guide_rax.rst"]}, {"commit_id": "26cc0b37807c345a64dc0b4314cc59cd918d1b81", "commit_date": "Mon Jun 30 21:40:11 2014 -0700", "commit_message": "nova.py: indented and sorted JSON output", "files_name": ["plugins/inventory/nova.py"]}, {"commit_id": "42966c22da67adcd2729cb6267ff7de55f8f6072", "commit_date": "Tue Jul 1 15:09:39 2014 +0200", "commit_message": "added missing force flag on mkfs commandline", "files_name": ["library/system/filesystem"]}, {"commit_id": "37318ca0954fd6f32938206c230580271b349e4d", "commit_date": "Tue Jul 1 18:05:18 2014 +0100", "commit_message": "include default options. #7938", "files_name": ["bin/ansible-doc"]}, {"commit_id": "50ffa9e0e7c8f886623edcc8fb88acf4db489d4d", "commit_date": "Tue Jul 1 09:41:55 2014 -0700", "commit_message": "nova.py: Set defaults for OpenStack settings", "files_name": ["plugins/inventory/nova.py"]}, {"commit_id": "891aa41001d2cce549167b69a436c3dcc54eb2d9", "commit_date": "Tue Jul 1 18:49:07 2014 +0100", "commit_message": "add interfact documentation #7704", "files_name": ["library/system/ufw"]}, {"commit_id": "eeb597360e6d766bf700e2af4b7b2ae236d55b69", "commit_date": "Thu Jun 26 08:01:06 2014 -0500", "commit_message": "Further safe_eval fixes", "files_name": ["lib/ansible/utils/__init__.py"]}, {"commit_id": "8ed6350e65c82292a631f08845dfaacffe7f07f5", "commit_date": "Mon Jun 30 15:59:32 2014 -0500", "commit_message": "When parsing json from untrusted sources, remove templating tags", "files_name": ["lib/ansible/inventory/script.py", "lib/ansible/runner/__init__.py", "lib/ansible/runner/return_data.py", "lib/ansible/utils/__init__.py", "lib/ansible/utils/template.py"]}, {"commit_id": "4036df11cf19ad51ddb2ad9205b655d922c0110b", "commit_date": "Tue Jul 1 15:29:39 2014 -0400", "commit_message": "Add configurable option to support nested inventory groups.", "files_name": ["plugins/inventory/ec2.ini", "plugins/inventory/ec2.py"]}, {"commit_id": "d5b67814822935ef9da8cb51625ff94ecfa4dab1", "commit_date": "Tue Jul 1 09:30:50 2014 -0700", "commit_message": "Make resource_tags required and do whitespace cleanup", "files_name": ["library/cloud/ec2_vpc"]}, {"commit_id": "7f27c56a794e74db06ee42da870b1e4c13714fc2", "commit_date": "Tue Jul 1 15:50:04 2014 -0400", "commit_message": "Add option to return all EC2/RDS instances regardless of state.", "files_name": ["plugins/inventory/ec2.ini", "plugins/inventory/ec2.py"]}, {"commit_id": "f5122b8bfcd688bb9f133a26729d0f5eb0e9566d", "commit_date": "Tue Jul 1 16:00:03 2014 -0500", "commit_message": "CHANGELOG and other updates for 1.6.6 release", "files_name": ["CHANGELOG.md", "RELEASES.txt", "packaging/debian/changelog", "packaging/rpm/ansible.spec"]}, {"commit_id": "30fae95efeec959be880800470459e0e58311a4b", "commit_date": "Thu May 15 19:15:56 2014 -0400", "commit_message": "Change variable from pattern to name to correctly indicate what is being passed to the callback.", "files_name": ["lib/ansible/callback_plugins/noop.py", "lib/ansible/callbacks.py"]}, {"commit_id": "4e98e3785acee725b6f70f9f30d179b62662dd10", "commit_date": "Thu May 15 19:17:36 2014 -0400", "commit_message": "Reset play attribute on callback plugins when a play fails.", "files_name": ["lib/ansible/playbook/__init__.py"]}, {"commit_id": "955dadf7431f184f249e7b1903c05f661c232908", "commit_date": "Fri May 16 00:49:11 2014 -0400", "commit_message": "Remove runner_on_error callback that is never used.", "files_name": ["lib/ansible/callback_plugins/noop.py", "lib/ansible/callbacks.py", "plugins/callbacks/hipchat.py", "plugins/callbacks/log_plays.py", "plugins/callbacks/mail.py", "plugins/callbacks/osx_say.py"]}, {"commit_id": "afbc7f8a0f344c0f82d07709a0da9f353c47f54a", "commit_date": "Tue Jul 1 17:06:44 2014 -0400", "commit_message": "Change parameter from pattern to name for playbook_on_play_start in example callback plugins.", "files_name": ["plugins/callbacks/hipchat.py", "plugins/callbacks/log_plays.py", "plugins/callbacks/osx_say.py"]}, {"commit_id": "3613cb0ce5e4f8fad193fbcf697228eed1c9c859", "commit_date": "Tue Jul 1 20:07:32 2014 -0500", "commit_message": "Merge pull request #7993 from msabramo/nova.py_Remove_documentation_block", "files_name": ["6524809aeb8af76890b15a99df313056fc13f8a7 - Tue Jul 1 20:08:46 2014 -0500 : Merge pull request #7994 from adamnbowen/patch-2", "27b1d05e4b1c2fb493f7d974428754b369924827 - Tue Jul 1 20:09:23 2014 -0500 : Merge pull request #7995 from adamnbowen/patch-3", "67e56853d3b777b49297605c7d67c8252a3e5f6b - Tue Jul 1 20:10:49 2014 -0500 : Merge pull request #7996 from msabramo/nova.py_JSON_indented_and_sorted", "efc07cf6274b69b2dee4aa96d8490bcb46080b86 - Wed Jul 2 08:10:53 2014 -0400 : Return service name, display name, start mode and state from win_service module.", "library/windows/win_service.ps1"]}, {"commit_id": "12a0f4abd848655acdec54f3ac3746724f44c819", "commit_date": "Wed Jul 2 08:11:32 2014 -0400", "commit_message": "Add integration tests for win_service module.", "files_name": ["test/integration/roles/test_win_service/defaults/main.yml", "test/integration/roles/test_win_service/tasks/main.yml", "test/integration/test_winrm.yml"]}, {"commit_id": "0ee28c1a0e48ab8fb180d9a0e461ce5eb2253a5d", "commit_date": "Wed Jul 2 09:26:14 2014 -0500", "commit_message": "Make sure subnets and route_tables are initialized before using", "files_name": ["library/cloud/ec2_vpc"]}, {"commit_id": "81f35323e9e4c6b61d398941d567a213d41f91fd", "commit_date": "Wed Jul 2 09:44:44 2014 -0500", "commit_message": "Revert \"Fix get_distribution() for platforms that may have spaces\"", "files_name": ["lib/ansible/module_utils/basic.py"]}, {"commit_id": "746f52c5aaea9954260d11a977921584f1cff513", "commit_date": "Wed Jul 2 09:50:27 2014 -0500", "commit_message": "Merge pull request #7896 from botify-labs/feature/add-instance-monitoring-to-ec2-lc", "files_name": ["c555b3a0b99c8221ffa95276b0776b576eecf39e - Tue Jul 1 07:34:55 2014 +0200 : Adds support for `kern_id` param in ec2_ls module.", "library/cloud/ec2_lc"]}, {"commit_id": "fcdafb7ff4436e57fca6a4b8c0fc23ea91f36422", "commit_date": "Tue Jul 1 07:39:06 2014 +0200", "commit_message": "Adds RAM disk id support for ec2_lc module.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "00c6253c8f4ebf3e7b5b3209157178f405a2c3e2", "commit_date": "Tue Jul 1 07:47:04 2014 +0200", "commit_message": "Adds support for IAM instance profile in ec2_lc module", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "729b56cb23b3007d2777db02bb2b82d0bb94851c", "commit_date": "Tue Jul 1 07:50:29 2014 +0200", "commit_message": "Adds support for EBS optimized instances in ecl_lc module.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "3ecfbfce4b3a6f5a413a5dd019852acb9599638c", "commit_date": "Tue Jul 1 07:53:30 2014 +0200", "commit_message": "Adds the possibility to attach a public IP address to instances launched into an autoscaling group within a VPC to ec2_lc module.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "ed9c2419d1d362cb13eca32e5cec077833ffbbdd", "commit_date": "Tue Jul 1 07:55:51 2014 +0200", "commit_message": "Adds support for instance monitoring in ec2_lc module.", "files_name": ["library/cloud/ec2_lc"]}, {"commit_id": "5b783e0bc60cc75115d4c90e5b4c1c623c4a4611", "commit_date": "Wed Jul 2 13:21:01 2014 -0700", "commit_message": "Error if private_key_file is group/world readable", "files_name": ["lib/ansible/runner/connection.py"]}, {"commit_id": "97b3e8c6e4c3ecd61e27ae604b8d1b0cb7b48ffd", "commit_date": "Wed Jul 2 23:13:29 2014 +0000", "commit_message": "Fix for #7368 breaks peering connections. Unreak them.", "files_name": ["library/cloud/ec2_vpc"]}, {"commit_id": "a9e23cf090ab60874bc696ae3c5ef217cdc8ec5f", "commit_date": "Wed Jul 2 16:21:55 2014 -0700", "commit_message": "ansible_ec2_instance-id key incorrect", "files_name": ["docsite/rst/guide_aws.rst"]}], "parents": [{"commit_id_before": "375edbd087afa41a7331a2638c37509bade1af1a", "url_before": "https://api.github.com/repos/ansible/ansible/commits/375edbd087afa41a7331a2638c37509bade1af1a", "html_url_before": "https://github.com/ansible/ansible/commit/375edbd087afa41a7331a2638c37509bade1af1a"}], "details": [{"raw_url": "https://github.com/ansible/ansible/raw/5429b85b9f6c2e640074176f36ff05fd5e4d1916/lib%2Fansible%2Fconstants.py", "code": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pwd\nimport sys\nimport ConfigParser\nfrom string import ascii_letters, digits\n\n# copied from utils, avoid circular reference fun :)\ndef mk_boolean(value):\n    if value is None:\n        return False\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False, islist=False):\n    ''' return a configuration variable with casting '''\n    value = _get_config(p, section, key, env_var, default)\n    if boolean:\n        return mk_boolean(value)\n    if value and integer:\n        return int(value)\n    if value and floating:\n        return float(value)\n    if value and islist:\n        return [x.strip() for x in value.split(',')]\n    return value\n\ndef _get_config(p, section, key, env_var, default):\n    ''' helper function for get_config '''\n    if env_var is not None:\n        value = os.environ.get(env_var, None)\n        if value is not None:\n            return value\n    if p is not None:\n        try:\n            return p.get(section, key, raw=True)\n        except:\n            return default\n    return default\n\ndef load_config_file():\n    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''\n\n    p = ConfigParser.ConfigParser()\n\n    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)\n    if path0 is not None:\n        path0 = os.path.expanduser(path0)\n    path1 = os.getcwd() + \"/ansible.cfg\"\n    path2 = os.path.expanduser(\"~/.ansible.cfg\")\n    path3 = \"/etc/ansible/ansible.cfg\"\n\n    for path in [path0, path1, path2, path3]:\n        if path is not None and os.path.exists(path):\n            p.read(path)\n            return p\n    return None\n\ndef shell_expand_path(path):\n    ''' shell_expand_path is needed as os.path.expanduser does not work\n        when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE '''\n    if path:\n        path = os.path.expanduser(path)\n    return path\n\np = load_config_file()\n\nactive_user   = pwd.getpwuid(os.geteuid())[0]\n\n# Needed so the RPM can call setup.py and have modules land in the\n# correct location. See #1277 for discussion\nif getattr(sys, \"real_prefix\", None):\n    # in a virtualenv\n    DIST_MODULE_PATH = os.path.join(sys.prefix, 'share/ansible/')\nelse:\n    DIST_MODULE_PATH = '/usr/share/ansible/'\n\n# check all of these extensions when looking for yaml files for things like\n# group variables -- really anything we can load\nYAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]\n\n# sections in config file\nDEFAULTS='defaults'\n\n# configurable things\nDEFAULT_HOST_LIST         = shell_expand_path(get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts'))\nDEFAULT_MODULE_PATH       = get_config(p, DEFAULTS, 'library',          'ANSIBLE_LIBRARY',          DIST_MODULE_PATH)\nDEFAULT_ROLES_PATH        = shell_expand_path(get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles'))\nDEFAULT_REMOTE_TMP        = shell_expand_path(get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '$HOME/.ansible/tmp'))\nDEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')\nDEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern',          None,                       '*')\nDEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, integer=True)\nDEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')\nDEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      'en_US.UTF-8')\nDEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, integer=True)\nDEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, integer=True)\nDEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      active_user)\nDEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, boolean=True)\nDEFAULT_PRIVATE_KEY_FILE  = shell_expand_path(get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None))\nDEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')\nDEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, boolean=True)\nDEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, integer=True)\nDEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, boolean=True)\nDEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')\nDEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       False, boolean=True)\nDEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}')\nDEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')\nDEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, boolean=True)\nDEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, boolean=True)\nDEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', 'sudo')\nDEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H')\nDEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')\nDEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)\nDEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')\nDEFAULT_SU_EXE            = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\nDEFAULT_SU                = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\nDEFAULT_SU_FLAGS          = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\nDEFAULT_SU_USER           = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\nDEFAULT_ASK_SU_PASS       = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\nDEFAULT_GATHERING         = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n\nDEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '/usr/share/ansible_plugins/action_plugins')\nDEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '/usr/share/ansible_plugins/callback_plugins')\nDEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '/usr/share/ansible_plugins/connection_plugins')\nDEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '/usr/share/ansible_plugins/lookup_plugins')\nDEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '/usr/share/ansible_plugins/vars_plugins')\nDEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '/usr/share/ansible_plugins/filter_plugins')\nDEFAULT_LOG_PATH               = shell_expand_path(get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', ''))\n\nANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, boolean=True)\nANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, boolean=True)\nANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, boolean=True)\nDISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, boolean=True)\nDEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, boolean=True)\nHOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, boolean=True)\nSYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, boolean=True)\nDEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, boolean=True)\nDEFAULT_CALLABLE_WHITELIST     = get_config(p, DEFAULTS, 'callable_whitelist', 'ANSIBLE_CALLABLE_WHITELIST', [], islist=True)\n\n# CONNECTION RELATED\nANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)\nANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', \"%(directory)s/ansible-ssh-%%h-%%p-%%r\")\nANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, boolean=True)\nPARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, boolean=True)\n# obsolete -- will be formally removed in 1.6\nZEROMQ_PORT                    = get_config(p, 'fireball_connection', 'zeromq_port', 'ANSIBLE_ZEROMQ_PORT', 5099, integer=True)\nACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, integer=True)\nACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, integer=True)\nACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, floating=True)\nACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, integer=True)\nACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')\nACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')\nACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')\nACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, boolean=True)\nPARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, boolean=True)\n\n# characters included in auto-generated passwords\nDEFAULT_PASSWORD_CHARS = ascii_letters + digits + \".,:-_\"\n\n# non-configurable things\nDEFAULT_SUDO_PASS         = None\nDEFAULT_REMOTE_PASS       = None\nDEFAULT_SUBSET            = None\nDEFAULT_SU_PASS           = None\nVAULT_VERSION_MIN         = 1.0\nVAULT_VERSION_MAX         = 1.0\n", "code_before": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pwd\nimport sys\nimport ConfigParser\nfrom string import ascii_letters, digits\n\n# copied from utils, avoid circular reference fun :)\ndef mk_boolean(value):\n    if value is None:\n        return False\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False):\n    ''' return a configuration variable with casting '''\n    value = _get_config(p, section, key, env_var, default)\n    if boolean:\n        return mk_boolean(value)\n    if value and integer:\n        return int(value)\n    if value and floating:\n        return float(value)\n    return value\n\ndef _get_config(p, section, key, env_var, default):\n    ''' helper function for get_config '''\n    if env_var is not None:\n        value = os.environ.get(env_var, None)\n        if value is not None:\n            return value\n    if p is not None:\n        try:\n            return p.get(section, key, raw=True)\n        except:\n            return default\n    return default\n\ndef load_config_file():\n    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''\n\n    p = ConfigParser.ConfigParser()\n\n    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)\n    if path0 is not None:\n        path0 = os.path.expanduser(path0)\n    path1 = os.getcwd() + \"/ansible.cfg\"\n    path2 = os.path.expanduser(\"~/.ansible.cfg\")\n    path3 = \"/etc/ansible/ansible.cfg\"\n\n    for path in [path0, path1, path2, path3]:\n        if path is not None and os.path.exists(path):\n            p.read(path)\n            return p\n    return None\n\ndef shell_expand_path(path):\n    ''' shell_expand_path is needed as os.path.expanduser does not work\n        when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE '''\n    if path:\n        path = os.path.expanduser(path)\n    return path\n\np = load_config_file()\n\nactive_user   = pwd.getpwuid(os.geteuid())[0]\n\n# Needed so the RPM can call setup.py and have modules land in the\n# correct location. See #1277 for discussion\nif getattr(sys, \"real_prefix\", None):\n    # in a virtualenv\n    DIST_MODULE_PATH = os.path.join(sys.prefix, 'share/ansible/')\nelse:\n    DIST_MODULE_PATH = '/usr/share/ansible/'\n\n# check all of these extensions when looking for yaml files for things like\n# group variables -- really anything we can load\nYAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]\n\n# sections in config file\nDEFAULTS='defaults'\n\n# configurable things\nDEFAULT_HOST_LIST         = shell_expand_path(get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts'))\nDEFAULT_MODULE_PATH       = get_config(p, DEFAULTS, 'library',          'ANSIBLE_LIBRARY',          DIST_MODULE_PATH)\nDEFAULT_ROLES_PATH        = shell_expand_path(get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles'))\nDEFAULT_REMOTE_TMP        = shell_expand_path(get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '$HOME/.ansible/tmp'))\nDEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')\nDEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern',          None,                       '*')\nDEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, integer=True)\nDEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')\nDEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      'en_US.UTF-8')\nDEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, integer=True)\nDEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, integer=True)\nDEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      active_user)\nDEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, boolean=True)\nDEFAULT_PRIVATE_KEY_FILE  = shell_expand_path(get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None))\nDEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')\nDEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, boolean=True)\nDEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, integer=True)\nDEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, boolean=True)\nDEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')\nDEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       False, boolean=True)\nDEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}')\nDEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')\nDEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, boolean=True)\nDEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, boolean=True)\nDEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', 'sudo')\nDEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H')\nDEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')\nDEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)\nDEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')\nDEFAULT_SU_EXE = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\nDEFAULT_SU = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\nDEFAULT_SU_FLAGS = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\nDEFAULT_SU_USER = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\nDEFAULT_ASK_SU_PASS = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\nDEFAULT_GATHERING = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n\nDEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '/usr/share/ansible_plugins/action_plugins')\nDEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '/usr/share/ansible_plugins/callback_plugins')\nDEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '/usr/share/ansible_plugins/connection_plugins')\nDEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '/usr/share/ansible_plugins/lookup_plugins')\nDEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '/usr/share/ansible_plugins/vars_plugins')\nDEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '/usr/share/ansible_plugins/filter_plugins')\nDEFAULT_LOG_PATH               = shell_expand_path(get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', ''))\n\nANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, boolean=True)\nANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, boolean=True)\nANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, boolean=True)\nDISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, boolean=True)\nDEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, boolean=True)\nHOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, boolean=True)\nSYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, boolean=True)\nDEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, boolean=True)\n\n# CONNECTION RELATED\nANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)\nANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', \"%(directory)s/ansible-ssh-%%h-%%p-%%r\")\nANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, boolean=True)\nPARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, boolean=True)\n# obsolete -- will be formally removed in 1.6\nZEROMQ_PORT                    = get_config(p, 'fireball_connection', 'zeromq_port', 'ANSIBLE_ZEROMQ_PORT', 5099, integer=True)\nACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, integer=True)\nACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, integer=True)\nACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, floating=True)\nACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, integer=True)\nACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')\nACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')\nACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')\nACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, boolean=True)\nPARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, boolean=True)\n\n# characters included in auto-generated passwords\nDEFAULT_PASSWORD_CHARS = ascii_letters + digits + \".,:-_\"\n\n# non-configurable things\nDEFAULT_SUDO_PASS         = None\nDEFAULT_REMOTE_PASS       = None\nDEFAULT_SUBSET            = None\nDEFAULT_SU_PASS           = None\nVAULT_VERSION_MIN         = 1.0\nVAULT_VERSION_MAX         = 1.0\n", "patch": "@@ -31,7 +31,7 @@ def mk_boolean(value):\n     else:\n         return False\n \n-def get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False):\n+def get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False, islist=False):\n     ''' return a configuration variable with casting '''\n     value = _get_config(p, section, key, env_var, default)\n     if boolean:\n@@ -40,6 +40,8 @@ def get_config(p, section, key, env_var, default, boolean=False, integer=False,\n         return int(value)\n     if value and floating:\n         return float(value)\n+    if value and islist:\n+        return [x.strip() for x in value.split(',')]\n     return value\n \n def _get_config(p, section, key, env_var, default):\n@@ -129,12 +131,12 @@ def shell_expand_path(path):\n DEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')\n DEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)\n DEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')\n-DEFAULT_SU_EXE = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\n-DEFAULT_SU = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\n-DEFAULT_SU_FLAGS = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\n-DEFAULT_SU_USER = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\n-DEFAULT_ASK_SU_PASS = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\n-DEFAULT_GATHERING = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n+DEFAULT_SU_EXE            = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\n+DEFAULT_SU                = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\n+DEFAULT_SU_FLAGS          = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\n+DEFAULT_SU_USER           = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\n+DEFAULT_ASK_SU_PASS       = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\n+DEFAULT_GATHERING         = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n \n DEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '/usr/share/ansible_plugins/action_plugins')\n DEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '/usr/share/ansible_plugins/callback_plugins')\n@@ -152,6 +154,7 @@ def shell_expand_path(path):\n HOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, boolean=True)\n SYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, boolean=True)\n DEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, boolean=True)\n+DEFAULT_CALLABLE_WHITELIST     = get_config(p, DEFAULTS, 'callable_whitelist', 'ANSIBLE_CALLABLE_WHITELIST', [], islist=True)\n \n # CONNECTION RELATED\n ANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)", "file_path": "files/2020_2/140", "file_language": "py", "file_name": "lib/ansible/constants.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/ansible/ansible/raw/5429b85b9f6c2e640074176f36ff05fd5e4d1916/lib%2Fansible%2Futils%2F__init__.py", "code": "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\n#import vault\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef parse_json(raw_data):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        return json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n        return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Expression,\n            ast.Compare,\n            ast.Str,\n            ast.List,\n            ast.Tuple,\n            ast.Dict,\n            ast.Call,\n            ast.Load,\n            ast.BinOp,\n            ast.UnaryOp,\n            ast.Num,\n            ast.Name,\n            ast.Add,\n            ast.Sub,\n            ast.Mult,\n            ast.Div,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    # builtin functions that are safe to call\n    BUILTIN_WHITELIST = [\n        'abs', 'all', 'any', 'basestring', 'bin', 'bool', 'buffer', 'bytearray',\n        'bytes', 'callable', 'chr', 'cmp', 'coerce', 'complex', 'copyright', 'credits',\n        'dict', 'dir', 'divmod', 'enumerate', 'exit', 'float', 'format', 'frozenset',\n        'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id', 'int', 'intern',\n        'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long',\n        'map', 'max', 'memoryview', 'min', 'next', 'oct', 'ord', 'pow', 'print',\n        'property', 'quit', 'range', 'reversed', 'round', 'set', 'slice', 'sorted',\n        'str', 'sum', 'tuple', 'unichr', 'unicode', 'vars', 'xrange', 'zip',\n    ]\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = BUILTIN_WHITELIST + filter_list + C.DEFAULT_CALLABLE_WHITELIST\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            super(CleansingNodeVisitor, self).generic_visit(node)\n        def visit_Call(self, call):\n            if call.func.id not in CALL_WHITELIST:\n                raise Exception(\"invalid function: %s\" % call.func.id)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv = CleansingNodeVisitor()\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "code_before": "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\n#import vault\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef parse_json(raw_data):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        return json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n        return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Expression,\n            ast.Compare,\n            ast.Str,\n            ast.List,\n            ast.Tuple,\n            ast.Dict,\n            ast.Call,\n            ast.Load,\n            ast.BinOp,\n            ast.UnaryOp,\n            ast.Num,\n            ast.Name,\n            ast.Add,\n            ast.Sub,\n            ast.Mult,\n            ast.Div,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    # builtin functions that are not safe to call\n    INVALID_CALLS = (\n       'classmethod', 'compile', 'delattr', 'eval', 'execfile', 'file',\n       'filter', 'help', 'input', 'object', 'open', 'raw_input', 'reduce',\n       'reload', 'repr', 'setattr', 'staticmethod', 'super', 'type',\n    )\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node):\n            if type(node) not in SAFE_NODES:\n                #raise Exception(\"invalid expression (%s) type=%s\" % (expr, type(node)))\n                raise Exception(\"invalid expression (%s)\" % expr)\n            super(CleansingNodeVisitor, self).generic_visit(node)\n        def visit_Call(self, call):\n            if call.func.id in INVALID_CALLS:\n                raise Exception(\"invalid function: %s\" % call.func.id)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv = CleansingNodeVisitor()\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "patch": "@@ -1065,21 +1065,31 @@ def safe_eval(expr, locals={}, include_exceptions=False):\n             )\n         )\n \n-    # builtin functions that are not safe to call\n-    INVALID_CALLS = (\n-       'classmethod', 'compile', 'delattr', 'eval', 'execfile', 'file',\n-       'filter', 'help', 'input', 'object', 'open', 'raw_input', 'reduce',\n-       'reload', 'repr', 'setattr', 'staticmethod', 'super', 'type',\n-    )\n+    # builtin functions that are safe to call\n+    BUILTIN_WHITELIST = [\n+        'abs', 'all', 'any', 'basestring', 'bin', 'bool', 'buffer', 'bytearray',\n+        'bytes', 'callable', 'chr', 'cmp', 'coerce', 'complex', 'copyright', 'credits',\n+        'dict', 'dir', 'divmod', 'enumerate', 'exit', 'float', 'format', 'frozenset',\n+        'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id', 'int', 'intern',\n+        'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long',\n+        'map', 'max', 'memoryview', 'min', 'next', 'oct', 'ord', 'pow', 'print',\n+        'property', 'quit', 'range', 'reversed', 'round', 'set', 'slice', 'sorted',\n+        'str', 'sum', 'tuple', 'unichr', 'unicode', 'vars', 'xrange', 'zip',\n+    ]\n+\n+    filter_list = []\n+    for filter in filter_loader.all():\n+        filter_list.extend(filter.filters().keys())\n+\n+    CALL_WHITELIST = BUILTIN_WHITELIST + filter_list + C.DEFAULT_CALLABLE_WHITELIST\n \n     class CleansingNodeVisitor(ast.NodeVisitor):\n         def generic_visit(self, node):\n             if type(node) not in SAFE_NODES:\n-                #raise Exception(\"invalid expression (%s) type=%s\" % (expr, type(node)))\n                 raise Exception(\"invalid expression (%s)\" % expr)\n             super(CleansingNodeVisitor, self).generic_visit(node)\n         def visit_Call(self, call):\n-            if call.func.id in INVALID_CALLS:\n+            if call.func.id not in CALL_WHITELIST:\n                 raise Exception(\"invalid function: %s\" % call.func.id)\n \n     if not isinstance(expr, basestring):", "file_path": "files/2020_2/141", "file_language": "py", "file_name": "lib/ansible/utils/__init__.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
