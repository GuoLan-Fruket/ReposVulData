{"index": 7815, "cve_id": "CVE-2021-3654", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "A vulnerability was found in openstack-nova's console proxy, noVNC. By crafting a malicious URL, noVNC could be made to redirect to any desired URL.", "cvss": "9.1", "publish_date": "March 2, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "HIGH", "UI": "NONE", "S": "CHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "781612b33282ed298f742c85dab58a075c8b793e", "commit_message": "Reject open redirection in the console proxy\n\nOur console proxies (novnc, serial, spice) run in a websockify server\nwhose request handler inherits from the python standard\nSimpleHTTPRequestHandler. There is a known issue [1] in the\nSimpleHTTPRequestHandler which allows open redirects by way of URLs\nin the following format:\n\n  http://vncproxy.my.domain.com//example.com/%2F..\n\nwhich if visited, will redirect a user to example.com.\n\nWe can intercept a request and reject requests that pass a redirection\nURL beginning with \"//\" by implementing the\nSimpleHTTPRequestHandler.send_head() method containing the\nvulnerability to reject such requests with a 400 Bad Request.\n\nThis code is copied from a patch suggested in one of the issue comments\n[2].\n\nCloses-Bug: #1927677\n\n[1] https://bugs.python.org/issue32084\n[2] https://bugs.python.org/issue32084#msg306545\n\nChange-Id: Ie36401c782f023d1d5f2623732619105dc2cfa24", "commit_date": "2021-05-14T15:26:00Z", "project": "openstack/nova", "url": "https://api.github.com/repos/openstack/nova/commits/781612b33282ed298f742c85dab58a075c8b793e", "html_url": "https://github.com/openstack/nova/commit/781612b33282ed298f742c85dab58a075c8b793e", "windows_before": [{"commit_id": "6b5fa144e40d6f1af9da959c546c7867fca2ebf1", "commit_date": "Fri May 14 12:47:42 2021 +0000", "commit_message": "Merge \"mypy: Add type annotations to 'nova.pci'\"", "files_name": ["e1cc0ed978d40596d368ba19063fb5b51e96421e - Tue May 11 11:05:48 2021 +0100 : Add regression test for bug #1928063", "nova/tests/functional/regressions/test_bug_1928063.py"]}, {"commit_id": "02f4235230001879b874f6bb6b846bf5e795c725", "commit_date": "Thu May 13 17:01:12 2021 +0000", "commit_message": "Merge \"Adapt to SQLAlchemy 1.4\"", "files_name": ["212f89a61e16c05696e0ccc9f66bd6e5e6a91d4f - Fri Mar 12 18:13:53 2021 +0000 : tests: Split external service fixtures out", "nova/tests/fixtures/__init__.py", "nova/tests/fixtures/cinder.py", "nova/tests/fixtures/cyborg.py", "nova/tests/fixtures/glance.py", "nova/tests/fixtures/neutron.py", "nova/tests/fixtures/nova.py", "nova/tests/unit/compute/test_compute.py", "nova/tests/unit/conductor/test_conductor.py"]}, {"commit_id": "c269285568b2f4a76baf55d57ccd39ae202def19", "commit_date": "Fri Mar 12 18:58:41 2021 +0000", "commit_message": "tests: Move remaining non-libvirt fixtures", "files_name": ["nova/test.py", "nova/tests/fixtures/__init__.py", "nova/tests/fixtures/api_paste.py", "nova/tests/fixtures/cast_as_call.py", "nova/tests/fixtures/policy.py", "nova/tests/functional/api_sample_tests/api_sample_base.py", "nova/tests/functional/integrated_helpers.py", "nova/tests/functional/libvirt/test_numa_live_migration.py", "nova/tests/functional/libvirt/test_numa_servers.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/functional/regressions/test_bug_1522536.py", "nova/tests/functional/regressions/test_bug_1541691.py", "nova/tests/functional/regressions/test_bug_1548980.py", "nova/tests/functional/regressions/test_bug_1552888.py", "nova/tests/functional/regressions/test_bug_1554631.py", "nova/tests/functional/regressions/test_bug_1558866.py", "nova/tests/functional/regressions/test_bug_1595962.py", "nova/tests/functional/regressions/test_bug_1620248.py", "nova/tests/functional/regressions/test_bug_1670627.py", "nova/tests/functional/regressions/test_bug_1671648.py", "nova/tests/functional/regressions/test_bug_1675570.py", "nova/tests/functional/regressions/test_bug_1679750.py", "nova/tests/functional/regressions/test_bug_1682693.py", "nova/tests/functional/regressions/test_bug_1689692.py", "nova/tests/functional/regressions/test_bug_1702454.py", "nova/tests/functional/regressions/test_bug_1713783.py", "nova/tests/functional/regressions/test_bug_1718455.py", "nova/tests/functional/regressions/test_bug_1718512.py", "nova/tests/functional/regressions/test_bug_1719730.py", "nova/tests/functional/regressions/test_bug_1735407.py", "nova/tests/functional/regressions/test_bug_1741307.py", "nova/tests/functional/regressions/test_bug_1746483.py", "nova/tests/functional/regressions/test_bug_1764556.py", "nova/tests/functional/regressions/test_bug_1764883.py", "nova/tests/functional/regressions/test_bug_1780373.py", "nova/tests/functional/regressions/test_bug_1781286.py", "nova/tests/functional/regressions/test_bug_1781710.py", "nova/tests/functional/regressions/test_bug_1784353.py", "nova/tests/functional/regressions/test_bug_1797580.py", "nova/tests/functional/regressions/test_bug_1806064.py", "nova/tests/functional/regressions/test_bug_1815153.py", "nova/tests/functional/regressions/test_bug_1835822.py", "nova/tests/functional/regressions/test_bug_1852458.py", "nova/tests/functional/regressions/test_bug_1893284.py", "nova/tests/functional/regressions/test_bug_1902925.py", "nova/tests/functional/regressions/test_bug_1914777.py", "nova/tests/functional/test_aggregates.py", "nova/tests/functional/test_availability_zones.py", "nova/tests/functional/test_boot_from_volume.py", "nova/tests/functional/test_compute_mgr.py", "nova/tests/functional/test_cross_az_attach.py", "nova/tests/functional/test_cross_cell_migrate.py", "nova/tests/functional/test_external_networks.py", "nova/tests/functional/test_instance_actions.py", "nova/tests/functional/test_list_servers_ip_filter.py", "nova/tests/functional/test_nova_manage.py", "nova/tests/functional/test_policy.py", "nova/tests/functional/test_scheduler.py", "nova/tests/functional/test_server_faults.py", "nova/tests/functional/test_server_group.py", "nova/tests/functional/test_servers.py", "nova/tests/functional/test_service.py", "nova/tests/functional/wsgi/test_flavor_manage.py", "nova/tests/functional/wsgi/test_secgroup.py", "nova/tests/functional/wsgi/test_servers.py", "nova/tests/unit/api/openstack/compute/test_server_groups.py", "nova/tests/unit/cmd/test_policy.py", "nova/tests/unit/cmd/test_status.py", "nova/tests/unit/conductor/test_conductor.py", "nova/tests/unit/policies/base.py", "nova/tests/unit/policies/test_attach_interfaces.py", "nova/tests/unit/policies/test_instance_actions.py", "nova/tests/unit/policies/test_services.py", "nova/tests/unit/test_policy.py"]}, {"commit_id": "2e53c8265371b0eaa5e41f80e3b09fc72766cf13", "commit_date": "Fri Mar 12 18:15:25 2021 +0000", "commit_message": "tests: Move ConfFixture", "files_name": ["nova/test.py", "nova/tests/fixtures/__init__.py", "nova/tests/fixtures/conf.py", "nova/tests/unit/api/openstack/test_requestlog.py", "nova/tests/unit/test_fixtures.py"]}, {"commit_id": "d726ef51ec15509d7ee570b3d220e2e43d37c8f4", "commit_date": "Fri Mar 12 17:59:20 2021 +0000", "commit_message": "tests: Create 'nova.tests.fixtures' module", "files_name": ["nova/tests/fixtures/__init__.py", "nova/tests/fixtures/nova.py"]}, {"commit_id": "150b9182512fa0a4f157586e040a7f67c1851005", "commit_date": "Mon May 10 18:10:56 2021 +0800", "commit_message": "Replace getargspec with getfullargspec", "files_name": ["nova/cmd/common.py", "nova/network/neutron.py", "nova/test.py", "nova/tests/unit/objects/test_objects.py", "nova/tests/unit/virt/libvirt/test_imagebackend.py", "nova/utils.py"]}, {"commit_id": "78a6a13f965d9ac75cb146336c7ba435e6d9a9e4", "commit_date": "Tue May 11 21:03:48 2021 +0000", "commit_message": "Merge \"rbd: Get rbd_utils unit tests running again\"", "files_name": ["86af7feed06f08ddb3ef65122089216708d53a06 - Mon May 3 17:25:43 2021 +0200 : Stop leaking ceph df cmd in RBD utils", "nova/storage/rbd_utils.py", "nova/tests/unit/storage/test_rbd.py"]}, {"commit_id": "8b647f1b3f56879be221b3925570790a1e0e77f8", "commit_date": "Mon May 10 17:31:25 2021 +0000", "commit_message": "rbd: Get rbd_utils unit tests running again", "files_name": ["nova/tests/unit/storage/__init__.py", "nova/tests/unit/storage/test_rbd.py"]}, {"commit_id": "251e601a4d86b487723b5297abf38b967def3d5e", "commit_date": "Mon May 10 15:04:31 2021 -0400", "commit_message": "Fix typo in test_utils", "files_name": ["nova/tests/unit/test_utils.py"]}, {"commit_id": "39a617752f71cb8fe7188baee08b1c2ba48ad066", "commit_date": "Mon May 3 10:44:52 2021 +0200", "commit_message": "Adapt to SQLAlchemy 1.4", "files_name": ["nova/cmd/manage.py"]}, {"commit_id": "67f79fdb44565cfe6fd36e13979c22e79377fb8d", "commit_date": "Tue May 4 22:29:51 2021 +0000", "commit_message": "Add unit test for importing ed25519 ssh key", "files_name": ["nova/tests/unit/compute/test_keypairs.py"]}, {"commit_id": "7953c0197d1a4466cb5b78070d47626c92f9db6e", "commit_date": "Tue May 4 04:44:51 2021 +0000", "commit_message": "Merge \"Drop support for SQLite < 3.7\"", "files_name": ["34cad6dfbe6418d6d48598c1df94bce67c1b2f1b - Mon May 3 21:57:16 2021 +0000 : Merge \"Update SRIOV port pci_slot when unshelving\"", "48b5bf94a306916e5979316e34b82ac81751bb78 - Mon May 3 14:21:56 2021 +0000 : Merge \"Remove references to 'sys.version_info'\"", "294b30b281dde4a7c438cc1b9fa4842927394a17 - Sat May 1 18:31:08 2021 +0000 : Merge \"vmware: Handle folder renames in rescue cmd\"", "c0c2888acaaccfa4266874523f62039cb9e143e0 - Sat May 1 12:45:58 2021 +0000 : Merge \"Remove 'create_db_entry_for_new_instance'\"", "3a78dfe4d93a99d9eda9b66f0e059ad3f9964608 - Sat May 1 04:07:31 2021 +0000 : Merge \"Test SRIOV port move operations with PCI conflicts\"", "240edec14345ad108762c8ac322810bba1d03c96 - Sat May 1 04:06:48 2021 +0000 : Merge \"libvirt: Delegate OVS plug to os-vif\"", "a4fb34a80e438625a3914901a32ccbe81a866dac - Sat May 1 00:32:42 2021 +0000 : Merge \"Fix bond_mode enum 802.1ad -> 802.3ad\"", "370e322d7393d64abcc5c8da5cb723f886787364 - Fri Apr 30 19:00:36 2021 +0000 : Merge \"vmware: Use oslo.vmware's get_moref_value()\"", "8d5fd20048081f2fd2bd024679552046caf3e81c - Fri Apr 30 18:12:43 2021 +0000 : Merge \"Consolidate device detach error handling\"", "a62dd42c0dbb6b2ab128e558e127d76962738446 - Fri Apr 30 12:51:35 2021 +0100 : libvirt: Delegate OVS plug to os-vif", "lower-constraints.txt", "nova/compute/manager.py", "nova/network/model.py", "nova/network/os_vif_util.py", "nova/objects/migrate_data.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/unit/fake_network.py", "nova/tests/unit/network/test_os_vif_util.py", "nova/tests/unit/virt/libvirt/fakelibvirt.py", "nova/tests/unit/virt/libvirt/test_driver.py", "nova/tests/unit/virt/libvirt/test_vif.py", "nova/virt/libvirt/driver.py", "nova/virt/libvirt/vif.py", "releasenotes/notes/libvirt-delegate-ovs-plugging-to-os-vif-6adc0398a0e0df58.yaml", "requirements.txt"]}, {"commit_id": "0b05b838a47f4c05ecf8443ec48a6d6b2670f579", "commit_date": "Thu Apr 29 17:42:59 2021 +0200", "commit_message": "Fix bond_mode enum 802.1ad -> 802.3ad", "files_name": ["doc/api_schemas/network_data.json"]}, {"commit_id": "dab4ec1a534d4774e61a24cdace0f3491788e4e7", "commit_date": "Fri Mar 5 12:54:32 2021 +0000", "commit_message": "zuul: Remove nova-dsvm-multinode-base", "files_name": [".zuul.yaml"]}, {"commit_id": "91e53e4c2b90ea57aeac4ec522dd7c8c54961d09", "commit_date": "Fri Mar 5 11:33:29 2021 +0000", "commit_message": "zuul: Replace grenade and nova-grenade-multinode with grenade-multinode", "files_name": [".zuul.yaml", "gate/live_migration/hooks/ceph.sh", "gate/live_migration/hooks/nfs.sh", "gate/live_migration/hooks/run_tests.sh", "gate/live_migration/hooks/utils.sh", "playbooks/legacy/nova-grenade-multinode/post.yaml", "playbooks/legacy/nova-grenade-multinode/run.yaml", "playbooks/legacy/nova-live-migration/post.yaml", "playbooks/legacy/nova-live-migration/run.yaml"]}, {"commit_id": "51d16adda6c3324b95693c852232988b7bb2a781", "commit_date": "Thu Apr 22 11:50:53 2021 +0100", "commit_message": "mypy: Add type annotations to 'nova.pci'", "files_name": ["mypy-files.txt", "nova/pci/devspec.py", "nova/pci/manager.py", "nova/pci/request.py", "nova/pci/stats.py", "nova/pci/utils.py", "nova/pci/whitelist.py", "nova/tests/unit/pci/test_manager.py", "nova/tests/unit/pci/test_utils.py"]}, {"commit_id": "eba9d596daa91d8f702b719afb88cb89f2d5bb32", "commit_date": "Sat Apr 24 17:48:28 2021 +0000", "commit_message": "Merge \"Move instance power state check to _detach_with_retry\"", "files_name": ["3c526851254f14ebf5c5039682186dc668e4424c - Sat Apr 24 09:37:23 2021 +0000 : Merge \"Switch to new rolevar for run-tempest role\"", "00f1d4757e503bb9807d7a8d7035c061a97db983 - Wed Mar 31 16:57:35 2021 -0400 : Update SRIOV port pci_slot when unshelving", "nova/compute/manager.py", "nova/network/neutron.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/unit/network/test_neutron.py", "releasenotes/notes/bug-1851545-781c358939d96cea.yaml"]}, {"commit_id": "606d588e3eca1d88ad26b4c2cfa3f2e1d5ed553e", "commit_date": "Fri Apr 23 12:14:42 2021 +0100", "commit_message": "guestfs: With libguestfs >= v1.41.1 decode returned bytes to string", "files_name": ["nova/tests/unit/virt/disk/vfs/fakeguestfs.py", "nova/virt/disk/api.py"]}], "windows_after": [{"commit_id": "5592d314e15812073fc8b7fc69ae6df278098a29", "commit_date": "Sat May 15 06:16:43 2021 +0000", "commit_message": "Merge \"Reject open redirection in the console proxy\"", "files_name": ["82141b12c356fe374822038bdf0a6f0aaa32047b - Sat May 15 17:49:11 2021 +0000 : Merge \"Stop leaking ceph df cmd in RBD utils\"", "74724b4964b6eb80a462458c7b04935ccae49710 - Tue May 18 22:22:53 2021 +0900 : Change minversion of tox to 3.18.0", "tox.ini"]}, {"commit_id": "0d84833e9688e0df97f3d24e06025e512bca3ce3", "commit_date": "Tue Apr 27 12:19:47 2021 +0200", "commit_message": "Use the new type HostDomainOpt.", "files_name": ["lower-constraints.txt", "nova/conf/libvirt.py", "nova/conf/netconf.py", "requirements.txt"]}, {"commit_id": "b28579a7b0dd744e83d1b01c777eef7654066694", "commit_date": "Thu May 20 13:23:38 2021 +0200", "commit_message": "Describe the use of Review-Priority label", "files_name": ["doc/source/contributor/process.rst"]}, {"commit_id": "eb3926e65a1373ee92433aed28aed9a7bd561abb", "commit_date": "Thu May 20 14:06:25 2021 +0000", "commit_message": "Merge \"tests: Move remaining non-libvirt fixtures\"", "files_name": ["f44abb03a0e52043e480b6ab9a5ac973bc587881 - Thu May 20 14:06:56 2021 +0000 : Merge \"tests: Split external service fixtures out\"", "771ea5bf1ea667d6ffe456ee6ef081b83a77f53c - Thu May 20 15:50:32 2021 +0000 : Merge \"Add regression test for bug #1928063\"", "9d037f7d199443da0f2c6c1755704e589d52e730 - Wed May 12 13:11:50 2021 +0100 : image_meta: Provide image_ref as the id when fetching from instance", "nova/objects/image_meta.py", "nova/tests/unit/api/openstack/compute/test_server_actions.py", "nova/tests/unit/api/openstack/compute/test_servers.py", "nova/tests/unit/api/openstack/fakes.py", "nova/tests/unit/compute/test_api.py", "nova/tests/unit/compute/test_compute.py", "nova/tests/unit/objects/test_instance.py", "nova/tests/unit/virt/libvirt/test_driver.py", "nova/tests/unit/virt/libvirt/test_machine_type_utils.py", "nova/tests/unit/virt/libvirt/test_vif.py", "nova/tests/unit/virt/test_configdrive.py", "nova/tests/unit/virt/vmwareapi/test_driver_api.py"]}, {"commit_id": "d0b8028b5152875162b399c06a53e5b8eb46a5ee", "commit_date": "Thu May 20 17:24:48 2021 +0100", "commit_message": "docs: Add releases to libvirt distro support matrix", "files_name": ["doc/source/reference/libvirt-distro-support-matrix.rst"]}, {"commit_id": "33be6d4b56e4b6c2cbb16b6b8d40821162fdfa5c", "commit_date": "Sat Mar 13 11:53:04 2021 +0000", "commit_message": "tests: Move libvirt-specific fixtures", "files_name": ["nova/tests/fixtures/__init__.py", "nova/tests/fixtures/imagebackend.py", "nova/tests/fixtures/libvirt.py", "nova/tests/fixtures/libvirt_data.py", "nova/tests/functional/libvirt/base.py", "nova/tests/functional/libvirt/integrated_helpers.py", "nova/tests/functional/libvirt/test_evacuate.py", "nova/tests/functional/libvirt/test_numa_live_migration.py", "nova/tests/functional/libvirt/test_numa_servers.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/functional/libvirt/test_report_cpu_traits.py", "nova/tests/functional/libvirt/test_reshape.py", "nova/tests/functional/libvirt/test_vgpu.py", "nova/tests/functional/libvirt/test_vpmem.py", "nova/tests/functional/notification_sample_tests/test_libvirt.py", "nova/tests/functional/regressions/test_bug_1595962.py", "nova/tests/functional/regressions/test_bug_1888395.py", "nova/tests/functional/regressions/test_bug_1899649.py", "nova/tests/functional/regressions/test_bug_1928063.py", "nova/tests/unit/fixtures/test_libvirt.py", "nova/tests/unit/virt/libvirt/test_config.py", "nova/tests/unit/virt/libvirt/test_designer.py", "nova/tests/unit/virt/libvirt/test_driver.py", "nova/tests/unit/virt/libvirt/test_guest.py", "nova/tests/unit/virt/libvirt/test_host.py", "nova/tests/unit/virt/libvirt/test_migration.py", "nova/tests/unit/virt/libvirt/test_utils.py", "nova/tests/unit/virt/libvirt/test_vif.py", "nova/tests/unit/virt/libvirt/volume/test_volume.py", "nova/tests/unit/virt/test_virt_drivers.py"]}, {"commit_id": "e2d25eb149b4439751394fa583bfa10ee94c0b2a", "commit_date": "Sat Mar 13 12:20:30 2021 +0000", "commit_message": "tests: Add os-brick fixture", "files_name": ["nova/tests/fixtures/__init__.py", "nova/tests/fixtures/os_brick.py", "nova/tests/functional/libvirt/test_numa_live_migration.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/functional/regressions/test_bug_1888395.py", "nova/tests/unit/virt/test_virt_drivers.py"]}, {"commit_id": "696fbab9e1a96841b0acd1d5530b59e4c7878c00", "commit_date": "Thu May 20 11:30:03 2021 +0100", "commit_message": "tests: Rename 'ImageBackendFixture' to 'LibvirtImageBackendFixture'", "files_name": ["nova/tests/fixtures/__init__.py", "nova/tests/fixtures/libvirt_imagebackend.py", "nova/tests/functional/libvirt/base.py", "nova/tests/functional/libvirt/test_vpmem.py", "nova/tests/unit/virt/libvirt/test_driver.py", "nova/tests/unit/virt/test_virt_drivers.py"]}, {"commit_id": "f1f599d098c2dcb307bfab074060855c703a8288", "commit_date": "Thu Oct 15 12:47:36 2020 +0200", "commit_message": "Create a fixture around fake_notifier", "files_name": ["nova/tests/fixtures/__init__.py", "nova/tests/fixtures/notifications.py", "nova/tests/functional/compute/test_cache_image.py", "nova/tests/functional/compute/test_init_host.py", "nova/tests/functional/compute/test_live_migration.py", "nova/tests/functional/compute/test_resource_tracker.py", "nova/tests/functional/integrated_helpers.py", "nova/tests/functional/libvirt/test_evacuate.py", "nova/tests/functional/libvirt/test_numa_servers.py", "nova/tests/functional/libvirt/test_pci_sriov_servers.py", "nova/tests/functional/notification_sample_tests/notification_sample_base.py", "nova/tests/functional/notification_sample_tests/test_aggregate.py", "nova/tests/functional/notification_sample_tests/test_compute_task.py", "nova/tests/functional/notification_sample_tests/test_exception_notification.py", "nova/tests/functional/notification_sample_tests/test_flavor.py", "nova/tests/functional/notification_sample_tests/test_instance.py", "nova/tests/functional/notification_sample_tests/test_keypair.py", "nova/tests/functional/notification_sample_tests/test_libvirt.py", "nova/tests/functional/notification_sample_tests/test_metrics.py", "nova/tests/functional/notification_sample_tests/test_server_group.py", "nova/tests/functional/notification_sample_tests/test_service.py", "nova/tests/functional/notification_sample_tests/test_volume.py", "nova/tests/functional/regressions/test_bug_1713783.py", "nova/tests/functional/regressions/test_bug_1735407.py", "nova/tests/functional/regressions/test_bug_1764883.py", "nova/tests/functional/regressions/test_bug_1781286.py", "nova/tests/functional/regressions/test_bug_1806515.py", "nova/tests/functional/regressions/test_bug_1835822.py", "nova/tests/functional/regressions/test_bug_1843090.py", "nova/tests/functional/regressions/test_bug_1843708.py", "nova/tests/functional/regressions/test_bug_1862633.py", "nova/tests/functional/test_cold_migrate.py", "nova/tests/functional/test_cross_cell_migrate.py", "nova/tests/functional/test_server_external_events.py", "nova/tests/functional/test_servers.py", "nova/tests/unit/compute/test_compute.py", "nova/tests/unit/compute/test_compute_mgr.py", "nova/tests/unit/compute/test_compute_utils.py", "nova/tests/unit/compute/test_host_api.py", "nova/tests/unit/compute/test_resource_tracker.py", "nova/tests/unit/conductor/test_conductor.py", "nova/tests/unit/objects/test_objects.py", "nova/tests/unit/test_exception_wrapper.py", "nova/tests/unit/test_notifications.py"]}, {"commit_id": "b14f6ba62e4feed98e7293a6d67dbbc321994c7d", "commit_date": "Thu Oct 15 13:46:30 2020 +0200", "commit_message": "Use NotificationFixture for legacy notifications too", "files_name": ["nova/tests/fixtures/notifications.py", "nova/tests/functional/regressions/test_bug_1713783.py", "nova/tests/functional/regressions/test_bug_1837955.py", "nova/tests/unit/compute/test_compute.py", "nova/tests/unit/compute/test_compute_mgr.py", "nova/tests/unit/compute/test_compute_utils.py", "nova/tests/unit/compute/test_host_api.py", "nova/tests/unit/compute/test_keypairs.py", "nova/tests/unit/compute/test_resource_tracker.py", "nova/tests/unit/conductor/test_conductor.py", "nova/tests/unit/objects/test_aggregate.py", "nova/tests/unit/objects/test_objects.py", "nova/tests/unit/test_exception_wrapper.py", "nova/tests/unit/test_notifications.py"]}, {"commit_id": "b0cd985f0c09088098f74cc0cb1df616cc0ef12b", "commit_date": "Mon May 24 22:01:07 2021 +0000", "commit_message": "Merge \"image_meta: Provide image_ref as the id when fetching from instance\"", "files_name": ["472db13aaf140a3cd59877292b9518d7fb665d94 - Thu May 20 12:43:57 2021 +0100 : docs: Address TODO", "doc/source/admin/networking.rst"]}, {"commit_id": "740e6f09bf5a3e5ab3c6dd6d412dd1fe33f81d9f", "commit_date": "Mon Sep 21 11:27:46 2020 +0100", "commit_message": "libvirt: Enable 'vmcoreinfo' feature by default", "files_name": ["nova/tests/fixtures/libvirt_data.py", "nova/tests/unit/virt/libvirt/test_driver.py", "nova/virt/libvirt/config.py", "nova/virt/libvirt/driver.py", "releasenotes/notes/libvirt-vmcoreinfo-3be69e21dfe7dbd2.yaml"]}, {"commit_id": "d5ed968826895d362f4f2aa21decfdebb9b1fd84", "commit_date": "Wed May 26 19:27:45 2021 +0100", "commit_message": "zuul: Skip swap_volume tests as part of nova-next", "files_name": [".zuul.yaml"]}, {"commit_id": "e98994027f0af0b22277bcfaed4ab6e6f4a2c74e", "commit_date": "Tue May 11 11:37:22 2021 +0100", "commit_message": "hardware: Use image_meta.id within get_mem_encryption_constraint", "files_name": ["nova/tests/functional/regressions/test_bug_1928063.py", "nova/tests/unit/virt/test_hardware.py", "nova/virt/hardware.py"]}, {"commit_id": "56eb253e9febccf721df6bca4eb851ad26cb70a6", "commit_date": "Fri May 28 00:26:04 2021 +0000", "commit_message": "Honor [neutron]http_retries in the manual client", "files_name": ["nova/network/neutron.py", "nova/tests/unit/network/test_neutron.py"]}, {"commit_id": "17ac1a40cbc7773e5f86e2f5ef2e14767a14e4c8", "commit_date": "Tue Apr 13 14:50:57 2021 +0200", "commit_message": "Add test coverage for security group checking", "files_name": ["nova/tests/unit/network/test_neutron.py"]}, {"commit_id": "5c50a45a1e5b66e6ef97192bbaec6fdd54f9c2a4", "commit_date": "Fri May 14 15:29:47 2021 +0200", "commit_message": "Fix RequestLevelParams persistence handling in RequestSpec", "files_name": ["nova/objects/request_spec.py", "nova/tests/unit/objects/test_request_spec.py"]}, {"commit_id": "fc3838a9b3700b4b83d6d34ae86b6ab057c2dab3", "commit_date": "Mon May 31 10:43:49 2021 +0200", "commit_message": "Change nova doc after Freenode -> OFTC move", "files_name": ["doc/source/contributor/api.rst", "releasenotes/notes/deprecate-image-download-ext-point-cd5809e11bbd09d3.yaml", "releasenotes/notes/deprecate-xen-driver-train-bd57a16fa51ab679.yaml", "releasenotes/notes/remove-caching-scheduler-cfe0985b5a58bef4.yaml"]}, {"commit_id": "5cf06bf33d8f187d444f812177946e134e4c9932", "commit_date": "Mon May 31 15:07:41 2021 +0100", "commit_message": "docs: Remove duplicate ToC entry", "files_name": ["doc/source/user/index.rst"]}, {"commit_id": "9e7cd433d109e5c6d714b6d1633d07d7fd236a89", "commit_date": "Tue Jun 1 13:48:51 2021 +0000", "commit_message": "Merge \"Add unit test for importing ed25519 ssh key\"", "files_name": ["3fdd3ea89a01ba879ee58660deaa839b28696a70 - Tue Jun 1 13:49:38 2021 +0000 : Merge \"Change minversion of tox to 3.18.0\"", "da57eebc9e1ab7e48d4c4ef6ec1eeba80d867d81 - Tue Jun 1 13:51:24 2021 +0000 : Merge \"Remove unused DeleteFromSelect db api method\"", "7c7a2a142d74a7deeda2a79baf21b689fe32cd08 - Mon Aug 10 23:45:11 2020 +0000 : Deprecate filters that have been replaced by placement filters", "doc/source/admin/availability-zones.rst", "doc/source/admin/configuration/schedulers.rst", "nova/conf/scheduler.py", "nova/scheduler/filters/availability_zone_filter.py", "nova/tests/functional/test_aggregates.py", "releasenotes/notes/deprecate-AZ-filter-28406abc0135c1c3.yaml"]}, {"commit_id": "33c8af1f8c46c9c37fcc28fb3409fbd3a78ae39f", "commit_date": "Wed Mar 31 11:06:49 2021 -0300", "commit_message": "Error anti-affinity violation on migrations", "files_name": []}], "parents": [{"commit_id_before": "78a6a13f965d9ac75cb146336c7ba435e6d9a9e4", "url_before": "https://api.github.com/repos/openstack/nova/commits/78a6a13f965d9ac75cb146336c7ba435e6d9a9e4", "html_url_before": "https://github.com/openstack/nova/commit/78a6a13f965d9ac75cb146336c7ba435e6d9a9e4"}], "details": [{"raw_url": "https://github.com/openstack/nova/raw/781612b33282ed298f742c85dab58a075c8b793e/nova%2Fconsole%2Fwebsocketproxy.py", "code": "# Copyright (c) 2012 OpenStack Foundation\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n'''\nWebsocket proxy that is compatible with OpenStack Nova.\nLeverages websockify.py by Joel Martin\n'''\n\nimport copy\nfrom http import cookies as Cookie\nfrom http import HTTPStatus\nimport os\nimport socket\nfrom urllib import parse as urlparse\n\nfrom oslo_log import log as logging\nfrom oslo_utils import encodeutils\nfrom oslo_utils import importutils\nimport websockify\n\nfrom nova.compute import rpcapi as compute_rpcapi\nimport nova.conf\nfrom nova import context\nfrom nova import exception\nfrom nova.i18n import _\nfrom nova import objects\n\n# Location of WebSockifyServer class in websockify v0.9.0\nwebsockifyserver = importutils.try_import('websockify.websockifyserver')\n\nLOG = logging.getLogger(__name__)\n\nCONF = nova.conf.CONF\n\n\nclass TenantSock(object):\n    \"\"\"A socket wrapper for communicating with the tenant.\n\n    This class provides a socket-like interface to the internal\n    websockify send/receive queue for the client connection to\n    the tenant user. It is used with the security proxy classes.\n    \"\"\"\n\n    def __init__(self, reqhandler):\n        self.reqhandler = reqhandler\n        self.queue = []\n\n    def recv(self, cnt):\n        # NB(sross): it's ok to block here because we know\n        #            exactly the sequence of data arriving\n        while len(self.queue) < cnt:\n            # new_frames looks like ['abc', 'def']\n            new_frames, closed = self.reqhandler.recv_frames()\n            # flatten frames onto queue\n            for frame in new_frames:\n                self.queue.extend(\n                    [bytes(chr(c), 'ascii') for c in frame])\n\n            if closed:\n                break\n\n        popped = self.queue[0:cnt]\n        del self.queue[0:cnt]\n        return b''.join(popped)\n\n    def sendall(self, data):\n        self.reqhandler.send_frames([encodeutils.safe_encode(data)])\n\n    def finish_up(self):\n        self.reqhandler.send_frames([b''.join(self.queue)])\n\n    def close(self):\n        self.finish_up()\n        self.reqhandler.send_close()\n\n\nclass NovaProxyRequestHandler(websockify.ProxyRequestHandler):\n\n    def __init__(self, *args, **kwargs):\n        self._compute_rpcapi = None\n        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)\n\n    @property\n    def compute_rpcapi(self):\n        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.\n        # This way, if we receive a TCP RST, we will not create a ComputeAPI\n        # object we won't use.\n        if not self._compute_rpcapi:\n            self._compute_rpcapi = compute_rpcapi.ComputeAPI()\n        return self._compute_rpcapi\n\n    def verify_origin_proto(self, connect_info, origin_proto):\n        if 'access_url_base' not in connect_info:\n            detail = _(\"No access_url_base in connect_info. \"\n                       \"Cannot validate protocol\")\n            raise exception.ValidationError(detail=detail)\n\n        expected_protos = [\n            urlparse.urlparse(connect_info.access_url_base).scheme]\n        # NOTE: For serial consoles the expected protocol could be ws or\n        # wss which correspond to http and https respectively in terms of\n        # security.\n        if 'ws' in expected_protos:\n            expected_protos.append('http')\n        if 'wss' in expected_protos:\n            expected_protos.append('https')\n\n        return origin_proto in expected_protos\n\n    def _check_console_port(self, ctxt, instance_uuid, port, console_type):\n\n        try:\n            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)\n        except exception.InstanceNotFound:\n            return\n\n        # NOTE(melwitt): The port is expected to be a str for validation.\n        return self.compute_rpcapi.validate_console_port(ctxt, instance,\n                                                         str(port),\n                                                         console_type)\n\n    def _get_connect_info(self, ctxt, token):\n        \"\"\"Validate the token and get the connect info.\"\"\"\n        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.\n        # We call the compute manager directly to check the console port\n        # is correct.\n        connect_info = objects.ConsoleAuthToken.validate(ctxt, token)\n\n        valid_port = self._check_console_port(\n            ctxt, connect_info.instance_uuid, connect_info.port,\n            connect_info.console_type)\n\n        if not valid_port:\n            raise exception.InvalidToken(token='***')\n\n        return connect_info\n\n    def new_websocket_client(self):\n        \"\"\"Called after a new WebSocket connection has been established.\"\"\"\n        # Reopen the eventlet hub to make sure we don't share an epoll\n        # fd with parent and/or siblings, which would be bad\n        from eventlet import hubs\n        hubs.use_hub()\n\n        # The nova expected behavior is to have token\n        # passed to the method GET of the request\n        token = urlparse.parse_qs(\n            urlparse.urlparse(self.path).query\n        ).get('token', ['']).pop()\n        if not token:\n            # NoVNC uses it's own convention that forward token\n            # from the request to a cookie header, we should check\n            # also for this behavior\n            hcookie = self.headers.get('cookie')\n            if hcookie:\n                cookie = Cookie.SimpleCookie()\n                for hcookie_part in hcookie.split(';'):\n                    hcookie_part = hcookie_part.lstrip()\n                    try:\n                        cookie.load(hcookie_part)\n                    except Cookie.CookieError:\n                        # NOTE(stgleb): Do not print out cookie content\n                        # for security reasons.\n                        LOG.warning('Found malformed cookie')\n                    else:\n                        if 'token' in cookie:\n                            token = cookie['token'].value\n\n        ctxt = context.get_admin_context()\n        connect_info = self._get_connect_info(ctxt, token)\n\n        # Verify Origin\n        expected_origin_hostname = self.headers.get('Host')\n        if ':' in expected_origin_hostname:\n            e = expected_origin_hostname\n            if '[' in e and ']' in e:\n                expected_origin_hostname = e.split(']')[0][1:]\n            else:\n                expected_origin_hostname = e.split(':')[0]\n        expected_origin_hostnames = CONF.console.allowed_origins\n        expected_origin_hostnames.append(expected_origin_hostname)\n        origin_url = self.headers.get('Origin')\n        # missing origin header indicates non-browser client which is OK\n        if origin_url is not None:\n            origin = urlparse.urlparse(origin_url)\n            origin_hostname = origin.hostname\n            origin_scheme = origin.scheme\n            # If the console connection was forwarded by a proxy (example:\n            # haproxy), the original protocol could be contained in the\n            # X-Forwarded-Proto header instead of the Origin header. Prefer the\n            # forwarded protocol if it is present.\n            forwarded_proto = self.headers.get('X-Forwarded-Proto')\n            if forwarded_proto is not None:\n                origin_scheme = forwarded_proto\n            if origin_hostname == '' or origin_scheme == '':\n                detail = _(\"Origin header not valid.\")\n                raise exception.ValidationError(detail=detail)\n            if origin_hostname not in expected_origin_hostnames:\n                detail = _(\"Origin header does not match this host.\")\n                raise exception.ValidationError(detail=detail)\n            if not self.verify_origin_proto(connect_info, origin_scheme):\n                detail = _(\"Origin header protocol does not match this host.\")\n                raise exception.ValidationError(detail=detail)\n\n        sanitized_info = copy.copy(connect_info)\n        sanitized_info.token = '***'\n        self.msg(_('connect info: %s'), sanitized_info)\n\n        host = connect_info.host\n        port = connect_info.port\n\n        # Connect to the target\n        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,\n                                                          'port': port})\n        tsock = self.socket(host, port, connect=True)\n\n        # Handshake as necessary\n        if 'internal_access_path' in connect_info:\n            path = connect_info.internal_access_path\n            if path:\n                tsock.send(encodeutils.safe_encode(\n                    'CONNECT %s HTTP/1.1\\r\\n\\r\\n' % path))\n                end_token = \"\\r\\n\\r\\n\"\n                while True:\n                    data = tsock.recv(4096, socket.MSG_PEEK)\n                    token_loc = data.find(end_token)\n                    if token_loc != -1:\n                        if data.split(\"\\r\\n\")[0].find(\"200\") == -1:\n                            raise exception.InvalidConnectionInfo()\n                        # remove the response from recv buffer\n                        tsock.recv(token_loc + len(end_token))\n                        break\n\n        if self.server.security_proxy is not None:\n            tenant_sock = TenantSock(self)\n\n            try:\n                tsock = self.server.security_proxy.connect(tenant_sock, tsock)\n            except exception.SecurityProxyNegotiationFailed:\n                LOG.exception(\"Unable to perform security proxying, shutting \"\n                              \"down connection\")\n                tenant_sock.close()\n                tsock.shutdown(socket.SHUT_RDWR)\n                tsock.close()\n                raise\n\n            tenant_sock.finish_up()\n\n        # Start proxying\n        try:\n            self.do_proxy(tsock)\n        except Exception:\n            if tsock:\n                tsock.shutdown(socket.SHUT_RDWR)\n                tsock.close()\n                self.vmsg(_(\"%(host)s:%(port)s: \"\n                          \"Websocket client or target closed\") %\n                          {'host': host, 'port': port})\n            raise\n\n    def socket(self, *args, **kwargs):\n        return websockifyserver.WebSockifyServer.socket(*args, **kwargs)\n\n    def send_head(self):\n        # This code is copied from this example patch:\n        # https://bugs.python.org/issue32084#msg306545\n        path = self.translate_path(self.path)\n        if os.path.isdir(path):\n            parts = urlparse.urlsplit(self.path)\n            if not parts.path.endswith('/'):\n                # redirect browser - doing basically what apache does\n                new_parts = (parts[0], parts[1], parts[2] + '/',\n                              parts[3], parts[4])\n                new_url = urlparse.urlunsplit(new_parts)\n\n                # Browsers interpret \"Location: //uri\" as an absolute URI\n                # like \"http://URI\"\n                if new_url.startswith('//'):\n                    self.send_error(HTTPStatus.BAD_REQUEST,\n                                    \"URI must not start with //\")\n                    return None\n\n        return super(NovaProxyRequestHandler, self).send_head()\n\n\nclass NovaWebSocketProxy(websockify.WebSocketProxy):\n    def __init__(self, *args, **kwargs):\n        \"\"\":param security_proxy: instance of\n            nova.console.securityproxy.base.SecurityProxy\n\n        Create a new web socket proxy, optionally using the\n        @security_proxy instance to negotiate security layer\n        with the compute node.\n        \"\"\"\n        self.security_proxy = kwargs.pop('security_proxy', None)\n\n        # If 'default' was specified as the ssl_minimum_version, we leave\n        # ssl_options unset to default to the underlying system defaults.\n        # We do this to avoid using websockify's behaviour for 'default'\n        # in select_ssl_version(), which hardcodes the versions to be\n        # quite relaxed and prevents us from using sytem crypto policies.\n        ssl_min_version = kwargs.pop('ssl_minimum_version', None)\n        if ssl_min_version and ssl_min_version != 'default':\n            kwargs['ssl_options'] = websockify.websocketproxy. \\\n                                    select_ssl_version(ssl_min_version)\n\n        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)\n\n    @staticmethod\n    def get_logger():\n        return LOG\n", "code_before": "# Copyright (c) 2012 OpenStack Foundation\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n'''\nWebsocket proxy that is compatible with OpenStack Nova.\nLeverages websockify.py by Joel Martin\n'''\n\nimport copy\nfrom http import cookies as Cookie\nimport socket\nfrom urllib import parse as urlparse\n\nfrom oslo_log import log as logging\nfrom oslo_utils import encodeutils\nfrom oslo_utils import importutils\nimport websockify\n\nfrom nova.compute import rpcapi as compute_rpcapi\nimport nova.conf\nfrom nova import context\nfrom nova import exception\nfrom nova.i18n import _\nfrom nova import objects\n\n# Location of WebSockifyServer class in websockify v0.9.0\nwebsockifyserver = importutils.try_import('websockify.websockifyserver')\n\nLOG = logging.getLogger(__name__)\n\nCONF = nova.conf.CONF\n\n\nclass TenantSock(object):\n    \"\"\"A socket wrapper for communicating with the tenant.\n\n    This class provides a socket-like interface to the internal\n    websockify send/receive queue for the client connection to\n    the tenant user. It is used with the security proxy classes.\n    \"\"\"\n\n    def __init__(self, reqhandler):\n        self.reqhandler = reqhandler\n        self.queue = []\n\n    def recv(self, cnt):\n        # NB(sross): it's ok to block here because we know\n        #            exactly the sequence of data arriving\n        while len(self.queue) < cnt:\n            # new_frames looks like ['abc', 'def']\n            new_frames, closed = self.reqhandler.recv_frames()\n            # flatten frames onto queue\n            for frame in new_frames:\n                self.queue.extend(\n                    [bytes(chr(c), 'ascii') for c in frame])\n\n            if closed:\n                break\n\n        popped = self.queue[0:cnt]\n        del self.queue[0:cnt]\n        return b''.join(popped)\n\n    def sendall(self, data):\n        self.reqhandler.send_frames([encodeutils.safe_encode(data)])\n\n    def finish_up(self):\n        self.reqhandler.send_frames([b''.join(self.queue)])\n\n    def close(self):\n        self.finish_up()\n        self.reqhandler.send_close()\n\n\nclass NovaProxyRequestHandler(websockify.ProxyRequestHandler):\n\n    def __init__(self, *args, **kwargs):\n        self._compute_rpcapi = None\n        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)\n\n    @property\n    def compute_rpcapi(self):\n        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.\n        # This way, if we receive a TCP RST, we will not create a ComputeAPI\n        # object we won't use.\n        if not self._compute_rpcapi:\n            self._compute_rpcapi = compute_rpcapi.ComputeAPI()\n        return self._compute_rpcapi\n\n    def verify_origin_proto(self, connect_info, origin_proto):\n        if 'access_url_base' not in connect_info:\n            detail = _(\"No access_url_base in connect_info. \"\n                       \"Cannot validate protocol\")\n            raise exception.ValidationError(detail=detail)\n\n        expected_protos = [\n            urlparse.urlparse(connect_info.access_url_base).scheme]\n        # NOTE: For serial consoles the expected protocol could be ws or\n        # wss which correspond to http and https respectively in terms of\n        # security.\n        if 'ws' in expected_protos:\n            expected_protos.append('http')\n        if 'wss' in expected_protos:\n            expected_protos.append('https')\n\n        return origin_proto in expected_protos\n\n    def _check_console_port(self, ctxt, instance_uuid, port, console_type):\n\n        try:\n            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)\n        except exception.InstanceNotFound:\n            return\n\n        # NOTE(melwitt): The port is expected to be a str for validation.\n        return self.compute_rpcapi.validate_console_port(ctxt, instance,\n                                                         str(port),\n                                                         console_type)\n\n    def _get_connect_info(self, ctxt, token):\n        \"\"\"Validate the token and get the connect info.\"\"\"\n        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.\n        # We call the compute manager directly to check the console port\n        # is correct.\n        connect_info = objects.ConsoleAuthToken.validate(ctxt, token)\n\n        valid_port = self._check_console_port(\n            ctxt, connect_info.instance_uuid, connect_info.port,\n            connect_info.console_type)\n\n        if not valid_port:\n            raise exception.InvalidToken(token='***')\n\n        return connect_info\n\n    def new_websocket_client(self):\n        \"\"\"Called after a new WebSocket connection has been established.\"\"\"\n        # Reopen the eventlet hub to make sure we don't share an epoll\n        # fd with parent and/or siblings, which would be bad\n        from eventlet import hubs\n        hubs.use_hub()\n\n        # The nova expected behavior is to have token\n        # passed to the method GET of the request\n        token = urlparse.parse_qs(\n            urlparse.urlparse(self.path).query\n        ).get('token', ['']).pop()\n        if not token:\n            # NoVNC uses it's own convention that forward token\n            # from the request to a cookie header, we should check\n            # also for this behavior\n            hcookie = self.headers.get('cookie')\n            if hcookie:\n                cookie = Cookie.SimpleCookie()\n                for hcookie_part in hcookie.split(';'):\n                    hcookie_part = hcookie_part.lstrip()\n                    try:\n                        cookie.load(hcookie_part)\n                    except Cookie.CookieError:\n                        # NOTE(stgleb): Do not print out cookie content\n                        # for security reasons.\n                        LOG.warning('Found malformed cookie')\n                    else:\n                        if 'token' in cookie:\n                            token = cookie['token'].value\n\n        ctxt = context.get_admin_context()\n        connect_info = self._get_connect_info(ctxt, token)\n\n        # Verify Origin\n        expected_origin_hostname = self.headers.get('Host')\n        if ':' in expected_origin_hostname:\n            e = expected_origin_hostname\n            if '[' in e and ']' in e:\n                expected_origin_hostname = e.split(']')[0][1:]\n            else:\n                expected_origin_hostname = e.split(':')[0]\n        expected_origin_hostnames = CONF.console.allowed_origins\n        expected_origin_hostnames.append(expected_origin_hostname)\n        origin_url = self.headers.get('Origin')\n        # missing origin header indicates non-browser client which is OK\n        if origin_url is not None:\n            origin = urlparse.urlparse(origin_url)\n            origin_hostname = origin.hostname\n            origin_scheme = origin.scheme\n            # If the console connection was forwarded by a proxy (example:\n            # haproxy), the original protocol could be contained in the\n            # X-Forwarded-Proto header instead of the Origin header. Prefer the\n            # forwarded protocol if it is present.\n            forwarded_proto = self.headers.get('X-Forwarded-Proto')\n            if forwarded_proto is not None:\n                origin_scheme = forwarded_proto\n            if origin_hostname == '' or origin_scheme == '':\n                detail = _(\"Origin header not valid.\")\n                raise exception.ValidationError(detail=detail)\n            if origin_hostname not in expected_origin_hostnames:\n                detail = _(\"Origin header does not match this host.\")\n                raise exception.ValidationError(detail=detail)\n            if not self.verify_origin_proto(connect_info, origin_scheme):\n                detail = _(\"Origin header protocol does not match this host.\")\n                raise exception.ValidationError(detail=detail)\n\n        sanitized_info = copy.copy(connect_info)\n        sanitized_info.token = '***'\n        self.msg(_('connect info: %s'), sanitized_info)\n\n        host = connect_info.host\n        port = connect_info.port\n\n        # Connect to the target\n        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,\n                                                          'port': port})\n        tsock = self.socket(host, port, connect=True)\n\n        # Handshake as necessary\n        if 'internal_access_path' in connect_info:\n            path = connect_info.internal_access_path\n            if path:\n                tsock.send(encodeutils.safe_encode(\n                    'CONNECT %s HTTP/1.1\\r\\n\\r\\n' % path))\n                end_token = \"\\r\\n\\r\\n\"\n                while True:\n                    data = tsock.recv(4096, socket.MSG_PEEK)\n                    token_loc = data.find(end_token)\n                    if token_loc != -1:\n                        if data.split(\"\\r\\n\")[0].find(\"200\") == -1:\n                            raise exception.InvalidConnectionInfo()\n                        # remove the response from recv buffer\n                        tsock.recv(token_loc + len(end_token))\n                        break\n\n        if self.server.security_proxy is not None:\n            tenant_sock = TenantSock(self)\n\n            try:\n                tsock = self.server.security_proxy.connect(tenant_sock, tsock)\n            except exception.SecurityProxyNegotiationFailed:\n                LOG.exception(\"Unable to perform security proxying, shutting \"\n                              \"down connection\")\n                tenant_sock.close()\n                tsock.shutdown(socket.SHUT_RDWR)\n                tsock.close()\n                raise\n\n            tenant_sock.finish_up()\n\n        # Start proxying\n        try:\n            self.do_proxy(tsock)\n        except Exception:\n            if tsock:\n                tsock.shutdown(socket.SHUT_RDWR)\n                tsock.close()\n                self.vmsg(_(\"%(host)s:%(port)s: \"\n                          \"Websocket client or target closed\") %\n                          {'host': host, 'port': port})\n            raise\n\n    def socket(self, *args, **kwargs):\n        return websockifyserver.WebSockifyServer.socket(*args, **kwargs)\n\n\nclass NovaWebSocketProxy(websockify.WebSocketProxy):\n    def __init__(self, *args, **kwargs):\n        \"\"\":param security_proxy: instance of\n            nova.console.securityproxy.base.SecurityProxy\n\n        Create a new web socket proxy, optionally using the\n        @security_proxy instance to negotiate security layer\n        with the compute node.\n        \"\"\"\n        self.security_proxy = kwargs.pop('security_proxy', None)\n\n        # If 'default' was specified as the ssl_minimum_version, we leave\n        # ssl_options unset to default to the underlying system defaults.\n        # We do this to avoid using websockify's behaviour for 'default'\n        # in select_ssl_version(), which hardcodes the versions to be\n        # quite relaxed and prevents us from using sytem crypto policies.\n        ssl_min_version = kwargs.pop('ssl_minimum_version', None)\n        if ssl_min_version and ssl_min_version != 'default':\n            kwargs['ssl_options'] = websockify.websocketproxy. \\\n                                    select_ssl_version(ssl_min_version)\n\n        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)\n\n    @staticmethod\n    def get_logger():\n        return LOG\n", "patch": "@@ -20,6 +20,8 @@\n \n import copy\n from http import cookies as Cookie\n+from http import HTTPStatus\n+import os\n import socket\n from urllib import parse as urlparse\n \n@@ -271,6 +273,27 @@ def new_websocket_client(self):\n     def socket(self, *args, **kwargs):\n         return websockifyserver.WebSockifyServer.socket(*args, **kwargs)\n \n+    def send_head(self):\n+        # This code is copied from this example patch:\n+        # https://bugs.python.org/issue32084#msg306545\n+        path = self.translate_path(self.path)\n+        if os.path.isdir(path):\n+            parts = urlparse.urlsplit(self.path)\n+            if not parts.path.endswith('/'):\n+                # redirect browser - doing basically what apache does\n+                new_parts = (parts[0], parts[1], parts[2] + '/',\n+                              parts[3], parts[4])\n+                new_url = urlparse.urlunsplit(new_parts)\n+\n+                # Browsers interpret \"Location: //uri\" as an absolute URI\n+                # like \"http://URI\"\n+                if new_url.startswith('//'):\n+                    self.send_error(HTTPStatus.BAD_REQUEST,\n+                                    \"URI must not start with //\")\n+                    return None\n+\n+        return super(NovaProxyRequestHandler, self).send_head()\n+\n \n class NovaWebSocketProxy(websockify.WebSocketProxy):\n     def __init__(self, *args, **kwargs):", "file_path": "files/2022_3/1008", "file_language": "py", "file_name": "nova/console/websocketproxy.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/openstack/nova/raw/781612b33282ed298f742c85dab58a075c8b793e/nova%2Ftests%2Funit%2Fconsole%2Ftest_websocketproxy.py", "code": "# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Tests for nova websocketproxy.\"\"\"\n\nimport copy\nimport socket\n\nimport mock\nfrom oslo_utils.fixture import uuidsentinel as uuids\n\nimport nova.conf\nfrom nova.console.securityproxy import base\nfrom nova.console import websocketproxy\nfrom nova import context as nova_context\nfrom nova import exception\nfrom nova import objects\nfrom nova import test\nfrom nova.tests.unit import fake_console_auth_token as fake_ca\nfrom nova import utils\n\nCONF = nova.conf.CONF\n\n\nclass NovaProxyRequestHandlerDBTestCase(test.TestCase):\n\n    def setUp(self):\n        super(NovaProxyRequestHandlerDBTestCase, self).setUp()\n\n        self.flags(console_allowed_origins=['allowed-origin-example-1.net',\n                                            'allowed-origin-example-2.net'])\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = websocketproxy.NovaWebSocketProxy()\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n    def _fake_console_db(self, **updates):\n        console_db = copy.deepcopy(fake_ca.fake_token_dict)\n        console_db['token_hash'] = utils.get_sha256_str('123-456-789')\n        if updates:\n            console_db.update(updates)\n        return console_db\n\n    fake_header = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    def test_new_websocket_client_db(\n            self, mock_validate_port, mock_inst_get, mock_validate,\n            internal_access_path=None,\n            instance_not_found=False):\n\n        db_obj = self._fake_console_db(\n            host='node1',\n            port=10000,\n            console_type='novnc',\n            access_url_base='https://example.net:6080',\n            internal_access_path=internal_access_path,\n            instance_uuid=uuids.instance,\n            # This is set by ConsoleAuthToken.validate\n            token='123-456-789'\n        )\n        ctxt = nova_context.get_context()\n        obj = nova.objects.ConsoleAuthToken._from_db_object(\n            ctxt, nova.objects.ConsoleAuthToken(), db_obj)\n        mock_validate.return_value = obj\n\n        if instance_not_found:\n            mock_inst_get.side_effect = exception.InstanceNotFound(\n                instance_id=uuids.instance)\n\n        if internal_access_path is None:\n            self.wh.socket.return_value = '<socket>'\n        else:\n            tsock = mock.MagicMock()\n            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n            self.wh.socket.return_value = tsock\n\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        if instance_not_found:\n            self.assertRaises(exception.InvalidToken,\n                              self.wh.new_websocket_client)\n        else:\n            with mock.patch('nova.context.get_admin_context',\n                            return_value=ctxt):\n                self.wh.new_websocket_client()\n\n            mock_validate.assert_called_once_with(ctxt, '123-456-789')\n            mock_validate_port.assert_called_once_with(\n                ctxt, mock_inst_get.return_value, str(db_obj['port']),\n                db_obj['console_type'])\n\n            self.wh.socket.assert_called_with('node1', 10000, connect=True)\n\n            if internal_access_path is None:\n                self.wh.do_proxy.assert_called_with('<socket>')\n            else:\n                self.wh.do_proxy.assert_called_with(tsock)\n\n    def test_new_websocket_client_db_internal_access_path(self):\n        self.test_new_websocket_client_db(internal_access_path='vmid')\n\n    def test_new_websocket_client_db_instance_not_found(self):\n        self.test_new_websocket_client_db(instance_not_found=True)\n\n\nclass NovaProxyRequestHandlerTestCase(test.NoDBTestCase):\n\n    def setUp(self):\n        super(NovaProxyRequestHandlerTestCase, self).setUp()\n\n        self.flags(allowed_origins=['allowed-origin-example-1.net',\n                                    'allowed-origin-example-2.net'],\n                   group='console')\n        self.server = websocketproxy.NovaWebSocketProxy()\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = self.server\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n    fake_header = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_ipv6 = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://[2001:db8::1]:6080',\n        'Host': '[2001:db8::1]:6080',\n    }\n\n    fake_header_bad_token = {\n        'cookie': 'token=\"XXX\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_bad_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://bad-origin-example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_allowed_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://allowed-origin-example-2.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_blank_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': '',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_no_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_http = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'http://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_malformed_cookie = {\n        'cookie': '?=!; token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n        # ensure that token is masked when logged\n        connection_info = self.wh.msg.mock_calls[0][1][1]\n        self.assertEqual('***', connection_info.token)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_ipv6_url(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://[2001:db8::1]:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"\n        self.wh.headers = self.fake_header_ipv6\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_token_invalid(self, validate):\n        validate.side_effect = exception.InvalidToken(token='XXX')\n\n        self.wh.path = \"http://127.0.0.1/?token=XXX\"\n        self.wh.headers = self.fake_header_bad_token\n\n        self.assertRaises(exception.InvalidToken,\n                          self.wh.new_websocket_client)\n        validate.assert_called_with(mock.ANY, \"XXX\")\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path(self, validate,\n                                                       check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'vmid',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        tsock.send.assert_called_with(test.MatchType(bytes))\n        self.wh.do_proxy.assert_called_with(tsock)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path_err(self, validate,\n                                                           check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'xxx',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.InvalidConnectionInfo,\n                          self.wh.new_websocket_client)\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path_rfb(self, validate,\n                                                           check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'vmid',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n        RFB_MSG = \"RFB 003.003\\n\"\n        # RFB negotiation message may arrive earlier.\n        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,\n                                  HTTP_RESP]\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),\n                                     mock.call(len(HTTP_RESP))])\n        self.wh.do_proxy.assert_called_with(tsock)\n\n    @mock.patch('socket.getfqdn')\n    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):\n        request_mock = mock.MagicMock()\n        request_mock.makefile().readline.side_effect = [\n            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',\n            b''\n        ]\n        server_mock = mock.MagicMock()\n        client_address = ('8.8.8.8', 54321)\n\n        handler = websocketproxy.NovaProxyRequestHandler(\n            request_mock, client_address, server_mock)\n        handler.log_message('log message using client address context info')\n\n        self.assertFalse(getfqdn.called)  # no reverse dns look up\n        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_bad_origin_header(self, validate,\n                                                          check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_bad_origin\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,\n                                                              check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_allowed_origin\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_blank_origin_header(self, validate,\n                                                            check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_blank_origin\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_no_origin_header(self, validate,\n                                                         check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_no_origin\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_https_origin_proto_http(\n            self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'http://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,\n                                                              check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'serial',\n            'access_url_base': 'ws://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_http_forwarded_proto_https(self, validate,\n                                                             check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'serial',\n            'access_url_base': 'wss://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        header = {\n            'cookie': 'token=\"123-456-789\"',\n            'Origin': 'http://example.net:6080',\n            'Host': 'example.net:6080',\n            'X-Forwarded-Proto': 'https'\n        }\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_bad_console_type(self, validate,\n                                                         check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'bad-console-type'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_malformed_cookie(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_malformed_cookie\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    def test_reject_open_redirect(self):\n        # This will test the behavior when an attempt is made to cause an open\n        # redirect. It should be rejected.\n        mock_req = mock.MagicMock()\n        mock_req.makefile().readline.side_effect = [\n            b'GET //example.com/%2F.. HTTP/1.1\\r\\n',\n            b''\n        ]\n\n        # Collect the response data to verify at the end. The\n        # SimpleHTTPRequestHandler writes the response data by calling the\n        # request socket sendall() method.\n        self.data = b''\n\n        def fake_sendall(data):\n            self.data += data\n\n        mock_req.sendall.side_effect = fake_sendall\n\n        client_addr = ('8.8.8.8', 54321)\n        mock_server = mock.MagicMock()\n        # This specifies that the server will be able to handle requests other\n        # than only websockets.\n        mock_server.only_upgrade = False\n\n        # Constructing a handler will process the mock_req request passed in.\n        websocketproxy.NovaProxyRequestHandler(\n            mock_req, client_addr, mock_server)\n\n        # Verify no redirect happens and instead a 400 Bad Request is returned.\n        self.data = self.data.decode()\n        self.assertIn('Error code: 400', self.data)\n        self.assertIn('Message: URI must not start with //', self.data)\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_no_compute_rpcapi_with_invalid_token(self, mock_validate):\n        \"\"\"Tests that we don't create a ComputeAPI object until we actually\n        need to use it to call the internal compute RPC API after token\n        validation succeeds. This way, we will not perform expensive object\n        creations when we receive unauthenticated (via token) messages. In the\n        past, it was possible for unauthenticated requests such as TCP RST or\n        requests with invalid tokens to be used to DOS the console proxy\n        service.\n        \"\"\"\n        # We will simulate a request with an invalid token and verify it\n        # will not trigger a ComputeAPI object creation.\n        mock_req = mock.MagicMock()\n        mock_req.makefile().readline.side_effect = [\n            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',\n            b''\n        ]\n        client_addr = ('8.8.8.8', 54321)\n        mock_server = mock.MagicMock()\n        handler = websocketproxy.NovaProxyRequestHandler(\n            mock_req, client_addr, mock_server)\n        # Internal ComputeAPI reference should be None when the request handler\n        # is initially created.\n        self.assertIsNone(handler._compute_rpcapi)\n        # Set up a token validation to fail when the new_websocket_client\n        # is called to handle the request.\n        mock_validate.side_effect = exception.InvalidToken(token='123-456-789')\n        # We expect InvalidToken to be raised during handling.\n        self.assertRaises(exception.InvalidToken, handler.new_websocket_client)\n        # And our internal ComputeAPI reference should still be None.\n        self.assertIsNone(handler._compute_rpcapi)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_ssl_min_version_is_not_set(self, mock_select_ssl):\n        websocketproxy.NovaWebSocketProxy()\n        self.assertFalse(mock_select_ssl.called)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_ssl_min_version_not_set_by_default(self, mock_select_ssl):\n        websocketproxy.NovaWebSocketProxy(ssl_minimum_version='default')\n        self.assertFalse(mock_select_ssl.called)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_non_default_ssl_min_version_is_set(self, mock_select_ssl):\n        minver = 'tlsv1_3'\n        websocketproxy.NovaWebSocketProxy(ssl_minimum_version=minver)\n        mock_select_ssl.assert_called_once_with(minver)\n\n\nclass NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):\n\n    def setUp(self):\n        super(NovaWebsocketSecurityProxyTestCase, self).setUp()\n\n        self.flags(allowed_origins=['allowed-origin-example-1.net',\n                                    'allowed-origin-example-2.net'],\n                   group='console')\n\n        self.server = websocketproxy.NovaWebSocketProxy(\n            security_proxy=mock.MagicMock(\n                spec=base.SecurityProxy)\n        )\n\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = self.server\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n        def get_header(header):\n            if header == 'cookie':\n                return 'token=\"123-456-789\"'\n            elif header == 'Origin':\n                return 'https://example.net:6080'\n            elif header == 'Host':\n                return 'example.net:6080'\n            else:\n                return\n\n        self.wh.headers.get = get_header\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    @mock.patch('nova.console.websocketproxy.TenantSock.close')\n    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')\n    def test_proxy_connect_ok(self, mock_finish, mock_close,\n                              mock_port_validate, mock_get,\n                              mock_token_validate):\n        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(\n            instance_uuid=uuids.instance, host='node1', port='10000',\n            console_type='novnc', access_url_base='https://example.net:6080')\n        # The token and id attributes are set by the validate() method.\n        mock_token_validate.return_value.token = '123-456-789'\n        mock_token_validate.return_value.id = 1\n\n        sock = mock.MagicMock(\n            spec=websocketproxy.TenantSock)\n        self.server.security_proxy.connect.return_value = sock\n\n        self.wh.new_websocket_client()\n\n        self.wh.do_proxy.assert_called_with(sock)\n        mock_finish.assert_called_with()\n        self.assertEqual(len(mock_close.calls), 0)\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    @mock.patch('nova.console.websocketproxy.TenantSock.close')\n    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')\n    def test_proxy_connect_err(self, mock_finish, mock_close,\n                               mock_port_validate, mock_get,\n                               mock_token_validate):\n        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(\n            instance_uuid=uuids.instance, host='node1', port='10000',\n            console_type='novnc', access_url_base='https://example.net:6080')\n        # The token attribute is set by the validate() method.\n        mock_token_validate.return_value.token = '123-456-789'\n        mock_token_validate.return_value.id = 1\n\n        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")\n        self.server.security_proxy.connect.side_effect = ex\n\n        self.assertRaises(exception.SecurityProxyNegotiationFailed,\n                          self.wh.new_websocket_client)\n\n        self.assertEqual(len(self.wh.do_proxy.calls), 0)\n        mock_close.assert_called_with()\n        self.assertEqual(len(mock_finish.calls), 0)\n", "code_before": "# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Tests for nova websocketproxy.\"\"\"\n\nimport copy\nimport socket\n\nimport mock\nfrom oslo_utils.fixture import uuidsentinel as uuids\n\nimport nova.conf\nfrom nova.console.securityproxy import base\nfrom nova.console import websocketproxy\nfrom nova import context as nova_context\nfrom nova import exception\nfrom nova import objects\nfrom nova import test\nfrom nova.tests.unit import fake_console_auth_token as fake_ca\nfrom nova import utils\n\nCONF = nova.conf.CONF\n\n\nclass NovaProxyRequestHandlerDBTestCase(test.TestCase):\n\n    def setUp(self):\n        super(NovaProxyRequestHandlerDBTestCase, self).setUp()\n\n        self.flags(console_allowed_origins=['allowed-origin-example-1.net',\n                                            'allowed-origin-example-2.net'])\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = websocketproxy.NovaWebSocketProxy()\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n    def _fake_console_db(self, **updates):\n        console_db = copy.deepcopy(fake_ca.fake_token_dict)\n        console_db['token_hash'] = utils.get_sha256_str('123-456-789')\n        if updates:\n            console_db.update(updates)\n        return console_db\n\n    fake_header = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    def test_new_websocket_client_db(\n            self, mock_validate_port, mock_inst_get, mock_validate,\n            internal_access_path=None,\n            instance_not_found=False):\n\n        db_obj = self._fake_console_db(\n            host='node1',\n            port=10000,\n            console_type='novnc',\n            access_url_base='https://example.net:6080',\n            internal_access_path=internal_access_path,\n            instance_uuid=uuids.instance,\n            # This is set by ConsoleAuthToken.validate\n            token='123-456-789'\n        )\n        ctxt = nova_context.get_context()\n        obj = nova.objects.ConsoleAuthToken._from_db_object(\n            ctxt, nova.objects.ConsoleAuthToken(), db_obj)\n        mock_validate.return_value = obj\n\n        if instance_not_found:\n            mock_inst_get.side_effect = exception.InstanceNotFound(\n                instance_id=uuids.instance)\n\n        if internal_access_path is None:\n            self.wh.socket.return_value = '<socket>'\n        else:\n            tsock = mock.MagicMock()\n            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n            self.wh.socket.return_value = tsock\n\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        if instance_not_found:\n            self.assertRaises(exception.InvalidToken,\n                              self.wh.new_websocket_client)\n        else:\n            with mock.patch('nova.context.get_admin_context',\n                            return_value=ctxt):\n                self.wh.new_websocket_client()\n\n            mock_validate.assert_called_once_with(ctxt, '123-456-789')\n            mock_validate_port.assert_called_once_with(\n                ctxt, mock_inst_get.return_value, str(db_obj['port']),\n                db_obj['console_type'])\n\n            self.wh.socket.assert_called_with('node1', 10000, connect=True)\n\n            if internal_access_path is None:\n                self.wh.do_proxy.assert_called_with('<socket>')\n            else:\n                self.wh.do_proxy.assert_called_with(tsock)\n\n    def test_new_websocket_client_db_internal_access_path(self):\n        self.test_new_websocket_client_db(internal_access_path='vmid')\n\n    def test_new_websocket_client_db_instance_not_found(self):\n        self.test_new_websocket_client_db(instance_not_found=True)\n\n\nclass NovaProxyRequestHandlerTestCase(test.NoDBTestCase):\n\n    def setUp(self):\n        super(NovaProxyRequestHandlerTestCase, self).setUp()\n\n        self.flags(allowed_origins=['allowed-origin-example-1.net',\n                                    'allowed-origin-example-2.net'],\n                   group='console')\n        self.server = websocketproxy.NovaWebSocketProxy()\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = self.server\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n    fake_header = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_ipv6 = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://[2001:db8::1]:6080',\n        'Host': '[2001:db8::1]:6080',\n    }\n\n    fake_header_bad_token = {\n        'cookie': 'token=\"XXX\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_bad_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://bad-origin-example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_allowed_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'https://allowed-origin-example-2.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_blank_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': '',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_no_origin = {\n        'cookie': 'token=\"123-456-789\"',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_http = {\n        'cookie': 'token=\"123-456-789\"',\n        'Origin': 'http://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    fake_header_malformed_cookie = {\n        'cookie': '?=!; token=\"123-456-789\"',\n        'Origin': 'https://example.net:6080',\n        'Host': 'example.net:6080',\n    }\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n        # ensure that token is masked when logged\n        connection_info = self.wh.msg.mock_calls[0][1][1]\n        self.assertEqual('***', connection_info.token)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_ipv6_url(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://[2001:db8::1]:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"\n        self.wh.headers = self.fake_header_ipv6\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_token_invalid(self, validate):\n        validate.side_effect = exception.InvalidToken(token='XXX')\n\n        self.wh.path = \"http://127.0.0.1/?token=XXX\"\n        self.wh.headers = self.fake_header_bad_token\n\n        self.assertRaises(exception.InvalidToken,\n                          self.wh.new_websocket_client)\n        validate.assert_called_with(mock.ANY, \"XXX\")\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path(self, validate,\n                                                       check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'vmid',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        tsock.send.assert_called_with(test.MatchType(bytes))\n        self.wh.do_proxy.assert_called_with(tsock)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path_err(self, validate,\n                                                           check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'xxx',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.InvalidConnectionInfo,\n                          self.wh.new_websocket_client)\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_internal_access_path_rfb(self, validate,\n                                                           check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'internal_access_path': 'vmid',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        tsock = mock.MagicMock()\n        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"\n        RFB_MSG = \"RFB 003.003\\n\"\n        # RFB negotiation message may arrive earlier.\n        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,\n                                  HTTP_RESP]\n\n        self.wh.socket.return_value = tsock\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.headers = self.fake_header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),\n                                     mock.call(len(HTTP_RESP))])\n        self.wh.do_proxy.assert_called_with(tsock)\n\n    @mock.patch('socket.getfqdn')\n    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):\n        request_mock = mock.MagicMock()\n        request_mock.makefile().readline.side_effect = [\n            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',\n            b''\n        ]\n        server_mock = mock.MagicMock()\n        client_address = ('8.8.8.8', 54321)\n\n        handler = websocketproxy.NovaProxyRequestHandler(\n            request_mock, client_address, server_mock)\n        handler.log_message('log message using client address context info')\n\n        self.assertFalse(getfqdn.called)  # no reverse dns look up\n        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_bad_origin_header(self, validate,\n                                                          check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_bad_origin\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,\n                                                              check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_allowed_origin\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_blank_origin_header(self, validate,\n                                                            check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_blank_origin\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_no_origin_header(self, validate,\n                                                         check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_no_origin\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_https_origin_proto_http(\n            self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'http://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,\n                                                              check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'serial',\n            'access_url_base': 'ws://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_http_forwarded_proto_https(self, validate,\n                                                             check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'serial',\n            'access_url_base': 'wss://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        header = {\n            'cookie': 'token=\"123-456-789\"',\n            'Origin': 'http://example.net:6080',\n            'Host': 'example.net:6080',\n            'X-Forwarded-Proto': 'https'\n        }\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"https://127.0.0.1/\"\n        self.wh.headers = header\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_new_websocket_client_novnc_bad_console_type(self, validate,\n                                                         check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'bad-console-type'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header\n\n        self.assertRaises(exception.ValidationError,\n                          self.wh.new_websocket_client)\n\n    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandler.'\n                '_check_console_port')\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_malformed_cookie(self, validate, check_port):\n        params = {\n            'id': 1,\n            'token': '123-456-789',\n            'instance_uuid': uuids.instance,\n            'host': 'node1',\n            'port': '10000',\n            'console_type': 'novnc',\n            'access_url_base': 'https://example.net:6080'\n        }\n        validate.return_value = objects.ConsoleAuthToken(**params)\n\n        self.wh.socket.return_value = '<socket>'\n        self.wh.path = \"http://127.0.0.1/\"\n        self.wh.headers = self.fake_header_malformed_cookie\n\n        self.wh.new_websocket_client()\n\n        validate.assert_called_with(mock.ANY, \"123-456-789\")\n        self.wh.socket.assert_called_with('node1', 10000, connect=True)\n        self.wh.do_proxy.assert_called_with('<socket>')\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    def test_no_compute_rpcapi_with_invalid_token(self, mock_validate):\n        \"\"\"Tests that we don't create a ComputeAPI object until we actually\n        need to use it to call the internal compute RPC API after token\n        validation succeeds. This way, we will not perform expensive object\n        creations when we receive unauthenticated (via token) messages. In the\n        past, it was possible for unauthenticated requests such as TCP RST or\n        requests with invalid tokens to be used to DOS the console proxy\n        service.\n        \"\"\"\n        # We will simulate a request with an invalid token and verify it\n        # will not trigger a ComputeAPI object creation.\n        mock_req = mock.MagicMock()\n        mock_req.makefile().readline.side_effect = [\n            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',\n            b''\n        ]\n        client_addr = ('8.8.8.8', 54321)\n        mock_server = mock.MagicMock()\n        handler = websocketproxy.NovaProxyRequestHandler(\n            mock_req, client_addr, mock_server)\n        # Internal ComputeAPI reference should be None when the request handler\n        # is initially created.\n        self.assertIsNone(handler._compute_rpcapi)\n        # Set up a token validation to fail when the new_websocket_client\n        # is called to handle the request.\n        mock_validate.side_effect = exception.InvalidToken(token='123-456-789')\n        # We expect InvalidToken to be raised during handling.\n        self.assertRaises(exception.InvalidToken, handler.new_websocket_client)\n        # And our internal ComputeAPI reference should still be None.\n        self.assertIsNone(handler._compute_rpcapi)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_ssl_min_version_is_not_set(self, mock_select_ssl):\n        websocketproxy.NovaWebSocketProxy()\n        self.assertFalse(mock_select_ssl.called)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_ssl_min_version_not_set_by_default(self, mock_select_ssl):\n        websocketproxy.NovaWebSocketProxy(ssl_minimum_version='default')\n        self.assertFalse(mock_select_ssl.called)\n\n    @mock.patch('websockify.websocketproxy.select_ssl_version')\n    def test_non_default_ssl_min_version_is_set(self, mock_select_ssl):\n        minver = 'tlsv1_3'\n        websocketproxy.NovaWebSocketProxy(ssl_minimum_version=minver)\n        mock_select_ssl.assert_called_once_with(minver)\n\n\nclass NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):\n\n    def setUp(self):\n        super(NovaWebsocketSecurityProxyTestCase, self).setUp()\n\n        self.flags(allowed_origins=['allowed-origin-example-1.net',\n                                    'allowed-origin-example-2.net'],\n                   group='console')\n\n        self.server = websocketproxy.NovaWebSocketProxy(\n            security_proxy=mock.MagicMock(\n                spec=base.SecurityProxy)\n        )\n\n        with mock.patch('websockify.ProxyRequestHandler'):\n            self.wh = websocketproxy.NovaProxyRequestHandler()\n        self.wh.server = self.server\n        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"\n        self.wh.socket = mock.MagicMock()\n        self.wh.msg = mock.MagicMock()\n        self.wh.do_proxy = mock.MagicMock()\n        self.wh.headers = mock.MagicMock()\n\n        def get_header(header):\n            if header == 'cookie':\n                return 'token=\"123-456-789\"'\n            elif header == 'Origin':\n                return 'https://example.net:6080'\n            elif header == 'Host':\n                return 'example.net:6080'\n            else:\n                return\n\n        self.wh.headers.get = get_header\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    @mock.patch('nova.console.websocketproxy.TenantSock.close')\n    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')\n    def test_proxy_connect_ok(self, mock_finish, mock_close,\n                              mock_port_validate, mock_get,\n                              mock_token_validate):\n        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(\n            instance_uuid=uuids.instance, host='node1', port='10000',\n            console_type='novnc', access_url_base='https://example.net:6080')\n        # The token and id attributes are set by the validate() method.\n        mock_token_validate.return_value.token = '123-456-789'\n        mock_token_validate.return_value.id = 1\n\n        sock = mock.MagicMock(\n            spec=websocketproxy.TenantSock)\n        self.server.security_proxy.connect.return_value = sock\n\n        self.wh.new_websocket_client()\n\n        self.wh.do_proxy.assert_called_with(sock)\n        mock_finish.assert_called_with()\n        self.assertEqual(len(mock_close.calls), 0)\n\n    @mock.patch('nova.objects.ConsoleAuthToken.validate')\n    @mock.patch('nova.objects.Instance.get_by_uuid')\n    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')\n    @mock.patch('nova.console.websocketproxy.TenantSock.close')\n    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')\n    def test_proxy_connect_err(self, mock_finish, mock_close,\n                               mock_port_validate, mock_get,\n                               mock_token_validate):\n        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(\n            instance_uuid=uuids.instance, host='node1', port='10000',\n            console_type='novnc', access_url_base='https://example.net:6080')\n        # The token attribute is set by the validate() method.\n        mock_token_validate.return_value.token = '123-456-789'\n        mock_token_validate.return_value.id = 1\n\n        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")\n        self.server.security_proxy.connect.side_effect = ex\n\n        self.assertRaises(exception.SecurityProxyNegotiationFailed,\n                          self.wh.new_websocket_client)\n\n        self.assertEqual(len(self.wh.do_proxy.calls), 0)\n        mock_close.assert_called_with()\n        self.assertEqual(len(mock_finish.calls), 0)\n", "patch": "@@ -588,6 +588,40 @@ def test_malformed_cookie(self, validate, check_port):\n         self.wh.socket.assert_called_with('node1', 10000, connect=True)\n         self.wh.do_proxy.assert_called_with('<socket>')\n \n+    def test_reject_open_redirect(self):\n+        # This will test the behavior when an attempt is made to cause an open\n+        # redirect. It should be rejected.\n+        mock_req = mock.MagicMock()\n+        mock_req.makefile().readline.side_effect = [\n+            b'GET //example.com/%2F.. HTTP/1.1\\r\\n',\n+            b''\n+        ]\n+\n+        # Collect the response data to verify at the end. The\n+        # SimpleHTTPRequestHandler writes the response data by calling the\n+        # request socket sendall() method.\n+        self.data = b''\n+\n+        def fake_sendall(data):\n+            self.data += data\n+\n+        mock_req.sendall.side_effect = fake_sendall\n+\n+        client_addr = ('8.8.8.8', 54321)\n+        mock_server = mock.MagicMock()\n+        # This specifies that the server will be able to handle requests other\n+        # than only websockets.\n+        mock_server.only_upgrade = False\n+\n+        # Constructing a handler will process the mock_req request passed in.\n+        websocketproxy.NovaProxyRequestHandler(\n+            mock_req, client_addr, mock_server)\n+\n+        # Verify no redirect happens and instead a 400 Bad Request is returned.\n+        self.data = self.data.decode()\n+        self.assertIn('Error code: 400', self.data)\n+        self.assertIn('Message: URI must not start with //', self.data)\n+\n     @mock.patch('nova.objects.ConsoleAuthToken.validate')\n     def test_no_compute_rpcapi_with_invalid_token(self, mock_validate):\n         \"\"\"Tests that we don't create a ComputeAPI object until we actually", "file_path": "files/2022_3/1009", "file_language": "py", "file_name": "nova/tests/unit/console/test_websocketproxy.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/openstack/nova/raw/781612b33282ed298f742c85dab58a075c8b793e/releasenotes%2Fnotes%2Fconsole-proxy-reject-open-redirect-4ac0a7895acca7eb.yaml", "code": "---\nsecurity:\n  - |\n    A vulnerability in the console proxies (novnc, serial, spice) that allowed\n    open redirection has been `patched`_. The novnc, serial, and spice console\n    proxies are implemented as websockify servers and the request handler\n    inherits from the python standard SimpleHTTPRequestHandler. There is a\n    `known issue`_ in the SimpleHTTPRequestHandler which allows open redirects\n    by way of URLs in the following format::\n\n      http://vncproxy.my.domain.com//example.com/%2F..\n\n    which if visited, will redirect a user to example.com.\n\n    The novnc, serial, and spice console proxies will now reject requests that\n    pass a redirection URL beginning with \"//\" with a 400 Bad Request.\n\n    .. _patched: https://bugs.launchpad.net/nova/+bug/1927677\n    .. _known issue: https://bugs.python.org/issue32084\n", "code_before": "", "patch": "@@ -0,0 +1,19 @@\n+---\n+security:\n+  - |\n+    A vulnerability in the console proxies (novnc, serial, spice) that allowed\n+    open redirection has been `patched`_. The novnc, serial, and spice console\n+    proxies are implemented as websockify servers and the request handler\n+    inherits from the python standard SimpleHTTPRequestHandler. There is a\n+    `known issue`_ in the SimpleHTTPRequestHandler which allows open redirects\n+    by way of URLs in the following format::\n+\n+      http://vncproxy.my.domain.com//example.com/%2F..\n+\n+    which if visited, will redirect a user to example.com.\n+\n+    The novnc, serial, and spice console proxies will now reject requests that\n+    pass a redirection URL beginning with \"//\" with a 400 Bad Request.\n+\n+    .. _patched: https://bugs.launchpad.net/nova/+bug/1927677\n+    .. _known issue: https://bugs.python.org/issue32084", "file_path": "files/2022_3/1010", "file_language": "yaml", "file_name": "releasenotes/notes/console-proxy-reject-open-redirect-4ac0a7895acca7eb.yaml", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
