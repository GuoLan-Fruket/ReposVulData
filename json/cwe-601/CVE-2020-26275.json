{"index": 5203, "cve_id": "CVE-2020-26275", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "The Jupyter Server provides the backend (i.e. the core services, APIs, and REST endpoints) for Jupyter web applications like Jupyter notebook, JupyterLab, and Voila. In Jupyter Server before version 1.1.1, an open redirect vulnerability could cause the jupyter server to redirect the browser to a different malicious website. All jupyter servers running without a base_url prefix are technically affected, however, these maliciously crafted links can only be reasonably made for known jupyter server hosts. A link to your jupyter server may *appear* safe, but ultimately redirect to a spoofed server on the public internet. This same vulnerability was patched in upstream notebook v5.7.8. This is fixed in jupyter_server 1.1.1. If upgrade is not available, a workaround can be to run your server on a url prefix: \"jupyter server --ServerApp.base_url=/jupyter/\".", "cvss": "6.1", "publish_date": "December 21, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "85e4abccf6ea9321d29153f73b0bd72ccb3a6bca", "commit_message": "Merge pull request from GHSA-9f66-54xg-pc2c\n\nsync _redirect_safe with upstream", "commit_date": "2020-12-16T22:03:59Z", "project": "jupyter-server/jupyter_server", "url": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/85e4abccf6ea9321d29153f73b0bd72ccb3a6bca", "html_url": "https://github.com/jupyter-server/jupyter_server/commit/85e4abccf6ea9321d29153f73b0bd72ccb3a6bca", "windows_before": [{"commit_id": "a3a3a46b907cabd7be66c639cf161aafbf20b2e5", "commit_date": "Fri Dec 11 14:38:10 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "921508b338286d8e946c349e8512bb78770763c8", "commit_date": "Fri Dec 11 14:34:07 2020 -0800", "commit_message": "Release 1.1.0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "3bb4caa7fbd31fe9cd5b45d36e547770945e3809", "commit_date": "Fri Dec 11 14:32:21 2020 -0800", "commit_message": "Merge pull request #362 from Zsailer/changelog", "files_name": ["f55926ea3c7df5baa42b262880920290fa9204ac - Fri Dec 11 14:31:51 2020 -0800 : remove references to changelog", "docs/source/developers/dependency.rst", "docs/source/other/index.rst", "docs/source/users/installation.rst"]}, {"commit_id": "082fc383661c95ccf49af6ca9aef752bd26a3a6b", "commit_date": "Fri Dec 11 14:30:12 2020 -0800", "commit_message": "remove changelog from docs to reduce duplicity", "files_name": ["CHANGELOG.md", "docs/source/developers/index.rst", "docs/source/other/changelog.rst"]}, {"commit_id": "d05aebe015b9be1d1914c5b80b705f288e888660", "commit_date": "Fri Dec 11 14:23:05 2020 -0800", "commit_message": "update changelog for 1.1.0 release", "files_name": ["CHANGELOG.md"]}, {"commit_id": "6fef2a8f2e8b73d4db43aacc71402159b2e12fc9", "commit_date": "Thu Dec 10 15:15:57 2020 -0800", "commit_message": "Merge pull request #324 from mwakaba2/async-contents-api", "files_name": ["7d863f35c9c1e5dc8a58ec8af373bbb1b5158475 - Thu Dec 10 10:58:22 2020 -0800 : Update jupyter_server/services/contents/fileio.py", "jupyter_server/pytest_plugin.py", "jupyter_server/services/contents/fileio.py"]}, {"commit_id": "bd057ef13dabd47f79826124b8020f14b374cd0f", "commit_date": "Fri Dec 4 11:55:04 2020 -0700", "commit_message": "Update docs", "files_name": ["docs/source/developers/contents.rst"]}, {"commit_id": "01500bdafbab4452f5a3180a86c68387f0ac05e3", "commit_date": "Fri Dec 4 11:48:12 2020 -0700", "commit_message": "Checkpoints: Make all not implemented methods async", "files_name": ["jupyter_server/services/contents/checkpoints.py"]}, {"commit_id": "b19edc00708cbda23311212d5f04b71262fedf27", "commit_date": "Fri Dec 4 10:21:57 2020 -0700", "commit_message": "update docs and configs", "files_name": ["docs/source/developers/contents.rst", "docs/source/other/full-config.rst"]}, {"commit_id": "188fc3c1e2c505ce6e1ce66887eb002979d7f68b", "commit_date": "Thu Dec 3 10:26:22 2020 -0700", "commit_message": "Make handlers compatible with async CMs", "files_name": ["jupyter_server/base/handlers.py", "jupyter_server/files/handlers.py", "jupyter_server/nbconvert/handlers.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/handlers.py", "jupyter_server/services/contents/largefilemanager.py", "jupyter_server/services/contents/manager.py", "jupyter_server/view/handlers.py"]}, {"commit_id": "564325e9ba048c203c1cde83a47390328166821f", "commit_date": "Fri Nov 20 10:47:51 2020 -0700", "commit_message": "Create AsyncGenericFileCheckpoints", "files_name": ["jupyter_server/services/contents/filecheckpoints.py", "tests/services/contents/test_config.py"]}, {"commit_id": "9be92d81c402fe0fd31df571e45e71647330076a", "commit_date": "Fri Nov 20 10:10:05 2020 -0700", "commit_message": "Create AsyncLargeFileManager", "files_name": ["jupyter_server/services/contents/largefilemanager.py", "tests/services/contents/test_largefilemanager.py"]}, {"commit_id": "3bc0febc8d8df19dcf660e7ddfeb36406bdbc4f0", "commit_date": "Wed Nov 18 18:45:58 2020 -0700", "commit_message": "Skip test for windows", "files_name": ["tests/services/contents/test_manager.py"]}, {"commit_id": "0afe5b196a5be6a91215f8a3448ad3b52656d233", "commit_date": "Tue Nov 17 12:04:58 2020 -0700", "commit_message": "Fix lint errors", "files_name": ["jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/manager.py", "tests/services/contents/test_api.py", "tests/services/contents/test_config.py", "tests/services/contents/test_manager.py"]}, {"commit_id": "5a521e305bd8c3faa6fae61bf7e470dfc05e9d52", "commit_date": "Tue Nov 17 11:59:50 2020 -0700", "commit_message": "Add new async classes to serverapp", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "6bd874d5365a0ad51f2b01a53555a97a255d1d52", "commit_date": "Tue Nov 17 11:56:25 2020 -0700", "commit_message": "Remove condition for testing python 3.5", "files_name": ["tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/sessions/test_api.py"]}, {"commit_id": "24dd61839f8629f28a6185362b73b9b4aed61fef", "commit_date": "Tue Nov 17 11:55:16 2020 -0700", "commit_message": "Use jp prefix for fixtures", "files_name": ["jupyter_server/pytest_plugin.py", "tests/services/contents/test_manager.py"]}, {"commit_id": "3a97a6ab0bd2e57c7ee663c91359e731a7942034", "commit_date": "Thu Nov 12 11:46:49 2020 -0700", "commit_message": "Create AsyncFileContentsManager", "files_name": ["jupyter_server/serverapp.py", "jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/handlers.py", "jupyter_server/services/contents/manager.py", "setup.py", "tests/services/contents/test_api.py", "tests/services/contents/test_manager.py", "tests/services/kernels/test_api.py"]}, {"commit_id": "ca60bcf84245b3ff2b672f5a2a0a3c84596296a0", "commit_date": "Thu Nov 12 11:46:20 2020 -0700", "commit_message": "Add asynchronous support section", "files_name": ["docs/source/developers/contents.rst"]}, {"commit_id": "1cfc2110bb529220ce8aacfc78acd39b62e178ae", "commit_date": "Fri Oct 30 08:54:12 2020 -0600", "commit_message": "[DRAFT] Asynchronous Contents API", "files_name": ["jupyter_server/services/contents/checkpoints.py", "jupyter_server/services/contents/manager.py", "tests/services/contents/test_config.py"]}, {"commit_id": "28f784bbfdbb2541cac2224f5dcd625389258813", "commit_date": "Thu Dec 10 11:29:02 2020 -0800", "commit_message": "Merge pull request #360 from kevin-bates/restore-pytest-plugin", "files_name": ["1858bb50961deec8d3aac386c5b02a965252bfa1 - Thu Dec 10 11:05:46 2020 -0800 : Restore pytest plugin from pytest-jupyter", "examples/simple/setup.py", "examples/simple/tests/conftest.py", "jupyter_server/pytest_plugin.py", "setup.py", "tests/conftest.py", "tests/extension/test_handler.py", "tests/extension/test_serverextension.py", "tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/kernelspecs/test_api.py", "tests/services/sessions/test_api.py", "tests/test_paths.py", "tests/utils.py"]}, {"commit_id": "20c84e8d6deca063e43f6bdbd27ecaea41af3791", "commit_date": "Wed Dec 9 13:21:19 2020 +0100", "commit_message": "sync _redirect_safe with upstream", "files_name": ["jupyter_server/auth/login.py", "tests/auth/test_login.py"]}, {"commit_id": "ca492c1b8d3bfe933f47289889a542c842d46570", "commit_date": "Thu Dec 3 09:59:35 2020 -0800", "commit_message": "Merge pull request #354 from mwakaba2/fix-tests-setup", "files_name": ["d865e5901cae3c7723438491732441c7b265cc6a - Thu Dec 3 10:41:41 2020 -0700 : Fix upgrade packaging dependencies build step", ".github/workflows/main.yml"]}, {"commit_id": "f13a22b6280ed6beba9eda90963a840369a1364c", "commit_date": "Tue Dec 1 09:06:06 2020 -0800", "commit_message": "Merge pull request #333 from kevin-bates/codeql-pushed-branches", "files_name": ["c45d7f3655c23d6a4717ba4c780f3775430d0a6a - Mon Nov 30 16:04:50 2020 -0800 : Merge pull request #344 from yuvipanda/prometheus-auth", "679683c1961ad1a17e0f39bfa2d642570a2cf09b - Mon Nov 30 16:04:20 2020 -0800 : Merge pull request #343 from kevin-bates/port-5565-5588", "bbf01baf55b60b5eedee220e718b70323c8f2c11 - Sat Nov 21 10:08:45 2020 -0800 : Merge pull request #350 from ricklamers/connect-gateway-fix", "0584bf0a36d54803a1aaff30bc98667fd2f9dd94 - Fri Nov 20 13:04:43 2020 -0800 : Merge pull request #348 from kevin-bates/update-release-instructions", "7377a1e976302b7da14f4a3cb217af63637ed8c6 - Fri Nov 20 12:12:16 2020 -0800 : Update release instructions and dev version", "RELEASE.md", "jupyter_server/_version.py"]}, {"commit_id": "8763b5b98cb745cc11713af20f72a1919ea2d181", "commit_date": "Thu Nov 19 16:05:16 2020 -0800", "commit_message": "set version to dev", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "b2e089506baf0723fe63112cb9df7ef8b493d093", "commit_date": "Wed Nov 18 11:57:05 2020 -0800", "commit_message": "Merge pull request #346 from kevin-bates/fix-test-trailing-slash", "files_name": ["630018f6e806176dd088b996da4e6a44954ff1fd - Wed Nov 18 10:53:55 2020 -0800 : Update fixtures to use pytest-jupyter", "tests/test_paths.py"]}, {"commit_id": "782230e4a7cc838c2f35b9bd66941bdee5bb87fa", "commit_date": "Wed Nov 18 11:07:00 2020 -0800", "commit_message": "Merge pull request #345 from jupyter/1.0.x", "files_name": ["37eac444dd08cedbcb3490490c8f3d15b81e1eff - Wed Nov 18 09:56:15 2020 -0800 : fix test bug", "tests/test_paths.py"]}, {"commit_id": "e17091698fb90db938a6a3d875b48271597a6db5", "commit_date": "Wed Nov 18 09:35:01 2020 -0800", "commit_message": "bump version to 1.0.6", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "0c094b803822cbb3d27a1e77144538b779efde4a", "commit_date": "Wed Nov 18 09:23:07 2020 -0800", "commit_message": "update changelog for 1.0.6 release", "files_name": ["CHANGELOG.md", "docs/source/other/changelog.rst"]}, {"commit_id": "3d83e49090289c431da253e2bdb8dc479cbcb157", "commit_date": "Wed Nov 18 09:17:16 2020 -0800", "commit_message": "Merge pull request from GHSA-grfj-wjv9-4f9v", "files_name": ["293bff0c72572edd9c8e642fa8784ae21b7fea3e - Wed Nov 18 13:31:54 2020 +0530 : Allow toggling auth for prometheus metrics", "jupyter_server/base/handlers.py", "jupyter_server/serverapp.py"]}, {"commit_id": "66962b530261f9eca35f4060133bed818330b619", "commit_date": "Fri Jul 3 15:04:08 2020 +0200", "commit_message": "Improve login shell heuristics", "files_name": ["jupyter_server/terminal/__init__.py"]}, {"commit_id": "9e18c8ed700a55e8c30e51670884ba732583e04c", "commit_date": "Wed Jul 1 18:55:30 2020 +0200", "commit_message": "Nested shells should not be login (#5247) (#5565)", "files_name": ["jupyter_server/terminal/__init__.py"]}, {"commit_id": "e3de58b3be9865e25d653d0f47db8d929440d3ab", "commit_date": "Tue Nov 17 13:16:00 2020 -0800", "commit_message": "Merge pull request #341 from kevin-bates/notebook-gateway-updates", "files_name": ["5c311111eda3ac4db0cdf61b49f6e5ee49da4984 - Tue Nov 17 13:14:42 2020 -0800 : Merge pull request #339 from bollwyvl/gh-337-no-entrypoint", "2ce063a3758bbf67702bbfcd929ece7abcb2d41c - Mon Nov 16 17:00:26 2020 -0500 : move min tornado outside translation block", "jupyter_server/serverapp.py"]}, {"commit_id": "457059a2b2af399b6bcec62c9d9acb35ea5524aa", "commit_date": "Mon Nov 16 09:08:54 2020 +0100", "commit_message": "await _connect and inline read_messages callback to _connect", "files_name": ["jupyter_server/gateway/handlers.py"]}, {"commit_id": "e09ba054f002bf62c48435472d15619e2e3fcf8c", "commit_date": "Sun Nov 15 19:54:21 2020 -0500", "commit_message": "fix minimum tornado error message", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "da0fef56eb4f765f0746de2a44a0c4807895921d", "commit_date": "Sun Nov 15 13:23:11 2020 -0500", "commit_message": "updates from review", "files_name": ["jupyter_server/serverapp.py", "tests/conftest.py", "tests/test_files.py"]}, {"commit_id": "c38672997cc5d3ba792ce18dca192a3eb5d725a7", "commit_date": "Wed May 27 18:56:30 2020 +0200", "commit_message": "Changed _get_endpoint_for_user_filter to static and used in constructor class instead of each class method", "files_name": ["jupyter_server/gateway/managers.py"]}, {"commit_id": "b8da0a8e8272bc22c75c83ee42f4ca3401a6698c", "commit_date": "Wed May 27 12:27:18 2020 +0200", "commit_message": "Added functionality to allow filter kernels by Jupyter Enterprise Gateway using KERNEL_USERNAME env var", "files_name": ["jupyter_server/gateway/managers.py"]}, {"commit_id": "573adc3de6de26f644afb27b5b7f037f63a1b45a", "commit_date": "Mon Apr 6 16:40:56 2020 -0700", "commit_message": "Gateway only: Ensure launch and request timeouts are in sync (#5317)", "files_name": ["jupyter_server/gateway/managers.py", "tests/test_gateway.py"]}, {"commit_id": "b5997a6e38b010f15cc9698f5e54b7debac3870a", "commit_date": "Sun Nov 15 08:07:56 2020 -0800", "commit_message": "Merge pull request #340 from ricklamers/master", "files_name": ["85d3c76629e8d9a96c38902e234259575dfee36d - Sun Nov 15 10:23:07 2020 +0100 : add check_origin handler to gateway WebSocketChannelsHandler", "jupyter_server/gateway/handlers.py"]}, {"commit_id": "a0640b3d6a30f815079e2233afcdb4d74719d11c", "commit_date": "Sat Nov 14 13:47:56 2020 -0500", "commit_message": "more work on removing asyncio patch", "files_name": ["jupyter_server/serverapp.py", "tests/test_files.py"]}, {"commit_id": "480d6d693ddd5a4cc42543a7caf6ad74b7958bc9", "commit_date": "Sat Nov 14 13:32:30 2020 -0500", "commit_message": "try new tornado hotness", "files_name": ["jupyter_server/pytest_plugin.py"]}], "windows_after": [{"commit_id": "7f81846033947b2e16f716f499c8ed39c5e2dce8", "commit_date": "Wed Dec 16 14:10:16 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "14f0c8481555f8603ea4bb27a20bf813e70265c1", "commit_date": "Sat Dec 12 10:52:15 2020 +0100", "commit_message": "Nudge kernel with info request until we receive IOPub messages", "files_name": ["jupyter_server/services/kernels/handlers.py"]}, {"commit_id": "816ca645aaae966b61f7add58aa1b37b898ae229", "commit_date": "Mon Dec 21 12:53:13 2020 +0100", "commit_message": "Review", "files_name": ["jupyter_server/services/kernels/handlers.py"]}, {"commit_id": "dd567f69e819e9b5456b45261b9e831295f071f7", "commit_date": "Mon Dec 21 14:17:39 2020 -0800", "commit_message": "Merge pull request #361 from SylvainCorlay/nudge-kernel", "files_name": ["e7cefef7843876ef38ca876b58daeaf17c39c632 - Mon Dec 21 15:10:37 2020 -0800 : Release 1.1.2", "jupyter_server/_version.py"]}, {"commit_id": "c2b2c31c385ec40d16054a8a34bdefcfbc31af8e", "commit_date": "Mon Dec 21 15:12:59 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "f81521040e2096be18df4f4b4946b66e2bece992", "commit_date": "Tue Dec 22 16:34:07 2020 +0000", "commit_message": "Port over https://github.com/jupyter/notebook/pull/5355 and other fixes", "files_name": ["jupyter_server/services/kernels/kernelmanager.py", "tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/kernels/test_cull.py", "tests/services/sessions/test_api.py"]}, {"commit_id": "29db7f93bc5110b7b95f5e99c3b5b207b5dc338e", "commit_date": "Wed Dec 23 19:16:50 2020 +0000", "commit_message": "Follow up to fix CI", "files_name": [".github/workflows/python-linux.yml", ".github/workflows/python-macos.yml", ".github/workflows/python-windows.yml"]}, {"commit_id": "d0778f95aa133c8d25502d60c323980bf89692e5", "commit_date": "Wed Dec 23 12:05:01 2020 -0800", "commit_message": "Merge pull request #365 from afshin/ensure_last_activity", "files_name": ["fde129d1c239a83cf79364cfb42be991225f1d51 - Wed Dec 23 15:06:39 2020 -0800 : Release 1.1.3", "jupyter_server/_version.py"]}, {"commit_id": "4e4ab206610208b06c8dbc71a85da9e8de92c0ae", "commit_date": "Wed Dec 23 15:07:08 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "b82a5e03eb6df7f538d3e7e62b3e5578ad7bab4d", "commit_date": "Thu Dec 24 12:45:57 2020 -0700", "commit_message": "Update serverapp.py", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "1f5508e43a7b6004392aa13a16ad380fd6f60471", "commit_date": "Thu Dec 24 21:30:41 2020 -0800", "commit_message": "Merge pull request #367 from michaelaye/patch-1", "files_name": ["ddcfb54b4be5d71a7edd53356dbf79b8270ec764 - Sat Jan 2 11:31:15 2021 -0500 : use setuptools find_packages, exclude tests, docs and examples from distributions", "setup.py"]}, {"commit_id": "e59b4ab023731ce4f2dd187f50e62d08b17a13ca", "commit_date": "Sat Jan 2 11:43:37 2021 -0500", "commit_message": "also remove underlying deprecated wrapper", "files_name": ["setupbase.py"]}, {"commit_id": "2b471c2d4c692de4813cc1b04e5d3a958e0113f6", "commit_date": "Sat Jan 2 17:27:46 2021 +0000", "commit_message": "IPythonHandler -> JupyterHandler", "files_name": ["jupyter_server/gateway/handlers.py"]}, {"commit_id": "af89d26df36c7659b67c9ab36ea725e31ddb775f", "commit_date": "Sat Jan 2 10:07:47 2021 -0800", "commit_message": "Merge pull request #370 from krassowski/patch-1", "files_name": ["84401f08438aa4b87d8ca650fbaadb266dbc2262 - Sat Jan 2 22:42:33 2021 +0000 : Update the link to paths documentation", "docs/source/developers/extensions.rst"]}, {"commit_id": "a23015c7cf1fe4b9fef4c51374f511a730a8d6d2", "commit_date": "Sun Jan 3 06:20:12 2021 +0100", "commit_message": "Merge pull request #371 from krassowski/patch-2", "files_name": ["b4968ce98ebb70ab22a4601fbb1df1d42b9dcf2c - Mon Jan 4 10:57:55 2021 -0600 : Merge pull request #368 from bollwyvl/fix-tests-packaging", "41daba908b31b080bbb776c523d5f8058f54cd34 - Mon Jan 4 10:59:07 2021 -0600 : Release 1.1.4", "jupyter_server/_version.py"]}, {"commit_id": "00a6e25970f7e5af206f025e8dab1f86cea53f1d", "commit_date": "Mon Jan 4 10:59:36 2021 -0600", "commit_message": "back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "f56515eeada2f1aadab3ca389760d21afdfd44de", "commit_date": "Tue Jan 5 15:12:12 2021 +0100", "commit_message": "regression test for trust API", "files_name": ["tests/services/contents/test_api.py"]}, {"commit_id": "7106c1fa2229797f61b67592571001fd16b20235", "commit_date": "Tue Jan 5 15:13:15 2021 +0100", "commit_message": "Make trust handler use ensure_async", "files_name": ["jupyter_server/services/contents/handlers.py"]}, {"commit_id": "ee6c9097f24668399a5856a84ba9e4ac91defbdc", "commit_date": "Tue Jan 5 15:18:09 2021 +0100", "commit_message": "use relative paths for contents fixture", "files_name": ["tests/services/contents/test_api.py"]}, {"commit_id": "60c66b6a1ce26c474efae8bb8e77de621a58272c", "commit_date": "Tue Jan 5 07:05:37 2021 -0800", "commit_message": "Merge pull request #373 from jupyter-server/ensure-trust-async", "files_name": ["491f53bed3988837f40758f800c25e94536adb88 - Wed Jan 6 17:36:49 2021 +0000 : Add setting to disable redirect file browser launch", "jupyter_server/serverapp.py"]}, {"commit_id": "ebbcbb7850b74c74c4cf1b5f8f55f105b6572237", "commit_date": "Wed Jan 6 18:49:34 2021 +0000", "commit_message": "Handle open_browser trait in ServerApp and ExtensionApp differently", "files_name": ["jupyter_server/extension/application.py", "jupyter_server/serverapp.py"]}, {"commit_id": "72ee66b85f8b252441f8fef10bf3e70117dc3aca", "commit_date": "Wed Jan 6 11:07:05 2021 -0800", "commit_message": "Merge pull request #374 from afshin/disable-redirect-file", "files_name": ["ec6217ef6265ccf0ed3dc4f25f29f73065d9dde0 - Wed Jan 6 11:07:53 2021 -0800 : Merge pull request #375 from afshin/open-browser", "ea581ae22fe64a7ae124326dec1b3651dc4f630f - Wed Jan 6 20:03:21 2021 +0000 : Improve Handling of the soft limit on open file handles", "jupyter_server/serverapp.py"]}, {"commit_id": "7262c9f0eee28382a41282fc193c686a623bb593", "commit_date": "Wed Jan 6 15:05:08 2021 -0800", "commit_message": "Flip default value for open_browser in extensions", "files_name": ["jupyter_server/extension/application.py"]}, {"commit_id": "3e45900aa50f133c8af8d9cac0078af0b01ea699", "commit_date": "Wed Jan 6 15:19:32 2021 -0800", "commit_message": "Merge pull request #377 from ajbozarth/requested-fix", "files_name": ["09cef16e27d6962d9429e136f7d7513244159a57 - Wed Jan 6 16:33:24 2021 -0800 : Merge pull request #376 from afshin/soft-limits", "d3ac58a0e0f3c80450dcce23f807297aff21d7aa - Wed Jan 6 16:40:56 2021 -0800 : Release 1.2.0", "jupyter_server/_version.py"]}, {"commit_id": "d4438a219cb9ba8f0a5e233a774ccda4f346b024", "commit_date": "Wed Jan 6 16:42:15 2021 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "ee2b12d7f7b60f506563fabc1e3e0ed53f0897a1", "commit_date": "Fri Jan 8 17:50:39 2021 +0200", "commit_message": "Add reconnection to Gateway", "files_name": ["jupyter_server/gateway/handlers.py", "jupyter_server/gateway/managers.py"]}, {"commit_id": "abe6f9376411b94618c6c4ef74d8c89737a2cca7", "commit_date": "Fri Jan 8 16:39:28 2021 +0000", "commit_message": "Enable extensions to set debug and open-browser flags", "files_name": ["jupyter_server/extension/application.py", "jupyter_server/serverapp.py"]}, {"commit_id": "ee8814728239611e08194565843ce0cd413e77d2", "commit_date": "Fri Jan 8 09:30:24 2021 -0800", "commit_message": "Merge pull request #379 from afshin/debug-open-browser-flags", "files_name": ["0f8d89d3d67018ec30367d0d9d39bc57afb468f0 - Fri Jan 8 10:23:36 2021 -0800 : Merge pull request #378 from oyvsyo/gateway_connection_retry", "3ecbb6fbe339e85be751d62797135b9c04a35a46 - Fri Jan 8 10:51:10 2021 -0800 : Release 1.2.1", "jupyter_server/_version.py"]}, {"commit_id": "4cf7d4d4059be1c28bcf03f55b63a628f89ec9a8", "commit_date": "Fri Jan 8 10:51:55 2021 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "84ca636bb70af769f87dd835268d54b94fafad84", "commit_date": "Tue Jan 12 19:50:07 2021 +0000", "commit_message": "Add --autoreload flag", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "add9743398af7d4c26f1db7fcacb814906154e27", "commit_date": "Tue Jan 12 12:21:05 2021 -0800", "commit_message": "Merge pull request #380 from afshin/autoreload", "files_name": ["1a743bb74780ac269b366c8557dbd3f900fa4bc6 - Tue Jan 12 14:51:43 2021 -0800 : Replace secure_write, is_hidden, exists with jupyter_core's", "jupyter_server/base/handlers.py", "jupyter_server/serverapp.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/kernels/kernelmanager.py", "jupyter_server/utils.py", "tests/test_utils.py"]}, {"commit_id": "3135bd6f764210cf1d084cfec3cb8ad218a4340a", "commit_date": "Tue Jan 12 16:05:15 2021 -0800", "commit_message": "Merge pull request #382 from kevin-bates/replace-secure_write", "files_name": ["7a04ce2e7b102f5bd3a4c0c0d018c15b692ca80d - Thu Jan 14 16:07:41 2021 +0000 : Fix application exit", "jupyter_server/extension/application.py"]}, {"commit_id": "016647e0b63f22fec7aeb1952eb8865a46f19c98", "commit_date": "Thu Jan 14 10:16:35 2021 -0800", "commit_message": "Update changelog to 1.2.1", "files_name": ["CHANGELOG.md"]}, {"commit_id": "792d65959001139c4718fadb7034487161121108", "commit_date": "Thu Jan 14 11:27:27 2021 -0800", "commit_message": "Apply ensure_async to a couple session handlers", "files_name": ["jupyter_server/services/sessions/handlers.py"]}, {"commit_id": "b8629302dedb827be336cde6477ee300c40642a2", "commit_date": "Thu Jan 14 15:10:23 2021 -0800", "commit_message": "Merge pull request #384 from afshin/fix-app-exit", "files_name": ["04eba340b7c95af49e2f73ffbac2f60345066e2e - Thu Jan 14 15:10:35 2021 -0800 : Merge pull request #385 from Zsailer/changelog-1.2.0", "e93a546afc79094f2746046dbe1a31f8fcf06364 - Thu Jan 14 15:16:12 2021 -0800 : Merge pull request #386 from kevin-bates/fix-list-sessions", "a523141045b18163b86dfaaa98fe6be5e00493a5 - Thu Jan 14 16:49:18 2021 -0800 : Release 1.2.2", "jupyter_server/_version.py"]}, {"commit_id": "235e7498f80ff22b758e73920b37484345b21be3", "commit_date": "Thu Jan 14 16:51:15 2021 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "03666faf6061b9df994bf38c5e3ffbdc9f363596", "commit_date": "Thu Jan 14 16:58:14 2021 -0800", "commit_message": "update changelog for 1.2.2", "files_name": ["CHANGELOG.md"]}, {"commit_id": "1b7f6fe3e13ed45f98d4ea48a50cc366297e83be", "commit_date": "Thu Jan 14 17:00:10 2021 -0800", "commit_message": "Merge pull request #387 from jupyter-server/changelog-1.2.2", "files_name": ["083f7bed0da579c74c9ec7e656f8b2c864015167 - Sun Jan 17 10:08:05 2021 -0800 : Increase culling test idle timeout", "tests/services/kernels/test_cull.py"]}, {"commit_id": "5b45a03749d7b84652c90996207938b7f7d403d0", "commit_date": "Tue Jan 19 14:30:27 2021 +0100", "commit_message": "use jupyter_server_config.json as config file in the update password api", "files_name": ["jupyter_server/auth/login.py"]}, {"commit_id": "b5fed9cdedfa9a41ba9a377e9a8b96607b82612b", "commit_date": "Tue Jan 19 09:53:52 2021 -0600", "commit_message": "Merge pull request #388 from kevin-bates/cull-test-idle-timeout", "files_name": ["edf4a08784a191130a199d5ea0b1ab6b83d7d3fc - Tue Jan 19 17:38:35 2021 +0100 : Merge pull request #390 from datalayer-contrib/auth/jupyter_server_config", "5ffec87aa9bf553b23373f3bb1515922fe0ce1e6 - Thu Jan 21 16:08:36 2021 +0000 : Enable notebook ContentsManager in jupyter_server", "jupyter_server/serverapp.py", "jupyter_server/services/sessions/sessionmanager.py", "jupyter_server/traittypes.py", "tests/test_traittypes.py"]}, {"commit_id": "028feb026e00863064122229adfe905319234400", "commit_date": "Thu Jan 21 16:15:29 2021 +0000", "commit_message": "Re-enable default_url in ExtensionApp", "files_name": ["jupyter_server/extension/application.py"]}, {"commit_id": "2477da6d8f1df4ceade1fa4412bdd0e19ee09ed1", "commit_date": "Thu Jan 21 11:09:00 2021 -0600", "commit_message": "Merge pull request #393 from afshin/default-url", "files_name": ["a45a53b84069fad6e3692e22fa1355bc63c87095 - Thu Jan 21 10:07:48 2021 -0800 : Update jupyter_server/serverapp.py", "jupyter_server/serverapp.py"]}, {"commit_id": "0e042e2720c008cbae61dce8973266099a5d3a89", "commit_date": "Fri Jan 29 16:51:18 2021 +0100", "commit_message": "Update manager.py", "files_name": ["jupyter_server/extension/manager.py"]}, {"commit_id": "7978e46e69d42ff26c09d85341f4fc19ce060575", "commit_date": "Fri Jan 29 19:01:24 2021 +0000", "commit_message": "Fix tests", "files_name": [".github/workflows/python-windows.yml", "jupyter_server/traittypes.py"]}, {"commit_id": "5dc20a3c9ebc7af8e2b77b8f8111f2a9be8ab3fe", "commit_date": "Fri Jan 29 13:52:35 2021 -0800", "commit_message": "Merge pull request #392 from afshin/contents-manager", "files_name": ["ecbacff191a43695dab86d536f6f54546d190e96 - Fri Jan 29 15:11:16 2021 -0800 : add changelog for pending 1.2.3 release", "CHANGELOG.md"]}, {"commit_id": "b9ffb4b9f0313658b344524e9f34bf5f0c3ceb7b", "commit_date": "Fri Jan 29 15:33:18 2021 -0800", "commit_message": "Merge pull request #397 from Zsailer/changelog-1.2.3", "files_name": ["2aa117e067bb6847c3d390505c2f28a869de7dab - Fri Jan 29 15:34:24 2021 -0800 : Release 1.2.3", "jupyter_server/_version.py"]}, {"commit_id": "6338d307463553e5371ea68a8e2a422781e49612", "commit_date": "Fri Jan 29 15:35:08 2021 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "d5aa937c52eec4b374a808d533861e7e5aa95d08", "commit_date": "Mon Feb 1 09:31:18 2021 -0700", "commit_message": "Revert Session.username default value change", "files_name": ["docs/source/other/full-config.rst"]}, {"commit_id": "1e023c3956dea4a3eef65fe820a14320e2e28274", "commit_date": "Mon Feb 1 13:06:03 2021 -0700", "commit_message": "Update docs/source/other/full-config.rst", "files_name": ["docs/source/other/full-config.rst"]}, {"commit_id": "5013f62d5c05a78b27180b858ca4b6b071c81b46", "commit_date": "Mon Feb 1 13:20:29 2021 -0800", "commit_message": "Merge pull request #398 from mwakaba2/doc-change", "files_name": ["90355926d877c4427e79c880baf2527651da5a55 - Mon Feb 1 15:54:32 2021 -0800 : Use async kernel manager by default", "jupyter_server/gateway/managers.py", "jupyter_server/serverapp.py"]}, {"commit_id": "5a28ec1c572485db3b857eb8fdf6d2a3979ee82c", "commit_date": "Wed Feb 3 12:18:00 2021 +0100", "commit_message": "only use deprecated notebook_dir config if root_dir is not set", "files_name": ["jupyter_server/serverapp.py"]}], "parents": [{"commit_id_before": "b328e0a98fa553d3ec4cd911b6d11bb7363ddb0f", "url_before": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/b328e0a98fa553d3ec4cd911b6d11bb7363ddb0f", "html_url_before": "https://github.com/jupyter-server/jupyter_server/commit/b328e0a98fa553d3ec4cd911b6d11bb7363ddb0f"}, {"commit_id_before": "20c84e8d6deca063e43f6bdbd27ecaea41af3791", "url_before": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/20c84e8d6deca063e43f6bdbd27ecaea41af3791", "html_url_before": "https://github.com/jupyter-server/jupyter_server/commit/20c84e8d6deca063e43f6bdbd27ecaea41af3791"}], "details": [{"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/85e4abccf6ea9321d29153f73b0bd72ccb3a6bca/jupyter_server%2Fauth%2Flogin.py", "code": "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\nimport os\nimport uuid\n\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom .security import passwd_check, set_password\n\nfrom ..base.handlers import JupyterHandler\n\n\nclass LoginHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get(\"allow_password_change\"):\n                    config_dir = self.settings.get(\"config_dir\")\n                    config_file = os.path.join(\n                        config_dir, \"jupyter_notebook_config.json\"\n                    )\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n", "code_before": "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\nimport os\nimport uuid\n\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom .security import passwd_check, set_password\n\nfrom ..base.handlers import JupyterHandler\n\n\nclass LoginHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get(\"allow_password_change\"):\n                    config_dir = self.settings.get(\"config_dir\")\n                    config_file = os.path.join(\n                        config_dir, \"jupyter_notebook_config.json\"\n                    )\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n", "patch": "@@ -36,14 +36,19 @@ def _redirect_safe(self, url, default=None):\n         \"\"\"\n         if default is None:\n             default = self.base_url\n-        if not url.startswith(self.base_url):\n+        # protect chrome users from mishandling unescaped backslashes.\n+        # \\ is not valid in urls, but some browsers treat it as /\n+        # instead of %5C, causing `\\\\` to behave as `//`\n+        url = url.replace(\"\\\\\", \"%5C\")\n+        parsed = urlparse(url)\n+        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n             # require that next_url be absolute path within our path\n             allow = False\n             # OR pass our cross-origin check\n-            if '://' in url:\n+            if parsed.netloc:\n                 # if full URL, run our cross-origin check:\n-                parsed = urlparse(url.lower())\n                 origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n+                origin = origin.lower()\n                 if self.allow_origin:\n                     allow = self.allow_origin == origin\n                 elif self.allow_origin_pat:\n@@ -77,9 +82,11 @@ def post(self):\n                 self.set_login_cookie(self, uuid.uuid4().hex)\n             elif self.token and self.token == typed_password:\n                 self.set_login_cookie(self, uuid.uuid4().hex)\n-                if new_password and self.settings.get('allow_password_change'):\n-                    config_dir = self.settings.get('config_dir')\n-                    config_file = os.path.join(config_dir, 'jupyter_server_config.json')\n+                if new_password and self.settings.get(\"allow_password_change\"):\n+                    config_dir = self.settings.get(\"config_dir\")\n+                    config_file = os.path.join(\n+                        config_dir, \"jupyter_notebook_config.json\"\n+                    )\n                     set_password(new_password, config_file=config_file)\n                     self.log.info(\"Wrote hashed password to %s\" % config_file)\n             else:", "file_path": "files/2020_12/128", "file_language": "py", "file_name": "jupyter_server/auth/login.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class LoginHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get(\"allow_password_change\"):\n                    config_dir = self.settings.get(\"config_dir\")\n                    config_file = os.path.join(\n                        config_dir, \"jupyter_notebook_config.json\"\n                    )\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))", "target": 0}], "function_after": [{"function": "class LoginHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        return passwd_check(a, b)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        new_password = self.get_argument('new_password', default=u'')\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and self.settings.get(\"allow_password_change\"):\n                    config_dir = self.settings.get(\"config_dir\")\n                    config_file = os.path.join(\n                        config_dir, \"jupyter_notebook_config.json\"\n                    )\n                    set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid credentials'})\n                return\n\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        cookie_options.setdefault('path', handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n\n        Origin check should be skipped for token-authenticated requests.\n\n        Returns:\n        - True, if Handler must check for valid CORS origin.\n        - False, if Handler should skip origin check since requests are token-authenticated.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.\n\n        Login with a token is used to signal certain things, such as:\n\n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})\n            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\n        \n        Returns:\n        - uuid if authenticated\n        - None if not\n        \"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))", "target": 0}]}, {"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/85e4abccf6ea9321d29153f73b0bd72ccb3a6bca/tests%2Fauth%2Ftest_login.py", "code": "\"\"\"Tests for login redirects\"\"\"\n\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import url_concat, parse_cookie\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(jp_serverapp, http_server_client, jp_base_url, next):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(\n                {\n                    \"password\": jp_serverapp.token,\n                    \"_xsrf\": cookies.get(\"_xsrf\", \"\"),\n                }\n            ),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        return e.response.headers[\"Location\"]\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    url = await login(bad_next)\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    actual = await login(next=expected)\n    assert actual == expected\n", "code_before": "\"\"\"Tests for login redirects\"\"\"\n\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import url_concat, parse_cookie\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(jp_serverapp, http_server_client, jp_base_url, next):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(\n                {\n                    \"password\": jp_serverapp.token,\n                    \"_xsrf\": cookies.get(\"_xsrf\", \"\"),\n                }\n            ),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        return e.response.headers[\"Location\"]\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    url = await login(bad_next)\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    actual = await login(next=expected)\n    assert actual == expected\n", "patch": "@@ -0,0 +1,95 @@\n+\"\"\"Tests for login redirects\"\"\"\n+\n+from functools import partial\n+from urllib.parse import urlencode\n+\n+import pytest\n+from tornado.httpclient import HTTPClientError\n+from tornado.httputil import url_concat, parse_cookie\n+\n+from jupyter_server.utils import url_path_join\n+\n+\n+# override default config to ensure a non-empty base url is used\n+@pytest.fixture\n+def jp_base_url():\n+    return \"/a%40b/\"\n+\n+\n+@pytest.fixture\n+def jp_server_config(jp_base_url):\n+    return {\n+        \"ServerApp\": {\n+            \"base_url\": jp_base_url,\n+        },\n+    }\n+\n+\n+async def _login(jp_serverapp, http_server_client, jp_base_url, next):\n+    # first: request login page with no creds\n+    login_url = url_path_join(jp_base_url, \"login\")\n+    first = await http_server_client.fetch(login_url)\n+    cookie_header = first.headers[\"Set-Cookie\"]\n+    cookies = parse_cookie(cookie_header)\n+\n+    # second, submit login form with credentials\n+    try:\n+        resp = await http_server_client.fetch(\n+            url_concat(login_url, {\"next\": next}),\n+            method=\"POST\",\n+            body=urlencode(\n+                {\n+                    \"password\": jp_serverapp.token,\n+                    \"_xsrf\": cookies.get(\"_xsrf\", \"\"),\n+                }\n+            ),\n+            headers={\"Cookie\": cookie_header},\n+            follow_redirects=False,\n+        )\n+    except HTTPClientError as e:\n+        if e.code != 302:\n+            raise\n+        return e.response.headers[\"Location\"]\n+    else:\n+        assert resp.code == 302, \"Should have returned a redirect!\"\n+\n+\n+@pytest.fixture\n+def login(jp_serverapp, http_server_client, jp_base_url):\n+    \"\"\"Fixture to return a function to login to a Jupyter server\n+\n+    by submitting the login page form\n+    \"\"\"\n+    yield partial(_login, jp_serverapp, http_server_client, jp_base_url)\n+\n+\n+@pytest.mark.parametrize(\n+    \"bad_next\",\n+    (\n+        r\"\\\\tree\",\n+        \"//some-host\",\n+        \"//host{base_url}tree\",\n+        \"https://google.com\",\n+        \"/absolute/not/base_url\",\n+    ),\n+)\n+async def test_next_bad(login, jp_base_url, bad_next):\n+    bad_next = bad_next.format(base_url=jp_base_url)\n+    url = await login(bad_next)\n+    assert url == jp_base_url\n+\n+\n+@pytest.mark.parametrize(\n+    \"next_path\",\n+    (\n+        \"tree/\",\n+        \"//{base_url}tree\",\n+        \"notebooks/notebook.ipynb\",\n+        \"tree//something\",\n+    ),\n+)\n+async def test_next_ok(login, jp_base_url, next_path):\n+    next_path = next_path.format(base_url=jp_base_url)\n+    expected = jp_base_url + next_path\n+    actual = await login(next=expected)\n+    assert actual == expected", "file_path": "files/2020_12/129", "file_language": "py", "file_name": "tests/auth/test_login.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "async def _login(jp_serverapp, http_server_client, jp_base_url, next):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(\n                {\n                    \"password\": jp_serverapp.token,\n                    \"_xsrf\": cookies.get(\"_xsrf\", \"\"),\n                }\n            ),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        return e.response.headers[\"Location\"]\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"", "target": 0}], "function_after": [{"function": "async def _login(jp_serverapp, http_server_client, jp_base_url, next):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(\n                {\n                    \"password\": jp_serverapp.token,\n                    \"_xsrf\": cookies.get(\"_xsrf\", \"\"),\n                }\n            ),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        return e.response.headers[\"Location\"]\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
