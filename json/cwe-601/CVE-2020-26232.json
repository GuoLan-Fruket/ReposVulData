{"index": 5090, "cve_id": "CVE-2020-26232", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "Jupyter Server before version 1.0.6 has an Open redirect vulnerability. A maliciously crafted link to a jupyter server could redirect the browser to a different website. All jupyter servers are technically affected, however, these maliciously crafted links can only be reasonably made for known jupyter server hosts. A link to your jupyter server may appear safe, but ultimately redirect to a spoofed server on the public internet.", "cvss": "5.4", "publish_date": "November 24, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "3d83e49090289c431da253e2bdb8dc479cbcb157", "commit_message": "Merge pull request from GHSA-grfj-wjv9-4f9v\n\n[1.0.x] Fix GHSA-grfj-wjv9-4f9v", "commit_date": "2020-11-18T17:17:16Z", "project": "jupyter-server/jupyter_server", "url": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/3d83e49090289c431da253e2bdb8dc479cbcb157", "html_url": "https://github.com/jupyter-server/jupyter_server/commit/3d83e49090289c431da253e2bdb8dc479cbcb157", "windows_before": [{"commit_id": "66962b530261f9eca35f4060133bed818330b619", "commit_date": "Fri Jul 3 15:04:08 2020 +0200", "commit_message": "Improve login shell heuristics", "files_name": ["jupyter_server/terminal/__init__.py"]}, {"commit_id": "9e18c8ed700a55e8c30e51670884ba732583e04c", "commit_date": "Wed Jul 1 18:55:30 2020 +0200", "commit_message": "Nested shells should not be login (#5247) (#5565)", "files_name": ["jupyter_server/terminal/__init__.py"]}, {"commit_id": "e3de58b3be9865e25d653d0f47db8d929440d3ab", "commit_date": "Tue Nov 17 13:16:00 2020 -0800", "commit_message": "Merge pull request #341 from kevin-bates/notebook-gateway-updates", "files_name": ["5c311111eda3ac4db0cdf61b49f6e5ee49da4984 - Tue Nov 17 13:14:42 2020 -0800 : Merge pull request #339 from bollwyvl/gh-337-no-entrypoint", "2ce063a3758bbf67702bbfcd929ece7abcb2d41c - Mon Nov 16 17:00:26 2020 -0500 : move min tornado outside translation block", "jupyter_server/serverapp.py"]}, {"commit_id": "457059a2b2af399b6bcec62c9d9acb35ea5524aa", "commit_date": "Mon Nov 16 09:08:54 2020 +0100", "commit_message": "await _connect and inline read_messages callback to _connect", "files_name": ["jupyter_server/gateway/handlers.py"]}, {"commit_id": "e09ba054f002bf62c48435472d15619e2e3fcf8c", "commit_date": "Sun Nov 15 19:54:21 2020 -0500", "commit_message": "fix minimum tornado error message", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "da0fef56eb4f765f0746de2a44a0c4807895921d", "commit_date": "Sun Nov 15 13:23:11 2020 -0500", "commit_message": "updates from review", "files_name": ["jupyter_server/serverapp.py", "tests/conftest.py", "tests/test_files.py"]}, {"commit_id": "c38672997cc5d3ba792ce18dca192a3eb5d725a7", "commit_date": "Wed May 27 18:56:30 2020 +0200", "commit_message": "Changed _get_endpoint_for_user_filter to static and used in constructor class instead of each class method", "files_name": ["jupyter_server/gateway/managers.py"]}, {"commit_id": "b8da0a8e8272bc22c75c83ee42f4ca3401a6698c", "commit_date": "Wed May 27 12:27:18 2020 +0200", "commit_message": "Added functionality to allow filter kernels by Jupyter Enterprise Gateway using KERNEL_USERNAME env var", "files_name": ["jupyter_server/gateway/managers.py"]}, {"commit_id": "573adc3de6de26f644afb27b5b7f037f63a1b45a", "commit_date": "Mon Apr 6 16:40:56 2020 -0700", "commit_message": "Gateway only: Ensure launch and request timeouts are in sync (#5317)", "files_name": ["jupyter_server/gateway/managers.py", "tests/test_gateway.py"]}, {"commit_id": "b5997a6e38b010f15cc9698f5e54b7debac3870a", "commit_date": "Sun Nov 15 08:07:56 2020 -0800", "commit_message": "Merge pull request #340 from ricklamers/master", "files_name": ["85d3c76629e8d9a96c38902e234259575dfee36d - Sun Nov 15 10:23:07 2020 +0100 : add check_origin handler to gateway WebSocketChannelsHandler", "jupyter_server/gateway/handlers.py"]}, {"commit_id": "a0640b3d6a30f815079e2233afcdb4d74719d11c", "commit_date": "Sat Nov 14 13:47:56 2020 -0500", "commit_message": "more work on removing asyncio patch", "files_name": ["jupyter_server/serverapp.py", "tests/test_files.py"]}, {"commit_id": "480d6d693ddd5a4cc42543a7caf6ad74b7958bc9", "commit_date": "Sat Nov 14 13:32:30 2020 -0500", "commit_message": "try new tornado hotness", "files_name": ["jupyter_server/pytest_plugin.py", "jupyter_server/serverapp.py", "setup.py"]}, {"commit_id": "0e8a00fed71650169107ad884d3500502b0b48c0", "commit_date": "Sat Nov 14 13:16:56 2020 -0500", "commit_message": "fix imports", "files_name": ["tests/test_files.py"]}, {"commit_id": "20816c428bbeff9626e6e13737c5062c5ce35eef", "commit_date": "Sat Nov 14 12:31:42 2020 -0500", "commit_message": "overload jp_fetch", "files_name": ["tests/test_files.py"]}, {"commit_id": "8694e53c58c32a787482750a6ff159b2dc57282f", "commit_date": "Sat Nov 14 12:19:25 2020 -0500", "commit_message": "try with unlimited connect_timeout", "files_name": ["tests/test_files.py"]}, {"commit_id": "0d0ac3c5badd2371ed06b55405b829668d50c607", "commit_date": "Sat Nov 14 12:13:53 2020 -0500", "commit_message": "just connect_timeout", "files_name": ["tests/test_files.py"]}, {"commit_id": "631e07553a692a128dc4808800a39bf52dfc4ac1", "commit_date": "Sat Nov 14 12:10:59 2020 -0500", "commit_message": "rever winpty, try longer request timeouts", "files_name": ["setup.py", "tests/test_files.py"]}, {"commit_id": "b86e72d1828a6282eb313473db1d8373d201f77b", "commit_date": "Sat Nov 14 11:35:40 2020 -0500", "commit_message": "fix pywinpty name", "files_name": ["setup.py"]}, {"commit_id": "d026e8357af6a668dc9ebcbe8d11b6ece97eafaa", "commit_date": "Sat Nov 14 11:25:57 2020 -0500", "commit_message": "try adding winpty", "files_name": ["setup.py"]}, {"commit_id": "ba40f81fb45da336f9ef5b3413203e555722e927", "commit_date": "Sat Nov 14 10:33:34 2020 -0500", "commit_message": "log some more", "files_name": ["tests/test_files.py"]}, {"commit_id": "47f07a495b8d0c940f249ee70b0d767fd72894c7", "commit_date": "Sat Nov 14 10:24:03 2020 -0500", "commit_message": "paramaterize (un)hidden file tests", "files_name": [".github/workflows/main.yml", "tests/test_files.py"]}, {"commit_id": "02579a7304ea6c74d7402e692cb28c8d428b29bc", "commit_date": "Fri Nov 13 21:06:16 2020 -0500", "commit_message": "collect coverage", "files_name": [".github/workflows/main.yml"]}, {"commit_id": "3c99dff0e79f4cb0a7d42e4fc861d7e05adce088", "commit_date": "Fri Nov 13 21:00:42 2020 -0500", "commit_message": "fix workflow", "files_name": [".github/workflows/main.yml"]}, {"commit_id": "fd94f12cff0990b3ae3196907dab95eeb63422ef", "commit_date": "Fri Nov 13 20:59:41 2020 -0500", "commit_message": "inject server config properly", "files_name": [".github/workflows/main.yml", "examples/simple/README.md", "examples/simple/tests/test_handlers.py"]}, {"commit_id": "d925e670e0a904a8b75d2412056b951e924bc2c7", "commit_date": "Fri Nov 13 20:30:41 2020 -0500", "commit_message": "recursive-include to grab spec.yaml", "files_name": ["MANIFEST.in"]}, {"commit_id": "20ec9ecfffd62ce8708f60dadc5833dbd3549b35", "commit_date": "Fri Nov 13 20:23:28 2020 -0500", "commit_message": "add some more ci trappings", "files_name": [".github/workflows/main.yml"]}, {"commit_id": "933b4f55bd93a5b7018484878e7ed224b577d899", "commit_date": "Fri Nov 13 19:59:30 2020 -0500", "commit_message": "actually use renamed fixtures", "files_name": ["examples/simple/tests/test_handlers.py"]}, {"commit_id": "b96c939d97ac721dd191c573ede5dee3d6d71dbb", "commit_date": "Fri Nov 13 18:04:41 2020 -0500", "commit_message": "update fixtures in example", "files_name": ["examples/simple/tests/test_handlers.py"]}, {"commit_id": "2a3a2a0a469dffe44df7278354eaf2e11f488d85", "commit_date": "Fri Nov 13 18:00:41 2020 -0500", "commit_message": "tweak some metadata", "files_name": ["examples/simple/setup.py"]}, {"commit_id": "d7709fa25f6c5b38e6e94a96f7ecc1b84da519e0", "commit_date": "Fri Nov 13 17:58:21 2020 -0500", "commit_message": "remove un-needed conftest.py", "files_name": ["examples/simple/tests/conftest.py"]}, {"commit_id": "c076f84a49b8cb17c874a0cc426b4ff1ea3b3d14", "commit_date": "Fri Nov 13 17:57:16 2020 -0500", "commit_message": "merge master", "files_name": ["fcf30702000ef6ff55047ce4067dded08e7a6c5e - Fri Nov 13 13:25:21 2020 -0800 : Merge pull request #335 from kevin-bates/remove-pytest-plugins", "e7002ac54b68b61264fce847f41d5a28936e513c - Fri Nov 13 12:42:38 2020 -0800 : More CodeQL corrections", "tests/nbconvert/test_handlers.py", "tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/nbconvert/test_api.py", "tests/test_files.py"]}, {"commit_id": "e394bdc44a391b5f7f7737f802e458a8d0c63893", "commit_date": "Fri Nov 13 09:22:46 2020 -0800", "commit_message": "Adjust skip when pandoc is not available", "files_name": ["tests/nbconvert/test_handlers.py"]}, {"commit_id": "6cf530ee01a03518b6af72478582b30c018dd4b4", "commit_date": "Fri Nov 13 08:23:03 2020 -0800", "commit_message": "Remove unused imports/variables", "files_name": ["tests/services/config/test_api.py", "tests/services/kernels/test_api.py", "tests/services/nbconvert/test_api.py", "tests/test_files.py"]}, {"commit_id": "aabf8de64f7617731f0c6a36215b74ae4c480788", "commit_date": "Fri Nov 13 08:08:03 2020 -0800", "commit_message": "remove nose and pytest-tornasync refs", "files_name": ["setup.py"]}, {"commit_id": "f35144d9359f59d2f3ae814d4cc4ede81a37a567", "commit_date": "Fri Nov 13 01:03:45 2020 -0500", "commit_message": "add conftest to example", "files_name": ["examples/simple/tests/conftest.py"]}, {"commit_id": "ec6a9c666bc393a62d49713113dd5a4dd373a65b", "commit_date": "Fri Nov 13 00:29:25 2020 -0500", "commit_message": "try dotted import", "files_name": ["tests/conftest.py"]}, {"commit_id": "36173446ae50d8926eabe9e1abc991d1545da336", "commit_date": "Fri Nov 13 00:22:56 2020 -0500", "commit_message": "remote pytest11 entrypoint", "files_name": ["setup.py"]}, {"commit_id": "61ab548bf9186ab7323d8fa7bd0e12ae23555a28", "commit_date": "Thu Nov 12 16:37:48 2020 -0800", "commit_message": "Address open redirect vulnerability", "files_name": ["jupyter_server/base/handlers.py", "tests/test_paths.py"]}, {"commit_id": "505140f96f27c105c2cd4cb38d9afdf4ff4b34d6", "commit_date": "Wed Nov 11 17:37:52 2020 -0800", "commit_message": "Merge pull request #334 from jasongrout/quit", "files_name": ["f5fa53dfff282830eb48609febac640750dcc048 - Wed Nov 11 16:49:08 2020 -0800 : Make the help for quit_button more generic.", "docs/source/other/full-config.rst", "jupyter_server/serverapp.py"]}, {"commit_id": "b39ace91441fa04e40fa94ad413505da02917f48", "commit_date": "Sat Nov 7 14:35:32 2020 -0800", "commit_message": "Switch fixtures to use those in pytest-jupyter", "files_name": ["setup.py", "tests/conftest.py", "tests/extension/conftest.py", "tests/extension/test_app.py", "tests/extension/test_config.py", "tests/extension/test_entrypoint.py", "tests/extension/test_handler.py", "tests/extension/test_manager.py", "tests/extension/test_serverextension.py", "tests/extension/test_utils.py", "tests/nbconvert/test_handlers.py", "tests/services/api/test_api.py", "tests/services/config/test_api.py", "tests/services/contents/test_api.py", "tests/services/contents/test_config.py", "tests/services/contents/test_fileio.py", "tests/services/contents/test_largefilemanager.py", "tests/services/contents/test_manager.py", "tests/services/kernels/test_api.py", "tests/services/kernels/test_config.py", "tests/services/kernelspecs/test_api.py", "tests/services/nbconvert/test_api.py", "tests/services/sessions/test_api.py", "tests/test_files.py", "tests/test_gateway.py", "tests/test_serverapp.py", "tests/test_terminal.py", "tests/test_version.py"]}, {"commit_id": "38712f9a99c5a3744eec08b66ca87d2194b041ee", "commit_date": "Thu Nov 5 12:05:56 2020 -0800", "commit_message": "Enable CodeQL runs on all pushed branches", "files_name": [".github/workflows/codeql-analysis.yml"]}, {"commit_id": "a4090561ec4be3aef382b93dfefb7d96b62430ed", "commit_date": "Thu Nov 5 20:16:17 2020 +0100", "commit_message": "Merge pull request #332 from jupyter/jasongrout-patch-1", "files_name": ["f3d42ac57f7ab5830958ae001972c20a497e57c3 - Thu Nov 5 10:47:50 2020 -0800 : Create codeql-analysis.yml", ".github/workflows/codeql-analysis.yml"]}, {"commit_id": "26efa1b3385dca0a426a69dcb9485ece5deb1b6c", "commit_date": "Thu Nov 5 10:43:39 2020 -0800", "commit_message": "Merge pull request #331 from farisachugthai/imports", "files_name": ["27fbb5b2bf510c861c9be41849ceca507d79f77e - Thu Nov 5 11:30:10 2020 -0500 : Remove a few more unused imports", "tests/test_config_manager.py", "tests/test_files.py", "tests/test_serverapp.py"]}, {"commit_id": "b76acb81d20c411113fdd880c1d354d3d6c823b9", "commit_date": "Thu Nov 5 08:20:23 2020 -0800", "commit_message": "Merge pull request #326 from maartenbreddels/feat_replace_traceback", "files_name": ["d9e385c7275e2ac028a71d4f26a424cfd7fa7e7a - Wed Nov 4 17:36:21 2020 -0800 : Merge pull request #329 from Zsailer/migration-docs", "463a08cf60e58cc6b6055a83e900ed189df9a89a - Wed Nov 4 13:50:05 2020 -0800 : mention change in favicon location", "docs/source/developers/extensions.rst"]}, {"commit_id": "9d4354d5a3a3147e19142d194bf054bfa82c5cdb", "commit_date": "Wed Nov 4 13:28:41 2020 -0800", "commit_message": "server extension migration documentation", "files_name": ["docs/source/developers/extensions.rst"]}, {"commit_id": "523f19842e2b2006a623cf67703608051dd0054d", "commit_date": "Tue Nov 3 12:41:34 2020 -0800", "commit_message": "Merge pull request #328 from bollwyvl/add-wasm-mime", "files_name": ["c02adbe9f356c4e114a1b9f0492564621da60272 - Tue Nov 3 15:23:43 2020 -0500 : add wasm mime override"]}], "windows_after": [{"commit_id": "e17091698fb90db938a6a3d875b48271597a6db5", "commit_date": "Wed Nov 18 09:35:01 2020 -0800", "commit_message": "bump version to 1.0.6", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "37eac444dd08cedbcb3490490c8f3d15b81e1eff", "commit_date": "Wed Nov 18 09:56:15 2020 -0800", "commit_message": "fix test bug", "files_name": ["tests/test_paths.py"]}, {"commit_id": "782230e4a7cc838c2f35b9bd66941bdee5bb87fa", "commit_date": "Wed Nov 18 11:07:00 2020 -0800", "commit_message": "Merge pull request #345 from jupyter/1.0.x", "files_name": ["630018f6e806176dd088b996da4e6a44954ff1fd - Wed Nov 18 10:53:55 2020 -0800 : Update fixtures to use pytest-jupyter", "tests/test_paths.py"]}, {"commit_id": "b2e089506baf0723fe63112cb9df7ef8b493d093", "commit_date": "Wed Nov 18 11:57:05 2020 -0800", "commit_message": "Merge pull request #346 from kevin-bates/fix-test-trailing-slash", "files_name": ["8763b5b98cb745cc11713af20f72a1919ea2d181 - Thu Nov 19 16:05:16 2020 -0800 : set version to dev", "jupyter_server/_version.py"]}, {"commit_id": "7377a1e976302b7da14f4a3cb217af63637ed8c6", "commit_date": "Fri Nov 20 12:12:16 2020 -0800", "commit_message": "Update release instructions and dev version", "files_name": ["RELEASE.md", "jupyter_server/_version.py"]}, {"commit_id": "0584bf0a36d54803a1aaff30bc98667fd2f9dd94", "commit_date": "Fri Nov 20 13:04:43 2020 -0800", "commit_message": "Merge pull request #348 from kevin-bates/update-release-instructions", "files_name": ["bbf01baf55b60b5eedee220e718b70323c8f2c11 - Sat Nov 21 10:08:45 2020 -0800 : Merge pull request #350 from ricklamers/connect-gateway-fix", "679683c1961ad1a17e0f39bfa2d642570a2cf09b - Mon Nov 30 16:04:20 2020 -0800 : Merge pull request #343 from kevin-bates/port-5565-5588", "c45d7f3655c23d6a4717ba4c780f3775430d0a6a - Mon Nov 30 16:04:50 2020 -0800 : Merge pull request #344 from yuvipanda/prometheus-auth", "f13a22b6280ed6beba9eda90963a840369a1364c - Tue Dec 1 09:06:06 2020 -0800 : Merge pull request #333 from kevin-bates/codeql-pushed-branches", "d865e5901cae3c7723438491732441c7b265cc6a - Thu Dec 3 10:41:41 2020 -0700 : Fix upgrade packaging dependencies build step", ".github/workflows/main.yml"]}, {"commit_id": "ca492c1b8d3bfe933f47289889a542c842d46570", "commit_date": "Thu Dec 3 09:59:35 2020 -0800", "commit_message": "Merge pull request #354 from mwakaba2/fix-tests-setup", "files_name": ["20c84e8d6deca063e43f6bdbd27ecaea41af3791 - Wed Dec 9 13:21:19 2020 +0100 : sync _redirect_safe with upstream", "jupyter_server/auth/login.py", "tests/auth/test_login.py"]}, {"commit_id": "1858bb50961deec8d3aac386c5b02a965252bfa1", "commit_date": "Thu Dec 10 11:05:46 2020 -0800", "commit_message": "Restore pytest plugin from pytest-jupyter", "files_name": ["examples/simple/setup.py", "examples/simple/tests/conftest.py", "jupyter_server/pytest_plugin.py", "setup.py", "tests/conftest.py", "tests/extension/test_handler.py", "tests/extension/test_serverextension.py", "tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/kernelspecs/test_api.py", "tests/services/sessions/test_api.py", "tests/test_paths.py", "tests/utils.py"]}, {"commit_id": "28f784bbfdbb2541cac2224f5dcd625389258813", "commit_date": "Thu Dec 10 11:29:02 2020 -0800", "commit_message": "Merge pull request #360 from kevin-bates/restore-pytest-plugin", "files_name": ["1cfc2110bb529220ce8aacfc78acd39b62e178ae - Fri Oct 30 08:54:12 2020 -0600 : [DRAFT] Asynchronous Contents API", "jupyter_server/services/contents/checkpoints.py", "jupyter_server/services/contents/manager.py", "tests/services/contents/test_config.py"]}, {"commit_id": "ca60bcf84245b3ff2b672f5a2a0a3c84596296a0", "commit_date": "Thu Nov 12 11:46:20 2020 -0700", "commit_message": "Add asynchronous support section", "files_name": ["docs/source/developers/contents.rst"]}, {"commit_id": "3a97a6ab0bd2e57c7ee663c91359e731a7942034", "commit_date": "Thu Nov 12 11:46:49 2020 -0700", "commit_message": "Create AsyncFileContentsManager", "files_name": ["jupyter_server/serverapp.py", "jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/handlers.py", "jupyter_server/services/contents/manager.py", "setup.py", "tests/services/contents/test_api.py", "tests/services/contents/test_manager.py", "tests/services/kernels/test_api.py"]}, {"commit_id": "24dd61839f8629f28a6185362b73b9b4aed61fef", "commit_date": "Tue Nov 17 11:55:16 2020 -0700", "commit_message": "Use jp prefix for fixtures", "files_name": ["jupyter_server/pytest_plugin.py", "tests/services/contents/test_manager.py"]}, {"commit_id": "6bd874d5365a0ad51f2b01a53555a97a255d1d52", "commit_date": "Tue Nov 17 11:56:25 2020 -0700", "commit_message": "Remove condition for testing python 3.5", "files_name": ["tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/sessions/test_api.py"]}, {"commit_id": "5a521e305bd8c3faa6fae61bf7e470dfc05e9d52", "commit_date": "Tue Nov 17 11:59:50 2020 -0700", "commit_message": "Add new async classes to serverapp", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "0afe5b196a5be6a91215f8a3448ad3b52656d233", "commit_date": "Tue Nov 17 12:04:58 2020 -0700", "commit_message": "Fix lint errors", "files_name": ["jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/manager.py", "tests/services/contents/test_api.py", "tests/services/contents/test_config.py", "tests/services/contents/test_manager.py"]}, {"commit_id": "3bc0febc8d8df19dcf660e7ddfeb36406bdbc4f0", "commit_date": "Wed Nov 18 18:45:58 2020 -0700", "commit_message": "Skip test for windows", "files_name": ["tests/services/contents/test_manager.py"]}, {"commit_id": "9be92d81c402fe0fd31df571e45e71647330076a", "commit_date": "Fri Nov 20 10:10:05 2020 -0700", "commit_message": "Create AsyncLargeFileManager", "files_name": ["jupyter_server/services/contents/largefilemanager.py", "tests/services/contents/test_largefilemanager.py"]}, {"commit_id": "564325e9ba048c203c1cde83a47390328166821f", "commit_date": "Fri Nov 20 10:47:51 2020 -0700", "commit_message": "Create AsyncGenericFileCheckpoints", "files_name": ["jupyter_server/services/contents/filecheckpoints.py", "tests/services/contents/test_config.py"]}, {"commit_id": "188fc3c1e2c505ce6e1ce66887eb002979d7f68b", "commit_date": "Thu Dec 3 10:26:22 2020 -0700", "commit_message": "Make handlers compatible with async CMs", "files_name": ["jupyter_server/base/handlers.py", "jupyter_server/files/handlers.py", "jupyter_server/nbconvert/handlers.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/handlers.py", "jupyter_server/services/contents/largefilemanager.py", "jupyter_server/services/contents/manager.py", "jupyter_server/view/handlers.py"]}, {"commit_id": "b19edc00708cbda23311212d5f04b71262fedf27", "commit_date": "Fri Dec 4 10:21:57 2020 -0700", "commit_message": "update docs and configs", "files_name": ["docs/source/developers/contents.rst", "docs/source/other/full-config.rst"]}, {"commit_id": "01500bdafbab4452f5a3180a86c68387f0ac05e3", "commit_date": "Fri Dec 4 11:48:12 2020 -0700", "commit_message": "Checkpoints: Make all not implemented methods async", "files_name": ["jupyter_server/services/contents/checkpoints.py"]}, {"commit_id": "bd057ef13dabd47f79826124b8020f14b374cd0f", "commit_date": "Fri Dec 4 11:55:04 2020 -0700", "commit_message": "Update docs", "files_name": ["docs/source/developers/contents.rst"]}, {"commit_id": "7d863f35c9c1e5dc8a58ec8af373bbb1b5158475", "commit_date": "Thu Dec 10 10:58:22 2020 -0800", "commit_message": "Update jupyter_server/services/contents/fileio.py", "files_name": ["jupyter_server/pytest_plugin.py", "jupyter_server/services/contents/fileio.py"]}, {"commit_id": "6fef2a8f2e8b73d4db43aacc71402159b2e12fc9", "commit_date": "Thu Dec 10 15:15:57 2020 -0800", "commit_message": "Merge pull request #324 from mwakaba2/async-contents-api", "files_name": ["d05aebe015b9be1d1914c5b80b705f288e888660 - Fri Dec 11 14:23:05 2020 -0800 : update changelog for 1.1.0 release", "CHANGELOG.md"]}, {"commit_id": "082fc383661c95ccf49af6ca9aef752bd26a3a6b", "commit_date": "Fri Dec 11 14:30:12 2020 -0800", "commit_message": "remove changelog from docs to reduce duplicity", "files_name": ["CHANGELOG.md", "docs/source/developers/index.rst", "docs/source/other/changelog.rst"]}, {"commit_id": "f55926ea3c7df5baa42b262880920290fa9204ac", "commit_date": "Fri Dec 11 14:31:51 2020 -0800", "commit_message": "remove references to changelog", "files_name": ["docs/source/developers/dependency.rst", "docs/source/other/index.rst", "docs/source/users/installation.rst"]}, {"commit_id": "3bb4caa7fbd31fe9cd5b45d36e547770945e3809", "commit_date": "Fri Dec 11 14:32:21 2020 -0800", "commit_message": "Merge pull request #362 from Zsailer/changelog", "files_name": ["921508b338286d8e946c349e8512bb78770763c8 - Fri Dec 11 14:34:07 2020 -0800 : Release 1.1.0", "jupyter_server/_version.py"]}, {"commit_id": "a3a3a46b907cabd7be66c639cf161aafbf20b2e5", "commit_date": "Fri Dec 11 14:38:10 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "755471206fc2e8d62b5e46ea0e780c89ff83c7f1", "commit_date": "Tue Dec 15 09:28:00 2020 -0700", "commit_message": "Fix: await dir_exists", "files_name": ["jupyter_server/services/contents/handlers.py"]}, {"commit_id": "b328e0a98fa553d3ec4cd911b6d11bb7363ddb0f", "commit_date": "Wed Dec 16 08:58:41 2020 -0800", "commit_message": "Merge pull request #363 from mwakaba2/fix-async-contents-api", "files_name": ["85e4abccf6ea9321d29153f73b0bd72ccb3a6bca - Wed Dec 16 14:03:59 2020 -0800 : Merge pull request from GHSA-9f66-54xg-pc2c", "506e10b593b9c3bc3690b1b8cbdd6cdd2772baae - Wed Dec 16 14:08:53 2020 -0800 : Release 1.1.1", "jupyter_server/_version.py"]}, {"commit_id": "7f81846033947b2e16f716f499c8ed39c5e2dce8", "commit_date": "Wed Dec 16 14:10:16 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "14f0c8481555f8603ea4bb27a20bf813e70265c1", "commit_date": "Sat Dec 12 10:52:15 2020 +0100", "commit_message": "Nudge kernel with info request until we receive IOPub messages", "files_name": ["jupyter_server/services/kernels/handlers.py"]}, {"commit_id": "816ca645aaae966b61f7add58aa1b37b898ae229", "commit_date": "Mon Dec 21 12:53:13 2020 +0100", "commit_message": "Review", "files_name": ["jupyter_server/services/kernels/handlers.py"]}, {"commit_id": "dd567f69e819e9b5456b45261b9e831295f071f7", "commit_date": "Mon Dec 21 14:17:39 2020 -0800", "commit_message": "Merge pull request #361 from SylvainCorlay/nudge-kernel", "files_name": ["e7cefef7843876ef38ca876b58daeaf17c39c632 - Mon Dec 21 15:10:37 2020 -0800 : Release 1.1.2", "jupyter_server/_version.py"]}, {"commit_id": "c2b2c31c385ec40d16054a8a34bdefcfbc31af8e", "commit_date": "Mon Dec 21 15:12:59 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "f81521040e2096be18df4f4b4946b66e2bece992", "commit_date": "Tue Dec 22 16:34:07 2020 +0000", "commit_message": "Port over https://github.com/jupyter/notebook/pull/5355 and other fixes", "files_name": ["jupyter_server/services/kernels/kernelmanager.py", "tests/services/contents/test_api.py", "tests/services/kernels/test_api.py", "tests/services/kernels/test_cull.py", "tests/services/sessions/test_api.py"]}, {"commit_id": "29db7f93bc5110b7b95f5e99c3b5b207b5dc338e", "commit_date": "Wed Dec 23 19:16:50 2020 +0000", "commit_message": "Follow up to fix CI", "files_name": [".github/workflows/python-linux.yml", ".github/workflows/python-macos.yml", ".github/workflows/python-windows.yml"]}, {"commit_id": "d0778f95aa133c8d25502d60c323980bf89692e5", "commit_date": "Wed Dec 23 12:05:01 2020 -0800", "commit_message": "Merge pull request #365 from afshin/ensure_last_activity", "files_name": ["fde129d1c239a83cf79364cfb42be991225f1d51 - Wed Dec 23 15:06:39 2020 -0800 : Release 1.1.3", "jupyter_server/_version.py"]}, {"commit_id": "4e4ab206610208b06c8dbc71a85da9e8de92c0ae", "commit_date": "Wed Dec 23 15:07:08 2020 -0800", "commit_message": "Back to dev version", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "b82a5e03eb6df7f538d3e7e62b3e5578ad7bab4d", "commit_date": "Thu Dec 24 12:45:57 2020 -0700", "commit_message": "Update serverapp.py", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "1f5508e43a7b6004392aa13a16ad380fd6f60471", "commit_date": "Thu Dec 24 21:30:41 2020 -0800", "commit_message": "Merge pull request #367 from michaelaye/patch-1", "files_name": ["ddcfb54b4be5d71a7edd53356dbf79b8270ec764 - Sat Jan 2 11:31:15 2021 -0500 : use setuptools find_packages, exclude tests, docs and examples from distributions", "setup.py"]}, {"commit_id": "e59b4ab023731ce4f2dd187f50e62d08b17a13ca", "commit_date": "Sat Jan 2 11:43:37 2021 -0500", "commit_message": "also remove underlying deprecated wrapper", "files_name": []}], "parents": [{"commit_id_before": "505140f96f27c105c2cd4cb38d9afdf4ff4b34d6", "url_before": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/505140f96f27c105c2cd4cb38d9afdf4ff4b34d6", "html_url_before": "https://github.com/jupyter-server/jupyter_server/commit/505140f96f27c105c2cd4cb38d9afdf4ff4b34d6"}, {"commit_id_before": "61ab548bf9186ab7323d8fa7bd0e12ae23555a28", "url_before": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/61ab548bf9186ab7323d8fa7bd0e12ae23555a28", "html_url_before": "https://github.com/jupyter-server/jupyter_server/commit/61ab548bf9186ab7323d8fa7bd0e12ae23555a28"}], "details": [{"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/3d83e49090289c431da253e2bdb8dc479cbcb157/jupyter_server%2Fbase%2Fhandlers.py", "code": "\"\"\"Base Tornado handlers for the Jupyter server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport datetime\nimport functools\nimport ipaddress\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\nfrom http.client import responses\nfrom http.cookies import Morsel\nfrom urllib.parse import urlparse\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape, httputil\nfrom tornado.log import app_log\nimport prometheus_client\n\nfrom jupyter_server._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport jupyter_server\nfrom jupyter_server._tz import utcnow\nfrom jupyter_server.i18n import combine_translations\nfrom jupyter_server.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom jupyter_server.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n\n    def force_clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Tornado's cookie handling currently (Jan 2018) stores cookies in a dict\n        keyed by name, so it can only modify one cookie with a given name per\n        response. The browser can store multiple cookies with the same name\n        but different domains and/or paths. This method lets us clear multiple\n        cookies with the same name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        name = escape.native_str(name)\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n\n        morsel = Morsel()\n        morsel.set(name, '', '\"\"')\n        morsel['expires'] = httputil.format_timestamp(expires)\n        morsel['path'] = path\n        if domain:\n            morsel['domain'] = domain\n        self.add_header(\"Set-Cookie\", morsel.OutputString())\n\n    def clear_login_cookie(self):\n        cookie_options = self.settings.get('cookie_options', {})\n        path = cookie_options.setdefault('path', self.base_url)\n        self.clear_cookie(self.cookie_name, path=path)\n        if path and path != '/':\n            # also clear cookie on / to ensure old cookies are cleared\n            # after the change in path behavior.\n            # N.B. This bypasses the normal cookie handling, which can't update\n            # two cookies with the same name. See the method above.\n            self.force_clear_cookie(self.cookie_name)\n\n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == 'OPTIONS':\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n\n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n\n    @property\n    def log(self):\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n\n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n\n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n\n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n\n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n\n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n\n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n\n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n\n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n\n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n\n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n\n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(JupyterHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif (\n            self.token_authenticated\n            and \"Access-Control-Allow-Origin\" not in\n                self.settings.get('headers', {})\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n\n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(JupyterHandler, self).check_xsrf_cookie()\n\n    def check_host(self):\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get('allow_remote_access', False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        host = re.match(r'^(.*?)(:\\d+)?$', self.request.host).group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith('[') and host.endswith(']'):\n            host = host[1:-1]\n\n        try:\n            addr = ipaddress.ip_address(host)\n        except ValueError:\n            # Not an IP address: check against hostnames\n            allow = host in self.settings.get('local_hostnames', ['localhost'])\n        else:\n            allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\"Blocking request with non-local 'Host' %s (%s). \"\n                 \"If the server should be accessible at that name, \"\n                 \"set ServerApp.allow_remote_access to disable the check.\"),\n                host, self.request.host\n            )\n        return allow\n\n    def prepare(self):\n        if not self.check_host():\n            raise web.HTTPError(403)\n        return super(JupyterHandler, self).prepare()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n\n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=self.settings.get('allow_password_change'),\n            login_available=self.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            nbjs_translations=json.dumps(combine_translations(\n                self.request.headers.get('Accept-Language', ''))),\n            **self.jinja_template_vars\n        )\n\n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request') from e\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n\n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n                reply['reason'] = e.reason\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['reason'] = None\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        return user\n\n    def get_login_url(self):\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super(APIHandler, self).get_login_url()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, '_user_cache', None)\n            and self.get_argument('no_track_activity', None) is None\n        ):\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        if 'Access-Control-Allow-Headers' in self.settings.get('headers', {}):\n            self.set_header('Access-Control-Allow-Headers', self.settings['headers']['Access-Control-Allow-Headers'])\n        else:\n            self.set_header('Access-Control-Allow-Headers',\n                            'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get('Access-Control-Request-Headers', '').split(',')\n        if requested_headers and any(\n            h.strip().lower() == 'authorization'\n            for h in requested_headers\n        ) and (\n            # FIXME: it would be even better to check specifically for token-auth,\n            # but there is currently no API for this.\n            self.login_available\n        ) and (\n            self.allow_origin\n            or self.allow_origin_pat\n            or 'Access-Control-Allow-Origin' in self.settings.get('headers', {})\n        ):\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n\nclass Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super(AuthenticatedFileHandler, self).content_security_policy + \\\n                \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n\n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self):\n        return None\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root) and not self.contents_manager.allow_hidden:\n            self.log.info(\"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\")\n            raise web.HTTPError(404)\n        return abs_path\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths = {}\n\n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, string_types):\n            path = [path]\n\n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n\n    def compute_etag(self):\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n\n            cls._static_paths[path] = abspath\n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self):\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get\n\n\nclass MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self):\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get\n\n\nclass FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\nclass PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this Jupyter server\n    \"\"\"\n    @web.authenticated\n    def get(self):\n        self.set_header('Content-Type', prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n    (r'/metrics', PrometheusMetricsHandler)\n]\n", "code_before": "\"\"\"Base Tornado handlers for the Jupyter server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport datetime\nimport functools\nimport ipaddress\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\nfrom http.client import responses\nfrom http.cookies import Morsel\nfrom urllib.parse import urlparse\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape, httputil\nfrom tornado.log import app_log\nimport prometheus_client\n\nfrom jupyter_server._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport jupyter_server\nfrom jupyter_server._tz import utcnow\nfrom jupyter_server.i18n import combine_translations\nfrom jupyter_server.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom jupyter_server.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n\n    def force_clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Tornado's cookie handling currently (Jan 2018) stores cookies in a dict\n        keyed by name, so it can only modify one cookie with a given name per\n        response. The browser can store multiple cookies with the same name\n        but different domains and/or paths. This method lets us clear multiple\n        cookies with the same name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        name = escape.native_str(name)\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n\n        morsel = Morsel()\n        morsel.set(name, '', '\"\"')\n        morsel['expires'] = httputil.format_timestamp(expires)\n        morsel['path'] = path\n        if domain:\n            morsel['domain'] = domain\n        self.add_header(\"Set-Cookie\", morsel.OutputString())\n\n    def clear_login_cookie(self):\n        cookie_options = self.settings.get('cookie_options', {})\n        path = cookie_options.setdefault('path', self.base_url)\n        self.clear_cookie(self.cookie_name, path=path)\n        if path and path != '/':\n            # also clear cookie on / to ensure old cookies are cleared\n            # after the change in path behavior.\n            # N.B. This bypasses the normal cookie handling, which can't update\n            # two cookies with the same name. See the method above.\n            self.force_clear_cookie(self.cookie_name)\n\n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == 'OPTIONS':\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n\n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n\n    @property\n    def log(self):\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n\n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n\n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n\n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n\n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n\n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n\n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n\n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n\n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n\n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n\n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n\n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(JupyterHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif (\n            self.token_authenticated\n            and \"Access-Control-Allow-Origin\" not in\n                self.settings.get('headers', {})\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n\n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(JupyterHandler, self).check_xsrf_cookie()\n\n    def check_host(self):\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get('allow_remote_access', False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        host = re.match(r'^(.*?)(:\\d+)?$', self.request.host).group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith('[') and host.endswith(']'):\n            host = host[1:-1]\n\n        try:\n            addr = ipaddress.ip_address(host)\n        except ValueError:\n            # Not an IP address: check against hostnames\n            allow = host in self.settings.get('local_hostnames', ['localhost'])\n        else:\n            allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\"Blocking request with non-local 'Host' %s (%s). \"\n                 \"If the server should be accessible at that name, \"\n                 \"set ServerApp.allow_remote_access to disable the check.\"),\n                host, self.request.host\n            )\n        return allow\n\n    def prepare(self):\n        if not self.check_host():\n            raise web.HTTPError(403)\n        return super(JupyterHandler, self).prepare()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n\n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=self.settings.get('allow_password_change'),\n            login_available=self.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            nbjs_translations=json.dumps(combine_translations(\n                self.request.headers.get('Accept-Language', ''))),\n            **self.jinja_template_vars\n        )\n\n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request') from e\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n\n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n                reply['reason'] = e.reason\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['reason'] = None\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        return user\n\n    def get_login_url(self):\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super(APIHandler, self).get_login_url()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, '_user_cache', None)\n            and self.get_argument('no_track_activity', None) is None\n        ):\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        if 'Access-Control-Allow-Headers' in self.settings.get('headers', {}):\n            self.set_header('Access-Control-Allow-Headers', self.settings['headers']['Access-Control-Allow-Headers'])\n        else:\n            self.set_header('Access-Control-Allow-Headers',\n                            'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get('Access-Control-Request-Headers', '').split(',')\n        if requested_headers and any(\n            h.strip().lower() == 'authorization'\n            for h in requested_headers\n        ) and (\n            # FIXME: it would be even better to check specifically for token-auth,\n            # but there is currently no API for this.\n            self.login_available\n        ) and (\n            self.allow_origin\n            or self.allow_origin_pat\n            or 'Access-Control-Allow-Origin' in self.settings.get('headers', {})\n        ):\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n\nclass Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super(AuthenticatedFileHandler, self).content_security_policy + \\\n                \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n\n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self):\n        return None\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root) and not self.contents_manager.allow_hidden:\n            self.log.info(\"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\")\n            raise web.HTTPError(404)\n        return abs_path\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths = {}\n\n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, string_types):\n            path = [path]\n\n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n\n    def compute_etag(self):\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n\n            cls._static_paths[path] = abspath\n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self):\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get\n\n\nclass MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self):\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get\n\n\nclass FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\nclass PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this Jupyter server\n    \"\"\"\n    @web.authenticated\n    def get(self):\n        self.set_header('Content-Type', prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))\n\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n    (r'/metrics', PrometheusMetricsHandler)\n]\n", "patch": "@@ -776,9 +776,12 @@ class TrailingSlashHandler(web.RequestHandler):\n     \"\"\"\n \n     def get(self):\n-        uri = self.request.path.rstrip(\"/\")\n-        if uri:\n-            self.redirect('?'.join((uri, self.request.query)))\n+        path, *rest = self.request.uri.partition(\"?\")\n+        # trim trailing *and* leading /\n+        # to avoid misinterpreting repeated '//'\n+        path = \"/\" + path.strip(\"/\")\n+        new_uri = \"\".join([path, *rest])\n+        self.redirect(new_uri)\n \n     post = put = get\n ", "file_path": "files/2020_11/27", "file_language": "py", "file_name": "jupyter_server/base/handlers.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache", "target": 0}, {"function": "def log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log", "target": 0}, {"function": "class AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n\n    def force_clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Tornado's cookie handling currently (Jan 2018) stores cookies in a dict\n        keyed by name, so it can only modify one cookie with a given name per\n        response. The browser can store multiple cookies with the same name\n        but different domains and/or paths. This method lets us clear multiple\n        cookies with the same name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        name = escape.native_str(name)\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n\n        morsel = Morsel()\n        morsel.set(name, '', '\"\"')\n        morsel['expires'] = httputil.format_timestamp(expires)\n        morsel['path'] = path\n        if domain:\n            morsel['domain'] = domain\n        self.add_header(\"Set-Cookie\", morsel.OutputString())\n\n    def clear_login_cookie(self):\n        cookie_options = self.settings.get('cookie_options', {})\n        path = cookie_options.setdefault('path', self.base_url)\n        self.clear_cookie(self.cookie_name, path=path)\n        if path and path != '/':\n            # also clear cookie on / to ensure old cookies are cleared\n            # after the change in path behavior.\n            # N.B. This bypasses the normal cookie handling, which can't update\n            # two cookies with the same name. See the method above.\n            self.force_clear_cookie(self.cookie_name)\n\n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == 'OPTIONS':\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n\n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))", "target": 0}, {"function": "class JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n\n    @property\n    def log(self):\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n\n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n\n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n\n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n\n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n\n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n\n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n\n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n\n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n\n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n\n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n\n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(JupyterHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif (\n            self.token_authenticated\n            and \"Access-Control-Allow-Origin\" not in\n                self.settings.get('headers', {})\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n\n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(JupyterHandler, self).check_xsrf_cookie()\n\n    def check_host(self):\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get('allow_remote_access', False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        host = re.match(r'^(.*?)(:\\d+)?$', self.request.host).group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith('[') and host.endswith(']'):\n            host = host[1:-1]\n\n        try:\n            addr = ipaddress.ip_address(host)\n        except ValueError:\n            # Not an IP address: check against hostnames\n            allow = host in self.settings.get('local_hostnames', ['localhost'])\n        else:\n            allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\"Blocking request with non-local 'Host' %s (%s). \"\n                 \"If the server should be accessible at that name, \"\n                 \"set ServerApp.allow_remote_access to disable the check.\"),\n                host, self.request.host\n            )\n        return allow\n\n    def prepare(self):\n        if not self.check_host():\n            raise web.HTTPError(403)\n        return super(JupyterHandler, self).prepare()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n\n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=self.settings.get('allow_password_change'),\n            login_available=self.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            nbjs_translations=json.dumps(combine_translations(\n                self.request.headers.get('Accept-Language', ''))),\n            **self.jinja_template_vars\n        )\n\n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request') from e\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n\n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)", "target": 0}, {"function": "class APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n                reply['reason'] = e.reason\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['reason'] = None\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        return user\n\n    def get_login_url(self):\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super(APIHandler, self).get_login_url()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, '_user_cache', None)\n            and self.get_argument('no_track_activity', None) is None\n        ):\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        if 'Access-Control-Allow-Headers' in self.settings.get('headers', {}):\n            self.set_header('Access-Control-Allow-Headers', self.settings['headers']['Access-Control-Allow-Headers'])\n        else:\n            self.set_header('Access-Control-Allow-Headers',\n                            'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get('Access-Control-Request-Headers', '').split(',')\n        if requested_headers and any(\n            h.strip().lower() == 'authorization'\n            for h in requested_headers\n        ) and (\n            # FIXME: it would be even better to check specifically for token-auth,\n            # but there is currently no API for this.\n            self.login_available\n        ) and (\n            self.allow_origin\n            or self.allow_origin_pat\n            or 'Access-Control-Allow-Origin' in self.settings.get('headers', {})\n        ):\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))", "target": 0}, {"function": "class Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)", "target": 0}, {"function": "class AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super(AuthenticatedFileHandler, self).content_security_policy + \\\n                \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n\n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self):\n        return None\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root) and not self.contents_manager.allow_hidden:\n            self.log.info(\"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\")\n            raise web.HTTPError(404)\n        return abs_path", "target": 0}, {"function": "def json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper", "target": 0}, {"function": "class FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths = {}\n\n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, string_types):\n            path = [path]\n\n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n\n    def compute_etag(self):\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n\n            cls._static_paths[path] = abspath\n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)", "target": 0}, {"function": "class APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))", "target": 0}, {"function": "class TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self):\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get", "target": 0}, {"function": "class MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self):\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get", "target": 0}, {"function": "class FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    def get(self, path=''):\n        return self.redirect_to_files(self, path)", "target": 0}, {"function": "class RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)", "target": 0}, {"function": "class PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this Jupyter server\n    \"\"\"\n    @web.authenticated\n    def get(self):\n        self.set_header('Content-Type', prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))", "target": 0}], "function_after": [{"function": "def json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache", "target": 0}, {"function": "def log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log", "target": 0}, {"function": "class AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n\n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n\n    def force_clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Tornado's cookie handling currently (Jan 2018) stores cookies in a dict\n        keyed by name, so it can only modify one cookie with a given name per\n        response. The browser can store multiple cookies with the same name\n        but different domains and/or paths. This method lets us clear multiple\n        cookies with the same name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        name = escape.native_str(name)\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n\n        morsel = Morsel()\n        morsel.set(name, '', '\"\"')\n        morsel['expires'] = httputil.format_timestamp(expires)\n        morsel['path'] = path\n        if domain:\n            morsel['domain'] = domain\n        self.add_header(\"Set-Cookie\", morsel.OutputString())\n\n    def clear_login_cookie(self):\n        cookie_options = self.settings.get('cookie_options', {})\n        path = cookie_options.setdefault('path', self.base_url)\n        self.clear_cookie(self.cookie_name, path=path)\n        if path and path != '/':\n            # also clear cookie on / to ensure old cookies are cleared\n            # after the change in path behavior.\n            # N.B. This bypasses the normal cookie handling, which can't update\n            # two cookies with the same name. See the method above.\n            self.force_clear_cookie(self.cookie_name)\n\n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n\n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.request.method == 'OPTIONS':\n            # no origin-check on options requests, which are used to check origins!\n            return True\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n\n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))", "target": 0}, {"function": "class JupyterHandler(AuthenticatedHandler):\n    \"\"\"Jupyter-specific extensions to authenticated handling\n\n    Mostly property shortcuts to Jupyter-specific settings.\n    \"\"\"\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n\n    @property\n    def log(self):\n        \"\"\"use the Jupyter log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n\n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n\n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n\n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n\n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n\n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n\n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n\n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n\n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n\n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n\n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n\n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n\n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n\n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(JupyterHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        elif (\n            self.token_authenticated\n            and \"Access-Control-Allow-Origin\" not in\n                self.settings.get('headers', {})\n        ):\n            # allow token-authenticated requests cross-origin by default.\n            # only apply this exception if allow-origin has not been specified.\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))\n\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n\n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(JupyterHandler, self).check_xsrf_cookie()\n\n    def check_host(self):\n        \"\"\"Check the host header if remote access disallowed.\n\n        Returns True if the request should continue, False otherwise.\n        \"\"\"\n        if self.settings.get('allow_remote_access', False):\n            return True\n\n        # Remove port (e.g. ':8888') from host\n        host = re.match(r'^(.*?)(:\\d+)?$', self.request.host).group(1)\n\n        # Browsers format IPv6 addresses like [::1]; we need to remove the []\n        if host.startswith('[') and host.endswith(']'):\n            host = host[1:-1]\n\n        try:\n            addr = ipaddress.ip_address(host)\n        except ValueError:\n            # Not an IP address: check against hostnames\n            allow = host in self.settings.get('local_hostnames', ['localhost'])\n        else:\n            allow = addr.is_loopback\n\n        if not allow:\n            self.log.warning(\n                (\"Blocking request with non-local 'Host' %s (%s). \"\n                 \"If the server should be accessible at that name, \"\n                 \"set ServerApp.allow_remote_access to disable the check.\"),\n                host, self.request.host\n            )\n        return allow\n\n    def prepare(self):\n        if not self.check_host():\n            raise web.HTTPError(403)\n        return super(JupyterHandler, self).prepare()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n\n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n\n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n\n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            allow_password_change=self.settings.get('allow_password_change'),\n            login_available=self.login_available,\n            token_available=bool(self.token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            nbjs_translations=json.dumps(combine_translations(\n                self.request.headers.get('Accept-Language', ''))),\n            **self.jinja_template_vars\n        )\n\n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception as e:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request') from e\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n\n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n\n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)", "target": 0}, {"function": "class APIHandler(JupyterHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n                reply['reason'] = e.reason\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['reason'] = None\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        return user\n\n    def get_login_url(self):\n        # if get_login_url is invoked in an API handler,\n        # that means @web.authenticated is trying to trigger a redirect.\n        # instead of redirecting, raise 403 instead.\n        if not self.current_user:\n            raise web.HTTPError(403)\n        return super(APIHandler, self).get_login_url()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if (\n            self._track_activity\n            and getattr(self, '_user_cache', None)\n            and self.get_argument('no_track_activity', None) is None\n        ):\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        if 'Access-Control-Allow-Headers' in self.settings.get('headers', {}):\n            self.set_header('Access-Control-Allow-Headers', self.settings['headers']['Access-Control-Allow-Headers'])\n        else:\n            self.set_header('Access-Control-Allow-Headers',\n                            'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n\n        # if authorization header is requested,\n        # that means the request is token-authenticated.\n        # avoid browser-side rejection of the preflight request.\n        # only allow this exception if allow_origin has not been specified\n        # and Jupyter server authentication is enabled.\n        # If the token is not valid, the 'real' request will still be rejected.\n        requested_headers = self.request.headers.get('Access-Control-Request-Headers', '').split(',')\n        if requested_headers and any(\n            h.strip().lower() == 'authorization'\n            for h in requested_headers\n        ) and (\n            # FIXME: it would be even better to check specifically for token-auth,\n            # but there is currently no API for this.\n            self.login_available\n        ) and (\n            self.allow_origin\n            or self.allow_origin_pat\n            or 'Access-Control-Allow-Origin' in self.settings.get('headers', {})\n        ):\n            self.set_header('Access-Control-Allow-Origin',\n                self.request.headers.get('Origin', ''))", "target": 0}, {"function": "class Template404(JupyterHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)", "target": 0}, {"function": "class AuthenticatedFileHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the Jupyter server.\n        return super(AuthenticatedFileHandler, self).content_security_policy + \\\n                \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n\n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n\n    def compute_etag(self):\n        return None\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        Requires tornado 3.1\n\n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root) and not self.contents_manager.allow_hidden:\n            self.log.info(\"Refusing to serve hidden file, via 404 Error, use flag 'ContentsManager.allow_hidden' to enable\")\n            raise web.HTTPError(404)\n        return abs_path", "target": 0}, {"function": "def json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n\n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n\n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n\n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper", "target": 0}, {"function": "class FileFindHandler(JupyterHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n\n    # cache search results, don't search for files more than once\n    _static_paths = {}\n\n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n\n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n\n        if isinstance(path, string_types):\n            path = [path]\n\n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n\n    def compute_etag(self):\n        return None\n\n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n\n            cls._static_paths[path] = abspath\n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n\n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n\n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)", "target": 0}, {"function": "class APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\": jupyter_server.__version__}))", "target": 0}, {"function": "class TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n\n    This should be the first, highest priority handler.\n    \"\"\"\n\n    def get(self):\n        path, *rest = self.request.uri.partition(\"?\")\n        # trim trailing *and* leading /\n        # to avoid misinterpreting repeated '//'\n        path = \"/\" + path.strip(\"/\")\n        new_uri = \"\".join([path, *rest])\n        self.redirect(new_uri)\n\n    post = put = get", "target": 0}, {"function": "class MainHandler(JupyterHandler):\n    \"\"\"Simple handler for base_url.\"\"\"\n\n    def get(self):\n        html = self.render_template(\"main.html\")\n        self.write(html)\n\n    post = put = get", "target": 0}, {"function": "class FilesRedirectHandler(JupyterHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n\n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n\n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n\n    def get(self, path=''):\n        return self.redirect_to_files(self, path)", "target": 0}, {"function": "class RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)", "target": 0}, {"function": "class PrometheusMetricsHandler(JupyterHandler):\n    \"\"\"\n    Return prometheus metrics for this Jupyter server\n    \"\"\"\n    @web.authenticated\n    def get(self):\n        self.set_header('Content-Type', prometheus_client.CONTENT_TYPE_LATEST)\n        self.write(prometheus_client.generate_latest(prometheus_client.REGISTRY))", "target": 0}]}, {"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/3d83e49090289c431da253e2bdb8dc479cbcb157/tests%2Ftest_paths.py", "code": "import re\nimport pytest\nimport tornado\nfrom jupyter_server.base.handlers import path_regex\n\n\n# build regexps that tornado uses:\npath_pat = re.compile('^' + '/x%s' % path_regex + '$')\n\ndef test_path_regex():\n    for path in (\n        '/x',\n        '/x/',\n        '/x/foo',\n        '/x/foo.ipynb',\n        '/x/foo/bar',\n        '/x/foo/bar.txt',\n    ):\n        assert re.match(path_pat, path)\n\ndef test_path_regex_bad():\n    for path in (\n        '/xfoo',\n        '/xfoo/',\n        '/xfoo/bar',\n        '/xfoo/bar/',\n        '/x/foo/bar/',\n        '/x//foo',\n        '/y',\n        '/y/x/foo',\n    ):\n        assert re.match(path_pat, path) is None\n\n\n@pytest.mark.parametrize(\n    'uri,expected',\n    [\n        (\"/notebooks/mynotebook/\", \"/notebooks/mynotebook\"),\n        (\"////foo///\", \"/foo\"),\n        (\"//example.com/\", \"/example.com\"),\n        (\"/has/param/?hasparam=true\", \"/has/param?hasparam=true\"),\n    ]\n)\nasync def test_trailing_slash(uri, expected, http_server_client, auth_header, base_url):\n    # http_server_client raises an exception when follow_redirects=False\n    with pytest.raises(tornado.httpclient.HTTPClientError) as err:\n        await http_server_client.fetch(\n            uri,\n            headers=auth_header,\n            request_timeout=20,\n            follow_redirects=False\n        )\n    # Capture the response from the raised exception value.\n    response = err.value.response\n    assert response.code == 302\n    assert \"Location\" in response.headers\n    assert response.headers[\"Location\"] == expected\n    assert False\n", "code_before": "import re\nimport pytest\nimport tornado\nfrom jupyter_server.base.handlers import path_regex\n\n\n# build regexps that tornado uses:\npath_pat = re.compile('^' + '/x%s' % path_regex + '$')\n\ndef test_path_regex():\n    for path in (\n        '/x',\n        '/x/',\n        '/x/foo',\n        '/x/foo.ipynb',\n        '/x/foo/bar',\n        '/x/foo/bar.txt',\n    ):\n        assert re.match(path_pat, path)\n\ndef test_path_regex_bad():\n    for path in (\n        '/xfoo',\n        '/xfoo/',\n        '/xfoo/bar',\n        '/xfoo/bar/',\n        '/x/foo/bar/',\n        '/x//foo',\n        '/y',\n        '/y/x/foo',\n    ):\n        assert re.match(path_pat, path) is None\n\n\n@pytest.mark.parametrize(\n    'uri,expected',\n    [\n        (\"/notebooks/mynotebook/\", \"/notebooks/mynotebook\"),\n        (\"////foo///\", \"/foo\"),\n        (\"//example.com/\", \"/example.com\"),\n        (\"/has/param/?hasparam=true\", \"/has/param?hasparam=true\"),\n    ]\n)\nasync def test_trailing_slash(uri, expected, http_server_client, auth_header, base_url):\n    # http_server_client raises an exception when follow_redirects=False\n    with pytest.raises(tornado.httpclient.HTTPClientError) as err:\n        await http_server_client.fetch(\n            uri,\n            headers=auth_header,\n            request_timeout=20,\n            follow_redirects=False\n        )\n    # Capture the response from the raised exception value.\n    response = err.value.response\n    assert response.code == 302\n    assert \"Location\" in response.headers\n    assert response.headers[\"Location\"] == expected\n    assert False\n", "patch": "@@ -1,5 +1,6 @@\n import re\n-\n+import pytest\n+import tornado\n from jupyter_server.base.handlers import path_regex\n \n \n@@ -29,3 +30,29 @@ def test_path_regex_bad():\n         '/y/x/foo',\n     ):\n         assert re.match(path_pat, path) is None\n+\n+\n+@pytest.mark.parametrize(\n+    'uri,expected',\n+    [\n+        (\"/notebooks/mynotebook/\", \"/notebooks/mynotebook\"),\n+        (\"////foo///\", \"/foo\"),\n+        (\"//example.com/\", \"/example.com\"),\n+        (\"/has/param/?hasparam=true\", \"/has/param?hasparam=true\"),\n+    ]\n+)\n+async def test_trailing_slash(uri, expected, http_server_client, auth_header, base_url):\n+    # http_server_client raises an exception when follow_redirects=False\n+    with pytest.raises(tornado.httpclient.HTTPClientError) as err:\n+        await http_server_client.fetch(\n+            uri,\n+            headers=auth_header,\n+            request_timeout=20,\n+            follow_redirects=False\n+        )\n+    # Capture the response from the raised exception value.\n+    response = err.value.response\n+    assert response.code == 302\n+    assert \"Location\" in response.headers\n+    assert response.headers[\"Location\"] == expected\n+    assert False", "file_path": "files/2020_11/28", "file_language": "py", "file_name": "tests/test_paths.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_path_regex():\n    for path in (\n        '/x',\n        '/x/',\n        '/x/foo',\n        '/x/foo.ipynb',\n        '/x/foo/bar',\n        '/x/foo/bar.txt',\n    ):\n        assert re.match(path_pat, path)", "target": 0}, {"function": "def test_path_regex_bad():\n    for path in (\n        '/xfoo',\n        '/xfoo/',\n        '/xfoo/bar',\n        '/xfoo/bar/',\n        '/x/foo/bar/',\n        '/x//foo',\n        '/y',\n        '/y/x/foo',\n    ):\n        assert re.match(path_pat, path) is None", "target": 0}], "function_after": [{"function": "def test_path_regex():\n    for path in (\n        '/x',\n        '/x/',\n        '/x/foo',\n        '/x/foo.ipynb',\n        '/x/foo/bar',\n        '/x/foo/bar.txt',\n    ):\n        assert re.match(path_pat, path)", "target": 0}, {"function": "def test_path_regex_bad():\n    for path in (\n        '/xfoo',\n        '/xfoo/',\n        '/xfoo/bar',\n        '/xfoo/bar/',\n        '/x/foo/bar/',\n        '/x//foo',\n        '/y',\n        '/y/x/foo',\n    ):\n        assert re.match(path_pat, path) is None", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
