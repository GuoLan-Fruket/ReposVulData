{"index": 6700, "cve_id": "CVE-2021-43777", "cwe_id": ["CWE-352", "CWE-601"], "cve_language": "Python", "cve_description": "Redash is a package for data visualization and sharing. In Redash version 10.0 and prior, the implementation of Google Login (via OAuth) incorrectly uses the `state` parameter to pass the next URL to redirect the user to after login. The `state` parameter should be used for a Cross-Site Request Forgery (CSRF) token, not a static and easily predicted value. This vulnerability does not affect users who do not use Google Login for their instance of Redash. A patch in the `master` and `release/10.x.x` branches addresses this by replacing `Flask-Oauthlib` with `Authlib` which automatically provides and validates a CSRF token for the state variable. The new implementation stores the next URL on the user session object. As a workaround, one may disable Google Login to mitigate the vulnerability.", "cvss": "6.1", "publish_date": "November 24, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "da696ff7f84787cbf85967460fac52886cbe063e", "commit_message": "Merge pull request from GHSA-vhc7-w7r8-8m34\n\n* WIP: break the flask_oauthlib behavior\n\n* Refactor google-oauth to use cryptographic state.\n\n* Clean up comments\n\n* Fix: tests didn't pass because of the scope issues.\n\nMoved outside the create_blueprint method because this does not depend\non the Authlib object.\n\n* Apply Arik's fixes. Tests pass.", "commit_date": "2021-11-23T22:22:02Z", "project": "getredash/redash", "url": "https://api.github.com/repos/getredash/redash/commits/da696ff7f84787cbf85967460fac52886cbe063e", "html_url": "https://github.com/getredash/redash/commit/da696ff7f84787cbf85967460fac52886cbe063e", "windows_before": [{"commit_id": "ed654a7b78dd791779ba61e884100af4d76e1c97", "commit_date": "Fri Nov 19 00:00:48 2021 +0900", "commit_message": "Speed up BigQuery schema fetching (#5632)", "files_name": ["redash/query_runner/big_query.py"]}, {"commit_id": "3d032b69e59bc449e4f6da43b380f329072cc897", "commit_date": "Wed Nov 17 20:28:57 2021 +0530", "commit_message": "Update Readme to reflect Firebolt data source (#5649)", "files_name": ["README.md"]}, {"commit_id": "86514207a38cbb1e96570568770a58416644c372", "commit_date": "Mon Nov 15 16:43:51 2021 -0500", "commit_message": "Fix TypeScript warning: integet -> integer typo (#5637)", "files_name": ["viz-lib/src/visualizations/table/getOptions.ts", "viz-lib/src/visualizations/visualizationsSettings.tsx"]}, {"commit_id": "2e67227f1bb6068c3f23bc044ad76ef7d4bccdc7", "commit_date": "Thu Oct 28 15:55:48 2021 -0400", "commit_message": "Typo(#5636)", "files_name": ["Dockerfile"]}, {"commit_id": "86b2c4d06e38dd7457b530bd78a73eccb161a711", "commit_date": "Thu Oct 21 15:27:55 2021 -0500", "commit_message": "Bump master to 11.0.0-dev (#5631)", "files_name": ["package.json", "redash/__init__.py"]}, {"commit_id": "3c248acf21e5808511da642553e9a3d442482703", "commit_date": "Thu Oct 21 11:25:30 2021 -0500", "commit_message": "Fix: pagination is broken on the dashboard list page (#5612)", "files_name": ["CHANGELOG.md", "redash/models/__init__.py", "tests/models/test_dashboards.py"]}, {"commit_id": "39ca71c35606862a8fc0a9d8906e83dc5a360d89", "commit_date": "Mon Oct 18 22:56:10 2021 +0530", "commit_message": "Fixes issue #5622 (#5623)", "files_name": ["redash/query_runner/sqlite.py"]}, {"commit_id": "143d22db04a9058966b8c7d678b06f228b937326", "commit_date": "Thu Oct 14 23:27:12 2021 +0530", "commit_message": "Add support for Firebolt Database (#5606)", "files_name": ["client/app/assets/images/db-logos/firebolt.png", "redash/query_runner/firebolt.py", "redash/settings/__init__.py", "requirements_all_ds.txt"]}, {"commit_id": "7cac149cef70263b328049cb376c7f25f7b03efb", "commit_date": "Sat Oct 2 06:22:44 2021 +0900", "commit_message": "Fix: Specify the protobuf version (#5608)", "files_name": ["requirements_all_ds.txt"]}, {"commit_id": "a0a28b09b4064894c63560dad9ab7f841fbfbd4d", "commit_date": "Fri Sep 24 13:12:04 2021 -0600", "commit_message": "Guard against empty totalProcessedBytes in BigQuery responses (#5592)", "files_name": ["redash/query_runner/big_query.py"]}, {"commit_id": "e9bcc3c9243efbe1af922f918b5367fba9860172", "commit_date": "Mon Aug 30 02:43:00 2021 -0500", "commit_message": "Fix: Edit Source button disappeared for users without CanEdit perms (#5568)", "files_name": ["client/app/pages/queries/components/QueryPageHeader.jsx"]}, {"commit_id": "380345bb08a044b24a1725392ea6c1eb53678a7d", "commit_date": "Wed Aug 18 21:04:46 2021 +0300", "commit_message": "Pin python3 image version (#5570)", "files_name": ["Dockerfile"]}, {"commit_id": "0f41f2572060600301a31ac3654dff09395f5ab4", "commit_date": "Wed Aug 11 01:31:26 2021 +0900", "commit_message": "Fix: log message for bad auth token was malformed (#5557)", "files_name": ["redash/handlers/authentication.py"]}, {"commit_id": "7445080d1a26b7dd359b8d592f831ab9afa07663", "commit_date": "Mon Aug 2 13:16:33 2021 +0300", "commit_message": "Use Yarn instead of NPM (#5541)", "files_name": [".circleci/Dockerfile.cypress", ".circleci/config.yml", ".nvmrc", ".yarn/.gitignore", ".yarnrc", "Dockerfile", "Makefile", "client/cypress/cypress.js", "netlify.toml", "package-lock.json", "package.json", "viz-lib/package-lock.json", "viz-lib/package.json", "viz-lib/yarn.lock", "yarn.lock"]}, {"commit_id": "b9cb8191f524e9fb12907f96e8eb67ba420d43a2", "commit_date": "Wed Jul 28 05:27:09 2021 +0900", "commit_message": "Excel & CSV query runner (#2478)", "files_name": ["client/app/assets/images/db-logos/excel.png", "redash/query_runner/csv.py", "redash/query_runner/excel.py", "redash/settings/__init__.py", "requirements_all_ds.txt"]}, {"commit_id": "ff7c5e83673d04a726309cb1873cce75fc54e67b", "commit_date": "Tue Jun 15 17:41:36 2021 +0300", "commit_message": "remove redundant fields from slack alert destination (#5514)", "files_name": ["redash/destinations/slack.py"]}, {"commit_id": "041b184d37caaa5d40e8ecd47fab6b9e45a25e1d", "commit_date": "Fri May 14 21:52:29 2021 +0800", "commit_message": "README.md: Add TiDB to the Supported Data Sources (#5477)", "files_name": ["README.md"]}, {"commit_id": "5085495dd4564058b35e2a424dc62dd9dabe02d6", "commit_date": "Fri May 14 16:48:10 2021 +0300", "commit_message": "Refine Dockerfile caching (#5484)", "files_name": ["Dockerfile"]}, {"commit_id": "e62de4e4c32b1e8647a9c2201a2ad282638508ce", "commit_date": "Fri May 14 22:47:38 2021 +0900", "commit_message": "fix big_query.py google api import error (#5482)", "files_name": ["redash/query_runner/big_query.py"]}, {"commit_id": "8cac6b555cbad967f345cc2ae3f3b6d8ee50000c", "commit_date": "Fri May 14 13:45:43 2021 +0000", "commit_message": "Use the correct rq connection in `get_queues_status` (#5491)", "files_name": ["redash/monitor.py"]}, {"commit_id": "e4e567bbb945939687b3f94ba89daee2daf8d1ed", "commit_date": "Fri May 14 09:25:52 2021 -0400", "commit_message": "Fixing failure report rendering (#5492)", "files_name": ["redash/utils/__init__.py", "tests/test_utils.py"]}, {"commit_id": "8e728308ab34c38f563b64ae4ba807d8e8d9fe07", "commit_date": "Fri May 14 16:07:30 2021 +0300", "commit_message": "SFS-001: Adding support for the optional host connection property (#5490)", "files_name": ["redash/query_runner/snowflake.py"]}, {"commit_id": "7ec86cf4bd37152bde73f99e8f63d22932a5b70e", "commit_date": "Mon May 10 21:36:34 2021 +0300", "commit_message": "Expire sessions after 6 hours of inactivity (#5159)", "files_name": ["redash/authentication/__init__.py", "redash/settings/__init__.py", "redash/templates/login.html"]}, {"commit_id": "1c3f724f3ef97559a5d5f443093bb9516dd6fc8b", "commit_date": "Thu May 6 02:56:34 2021 +0300", "commit_message": "use ptpython instead of standard python shell (#5483)", "files_name": ["redash/cli/__init__.py", "requirements_dev.txt"]}, {"commit_id": "9c8c1bfa9ade90eb147bfcda75e5f9e95b691e42", "commit_date": "Mon Apr 26 12:02:47 2021 -0500", "commit_message": "Adds rate limit to /forgot. (#5425)", "files_name": ["redash/handlers/authentication.py", "redash/settings/__init__.py", "tests/handlers/test_authentication.py"]}, {"commit_id": "f21f7e211ff5fe12c850a9627cfadb80a5a8819e", "commit_date": "Thu Apr 22 05:01:57 2021 +0900", "commit_message": "Athena: skip tables with no StorageDescriptor (#5447)", "files_name": ["redash/query_runner/athena.py", "tests/query_runner/test_athena.py"]}, {"commit_id": "a70eeb95305b038d4d96c9ae1664faf1afc20357", "commit_date": "Mon Apr 19 14:45:52 2021 -0700", "commit_message": "Query Runner: SPARQL Endpoint Data Source (#5469)", "files_name": ["client/app/assets/images/db-logos/sparql_endpoint.png", "redash/query_runner/sparql_endpoint.py", "redash/settings/__init__.py"]}, {"commit_id": "427c005c044666c2bf1d04598e877b9a07ac3c6c", "commit_date": "Mon Apr 19 09:30:46 2021 -0300", "commit_message": "Replace hardcoded ids with hook (#5444)", "files_name": ["client/app/components/CreateSourceDialog.jsx", "client/app/components/EditParameterSettingsDialog.jsx", "client/app/components/dashboards/AddWidgetDialog.jsx", "client/app/components/queries/ApiKeyDialog/index.jsx", "client/app/components/queries/EmbedQueryDialog.jsx", "client/app/components/query-snippets/QuerySnippetDialog.jsx", "client/app/components/visualizations/EditVisualizationDialog.jsx", "client/app/pages/admin/OutdatedQueries.jsx", "client/app/pages/users/components/ApiKeyForm.jsx", "client/app/pages/users/components/CreateUserDialog.jsx"]}, {"commit_id": "d8d7c78992e44a4b6d7fdd4c39ccc1c35cd8c7a9", "commit_date": "Sat Apr 10 16:43:58 2021 -0300", "commit_message": "Replace `<a>` and `<button>` with `<PlainButton>` (#5433)", "files_name": ["client/app/assets/less/inc/schema-browser.less", "client/app/components/ApplicationArea/ApplicationLayout/DesktopNavbar.jsx", "client/app/components/EditVisualizationButton/QueryControlDropdown.jsx", "client/app/components/FavoritesControl.jsx", "client/app/components/HelpTrigger.jsx", "client/app/components/InputWithCopy.jsx", "client/app/components/Parameters.jsx", "client/app/components/PermissionsEditorDialog/index.jsx", "client/app/components/QuerySelector.jsx", "client/app/components/TagsList.tsx", "client/app/components/Tooltip.tsx", "client/app/components/dashboards/dashboard-widget/VisualizationWidget.jsx", "client/app/components/dashboards/dashboard-widget/Widget.jsx", "client/app/components/empty-state/EmptyState.jsx", "client/app/components/queries/AddToDashboardDialog.jsx", "client/app/components/queries/SchedulePhrase.jsx", "client/app/components/queries/SchemaBrowser.jsx", "client/app/components/tags-control/TagsControl.jsx", "client/app/pages/alert/components/AlertDestinations.jsx", "client/app/pages/alert/components/MenuButton.jsx", "client/app/pages/alert/components/Query.jsx", "client/app/pages/dashboards/components/DashboardHeader.jsx", "client/app/pages/data-sources/DataSourcesList.jsx", "client/app/pages/destinations/DestinationsList.jsx", "client/app/pages/home/Home.jsx", "client/app/pages/queries/QueryView.jsx", "client/app/pages/queries/components/QueryVisualizationTabs.jsx", "client/app/pages/query-snippets/QuerySnippetsList.jsx"]}, {"commit_id": "23ced5db5023a5063f4a2d4c9844b4397515c7a3", "commit_date": "Sat Apr 10 13:00:15 2021 -0300", "commit_message": "fix: treat possibly empty hrefs (#5468)", "files_name": ["client/app/components/PlainButton.tsx", "client/app/components/cards-list/CardsList.tsx", "client/app/components/empty-state/EmptyState.jsx"]}, {"commit_id": "f018c0a7b72a3727e1b01d5aa2ab99b731124b96", "commit_date": "Fri Apr 9 15:34:42 2021 -0300", "commit_message": "fix: rollback pip version to avoid legacy resolver problem (#5467)", "files_name": ["Dockerfile"]}, {"commit_id": "67263e1b0fbc3f625e9ef9aacc13464edb1bd720", "commit_date": "Thu Apr 8 13:32:34 2021 -0500", "commit_message": "Fixes issue #5445: Scheduled query not working (#5448)", "files_name": ["redash/handlers/query_results.py", "redash/tasks/queries/execution.py", "redash/tasks/queries/maintenance.py", "tests/tasks/test_queries.py", "tests/tasks/test_refresh_queries.py", "tests/tasks/test_worker.py"]}, {"commit_id": "bb1f8cbcf5d2d64676be5e1d35256f460da36c0f", "commit_date": "Wed Apr 7 09:50:54 2021 -0300", "commit_message": "Fix Ace editor keyboard trap (#5451)", "files_name": ["client/app/components/queries/QueryEditor/index.jsx", "client/app/lib/accessibility.ts"]}, {"commit_id": "a61a25dd3224c7ed97da711fe42667f0647d3f20", "commit_date": "Wed Mar 31 16:44:19 2021 -0300", "commit_message": "Run prettier (#5436)", "files_name": ["client/app/components/ApplicationArea/routeWithUserSession.tsx", "viz-lib/package.json", "viz-lib/src/components/ColorPicker/Input.tsx", "viz-lib/src/components/ColorPicker/Label.tsx", "viz-lib/src/components/ColorPicker/Swatch.tsx", "viz-lib/src/components/ColorPicker/index.tsx", "viz-lib/src/components/ErrorBoundary.tsx", "viz-lib/src/components/TextAlignmentSelect/index.tsx", "viz-lib/src/components/json-view-interactive/JsonViewInteractive.tsx", "viz-lib/src/components/visualizations/editor/ContextHelp.tsx", "viz-lib/src/components/visualizations/editor/Section.tsx", "viz-lib/src/components/visualizations/editor/Switch.tsx", "viz-lib/src/components/visualizations/editor/TextArea.tsx", "viz-lib/src/components/visualizations/editor/createTabbedEditor.tsx", "viz-lib/src/components/visualizations/editor/withControlLabel.tsx", "viz-lib/src/lib/value-format.tsx", "viz-lib/src/visualizations/Editor.tsx"]}], "windows_after": [{"commit_id": "ce60d20c4e3d1537581f2f70f1308fe77ab6a214", "commit_date": "Tue Nov 23 16:57:24 2021 -0600", "commit_message": "Merge pull request from GHSA-g8xr-f424-h2rv", "files_name": ["docker-compose.yml", "redash/settings/__init__.py", "requirements.txt"]}, {"commit_id": "61bbb5aa7a23a93f2f93710005f71bc972826099", "commit_date": "Tue Nov 23 16:58:20 2021 -0600", "commit_message": "Merge pull request from GHSA-fcpv-hgq6-87h7", "files_name": ["redash/query_runner/__init__.py", "redash/query_runner/csv.py", "redash/query_runner/excel.py", "redash/query_runner/json_ds.py", "redash/utils/requests_session.py", "requirements_all_ds.txt", "tests/query_runner/test_http.py"]}, {"commit_id": "7487550ad76de5b92f04ddc263f614ab6ad78705", "commit_date": "Tue Nov 23 17:24:31 2021 -0600", "commit_message": "Update changelog to incorporate security fixes and #5632 & #5606 (#5654)", "files_name": ["CHANGELOG.md"]}, {"commit_id": "df472eb1d444e4e8389d2bf1d7251a5f1db6d3ae", "commit_date": "Fri Nov 26 18:15:10 2021 -0600", "commit_message": "Update CircleCI configs and move advocate to main requirements file (#5658)", "files_name": [".circleci/docker-compose.circle.yml", ".circleci/docker-compose.cypress.yml", "requirements.txt", "requirements_all_ds.txt"]}, {"commit_id": "64586500a7c550fda1c2c3324741f72e97239c86", "commit_date": "Wed Dec 15 13:05:52 2021 +0900", "commit_message": "Improve BigQuery schema fetching when environment contains 50+ datasets (#5667)", "files_name": ["redash/query_runner/big_query.py"]}, {"commit_id": "965db26cabfc0de83f65c91439092ed94db4de4a", "commit_date": "Thu Dec 16 16:50:13 2021 +0800", "commit_message": "Fix\"Unable to locate package msodbcsql17\"on M1 (#5638)", "files_name": ["Dockerfile"]}, {"commit_id": "8ef9a1d3986ec90f89f8f9d859a11a943636cf97", "commit_date": "Wed Jan 19 10:17:27 2022 -0800", "commit_message": "Fix: make plotly charts have unbounded hoverlabel name length (#5661)", "files_name": ["viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/box-single-axis.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/box-with-second-axis.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/default-single-axis.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/default-with-second-axis.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/default-with-stacking.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/default-without-legend.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/pie-multiple-series.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/pie-without-annotations.json", "viz-lib/src/visualizations/chart/plotly/fixtures/prepareLayout/pie.json", "viz-lib/src/visualizations/chart/plotly/prepareLayout.ts"]}, {"commit_id": "4fddff104a050a5fe3511d9c9d863aec08bae8df", "commit_date": "Wed Jan 19 10:36:49 2022 -0800", "commit_message": "SAML auth: allow custom service provider settings from environment variable (#5621)", "files_name": ["redash/authentication/saml_auth.py", "redash/settings/organization.py"]}, {"commit_id": "e28e4227bf11b0688dc9646579647455fade419f", "commit_date": "Wed Jan 19 22:53:27 2022 +0300", "commit_message": "Python query runner: add function that transforms pandas dataframe to result format (#5629)", "files_name": ["redash/query_runner/python.py", "requirements_all_ds.txt"]}, {"commit_id": "f77f1b5ca155313d148edcfdbacddeeb5a0c7574", "commit_date": "Fri Jan 21 02:03:04 2022 +0800", "commit_message": "Fix: auto limit breaks for Oracle queries  (#5181)", "files_name": ["redash/query_runner/__init__.py", "redash/query_runner/databricks.py", "redash/query_runner/oracle.py", "redash/utils/__init__.py", "tests/query_runner/test_basesql_queryrunner.py", "tests/query_runner/test_databricks.py", "tests/query_runner/test_oracle.py", "tests/utils/test_query_limit.py"]}, {"commit_id": "2b5d1c03c1d1b6aca502f43efcb1b03b46a958db", "commit_date": "Fri Jan 21 15:43:42 2022 -0600", "commit_message": "JSON query runner: optionally skip certificate verification (#5690)", "files_name": ["redash/query_runner/json_ds.py"]}, {"commit_id": "12c475068483ba1cc2525e73ecd20843bf435922", "commit_date": "Fri Jan 28 08:52:31 2022 -0600", "commit_message": "Fix: don't accept password login requests if password auth is disabled (#5693)", "files_name": ["redash/handlers/authentication.py", "tests/test_handlers.py"]}, {"commit_id": "26ac8ab1cd56f550bef400d2db6e58f87ed2ec45", "commit_date": "Tue Feb 1 20:12:39 2022 +0530", "commit_message": "Firebolt Query Runner: now uses firebold-sdk python package (#5689)", "files_name": ["redash/query_runner/firebolt.py", "requirements_all_ds.txt"]}, {"commit_id": "ea07e7e19b62051e20f07726231d4ad3b08ab43e", "commit_date": "Tue Feb 1 21:18:07 2022 +0530", "commit_message": "Fix: Test Connection button disabled after save (#5666)", "files_name": ["client/app/components/dynamic-form/DynamicForm.jsx"]}, {"commit_id": "6797f32ea62da98742aa4b8f88e9d6aeff54a0b8", "commit_date": "Tue Feb 1 11:09:42 2022 -0600", "commit_message": "Snowflake: add option to lowercase column names (#5657)", "files_name": ["redash/query_runner/snowflake.py"]}, {"commit_id": "4164a42aabd8ba410839b7380e635e72f58297cd", "commit_date": "Wed Feb 2 08:13:40 2022 -0500", "commit_message": "Multi-filters: show all results by default (#5676)", "files_name": ["client/app/services/query-result.js", "client/cypress/integration/query/filters_spec.js"]}, {"commit_id": "49fe29579a56e7a8e206895586eca1736a6d210d", "commit_date": "Wed Feb 2 14:03:02 2022 -0600", "commit_message": "Move user profile image url into the users.details field (#5697)", "files_name": ["migrations/versions/fd4fc850d7ea_.py", "redash/models/__init__.py", "redash/models/users.py"]}, {"commit_id": "175a4da49b61253f1c5a447bbd522fced1d82a1b", "commit_date": "Thu Feb 10 01:57:25 2022 +1100", "commit_message": "Fix: Dashboard List page crashes when sorting by name (#5645)", "files_name": ["redash/models/__init__.py"]}, {"commit_id": "5de85543a57af75fecca43113f94bd456bad7f60", "commit_date": "Wed Feb 9 10:04:54 2022 -0600", "commit_message": "List pages: move sidebar to the left (#5698)", "files_name": ["client/app/components/layouts/content-with-sidebar.less", "client/app/pages/dashboards/dashboard-list.css", "client/app/pages/queries-list/queries-list.css"]}, {"commit_id": "b713f6b240970ed91fe1cfc7d6bf7eca69d9c918", "commit_date": "Wed Mar 2 10:34:52 2022 -0500", "commit_message": "Update Dockerfile CHOWN into COPY (#5660)", "files_name": ["Dockerfile"]}, {"commit_id": "e6ebef1e5ab866ce1e706eaee6260edaffdc2bd7", "commit_date": "Thu Mar 10 12:00:26 2022 -0600", "commit_message": "Update contributor guidelines and clarify PR review process (#5714)", "files_name": [".github/PULL_REQUEST_TEMPLATE.md", "CONTRIBUTING.md"]}, {"commit_id": "46ea3b1f0b263ba310de7c2c17e4a32d3ea4c343", "commit_date": "Thu Apr 28 12:20:13 2022 -0400", "commit_message": "Fix hard-coding of amd64 platform, make ARM build work. (#5687)", "files_name": [".circleci/config.yml", ".circleci/docker_build", "Dockerfile", "Makefile"]}, {"commit_id": "cabe33394bf4ea4155c6d45e779298e43a0d9e4a", "commit_date": "Wed Jun 1 09:15:18 2022 -0700", "commit_message": "[Fix] Broken image included in emails (#5719)", "files_name": ["redash/templates/emails/layout.html"]}, {"commit_id": "b2cc42e383dda5f03a193ca64e91acadf75efebc", "commit_date": "Sat Jul 2 11:13:00 2022 -0500", "commit_message": "Disable auto limit for mssql query runner (#5777)", "files_name": ["redash/query_runner/mssql_odbc.py"]}, {"commit_id": "6806ebd244c64864e03147445694ad59934d5253", "commit_date": "Sat Jul 2 14:02:38 2022 -0400", "commit_message": "Use correct names for Apache projects (#5776)", "files_name": ["README.md"]}, {"commit_id": "bdd1244604b17832cd50c19678dd0fba4e45a72e", "commit_date": "Sun Jul 3 03:02:49 2022 +0800", "commit_message": "Fix: mongodb schema refresh failed when user had insufficient permissions (#5734)", "files_name": ["redash/query_runner/mongodb.py"]}, {"commit_id": "c4bfd4f3e1328824d929d0631023054b44e28a54", "commit_date": "Sun Jul 3 12:00:56 2022 +0800", "commit_message": "mysql: add more configuration options (#5280)", "files_name": ["redash/query_runner/mysql.py"]}, {"commit_id": "fc37c1ecfcd4a5f93873f764e4fd36e8aa76ecb5", "commit_date": "Sun Jul 3 12:09:24 2022 +0800", "commit_message": "Remove unused params in query result GET handler (#5346)", "files_name": ["redash/handlers/query_results.py"]}, {"commit_id": "173cbdb2d60b5daeb9b2a46486212b5acb6ce9de", "commit_date": "Sun Jul 3 14:04:09 2022 -0400", "commit_message": "Added clear button for query-based parameter inputs (#5710)", "files_name": ["client/app/components/SelectWithVirtualScroll.tsx"]}, {"commit_id": "e2bad61e5bb526b2e898266f95973eb8fcc48bee", "commit_date": "Sun Jul 3 11:13:59 2022 -0700", "commit_message": "Add unarchive button to dashboard (#4697)", "files_name": ["client/app/pages/dashboards/components/DashboardHeader.jsx"]}, {"commit_id": "412c82940a60a71d567f463958bbb48bfeebc967", "commit_date": "Wed Jul 6 19:53:31 2022 +0800", "commit_message": "New Query Runner: Arango query runner (#5124)", "files_name": ["client/app/assets/images/db-logos/arangodb.png", "redash/query_runner/arango.py", "redash/settings/__init__.py", "requirements_all_ds.txt"]}, {"commit_id": "65f7b6c5affbcd59eb3d0dc6c6b3b6b08256db34", "commit_date": "Wed Jul 6 08:16:36 2022 -0500", "commit_message": "Sort Python safe built-ins (#5781)", "files_name": ["redash/query_runner/python.py", "tests/query_runner/test_python.py"]}, {"commit_id": "3624f8f2be40badefc053d098f793a17ec11d3ee", "commit_date": "Wed Jul 6 23:00:56 2022 +0200", "commit_message": "Feature: allow configuration / increase of gunicorn timeout (#5783)", "files_name": ["bin/docker-entrypoint", "docker-compose.yml"]}, {"commit_id": "f0a390b11a5fabb75062607e46180134ce3ee994", "commit_date": "Fri Jul 8 14:10:49 2022 -0400", "commit_message": "New Query Runner: Netezza Performance Server (#5771)", "files_name": ["client/app/assets/images/db-logos/nz.png", "redash/query_runner/nz.py", "redash/settings/__init__.py", "requirements.txt", "requirements_all_ds.txt"]}, {"commit_id": "9abc4f5f1e8ef3e644f907eb4bde1dffefc05fc4", "commit_date": "Tue Jul 12 12:27:20 2022 -0500", "commit_message": "Clickhouse: Multi-statements support (#5792)", "files_name": ["redash/query_runner/clickhouse.py", "tests/query_runner/test_clickhouse.py"]}, {"commit_id": "0712abb3590046d96d7252e7e4575875aefe5b84", "commit_date": "Fri Jul 15 15:29:28 2022 -0400", "commit_message": "README: update list of supported data sources (#5790)", "files_name": ["README.md"]}, {"commit_id": "4186f8303ee28d5cde7ca248c57df9023eba6224", "commit_date": "Wed Jul 20 07:47:44 2022 -0500", "commit_message": "New ElasticSearch Query Runner (#5794)", "files_name": ["client/app/assets/images/db-logos/elasticsearch2.png", "client/app/assets/images/db-logos/elasticsearch2_OpenDistroSQLElasticSearch.png", "client/app/assets/images/db-logos/elasticsearch2_XPackSQLElasticSearch.png", "redash/query_runner/amazon_elasticsearch.py", "redash/query_runner/elasticsearch.py", "redash/query_runner/elasticsearch2.py", "redash/settings/__init__.py", "tests/query_runner/test_elasticsearch2.py"]}, {"commit_id": "2935844e88ef87a5a4f0957026629c362c910c27", "commit_date": "Wed Aug 24 15:51:22 2022 +0200", "commit_message": "README: add MariaDB to supported data sources (#5808)", "files_name": ["README.md"]}, {"commit_id": "75cb59f4befc49cc10ceeff238c5fd0ad421b072", "commit_date": "Wed Aug 24 20:26:09 2022 +0600", "commit_message": "Databricks ODBC Driver: follow redirects (#5814)", "files_name": ["Dockerfile"]}, {"commit_id": "71458e5697e402badac28902bcc61a7f4ddac413", "commit_date": "Sat Sep 24 15:01:31 2022 +0900", "commit_message": "Fix typo in users.py (#5818)", "files_name": ["redash/cli/users.py"]}, {"commit_id": "a863c8c08c5610180a1d798fb0c0bd16e6e2633d", "commit_date": "Thu Oct 6 23:40:00 2022 -0700", "commit_message": "Adding Apache Pinot Query Runner (#5798)", "files_name": ["README.md", "client/app/assets/images/db-logos/pinot.png", "redash/query_runner/pinot.py", "redash/settings/__init__.py", "requirements_all_ds.txt"]}, {"commit_id": "328099137de07736485a28d6c2e185ac760cf0bb", "commit_date": "Thu Oct 6 23:45:03 2022 -0700", "commit_message": "Microsoft Teams Webhook alert destination (#5691)", "files_name": ["client/app/assets/images/destinations/microsoft_teams_webhook.png", "docker-compose.yml", "redash/destinations/microsoft_teams_webhook.py", "redash/settings/__init__.py"]}, {"commit_id": "5cf13afafe4a13c8db9da645d9667bc26fd118c5", "commit_date": "Thu Jan 5 05:12:16 2023 -0700", "commit_message": "Improve visibility of error message during schema retrieval (#5879)", "files_name": ["redash/query_runner/__init__.py", "redash/query_runner/athena.py", "redash/query_runner/azure_kusto.py", "redash/query_runner/big_query.py"]}], "parents": [{"commit_id_before": "ed654a7b78dd791779ba61e884100af4d76e1c97", "url_before": "https://api.github.com/repos/getredash/redash/commits/ed654a7b78dd791779ba61e884100af4d76e1c97", "html_url_before": "https://github.com/getredash/redash/commit/ed654a7b78dd791779ba61e884100af4d76e1c97"}], "details": [{"raw_url": "https://github.com/getredash/redash/raw/da696ff7f84787cbf85967460fac52886cbe063e/redash%2Fauthentication%2F__init__.py", "code": "import hashlib\nimport hmac\nimport logging\nimport time\nfrom datetime import timedelta\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import jsonify, redirect, request, url_for, session\nfrom flask_login import LoginManager, login_user, logout_user, user_logged_in\nfrom redash import models, settings\nfrom redash.authentication import jwt_auth\nfrom redash.authentication.org_resolving import current_org\nfrom redash.settings.organization import settings as org_settings\nfrom redash.tasks import record_event\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom werkzeug.exceptions import Unauthorized\n\nlogin_manager = LoginManager()\nlogger = logging.getLogger(\"authentication\")\n\n\ndef get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url\n\n\ndef sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()\n\n\n@login_manager.user_loader\ndef load_user(user_id_with_identity):\n    user = api_key_load_user_from_request(request)\n    if user:\n        return user\n\n    org = current_org._get_current_object()\n\n    try:\n        user_id, _ = user_id_with_identity.split(\"-\")\n        user = models.User.get_by_id_and_org(user_id, org)\n        if user.is_disabled or user.get_id() != user_id_with_identity:\n            return None\n\n        return user\n    except (models.NoResultFound, ValueError, AttributeError):\n        return None\n\n\ndef request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user\n\n\ndef hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None\n\n\ndef get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user\n\n\ndef get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key\n\n\ndef api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user\n\n\ndef jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user\n\n\ndef log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)\n\n\n@login_manager.unauthorized_handler\ndef redirect_to_login():\n    if request.is_xhr or \"/api/\" in request.path:\n        response = jsonify(\n            {\"message\": \"Couldn't find resource. Please login and try again.\"}\n        )\n        response.status_code = 404\n        return response\n\n    login_url = get_login_url(next=request.url, external=False)\n\n    return redirect(login_url)\n\n\ndef logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)\n\n\ndef init_app(app):\n    from redash.authentication import (\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    from redash.authentication.google_oauth import create_google_oauth_blueprint\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n\n    # Authlib's flask oauth client requires a Flask app to initialize\n    for blueprint in [create_google_oauth_blueprint(app), saml_auth.blueprint, remote_user_auth.blueprint, ldap_auth.blueprint, ]:\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)\n\n\ndef create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object\n\n\ndef get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path\n", "code_before": "import hashlib\nimport hmac\nimport logging\nimport time\nfrom datetime import timedelta\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import jsonify, redirect, request, url_for, session\nfrom flask_login import LoginManager, login_user, logout_user, user_logged_in\nfrom redash import models, settings\nfrom redash.authentication import jwt_auth\nfrom redash.authentication.org_resolving import current_org\nfrom redash.settings.organization import settings as org_settings\nfrom redash.tasks import record_event\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom werkzeug.exceptions import Unauthorized\n\nlogin_manager = LoginManager()\nlogger = logging.getLogger(\"authentication\")\n\n\ndef get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url\n\n\ndef sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()\n\n\n@login_manager.user_loader\ndef load_user(user_id_with_identity):\n    user = api_key_load_user_from_request(request)\n    if user:\n        return user\n\n    org = current_org._get_current_object()\n\n    try:\n        user_id, _ = user_id_with_identity.split(\"-\")\n        user = models.User.get_by_id_and_org(user_id, org)\n        if user.is_disabled or user.get_id() != user_id_with_identity:\n            return None\n\n        return user\n    except (models.NoResultFound, ValueError, AttributeError):\n        return None\n\n\ndef request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user\n\n\ndef hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None\n\n\ndef get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user\n\n\ndef get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key\n\n\ndef api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user\n\n\ndef jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user\n\n\ndef log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)\n\n\n@login_manager.unauthorized_handler\ndef redirect_to_login():\n    if request.is_xhr or \"/api/\" in request.path:\n        response = jsonify(\n            {\"message\": \"Couldn't find resource. Please login and try again.\"}\n        )\n        response.status_code = 404\n        return response\n\n    login_url = get_login_url(next=request.url, external=False)\n\n    return redirect(login_url)\n\n\ndef logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)\n\n\ndef init_app(app):\n    from redash.authentication import (\n        google_oauth,\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n    for auth in [google_oauth, saml_auth, remote_user_auth, ldap_auth]:\n        blueprint = auth.blueprint\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)\n\n\ndef create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object\n\n\ndef get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path\n", "patch": "@@ -243,12 +243,13 @@ def logout_and_redirect_to_index():\n \n def init_app(app):\n     from redash.authentication import (\n-        google_oauth,\n         saml_auth,\n         remote_user_auth,\n         ldap_auth,\n     )\n \n+    from redash.authentication.google_oauth import create_google_oauth_blueprint\n+\n     login_manager.init_app(app)\n     login_manager.anonymous_user = models.AnonymousUser\n     login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n@@ -259,8 +260,9 @@ def extend_session():\n         app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n \n     from redash.security import csrf\n-    for auth in [google_oauth, saml_auth, remote_user_auth, ldap_auth]:\n-        blueprint = auth.blueprint\n+\n+    # Authlib's flask oauth client requires a Flask app to initialize\n+    for blueprint in [create_google_oauth_blueprint(app), saml_auth.blueprint, remote_user_auth.blueprint, ldap_auth.blueprint, ]:\n         csrf.exempt(blueprint)\n         app.register_blueprint(blueprint)\n ", "file_path": "files/2021_11/52", "file_language": "py", "file_name": "redash/authentication/__init__.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url", "target": 0}, {"function": "def sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()", "target": 0}, {"function": "def request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user", "target": 0}, {"function": "def hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None", "target": 0}, {"function": "def get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user", "target": 0}, {"function": "def get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key", "target": 0}, {"function": "def api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user", "target": 0}, {"function": "def jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user", "target": 0}, {"function": "def log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)", "target": 0}, {"function": "def logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)", "target": 0}, {"function": "def init_app(app):\n    from redash.authentication import (\n        google_oauth,\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n    for auth in [google_oauth, saml_auth, remote_user_auth, ldap_auth]:\n        blueprint = auth.blueprint\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)", "target": 0}, {"function": "def create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object", "target": 0}, {"function": "def get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path", "target": 0}], "function_after": [{"function": "def get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url", "target": 0}, {"function": "def sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()", "target": 0}, {"function": "def request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user", "target": 0}, {"function": "def hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None", "target": 0}, {"function": "def get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user", "target": 0}, {"function": "def get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key", "target": 0}, {"function": "def api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user", "target": 0}, {"function": "def jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user", "target": 0}, {"function": "def log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)", "target": 0}, {"function": "def logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)", "target": 0}, {"function": "def init_app(app):\n    from redash.authentication import (\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    from redash.authentication.google_oauth import create_google_oauth_blueprint\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n\n    # Authlib's flask oauth client requires a Flask app to initialize\n    for blueprint in [create_google_oauth_blueprint(app), saml_auth.blueprint, remote_user_auth.blueprint, ldap_auth.blueprint, ]:\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)", "target": 0}, {"function": "def create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object", "target": 0}, {"function": "def get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path", "target": 0}]}, {"raw_url": "https://github.com/getredash/redash/raw/da696ff7f84787cbf85967460fac52886cbe063e/redash%2Fauthentication%2Fgoogle_oauth.py", "code": "import logging\nimport requests\nfrom flask import redirect, url_for, Blueprint, flash, request, session\n\n\nfrom redash import models, settings\nfrom redash.authentication import (\n    create_and_login_user,\n    logout_and_redirect_to_index,\n    get_next_path,\n)\nfrom redash.authentication.org_resolving import current_org\n\nfrom authlib.integrations.flask_client import OAuth\n\n\ndef verify_profile(org, profile):\n    if org.is_public:\n        return True\n\n    email = profile[\"email\"]\n    domain = email.split(\"@\")[-1]\n\n    if domain in org.google_apps_domains:\n        return True\n\n    if org.has_user(email) == 1:\n        return True\n\n    return False\n\n\ndef create_google_oauth_blueprint(app):\n    oauth = OAuth(app)\n\n    logger = logging.getLogger(\"google_oauth\")\n    blueprint = Blueprint(\"google_oauth\", __name__)\n\n    CONF_URL = \"https://accounts.google.com/.well-known/openid-configuration\"\n    oauth = OAuth(app)\n    oauth.register(\n        name=\"google\",\n        server_metadata_url=CONF_URL,\n        client_kwargs={\"scope\": \"openid email profile\"},\n    )\n\n    def get_user_profile(access_token):\n        headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n        response = requests.get(\n            \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n        )\n\n        if response.status_code == 401:\n            logger.warning(\"Failed getting user profile (response code 401).\")\n            return None\n\n        return response.json()\n\n    @blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\n    def org_login(org_slug):\n        session[\"org_slug\"] = current_org.slug\n        return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n\n    @blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\n    def login():\n\n        redirect_uri = url_for(\".callback\", _external=True)\n\n        next_path = request.args.get(\n            \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n        )\n        logger.debug(\"Callback url: %s\", redirect_uri)\n        logger.debug(\"Next is: %s\", next_path)\n\n        session[\"next_url\"] = next_path\n\n        return oauth.google.authorize_redirect(redirect_uri)\n\n    @blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\n    def authorized():\n\n        logger.debug(\"Authorized user inbound\")\n\n        resp = oauth.google.authorize_access_token()\n        user = resp.get(\"userinfo\")\n        if user:\n            session[\"user\"] = user\n\n        access_token = resp[\"access_token\"]\n\n        if access_token is None:\n            logger.warning(\"Access token missing in call back request.\")\n            flash(\"Validation error. Please retry.\")\n            return redirect(url_for(\"redash.login\"))\n\n        profile = get_user_profile(access_token)\n        if profile is None:\n            flash(\"Validation error. Please retry.\")\n            return redirect(url_for(\"redash.login\"))\n\n        if \"org_slug\" in session:\n            org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n        else:\n            org = current_org\n\n        if not verify_profile(org, profile):\n            logger.warning(\n                \"User tried to login with unauthorized domain name: %s (org: %s)\",\n                profile[\"email\"],\n                org,\n            )\n            flash(\n                \"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"])\n            )\n            return redirect(url_for(\"redash.login\", org_slug=org.slug))\n\n        picture_url = \"%s?sz=40\" % profile[\"picture\"]\n        user = create_and_login_user(\n            org, profile[\"name\"], profile[\"email\"], picture_url\n        )\n        if user is None:\n            return logout_and_redirect_to_index()\n\n        unsafe_next_path = session.get(\"next_url\") or url_for(\n            \"redash.index\", org_slug=org.slug\n        )\n        next_path = get_next_path(unsafe_next_path)\n\n        return redirect(next_path)\n\n    return blueprint\n", "code_before": "import logging\nimport requests\nfrom flask import redirect, url_for, Blueprint, flash, request, session\nfrom flask_oauthlib.client import OAuth\n\nfrom redash import models, settings\nfrom redash.authentication import (\n    create_and_login_user,\n    logout_and_redirect_to_index,\n    get_next_path,\n)\nfrom redash.authentication.org_resolving import current_org\n\nlogger = logging.getLogger(\"google_oauth\")\n\noauth = OAuth()\nblueprint = Blueprint(\"google_oauth\", __name__)\n\n\ndef google_remote_app():\n    if \"google\" not in oauth.remote_apps:\n        oauth.remote_app(\n            \"google\",\n            base_url=\"https://www.google.com/accounts/\",\n            authorize_url=\"https://accounts.google.com/o/oauth2/auth?prompt=select_account+consent\",\n            request_token_url=None,\n            request_token_params={\n                \"scope\": \"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile\"\n            },\n            access_token_url=\"https://accounts.google.com/o/oauth2/token\",\n            access_token_method=\"POST\",\n            consumer_key=settings.GOOGLE_CLIENT_ID,\n            consumer_secret=settings.GOOGLE_CLIENT_SECRET,\n        )\n\n    return oauth.google\n\n\ndef get_user_profile(access_token):\n    headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n    response = requests.get(\n        \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n    )\n\n    if response.status_code == 401:\n        logger.warning(\"Failed getting user profile (response code 401).\")\n        return None\n\n    return response.json()\n\n\ndef verify_profile(org, profile):\n    if org.is_public:\n        return True\n\n    email = profile[\"email\"]\n    domain = email.split(\"@\")[-1]\n\n    if domain in org.google_apps_domains:\n        return True\n\n    if org.has_user(email) == 1:\n        return True\n\n    return False\n\n\n@blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\ndef org_login(org_slug):\n    session[\"org_slug\"] = current_org.slug\n    return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n\n\n@blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\ndef login():\n    callback = url_for(\".callback\", _external=True)\n    next_path = request.args.get(\n        \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n    )\n    logger.debug(\"Callback url: %s\", callback)\n    logger.debug(\"Next is: %s\", next_path)\n    return google_remote_app().authorize(callback=callback, state=next_path)\n\n\n@blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\ndef authorized():\n    resp = google_remote_app().authorized_response()\n    access_token = resp[\"access_token\"]\n\n    if access_token is None:\n        logger.warning(\"Access token missing in call back request.\")\n        flash(\"Validation error. Please retry.\")\n        return redirect(url_for(\"redash.login\"))\n\n    profile = get_user_profile(access_token)\n    if profile is None:\n        flash(\"Validation error. Please retry.\")\n        return redirect(url_for(\"redash.login\"))\n\n    if \"org_slug\" in session:\n        org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n    else:\n        org = current_org\n\n    if not verify_profile(org, profile):\n        logger.warning(\n            \"User tried to login with unauthorized domain name: %s (org: %s)\",\n            profile[\"email\"],\n            org,\n        )\n        flash(\"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"]))\n        return redirect(url_for(\"redash.login\", org_slug=org.slug))\n\n    picture_url = \"%s?sz=40\" % profile[\"picture\"]\n    user = create_and_login_user(org, profile[\"name\"], profile[\"email\"], picture_url)\n    if user is None:\n        return logout_and_redirect_to_index()\n\n    unsafe_next_path = request.args.get(\"state\") or url_for(\n        \"redash.index\", org_slug=org.slug\n    )\n    next_path = get_next_path(unsafe_next_path)\n\n    return redirect(next_path)\n", "patch": "@@ -1,7 +1,7 @@\n import logging\n import requests\n from flask import redirect, url_for, Blueprint, flash, request, session\n-from flask_oauthlib.client import OAuth\n+\n \n from redash import models, settings\n from redash.authentication import (\n@@ -11,42 +11,7 @@\n )\n from redash.authentication.org_resolving import current_org\n \n-logger = logging.getLogger(\"google_oauth\")\n-\n-oauth = OAuth()\n-blueprint = Blueprint(\"google_oauth\", __name__)\n-\n-\n-def google_remote_app():\n-    if \"google\" not in oauth.remote_apps:\n-        oauth.remote_app(\n-            \"google\",\n-            base_url=\"https://www.google.com/accounts/\",\n-            authorize_url=\"https://accounts.google.com/o/oauth2/auth?prompt=select_account+consent\",\n-            request_token_url=None,\n-            request_token_params={\n-                \"scope\": \"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile\"\n-            },\n-            access_token_url=\"https://accounts.google.com/o/oauth2/token\",\n-            access_token_method=\"POST\",\n-            consumer_key=settings.GOOGLE_CLIENT_ID,\n-            consumer_secret=settings.GOOGLE_CLIENT_SECRET,\n-        )\n-\n-    return oauth.google\n-\n-\n-def get_user_profile(access_token):\n-    headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n-    response = requests.get(\n-        \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n-    )\n-\n-    if response.status_code == 401:\n-        logger.warning(\"Failed getting user profile (response code 401).\")\n-        return None\n-\n-    return response.json()\n+from authlib.integrations.flask_client import OAuth\n \n \n def verify_profile(org, profile):\n@@ -65,60 +30,102 @@ def verify_profile(org, profile):\n     return False\n \n \n-@blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\n-def org_login(org_slug):\n-    session[\"org_slug\"] = current_org.slug\n-    return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n+def create_google_oauth_blueprint(app):\n+    oauth = OAuth(app)\n \n+    logger = logging.getLogger(\"google_oauth\")\n+    blueprint = Blueprint(\"google_oauth\", __name__)\n \n-@blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\n-def login():\n-    callback = url_for(\".callback\", _external=True)\n-    next_path = request.args.get(\n-        \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n+    CONF_URL = \"https://accounts.google.com/.well-known/openid-configuration\"\n+    oauth = OAuth(app)\n+    oauth.register(\n+        name=\"google\",\n+        server_metadata_url=CONF_URL,\n+        client_kwargs={\"scope\": \"openid email profile\"},\n     )\n-    logger.debug(\"Callback url: %s\", callback)\n-    logger.debug(\"Next is: %s\", next_path)\n-    return google_remote_app().authorize(callback=callback, state=next_path)\n-\n-\n-@blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\n-def authorized():\n-    resp = google_remote_app().authorized_response()\n-    access_token = resp[\"access_token\"]\n-\n-    if access_token is None:\n-        logger.warning(\"Access token missing in call back request.\")\n-        flash(\"Validation error. Please retry.\")\n-        return redirect(url_for(\"redash.login\"))\n-\n-    profile = get_user_profile(access_token)\n-    if profile is None:\n-        flash(\"Validation error. Please retry.\")\n-        return redirect(url_for(\"redash.login\"))\n-\n-    if \"org_slug\" in session:\n-        org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n-    else:\n-        org = current_org\n-\n-    if not verify_profile(org, profile):\n-        logger.warning(\n-            \"User tried to login with unauthorized domain name: %s (org: %s)\",\n-            profile[\"email\"],\n-            org,\n+\n+    def get_user_profile(access_token):\n+        headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n+        response = requests.get(\n+            \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n         )\n-        flash(\"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"]))\n-        return redirect(url_for(\"redash.login\", org_slug=org.slug))\n \n-    picture_url = \"%s?sz=40\" % profile[\"picture\"]\n-    user = create_and_login_user(org, profile[\"name\"], profile[\"email\"], picture_url)\n-    if user is None:\n-        return logout_and_redirect_to_index()\n+        if response.status_code == 401:\n+            logger.warning(\"Failed getting user profile (response code 401).\")\n+            return None\n \n-    unsafe_next_path = request.args.get(\"state\") or url_for(\n-        \"redash.index\", org_slug=org.slug\n-    )\n-    next_path = get_next_path(unsafe_next_path)\n+        return response.json()\n+\n+    @blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\n+    def org_login(org_slug):\n+        session[\"org_slug\"] = current_org.slug\n+        return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n+\n+    @blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\n+    def login():\n+\n+        redirect_uri = url_for(\".callback\", _external=True)\n+\n+        next_path = request.args.get(\n+            \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n+        )\n+        logger.debug(\"Callback url: %s\", redirect_uri)\n+        logger.debug(\"Next is: %s\", next_path)\n+\n+        session[\"next_url\"] = next_path\n+\n+        return oauth.google.authorize_redirect(redirect_uri)\n+\n+    @blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\n+    def authorized():\n+\n+        logger.debug(\"Authorized user inbound\")\n+\n+        resp = oauth.google.authorize_access_token()\n+        user = resp.get(\"userinfo\")\n+        if user:\n+            session[\"user\"] = user\n+\n+        access_token = resp[\"access_token\"]\n+\n+        if access_token is None:\n+            logger.warning(\"Access token missing in call back request.\")\n+            flash(\"Validation error. Please retry.\")\n+            return redirect(url_for(\"redash.login\"))\n+\n+        profile = get_user_profile(access_token)\n+        if profile is None:\n+            flash(\"Validation error. Please retry.\")\n+            return redirect(url_for(\"redash.login\"))\n+\n+        if \"org_slug\" in session:\n+            org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n+        else:\n+            org = current_org\n+\n+        if not verify_profile(org, profile):\n+            logger.warning(\n+                \"User tried to login with unauthorized domain name: %s (org: %s)\",\n+                profile[\"email\"],\n+                org,\n+            )\n+            flash(\n+                \"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"])\n+            )\n+            return redirect(url_for(\"redash.login\", org_slug=org.slug))\n+\n+        picture_url = \"%s?sz=40\" % profile[\"picture\"]\n+        user = create_and_login_user(\n+            org, profile[\"name\"], profile[\"email\"], picture_url\n+        )\n+        if user is None:\n+            return logout_and_redirect_to_index()\n+\n+        unsafe_next_path = session.get(\"next_url\") or url_for(\n+            \"redash.index\", org_slug=org.slug\n+        )\n+        next_path = get_next_path(unsafe_next_path)\n+\n+        return redirect(next_path)\n \n-    return redirect(next_path)\n+    return blueprint", "file_path": "files/2021_11/53", "file_language": "py", "file_name": "redash/authentication/google_oauth.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.open-redirect.open-redirect                                             \n          Data from request is passed to redirect(). This is an open redirect and could be exploited.\n          Consider using 'url_for()' to generate links to known locations. If you must use a URL to  \n          unknown pages, consider using 'urlparse()' or similar and checking if the 'netloc' property\n          is the same as your site's host name. See the references for more information.             \n          Details: https://sg.run/kXe2                                                               \n           71\u2506 return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))"]]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/getredash/redash/raw/da696ff7f84787cbf85967460fac52886cbe063e/requirements.txt", "code": "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\nAuthlib==0.15.5", "code_before": "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-OAuthLib==0.9.5\n# pin this until https://github.com/lepture/flask-oauthlib/pull/388 is released\nrequests-oauthlib>=0.6.2,<1.2.0\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\n", "patch": "@@ -8,9 +8,6 @@ httplib2==0.14.0\n wtforms==2.2.1\n Flask-RESTful==0.3.7\n Flask-Login==0.4.1\n-Flask-OAuthLib==0.9.5\n-# pin this until https://github.com/lepture/flask-oauthlib/pull/388 is released\n-requests-oauthlib>=0.6.2,<1.2.0\n Flask-SQLAlchemy==2.4.1\n Flask-Migrate==2.5.2\n flask-mail==0.9.1\n@@ -67,3 +64,4 @@ werkzeug==0.16.1\n # Uncomment the requirement for ldap3 if using ldap.\n # It is not included by default because of the GPL license conflict.\n # ldap3==2.2.4\n+Authlib==0.15.5\n\\ No newline at end of file", "file_path": "files/2021_11/54", "file_language": "txt", "file_name": "requirements.txt", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 1}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
