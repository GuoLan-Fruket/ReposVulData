{"index": 7768, "cve_id": "CVE-2022-0697", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "Open Redirect in GitHub repository archivy/archivy prior to 1.7.0.", "cvss": "9.8", "publish_date": "March 6, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "2d8cb29853190d42572b36deb61127e68d6be574", "commit_message": "fix open redirect", "commit_date": "2022-02-24T20:35:55Z", "project": "archivy/archivy", "url": "https://api.github.com/repos/archivy/archivy/commits/2d8cb29853190d42572b36deb61127e68d6be574", "html_url": "https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574", "windows_before": [{"commit_id": "fa389e7d59f91980693965830839d6de1f1db45f", "commit_date": "Sun Feb 13 13:23:44 2022 +0100", "commit_message": "Improve bookmarklet and backend to upload bookmarks with direct html (#287)", "files_name": ["archivy/models.py", "archivy/routes.py", "archivy/templates/bookmarklet.html", "tests/functional/test_routes.py", "tests/integration/test_api.py"]}, {"commit_id": "440ed1a6deeac6333c5127bc64465616d37510b9", "commit_date": "Sat Feb 5 21:04:23 2022 +0300", "commit_message": "fix: check is_relative_to based on resolved paths (#286)", "files_name": ["archivy/data.py"]}, {"commit_id": "75ee46be486c3196553a741c199b0d40445a71e1", "commit_date": "Sat Jan 29 16:20:39 2022 +0100", "commit_message": "Disable spell check (#263)", "files_name": ["archivy/config.py", "archivy/templates/dataobjs/show.html"]}, {"commit_id": "dab9b508193056f9a2d22b94eef98687cdffa390", "commit_date": "Sat Jan 29 15:45:49 2022 +0100", "commit_message": "Replace \\t by \"    \" in **/*css (#285)", "files_name": ["archivy/static/editor_dark.css", "archivy/static/main.css", "archivy/static/main_dark.css", "archivy/static/markdown.css", "archivy/static/mvp.css", "archivy/templates/base.html", "archivy/templates/click_web/command_form.html", "archivy/templates/config.html", "archivy/templates/dataobjs/show.html", "archivy/templates/users/edit.html"]}, {"commit_id": "f92f7f60e5b70c36d870e4df11bf253f6c7d3bb2", "commit_date": "Sat Jan 29 00:35:30 2022 +0100", "commit_message": "v1.7.0", "files_name": ["setup.py"]}, {"commit_id": "6d95743b0e9f6054e4ac8b5595d59ae75b82dbc0", "commit_date": "Thu Jan 27 15:12:24 2022 +0100", "commit_message": "Auto note link creation in editor (#284)", "files_name": ["archivy/templates/dataobjs/show.html", "docs/editing.md"]}, {"commit_id": "12fffcfe18f3fc3d6e1ed6246762fc83d205904f", "commit_date": "Thu Jan 27 15:02:56 2022 +0100", "commit_message": "doc", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "53c39eb1680f2c262a4be74dba0fb128548fd07b", "commit_date": "Thu Jan 27 15:02:13 2022 +0100", "commit_message": "fix rendering issues with escaped characters", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "419668d39cb9dcadb39ba76562a2d88c48bf6038", "commit_date": "Tue Jan 25 21:50:28 2022 +0100", "commit_message": "allow use on intranet by vendoring resources", "files_name": [".gitattributes", "archivy/static/logo.png", "archivy/static/math.css", "archivy/templates/base.html", "archivy/templates/markdown-parser.html"]}, {"commit_id": "a33c05b8aaf0606b66dcc6eac7262b832d331c81", "commit_date": "Sun Jan 23 18:29:29 2022 +0100", "commit_message": "bump up requests to fix versioning problem", "files_name": ["requirements.txt"]}, {"commit_id": "c51e0c3a7d96cdb04183c8bc076ed5cba10d9ba5", "commit_date": "Sun Jan 23 17:37:29 2022 +0100", "commit_message": "Better scraping (#281)", "files_name": ["archivy/models.py", "conftest.py", "requirements.txt", "tests/functional/test_routes.py"]}, {"commit_id": "8cf1c80c6fef28f06f89917c2a97cd410d80dda4", "commit_date": "Sun Jan 23 12:45:47 2022 +0100", "commit_message": "Improve frontmatter tags (#283)", "files_name": ["archivy/routes.py", "archivy/search.py", "archivy/tags.py", "archivy/templates/dataobjs/show.html", "tests/functional/test_routes.py"]}, {"commit_id": "66eae2c9bd67257cf776f5ec17394d9e0fab103d", "commit_date": "Sun Jan 16 15:16:59 2022 +0100", "commit_message": "remove useless style tag", "files_name": ["archivy/templates/base.html"]}, {"commit_id": "039dfa8da728470d0752077b7b392378d393ec59", "commit_date": "Sat Jan 15 14:08:34 2022 +0100", "commit_message": "formatting", "files_name": ["archivy/__init__.py"]}, {"commit_id": "1d34a6f9f2e98ce2d2721e1bf91ac8f520f163ad", "commit_date": "Sat Jan 15 14:07:24 2022 +0100", "commit_message": "sometimes jinja2 extension syntax didn't work => refactor for resilience", "files_name": ["archivy/__init__.py"]}, {"commit_id": "e7e6d61c6e296d1451919440f7b0887f9500646c", "commit_date": "Sat Jan 15 14:05:20 2022 +0100", "commit_message": "fix security issue with script rendering", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "83b90450fa79b8e35325a2af3acd7a7a3b04b49e", "commit_date": "Wed Jan 12 23:04:53 2022 +0100", "commit_message": "v1.6.2 - security patch and archivy_internal_dir", "files_name": ["setup.py"]}, {"commit_id": "418ef47d7e10bc35611e93641e0445d6067efe41", "commit_date": "Fri Dec 31 16:45:56 2021 +0100", "commit_message": "feat: add ARCHIVY_INTERNAL_DIR_PATH env variable (#274)", "files_name": ["archivy/config.py"]}, {"commit_id": "a0dca90b7953c373facc710571890391725f5b6a", "commit_date": "Wed Dec 29 17:27:35 2021 +0100", "commit_message": "fix problem where some notes aren't able to be linked through UI", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "a8d898428df543ef175d7e29b6b9050dbb9cd378", "commit_date": "Mon Dec 27 14:56:46 2021 +0100", "commit_message": "remove CSRF on API", "files_name": ["archivy/__init__.py"]}, {"commit_id": "796c3ae318eea183fc88c87ec5a27355b0f6a99d", "commit_date": "Fri Dec 24 12:16:44 2021 +0100", "commit_message": "better CSRF protection; change delete route to POST", "files_name": ["archivy/__init__.py", "archivy/click_web/resources/cmd_exec.py", "archivy/routes.py", "archivy/templates/click_web/command_form.html", "archivy/templates/dataobjs/show.html", "tests/functional/test_routes.py"]}, {"commit_id": "ea353cd20a2892149ecdda3bb86a32e0974ba098", "commit_date": "Thu Dec 23 10:49:30 2021 +0100", "commit_message": "add security.md", "files_name": ["SECURITY.md", "setup.py"]}, {"commit_id": "bf378177f1603da5425dcdb5e78d0509827a76cf", "commit_date": "Thu Dec 16 20:25:52 2021 +0100", "commit_message": "fix readme formatting", "files_name": ["README.md"]}, {"commit_id": "16b0f7cde604550f10d4c3c0c61f2653be3c2a0a", "commit_date": "Thu Dec 16 20:20:31 2021 +0100", "commit_message": "v1.6.1 - patch windows paths on ripgrep", "files_name": ["archivy/search.py", "setup.py"]}, {"commit_id": "af1273afcc133e4326e7320dc9ddda0c633f725a", "commit_date": "Thu Dec 16 20:19:15 2021 +0100", "commit_message": "fix issues with windows paths", "files_name": ["archivy/search.py"]}, {"commit_id": "3990471dd57875a02353ace9c7025111a2bb0f5e", "commit_date": "Wed Dec 15 22:22:29 2021 +0100", "commit_message": "add mention of v1.6.0 in docs", "files_name": ["README.md", "docs/index.md"]}, {"commit_id": "5ce47aaf77842ecd455974e0d11a53d8e783f91e", "commit_date": "Wed Dec 15 21:50:48 2021 +0100", "commit_message": "v1.6.0", "files_name": ["README.md", "docs/index.md", "setup.py"]}, {"commit_id": "ef1fd3e3cdf68464e4d88dcbcb0f992ec511222b", "commit_date": "Tue Dec 14 22:06:30 2021 +0100", "commit_message": "fix duplicate rendering katex bug", "files_name": ["archivy/static/main.css"]}, {"commit_id": "2f78491794cfb1d35c6e88a3720e33abdccf8dce", "commit_date": "Tue Dec 14 22:01:33 2021 +0100", "commit_message": "fix bug where note link form can't be closed", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "3fcd8032825a6b475c12cfa32637084240e30414", "commit_date": "Sat Dec 11 15:34:35 2021 +0100", "commit_message": "need to rerun workflows, finally found the problem - discrepancy between semver and pypi format for versioning", "files_name": ["setup.py"]}, {"commit_id": "afd1aa819ec727501052891b45a7b1527274367b", "commit_date": "Sat Dec 11 15:19:00 2021 +0100", "commit_message": "v1.6rc2 - having problems with automated actions", "files_name": ["setup.py"]}, {"commit_id": "1e3b879e0e13b7af2e625209a02c7c2e2244922d", "commit_date": "Sat Dec 11 15:09:58 2021 +0100", "commit_message": "fix release deployment match", "files_name": [".github/workflows/pypi-auto-deploy.yml"]}, {"commit_id": "edeb60af276b47ab4bf08a908033b0e4681d7bcc", "commit_date": "Sat Dec 11 14:49:05 2021 +0100", "commit_message": "v1.6rc1", "files_name": ["setup.py"]}, {"commit_id": "f2fda0dd95a835e566e15c9aea417543fcfe93bf", "commit_date": "Sat Dec 11 12:48:07 2021 +0100", "commit_message": "v1.6.0rc1", "files_name": ["setup.py"]}, {"commit_id": "af4b8eaeb1f48df80432c7e3ac01ac8854d67767", "commit_date": "Sat Dec 11 12:46:43 2021 +0100", "commit_message": "doc updates", "files_name": ["docs/install.md"]}, {"commit_id": "48b359e1a6c0012d1f1f391a148f009a1c151115", "commit_date": "Fri Dec 10 23:54:40 2021 +0100", "commit_message": "finalize lite setup", "files_name": [".github/workflows/build-docker-on-release.yml"]}, {"commit_id": "e3086b56e8c2b2bcec5eecdd98a346dbb985113e", "commit_date": "Fri Dec 10 23:45:40 2021 +0100", "commit_message": "Bump mkdocs from 1.1.2 to 1.2.3 in /docs (#268)", "files_name": ["docs/requirements.txt"]}, {"commit_id": "61931b601b383015ecd52a1fb9612b53b7512356", "commit_date": "Fri Dec 10 23:45:12 2021 +0100", "commit_message": "use more precise import", "files_name": ["archivy/__init__.py"]}, {"commit_id": "1ff3ee1c7c059be1ead2b44cb3d60c401dd6b7a2", "commit_date": "Fri Dec 10 23:28:36 2021 +0100", "commit_message": "small errors in gh workflow", "files_name": [".github/workflows/build-docker-on-release.yml", ".github/workflows/build-docker-specific-version.yml"]}, {"commit_id": "cf5430f93e5be21e37f74c0265d5078d78c9bedb", "commit_date": "Fri Dec 10 23:20:31 2021 +0100", "commit_message": "modify workflow to build archivy-lite images", "files_name": [".github/workflows/build-docker-on-release.yml", ".github/workflows/build-docker-specific-version.yml"]}, {"commit_id": "4e14731b9a71530c31d36c0d15b5d67ec84e2070", "commit_date": "Sat Dec 4 18:09:23 2021 +0100", "commit_message": "formatting", "files_name": ["archivy/__init__.py"]}, {"commit_id": "a7fe0e7e6f3299cb22c0040e495f833344e9da2a", "commit_date": "Sat Dec 4 18:04:31 2021 +0100", "commit_message": "don't show Tags button when ripgrep not installed; style fixes", "files_name": ["archivy/__init__.py", "archivy/templates/base.html", "archivy/templates/users/login.html"]}, {"commit_id": "7bd0c6ad9940502dc905a46e87f35585e6037048", "commit_date": "Wed Nov 10 18:39:41 2021 +0530", "commit_message": "Add helper command to generate plugin directory with structure (#264)", "files_name": ["archivy/cli.py", "archivy/helpers.py", "tests/unit/test_cli.py"]}, {"commit_id": "04bc60a3662e77d367028ca07b60beb7fa22cdbb", "commit_date": "Thu Nov 4 16:17:38 2021 +0100", "commit_message": "add docs", "files_name": ["README.md", "docs/editing.md"]}, {"commit_id": "399312279cd82f62884f00d9982008c34e292c79", "commit_date": "Wed Nov 3 01:59:31 2021 +0100", "commit_message": "move flashes outside of model code", "files_name": ["archivy/models.py", "archivy/routes.py"]}, {"commit_id": "eb7821bfd9e3b506499f7a617914481d59ac93c4", "commit_date": "Sun Oct 31 12:07:51 2021 +0100", "commit_message": "replace _ with ' ' for better titles (not ideal, but half-works) (#261)", "files_name": ["archivy/search.py"]}, {"commit_id": "00522416ad7a5111b3f339e717d55515151536c8", "commit_date": "Sun Oct 31 11:59:27 2021 +0100", "commit_message": "change #tag to #tag# (#260)", "files_name": ["archivy/routes.py", "archivy/search.py", "archivy/templates/dataobjs/show.html", "archivy/templates/markdown-parser.html", "conftest.py"]}, {"commit_id": "92f4ce8cac7bf74910f7e79eb5061a072f127056", "commit_date": "Sat Oct 30 17:32:40 2021 +0200", "commit_message": "formatting", "files_name": ["archivy/templates/dataobjs/show.html", "archivy/templates/tags/show.html"]}, {"commit_id": "062aeafd2a8ee0b133051b12f0f8381c47a558dd", "commit_date": "Sat Oct 30 17:14:29 2021 +0200", "commit_message": "Better search (matches and IU) results / output (#259)", "files_name": ["archivy/api.py", "archivy/routes.py"]}], "windows_after": [{"commit_id": "0442d252d300e1b8fcfa99df9aefdf79c31491d9", "commit_date": "Thu Feb 24 21:41:54 2022 +0100", "commit_message": "fix deprecated dependencies", "files_name": ["requirements.txt"]}, {"commit_id": "10a9c9aed0629ddd855f876e171a516b74b68a96", "commit_date": "Thu Feb 24 21:44:21 2022 +0100", "commit_message": "add paths to watch for testing", "files_name": [".github/workflows/codecov.yml"]}, {"commit_id": "65ff8d3aa3ed76ea9363fa9a16f90f4077323af2", "commit_date": "Sat Feb 26 10:12:02 2022 +0100", "commit_message": "remove old bugfix for katex html being duplicated, now fixed", "files_name": ["archivy/static/main.css"]}, {"commit_id": "9dc7c336f8ade7e89df3c2e8082b5be6585c46f8", "commit_date": "Sat Feb 26 11:01:12 2022 +0100", "commit_message": "upgrade to flask 2 (tested)", "files_name": ["requirements.txt"]}, {"commit_id": "5db3031d566b11519e642bf886b0e7524e710f43", "commit_date": "Sat Feb 26 12:38:13 2022 +0100", "commit_message": "v1.7.1", "files_name": ["setup.py"]}, {"commit_id": "dedc5a0b214acf2a25e0300304dabb46def4eef1", "commit_date": "Sun Mar 6 00:30:04 2022 +0100", "commit_message": "fix path traversal issue", "files_name": ["archivy/data.py"]}, {"commit_id": "902a6ec67ad69378cc646840d66adb50c19202a0", "commit_date": "Mon Mar 7 22:18:35 2022 +0100", "commit_message": "Allow customization of note / bookmark show page through JS (#288)", "files_name": ["archivy/config.py", "archivy/routes.py", "archivy/templates/dataobjs/show.html"]}, {"commit_id": "62588c56e96efb1d243671d40418b6bfec8dc3a5", "commit_date": "Wed Mar 9 19:03:13 2022 +0100", "commit_message": "move save functionality in JS to function", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "c94aad9f1d79f4580c9067219f5d11e0f662ce8e", "commit_date": "Wed Mar 9 19:03:36 2022 +0100", "commit_message": "v1.7.2", "files_name": ["setup.py"]}, {"commit_id": "e429e1c57029142c69aa057e9058ff5d97e9c097", "commit_date": "Sun Mar 20 18:48:39 2022 +0100", "commit_message": "add alert for network errors", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "b48c90e87e95d29e77492601c435f86e162e7b90", "commit_date": "Sun Mar 20 18:52:33 2022 +0100", "commit_message": "fix whitespace", "files_name": ["archivy/templates/dataobjs/show.html"]}, {"commit_id": "e081760d530eeecb59bec5a417fa6d11c4cb8be8", "commit_date": "Wed Mar 23 14:30:44 2022 +0100", "commit_message": "add option to change editor icons", "files_name": ["archivy/config.py", "archivy/routes.py", "archivy/templates/dataobjs/show.html", "docs/config.md"]}, {"commit_id": "ca6f0c3f3431020492a5534304f867327455e545", "commit_date": "Wed Mar 23 14:31:17 2022 +0100", "commit_message": "formatting", "files_name": ["archivy/config.py"]}, {"commit_id": "dec6f7f5e5e92f0f3068480aef1430e3c2bac216", "commit_date": "Thu Mar 24 12:43:19 2022 +0100", "commit_message": "doc improvements", "files_name": ["README.md", "docs/index.md"]}, {"commit_id": "53fc8f13d42d52809a3fae9e2b61bd8d8669bdac", "commit_date": "Wed Apr 27 16:13:32 2022 +0200", "commit_message": "Autosave / better highlighting of when things aren't saved (#292)", "files_name": ["archivy/config.py", "archivy/routes.py", "archivy/templates/dataobjs/show.html", "archivy/templates/home.html", "docs/config.md", "docs/editing.md", "requirements.txt"]}, {"commit_id": "33d41e3f06d6b88a5a357b6502344279cbcdf903", "commit_date": "Wed Apr 27 22:19:35 2022 +0200", "commit_message": "v1.7.3: requirements fixes and auto-saves", "files_name": ["setup.py"]}, {"commit_id": "0f6704f2e17d5938e089a967c6d86be3eaf073af", "commit_date": "Thu Sep 8 06:28:04 2022 +0200", "commit_message": "Tag cloud per folder (#295)", "files_name": ["archivy/routes.py", "archivy/static/main.css", "archivy/templates/home.html"]}, {"commit_id": "f351afd15dcd9683b43028f79b75a02f5da6a8a9", "commit_date": "Thu Sep 8 06:34:17 2022 +0200", "commit_message": "fix site deployment", "files_name": ["docs/requirements.txt"]}, {"commit_id": "f4bf6308b286bf9cb864e3a9425718456939c73c", "commit_date": "Thu Sep 8 06:54:13 2022 +0200", "commit_message": "fix an install conflict", "files_name": ["requirements.txt"]}, {"commit_id": "7c5a4acf0647b0bb590ae2e6fd1400f68ed1621f", "commit_date": "Mon Dec 5 22:23:34 2022 -0500", "commit_message": "Create panel for recently modified pages in a given directory (#298)", "files_name": ["archivy/data.py", "archivy/models.py", "archivy/routes.py", "archivy/templates/home.html"]}, {"commit_id": "9be74471055ab08f95a86de13fd2b929f015432f", "commit_date": "Tue Jan 17 16:36:30 2023 +0100", "commit_message": "fix conflicts", "files_name": ["archivy/api.py", "archivy/models.py", "archivy/templates/home.html"]}, {"commit_id": "9e1869160ab1a2f6a77203f67eae69e28e9a070e", "commit_date": "Tue Nov 29 23:44:54 2022 +0100", "commit_message": "fix formatting and fix api endpoint", "files_name": ["archivy/api.py"]}, {"commit_id": "f8b4fce8732a1ae95b67433b0e829b0dff9c45c9", "commit_date": "Sun Dec 4 23:27:49 2022 +0100", "commit_message": "slight design changes", "files_name": ["archivy/templates/home.html"]}, {"commit_id": "a92f01b1e4549c9415be82b7b81e2f9839845073", "commit_date": "Sun Dec 4 23:31:57 2022 +0100", "commit_message": "fix html formattingg", "files_name": ["archivy/templates/home.html"]}, {"commit_id": "ffadbea84c7f6ad6dab1bfa7ef5c8147bc6f4c5e", "commit_date": "Tue Jan 17 16:58:20 2023 +0100", "commit_message": "v1.7.4", "files_name": ["setup.py"]}, {"commit_id": "1b76ca1060dae90fd50d0866a404eea7686d0be2", "commit_date": "Sun Jun 18 11:38:51 2023 -0400", "commit_message": "fix RAM usage and clean stuff up (#305)", "files_name": [".github/workflows/codecov.yml", "archivy/click_web/resources/cmd_exec.py", "archivy/data.py", "archivy/models.py", "archivy/routes.py", "archivy/tags.py", "requirements.txt", "tests/functional/test_routes.py", "tests/integration/test_api.py"]}, {"commit_id": "775f9d28ef2129d95043d3ce192cc3e7bdc84ae8", "commit_date": "Sun Jun 18 11:39:46 2023 -0400", "commit_message": "v1.7.5", "files_name": ["setup.py"]}, {"commit_id": "a89687d2a72bd910931c3663d0c9efe74190f4a9", "commit_date": "Sun Jun 18 11:47:37 2023 -0400", "commit_message": "bump python", "files_name": [".github/workflows/deploy-docs.yml", ".github/workflows/pypi-auto-deploy.yml"]}, {"commit_id": "7d602ab474931fc204af70ad11f4cfa4384d8006", "commit_date": "Sun Jun 18 11:50:35 2023 -0400", "commit_message": "bump docs", "files_name": ["docs/requirements.txt"]}, {"commit_id": "78e262fff7d84ffbfbfb2bc9c2567319f8656a44", "commit_date": "Mon Jun 19 12:34:31 2023 -0400", "commit_message": "update ubuntu version", "files_name": [".github/workflows/pypi-auto-deploy.yml"]}, {"commit_id": "b1f4fc6f1c5f1b8be4290592e7937da948f73402", "commit_date": "Tue Jul 25 18:48:27 2023 -0400", "commit_message": "v1.7.6: add a load_content option for some workflows where being able to load the content is very valuable", "files_name": ["archivy/data.py", "setup.py"]}, {"commit_id": "bdcdd39ac6cf9f7b3709b984d8be2f0fa898139e", "commit_date": "Tue Jul 25 19:32:46 2023 -0400", "commit_message": "v1.7.7 fixing dependency conflicts...", "files_name": ["requirements.txt", "setup.py"]}], "parents": [{"commit_id_before": "fa389e7d59f91980693965830839d6de1f1db45f", "url_before": "https://api.github.com/repos/archivy/archivy/commits/fa389e7d59f91980693965830839d6de1f1db45f", "html_url_before": "https://github.com/archivy/archivy/commit/fa389e7d59f91980693965830839d6de1f1db45f"}], "details": [{"raw_url": "https://github.com/archivy/archivy/raw/2d8cb29853190d42572b36deb61127e68d6be574/archivy%2Fhelpers.py", "code": "from pathlib import Path\nimport sys\nimport os\n\nimport elasticsearch\nimport yaml\nfrom elasticsearch import Elasticsearch\nfrom flask import current_app, g, request\nfrom tinydb import TinyDB, Query, operations\nfrom urllib.parse import urlparse, urljoin\n\nfrom archivy.config import BaseHooks, Config\n\n\ndef load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)\n\n\ndef config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1\n\n\ndef write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)\n\n\ndef load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()\n\n\ndef load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})\n\n\ndef get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db\n\n\ndef get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]\n\n\ndef set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")\n\n\ndef test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )\n\n\ndef get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es\n\n\ndef create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False\n\n\ndef is_safe_redirect_url(target):\n    host_url = urlparse(request.host_url)\n    redirect_url = urlparse(urljoin(request.host_url, target))\n    return (\n        redirect_url.scheme in (\"http\", \"https\")\n        and host_url.netloc == redirect_url.netloc\n    )\n", "code_before": "from pathlib import Path\nimport sys\nimport os\n\nimport elasticsearch\nimport yaml\nfrom elasticsearch import Elasticsearch\nfrom flask import current_app, g\nfrom tinydb import TinyDB, Query, operations\n\nfrom archivy.config import BaseHooks, Config\n\n\ndef load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)\n\n\ndef config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1\n\n\ndef write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)\n\n\ndef load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()\n\n\ndef load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})\n\n\ndef get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db\n\n\ndef get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]\n\n\ndef set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")\n\n\ndef test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )\n\n\ndef get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es\n\n\ndef create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False\n", "patch": "@@ -5,8 +5,9 @@\n import elasticsearch\n import yaml\n from elasticsearch import Elasticsearch\n-from flask import current_app, g\n+from flask import current_app, g, request\n from tinydb import TinyDB, Query, operations\n+from urllib.parse import urlparse, urljoin\n \n from archivy.config import BaseHooks, Config\n \n@@ -230,3 +231,12 @@ def create_plugin_dir(name):\n         return True\n     except FileExistsError:\n         return False\n+\n+\n+def is_safe_redirect_url(target):\n+    host_url = urlparse(request.host_url)\n+    redirect_url = urlparse(urljoin(request.host_url, target))\n+    return (\n+        redirect_url.scheme in (\"http\", \"https\")\n+        and host_url.netloc == redirect_url.netloc\n+    )", "file_path": "files/2022_3/717", "file_language": "py", "file_name": "archivy/helpers.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)", "target": 0}, {"function": "def config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1", "target": 0}, {"function": "def write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)", "target": 0}, {"function": "def load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()", "target": 0}, {"function": "def load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})", "target": 0}, {"function": "def get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db", "target": 0}, {"function": "def get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]", "target": 0}, {"function": "def set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")", "target": 0}, {"function": "def test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )", "target": 0}, {"function": "def get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es", "target": 0}, {"function": "def create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False", "target": 0}], "function_after": [{"function": "def load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)", "target": 0}, {"function": "def config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1", "target": 0}, {"function": "def write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)", "target": 0}, {"function": "def load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()", "target": 0}, {"function": "def load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})", "target": 0}, {"function": "def get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db", "target": 0}, {"function": "def get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]", "target": 0}, {"function": "def set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")", "target": 0}, {"function": "def test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )", "target": 0}, {"function": "def get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es", "target": 0}, {"function": "def create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False", "target": 0}, {"function": "def is_safe_redirect_url(target):\n    host_url = urlparse(request.host_url)\n    redirect_url = urlparse(urljoin(request.host_url, target))\n    return (\n        redirect_url.scheme in (\"http\", \"https\")\n        and host_url.netloc == redirect_url.netloc\n    )", "target": 0}]}, {"raw_url": "https://github.com/archivy/archivy/raw/2d8cb29853190d42572b36deb61127e68d6be574/archivy%2Froutes.py", "code": "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms, csrf\nfrom archivy.helpers import get_db, write_config, is_safe_redirect_url\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search, search_frontmatter_tags\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    results = search(f\"#{tag_name}#\", strict=True)\n    res_ids = set(\n        [item[\"id\"] for item in results]\n    )  # avoid duplication of results between context-aware embedded tags and metadata ones\n    for res in search_frontmatter_tags(tag_name):\n        if res[\"id\"] not in res_ids:\n            results.append(res)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            if next_url and is_safe_redirect_url(next_url):\n                return redirect(next_url)\n            else:\n                return redirect(\"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n\n\n@csrf.exempt  # exempt from CSRF to be able to submit info directly from bookmarklet\n@app.route(\"/save_from_bookmarklet\", methods=[\"POST\"])\ndef save_raw_url():\n    \"\"\"\n    Used in the bookmarklet - Saves a URL by taking its raw HTML.\n\n    POST parameters:\n    - html\n    - url\n    \"\"\"\n    html = request.form.get(\"html\")\n    if not html:\n        return \"No HTML provided\", 400\n    bookmark = DataObj(url=request.form.get(\"url\"), type=\"bookmark\")\n    bookmark.process_bookmark_url(html)\n    if bookmark.insert():\n        return redirect(f\"/dataobj/{bookmark.id}\")\n    else:\n        return \"Could not save bookmark\", 500\n", "code_before": "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms, csrf\nfrom archivy.helpers import get_db, write_config\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search, search_frontmatter_tags\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    results = search(f\"#{tag_name}#\", strict=True)\n    res_ids = set(\n        [item[\"id\"] for item in results]\n    )  # avoid duplication of results between context-aware embedded tags and metadata ones\n    for res in search_frontmatter_tags(tag_name):\n        if res[\"id\"] not in res_ids:\n            results.append(res)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            return redirect(next_url or \"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n\n\n@csrf.exempt  # exempt from CSRF to be able to submit info directly from bookmarklet\n@app.route(\"/save_from_bookmarklet\", methods=[\"POST\"])\ndef save_raw_url():\n    \"\"\"\n    Used in the bookmarklet - Saves a URL by taking its raw HTML.\n\n    POST parameters:\n    - html\n    - url\n    \"\"\"\n    html = request.form.get(\"html\")\n    if not html:\n        return \"No HTML provided\", 400\n    bookmark = DataObj(url=request.form.get(\"url\"), type=\"bookmark\")\n    bookmark.process_bookmark_url(html)\n    if bookmark.insert():\n        return redirect(f\"/dataobj/{bookmark.id}\")\n    else:\n        return \"Could not save bookmark\", 500\n", "patch": "@@ -19,7 +19,7 @@\n \n from archivy.models import DataObj, User\n from archivy import data, app, forms, csrf\n-from archivy.helpers import get_db, write_config\n+from archivy.helpers import get_db, write_config, is_safe_redirect_url\n from archivy.tags import get_all_tags\n from archivy.search import search, search_frontmatter_tags\n from archivy.config import Config\n@@ -264,7 +264,10 @@ def login():\n             flash(\"Login successful!\", \"success\")\n \n             next_url = request.args.get(\"next\")\n-            return redirect(next_url or \"/\")\n+            if next_url and is_safe_redirect_url(next_url):\n+                return redirect(next_url)\n+            else:\n+                return redirect(\"/\")\n \n         flash(\"Invalid credentials\", \"error\")\n         return redirect(\"/login\")", "file_path": "files/2022_3/718", "file_language": "py", "file_name": "archivy/routes.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.open-redirect.open-redirect                                             \n          Data from request is passed to redirect(). This is an open redirect and could be exploited.\n          Consider using 'url_for()' to generate links to known locations. If you must use a URL to  \n          unknown pages, consider using 'urlparse()' or similar and checking if the 'netloc' property\n          is the same as your site's host name. See the references for more information.             \n          Details: https://sg.run/kXe2                                                               \n\n          266\u2506 next_url = request.args.get(\"next\")\n          267\u2506 return redirect(next_url or \"/\")"]]}, "target": 1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
