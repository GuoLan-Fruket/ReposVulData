{"index": 6137, "cve_id": "CVE-2021-23393", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "This affects the package Flask-Unchained before 0.9.0. When using the the _validate_redirect_url function, it is possible to bypass URL validation and redirect a user to an arbitrary URL by providing multiple back slashes such as \\\\\\evil.com/path. This vulnerability is only exploitable if an alternative WSGI server other than Werkzeug is used, or the default behaviour of Werkzeug is modified using 'autocorrect_location_header=False.", "cvss": "5.4", "publish_date": "June 10, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "71e36b28166f9ffbe0a991f51127f0984f7e6a40", "commit_message": "add tests for validate_redirect_url", "commit_date": "2021-05-27T18:39:02Z", "project": "briancappello/flask-unchained", "url": "https://api.github.com/repos/briancappello/flask-unchained/commits/71e36b28166f9ffbe0a991f51127f0984f7e6a40", "html_url": "https://github.com/briancappello/flask-unchained/commit/71e36b28166f9ffbe0a991f51127f0984f7e6a40", "windows_before": [{"commit_id": "2bfeedf1bc31df851cab8c66df0c432b10406aad", "commit_date": "Thu May 27 13:47:52 2021 -0400", "commit_message": "security fixes", "files_name": ["flask_unchained/bundles/controller/utils.py"]}, {"commit_id": "b38d16fee010b99531149669a52428f6682f77d4", "commit_date": "Sun May 23 09:32:36 2021 -0400", "commit_message": "fix ipython version for py36", "files_name": ["requirements.txt"]}, {"commit_id": "ec83553cb938e232e2fde4a7dfaa09644d0dd824", "commit_date": "Sat May 22 14:44:31 2021 -0400", "commit_message": "make bundle blueprint compatible with flask 1 and 2", "files_name": ["flask_unchained/bundles/controller/bundle_blueprint.py"]}, {"commit_id": "9059042efeca88caf9424455faa7e37942499d62", "commit_date": "Sat May 22 14:44:16 2021 -0400", "commit_message": "more api bundle fixes", "files_name": ["flask_unchained/bundles/api/__init__.py", "flask_unchained/bundles/api/apispec.py", "flask_unchained/bundles/api/config.py", "flask_unchained/bundles/api/extensions/api.py", "flask_unchained/bundles/api/hooks/register_model_resources_hook.py", "flask_unchained/bundles/api/hooks/register_model_serializers_hook.py", "flask_unchained/bundles/api/model_serializer.py", "flask_unchained/bundles/api/openapi_converter.py", "requirements.txt"]}, {"commit_id": "8124c46b33ba51468676b3a5fbd52f8f66f171db", "commit_date": "Thu May 13 10:36:52 2021 -0400", "commit_message": "fix and improve api bundle", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/api/__init__.py", "flask_unchained/bundles/api/apispec.py", "flask_unchained/bundles/api/config.py", "flask_unchained/bundles/api/extensions/api.py", "flask_unchained/bundles/api/extensions/marshmallow.py", "flask_unchained/bundles/api/templates/open_api/redoc.html", "flask_unchained/bundles/api/views.py", "setup.py"]}, {"commit_id": "6e58a603f57973e1432acfaddd4ee2964fae9691", "commit_date": "Sat May 1 10:53:46 2021 -0400", "commit_message": "bump required flask-sqlalchemy-unchained version", "files_name": ["CHANGELOG.md", "requirements.txt", "setup.py"]}, {"commit_id": "c25c6e17245eb4fcdd1112f2d2e70eb5058c5561", "commit_date": "Fri Apr 30 11:40:43 2021 -0400", "commit_message": "fix BundleBlueprint to work with flask 2", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/controller/bundle_blueprint.py"]}, {"commit_id": "85d6cd01cf38b591f5a0b9bdd298cebaa54118c2", "commit_date": "Fri Apr 30 11:39:23 2021 -0400", "commit_message": "add shell readline completion", "files_name": ["CHANGELOG.md", "flask_unchained/commands/shell.py"]}, {"commit_id": "04fb2fef67283fbd18dce368546d9398115e92f1", "commit_date": "Fri Apr 30 11:37:32 2021 -0400", "commit_message": "fix deprecation warning", "files_name": ["flask_unchained/pytest.py"]}, {"commit_id": "9d0b700c1093821502b43f4926fdadaa25e06a68", "commit_date": "Fri Apr 30 11:36:25 2021 -0400", "commit_message": "fix security bundle salt config for itsdangerous 2.0+", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/security/config.py", "flask_unchained/bundles/security/extensions/security.py"]}, {"commit_id": "aed88d116e05c56b3c4b536a0963c7c19333e76d", "commit_date": "Sun Jan 17 22:01:24 2021 -0500", "commit_message": "release v0.8.1", "files_name": ["CHANGELOG.md", "docs/conf.py", "flask_unchained/__init__.py", "flask_unchained/_code_templates/project/requirements.txt", "requirements.txt", "setup.cfg", "setup.py"]}, {"commit_id": "c327c102e3695366f674a9bfc80e086224ce80c7", "commit_date": "Sun Jan 17 21:55:31 2021 -0500", "commit_message": "add default Model Admins for the User and Role models", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/security/admins/__init__.py", "flask_unchained/bundles/security/admins/role_admin.py", "flask_unchained/bundles/security/admins/user_admin.py", "flask_unchained/bundles/security/config.py"]}, {"commit_id": "9832c6826f5a1464a600be30814df66807764cc8", "commit_date": "Sun Jan 17 21:54:10 2021 -0500", "commit_message": "do not register duplicate templates folder for single-module app bundle", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/controller/bundle_blueprint.py"]}, {"commit_id": "eb10eb65fe50c82c5a93bf3001c53f24ee9cefee", "commit_date": "Sun Jan 17 21:53:21 2021 -0500", "commit_message": "add Admin-specific post login/logout redirect endpoints", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/admin/config.py", "flask_unchained/bundles/admin/templates/admin/login.html", "flask_unchained/bundles/admin/views/admin_security_controller.py"]}, {"commit_id": "ead874d7c04e6096b81786cb17760ef42c71c2a7", "commit_date": "Sun Jan 17 21:39:57 2021 -0500", "commit_message": "defer initialization of the Admin extension to fix template overriding", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/admin/__init__.py", "flask_unchained/bundles/admin/extensions/admin.py"]}, {"commit_id": "8897686e8f30e4658db5db11563948ad3d100a2a", "commit_date": "Sun Jan 17 21:38:48 2021 -0500", "commit_message": "upgrade Flask-Admin templates to bootstrap4", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/admin/config.py", "flask_unchained/bundles/admin/templates/admin/_macros.html", "flask_unchained/bundles/admin/templates/admin/column_formatters.html", "flask_unchained/bundles/admin/templates/admin/dashboard.html", "flask_unchained/bundles/admin/templates/admin/layout.html", "flask_unchained/bundles/admin/templates/admin/login.html", "flask_unchained/bundles/admin/templates/admin/master.html"]}, {"commit_id": "ac5608334752e76a0540478c15d4d1cc8b82cae2", "commit_date": "Sun Jan 17 21:36:12 2021 -0500", "commit_message": "fix default config settings for `ADMIN_LOGIN_ENDPOINT` and `ADMIN_LOGOUT_ENDPOINT`", "files_name": ["CHANGELOG.md", "docs/bundles/admin.rst", "flask_unchained/bundles/admin/config.py"]}, {"commit_id": "d882b289fcc9361679a1499d3e6a22da53295ca8", "commit_date": "Sun Jan 17 21:14:41 2021 -0500", "commit_message": "rename `User.active` to `User.is_active` for compatibility with Flask-Login v0.5", "files_name": ["CHANGELOG.md", "docs/index.rst", "docs/tutorial/security.rst", "flask_unchained/_code_templates/project/db/fixtures/User.yaml", "flask_unchained/bundles/security/commands/users.py", "flask_unchained/bundles/security/models/anonymous_user.py", "flask_unchained/bundles/security/models/user.py", "flask_unchained/bundles/security/serializers/user_serializer.py", "flask_unchained/bundles/security/services/security_service.py", "tests/bundles/security/commands/test_users.py", "tests/bundles/security/conftest.py", "tests/bundles/security/views/security_controller/test_confirm_email.py", "tests/bundles/security/views/security_controller/test_login.py"]}, {"commit_id": "23b824c113aaf4f9ec4c7800983ead3785dfa233", "commit_date": "Sun Dec 20 11:40:09 2020 -0500", "commit_message": "update readme now that v0.8 is on pypi", "files_name": ["README.md"]}, {"commit_id": "7730362f48f280dfacde0e117688b833e9ed0036", "commit_date": "Sun Dec 20 11:38:43 2020 -0500", "commit_message": "release v0.8.0", "files_name": ["CHANGELOG.md", "docs/conf.py", "flask_unchained/__init__.py", "flask_unchained/_code_templates/project/requirements.txt", "setup.cfg", "setup.py"]}, {"commit_id": "15d5d72eb0d8d27ca5859c4be626f714afa31f4f", "commit_date": "Sun Dec 20 11:37:51 2020 -0500", "commit_message": "add quart asyncio to changelog", "files_name": ["CHANGELOG.md", "TODO.md"]}, {"commit_id": "2b5c9d15c2d894a7e6dfb4f6dfad2d1b607530e7", "commit_date": "Sun Dec 20 11:36:54 2020 -0500", "commit_message": "rename a few variables", "files_name": ["flask_unchained/hooks/run_hooks_hook.py"]}, {"commit_id": "0474625a6cff9349efa5c46af6963c805dfe06bc", "commit_date": "Wed Dec 16 21:46:17 2020 -0500", "commit_message": "improve introduction docs", "files_name": ["docs/how-flask-unchained-works.rst", "docs/index.rst"]}, {"commit_id": "8f4737d01526ee5ffc3807158c5616c8f5fa3064", "commit_date": "Wed Dec 16 21:45:27 2020 -0500", "commit_message": "fix bug in controller_name when passed a str", "files_name": ["flask_unchained/bundles/controller/route.py", "flask_unchained/bundles/controller/utils.py"]}, {"commit_id": "5af53ad0705d2e356e593e845163b7ed74a42c4e", "commit_date": "Wed Dec 16 21:44:54 2020 -0500", "commit_message": "improve type checker function type hints", "files_name": ["flask_unchained/app_factory.py", "flask_unchained/app_factory_hook.py"]}, {"commit_id": "511b42666f7f8da715a57de2969ee2491c97f79b", "commit_date": "Wed Dec 16 21:43:54 2020 -0500", "commit_message": "reduce global toc depth to 2", "files_name": ["docs/conf.py", "docs/table-of-contents.rst"]}, {"commit_id": "ab461acd1146a47eb80383ec6a3852f34ae438fe", "commit_date": "Fri Nov 27 01:11:23 2020 -0500", "commit_message": "whitespace", "files_name": ["README.md", "docs/bundles/controller.rst", "docs/index.rst", "docs/tutorial/getting_started.rst", "flask_unchained/bundles/controller/controller.py"]}, {"commit_id": "21cf9282e7281d3b2db6f88a76f1d9a442af264e", "commit_date": "Fri Nov 27 01:00:18 2020 -0500", "commit_message": "lower min ipython version to 7.16.0 for python3.6 support", "files_name": ["requirements.txt", "setup.py"]}, {"commit_id": "d296aed2b0881de96b6190b99259d2d3979f855f", "commit_date": "Wed Nov 25 19:15:06 2020 -0500", "commit_message": "simplify example for enabling CSRF", "files_name": ["CHANGELOG.md"]}, {"commit_id": "e2cf25f23ca9de6dad64e4424137e6e83da979b1", "commit_date": "Wed Nov 25 19:14:47 2020 -0500", "commit_message": "rename UNCHAINED_CONFIG env var to just UNCHAINED", "files_name": ["CHANGELOG.md", "README.md", "docs/how-flask-unchained-works.rst", "flask_unchained/app_factory.py"]}, {"commit_id": "8788731a71d8f8491a26e45b83eb3d4c2ef1b00b", "commit_date": "Wed Nov 25 19:09:54 2020 -0500", "commit_message": "Merge remote-tracking branch 'origin/master'", "files_name": ["1fdeda728beffa69f5212356870f0c79e76a8a38 - Wed Nov 25 19:09:35 2020 -0500 : bump a few reqs", "requirements-dev.txt", "requirements.txt", "setup.py"]}, {"commit_id": "efad58a2af2f103bcf9a998b04649d7dfa287f06", "commit_date": "Mon Nov 23 09:37:46 2020 -0500", "commit_message": "fall back to returning json from model resource if we can", "files_name": ["flask_unchained/bundles/api/model_resource.py"]}, {"commit_id": "9cedaa5d725d71633ded01c6293e37c3e999b7bd", "commit_date": "Mon Nov 23 09:36:04 2020 -0500", "commit_message": "support using un-instantiated classes for ModelResource serializer meta options", "files_name": ["flask_unchained/bundles/api/hooks/register_model_resources_hook.py", "flask_unchained/bundles/api/model_resource.py"]}, {"commit_id": "6dc6c7e4b457a57c380d25da259713ee4e2d4110", "commit_date": "Mon Nov 23 09:35:07 2020 -0500", "commit_message": "fix include_methods and exclude_methods on Resources", "files_name": ["flask_unchained/bundles/api/model_resource.py"]}, {"commit_id": "18ab65b5cb8681fd61e21cc8f44cde0743e698de", "commit_date": "Mon Nov 23 09:34:14 2020 -0500", "commit_message": "correctly support resource routes when not using declarative routing", "files_name": ["flask_unchained/bundles/controller/hooks/register_routes_hook.py"]}, {"commit_id": "95e0f5e38feef6d99f5751c6bcf874f12f168ee1", "commit_date": "Mon Nov 23 09:32:51 2020 -0500", "commit_message": "form error-handling logic fix", "files_name": ["flask_unchained/bundles/security/views/security_controller.py"]}, {"commit_id": "fe04a923f11b823cdc9467af5e5b71d15201e66b", "commit_date": "Mon Nov 23 09:32:20 2020 -0500", "commit_message": "allow the sqlalchemy extension to be used in Bundle.after_init_app", "files_name": ["flask_unchained/bundles/sqlalchemy/extensions/sqlalchemy_unchained.py"]}, {"commit_id": "562794e5fdf5d17158286fcc0cabffdfd9b38d9e", "commit_date": "Mon Nov 23 09:25:23 2020 -0500", "commit_message": "add debug helper exception when method on unchained ext doesnt exist", "files_name": ["flask_unchained/unchained.py"]}], "windows_after": [{"commit_id": "f973677ed82a88b2b40c6f8044a84517135eb111", "commit_date": "Mon Jun 7 18:59:00 2021 -0400", "commit_message": "compat with marshmallow-sqlalchemy 0.26", "files_name": ["flask_unchained/bundles/api/model_serializer.py"]}, {"commit_id": "14ba22995ad044cd4795f5280ba1335aa6403ad1", "commit_date": "Mon Jun 7 18:59:32 2021 -0400", "commit_message": "remove unused import", "files_name": ["flask_unchained/bundles/api/hooks/register_model_serializers_hook.py"]}, {"commit_id": "d96fd3a1fb32c8f4703d4ec14d2acb50230f825f", "commit_date": "Mon Jun 7 18:59:54 2021 -0400", "commit_message": "compat with click 8.0", "files_name": ["CHANGELOG.md", "flask_unchained/click.py"]}, {"commit_id": "3c10948bb77328945274df93aeffc351feb9b467", "commit_date": "Mon Jun 7 19:03:28 2021 -0400", "commit_message": "bump requirements", "files_name": ["flask_unchained/_code_templates/project/requirements-dev.txt", "requirements-dev.txt", "requirements.txt", "setup.py", "tox.ini"]}, {"commit_id": "0cd74e95b09ed7b3f2dff47daa1c9c91e2095fc6", "commit_date": "Mon Jun 7 19:09:53 2021 -0400", "commit_message": "Merge remote-tracking branch 'origin' into merge-upstream", "files_name": ["229d4704de3916ceb79a0b7e35906d803a6f77d2 - Mon Jun 7 19:13:40 2021 -0400 : add back missing flask-wtf requirement", "requirements.txt"]}, {"commit_id": "f282da7b65eb9644cc0d0b1b4c11e74ca04f9dd3", "commit_date": "Mon Jun 7 19:17:33 2021 -0400", "commit_message": "release v0.9.0", "files_name": ["CHANGELOG.md", "docs/conf.py", "flask_unchained/__init__.py", "flask_unchained/_code_templates/project/requirements.txt", "setup.cfg", "setup.py"]}, {"commit_id": "ffb0590c1373568d44c4d44f37d474bc1ef0095d", "commit_date": "Tue Jun 8 10:59:17 2021 -0400", "commit_message": "update docs to reflect python 3.7+", "files_name": [".readthedocs.yml", ".travis.yml", "docs/index.rst", "docs/tutorial/index.rst"]}, {"commit_id": "287d5dc00ae4c3a1c086a28f2a01a79ed087742d", "commit_date": "Tue Jun 8 11:03:38 2021 -0400", "commit_message": "add twine to dev reqs", "files_name": ["requirements-dev.txt"]}, {"commit_id": "5762795c57df2aba2bf90d025c677b6c1a9b91db", "commit_date": "Mon Jul 5 14:28:53 2021 -0400", "commit_message": "do not require the API bundle to be enabled to use the Security Bundle", "files_name": ["CHANGELOG.md", "flask_unchained/app_factory_hook.py", "flask_unchained/bundles/controller/hooks/register_blueprints_hook.py", "flask_unchained/bundles/security/views/__init__.py"]}, {"commit_id": "b3a2d06717fd664f4c4b4792a279f1d75f24a50c", "commit_date": "Mon Jul 5 14:51:25 2021 -0400", "commit_message": "fix auto-generated imports in db migrations requiring user app code", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/sqlalchemy/alembic/migrations.py"]}, {"commit_id": "5410d82789e76b9502167c7c6c9c515d5ce2bba9", "commit_date": "Tue Jul 20 10:28:15 2021 -0600", "commit_message": "update app bundle code template", "files_name": ["flask_unchained/_code_templates/project/app/__init__.py"]}, {"commit_id": "643841871ccb63b3e5a1a9f1604132cdd4c6ce5d", "commit_date": "Tue Jul 20 10:28:26 2021 -0600", "commit_message": "add compat for flask-session 0.4.0", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/session/session_interfaces/sqla.py"]}, {"commit_id": "aa07da4c7be2505f99d21fdcb069df6e0f8bce77", "commit_date": "Tue Jul 20 13:50:40 2021 -0600", "commit_message": "remove jinja2-time extension from new project template", "files_name": ["flask_unchained/_code_templates/project/app/__init__.py", "flask_unchained/_code_templates/project/requirements.txt"]}, {"commit_id": "0bd7051573324ef26100b483b8e1c6293e21b364", "commit_date": "Tue Jul 20 13:51:09 2021 -0600", "commit_message": "include a managers package in the generated new project template", "files_name": ["flask_unchained/_code_templates/project/app/managers/__init__.py", "flask_unchained/commands/new.py"]}, {"commit_id": "0126621240bc414b19e8fca653a20a26013b6048", "commit_date": "Tue Jul 20 13:51:25 2021 -0600", "commit_message": "configure the session bundle to use filesystem storage by default", "files_name": ["flask_unchained/bundles/session/config.py"]}, {"commit_id": "ce2df0267382acbd436fe2159132eae4964e598b", "commit_date": "Tue Jul 20 14:59:20 2021 -0600", "commit_message": "fix compatibility with Flask-WTF auto-population of form data on submit", "files_name": ["CHANGELOG.md", "flask_unchained/forms/fields.py", "flask_unchained/forms/flask_form.py", "flask_unchained/forms/validators.py"]}, {"commit_id": "e5ccc99ac20e471a0fa36df636fe009ed6c5e2b2", "commit_date": "Wed Jul 28 21:19:24 2021 -0600", "commit_message": "fix resolving hook order with networkx>2.5", "files_name": ["flask_unchained/bundles/controller/hooks/register_routes_hook.py", "flask_unchained/hooks/configure_app_hook.py"]}, {"commit_id": "0d6e316ce44eab3f903a2bc15d763dbb804c5018", "commit_date": "Tue Aug 3 13:45:23 2021 -0600", "commit_message": "move some more database code into sqlalchemy-unchained", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/sqlalchemy/meta_options.py", "flask_unchained/bundles/sqlalchemy/model_registry.py", "requirements.txt", "setup.py"]}, {"commit_id": "c4ab8f1c5c50a2bfa9622a7bff510d649e23bcee", "commit_date": "Tue Aug 3 13:58:43 2021 -0600", "commit_message": "allow extensions to specify optional dependent extensions", "files_name": ["CHANGELOG.md", "docs/bundles/session.rst", "flask_unchained/bundles/session/config.py", "flask_unchained/bundles/session/extensions/__init__.py", "flask_unchained/bundles/session/extensions/session.py", "flask_unchained/hooks/init_extensions_hook.py"]}, {"commit_id": "a31b5b334d0c9f1b6f367a5c3ec74edd807af0fb", "commit_date": "Tue Aug 3 13:59:23 2021 -0600", "commit_message": "add compatibility with upcoming wtforms v3", "files_name": ["CHANGELOG.md", "flask_unchained/_compat.py", "flask_unchained/forms/_compat.py", "flask_unchained/forms/fields.py"]}, {"commit_id": "dc2442354c31198848420879e648f78af09dd171", "commit_date": "Tue Aug 3 14:00:22 2021 -0600", "commit_message": "add support for specifying the model converter class for sqlalchemy forms", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/sqlalchemy/forms.py"]}, {"commit_id": "5cb707c8c41fb27d2c162f5aa414b5de0ac08684", "commit_date": "Tue Aug 3 14:01:37 2021 -0600", "commit_message": "minor admin bundle bugfixes and improvements", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/admin/config.py", "flask_unchained/bundles/admin/hooks/register_model_admins_hook.py", "flask_unchained/bundles/admin/model_admin.py", "flask_unchained/bundles/security/admins/role_admin.py", "flask_unchained/bundles/security/admins/user_admin.py", "flask_unchained/bundles/security/models/role.py"]}, {"commit_id": "4ec5a92b6db2ee685419309fa327f17adc5f9619", "commit_date": "Wed Aug 4 14:25:53 2021 -0600", "commit_message": "begin documenting ModelAdmin better", "files_name": ["flask_unchained/bundles/admin/model_admin.py"]}, {"commit_id": "131d8ff53453b45fe4de0f4cb40432086a79c256", "commit_date": "Wed Aug 4 14:26:12 2021 -0600", "commit_message": "admin template fixes for bootstrap4", "files_name": ["flask_unchained/bundles/admin/templates/admin/_macros.html"]}, {"commit_id": "a27f0a106dd96b01781937d99d44ee6fb5d6e13c", "commit_date": "Wed Aug 4 14:26:29 2021 -0600", "commit_message": "add flask users create-superuser command", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/security/commands/users.py"]}, {"commit_id": "acb9a52889fd1d8f31081b99b5df27eff509d6be", "commit_date": "Wed Aug 4 14:27:43 2021 -0600", "commit_message": "update default repr of User to include list of roles", "files_name": ["flask_unchained/bundles/security/models/user.py", "flask_unchained/bundles/security/services/user_manager.py"]}, {"commit_id": "e45b3dbc3da512c0cdd3c328e97f083b020cdf01", "commit_date": "Wed Aug 4 14:28:00 2021 -0600", "commit_message": "bump min required version of sqlalchemy-unchained to v0.12.2", "files_name": ["requirements.txt", "setup.py"]}, {"commit_id": "c88d7998cbe27ad0579b9572abb63939ea29ebcc", "commit_date": "Thu Aug 5 10:55:48 2021 -0700", "commit_message": "fix redirect when the next parameter is an url-encoded string", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/controller/utils.py"]}, {"commit_id": "9ebdc27c862e388610b4f2d71f5eb01890eabd50", "commit_date": "Thu Aug 5 10:58:59 2021 -0700", "commit_message": "admin details view should inherit formatters from the list view", "files_name": ["flask_unchained/bundles/admin/model_admin.py"]}, {"commit_id": "8af97855e5bd1f9b42ca66f557de10049098ea9e", "commit_date": "Thu Aug 5 10:59:57 2021 -0700", "commit_message": "change default admin date format to be compatible with both strftime and strptime", "files_name": ["flask_unchained/bundles/admin/model_admin.py"]}, {"commit_id": "ee0daca4a4e0e73560a619c0f7d35a64203fd592", "commit_date": "Thu Aug 5 11:00:18 2021 -0700", "commit_message": "class attributes are tricky", "files_name": ["flask_unchained/bundles/admin/model_admin.py"]}, {"commit_id": "2356d05ad819b47903d835d3f0ad86c83b7ef89e", "commit_date": "Thu Aug 5 11:02:11 2021 -0700", "commit_message": "update admin date column_formatters to match new format", "files_name": ["flask_unchained/bundles/admin/templates/admin/column_formatters.html"]}, {"commit_id": "3380b458d4225c479918d36dba1b8df4b767098f", "commit_date": "Thu Aug 5 11:02:54 2021 -0700", "commit_message": "fix admin login form post-redirect so the query param takes precedence over the form value", "files_name": ["flask_unchained/bundles/admin/templates/admin/login.html"]}, {"commit_id": "66e293949cb1257447fb808df681ee67b61d72e1", "commit_date": "Thu Aug 5 11:03:21 2021 -0700", "commit_message": "bad ideas are bad", "files_name": ["flask_unchained/bundles/admin/views/admin_security_controller.py"]}, {"commit_id": "604392c0a6128fa3e774355c7a51b76adef85730", "commit_date": "Thu Aug 5 11:04:48 2021 -0700", "commit_message": "add helper admin column_formatter functions for easily generating links to other admin views", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/admin/templates/__init__.py", "flask_unchained/bundles/security/admins/role_admin.py", "flask_unchained/bundles/security/admins/user_admin.py"]}, {"commit_id": "453180cf9f8885b03082c2365b10d6b5bc50b06f", "commit_date": "Sat Aug 21 10:32:32 2021 -0600", "commit_message": "improve function signature of db.slugify", "files_name": ["flask_unchained/bundles/sqlalchemy/sqla/events.py"]}, {"commit_id": "21d36848a3c0fde18fc1ebcded62118521206c5b", "commit_date": "Sat Aug 21 10:33:29 2021 -0600", "commit_message": "make default setting of the alembic migrations folder to be accessible from current_app", "files_name": ["flask_unchained/bundles/sqlalchemy/extensions/migrate.py"]}, {"commit_id": "1f868ce416b86ac3ef5302013321d816d22b1bf9", "commit_date": "Sat Aug 21 10:34:11 2021 -0600", "commit_message": "automatically increment database migration version if SQLAlchemy Bundle is enabled", "files_name": ["CHANGELOG.md", "flask_unchained/cli.py"]}, {"commit_id": "b4618b84f0fc8c8fad677ca17c2576d6083e749f", "commit_date": "Sat Aug 21 11:02:43 2021 -0600", "commit_message": "add backwards compatibility for UUID migration versions", "files_name": ["flask_unchained/cli.py"]}, {"commit_id": "5d5105222c6bcad38c8e8054d2cecd7408ac2d5f", "commit_date": "Sun Aug 22 21:56:14 2021 -0600", "commit_message": "refactor support for automatic sequentially numbered db migration versions", "files_name": ["flask_unchained/cli.py"]}, {"commit_id": "daa3d38b49a8805cb01cafc79e2aea87fc66c097", "commit_date": "Thu Aug 26 16:34:32 2021 -0600", "commit_message": "remove experimental `qtconsole` command", "files_name": ["CHANGELOG.md", "docs/commands.rst", "flask_unchained/cli.py", "flask_unchained/commands/__init__.py", "flask_unchained/commands/qtconsole.py", "requirements.txt", "setup.py"]}, {"commit_id": "faa0c7126806f3cb466db87b8c78a4b8ece72c6c", "commit_date": "Thu Aug 26 16:35:44 2021 -0600", "commit_message": "append uuid substr to migration version revids", "files_name": ["flask_unchained/cli.py"]}, {"commit_id": "bd65ad3587735a365f14d68a1b7d478e27c562e3", "commit_date": "Fri Sep 3 12:58:29 2021 -0600", "commit_message": "install m2r2 and bump sphinx", "files_name": ["docs/conf.py", "requirements-dev.txt", "setup.py"]}, {"commit_id": "2bee29ba96d4b3f1a9bc6d57d310971a6b373458", "commit_date": "Fri Sep 3 12:59:34 2021 -0600", "commit_message": "default alembic migrations to `compare_type=True`", "files_name": ["CHANGELOG.md", "flask_unchained/bundles/sqlalchemy/config.py"]}, {"commit_id": "5de8169d8128ed51ecaf6fd20f97278517885cf9", "commit_date": "Sun Oct 3 19:44:23 2021 -0600", "commit_message": "enable dependency injection on `ModelAdmin`", "files_name": ["flask_unchained/bundles/admin/model_admin.py"]}], "parents": [{"commit_id_before": "2bfeedf1bc31df851cab8c66df0c432b10406aad", "url_before": "https://api.github.com/repos/briancappello/flask-unchained/commits/2bfeedf1bc31df851cab8c66df0c432b10406aad", "html_url_before": "https://github.com/briancappello/flask-unchained/commit/2bfeedf1bc31df851cab8c66df0c432b10406aad"}], "details": [{"raw_url": "https://github.com/briancappello/flask-unchained/raw/71e36b28166f9ffbe0a991f51127f0984f7e6a40/flask_unchained%2Fbundles%2Fcontroller%2Futils.py", "code": "import re\n\nfrom flask import (Response, current_app, request, redirect as flask_redirect,\n                   url_for as flask_url_for)\nfrom flask_unchained.string_utils import kebab_case, right_replace, snake_case\nfrom flask_unchained._compat import is_local_proxy\nfrom py_meta_utils import _missing\nfrom typing import *\nfrom urllib.parse import urlsplit, quote as urlquote\nfrom werkzeug.routing import BuildError, UnicodeConverter\n\nfrom .attr_constants import CONTROLLER_ROUTES_ATTR, REMOVE_SUFFIXES_ATTR\n\n\nPARAM_NAME_RE = re.compile(r'<(\\w+:)?(?P<param_name>\\w+)>')\n\n\nclass StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)\n\n\ndef controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)\n\n\ndef get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]\n\n\ndef url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)\n\n\ndef join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'\n\n\ndef method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')\n\n\ndef encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=<>\")\n\n\n# modified from flask_security.utils.get_post_action_redirect\ndef redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')\n\n\ndef rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)\n\n\ndef _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default\n\n\ndef _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'\n\n\n# modified from flask_security.utils.validate_redirect_url\ndef _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True\n\n\n__all__ = [\n    'controller_name',\n    'get_param_tuples',\n    'join',\n    'method_name_to_url',\n    'redirect',\n    'rename_parent_resource_param_name',\n    'url_for',\n]\n", "code_before": "import re\n\nfrom flask import (Response, current_app, request, redirect as flask_redirect,\n                   url_for as flask_url_for)\nfrom flask_unchained.string_utils import kebab_case, right_replace, snake_case\nfrom flask_unchained._compat import is_local_proxy\nfrom py_meta_utils import _missing\nfrom typing import *\nfrom urllib.parse import urlsplit, quote as urlquote\nfrom werkzeug.routing import BuildError, UnicodeConverter\n\nfrom .attr_constants import CONTROLLER_ROUTES_ATTR, REMOVE_SUFFIXES_ATTR\n\n\nPARAM_NAME_RE = re.compile(r'<(\\w+:)?(?P<param_name>\\w+)>')\n\n\nclass StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)\n\n\ndef controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)\n\n\ndef get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]\n\n\ndef url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)\n\n\ndef join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'\n\n\ndef method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')\n\n\ndef encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=\")\n\n\n# modified from flask_security.utils.get_post_action_redirect\ndef redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')\n\n\ndef rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)\n\n\ndef _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default\n\n\ndef _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'\n\n\n# modified from flask_security.utils.validate_redirect_url\ndef _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True\n\n\n__all__ = [\n    'controller_name',\n    'get_param_tuples',\n    'join',\n    'method_name_to_url',\n    'redirect',\n    'rename_parent_resource_param_name',\n    'url_for',\n]\n", "patch": "@@ -185,7 +185,7 @@ def method_name_to_url(method_name) -> str:\n \n def encode_non_url_reserved_characters(url):\n     # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n-    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=\")\n+    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=<>\")\n \n \n # modified from flask_security.utils.get_post_action_redirect", "file_path": "files/2021_6/265", "file_language": "py", "file_name": "flask_unchained/bundles/controller/utils.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)", "target": 0}, {"function": "def controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)", "target": 0}, {"function": "def get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]", "target": 0}, {"function": "def url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)", "target": 0}, {"function": "def join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'", "target": 0}, {"function": "def method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')", "target": 0}, {"function": "def encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=\")", "target": 0}, {"function": "def redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')", "target": 0}, {"function": "def rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)", "target": 0}, {"function": "def _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default", "target": 0}, {"function": "def _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'", "target": 0}, {"function": "def _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True", "target": 0}], "function_after": [{"function": "class StringConverter(UnicodeConverter):\n    \"\"\"\n    This converter is the default converter and accepts any string but\n    only one path segment.  Thus the string can not include a slash.\n\n    This is the default validator.\n\n    Example::\n\n        Rule('/pages/<page>'),\n        Rule('/<string(length=2):lang_code>')\n\n    :param map: the :class:`Map`.\n    :param minlength: the minimum length of the string.  Must be greater\n                      or equal 1.\n    :param maxlength: the maximum length of the string.\n    :param length: the exact length of the string.\n    \"\"\"\n    def __init__(self, map, minlength=1, maxlength=None, length=None, upper=False):\n        super().__init__(map, minlength, maxlength, length)\n        self.is_upper = upper\n\n    def to_python(self, value: str):\n        if self.is_upper:\n            return super().to_python(value).upper()\n        return super().to_python(value)\n\n    def to_url(self, value):\n        if self.is_upper:\n            return super().to_url(value).upper()\n        return super().to_url(value)", "target": 0}, {"function": "def controller_name(\n    cls: Union[Type[object], str],  # FIXME Union[Type[Controller], str] on 3.7+\n    _remove_suffixes: Optional[Union[List[str], Tuple[str, ...]]] = None,\n) -> str:\n    \"\"\"\n    Returns the snake_cased name for a controller/resource class. Automatically\n    strips the ``Controller`` and ``View`` suffixes from controllers and resources,\n    as well as the ``Resource`` and ``MethodView`` suffixes from resources, eg::\n\n        SiteController -> site\n        FooBarBazView -> foo_bar_baz\n        UsersMethodView -> users\n        RoleResource -> role\n    \"\"\"\n    if isinstance(cls, str):\n        name = cls\n        remove_suffixes = _remove_suffixes or ()\n    else:\n        name = cls.__name__\n        remove_suffixes = _remove_suffixes or getattr(cls, REMOVE_SUFFIXES_ATTR)\n\n    for suffix in remove_suffixes:\n        if name.endswith(suffix):\n            name = right_replace(name, suffix, '')\n            break\n    return snake_case(name)", "target": 0}, {"function": "def get_param_tuples(url_rule: Union[str, None]) -> List[Tuple[str, str]]:\n    \"\"\"\n    Returns a list of parameter tuples in a URL rule, eg::\n\n        url_rule = '/users/<string:username>/roles/<int:id>'\n        param_tuples = get_param_tuples(url_rule)\n        assert param_tuples == [('string', 'username'), ('int', 'id')]\n    \"\"\"\n    if not url_rule:\n        return []\n    return [(type_[:-1], name) for type_, name\n            in re.findall(PARAM_NAME_RE, url_rule)]", "target": 0}, {"function": "def url_for(endpoint_or_url_or_config_key: Union[str, None],\n            _anchor: Optional[str] = None,\n            _cls: Optional[Union[object, type]] = None,\n            _external: Optional[bool] = False,\n            _external_host: Optional[str] = None,\n            _method: Optional[str] = None,\n            _scheme: Optional[str] = None,\n            **values,\n            ) -> Union[str, None]:\n    \"\"\"\n    An improved version of flask's url_for function\n\n    :param endpoint_or_url_or_config_key: what to lookup. it can be an endpoint\n      name, an app config key, or an already-formed url. if _cls is specified,\n      it also accepts a method name.\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, can also pass a method name as the first argument\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server\n        to generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    what = endpoint_or_url_or_config_key\n\n    # if what is a config key\n    if what and what.isupper():\n        what = current_app.config.get(what)\n\n    if is_local_proxy(what):\n        what = what._get_current_object()\n\n    # if we already have a url (or an invalid value, eg None)\n    if not what or '/' in what:\n        return what\n\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    # check if it's a class method name, and try that endpoint\n    if _cls and '.' not in what:\n        controller_routes = getattr(_cls, CONTROLLER_ROUTES_ATTR)\n        method_routes = controller_routes.get(what)\n        try:\n            return _url_for(method_routes[0].endpoint, **flask_url_for_kwargs)\n        except (\n            BuildError,  # url not found\n            IndexError,  # method_routes[0] is out-of-range (no routes on view)\n            TypeError,   # method_routes is None (\"what\" wasn't a view/method name)\n        ):\n            pass\n\n    # what must be an endpoint\n    return _url_for(what, **flask_url_for_kwargs)", "target": 0}, {"function": "def join(*args: Union[None, str], trailing_slash: bool = False) -> str:\n    \"\"\"\n    Return a url path joined from the arguments. It correctly handles blank/None\n    arguments, and removes back-to-back slashes, eg::\n\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n        assert join('/', '/foo', '/', '/bar/') == '/foo/bar'\n\n    Note that it removes trailing slashes by default, so if you want to keep those,\n    then you need to pass the ``trailing_slash`` keyword argument::\n\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n    \"\"\"\n    dirty_path = '/'.join(map(lambda x: x and x or '', args))\n    path = re.sub(r'/+', '/', dirty_path)\n    if path in {'', '/'}:\n        return '/'\n    path = path.rstrip('/')\n    return path if not trailing_slash else path + '/'", "target": 0}, {"function": "def method_name_to_url(method_name) -> str:\n    \"\"\"\n    Converts a method name to a url.\n    \"\"\"\n    return '/' + kebab_case(method_name).strip('-')", "target": 0}, {"function": "def encode_non_url_reserved_characters(url):\n    # safe url reserved characters: https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\n    return urlquote(url, safe=\":/?#[]@!$&'()*+,;=<>\")", "target": 0}, {"function": "def redirect(where: Optional[str] = None,\n             default: Optional[str] = None,\n             override: Optional[str] = None,\n             _anchor: Optional[str] = None,\n             _cls: Optional[Union[object, type]] = None,\n             _external: Optional[bool] = False,\n             _external_host: Optional[str] = None,\n             _method: Optional[str] = None,\n             _scheme: Optional[str] = None,\n             **values,\n             ) -> Response:\n    \"\"\"\n    An improved version of flask's redirect function\n\n    :param where: A URL, endpoint, or config key name to redirect to\n    :param default: A URL, endpoint, or config key name to redirect to if\n      ``where`` is invalid\n    :param override: explicitly redirect to a URL, endpoint, or config key name\n      (takes precedence over the ``next`` value in query strings or forms)\n    :param values: the variable arguments of the URL rule\n    :param _anchor: if provided this is added as anchor to the URL.\n    :param _cls: if specified, allows a method name to be passed to where,\n      default, and/or override\n    :param _external: if set to ``True``, an absolute URL is generated. Server\n      address can be changed via ``SERVER_NAME`` configuration variable which\n      defaults to `localhost`.\n    :param _external_host: if specified, the host of an external server to\n      generate urls for (eg https://example.com or localhost:8888)\n    :param _method: if provided this explicitly specifies an HTTP method.\n    :param _scheme: a string specifying the desired URL scheme. The `_external`\n      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The\n      default behavior uses the same scheme as the current request, or\n      ``PREFERRED_URL_SCHEME`` from the :ref:`app configuration <config>` if no\n      request context is available. As of Werkzeug 0.10, this also can be set\n      to an empty string to build protocol-relative URLs.\n    \"\"\"\n    flask_url_for_kwargs = dict(_anchor=_anchor, _external=_external,\n                                _external_host=_external_host, _method=_method,\n                                _scheme=_scheme, **values)\n\n    urls = [url_for(request.args.get('next'), **flask_url_for_kwargs),\n            url_for(request.form.get('next'), **flask_url_for_kwargs)]\n    if where:\n        urls.append(url_for(where, _cls=_cls, **flask_url_for_kwargs))\n    if default:\n        urls.append(url_for(default, _cls=_cls, **flask_url_for_kwargs))\n    if override:\n        urls.insert(0, url_for(override, _cls=_cls, **flask_url_for_kwargs))\n\n    for url in urls:\n        if _validate_redirect_url(url, _external_host):\n            return flask_redirect(encode_non_url_reserved_characters(url))\n    return flask_redirect('/')", "target": 0}, {"function": "def rename_parent_resource_param_name(route, rule: str) -> str:\n    ctrl_name = controller_name(route._parent_resource_cls)\n    type_, orig_name = get_param_tuples(route._parent_member_param)[0]\n    renamed_param = (route._unique_member_param\n                     or f'<{type_}:{ctrl_name}_{orig_name}>')\n    if renamed_param in rule:\n        type_, orig_name = get_param_tuples(route.unique_member_param)[0]\n        renamed_param = f'<{type_}:{ctrl_name}_{orig_name}>'\n    return rule.replace(route._parent_member_param, renamed_param, 1)", "target": 0}, {"function": "def _missing_to_default(arg, default=None):\n    return arg if arg is not _missing else default", "target": 0}, {"function": "def _url_for(endpoint: str, **values) -> Union[str, None]:\n    \"\"\"\n    The same as flask's url_for, except this also supports building external\n    urls for hosts that are different from app.config.SERVER_NAME. One case\n    where this is especially useful is for single page apps, where the frontend\n    is not hosted by the same server as the backend, but the backend still needs\n    to generate urls to frontend routes\n\n    :param endpoint: the name of the endpoint\n    :param values: the variable arguments of the URL rule\n    :return: a url path, or None\n    \"\"\"\n    _external_host = values.pop('_external_host', '')\n    is_external = bool(_external_host or values.get('_external'))\n    external_host = (\n        _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n    ).rstrip('/')\n    if not external_host or not is_external:\n        return flask_url_for(endpoint, **values)\n\n    values.pop('_external')  # do custom external host handling instead\n    scheme = values.pop('_scheme', 'http')\n    if '://' not in external_host:\n        external_host = f'{scheme}://{external_host}'\n    elif not external_host.startswith(f'{scheme}://'):\n        external_host = f\"{scheme}{external_host[external_host.find('://'):]}\"\n\n    url = flask_url_for(endpoint, **values)\n    if '://' in url:\n        url = url[url.find('/', url.find('://')+3):]\n    return f'{external_host}{url}'", "target": 0}, {"function": "def _validate_redirect_url(url, _external_host=None):\n    url = (url or '').strip().replace('\\\\', '/')\n\n    # reject empty urls and urls starting with 3+ slashes or a control character\n    if not url or url.startswith('///') or ord(url[0]) <= 32:\n        return False\n\n    url_next = urlsplit(url)\n    url_base = urlsplit(request.host_url)\n    if url_next.netloc or url_next.scheme:\n        # require both netloc and scheme\n        if not url_next.netloc or not url_next.scheme:\n            return False\n\n        # if external host, require same netloc and scheme\n        external_host = _external_host or current_app.config.get('EXTERNAL_SERVER_NAME', '')\n        if external_host:\n            url_external = urlsplit(external_host)\n            if url_next.netloc == url_external.netloc and url_next.scheme == url_external.scheme:\n                return True\n\n        # require same netloc and scheme\n        if url_next.netloc != url_base.netloc or url_next.scheme != url_base.scheme:\n            return False\n    return True", "target": 0}]}, {"raw_url": "https://github.com/briancappello/flask-unchained/raw/71e36b28166f9ffbe0a991f51127f0984f7e6a40/requirements.txt", "code": "alembic==1.5.8\napispec==4.4.1\napispec_webframeworks==0.5.2\nbcrypt==3.2.0\nbeautifulsoup4==4.9.3\nblinker==1.4\ncelery==4.4.7\nclick==7.1.2\ndill==0.3.3\nemail-validator==1.1.2\nflask==1.1.2\nflask-admin==1.5.8\nflask_babelex==0.9.4\nflask-graphql==2.0.1\nflask-login==0.5.0\nflask-marshmallow==0.14.0\nflask_migrate==2.7.0\nflask-oauthlib==0.9.5\nflask-principal==0.4.0\nflask-session==0.3.2\nflask-sqlalchemy==2.5.1\nflask-sqlalchemy-unchained==0.7.4\nflask_wtf==0.14.3\ngraphene==2.1.8\ngraphene-sqlalchemy==2.3.0\ngraphql-core>=2.3.2,<3\ngraphql-relay>=2.0.1,<3\ngraphql-server-core>=1.2.0,<2\nIPython==7.16.1\nitsdangerous==1.1.0\njedi==0.17.2\njinja2==2.11.3\nlxml==4.6.3\nmarkupsafe==1.1.1\nmarshmallow==3.12.1\nmarshmallow-sqlalchemy==0.25\nnetworkx==2.5.1\npasslib==1.7.4\npy-meta-utils==0.7.8\npy-yaml-fixtures==0.6.1\npyterminalsize\npyqt5==5.15.4\nspeaklater==1.3\nsqlalchemy==1.3.24\nsqlalchemy-unchained==0.11.0\nqtconsole==4.7.7\nwerkzeug==1.0.1\nwtforms==2.3.3\nwtforms_sqlalchemy==0.2\n", "code_before": "alembic==1.5.8\napispec==4.4.1\napispec_webframeworks==0.5.2\nbcrypt==3.2.0\nbeautifulsoup4==4.9.3\nblinker==1.4\ncelery==4.4.7\nclick==7.1.2\ndill==0.3.3\nemail-validator==1.1.2\nflask==1.1.2\nflask-admin==1.5.8\nflask_babelex==0.9.4\nflask-graphql==2.0.1\nflask-login==0.5.0\nflask-marshmallow==0.14.0\nflask_migrate==2.7.0\nflask-oauthlib==0.9.5\nflask-principal==0.4.0\nflask-session==0.3.2\nflask-sqlalchemy-unchained==0.7.4\nflask_wtf==0.14.3\ngraphene==2.1.8\ngraphene-sqlalchemy==2.3.0\ngraphql-core>=2.3.2,<3\ngraphql-relay>=2.0.1,<3\ngraphql-server-core>=1.2.0,<2\nIPython==7.16.1\nitsdangerous==1.1.0\njedi==0.17.2\njinja2==2.11.3\nlxml==4.6.3\nmarkupsafe==1.1.1\nmarshmallow==3.12.1\nmarshmallow-sqlalchemy==0.25\nnetworkx==2.5.1\npasslib==1.7.4\npy-meta-utils==0.7.8\npy-yaml-fixtures==0.6.1\npyterminalsize\npyqt5==5.15.4\nspeaklater==1.3\nsqlalchemy==1.3.24\nsqlalchemy-unchained==0.11.0\nqtconsole==4.7.7\nwerkzeug==1.0.1\nwtforms==2.3.3\nwtforms_sqlalchemy==0.2\n", "patch": "@@ -18,6 +18,7 @@ flask_migrate==2.7.0\n flask-oauthlib==0.9.5\n flask-principal==0.4.0\n flask-session==0.3.2\n+flask-sqlalchemy==2.5.1\n flask-sqlalchemy-unchained==0.7.4\n flask_wtf==0.14.3\n graphene==2.1.8", "file_path": "files/2021_6/266", "file_language": "txt", "file_name": "requirements.txt", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/briancappello/flask-unchained/raw/71e36b28166f9ffbe0a991f51127f0984f7e6a40/tests%2Fbundles%2Fcontroller%2Ftest_utils.py", "code": "import pytest\n\nfrom werkzeug.routing import BuildError\n\nfrom flask_unchained.bundles.controller import Controller, Resource\nfrom flask_unchained.bundles.controller.utils import (\n    controller_name, get_param_tuples, join,\n    method_name_to_url, url_for, _validate_redirect_url)\nfrom py_meta_utils import deep_getattr\n\n\ndef test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'\n\n\nclass TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'\n\n\nclass TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]\n\n\nclass TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)\n\n\nclass TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'\n\n\nclass TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'\n\n\nclass TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n        assert _validate_redirect_url('///evil.com') is False\n        assert _validate_redirect_url('\\\\\\\\\\\\evil.com') is False\n        assert _validate_redirect_url('\\x00evil.com') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    def test_it_requires_same_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'https://example.com')\n            assert _validate_redirect_url('http://example.com/foo') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='http://works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='https://works.com')\n    def test_it_requires_same_external_server_name_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is False\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='http://works.com')\n            assert result is True\n            monkeypatch.undo()\n", "code_before": "import pytest\n\nfrom werkzeug.routing import BuildError\n\nfrom flask_unchained.bundles.controller import Controller, Resource\nfrom flask_unchained.bundles.controller.utils import (\n    controller_name, get_param_tuples, join,\n    method_name_to_url, url_for, _validate_redirect_url)\nfrom py_meta_utils import deep_getattr\n\n\ndef test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'\n\n\nclass TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'\n\n\nclass TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]\n\n\nclass TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)\n\n\nclass TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'\n\n\nclass TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'\n\n\nclass TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='works.com')\n            assert result is True\n            monkeypatch.undo()\n", "patch": "@@ -190,24 +190,40 @@ class TestValidateRedirectUrl:\n     def test_it_fails_on_garbage(self):\n         assert _validate_redirect_url(None) is False\n         assert _validate_redirect_url(' ') is False\n+        assert _validate_redirect_url('///evil.com') is False\n+        assert _validate_redirect_url('\\\\\\\\\\\\evil.com') is False\n+        assert _validate_redirect_url('\\x00evil.com') is False\n \n     def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n         with app.test_request_context():\n             monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n             assert _validate_redirect_url('http://fail.com') is False\n             monkeypatch.undo()\n \n-    @pytest.mark.options(EXTERNAL_SERVER_NAME='works.com')\n+    def test_it_requires_same_scheme(self, app, monkeypatch):\n+        with app.test_request_context():\n+            monkeypatch.setattr('flask.request.host_url', 'https://example.com')\n+            assert _validate_redirect_url('http://example.com/foo') is False\n+            monkeypatch.undo()\n+\n+    @pytest.mark.options(EXTERNAL_SERVER_NAME='http://works.com')\n     def test_it_works_with_external_server_name(self, app, monkeypatch):\n         with app.test_request_context():\n             monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n             assert _validate_redirect_url('http://works.com') is True\n             monkeypatch.undo()\n \n+    @pytest.mark.options(EXTERNAL_SERVER_NAME='https://works.com')\n+    def test_it_requires_same_external_server_name_scheme(self, app, monkeypatch):\n+        with app.test_request_context():\n+            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n+            assert _validate_redirect_url('http://works.com') is False\n+            monkeypatch.undo()\n+\n     def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n         with app.test_request_context():\n             monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n             result = _validate_redirect_url('http://works.com',\n-                                            _external_host='works.com')\n+                                            _external_host='http://works.com')\n             assert result is True\n             monkeypatch.undo()", "file_path": "files/2021_6/267", "file_language": "py", "file_name": "tests/bundles/controller/test_utils.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'", "target": 0}, {"function": "class TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'", "target": 0}, {"function": "class TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]", "target": 0}, {"function": "class TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)", "target": 0}, {"function": "class TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'", "target": 0}, {"function": "class TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'", "target": 0}, {"function": "class TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='works.com')\n            assert result is True\n            monkeypatch.undo()", "target": 0}], "function_after": [{"function": "def test_deep_getattr():\n    clsdict = {'a': 'clsdict'}\n\n    class First:\n        a = 'first'\n        b = 'first'\n\n    class Second:\n        b = 'second'\n        c = 'second'\n\n    bases = (First, Second)\n\n    assert deep_getattr(clsdict, bases, 'a') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b') == 'first'\n    assert deep_getattr(clsdict, bases, 'c') == 'second'\n    with pytest.raises(AttributeError):\n        deep_getattr(clsdict, bases, 'd')\n\n    assert deep_getattr(clsdict, bases, 'a', 'default') == 'clsdict'\n    assert deep_getattr(clsdict, bases, 'b', 'default') == 'first'\n    assert deep_getattr(clsdict, bases, 'c', 'default') == 'second'\n    assert deep_getattr(clsdict, bases, 'd', 'default') == 'default'", "target": 0}, {"function": "class TestControllerName:\n    def test_it_strips_controller(self):\n        class UserController(Controller):\n            pass\n        assert controller_name(UserController) == 'user'\n\n    def test_it_handles_acronyms(self):\n        class APIController(Controller):\n            pass\n\n        assert controller_name(APIController) == 'api'\n\n    def test_it_strips_view(self):\n        class SomeView(Controller):\n            pass\n        assert controller_name(SomeView) == 'some'\n\n    def test_it_works_with_more_than_one_word(self):\n        class MoreThanOneWordController(Controller):\n            pass\n        assert controller_name(MoreThanOneWordController) == 'more_than_one_word'\n\n    def test_it_strips_resource(self):\n        class UserResource(Resource):\n            pass\n        assert controller_name(UserResource) == 'user'\n\n    def test_it_strips_method_view(self):\n        class RoleMethodView(Resource):\n            pass\n        assert controller_name(RoleMethodView) == 'role'\n\n    def test_it_only_strips_one_suffix(self):\n        class RoleViewControllerResource(Resource):\n            pass\n        assert controller_name(RoleViewControllerResource) == 'role_view_controller'\n\n    def test_it_works_without_stripping_any_suffixes(self):\n        class SomeCtrl(Controller):\n            pass\n        assert controller_name(SomeCtrl) == 'some_ctrl'", "target": 0}, {"function": "class TestGetParamTuples:\n    def test_it_works(self):\n        assert get_param_tuples('<int:id>') == [('int', 'id')]\n\n    def test_it_works_on_garbage(self):\n        assert get_param_tuples(None) == []\n\n    def test_multiple(self):\n        path = '/users/<int:user_id>/roles/<string:slug>'\n        assert get_param_tuples(path) == [('int', 'user_id'), ('string', 'slug')]", "target": 0}, {"function": "class TestUrlFor:\n    def test_it_works_with_already_formed_path(self):\n        assert url_for('/foobar') == '/foobar'\n\n    def test_it_works_with_garbage(self):\n        assert url_for(None) is None\n\n    def test_it_works_with_config_keys_returning_path(self, app):\n        app.config.from_mapping({'MY_KEY': '/my-key'})\n        assert url_for('MY_KEY') == '/my-key'\n\n    def test_it_works_with_config_keys_returning_endpoints(self, app):\n        app.config.from_mapping({'MY_KEY': 'some.endpoint'})\n\n        with pytest.raises(BuildError):\n            assert url_for('MY_KEY')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('MY_KEY') == '/some-endpoint'\n\n    def test_it_works_with_endpoints(self, app):\n        with pytest.raises(BuildError):\n            assert url_for('some.endpoint')\n\n        with app.test_request_context():\n            app.add_url_rule('/some-endpoint', endpoint='some.endpoint')\n            assert url_for('some.endpoint') == '/some-endpoint'\n\n    def test_it_works_with_controller_method_names(self, app):\n        class SiteController(Controller):\n            def about_us(self):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/about-us', endpoint='site_controller.about_us')\n            assert url_for('about_us', _cls=SiteController) == '/about-us'\n\n    def test_it_works_with_url_for_kwargs(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            assert url_for('get', id=1, _cls=SiteResource) == '/sites/1'\n\n            app.add_url_rule('/foo/<string:slug>', endpoint='some.endpoint')\n            assert url_for('some.endpoint', slug='hi') == '/foo/hi'\n\n    def test_it_falls_through_if_class_endpoint_not_found(self, app):\n        class SiteResource(Resource):\n            def get(self, id):\n                pass\n\n        with app.test_request_context():\n            app.add_url_rule('/sites/<int:id>', endpoint='site_resource.get')\n            with pytest.raises(BuildError):\n                url_for('delete', id=1, _cls=SiteResource)", "target": 0}, {"function": "class TestJoin:\n    def test_it_works_with_garbage(self):\n        assert join(None) == '/'\n        assert join(None, None, '', 0) == '/'\n\n    def test_it_works_with_partially_valid_input(self):\n        assert join('/', 'foo', None, 'bar', '', 'baz') == '/foo/bar/baz'\n\n    def test_it_strips_neighboring_slashes(self):\n        assert join('/', '/foo', '/', '/bar') == '/foo/bar'\n\n    def test_it_doesnt_eat_single_slash(self):\n        assert join('/', '/') == '/'\n        assert join(None, '/') == '/'\n        assert join('/', None) == '/'\n\n    def test_it_strips_trailing_slash(self):\n        assert join('/foo/bar/') == '/foo/bar'\n        assert join('/foo/bar/', None) == '/foo/bar'\n        assert join('/foo/bar/', '/') == '/foo/bar'\n        assert join('/foo', 'bar/') == '/foo/bar'\n\n    def test_trailing_slash(self):\n        assert join('/', trailing_slash=True) == '/'\n        assert join('/foo', 'baz', None, trailing_slash=True) == '/foo/baz/'\n        assert join('/foo', 'baz/', trailing_slash=True) == '/foo/baz/'", "target": 0}, {"function": "class TestMethodNameToUrl:\n    def test_it_works(self):\n        assert method_name_to_url('fooBar') == '/foo-bar'\n        assert method_name_to_url('foo_bar') == '/foo-bar'\n        assert method_name_to_url('fooBar_baz') == '/foo-bar-baz'\n        assert method_name_to_url('_FooBar_baz-booFoo_') == '/foo-bar-baz-boo-foo'", "target": 0}, {"function": "class TestValidateRedirectUrl:\n    def test_it_fails_on_garbage(self):\n        assert _validate_redirect_url(None) is False\n        assert _validate_redirect_url(' ') is False\n        assert _validate_redirect_url('///evil.com') is False\n        assert _validate_redirect_url('\\\\\\\\\\\\evil.com') is False\n        assert _validate_redirect_url('\\x00evil.com') is False\n\n    def test_it_fails_with_invalid_netloc(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://fail.com') is False\n            monkeypatch.undo()\n\n    def test_it_requires_same_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'https://example.com')\n            assert _validate_redirect_url('http://example.com/foo') is False\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='http://works.com')\n    def test_it_works_with_external_server_name(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is True\n            monkeypatch.undo()\n\n    @pytest.mark.options(EXTERNAL_SERVER_NAME='https://works.com')\n    def test_it_requires_same_external_server_name_scheme(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            assert _validate_redirect_url('http://works.com') is False\n            monkeypatch.undo()\n\n    def test_it_works_with_explicit_external_host(self, app, monkeypatch):\n        with app.test_request_context():\n            monkeypatch.setattr('flask.request.host_url', 'http://example.com')\n            result = _validate_redirect_url('http://works.com',\n                                            _external_host='http://works.com')\n            assert result is True\n            monkeypatch.undo()", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
