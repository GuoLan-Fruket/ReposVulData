{"index": 6421, "cve_id": "CVE-2021-32806", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "Products.isurlinportal is a replacement for isURLInPortal method in Plone. Versions of Products.isurlinportal prior to 1.2.0 have an Open Redirect vulnerability. Various parts of Plone use the 'is url in portal' check for security, mostly to see if it is safe to redirect to a url. A url like `https://example.org` is not in the portal. The url `https:example.org` without slashes is considered to be in the portal. When redirecting, some browsers go to `https://example.org`, others give an error. Attackers may use this to redirect victims to their site, especially as part of a phishing attack. The problem has been patched in Products.isurlinportal 1.2.0.", "cvss": "6.1", "publish_date": "August 2, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "d4fd34990d18adf05a10dc5e2bb4b066798280ba", "commit_message": "Merge pull request from GHSA-q3m9-9fj2-mfwr\n\nTreat urls like https:example.org without slashes as outside the portal.", "commit_date": "2021-07-31T12:33:49Z", "project": "plone/products.isurlinportal", "url": "https://api.github.com/repos/plone/Products.isurlinportal/commits/d4fd34990d18adf05a10dc5e2bb4b066798280ba", "html_url": "https://github.com/plone/Products.isurlinportal/commit/d4fd34990d18adf05a10dc5e2bb4b066798280ba", "windows_before": [{"commit_id": "a52a08c32296ea0d2a37075260481fa6f132a050", "commit_date": "Wed Jul 28 00:49:51 2021 +0200", "commit_message": "Merge pull request #6 from plone/maurits/tox-use-development-version", "files_name": ["e1d914bd15dc759ba0aa6b7d50c0b765cfa72be9 - Wed Jul 28 00:20:41 2021 +0200 : Tox: use development version of Products.isurlinportal.", "buildout.cfg", "tox.ini"]}, {"commit_id": "9f46523a16d4ec1d00308df5b1382fcba384c330", "commit_date": "Sun Jul 11 12:59:49 2021 +0200", "commit_message": "Merge pull request #5 from plone/maurits/github-actions-tox", "files_name": ["f62b81959ace7f6c27c09a4713d962ea407093fe - Sat Jul 10 22:25:29 2021 +0200 : Move to GitHub Actions and test Plone 5.0.", ".github/workflows/tests.yml", ".travis.yml", "tox.ini"]}, {"commit_id": "0187d41bb8faf4a88c1f780fb8a305b63b12859b", "commit_date": "Mon Sep 7 22:26:22 2020 +0200", "commit_message": "Back to development: 1.1.2", "files_name": ["setup.py"]}, {"commit_id": "667f8d35a30d17931dbb7e11ce6551431d9fd1bb", "commit_date": "Mon Sep 7 22:25:40 2020 +0200", "commit_message": "Preparing release 1.1.1", "files_name": ["CHANGES.rst", "news/3.bugfix", "setup.py"]}, {"commit_id": "88de78434a9ed4ceac86bb7945dc78deb18c785e", "commit_date": "Tue Aug 18 16:08:41 2020 +0200", "commit_message": "Merge pull request #3 from plone/support_py38", "files_name": ["9cf1d1e0739e75efd4f99e2a059d9a588b6a0dd6 - Tue Aug 18 15:54:29 2020 +0200 : restore extends url", "buildout.cfg"]}, {"commit_id": "0561698141c862ba9c42c19a74f1e57a42470e3b", "commit_date": "Tue Aug 18 14:28:38 2020 +0200", "commit_message": "test python 3.6; update changelog", "files_name": [".travis.yml", "buildout.cfg", "news/3.bugfix", "tox.ini"]}, {"commit_id": "d56eb71b2b5e748b05c269469c28ae59e9ea5e69", "commit_date": "Tue Aug 18 10:24:57 2020 +0200", "commit_message": "Support Python 3.8", "files_name": [".travis.yml", "setup.py"]}, {"commit_id": "5a5ce3386e6772843a935a943cadb119fc2ddea8", "commit_date": "Sun Aug 16 16:16:11 2020 +0200", "commit_message": "Back to development: 1.1.1", "files_name": ["setup.py"]}, {"commit_id": "d74ed08d5a3b1ea9796ecdf132f1c6be5d6cb0f5", "commit_date": "Sun Aug 16 16:15:26 2020 +0200", "commit_message": "Preparing release 1.1.0", "files_name": ["CHANGES.rst", "news/1.feature", "setup.py"]}, {"commit_id": "6818a555606631196a51ea4de25e0affa135861c", "commit_date": "Sun Aug 16 16:15:02 2020 +0200", "commit_message": "check-manifest", "files_name": ["setup.cfg"]}, {"commit_id": "b0106b9178ba1acc52e58aba92860de92e9bdec2", "commit_date": "Tue Jul 21 21:10:58 2020 +0200", "commit_message": "Harden against tricky whitespace in urls.", "files_name": ["Products/isurlinportal/__init__.py", "Products/isurlinportal/tests.py", "news/1.feature", "setup.py"]}, {"commit_id": "ffeada528c6e75002326aae5371e41cc441e59cb", "commit_date": "Tue Jul 21 22:14:11 2020 +0200", "commit_message": "Add tox.ini for local testing.", "files_name": [".gitignore", "tox.ini"]}, {"commit_id": "39d4880a7fddf75fc1409afea2d7ac98993377f0", "commit_date": "Tue Jul 21 18:29:31 2020 +0200", "commit_message": "Initialized towncrier.", "files_name": ["CHANGES.rst", "MANIFEST.in", "news/.gitkeep", "pyproject.toml"]}, {"commit_id": "62156bd06b1f7be01d8ff5c4d1580013961184aa", "commit_date": "Tue Jul 21 18:28:58 2020 +0200", "commit_message": "Back to development: 1.0.1", "files_name": ["CHANGES.rst", "setup.py"]}, {"commit_id": "60b7724fdbefcb2f6c20fad28b36e7091cd77ead", "commit_date": "Tue Jul 21 18:28:34 2020 +0200", "commit_message": "Preparing release 1.0.0", "files_name": ["CHANGES.rst", "setup.py"]}, {"commit_id": "b896580347ae1cbfb100eaf52cc1cee38c01a6f3", "commit_date": "Tue Jul 21 18:28:20 2020 +0200", "commit_message": "check-manifest", "files_name": ["setup.cfg"]}, {"commit_id": "99d91ce0d20a85ab4ec93036ab066037ee17a192", "commit_date": "Tue Jul 21 15:28:43 2020 +0200", "commit_message": "Note that code is same as current CMFPlone 4.3.x, 5.1.x, 5.2.x branches.", "files_name": ["CHANGES.rst"]}, {"commit_id": "2f5e4e22f3ea12aab11baf3e86ddc4a4478f1cd9", "commit_date": "Tue Jul 21 14:59:38 2020 +0200", "commit_message": "Added Travis and buildout files from buildout.plonetest.", "files_name": [".travis.yml", "buildout.cfg", "requirements.txt"]}, {"commit_id": "c2140497fbab76d186d53b13bd872447dd2a700c", "commit_date": "Tue Jul 21 14:56:27 2020 +0200", "commit_message": "Fixed MANIFEST.in", "files_name": ["MANIFEST.in"]}, {"commit_id": "97a806d77b89d6bd2ed660cad03cd63ec25d16ee", "commit_date": "Tue Jul 21 14:29:57 2020 +0200", "commit_message": "Fixed invalid escape sequence in tests by using raw string.", "files_name": ["Products/isurlinportal/tests.py"]}, {"commit_id": "1f98a2c517c95f6fb379324bf90ea65c0d6644e0", "commit_date": "Tue Jul 21 14:22:26 2020 +0200", "commit_message": "Add test for other sub domain.", "files_name": ["Products/isurlinportal/tests.py"]}, {"commit_id": "7925f2f3ef296a153d299d7fa8081be93cf6708e", "commit_date": "Tue Jul 21 14:18:30 2020 +0200", "commit_message": "Patch get_external_sites in tests.", "files_name": ["Products/isurlinportal/tests.py"]}, {"commit_id": "9110185f8ba046e02db7e73a7c2e1bec41559642", "commit_date": "Tue Jul 21 14:08:43 2020 +0200", "commit_message": "black tests.py", "files_name": ["Products/isurlinportal/tests.py"]}, {"commit_id": "31ac5d43f7a15cbaf49bb605e427dc096b32b905", "commit_date": "Tue Jul 21 14:08:20 2020 +0200", "commit_message": "Copied tests/testURLTool.py from Products.CMFPlone 5.2.2rc2.", "files_name": ["Products/isurlinportal/tests.py"]}, {"commit_id": "f296bf896c43ff07c90fe7ab6e4296171e70e06d", "commit_date": "Tue Jul 21 14:04:53 2020 +0200", "commit_message": "Moved get_external_sites to _compat.", "files_name": ["Products/isurlinportal/__init__.py", "Products/isurlinportal/_compat.py"]}, {"commit_id": "2c5eb29a18d86c16280a9db1ddec3b3d8c930289", "commit_date": "Tue Jul 21 14:02:46 2020 +0200", "commit_message": "Use own _compat module to avoid depending on six.", "files_name": ["Products/isurlinportal/__init__.py", "Products/isurlinportal/_compat.py", "setup.py"]}, {"commit_id": "9e890df93e76a2ae7b23b88172c87bd160043f28", "commit_date": "Tue Jul 21 13:33:43 2020 +0200", "commit_message": "Get external sites in correct way in both Plone 4 and 5.", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "4d967b0bbbf360e0f93fbe2cbacef6e247b8a2f1", "commit_date": "Tue Jul 21 11:59:27 2020 +0200", "commit_message": "Method intentionally does not contain a docstring.", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "470e1a6b0022f4798413ad3d6d03f54f5915a791", "commit_date": "Tue Jul 21 11:32:11 2020 +0200", "commit_message": "TODO: maybe get rid of six dependency, as older Plones may not have it.", "files_name": ["Products/isurlinportal/__init__.py", "setup.py"]}, {"commit_id": "8ca75150916e7c3b1c2bbfd22e3ecddb4197e000", "commit_date": "Tue Jul 21 11:31:04 2020 +0200", "commit_message": "Keep only the isURLInPortal function, and related parts.", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "6cdc1dbe0d2ea480d001861eda59f7859f535f24", "commit_date": "Tue Jul 21 11:20:26 2020 +0200", "commit_message": "black", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "68451bdbb1b4031bb4083812fd98fca32b89dfb7", "commit_date": "Tue Jul 21 11:19:28 2020 +0200", "commit_message": "Added copy of URLTool.py of Plone 5.2 as __init__.py", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "ab4b168f272c4daa17503f731537e3b0e04b93e8", "commit_date": "Tue Jul 21 11:08:40 2020 +0200", "commit_message": "Use the Products namespace.", "files_name": ["Products/__init__.py", "Products/isurlinportal/__init__.py", "README.rst", "setup.py"]}, {"commit_id": "52b8bab42c73bc51c7e6f438f9cf4d0c16ac22d7", "commit_date": "Mon Jul 20 23:38:41 2020 +0200", "commit_message": "Initial structure.", "files_name": ["CHANGES.rst", "MANIFEST.in", "README.rst", "setup.cfg", "setup.py", "src/isurlinportal/__init__.py"]}], "windows_after": [{"commit_id": "1cea43bd1dd2a26abdc5929aa822d902cec7c370", "commit_date": "Sat Jul 31 14:35:19 2021 +0200", "commit_message": "Preparing release 1.2.0", "files_name": ["CHANGES.rst", "news/1.feature", "setup.py"]}, {"commit_id": "21b9ffff747268c14ee498c47e3847ac22223f64", "commit_date": "Sat Jul 31 14:36:03 2021 +0200", "commit_message": "Back to development: 1.2.1", "files_name": ["setup.py"]}, {"commit_id": "462551da6db9684644a019c0cf4d8959d5716609", "commit_date": "Fri Aug 6 21:26:57 2021 +0200", "commit_message": "make `tox.ini` compatible with the upcoming `tox` version 4", "files_name": ["tox.ini"]}, {"commit_id": "22c8830077ea5a03010360218d237d77a17143cf", "commit_date": "Fri Aug 6 21:37:09 2021 +0200", "commit_message": "add changelog", "files_name": ["news/7.bugfix.rst"]}, {"commit_id": "09de2202a15660d563213438d373adbf5d62d8ba", "commit_date": "Mon Aug 9 11:40:58 2021 +0200", "commit_message": "Fix sed pattern in tox.ini for Mac.", "files_name": ["tox.ini"]}, {"commit_id": "9de348b6de6b0310b45f28a62fc4aa022414dc9a", "commit_date": "Mon Aug 9 12:04:09 2021 +0200", "commit_message": "Merge pull request #7 from plone/jugmac00-patch-1", "files_name": ["22baead21d9838298c125ca507efa9906bbe255e - Mon Aug 9 12:04:46 2021 +0200 : Removed news snippet for internal detail.", "news/7.bugfix.rst"]}, {"commit_id": "3830bbe0feb4c72972dc8875e387a0896507a555", "commit_date": "Mon Aug 9 11:25:13 2021 +0200", "commit_message": "Return False when a url is not like a string, for example None.", "files_name": ["Products/isurlinportal/__init__.py", "Products/isurlinportal/tests.py", "news/8.bugfix"]}, {"commit_id": "f93126f5d4795315ebfc15df98f77b2b18da686c", "commit_date": "Tue Aug 10 11:54:12 2021 +0200", "commit_message": "Merge pull request #9 from plone/maurits/fix-nonetype-splitlines", "files_name": ["cc4ac88f125ab0f436ec43e3782f29ab2b38f447 - Tue Aug 10 12:18:58 2021 +0200 : Preparing release 1.2.1", "CHANGES.rst", "news/8.bugfix", "setup.py"]}, {"commit_id": "453bd9a01f5224041370448517f6c89ffae5cc1f", "commit_date": "Tue Aug 10 12:19:29 2021 +0200", "commit_message": "Back to development: 1.2.2", "files_name": ["setup.py"]}, {"commit_id": "c2b1455c17e6e09510624283fc4905b14e098824", "commit_date": "Sat Feb 25 01:07:42 2023 +0100", "commit_message": "Add python_requires and more classifiers.", "files_name": ["setup.py"]}, {"commit_id": "73a38fce5d49f6f9146558c4128de46905a9a249", "commit_date": "Sat Feb 25 01:08:03 2023 +0100", "commit_message": "black, removing one whiteline", "files_name": ["Products/isurlinportal/_compat.py"]}, {"commit_id": "a7eaab0a6dff1afe1999ae6a657b2577cc71f26d", "commit_date": "Sat Feb 25 01:14:14 2023 +0100", "commit_message": "Add compatibility note.", "files_name": ["README.rst"]}, {"commit_id": "432c442fb0666de55c4b0cc71c042e3ac05025fe", "commit_date": "Sat Feb 25 01:15:46 2023 +0100", "commit_message": "Drop compatibility with Plone 5.2 and lower.", "files_name": ["Products/__init__.py", "Products/isurlinportal/__init__.py", "Products/isurlinportal/_compat.py", "Products/isurlinportal/tests.py", "news/60.breaking", "setup.py"]}, {"commit_id": "8087b78d4b5caf52fac09c5302569d6350ce5f03", "commit_date": "Sat Feb 25 01:47:50 2023 +0100", "commit_message": "Fix tox and gh-actions to run on Plone 6.0.", "files_name": [".github/workflows/tests.yml", "buildout.cfg", "requirements.txt", "tox.ini"]}, {"commit_id": "ce25ec00c0895b736f1b429c61647f2e98503442", "commit_date": "Sat Feb 25 13:11:40 2023 +0100", "commit_message": "Add Plone 6.0 framework classifier.", "files_name": ["setup.py"]}, {"commit_id": "35162761234ba25dc011e4fcf9d271b6088ff644", "commit_date": "Sat Feb 25 23:04:37 2023 +0100", "commit_message": "Merge pull request #10 from plone/maurits-drop-52", "files_name": ["622ea08539ee6e54524c953282ab8b0389c74874 - Tue Mar 14 17:05:33 2023 +0100 : Fixed wrongly named classifier.", "setup.py"]}, {"commit_id": "1dab93323f58447a5ad44adf97142d438e1ec616", "commit_date": "Tue Mar 14 17:05:43 2023 +0100", "commit_message": "Preparing release 2.0.0", "files_name": ["CHANGES.rst", "news/60.breaking", "setup.py"]}, {"commit_id": "79b64ed38a6cffe1beaa9168fd017d041c225c20", "commit_date": "Tue Mar 14 17:06:05 2023 +0100", "commit_message": "Back to development: 2.0.1", "files_name": ["setup.py"]}, {"commit_id": "a62e7ea389aa1281c7e88521b8456863d36a0482", "commit_date": "Sun Apr 9 14:44:33 2023 +0200", "commit_message": "Configuring with plone/meta", "files_name": [".editorconfig", ".meta.toml", ".pre-commit-config.yaml", "news/3333c742.internal", "pyproject.toml", "setup.cfg", "tox.ini"]}, {"commit_id": "ac0b360fb8dc96eccd545b0bc5ac030f99fc6021", "commit_date": "Sun Apr 9 14:48:45 2023 +0200", "commit_message": "cleanup: use generic workflow", "files_name": [".github/workflows/tests.yml", "buildout.cfg", "requirements.txt"]}, {"commit_id": "4d6a41d5ed83671f658bb1c708ea54b5e1dcb34f", "commit_date": "Sun Apr 9 14:49:52 2023 +0200", "commit_message": "chore: isort", "files_name": ["Products/isurlinportal/__init__.py"]}, {"commit_id": "7b447af53bbb446e19da998fc08330537bada58e", "commit_date": "Sun Apr 9 14:50:55 2023 +0200", "commit_message": "feat: configure codespell", "files_name": ["pyproject.toml"]}, {"commit_id": "0fa32d4060c66a5e7c44b3215d2ade0251a18fc6", "commit_date": "Sun Apr 9 14:55:18 2023 +0200", "commit_message": "feat: declare dependencies", "files_name": ["setup.py"]}, {"commit_id": "d8d161f25f8693309996e3a6a6bea39576e96e7f", "commit_date": "Thu Apr 13 16:11:17 2023 +0200", "commit_message": "Random change to trigger GHA", "files_name": ["tox.ini"]}, {"commit_id": "0e3b7d0b8a7d6242edd93d29fe6a216c1e3f1f42", "commit_date": "Tue Apr 18 00:14:27 2023 +0200", "commit_message": "Configuring with plone/meta", "files_name": [".meta.toml", "pyproject.toml", "tox.ini"]}, {"commit_id": "418de5a26190b4f5e723a5e6b296fd2be5bed9a9", "commit_date": "Tue Apr 18 00:21:25 2023 +0200", "commit_message": "Moved Products.CMFPlone to requirements in new test extra.", "files_name": [".meta.toml", "pyproject.toml", "setup.py"]}, {"commit_id": "8da42cac4248d61c68bb8eddc91189817eb42bc0", "commit_date": "Tue Apr 18 14:32:37 2023 +0200", "commit_message": "Merge pull request #11 from plone/config-with-default-template-79b64ed3", "files_name": ["2914409c8f596e3b951779a5b12e984a5c2a9a7a - Wed Apr 19 23:03:57 2023 +0200 : Preparing release 2.0.1", "CHANGES.rst", "news/3333c742.internal", "setup.py"]}, {"commit_id": "161c76cac851310c91071088d8d1158b55c6858e", "commit_date": "Wed Apr 19 23:04:27 2023 +0200", "commit_message": "Back to development: 2.0.2", "files_name": ["setup.py"]}, {"commit_id": "aeede929539678597f1ac237ad9d0a8673f6028a", "commit_date": "Mon May 1 22:46:06 2023 +0000", "commit_message": "[pre-commit.ci] pre-commit autoupdate", "files_name": [".pre-commit-config.yaml"]}, {"commit_id": "25b2327fe313457b55bf41ad2bf13e7af03d44cf", "commit_date": "Tue May 2 16:43:58 2023 +0200", "commit_message": "Merge pull request #13 from plone/pre-commit-ci-update-config", "files_name": ["e7a5c283e3c12e552030906557dfee80a3ffb3be - Mon Jun 5 22:21:39 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "3efc4753f2d202d6793387d3e97d1647eaa7b993", "commit_date": "Tue Jun 6 09:21:41 2023 +0200", "commit_message": "Merge pull request #14 from plone/pre-commit-ci-update-config", "files_name": ["c72e45d6145902d427fc9fad0ff926423fb3fbb5 - Sat Jun 17 23:35:07 2023 +0200 : Configuring with plone/meta", ".editorconfig", ".flake8", ".github/workflows/meta.yml", ".gitignore", ".meta.toml", ".pre-commit-config.yaml", "news/7723aeaf.internal", "pyproject.toml", "tox.ini"]}, {"commit_id": "7d9e7922b964ee5d0d930172bfd782810a2ac847", "commit_date": "Sat Jun 17 23:35:20 2023 +0200", "commit_message": "cleanup: remove unused file", "files_name": ["setup.cfg"]}, {"commit_id": "b241b8c59a6615b0f4d20e895563051f9c37727e", "commit_date": "Fri Jun 23 14:13:27 2023 +0200", "commit_message": "Merge pull request #15 from plone/config-with-default-template-3efc4753", "files_name": ["fbc5dbca338e23035f456202a944226b954feae7 - Mon Jul 3 23:24:22 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "6191574387769d5b59b8e1df17e6dfa77a39cf81", "commit_date": "Tue Jul 4 08:16:16 2023 +0200", "commit_message": "Merge pull request #16 from plone/pre-commit-ci-update-config", "files_name": ["532cbecc30a40664130faded418278254fb65fc4 - Tue Aug 1 00:33:57 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "5f29bf366dfcb92380461427cb1eec3b9f6b6a03", "commit_date": "Tue Aug 1 08:37:43 2023 +0200", "commit_message": "Merge pull request #17 from plone/pre-commit-ci-update-config", "files_name": ["078dcd385747c702d9ec1c4a5af7124681bc4c13 - Tue Oct 3 01:27:01 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "76f904928811106d366c73fdc5dd5fbd3ed528ac", "commit_date": "Tue Oct 3 13:11:19 2023 +0200", "commit_message": "Merge pull request #18 from plone/pre-commit-ci-update-config", "files_name": ["311fc342edfb94e17782d7798d06c826c04f13d2 - Mon Nov 6 18:34:15 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "cabb2d77e3662e991a9e6aae6d8a78e39ce20375", "commit_date": "Mon Nov 6 23:11:28 2023 +0100", "commit_message": "Merge pull request #19 from plone/pre-commit-ci-update-config", "files_name": ["6a482d4e75fea25da728f5872020b13893d43337 - Mon Dec 4 18:32:43 2023 +0000 : [pre-commit.ci] pre-commit autoupdate", ".pre-commit-config.yaml"]}, {"commit_id": "f154c376764fe4fa4c4d33f302de3842d86bd71c", "commit_date": "Tue Dec 5 16:00:22 2023 +0100", "commit_message": "Merge pull request #20 from plone/pre-commit-ci-update-config", "files_name": []}], "parents": [{"commit_id_before": "a52a08c32296ea0d2a37075260481fa6f132a050", "url_before": "https://api.github.com/repos/plone/Products.isurlinportal/commits/a52a08c32296ea0d2a37075260481fa6f132a050", "html_url_before": "https://github.com/plone/Products.isurlinportal/commit/a52a08c32296ea0d2a37075260481fa6f132a050"}, {"commit_id_before": "7cbf4a438f1ab6510fdfa4bae84f71ecaa3130fc", "url_before": "https://api.github.com/repos/plone/Products.isurlinportal/commits/7cbf4a438f1ab6510fdfa4bae84f71ecaa3130fc", "html_url_before": "https://github.com/plone/Products.isurlinportal/commit/7cbf4a438f1ab6510fdfa4bae84f71ecaa3130fc"}], "details": [{"raw_url": "https://github.com/plone/Products.isurlinportal/raw/d4fd34990d18adf05a10dc5e2bb4b066798280ba/Products%2Fisurlinportal%2F__init__.py", "code": "# -*- coding: utf-8 -*-\nfrom ._compat import get_external_sites\nfrom ._compat import unescape\nfrom ._compat import urljoin\nfrom ._compat import urlparse\nfrom posixpath import normpath\n\n# This is the class we will patch:\nfrom Products.CMFPlone.URLTool import URLTool\n\nimport re\nimport string\nimport unicodedata\n\n\n# These schemas are allowed in full urls to consider them in the portal:\n# A mailto schema is an obvious sign of a url that is not in the portal.\n# This is a whitelist.\nALLOWED_SCHEMAS = [\n    \"https\",\n    \"http\",\n]\n# These bad parts are not allowed in urls that are in the portal:\n# This is a blacklist.\nBAD_URL_PARTS = [\n    \"\\\\\\\\\",\n    \"<script\",\n    \"%3cscript\",\n    \"javascript:\",\n    \"javascript%3a\",\n]\n\n# Determine allowed ascii characters.\n# We want to allow most printable characters,\n# but no whitespace, and no punctuation, except for a few exceptions.\n# This boils down to ascii letters plus digits plus exceptions.\n# Exceptions:\n# - dot and slash for relative or absolute paths.\n# - @ because we have views starting with @@\n# - + because we have ++resource++ urls\nallowed_ascii = string.ascii_letters + string.digits + \"./@+\"\n\n\ndef safe_url_first_char(url):\n    # For character code points higher than 127, the bytes representation of a character\n    # is longer than the unicode representation, so url[0] may give different results\n    # for bytes and unicode.  On Python 2:\n    # >>> unichr(128)\n    # u'\\x80'\n    # >>> len(unichr(128))\n    # 1\n    # >>> unichr(128).encode(\"latin-1\")\n    # '\\x80'\n    # >>> len(unichr(128).encode(\"latin-1\"))\n    # 1\n    # >>> unichr(128).encode(\"utf-8\")\n    # '\\xc2\\x80'\n    # >>> len(unichr(128).encode(\"utf-8\"))\n    # 2\n    # >>> unichr(128).encode(\"utf-8\")[0]\n    # '\\xc2'\n    # So make sure we have unicode here for comparing the first character.\n    if isinstance(url, bytes):\n        # Remember, on Python 2, bytes == str.\n        try:\n            first = url.decode(\"utf-8\")[0]\n        except UnicodeDecodeError:\n            # We don't trust this\n            return False\n    else:\n        first = url[0]\n    if ord(first) < 128:\n        if first not in allowed_ascii:\n            # The first character of the url is ascii but not in the allowed range.\n            return False\n    else:\n        # This is non-ascii, which has lots of control characters, which may be dangerous.\n        # Check taken from django.utils.http._is_safe_url.  See\n        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n        # Forbid URLs that start with control characters. Some browsers (like\n        # Chrome) ignore quite a few control characters at the start of a\n        # URL and might consider the URL as scheme relative.\n        # For categories, see 5.7.1 General Category Values here:\n        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n        # We look for Control categories here.\n        if unicodedata.category(first)[0] == \"C\":\n            return False\n    return True\n\n\ndef isURLInPortal(self, url, context=None):\n    # Note: no docstring, because the method is publicly available\n    # but does not need to be callable on site-url/portal_url/isURLInPortal.\n\n    # Check if a given url is on the same host and contains the portal\n    # path.  Used to ensure that login forms can determine relevant\n    # referrers (i.e. in portal).  Also return true for some relative\n    # urls if context is passed in to allow for url parsing. When context\n    # is not provided, assume that relative urls are in the portal. It is\n    # assumed that http://portal is the same portal as https://portal.\n\n    # External sites listed in 'allow_external_login_sites' of\n    # site_properties are also considered within the portal to allow for\n    # single sign on.\n\n    if len(url.splitlines()) > 1:\n        # very fishy\n        return False\n    if url != url.strip():\n        # somewhat fishy\n        return False\n    if url != \" \".join(url.split()):\n        # Some non-normal whitespace is used, like a tab.\n        # Could be a ploy to circumvent our checks.  We don't trust this.\n        return False\n    if url and not safe_url_first_char(url):\n        return False\n\n    # sanitize url\n    url = re.sub(\"^[\\x00-\\x20]+\", \"\", url).strip()\n    cmp_url = url.lower()\n    for bad in BAD_URL_PARTS:\n        if bad in cmp_url:\n            return False\n\n    p_url = self()\n\n    schema, u_host, u_path, _, _, _ = urlparse(url)\n    if schema and schema not in ALLOWED_SCHEMAS:\n        # Redirecting to 'data:' may be harmful,\n        # and redirecting to 'mailto:' or 'ftp:' is silly.\n        return False\n\n    if schema and not u_host:\n        # Example: https:example.org\n        # When we redirect to this, some browsers fail, others happily go to example.org.\n        # In any case, this is not in the portal.\n        return False\n\n    # Someone may be doing tricks with escaped html code.\n    unescaped_url = unescape(url)\n    if unescaped_url != url:\n        if not self.isURLInPortal(unescaped_url):\n            return False\n\n    if not u_host and not u_path.startswith(\"/\"):\n        if context is None:\n            return True  # old behavior\n        if not context.isPrincipiaFolderish:\n            useurl = context.aq_parent.absolute_url()\n        else:\n            useurl = context.absolute_url()\n    else:\n        useurl = p_url  # when u_path.startswith('/')\n    if not useurl.endswith(\"/\"):\n        useurl += \"/\"\n\n    # urljoin to current url to get an absolute path\n    _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))\n\n    # normalise to end with a '/' so /foobar is not considered within /foo\n    if not u_path:\n        u_path = \"/\"\n    else:\n        u_path = normpath(u_path)\n        if not u_path.endswith(\"/\"):\n            u_path += \"/\"\n    _, host, path, _, _, _ = urlparse(p_url)\n    if not path.endswith(\"/\"):\n        path += \"/\"\n    if host == u_host and u_path.startswith(path):\n        return True\n\n    for external_site in get_external_sites(self):\n        _, host, path, _, _, _ = urlparse(external_site)\n        if not path.endswith(\"/\"):\n            path += \"/\"\n        if host == u_host and u_path.startswith(path):\n            return True\n    return False\n\n\n# Add our method to the URLTool.\nURLTool.isURLInPortal = isURLInPortal\n", "code_before": "# -*- coding: utf-8 -*-\nfrom ._compat import get_external_sites\nfrom ._compat import unescape\nfrom ._compat import urljoin\nfrom ._compat import urlparse\nfrom posixpath import normpath\n\n# This is the class we will patch:\nfrom Products.CMFPlone.URLTool import URLTool\n\nimport re\nimport string\nimport unicodedata\n\n\n# These schemas are allowed in full urls to consider them in the portal:\n# A mailto schema is an obvious sign of a url that is not in the portal.\n# This is a whitelist.\nALLOWED_SCHEMAS = [\n    \"https\",\n    \"http\",\n]\n# These bad parts are not allowed in urls that are in the portal:\n# This is a blacklist.\nBAD_URL_PARTS = [\n    \"\\\\\\\\\",\n    \"<script\",\n    \"%3cscript\",\n    \"javascript:\",\n    \"javascript%3a\",\n]\n\n# Determine allowed ascii characters.\n# We want to allow most printable characters,\n# but no whitespace, and no punctuation, except for a few exceptions.\n# This boils down to ascii letters plus digits plus exceptions.\n# Exceptions:\n# - dot and slash for relative or absolute paths.\n# - @ because we have views starting with @@\n# - + because we have ++resource++ urls\nallowed_ascii = string.ascii_letters + string.digits + \"./@+\"\n\n\ndef safe_url_first_char(url):\n    # For character code points higher than 127, the bytes representation of a character\n    # is longer than the unicode representation, so url[0] may give different results\n    # for bytes and unicode.  On Python 2:\n    # >>> unichr(128)\n    # u'\\x80'\n    # >>> len(unichr(128))\n    # 1\n    # >>> unichr(128).encode(\"latin-1\")\n    # '\\x80'\n    # >>> len(unichr(128).encode(\"latin-1\"))\n    # 1\n    # >>> unichr(128).encode(\"utf-8\")\n    # '\\xc2\\x80'\n    # >>> len(unichr(128).encode(\"utf-8\"))\n    # 2\n    # >>> unichr(128).encode(\"utf-8\")[0]\n    # '\\xc2'\n    # So make sure we have unicode here for comparing the first character.\n    if isinstance(url, bytes):\n        # Remember, on Python 2, bytes == str.\n        try:\n            first = url.decode(\"utf-8\")[0]\n        except UnicodeDecodeError:\n            # We don't trust this\n            return False\n    else:\n        first = url[0]\n    if ord(first) < 128:\n        if first not in allowed_ascii:\n            # The first character of the url is ascii but not in the allowed range.\n            return False\n    else:\n        # This is non-ascii, which has lots of control characters, which may be dangerous.\n        # Check taken from django.utils.http._is_safe_url.  See\n        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n        # Forbid URLs that start with control characters. Some browsers (like\n        # Chrome) ignore quite a few control characters at the start of a\n        # URL and might consider the URL as scheme relative.\n        # For categories, see 5.7.1 General Category Values here:\n        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n        # We look for Control categories here.\n        if unicodedata.category(first)[0] == \"C\":\n            return False\n    return True\n\n\ndef isURLInPortal(self, url, context=None):\n    # Note: no docstring, because the method is publicly available\n    # but does not need to be callable on site-url/portal_url/isURLInPortal.\n\n    # Check if a given url is on the same host and contains the portal\n    # path.  Used to ensure that login forms can determine relevant\n    # referrers (i.e. in portal).  Also return true for some relative\n    # urls if context is passed in to allow for url parsing. When context\n    # is not provided, assume that relative urls are in the portal. It is\n    # assumed that http://portal is the same portal as https://portal.\n\n    # External sites listed in 'allow_external_login_sites' of\n    # site_properties are also considered within the portal to allow for\n    # single sign on.\n\n    if len(url.splitlines()) > 1:\n        # very fishy\n        return False\n    if url != url.strip():\n        # somewhat fishy\n        return False\n    if url != \" \".join(url.split()):\n        # Some non-normal whitespace is used, like a tab.\n        # Could be a ploy to circumvent our checks.  We don't trust this.\n        return False\n    if url and not safe_url_first_char(url):\n        return False\n\n    # sanitize url\n    url = re.sub(\"^[\\x00-\\x20]+\", \"\", url).strip()\n    cmp_url = url.lower()\n    for bad in BAD_URL_PARTS:\n        if bad in cmp_url:\n            return False\n\n    p_url = self()\n\n    schema, u_host, u_path, _, _, _ = urlparse(url)\n    if schema and schema not in ALLOWED_SCHEMAS:\n        # Redirecting to 'data:' may be harmful,\n        # and redirecting to 'mailto:' or 'ftp:' is silly.\n        return False\n\n    if schema and not u_host:\n        # Example: https:example.org\n        # When we redirect to this, some browsers fail, others happily go to example.org.\n        # In any case, this is not in the portal.\n        return False\n\n    # Someone may be doing tricks with escaped html code.\n    unescaped_url = unescape(url)\n    if unescaped_url != url:\n        if not self.isURLInPortal(unescaped_url):\n            return False\n\n    if not u_host and not u_path.startswith(\"/\"):\n        if context is None:\n            return True  # old behavior\n        if not context.isPrincipiaFolderish:\n            useurl = context.aq_parent.absolute_url()\n        else:\n            useurl = context.absolute_url()\n    else:\n        useurl = p_url  # when u_path.startswith('/')\n    if not useurl.endswith(\"/\"):\n        useurl += \"/\"\n\n    # urljoin to current url to get an absolute path\n    _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))\n\n    # normalise to end with a '/' so /foobar is not considered within /foo\n    if not u_path:\n        u_path = \"/\"\n    else:\n        u_path = normpath(u_path)\n        if not u_path.endswith(\"/\"):\n            u_path += \"/\"\n    _, host, path, _, _, _ = urlparse(p_url)\n    if not path.endswith(\"/\"):\n        path += \"/\"\n    if host == u_host and u_path.startswith(path):\n        return True\n\n    for external_site in get_external_sites(self):\n        _, host, path, _, _, _ = urlparse(external_site)\n        if not path.endswith(\"/\"):\n            path += \"/\"\n        if host == u_host and u_path.startswith(path):\n            return True\n    return False\n\n\n# Add our method to the URLTool.\nURLTool.isURLInPortal = isURLInPortal\n", "patch": "@@ -131,6 +131,12 @@ def isURLInPortal(self, url, context=None):\n         # and redirecting to 'mailto:' or 'ftp:' is silly.\n         return False\n \n+    if schema and not u_host:\n+        # Example: https:example.org\n+        # When we redirect to this, some browsers fail, others happily go to example.org.\n+        # In any case, this is not in the portal.\n+        return False\n+\n     # Someone may be doing tricks with escaped html code.\n     unescaped_url = unescape(url)\n     if unescaped_url != url:", "file_path": "files/2021_8/587", "file_language": "py", "file_name": "Products/isurlinportal/__init__.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/plone/Products.isurlinportal/raw/d4fd34990d18adf05a10dc5e2bb4b066798280ba/Products%2Fisurlinportal%2Ftests.py", "code": "# -*- coding: utf-8 -*-\nfrom Acquisition import aq_parent\nfrom Products.CMFCore.tests.base.dummy import DummyContent\nfrom Products.CMFCore.tests.base.dummy import DummyFolder\nfrom Products.CMFCore.tests.base.dummy import DummySite\nfrom zope.component import getSiteManager\n\nimport unittest\n\n\nclass DummyFolder(DummyFolder):\n    def absolute_url(self):\n        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])\n\n\ndef dummy_get_external_sites(context=None):\n    return [\n        \"http://external1\",\n        \"http://external2/\",\n        \"http://external3/site\",\n        \"http://external4/site/\",\n    ]\n\n\nclass TestURLTool(unittest.TestCase):\n    def setUp(self):\n        import Products.isurlinportal\n\n        # Patch get_external_sites to return a fixed list of sites.\n        self._original_get_external_sites = Products.isurlinportal.get_external_sites\n        Products.isurlinportal.get_external_sites = dummy_get_external_sites\n\n        # Create dummy site and content.\n        self.site = DummySite(id=\"foo\")\n        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))\n        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))\n\n    def tearDown(self):\n        import Products.isurlinportal\n\n        # Restore original get_external_sites.\n        Products.isurlinportal.get_external_sites = self._original_get_external_sites\n\n    def _makeOne(self, *args, **kw):\n        from Products.CMFPlone.URLTool import URLTool\n\n        url_tool = URLTool(*args, **kw)\n        return url_tool.__of__(self.site)\n\n    def test_isURLInPortal(self):\n        # First test what the absolute url of the site is, otherwise these\n        # tests look really weird.  Apparently our domain is www.foobar.com.\n        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")\n\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))\n        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))\n        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))\n        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"/images\"))\n        self.assertTrue(iURLiP(\"/bar/foo/foo\"))\n\n    def test_isURLInPortalRelative(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n\n        # non-root relative urls will need a current context to be passed in\n        self.assertTrue(iURLiP(\"images/img1.jpg\"))\n        self.assertTrue(iURLiP(\"./images/img1.jpg\"))\n\n        # /bar/foo/something\n        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))\n        # /bar/afolder\n        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))\n        # /afolder\n        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))\n\n        # /../afolder? How do we have more ../'s than there are parts in\n        # the URL?\n        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))\n\n        # /bar/foo/afolder\n        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))\n\n    def test_isURLInPortalExternal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://external1\"))\n        self.assertTrue(iURLiP(\"http://external1/\"))\n        self.assertTrue(iURLiP(\"http://external1/something\"))\n        self.assertTrue(iURLiP(\"http://external2\"))\n        self.assertTrue(iURLiP(\"http://external2/\"))\n        self.assertTrue(iURLiP(\"http://external2/something\"))\n        self.assertTrue(iURLiP(\"http://external3/site\"))\n        self.assertTrue(iURLiP(\"http://external3/site/\"))\n        self.assertTrue(iURLiP(\"http://external3/site/something\"))\n        self.assertTrue(iURLiP(\"http://external4/site\"))\n        self.assertTrue(iURLiP(\"http://external4/site/\"))\n        self.assertTrue(iURLiP(\"http://external4/site/something\"))\n\n        self.assertFalse(iURLiP(\"http://external3/other\"))\n        self.assertFalse(iURLiP(\"http://external4/other\"))\n        self.assertFalse(iURLiP(\"http://external5\"))\n        self.assertFalse(iURLiP(\"http://external11\"))\n\n    def test_script_tag_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n\n    def test_inline_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"javascript:alert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))\n\n    def test_double_back_slash(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))\n\n    def test_escape(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))\n\n    def test_regression_absolute_url_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(url_tool()))\n        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))\n\n    def test_mailto_simple_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))\n\n    def test_mailto_complex_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\n                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"\n                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"\n                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"\n            )\n        )\n\n    def test_data_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")\n        )\n\n    def test_ftp_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))\n\n    def test_double_slash(self):\n        # I wondered if this might be a problem after reading\n        # https://bugs.python.org/issue23505\n        # Apparently not, but let's test it.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"//www.google.com\"))\n        self.assertFalse(iURLiP(\"////www.google.com\"))\n\n    def test_empty(self):\n        # Redirecting to nothing would probably mean we end up on the same page.\n        # So an empty url should be fine.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"\"))\n\n    def test_newlines(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertFalse(iURLiP(\"f\\noo\"))\n        self.assertFalse(iURLiP(\"f\\roo\"))\n        self.assertFalse(iURLiP(\"\\nfoo\"))\n        self.assertFalse(iURLiP(\"\\rfoo\"))\n\n    def test_whitespace(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertTrue(iURLiP(\"f oo\"))\n        # '\\x20' == ' '\n        self.assertTrue(iURLiP(\"f\\x20oo\"))\n        self.assertFalse(iURLiP(\"f\\too\"))\n        self.assertFalse(iURLiP(\"\\tfoo\"))\n        self.assertFalse(iURLiP(\"foo\\t\"))\n        self.assertFalse(iURLiP(\" foo\"))\n        self.assertFalse(iURLiP(\"foo \"))\n\n    def test_without_slashes(self):\n        # This does not work in all browsers.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"http:example.org\"))\n        self.assertFalse(iURLiP(\"https:example.org\"))\n", "code_before": "# -*- coding: utf-8 -*-\nfrom Acquisition import aq_parent\nfrom Products.CMFCore.tests.base.dummy import DummyContent\nfrom Products.CMFCore.tests.base.dummy import DummyFolder\nfrom Products.CMFCore.tests.base.dummy import DummySite\nfrom zope.component import getSiteManager\n\nimport unittest\n\n\nclass DummyFolder(DummyFolder):\n    def absolute_url(self):\n        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])\n\n\ndef dummy_get_external_sites(context=None):\n    return [\n        \"http://external1\",\n        \"http://external2/\",\n        \"http://external3/site\",\n        \"http://external4/site/\",\n    ]\n\n\nclass TestURLTool(unittest.TestCase):\n    def setUp(self):\n        import Products.isurlinportal\n\n        # Patch get_external_sites to return a fixed list of sites.\n        self._original_get_external_sites = Products.isurlinportal.get_external_sites\n        Products.isurlinportal.get_external_sites = dummy_get_external_sites\n\n        # Create dummy site and content.\n        self.site = DummySite(id=\"foo\")\n        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))\n        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))\n\n    def tearDown(self):\n        import Products.isurlinportal\n\n        # Restore original get_external_sites.\n        Products.isurlinportal.get_external_sites = self._original_get_external_sites\n\n    def _makeOne(self, *args, **kw):\n        from Products.CMFPlone.URLTool import URLTool\n\n        url_tool = URLTool(*args, **kw)\n        return url_tool.__of__(self.site)\n\n    def test_isURLInPortal(self):\n        # First test what the absolute url of the site is, otherwise these\n        # tests look really weird.  Apparently our domain is www.foobar.com.\n        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")\n\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))\n        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))\n        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))\n        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"/images\"))\n        self.assertTrue(iURLiP(\"/bar/foo/foo\"))\n\n    def test_isURLInPortalRelative(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n\n        # non-root relative urls will need a current context to be passed in\n        self.assertTrue(iURLiP(\"images/img1.jpg\"))\n        self.assertTrue(iURLiP(\"./images/img1.jpg\"))\n\n        # /bar/foo/something\n        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))\n        # /bar/afolder\n        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))\n        # /afolder\n        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))\n\n        # /../afolder? How do we have more ../'s than there are parts in\n        # the URL?\n        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))\n\n        # /bar/foo/afolder\n        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))\n\n    def test_isURLInPortalExternal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://external1\"))\n        self.assertTrue(iURLiP(\"http://external1/\"))\n        self.assertTrue(iURLiP(\"http://external1/something\"))\n        self.assertTrue(iURLiP(\"http://external2\"))\n        self.assertTrue(iURLiP(\"http://external2/\"))\n        self.assertTrue(iURLiP(\"http://external2/something\"))\n        self.assertTrue(iURLiP(\"http://external3/site\"))\n        self.assertTrue(iURLiP(\"http://external3/site/\"))\n        self.assertTrue(iURLiP(\"http://external3/site/something\"))\n        self.assertTrue(iURLiP(\"http://external4/site\"))\n        self.assertTrue(iURLiP(\"http://external4/site/\"))\n        self.assertTrue(iURLiP(\"http://external4/site/something\"))\n\n        self.assertFalse(iURLiP(\"http://external3/other\"))\n        self.assertFalse(iURLiP(\"http://external4/other\"))\n        self.assertFalse(iURLiP(\"http://external5\"))\n        self.assertFalse(iURLiP(\"http://external11\"))\n\n    def test_script_tag_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n\n    def test_inline_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"javascript:alert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))\n\n    def test_double_back_slash(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))\n\n    def test_escape(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))\n\n    def test_regression_absolute_url_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(url_tool()))\n        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))\n\n    def test_mailto_simple_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))\n\n    def test_mailto_complex_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\n                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"\n                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"\n                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"\n            )\n        )\n\n    def test_data_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")\n        )\n\n    def test_ftp_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))\n\n    def test_double_slash(self):\n        # I wondered if this might be a problem after reading\n        # https://bugs.python.org/issue23505\n        # Apparently not, but let's test it.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"//www.google.com\"))\n        self.assertFalse(iURLiP(\"////www.google.com\"))\n\n    def test_empty(self):\n        # Redirecting to nothing would probably mean we end up on the same page.\n        # So an empty url should be fine.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"\"))\n\n    def test_newlines(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertFalse(iURLiP(\"f\\noo\"))\n        self.assertFalse(iURLiP(\"f\\roo\"))\n        self.assertFalse(iURLiP(\"\\nfoo\"))\n        self.assertFalse(iURLiP(\"\\rfoo\"))\n\n    def test_whitespace(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertTrue(iURLiP(\"f oo\"))\n        # '\\x20' == ' '\n        self.assertTrue(iURLiP(\"f\\x20oo\"))\n        self.assertFalse(iURLiP(\"f\\too\"))\n        self.assertFalse(iURLiP(\"\\tfoo\"))\n        self.assertFalse(iURLiP(\"foo\\t\"))\n        self.assertFalse(iURLiP(\" foo\"))\n        self.assertFalse(iURLiP(\"foo \"))\n\n    def test_without_slashes(self):\n        # This does not work in all browsers.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"http:example.org\"))\n        self.assertFalse(iURLiP(\"https:example.org\"))\n", "patch": "@@ -167,6 +167,11 @@ def test_data_not_in_portal(self):\n             iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")\n         )\n \n+    def test_ftp_not_in_portal(self):\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))\n+\n     def test_double_slash(self):\n         # I wondered if this might be a problem after reading\n         # https://bugs.python.org/issue23505\n@@ -204,3 +209,10 @@ def test_whitespace(self):\n         self.assertFalse(iURLiP(\"foo\\t\"))\n         self.assertFalse(iURLiP(\" foo\"))\n         self.assertFalse(iURLiP(\"foo \"))\n+\n+    def test_without_slashes(self):\n+        # This does not work in all browsers.\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\"http:example.org\"))\n+        self.assertFalse(iURLiP(\"https:example.org\"))", "file_path": "files/2021_8/588", "file_language": "py", "file_name": "Products/isurlinportal/tests.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class DummyFolder(DummyFolder):\n    def absolute_url(self):\n        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])", "target": 0}, {"function": "def dummy_get_external_sites(context=None):\n    return [\n        \"http://external1\",\n        \"http://external2/\",\n        \"http://external3/site\",\n        \"http://external4/site/\",\n    ]", "target": 0}, {"function": "class TestURLTool(unittest.TestCase):\n    def setUp(self):\n        import Products.isurlinportal\n\n        # Patch get_external_sites to return a fixed list of sites.\n        self._original_get_external_sites = Products.isurlinportal.get_external_sites\n        Products.isurlinportal.get_external_sites = dummy_get_external_sites\n\n        # Create dummy site and content.\n        self.site = DummySite(id=\"foo\")\n        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))\n        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))\n\n    def tearDown(self):\n        import Products.isurlinportal\n\n        # Restore original get_external_sites.\n        Products.isurlinportal.get_external_sites = self._original_get_external_sites\n\n    def _makeOne(self, *args, **kw):\n        from Products.CMFPlone.URLTool import URLTool\n\n        url_tool = URLTool(*args, **kw)\n        return url_tool.__of__(self.site)\n\n    def test_isURLInPortal(self):\n        # First test what the absolute url of the site is, otherwise these\n        # tests look really weird.  Apparently our domain is www.foobar.com.\n        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")\n\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))\n        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))\n        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))\n        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"/images\"))\n        self.assertTrue(iURLiP(\"/bar/foo/foo\"))\n\n    def test_isURLInPortalRelative(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n\n        # non-root relative urls will need a current context to be passed in\n        self.assertTrue(iURLiP(\"images/img1.jpg\"))\n        self.assertTrue(iURLiP(\"./images/img1.jpg\"))\n\n        # /bar/foo/something\n        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))\n        # /bar/afolder\n        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))\n        # /afolder\n        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))\n\n        # /../afolder? How do we have more ../'s than there are parts in\n        # the URL?\n        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))\n\n        # /bar/foo/afolder\n        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))\n\n    def test_isURLInPortalExternal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://external1\"))\n        self.assertTrue(iURLiP(\"http://external1/\"))\n        self.assertTrue(iURLiP(\"http://external1/something\"))\n        self.assertTrue(iURLiP(\"http://external2\"))\n        self.assertTrue(iURLiP(\"http://external2/\"))\n        self.assertTrue(iURLiP(\"http://external2/something\"))\n        self.assertTrue(iURLiP(\"http://external3/site\"))\n        self.assertTrue(iURLiP(\"http://external3/site/\"))\n        self.assertTrue(iURLiP(\"http://external3/site/something\"))\n        self.assertTrue(iURLiP(\"http://external4/site\"))\n        self.assertTrue(iURLiP(\"http://external4/site/\"))\n        self.assertTrue(iURLiP(\"http://external4/site/something\"))\n\n        self.assertFalse(iURLiP(\"http://external3/other\"))\n        self.assertFalse(iURLiP(\"http://external4/other\"))\n        self.assertFalse(iURLiP(\"http://external5\"))\n        self.assertFalse(iURLiP(\"http://external11\"))\n\n    def test_script_tag_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n\n    def test_inline_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"javascript:alert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))\n\n    def test_double_back_slash(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))\n\n    def test_escape(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))\n\n    def test_regression_absolute_url_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(url_tool()))\n        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))\n\n    def test_mailto_simple_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))\n\n    def test_mailto_complex_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\n                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"\n                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"\n                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"\n            )\n        )\n\n    def test_data_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")\n        )\n\n    def test_ftp_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))\n\n    def test_double_slash(self):\n        # I wondered if this might be a problem after reading\n        # https://bugs.python.org/issue23505\n        # Apparently not, but let's test it.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"//www.google.com\"))\n        self.assertFalse(iURLiP(\"////www.google.com\"))\n\n    def test_empty(self):\n        # Redirecting to nothing would probably mean we end up on the same page.\n        # So an empty url should be fine.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"\"))\n\n    def test_newlines(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertFalse(iURLiP(\"f\\noo\"))\n        self.assertFalse(iURLiP(\"f\\roo\"))\n        self.assertFalse(iURLiP(\"\\nfoo\"))\n        self.assertFalse(iURLiP(\"\\rfoo\"))\n\n    def test_whitespace(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertTrue(iURLiP(\"f oo\"))\n        # '\\x20' == ' '\n        self.assertTrue(iURLiP(\"f\\x20oo\"))\n        self.assertFalse(iURLiP(\"f\\too\"))\n        self.assertFalse(iURLiP(\"\\tfoo\"))\n        self.assertFalse(iURLiP(\"foo\\t\"))\n        self.assertFalse(iURLiP(\" foo\"))\n        self.assertFalse(iURLiP(\"foo \"))\n\n    def test_without_slashes(self):\n        # This does not work in all browsers.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"http:example.org\"))\n        self.assertFalse(iURLiP(\"https:example.org\"))", "target": 0}], "function_after": [{"function": "class DummyFolder(DummyFolder):\n    def absolute_url(self):\n        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])", "target": 0}, {"function": "def dummy_get_external_sites(context=None):\n    return [\n        \"http://external1\",\n        \"http://external2/\",\n        \"http://external3/site\",\n        \"http://external4/site/\",\n    ]", "target": 0}, {"function": "class TestURLTool(unittest.TestCase):\n    def setUp(self):\n        import Products.isurlinportal\n\n        # Patch get_external_sites to return a fixed list of sites.\n        self._original_get_external_sites = Products.isurlinportal.get_external_sites\n        Products.isurlinportal.get_external_sites = dummy_get_external_sites\n\n        # Create dummy site and content.\n        self.site = DummySite(id=\"foo\")\n        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))\n        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))\n\n    def tearDown(self):\n        import Products.isurlinportal\n\n        # Restore original get_external_sites.\n        Products.isurlinportal.get_external_sites = self._original_get_external_sites\n\n    def _makeOne(self, *args, **kw):\n        from Products.CMFPlone.URLTool import URLTool\n\n        url_tool = URLTool(*args, **kw)\n        return url_tool.__of__(self.site)\n\n    def test_isURLInPortal(self):\n        # First test what the absolute url of the site is, otherwise these\n        # tests look really weird.  Apparently our domain is www.foobar.com.\n        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")\n\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))\n        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))\n        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))\n        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))\n        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))\n        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))\n        self.assertFalse(iURLiP(\"/images\"))\n        self.assertTrue(iURLiP(\"/bar/foo/foo\"))\n\n    def test_isURLInPortalRelative(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n\n        # non-root relative urls will need a current context to be passed in\n        self.assertTrue(iURLiP(\"images/img1.jpg\"))\n        self.assertTrue(iURLiP(\"./images/img1.jpg\"))\n\n        # /bar/foo/something\n        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))\n        # /bar/afolder\n        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))\n        # /afolder\n        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))\n\n        # /../afolder? How do we have more ../'s than there are parts in\n        # the URL?\n        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))\n\n        # /bar/foo/afolder\n        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))\n\n    def test_isURLInPortalExternal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"http://external1\"))\n        self.assertTrue(iURLiP(\"http://external1/\"))\n        self.assertTrue(iURLiP(\"http://external1/something\"))\n        self.assertTrue(iURLiP(\"http://external2\"))\n        self.assertTrue(iURLiP(\"http://external2/\"))\n        self.assertTrue(iURLiP(\"http://external2/something\"))\n        self.assertTrue(iURLiP(\"http://external3/site\"))\n        self.assertTrue(iURLiP(\"http://external3/site/\"))\n        self.assertTrue(iURLiP(\"http://external3/site/something\"))\n        self.assertTrue(iURLiP(\"http://external4/site\"))\n        self.assertTrue(iURLiP(\"http://external4/site/\"))\n        self.assertTrue(iURLiP(\"http://external4/site/something\"))\n\n        self.assertFalse(iURLiP(\"http://external3/other\"))\n        self.assertFalse(iURLiP(\"http://external4/other\"))\n        self.assertFalse(iURLiP(\"http://external5\"))\n        self.assertFalse(iURLiP(\"http://external11\"))\n\n    def test_script_tag_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))\n        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))\n\n    def test_inline_url_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))\n        self.assertFalse(iURLiP(\"javascript:alert(3)\"))\n        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))\n\n    def test_double_back_slash(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))\n\n    def test_escape(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))\n        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))\n\n    def test_regression_absolute_url_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(url_tool()))\n        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))\n\n    def test_mailto_simple_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))\n\n    def test_mailto_complex_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\n                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"\n                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"\n                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"\n            )\n        )\n\n    def test_data_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(\n            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")\n        )\n\n    def test_ftp_not_in_portal(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))\n\n    def test_double_slash(self):\n        # I wondered if this might be a problem after reading\n        # https://bugs.python.org/issue23505\n        # Apparently not, but let's test it.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"//www.google.com\"))\n        self.assertFalse(iURLiP(\"////www.google.com\"))\n\n    def test_empty(self):\n        # Redirecting to nothing would probably mean we end up on the same page.\n        # So an empty url should be fine.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"\"))\n\n    def test_newlines(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertFalse(iURLiP(\"f\\noo\"))\n        self.assertFalse(iURLiP(\"f\\roo\"))\n        self.assertFalse(iURLiP(\"\\nfoo\"))\n        self.assertFalse(iURLiP(\"\\rfoo\"))\n\n    def test_whitespace(self):\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertTrue(iURLiP(\"foo\"))\n        self.assertTrue(iURLiP(\"f oo\"))\n        # '\\x20' == ' '\n        self.assertTrue(iURLiP(\"f\\x20oo\"))\n        self.assertFalse(iURLiP(\"f\\too\"))\n        self.assertFalse(iURLiP(\"\\tfoo\"))\n        self.assertFalse(iURLiP(\"foo\\t\"))\n        self.assertFalse(iURLiP(\" foo\"))\n        self.assertFalse(iURLiP(\"foo \"))\n\n    def test_without_slashes(self):\n        # This does not work in all browsers.\n        url_tool = self._makeOne()\n        iURLiP = url_tool.isURLInPortal\n        self.assertFalse(iURLiP(\"http:example.org\"))\n        self.assertFalse(iURLiP(\"https:example.org\"))", "target": 0}]}, {"raw_url": "https://github.com/plone/Products.isurlinportal/raw/d4fd34990d18adf05a10dc5e2bb4b066798280ba/news%2F1.feature", "code": "Treat urls like ``https:example.org`` without slashes as outside the portal.\nSome browsers would redirect to example.org, some would redirect to a non-existing local page.\nWe never want this, because this is likely a hack attempt.\nThis vulnerability was discovered and reported by Yuji Tounai of Mitsui Bussan Secure Directions, Inc.\nSee `security advisory 1 <https://github.com/plone/Products.isurlinportal/security/advisories/GHSA-q3m9-9fj2-mfwr>`_.\n[maurits]\n", "code_before": "Treat urls like ``https:example.org`` without slashes as outside the portal.\nSome browsers would redirect to example.org, some would redirect to a non-existing local page.\nWe never want this, because this is likely a hack attempt.\nThis vulnerability was discovered and reported by Yuji Tounai of Mitsui Bussan Secure Directions, Inc.\nSee `security advisory 1 <https://github.com/plone/Products.isurlinportal/security/advisories/GHSA-q3m9-9fj2-mfwr>`_.\n[maurits]\n", "patch": "@@ -0,0 +1,6 @@\n+Treat urls like ``https:example.org`` without slashes as outside the portal.\n+Some browsers would redirect to example.org, some would redirect to a non-existing local page.\n+We never want this, because this is likely a hack attempt.\n+This vulnerability was discovered and reported by Yuji Tounai of Mitsui Bussan Secure Directions, Inc.\n+See `security advisory 1 <https://github.com/plone/Products.isurlinportal/security/advisories/GHSA-q3m9-9fj2-mfwr>`_.\n+[maurits]", "file_path": "files/2021_8/589", "file_language": "feature", "file_name": "news/1.feature", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
