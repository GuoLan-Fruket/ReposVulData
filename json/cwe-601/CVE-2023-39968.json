{"index": 12057, "cve_id": "CVE-2023-39968", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "jupyter-server is the backend for Jupyter web applications. Open Redirect Vulnerability. Maliciously crafted login links to known Jupyter Servers can cause successful login or an already logged-in session to be redirected to arbitrary sites, which should be restricted to Jupyter Server-served URLs. This issue has been addressed in commit `29036259` which is included in release 2.7.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "cvss": "6.1", "publish_date": "August 28, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "290362593b2ffb23c59f8114d76f77875de4b925", "commit_message": "Merge pull request from GHSA-r726-vmfq-j9j3\n\nCo-authored-by: Zachary Sailer <zsailer@apple.com>", "commit_date": "2023-08-18T03:27:27Z", "project": "jupyter-server/jupyter_server", "url": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/290362593b2ffb23c59f8114d76f77875de4b925", "html_url": "https://github.com/jupyter-server/jupyter_server/commit/290362593b2ffb23c59f8114d76f77875de4b925", "windows_before": [{"commit_id": "87a4927272819f0b1cae1afa4c8c86ee2da002fd", "commit_date": "Fri Aug 18 05:27:05 2023 +0200", "commit_message": "Merge pull request from GHSA-64x5-55rw-9974", "files_name": ["jupyter_server/base/handlers.py"]}, {"commit_id": "ed65a6ce85808b9099e652cea6170f0289e76e51", "commit_date": "Tue Aug 15 23:24:38 2023 +0900", "commit_message": "Assert return value of `expected_http_error` (#1308)", "files_name": ["jupyter_server/services/events/handlers.py", "tests/services/contents/test_manager.py", "tests/services/events/test_api.py"]}, {"commit_id": "a25440c2ebc9ec5576e6fab52ba5b925b8f729c0", "commit_date": "Tue Aug 15 11:33:07 2023 +0000", "commit_message": "Bump to 2.8.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "6b45913c174fec7dfa13b9d95f85bf345ad7316c", "commit_date": "Tue Aug 15 11:33:05 2023 +0000", "commit_message": "Publish 2.7.1", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}, {"commit_id": "d8f4856c32b895106eac58c9c5768afd0e2f6465", "commit_date": "Tue Aug 15 13:25:51 2023 +0200", "commit_message": "accessing API version should not count as activity (#1315)", "files_name": ["jupyter_server/base/handlers.py"]}, {"commit_id": "bc171145cd00178465f38ea7d2e349fd928752e7", "commit_date": "Mon Aug 14 19:50:13 2023 -0500", "commit_message": "minor change to test token usage", "files_name": ["pyproject.toml"]}, {"commit_id": "c0833098e8c54b302a865a5fb9e63e0a8d7b2ebc", "commit_date": "Sat Aug 12 13:00:42 2023 +0200", "commit_message": "Add root `/api/` endpoint to REST spec (#1312)", "files_name": ["jupyter_server/services/api/api.yaml"]}, {"commit_id": "c5dc0f696f376e1db5a9a0cbcebb40a0bf98875c", "commit_date": "Wed Jul 26 11:57:41 2023 +0200", "commit_message": "Fix broken link in doc (#1307)", "files_name": ["docs/source/developers/extensions.rst"]}, {"commit_id": "aa7885cd8a9636d3e9fa006e6d5ef5d609c78089", "commit_date": "Wed Jul 26 13:15:30 2023 +0400", "commit_message": "Rename notebook.auth.security.passwd->jupyter_server.auth.passwd in docs (#1306)", "files_name": ["docs/source/operators/public-server.rst"]}, {"commit_id": "c1d689e05169ba47e630ccaa39cebb4f847b3562", "commit_date": "Sat Jul 15 15:52:12 2023 -0500", "commit_message": "[pre-commit.ci] pre-commit autoupdate (#1295)", "files_name": [".pre-commit-config.yaml", "jupyter_server/gateway/gateway_client.py", "jupyter_server/serverapp.py", "jupyter_server/services/kernels/connection/channels.py", "jupyter_server/services/kernels/websocket.py", "jupyter_server/utils.py", "pyproject.toml"]}, {"commit_id": "2563baeca9575be7895930ada2b1d244f93e5163", "commit_date": "Wed Jul 12 18:44:46 2023 -0700", "commit_message": "Make kernel_id as a conditional optional field (#1300)", "files_name": ["jupyter_server/event_schemas/kernel_actions/v1.yaml", "jupyter_server/services/kernels/kernelmanager.py", "pyproject.toml"]}, {"commit_id": "6658e2fc004bc4af9e5f30dda05bce3d4d1e5957", "commit_date": "Fri Jul 7 18:42:07 2023 +0300", "commit_message": "docs: fix broken hyperlink to Tornado (#1297)", "files_name": ["docs/source/operators/public-server.rst", "pyproject.toml"]}, {"commit_id": "7d1ea8b6d86497510d13b3114049725599406bcc", "commit_date": "Thu Jul 6 16:25:41 2023 +0100", "commit_message": "Update notes link (#1298)", "files_name": ["README.md"]}, {"commit_id": "8131c214c448182d93a1ed804abfa7d34bfee26c", "commit_date": "Fri Jun 30 03:28:04 2023 -0500", "commit_message": "Reference current_user to detect auth (#1294)", "files_name": ["jupyter_server/base/handlers.py"]}, {"commit_id": "8c90eb5cdce4bb66ec14a22a02b0abbf5ec58b67", "commit_date": "Wed Jun 28 00:47:46 2023 +0800", "commit_message": "send2trash now supports deleting from different filesystem type(#1290) (#1291)", "files_name": ["jupyter_server/services/contents/filemanager.py", "pyproject.toml"]}, {"commit_id": "32df893ef2fdd40a102e73a361c4280dbf042b71", "commit_date": "Tue Jun 27 03:52:43 2023 +0000", "commit_message": "Bump to 2.8.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "c8fff464f5fb4565ee045e68bb00bd7c87ce01f0", "commit_date": "Tue Jun 27 03:52:41 2023 +0000", "commit_message": "Publish 2.7.0", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}, {"commit_id": "b652f8d08530bd60ecf4cfffe6c32939fd94eb41", "commit_date": "Fri Jun 23 19:49:33 2023 +0200", "commit_message": "Remove frontend doc (#1292)", "files_name": ["docs/source/operators/public-server.rst"]}, {"commit_id": "820551ceaff90ec6ed72abaa6ae4f1b09075ab6e", "commit_date": "Thu Jun 22 08:03:58 2023 -0700", "commit_message": "Add missing events to gateway client (#1288)", "files_name": ["jupyter_server/gateway/gateway_client.py"]}, {"commit_id": "8c2987fef9da26c3ef12f6be8a6ad53444446578", "commit_date": "Mon Jun 19 09:19:17 2023 -0500", "commit_message": "Try testing against python 3.12 (#1282)", "files_name": [".github/workflows/python-tests.yml", "pyproject.toml"]}, {"commit_id": "acf63901a86d4197654b38f877408faee47e6b25", "commit_date": "Mon Jun 19 08:54:57 2023 -0500", "commit_message": "Handle test failures (#1289)", "files_name": [".github/workflows/python-tests.yml", "pyproject.toml", "tests/test_terminal.py"]}, {"commit_id": "d48843eea78fe2ee37608a767ceea3d0d2f71763", "commit_date": "Tue Jun 6 02:05:07 2023 +0000", "commit_message": "[pre-commit.ci] pre-commit autoupdate (#1286)", "files_name": [".pre-commit-config.yaml", "jupyter_server/services/kernels/connection/base.py", "pyproject.toml"]}, {"commit_id": "9106e059f74353701621fd83e39584a910060ce0", "commit_date": "Thu May 25 17:01:40 2023 +0000", "commit_message": "Bump to 2.7.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "4249fb62612bef2c62c39a8d48d933dc9735e2f5", "commit_date": "Thu May 25 17:01:37 2023 +0000", "commit_message": "Publish 2.6.0", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}, {"commit_id": "35b8e9cb68eec48fe9a017ac128cb776c2ead195", "commit_date": "Tue May 23 16:30:05 2023 +0200", "commit_message": "Fix DeprecationWarning from pytest-console-scripts (#1281)", "files_name": ["tests/extension/test_entrypoint.py"]}, {"commit_id": "09c15ce4ffa9b1c5b54c376ff1601475150554fb", "commit_date": "Mon May 15 17:33:24 2023 -0500", "commit_message": "Remove distuils and mistune pins (#1278)", "files_name": ["pyproject.toml"]}, {"commit_id": "d7e3b0863d1fad9e007af44cd378a20c37f521c5", "commit_date": "Mon May 15 17:14:46 2023 -0500", "commit_message": "Update docutils requirement from <0.20 to <0.21 (#1277)", "files_name": ["pyproject.toml"]}, {"commit_id": "5342880d42315afb1332b8e7a6a4a0749e9f7a1f", "commit_date": "Fri May 12 12:33:56 2023 +0200", "commit_message": "Write server list to stdout (#1275)", "files_name": ["jupyter_server/serverapp.py", "pyproject.toml", "tests/test_serverapp.py"]}, {"commit_id": "cca1ef14c557a9ab4bf27c51ab6f5c672296f31a", "commit_date": "Fri May 12 12:33:44 2023 +0200", "commit_message": "Don't instantiate an unused Future in gateway connection trait (#1276)", "files_name": ["jupyter_server/gateway/connections.py"]}, {"commit_id": "35ffe5d435682128da16dc144a8e9e9f8fa85dd8", "commit_date": "Wed May 10 14:12:10 2023 -0700", "commit_message": "Merge the gateway handlers into the standard handlers. (#1261)", "files_name": ["docs/source/api/jupyter_server.gateway.rst", "jupyter_server/gateway/connections.py", "jupyter_server/gateway/handlers.py", "jupyter_server/kernelspecs/handlers.py", "jupyter_server/serverapp.py", "tests/test_gateway.py", "tests/test_serverapp.py"]}, {"commit_id": "54d72923949a506375c522193b41b3cff3aaa79f", "commit_date": "Wed May 10 18:07:23 2023 +0200", "commit_message": "Allows immutable cache for static files in a directory (#1268)", "files_name": ["jupyter_server/base/handlers.py", "jupyter_server/serverapp.py", "tests/base/test_handlers.py", "tests/test_serverapp.py"]}, {"commit_id": "ecd282229770c6545fa49ab6ad4b7beac60ff60b", "commit_date": "Wed May 10 09:04:49 2023 -0700", "commit_message": "Make the kernel_websocket_protocol flag reusable. (#1264)", "files_name": ["jupyter_server/services/kernels/connection/base.py", "jupyter_server/services/kernels/connection/channels.py"]}, {"commit_id": "e6be0fa72220271a12fdb01f83f487c894b8696d", "commit_date": "Mon May 8 17:15:46 2023 -0500", "commit_message": "[pre-commit.ci] pre-commit autoupdate (#1266)", "files_name": [".pre-commit-config.yaml", "jupyter_server/_sysinfo.py", "jupyter_server/serverapp.py", "pyproject.toml", "tests/extension/test_launch.py", "tests/services/kernels/test_events.py", "tests/test_utils.py"]}, {"commit_id": "f8ed273bb790f167c24a29f14a5f6cbf73e7eee3", "commit_date": "Mon May 8 23:41:18 2023 +0200", "commit_message": "Fix typo in docs (#1270)", "files_name": ["docs/source/operators/security.rst"]}, {"commit_id": "15505bb3467eaacaa83e7dc2a04f882e29a9d152", "commit_date": "Sat May 6 06:11:45 2023 -0700", "commit_message": "Use Python 3.9 for the readthedocs builds (#1269)", "files_name": [".readthedocs.yaml"]}, {"commit_id": "3ba9ac973643b56011cb6fbd63dc1093865b174e", "commit_date": "Tue Apr 25 15:02:07 2023 +0200", "commit_message": "Extends the IP documentation (#1258)Co-authored-by: Zachary Sailer <zachsailer@gmail.com>", "files_name": ["docs/source/operators/security.rst"]}, {"commit_id": "934fb5b4ef231301656bec900221cbe91830eaf9", "commit_date": "Mon Apr 24 18:18:09 2023 +0200", "commit_message": "Fix typo (#1262)", "files_name": ["docs/source/operators/multiple-extensions.rst"]}, {"commit_id": "5c49253359865773439bdba69352e26a473b9e07", "commit_date": "Mon Apr 17 13:52:05 2023 -0700", "commit_message": "Emit events from the kernels service and gateway client (#1252)", "files_name": ["jupyter_server/event_schemas/gateway_client/v1.yaml", "jupyter_server/event_schemas/kernel_actions/v1.yaml", "jupyter_server/gateway/gateway_client.py", "jupyter_server/gateway/managers.py", "jupyter_server/serverapp.py", "jupyter_server/services/kernels/kernelmanager.py", "pyproject.toml", "tests/services/kernels/test_events.py", "tests/test_gateway.py"]}, {"commit_id": "8144a0d1192761b0925f1ecee5e5b8900b49b01c", "commit_date": "Thu Apr 13 15:39:38 2023 -0500", "commit_message": "Fix coverage handling (#1257)", "files_name": [".github/workflows/integration-tests.yml", ".github/workflows/python-tests.yml", "README.md", "codecov.yml", "docs/source/conf.py", "pyproject.toml"]}, {"commit_id": "ca4b06227a3a1387d02c149eba9c12415a8520d0", "commit_date": "Tue Apr 11 10:10:32 2023 -0700", "commit_message": "Define a CURRENT_JUPYTER_HANDLER context var (#1251)", "files_name": ["docs/source/api/jupyter_server.base.rst", "jupyter_server/__init__.py", "jupyter_server/base/call_context.py", "jupyter_server/base/handlers.py", "tests/base/test_call_context.py"]}, {"commit_id": "87b215809701f46819e775c29417884a77dc935c", "commit_date": "Fri Apr 7 08:05:15 2023 -0700", "commit_message": "Gateway manager retry kernel updates (#1256)", "files_name": ["jupyter_server/gateway/managers.py", "tests/test_gateway.py"]}, {"commit_id": "cd8010e2335de29e6f9d7b98cd496b0695bc0ed3", "commit_date": "Tue Apr 4 17:58:45 2023 +0000", "commit_message": "[pre-commit.ci] pre-commit autoupdate (#1255)", "files_name": [".pre-commit-config.yaml", "jupyter_server/auth/__main__.py", "jupyter_server/auth/identity.py", "jupyter_server/auth/login.py", "jupyter_server/auth/security.py", "jupyter_server/auth/utils.py", "jupyter_server/base/handlers.py", "jupyter_server/extension/utils.py", "jupyter_server/gateway/handlers.py", "jupyter_server/serverapp.py", "jupyter_server/services/kernels/websocket.py", "jupyter_server/utils.py", "pyproject.toml", "tests/auth/test_login.py", "tests/extension/test_manager.py", "tests/test_serverapp.py"]}], "windows_after": [{"commit_id": "5a8a47f5ba674d0f758a91cca08e2a9c6eacf224", "commit_date": "Fri Aug 18 03:46:02 2023 +0000", "commit_message": "Publish 2.7.2", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "b1388b55eebe868e25c33d4ccc4c835fadb5381a", "commit_date": "Fri Aug 18 03:46:04 2023 +0000", "commit_message": "Bump to 2.8.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "e72bf7187e396605f46ba59567543ef6386e8920", "commit_date": "Thu Aug 31 10:08:57 2023 +0200", "commit_message": "Support external kernels (#1305)", "files_name": ["jupyter_server/serverapp.py", "jupyter_server/services/kernels/connection/channels.py"]}, {"commit_id": "cf8df8a6b26455977f1eb946dc3dead069981ea4", "commit_date": "Thu Aug 31 08:20:33 2023 +0000", "commit_message": "Publish 2.7.3", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}, {"commit_id": "93fde1ad9fece22607960184501f5c9c80cd3765", "commit_date": "Thu Aug 31 08:20:36 2023 +0000", "commit_message": "Bump to 2.8.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "1d9a77a4e3ba980014bf69174813a766838bfd3d", "commit_date": "Mon Sep 4 18:35:57 2023 +0200", "commit_message": "Avoid showing \"No answer for 5s\" when shutdown is slow (#1320)", "files_name": ["jupyter_server/serverapp.py"]}, {"commit_id": "a7b033deba7b4d87d8ce85846edd032db89d8910", "commit_date": "Mon Sep 4 21:05:20 2023 -0500", "commit_message": "Bump actions/checkout from 3 to 4 (#1321)", "files_name": [".github/workflows/downstream.yml", ".github/workflows/python-tests.yml"]}, {"commit_id": "1cb41168c21c9191dd52103f0ec1209d7e1debd0", "commit_date": "Tue Sep 5 05:06:10 2023 -0500", "commit_message": "[pre-commit.ci] pre-commit autoupdate (#1322)", "files_name": [".pre-commit-config.yaml", "jupyter_server/base/handlers.py", "jupyter_server/extension/application.py", "jupyter_server/extension/utils.py", "jupyter_server/gateway/connections.py", "jupyter_server/gateway/gateway_client.py", "jupyter_server/gateway/handlers.py", "jupyter_server/gateway/managers.py", "jupyter_server/log.py", "jupyter_server/serverapp.py", "jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/manager.py", "jupyter_server/services/kernels/connection/channels.py", "jupyter_server/services/kernelspecs/handlers.py", "jupyter_server/services/sessions/sessionmanager.py", "jupyter_server/traittypes.py", "pyproject.toml"]}, {"commit_id": "46e685bdce384e4c82530981cd8197bfa00aa39d", "commit_date": "Mon Sep 18 21:46:25 2023 -0500", "commit_message": "Adopt sp-repo-review (#1324)", "files_name": [".github/workflows/python-tests.yml", ".pre-commit-config.yaml", "CHANGELOG.md", "CONTRIBUTING.rst", "docs/source/conf.py", "docs/source/developers/contents.rst", "docs/source/developers/extensions.rst", "docs/source/developers/savehooks.rst", "docs/source/developers/websocket-protocols.rst", "docs/source/operators/configuring-logging.rst", "docs/source/operators/public-server.rst", "docs/source/operators/security.rst", "docs/source/users/configuration.rst", "examples/authorization/README.md", "examples/identity/system_password/jupyter_server_config.py", "examples/simple/README.md", "examples/simple/conftest.py", "examples/simple/simple_ext11/application.py", "examples/simple/simple_ext2/application.py", "jupyter_server/_tz.py", "jupyter_server/base/handlers.py", "jupyter_server/event_schemas/contents_service/v1.yaml", "jupyter_server/event_schemas/gateway_client/v1.yaml", "jupyter_server/event_schemas/kernel_actions/v1.yaml", "jupyter_server/extension/application.py", "jupyter_server/extension/utils.py", "jupyter_server/gateway/gateway_client.py", "jupyter_server/gateway/handlers.py", "jupyter_server/gateway/managers.py", "jupyter_server/i18n/notebook.pot", "jupyter_server/i18n/zh_CN/LC_MESSAGES/notebook.po", "jupyter_server/kernelspecs/handlers.py", "jupyter_server/log.py", "jupyter_server/prometheus/metrics.py", "jupyter_server/serverapp.py", "jupyter_server/services/api/api.yaml", "jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/manager.py", "jupyter_server/services/kernels/connection/channels.py", "jupyter_server/services/kernels/kernelmanager.py", "jupyter_server/services/sessions/sessionmanager.py", "jupyter_server/utils.py", "package.json", "pyproject.toml", "tests/base/test_handlers.py", "tests/extension/test_serverextension.py", "tests/services/config/test_api.py", "tests/services/contents/test_api.py", "tests/services/contents/test_fileio.py", "tests/services/kernelspecs/test_api.py", "tests/test_gateway.py", "tests/test_serverapp.py", "tests/test_terminal.py", "tests/unix_sockets/test_serverapp_integration.py"]}, {"commit_id": "3544deb53902cc02c9aa9d6513b3c30f1113896b", "commit_date": "Thu Sep 28 12:54:48 2023 -0500", "commit_message": "Update typings for traitlets 5.10 (#1330)", "files_name": ["examples/simple/simple_ext1/application.py", "examples/simple/simple_ext2/application.py", "jupyter_server/auth/identity.py", "jupyter_server/extension/manager.py", "jupyter_server/gateway/connections.py", "jupyter_server/gateway/gateway_client.py", "jupyter_server/gateway/managers.py", "jupyter_server/serverapp.py", "jupyter_server/services/contents/filecheckpoints.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/manager.py", "jupyter_server/services/events/handlers.py", "jupyter_server/services/kernels/connection/channels.py", "jupyter_server/services/kernels/kernelmanager.py", "jupyter_server/traittypes.py", "pyproject.toml", "tests/extension/mockextensions/app.py"]}, {"commit_id": "1ece796301b185d69e2173a303487966585b5356", "commit_date": "Tue Oct 3 15:59:19 2023 -0500", "commit_message": "chore: update pre-commit hooks (#1334)", "files_name": [".pre-commit-config.yaml", "CHANGELOG.md", "docs/source/developers/contents.rst", "jupyter_server/base/handlers.py"]}, {"commit_id": "63463c40a51e8a7454d1f587da83077ef697206d", "commit_date": "Sat Oct 14 19:24:36 2023 -0500", "commit_message": "Add typings to commonly used APIs (#1333)", "files_name": ["examples/simple/simple_ext1/handlers.py", "examples/simple/simple_ext2/handlers.py", "jupyter_server/_tz.py", "jupyter_server/auth/decorator.py", "jupyter_server/auth/identity.py", "jupyter_server/auth/login.py", "jupyter_server/base/handlers.py", "jupyter_server/config_manager.py", "jupyter_server/extension/application.py", "jupyter_server/extension/handler.py", "jupyter_server/extension/serverextension.py", "jupyter_server/files/handlers.py", "jupyter_server/gateway/connections.py", "jupyter_server/gateway/handlers.py", "jupyter_server/gateway/managers.py", "jupyter_server/nbconvert/handlers.py", "jupyter_server/serverapp.py", "jupyter_server/services/contents/filemanager.py", "jupyter_server/services/contents/handlers.py", "jupyter_server/services/contents/manager.py", "jupyter_server/services/events/handlers.py", "jupyter_server/services/kernels/handlers.py", "jupyter_server/services/kernelspecs/handlers.py", "jupyter_server/services/sessions/handlers.py", "jupyter_server/services/shutdown.py", "jupyter_server/utils.py", "pyproject.toml", "tests/base/test_handlers.py", "tests/services/sessions/test_manager.py", "tests/test_gateway.py", "tests/test_utils.py"]}, {"commit_id": "89c8de5c6b7612559c8adfdc72b90af2241488f8", "commit_date": "Sat Oct 14 19:50:17 2023 -0500", "commit_message": "Update typings for mypy 1.6 (#1337)", "files_name": ["docs/source/conf.py", "examples/identity/system_password/jupyter_server_config.py", "examples/simple/simple_ext11/application.py", "jupyter_server/gateway/managers.py", "jupyter_server/prometheus/metrics.py", "jupyter_server/services/sessions/sessionmanager.py", "jupyter_server/utils.py", "pyproject.toml", "tests/test_terminal.py"]}, {"commit_id": "a984e0771da5db4a14e9ac86a392ad3592b863e5", "commit_date": "Sun Oct 15 20:22:07 2023 +0530", "commit_message": "Added Logs for get_os_path closes issue (#1336)", "files_name": ["jupyter_server/services/contents/fileio.py", "jupyter_server/services/contents/filemanager.py", "tests/services/contents/test_fileio.py"]}, {"commit_id": "91e726c8cf6f9c1b7e829406e34dc206af239c07", "commit_date": "Mon Oct 16 10:27:53 2023 +0000", "commit_message": "Publish 2.8.0", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}, {"commit_id": "260e86acbac026645ef451ac7da67b5ba18e1dae", "commit_date": "Mon Oct 16 10:27:55 2023 +0000", "commit_message": "Bump to 2.9.0.dev0", "files_name": ["jupyter_server/_version.py"]}, {"commit_id": "393c108694c566a3716f1004db3a109f6516815d", "commit_date": "Mon Oct 23 09:04:32 2023 -0700", "commit_message": "Run Gateway token renewers even if the auth token is empty. (#1340)", "files_name": ["jupyter_server/gateway/gateway_client.py", "tests/test_gateway.py"]}, {"commit_id": "b475f0e25660a26fcff70700ac33e3e24f1c3726", "commit_date": "Tue Oct 24 13:16:39 2023 -0700", "commit_message": "Ability to configure cull_idle_timeout with kernelSpec (#1342)", "files_name": ["jupyter_server/services/kernels/kernelmanager.py", "tests/services/kernels/test_cull.py"]}, {"commit_id": "3438ddb16575155e98fc4f49700fff420088c8b0", "commit_date": "Wed Oct 25 02:05:30 2023 +0200", "commit_message": "Update kernel env to reflect changes in session. (#1341)", "files_name": ["jupyter_server/services/sessions/sessionmanager.py"]}, {"commit_id": "b137c8d0297fa88f520a27bb2d6f137ba9511a96", "commit_date": "Wed Oct 25 01:28:54 2023 +0000", "commit_message": "Publish 2.9.0", "files_name": ["CHANGELOG.md", "jupyter_server/_version.py"]}], "parents": [{"commit_id_before": "87a4927272819f0b1cae1afa4c8c86ee2da002fd", "url_before": "https://api.github.com/repos/jupyter-server/jupyter_server/commits/87a4927272819f0b1cae1afa4c8c86ee2da002fd", "html_url_before": "https://github.com/jupyter-server/jupyter_server/commit/87a4927272819f0b1cae1afa4c8c86ee2da002fd"}], "details": [{"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/290362593b2ffb23c59f8114d76f77875de4b925/jupyter_server%2Fauth%2Flogin.py", "code": "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport os\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom ..base.handlers import JupyterHandler\nfrom .security import passwd_check, set_password\n\n\nclass LoginFormHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    accepts login form, passed to IdentityProvider.process_login_form.\n    \"\"\"\n\n    def _render(self, message=None):\n        \"\"\"Render the login form.\"\"\"\n        self.write(\n            self.render_template(\n                \"login.html\",\n                next=url_escape(self.get_argument(\"next\", default=self.base_url)),\n                message=message,\n            )\n        )\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        # urllib and browsers interpret extra '/' in the scheme separator (`scheme:///host/path`)\n        # differently.\n        # urllib gives scheme=scheme, netloc='', path='/host/path', while\n        # browsers get scheme=scheme, netloc='host', path='/path'\n        # so make sure ':///*' collapses to '://' by splitting and stripping any additional leading slash\n        # don't allow any kind of `:/` shenanigans by splitting on ':' only\n        # and replacing `:/*` with exactly `://`\n        if \":\" in url:\n            scheme, _, rest = url.partition(\":\")\n            url = f\"{scheme}://{rest.lstrip('/')}\"\n        parsed = urlparse(url)\n        # full url may be `//host/path` (empty scheme == same scheme as request)\n        # or `https://host/path`\n        # or even `https:///host/path` (invalid, but accepted and ambiguously interpreted)\n        if (parsed.scheme or parsed.netloc) or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.scheme or parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = f\"{parsed.scheme}://{parsed.netloc}\"\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(re.match(self.allow_origin_pat, origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        \"\"\"Get the login form.\"\"\"\n        if self.current_user:\n            next_url = self.get_argument(\"next\", default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    def post(self):\n        \"\"\"Post a login.\"\"\"\n        user = self.current_user = self.identity_provider.process_login_form(self)\n        if user is None:\n            self.set_status(401)\n            self._render(message={\"error\": \"Invalid credentials\"})\n            return\n\n        self.log.info(f\"User {user.username} logged in.\")\n        self.identity_provider.set_login_cookie(self, user)\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n\nclass LegacyLoginHandler(LoginFormHandler):\n    \"\"\"Legacy LoginHandler, implementing most custom auth configuration.\n\n    Deprecated in jupyter-server 2.0.\n    Login configuration has moved to IdentityProvider.\n    \"\"\"\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        \"\"\"Check a passwd.\"\"\"\n        return passwd_check(a, b)\n\n    def post(self):\n        \"\"\"Post a login form.\"\"\"\n        typed_password = self.get_argument(\"password\", default=\"\")\n        new_password = self.get_argument(\"new_password\", default=\"\")\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and getattr(self.identity_provider, \"allow_password_change\", False):\n                    config_dir = self.settings.get(\"config_dir\", \"\")\n                    config_file = os.path.join(config_dir, \"jupyter_server_config.json\")\n                    self.identity_provider.hashed_password = self.settings[\n                        \"password\"\n                    ] = set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={\"error\": \"Invalid credentials\"})\n                return\n\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get(\"cookie_options\", {})\n        cookie_options.setdefault(\"httponly\", True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get(\"secure_cookie\", handler.request.protocol == \"https\"):\n            cookie_options.setdefault(\"secure\", True)\n        cookie_options.setdefault(\"path\", handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile(r\"token\\s+(.+)\", re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument(\"token\", \"\")\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get(\"Authorization\", \"\"))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if getattr(handler, \"_user_id\", None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.current_user  # noqa\n        return getattr(handler, \"_token_authenticated\", False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, \"_user_id\", None):\n            return handler._user_id\n        token_user_id = cls.get_user_token(handler)\n        cookie_user_id = cls.get_user_cookie(handler)\n        # prefer token to cookie if both given,\n        # because token is always explicit\n        user_id = token_user_id or cookie_user_id\n        if token_user_id:\n            # if token-authenticated, persist user_id in cookie\n            # if it hasn't already been stored there\n            if user_id != cookie_user_id:\n                cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = \"anonymous\"\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_cookie(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        get_secure_cookie_kwargs = handler.settings.get(\"get_secure_cookie_kwargs\", {})\n        user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs)\n        if user_id:\n            user_id = user_id.decode()\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\n                \"Accepting token-authenticated connection from %s\",\n                handler.request.remote_ip,\n            )\n            authenticated = True\n\n        if authenticated:\n            # token does not correspond to user-id,\n            # which is stored in a cookie.\n            # still check the cookie for the user id\n            user_id = cls.get_user_cookie(handler)\n            if user_id is None:\n                # no cookie, generate new random user_id\n                user_id = uuid.uuid4().hex\n                handler.log.info(\n                    f\"Generating new user_id for token-authenticated request: {user_id}\"\n                )\n            return user_id\n        else:\n            return None\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(f\"{warning} and not using encryption. This is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(\n                    f\"{warning} and not using authentication. \"\n                    \"This is highly insecure and not recommended.\"\n                )\n        elif not app.password and not app.token:\n            app.log.warning(\n                \"All authentication is disabled.\"\n                \"  Anyone who can connect to this server will be able to run code.\"\n            )\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return settings.get(\"password\", \"\")\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n\n        return bool(cls.password_from_settings(settings) or settings.get(\"token\"))\n\n\n# deprecated import, so deprecated implementations get the Legacy class instead\nLoginHandler = LegacyLoginHandler\n", "code_before": "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\nimport os\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nfrom tornado.escape import url_escape\n\nfrom ..base.handlers import JupyterHandler\nfrom .security import passwd_check, set_password\n\n\nclass LoginFormHandler(JupyterHandler):\n    \"\"\"The basic tornado login handler\n\n    accepts login form, passed to IdentityProvider.process_login_form.\n    \"\"\"\n\n    def _render(self, message=None):\n        \"\"\"Render the login form.\"\"\"\n        self.write(\n            self.render_template(\n                \"login.html\",\n                next=url_escape(self.get_argument(\"next\", default=self.base_url)),\n                message=message,\n            )\n        )\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        # protect chrome users from mishandling unescaped backslashes.\n        # \\ is not valid in urls, but some browsers treat it as /\n        # instead of %5C, causing `\\\\` to behave as `//`\n        url = url.replace(\"\\\\\", \"%5C\")\n        parsed = urlparse(url)\n        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if parsed.netloc:\n                # if full URL, run our cross-origin check:\n                origin = f\"{parsed.scheme}://{parsed.netloc}\"\n                origin = origin.lower()\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(re.match(self.allow_origin_pat, origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        \"\"\"Get the login form.\"\"\"\n        if self.current_user:\n            next_url = self.get_argument(\"next\", default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    def post(self):\n        \"\"\"Post a login.\"\"\"\n        user = self.current_user = self.identity_provider.process_login_form(self)\n        if user is None:\n            self.set_status(401)\n            self._render(message={\"error\": \"Invalid credentials\"})\n            return\n\n        self.log.info(f\"User {user.username} logged in.\")\n        self.identity_provider.set_login_cookie(self, user)\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n\nclass LegacyLoginHandler(LoginFormHandler):\n    \"\"\"Legacy LoginHandler, implementing most custom auth configuration.\n\n    Deprecated in jupyter-server 2.0.\n    Login configuration has moved to IdentityProvider.\n    \"\"\"\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def passwd_check(self, a, b):\n        \"\"\"Check a passwd.\"\"\"\n        return passwd_check(a, b)\n\n    def post(self):\n        \"\"\"Post a login form.\"\"\"\n        typed_password = self.get_argument(\"password\", default=\"\")\n        new_password = self.get_argument(\"new_password\", default=\"\")\n\n        if self.get_login_available(self.settings):\n            if self.passwd_check(self.hashed_password, typed_password) and not new_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n                if new_password and getattr(self.identity_provider, \"allow_password_change\", False):\n                    config_dir = self.settings.get(\"config_dir\", \"\")\n                    config_file = os.path.join(config_dir, \"jupyter_server_config.json\")\n                    self.identity_provider.hashed_password = self.settings[\n                        \"password\"\n                    ] = set_password(new_password, config_file=config_file)\n                    self.log.info(\"Wrote hashed password to %s\" % config_file)\n            else:\n                self.set_status(401)\n                self._render(message={\"error\": \"Invalid credentials\"})\n                return\n\n        next_url = self.get_argument(\"next\", default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get(\"cookie_options\", {})\n        cookie_options.setdefault(\"httponly\", True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get(\"secure_cookie\", handler.request.protocol == \"https\"):\n            cookie_options.setdefault(\"secure\", True)\n        cookie_options.setdefault(\"path\", handler.base_url)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile(r\"token\\s+(.+)\", re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument(\"token\", \"\")\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get(\"Authorization\", \"\"))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return not cls.is_token_authenticated(handler)\n\n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if getattr(handler, \"_user_id\", None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.current_user  # noqa\n        return getattr(handler, \"_token_authenticated\", False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, \"_user_id\", None):\n            return handler._user_id\n        token_user_id = cls.get_user_token(handler)\n        cookie_user_id = cls.get_user_cookie(handler)\n        # prefer token to cookie if both given,\n        # because token is always explicit\n        user_id = token_user_id or cookie_user_id\n        if token_user_id:\n            # if token-authenticated, persist user_id in cookie\n            # if it hasn't already been stored there\n            if user_id != cookie_user_id:\n                cls.set_login_cookie(handler, user_id)\n            # Record that the current request has been authenticated with a token.\n            # Used in is_token_authenticated above.\n            handler._token_authenticated = True\n\n        if user_id is None:\n            # If an invalid cookie was sent, clear it to prevent unnecessary\n            # extra warnings. But don't do this on a request with *no* cookie,\n            # because that can erroneously log you out (see gh-3365)\n            if handler.get_cookie(handler.cookie_name) is not None:\n                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)\n                handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = \"anonymous\"\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_cookie(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        get_secure_cookie_kwargs = handler.settings.get(\"get_secure_cookie_kwargs\", {})\n        user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs)\n        if user_id:\n            user_id = user_id.decode()\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\n                \"Accepting token-authenticated connection from %s\",\n                handler.request.remote_ip,\n            )\n            authenticated = True\n\n        if authenticated:\n            # token does not correspond to user-id,\n            # which is stored in a cookie.\n            # still check the cookie for the user id\n            user_id = cls.get_user_cookie(handler)\n            if user_id is None:\n                # no cookie, generate new random user_id\n                user_id = uuid.uuid4().hex\n                handler.log.info(\n                    f\"Generating new user_id for token-authenticated request: {user_id}\"\n                )\n            return user_id\n        else:\n            return None\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        if not app.ip:\n            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(f\"{warning} and not using encryption. This is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(\n                    f\"{warning} and not using authentication. \"\n                    \"This is highly insecure and not recommended.\"\n                )\n        elif not app.password and not app.token:\n            app.log.warning(\n                \"All authentication is disabled.\"\n                \"  Anyone who can connect to this server will be able to run code.\"\n            )\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n        return settings.get(\"password\", \"\")\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"DEPRECATED in 2.0, use IdentityProvider API\"\"\"\n\n        return bool(cls.password_from_settings(settings) or settings.get(\"token\"))\n\n\n# deprecated import, so deprecated implementations get the Legacy class instead\nLoginHandler = LegacyLoginHandler\n", "patch": "@@ -41,12 +41,25 @@ def _redirect_safe(self, url, default=None):\n         # \\ is not valid in urls, but some browsers treat it as /\n         # instead of %5C, causing `\\\\` to behave as `//`\n         url = url.replace(\"\\\\\", \"%5C\")\n+        # urllib and browsers interpret extra '/' in the scheme separator (`scheme:///host/path`)\n+        # differently.\n+        # urllib gives scheme=scheme, netloc='', path='/host/path', while\n+        # browsers get scheme=scheme, netloc='host', path='/path'\n+        # so make sure ':///*' collapses to '://' by splitting and stripping any additional leading slash\n+        # don't allow any kind of `:/` shenanigans by splitting on ':' only\n+        # and replacing `:/*` with exactly `://`\n+        if \":\" in url:\n+            scheme, _, rest = url.partition(\":\")\n+            url = f\"{scheme}://{rest.lstrip('/')}\"\n         parsed = urlparse(url)\n-        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):\n+        # full url may be `//host/path` (empty scheme == same scheme as request)\n+        # or `https://host/path`\n+        # or even `https:///host/path` (invalid, but accepted and ambiguously interpreted)\n+        if (parsed.scheme or parsed.netloc) or not (parsed.path + \"/\").startswith(self.base_url):\n             # require that next_url be absolute path within our path\n             allow = False\n             # OR pass our cross-origin check\n-            if parsed.netloc:\n+            if parsed.scheme or parsed.netloc:\n                 # if full URL, run our cross-origin check:\n                 origin = f\"{parsed.scheme}://{parsed.netloc}\"\n                 origin = origin.lower()", "file_path": "files/2023_8/113", "file_language": "py", "file_name": "jupyter_server/auth/login.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/jupyter-server/jupyter_server/raw/290362593b2ffb23c59f8114d76f77875de4b925/tests%2Fauth%2Ftest_login.py", "code": "\"\"\"Tests for login redirects\"\"\"\nimport json\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import parse_cookie, url_concat\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(\n    jp_serverapp,\n    http_server_client,\n    jp_base_url,\n    login_headers,\n    next=\"/\",\n    password=None,\n    new_password=None,\n):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    form = {\"_xsrf\": cookies.get(\"_xsrf\")}\n    if password is None:\n        password = jp_serverapp.identity_provider.token\n    if password:\n        form[\"password\"] = password\n    if new_password:\n        form[\"new_password\"] = new_password\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(form),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        assert e.response is not None\n        resp = e.response\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n    return resp\n\n\n@pytest.fixture\ndef login_headers():\n    \"\"\"Extra headers to pass to login\n\n    Fixture so it can be overridden\n    \"\"\"\n    return {}\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url, login_headers):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url, login_headers)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n        \"https:///a%40b/extra/slash\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    resp = await login(bad_next)\n    url = resp.headers[\"Location\"]\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    resp = await login(next=expected)\n    actual = resp.headers[\"Location\"]\n    assert actual == expected\n\n\nasync def test_login_cookie(login, jp_serverapp, jp_fetch, login_headers):\n    resp = await login()\n    assert \"Set-Cookie\" in resp.headers\n    cookie = resp.headers[\"Set-Cookie\"]\n    headers = {\"Cookie\": cookie}\n    headers.update(login_headers)\n    id_resp = await jp_fetch(\"/api/me\", headers=headers)\n    assert id_resp.code == 200\n    model = json.loads(id_resp.body.decode(\"utf8\"))\n    assert model[\"identity\"][\"username\"]\n    with pytest.raises(HTTPClientError) as exc:\n        resp = await login(password=\"incorrect\")\n    assert exc.value.code == 401\n\n\n@pytest.mark.parametrize(\"allow_password_change\", [True, False])\nasync def test_change_password(login, jp_serverapp, jp_base_url, jp_fetch, allow_password_change):\n    new_password = \"super-new-pass\"\n    jp_serverapp.identity_provider.allow_password_change = allow_password_change\n    resp = await login(new_password=new_password)\n\n    # second request\n    if allow_password_change:\n        resp = await login(password=new_password)\n        assert resp.code == 302\n    else:\n        with pytest.raises(HTTPClientError) as exc_info:\n            resp = await login(password=new_password)\n        assert exc_info.value.code == 401\n\n\nasync def test_logout(jp_serverapp, login, http_server_client, jp_base_url):\n    jp_serverapp.identity_provider.cookie_name = \"test-cookie\"\n    expected = jp_base_url\n    resp = await login(next=jp_base_url)\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert cookies.get(\"test-cookie\")\n\n    resp = await http_server_client.fetch(jp_base_url + \"logout\", headers={\"Cookie\": cookie_header})\n    assert resp.code == 200\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert not cookies.get(\"test-cookie\")\n    assert \"Successfully logged out\" in resp.body.decode(\"utf8\")\n\n\nasync def test_token_cookie_user_id(jp_serverapp, jp_fetch):\n    token = jp_serverapp.identity_provider.token\n\n    # first request with token, sets cookie with user-id\n    resp = await jp_fetch(\"/\")\n    assert resp.code == 200\n    set_cookie = resp.headers[\"set-cookie\"]\n    headers = {\"Cookie\": set_cookie}\n\n    # subsequent requests with cookie and no token\n    # receive same user-id\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id = json.loads(resp.body.decode(\"utf8\"))\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id2 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] == user_id2[\"identity\"]\n\n    # new request, just token -> new user_id\n    resp = await jp_fetch(\"/api/me\")\n    user_id3 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] != user_id3[\"identity\"]\n", "code_before": "\"\"\"Tests for login redirects\"\"\"\nimport json\nfrom functools import partial\nfrom urllib.parse import urlencode\n\nimport pytest\nfrom tornado.httpclient import HTTPClientError\nfrom tornado.httputil import parse_cookie, url_concat\n\nfrom jupyter_server.utils import url_path_join\n\n\n# override default config to ensure a non-empty base url is used\n@pytest.fixture\ndef jp_base_url():\n    return \"/a%40b/\"\n\n\n@pytest.fixture\ndef jp_server_config(jp_base_url):\n    return {\n        \"ServerApp\": {\n            \"base_url\": jp_base_url,\n        },\n    }\n\n\nasync def _login(\n    jp_serverapp,\n    http_server_client,\n    jp_base_url,\n    login_headers,\n    next=\"/\",\n    password=None,\n    new_password=None,\n):\n    # first: request login page with no creds\n    login_url = url_path_join(jp_base_url, \"login\")\n    first = await http_server_client.fetch(login_url)\n    cookie_header = first.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    form = {\"_xsrf\": cookies.get(\"_xsrf\")}\n    if password is None:\n        password = jp_serverapp.identity_provider.token\n    if password:\n        form[\"password\"] = password\n    if new_password:\n        form[\"new_password\"] = new_password\n\n    # second, submit login form with credentials\n    try:\n        resp = await http_server_client.fetch(\n            url_concat(login_url, {\"next\": next}),\n            method=\"POST\",\n            body=urlencode(form),\n            headers={\"Cookie\": cookie_header},\n            follow_redirects=False,\n        )\n    except HTTPClientError as e:\n        if e.code != 302:\n            raise\n        assert e.response is not None\n        resp = e.response\n    else:\n        assert resp.code == 302, \"Should have returned a redirect!\"\n    return resp\n\n\n@pytest.fixture\ndef login_headers():\n    \"\"\"Extra headers to pass to login\n\n    Fixture so it can be overridden\n    \"\"\"\n    return {}\n\n\n@pytest.fixture\ndef login(jp_serverapp, http_server_client, jp_base_url, login_headers):\n    \"\"\"Fixture to return a function to login to a Jupyter server\n\n    by submitting the login page form\n    \"\"\"\n    yield partial(_login, jp_serverapp, http_server_client, jp_base_url, login_headers)\n\n\n@pytest.mark.parametrize(\n    \"bad_next\",\n    (\n        r\"\\\\tree\",\n        \"//some-host\",\n        \"//host{base_url}tree\",\n        \"https://google.com\",\n        \"/absolute/not/base_url\",\n    ),\n)\nasync def test_next_bad(login, jp_base_url, bad_next):\n    bad_next = bad_next.format(base_url=jp_base_url)\n    resp = await login(bad_next)\n    url = resp.headers[\"Location\"]\n    assert url == jp_base_url\n\n\n@pytest.mark.parametrize(\n    \"next_path\",\n    (\n        \"tree/\",\n        \"//{base_url}tree\",\n        \"notebooks/notebook.ipynb\",\n        \"tree//something\",\n    ),\n)\nasync def test_next_ok(login, jp_base_url, next_path):\n    next_path = next_path.format(base_url=jp_base_url)\n    expected = jp_base_url + next_path\n    resp = await login(next=expected)\n    actual = resp.headers[\"Location\"]\n    assert actual == expected\n\n\nasync def test_login_cookie(login, jp_serverapp, jp_fetch, login_headers):\n    resp = await login()\n    assert \"Set-Cookie\" in resp.headers\n    cookie = resp.headers[\"Set-Cookie\"]\n    headers = {\"Cookie\": cookie}\n    headers.update(login_headers)\n    id_resp = await jp_fetch(\"/api/me\", headers=headers)\n    assert id_resp.code == 200\n    model = json.loads(id_resp.body.decode(\"utf8\"))\n    assert model[\"identity\"][\"username\"]\n    with pytest.raises(HTTPClientError) as exc:\n        resp = await login(password=\"incorrect\")\n    assert exc.value.code == 401\n\n\n@pytest.mark.parametrize(\"allow_password_change\", [True, False])\nasync def test_change_password(login, jp_serverapp, jp_base_url, jp_fetch, allow_password_change):\n    new_password = \"super-new-pass\"\n    jp_serverapp.identity_provider.allow_password_change = allow_password_change\n    resp = await login(new_password=new_password)\n\n    # second request\n    if allow_password_change:\n        resp = await login(password=new_password)\n        assert resp.code == 302\n    else:\n        with pytest.raises(HTTPClientError) as exc_info:\n            resp = await login(password=new_password)\n        assert exc_info.value.code == 401\n\n\nasync def test_logout(jp_serverapp, login, http_server_client, jp_base_url):\n    jp_serverapp.identity_provider.cookie_name = \"test-cookie\"\n    expected = jp_base_url\n    resp = await login(next=jp_base_url)\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert cookies.get(\"test-cookie\")\n\n    resp = await http_server_client.fetch(jp_base_url + \"logout\", headers={\"Cookie\": cookie_header})\n    assert resp.code == 200\n    cookie_header = resp.headers[\"Set-Cookie\"]\n    cookies = parse_cookie(cookie_header)\n    assert not cookies.get(\"test-cookie\")\n    assert \"Successfully logged out\" in resp.body.decode(\"utf8\")\n\n\nasync def test_token_cookie_user_id(jp_serverapp, jp_fetch):\n    token = jp_serverapp.identity_provider.token\n\n    # first request with token, sets cookie with user-id\n    resp = await jp_fetch(\"/\")\n    assert resp.code == 200\n    set_cookie = resp.headers[\"set-cookie\"]\n    headers = {\"Cookie\": set_cookie}\n\n    # subsequent requests with cookie and no token\n    # receive same user-id\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id = json.loads(resp.body.decode(\"utf8\"))\n    resp = await jp_fetch(\"/api/me\", headers=headers)\n    user_id2 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] == user_id2[\"identity\"]\n\n    # new request, just token -> new user_id\n    resp = await jp_fetch(\"/api/me\")\n    user_id3 = json.loads(resp.body.decode(\"utf8\"))\n    assert user_id[\"identity\"] != user_id3[\"identity\"]\n", "patch": "@@ -92,6 +92,7 @@ def login(jp_serverapp, http_server_client, jp_base_url, login_headers):\n         \"//host{base_url}tree\",\n         \"https://google.com\",\n         \"/absolute/not/base_url\",\n+        \"https:///a%40b/extra/slash\",\n     ),\n )\n async def test_next_bad(login, jp_base_url, bad_next):", "file_path": "files/2023_8/114", "file_language": "py", "file_name": "tests/auth/test_login.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
