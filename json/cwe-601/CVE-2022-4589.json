{"index": 10037, "cve_id": "CVE-2022-4589", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "A vulnerability has been found in cyface Terms and Conditions Module up to 2.0.9 and classified as problematic. Affected by this vulnerability is the function returnTo of the file termsandconditions/views.py. The manipulation leads to open redirect. The attack can be launched remotely. Upgrading to version 2.0.10 is able to address this issue. The name of the patch is 03396a1c2e0af95e12a45c5faef7e47a4b513e1a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216175.", "cvss": "6.1", "publish_date": "December 17, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "03396a1c2e0af95e12a45c5faef7e47a4b513e1a", "commit_message": "Fix open redirect vulnerability", "commit_date": "2022-06-23T12:50:22Z", "project": "cyface/django-termsandconditions", "url": "https://api.github.com/repos/cyface/django-termsandconditions/commits/03396a1c2e0af95e12a45c5faef7e47a4b513e1a", "html_url": "https://github.com/cyface/django-termsandconditions/commit/03396a1c2e0af95e12a45c5faef7e47a4b513e1a", "windows_before": [{"commit_id": "c131a1b1daab533ece466f12d79a9ff903c9cacc", "commit_date": "Wed Jun 22 21:59:14 2022 +0000", "commit_message": "Poetry dependency update.", "files_name": ["poetry.lock"]}, {"commit_id": "cc239f34dc97a3048cadf13ff8e1b16988af4544", "commit_date": "Wed Jun 22 21:54:24 2022 +0000", "commit_message": "Adding superuser setup to gitpod", "files_name": [".gitpod.yml"]}, {"commit_id": "63f4ae2f7120935b2cea2704763c9820cc0c4281", "commit_date": "Wed Jun 22 21:54:01 2022 +0000", "commit_message": "Adding DEFAULT_AUTO_FIELD to demo project.", "files_name": ["termsandconditions_demo/settings.py"]}, {"commit_id": "87d9cc48272e9c77d4a0ffb8bd1ef043fbcaab37", "commit_date": "Wed Jun 22 21:31:44 2022 +0000", "commit_message": "Readme Update", "files_name": ["README.md"]}, {"commit_id": "f60955d5669b60a9c43a30091e4c5cbe4d5b11d9", "commit_date": "Wed Jun 22 21:29:17 2022 +0000", "commit_message": "Adding poetry config", "files_name": [".gitpod.yml", "poetry.toml"]}, {"commit_id": "d73aad2cabd387236fb22f08cc1fd4b92edff1b7", "commit_date": "Wed Jun 22 21:19:49 2022 +0000", "commit_message": "poetry config", "files_name": ["pyproject.toml"]}, {"commit_id": "be82a45eaed60d2d2a708b54b510652f7116139b", "commit_date": "Wed Jun 22 21:12:12 2022 +0000", "commit_message": "jQuery update for demo app", "files_name": ["pyproject.toml", "termsandconditions_demo/templates/base.html"]}, {"commit_id": "a796b2905eb21bf9eb4409cb2ea779958c7a2e6b", "commit_date": "Wed Jun 22 20:32:27 2022 +0000", "commit_message": "Adding GitPod Configuration.", "files_name": [".gitpod.yml"]}, {"commit_id": "0a61134ee2d9f037584db156c7070f99ccef8b03", "commit_date": "Fri Feb 11 13:11:57 2022 +0000", "commit_message": "Bump poetry from 1.1.12 to 1.1.13", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "0962418d63a487dcc2b7a9e9faf2e18bd15845a9", "commit_date": "Mon Apr 11 12:05:46 2022 +0000", "commit_message": "Bump django from 3.2.12 to 3.2.13", "files_name": ["poetry.lock"]}, {"commit_id": "69371be89c5d6c180a08742bb1592a003aee9e28", "commit_date": "Tue Feb 1 12:03:25 2022 +0000", "commit_message": "Bump django from 3.2.11 to 3.2.12", "files_name": ["poetry.lock"]}, {"commit_id": "8c7d5bd2cb7b091015cec3ec4974130cf95b6c66", "commit_date": "Tue Jan 4 14:41:04 2022 +0000", "commit_message": "Bump poetry from 1.1.11 to 1.1.12", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "1dfccdf8770576cf300fb390ac0a9806e961d0b5", "commit_date": "Tue Jan 4 14:38:46 2022 +0000", "commit_message": "Bump coverage from 6.1.1 to 6.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "8342f0c72430ad0818e843a92ec7ad6866bc1d5d", "commit_date": "Tue Jan 4 12:02:32 2022 +0000", "commit_message": "Bump django from 3.2.9 to 3.2.11", "files_name": ["poetry.lock"]}, {"commit_id": "cc98bb0535b1b3d563e5f8f10cc52a24ae664790", "commit_date": "Fri Nov 26 12:01:50 2021 +0000", "commit_message": "Bump pylint from 2.11.1 to 2.12.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "5a14ee1271542bc0d4793db1c1ab307ce5500d00", "commit_date": "Mon Nov 1 13:36:54 2021 +0000", "commit_message": "Bump django from 3.2.8 to 3.2.9", "files_name": ["poetry.lock"]}, {"commit_id": "0760a797573f01a01cb70e6f463592a85cf48be5", "commit_date": "Mon Nov 1 12:02:07 2021 +0000", "commit_message": "Bump coverage from 6.0.1 to 6.1.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "5cb305367745d1005f28e12e1dcc4f76a18afc26", "commit_date": "Thu Oct 7 09:07:40 2021 -0600", "commit_message": "Version 2.0.9", "files_name": ["pyproject.toml"]}, {"commit_id": "0a0f7ac5ded705d4083a0ffa0db4909557412d04", "commit_date": "Tue Oct 5 08:52:24 2021 +0200", "commit_message": "Fix an open redirect vulnerability", "files_name": ["termsandconditions/tests.py", "termsandconditions/views.py"]}, {"commit_id": "0ccdfd70ef7d601e1361da1fcb36c622d1722cd4", "commit_date": "Thu Oct 7 12:02:13 2021 +0000", "commit_message": "Bump coverage from 6.0 to 6.0.1", "files_name": ["poetry.lock"]}, {"commit_id": "1f10b09e75225f927454dcaa77e6100e8ebd8b28", "commit_date": "Tue Oct 5 12:02:37 2021 +0000", "commit_message": "Bump django from 3.2.7 to 3.2.8", "files_name": ["poetry.lock"]}, {"commit_id": "752914848d2ebc05d7e4e617bfea57cbbe35192d", "commit_date": "Tue Oct 5 12:02:21 2021 +0000", "commit_message": "Bump poetry from 1.1.10 to 1.1.11", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "5852f5c0075ad9b1819c1dbad9a5810e19da881d", "commit_date": "Mon Oct 4 07:58:45 2021 -0600", "commit_message": "coverage 6.0", "files_name": ["poetry.lock"]}, {"commit_id": "c51f21878a44530a16d07207e561359e0e5e63f7", "commit_date": "Mon Oct 4 07:50:58 2021 -0600", "commit_message": "coverage 6.0", "files_name": ["pyproject.toml"]}, {"commit_id": "03283e57cc51c39c19fb0db7fa955efa0c43bdaf", "commit_date": "Mon Oct 4 13:29:30 2021 +0000", "commit_message": "Bump poetry from 1.1.8 to 1.1.10", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "4c58a38895255609c3ee49f325b8a8cdf0f09df2", "commit_date": "Mon Oct 4 07:29:12 2021 -0600", "commit_message": "Adding python 3.9", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "6814beb089f7fbe8e674f817ff74407574f607c0", "commit_date": "Fri Sep 17 12:02:08 2021 +0000", "commit_message": "Bump pylint from 2.10.2 to 2.11.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "b5137b4d362da8468a5d958dc1bf9ba32931857b", "commit_date": "Wed Sep 1 12:02:11 2021 +0000", "commit_message": "Bump django from 3.2.6 to 3.2.7", "files_name": ["poetry.lock"]}, {"commit_id": "b70655698589b5ad4781e1a5a7f2d99213b37aa5", "commit_date": "Mon Aug 23 12:02:23 2021 +0000", "commit_message": "Bump pylint from 2.9.6 to 2.10.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "622876b4e1a93959ed9d7b233f6f2e51be3f2378", "commit_date": "Fri Aug 20 12:02:22 2021 +0000", "commit_message": "Bump poetry from 1.1.7 to 1.1.8", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "6f825517dc807c8838500f832a74bddddf572deb", "commit_date": "Mon Aug 2 12:02:19 2021 +0000", "commit_message": "Bump django from 3.2.5 to 3.2.6", "files_name": ["poetry.lock"]}, {"commit_id": "7c39113b1004002de512cb398cfebe910b5d4a0c", "commit_date": "Thu Jul 29 12:01:46 2021 +0000", "commit_message": "Bump pylint from 2.9.3 to 2.9.6", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "6d0c0d33bd52bcf3de1e15b422b8478be7f330fd", "commit_date": "Fri Jul 2 12:02:17 2021 +0000", "commit_message": "Bump pylint from 2.9.2 to 2.9.3", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "e2d0772640e3b16c2b40e429821d98fa163538ab", "commit_date": "Thu Jul 1 12:01:58 2021 +0000", "commit_message": "Bump pylint from 2.9.1 to 2.9.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "e14c1bed1f569c58fd0445025b6c97abb95e98a3", "commit_date": "Thu Jul 1 12:02:18 2021 +0000", "commit_message": "Bump django from 3.2.4 to 3.2.5", "files_name": ["poetry.lock"]}, {"commit_id": "9afc3502fe17765e6c52b306f2e54d5e56e288b8", "commit_date": "Wed Jun 30 12:15:28 2021 +0000", "commit_message": "Bump django from 3.2.1 to 3.2.4", "files_name": ["poetry.lock"]}, {"commit_id": "060e81dfed9eee905c96f5536205e91d68ebfa4b", "commit_date": "Wed Jun 30 12:15:55 2021 +0000", "commit_message": "Bump poetry from 1.1.6 to 1.1.7", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "b424776e0d37c76ffc7c2974ed89b25af2e27f54", "commit_date": "Wed Jun 30 12:02:07 2021 +0000", "commit_message": "Bump pylint from 2.8.1 to 2.9.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "b14ff060448d05308647220c9a2ccb75ecd30aa0", "commit_date": "Tue May 4 12:01:45 2021 +0000", "commit_message": "Bump django from 3.2 to 3.2.1", "files_name": ["poetry.lock"]}, {"commit_id": "997ecf70030b6f7f98753aa7490e7af3d6436f34", "commit_date": "Mon Apr 26 12:01:45 2021 +0000", "commit_message": "Bump pylint from 2.7.4 to 2.8.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "3a5d6ac496f12f673bd52d5180133bce75617bcb", "commit_date": "Thu Apr 15 12:01:55 2021 +0000", "commit_message": "Bump poetry from 1.1.5 to 1.1.6", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "3c9473133c59ec9fce9a86847b642677e940314f", "commit_date": "Tue Apr 6 12:01:42 2021 +0000", "commit_message": "Bump django from 3.1.7 to 3.2", "files_name": ["poetry.lock"]}, {"commit_id": "aac297693f1def6b58ce3512fe0da7fbddf1bfe2", "commit_date": "Tue Mar 30 08:07:14 2021 -0600", "commit_message": "Merge pull request #196 from cyface/dependabot/pip/pylint-2.7.4", "files_name": ["b18af95114cd9e759d408eb7ea8f7489ae24d3b6 - Tue Mar 30 12:01:42 2021 +0000 : Bump pylint from 2.7.2 to 2.7.4", "poetry.lock", "pyproject.toml"]}, {"commit_id": "481173619fb3dba130fe36b579c0f1fe388ced74", "commit_date": "Sat Mar 27 07:49:43 2021 -0600", "commit_message": "rename to main", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "4684482005710fe316823a7e2987dfb414866bf7", "commit_date": "Thu Mar 4 09:44:08 2021 -0700", "commit_message": "Merge pull request #194 from cyface/dependabot/pip/poetry-1.1.5", "files_name": ["85e91f6f2bfc93b714ef91309f4b35c1538575e0 - Thu Mar 4 12:01:38 2021 +0000 : Bump poetry from 1.1.4 to 1.1.5", "poetry.lock", "pyproject.toml"]}, {"commit_id": "1f872ee06fab82a59394242b0d11adff934fe57a", "commit_date": "Mon Mar 1 07:15:41 2021 -0700", "commit_message": "Merge pull request #192 from cyface/dependabot/pip/coverage-5.5", "files_name": ["6142e836ef578d7584a9be7b89e666984f9e00f5 - Mon Mar 1 14:14:49 2021 +0000 : Bump coverage from 5.4 to 5.5", "poetry.lock", "pyproject.toml"]}, {"commit_id": "9d6253ef2cf15213bd46b500123a09530da304b8", "commit_date": "Mon Mar 1 07:13:17 2021 -0700", "commit_message": "Merge pull request #193 from cyface/dependabot/pip/pylint-2.7.2", "files_name": ["fa9de707f6654570ae27e7971bf1838836495b49 - Mon Mar 1 12:01:41 2021 +0000 : Bump pylint from 2.7.1 to 2.7.2", "poetry.lock", "pyproject.toml"]}, {"commit_id": "8063e08f4ab8b1e7c77da6d0d56d46f0873b67af", "commit_date": "Wed Feb 24 05:31:34 2021 -0700", "commit_message": "Merge pull request #191 from cyface/dependabot/pip/pylint-2.7.1", "files_name": ["5f01c7d597d835d4357c7b06023328857d9c9dff - Wed Feb 24 12:01:34 2021 +0000 : Bump pylint from 2.7.0 to 2.7.1", "poetry.lock", "pyproject.toml"]}, {"commit_id": "7f16f16915649ed41f09f30f650162b4a0d070eb", "commit_date": "Mon Feb 22 07:10:57 2021 -0700", "commit_message": "Merge pull request #190 from cyface/dependabot/pip/pylint-2.7.0", "files_name": ["f81cf1442f0d7d213ed84d880c33b5c40eae1797 - Mon Feb 22 12:01:32 2021 +0000 : Bump pylint from 2.6.2 to 2.7.0", "poetry.lock", "pyproject.toml"]}, {"commit_id": "fbba218e8464fa671b3e287b2665c63aa7d66baa", "commit_date": "Fri Feb 19 07:03:57 2021 -0700", "commit_message": "Merge pull request #189 from cyface/dependabot/pip/django-3.1.7", "files_name": ["c4276e5582792e10b5c427f2e5ecf4a9fc02afd3 - Fri Feb 19 12:01:23 2021 +0000 : Bump django from 2.2.17 to 3.1.7", "poetry.lock"]}, {"commit_id": "d18805b817b3068be0747a84c4a5e1893bf8a8cf", "commit_date": "Tue Feb 16 09:37:27 2021 -0700", "commit_message": "Merge pull request #188 from cyface/dependabot/pip/pylint-2.6.2", "files_name": ["df2e9487e02c5920f4cfa4edf2077154d24697cd - Tue Feb 16 12:01:49 2021 +0000 : Bump pylint from 2.6.0 to 2.6.2", "poetry.lock", "pyproject.toml"]}, {"commit_id": "7e528ada08b1bc7b3a4070f84025328e79565965", "commit_date": "Wed Jan 27 09:43:09 2021 -0700", "commit_message": "Update pyproject.toml", "files_name": ["pyproject.toml"]}, {"commit_id": "8947dd93dbca370c1c2187b26c50aacccc9954a8", "commit_date": "Wed Jan 27 09:38:50 2021 -0700", "commit_message": "Updating requirements to be greater than 2.2.", "files_name": ["dist/django-termsandconditions-2.0.6.tar.gz", "dist/django-termsandconditions-2.0.7.tar.gz", "dist/django_termsandconditions-2.0.6-py3-none-any.whl", "dist/django_termsandconditions-2.0.7-py3-none-any.whl"]}], "windows_after": [{"commit_id": "6145d3fe9ba25ea712da0f9da09c0ab09a1b2bde", "commit_date": "Thu Jun 23 06:51:54 2022 -0600", "commit_message": "Delete .travis.yml", "files_name": [".travis.yml"]}, {"commit_id": "32c49024f8055f2a1c3b73bb39462a631aed881c", "commit_date": "Thu Jun 23 06:54:32 2022 -0600", "commit_message": "v2.0.10", "files_name": ["pyproject.toml"]}, {"commit_id": "a353c4ba96dff76c942948e97ec0aabb62068327", "commit_date": "Wed Aug 3 12:03:48 2022 +0000", "commit_message": "Bump django from 3.2.13 to 3.2.15", "files_name": ["poetry.lock"]}, {"commit_id": "ea0fa021b903e61cfa584a27ca68977c2082f365", "commit_date": "Fri Aug 12 13:34:49 2022 +0000", "commit_message": "Bump poetry from 1.1.13 to 1.1.14", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "a54fd68f6c95a54d1aa6bd6c83603c21268276c5", "commit_date": "Mon Aug 22 12:04:09 2022 +0000", "commit_message": "Bump poetry from 1.1.14 to 1.1.15", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "74d34babfdf5fcfa8e5f7bc9672542023382765b", "commit_date": "Tue Oct 4 12:06:55 2022 +0000", "commit_message": "Bump django from 3.2.15 to 3.2.16", "files_name": ["poetry.lock"]}, {"commit_id": "21231babbb998e30f1cfa5c22cc20bc670c8a2f2", "commit_date": "Sat Oct 15 14:34:13 2022 +0000", "commit_message": "Appending slash to slug for terms redirect.", "files_name": ["termsandconditions/pipeline.py"]}, {"commit_id": "5b319e40e1555ed1a2003eaf5b400e69592f5889", "commit_date": "Sat Oct 15 14:34:24 2022 +0000", "commit_message": "Adding test run config.", "files_name": [".run/Test All.run.xml"]}, {"commit_id": "6cabe13cf6039caf1588cb2ba93de6af6881ac39", "commit_date": "Sat Oct 15 08:41:41 2022 -0600", "commit_message": "version 2.10.11", "files_name": ["pyproject.toml"]}, {"commit_id": "04dec2fda6e344d0b3662280565ec5de7965acbb", "commit_date": "Wed Jan 4 19:35:09 2023 +0000", "commit_message": "codespaces config", "files_name": [".devcontainer/Dockerfile", ".devcontainer/devcontainer.json", ".devcontainer/docker-compose.yml"]}, {"commit_id": "8b0df88adc7e4d30bd774dd7691b55d3d543c22a", "commit_date": "Wed Jan 4 19:41:39 2023 +0000", "commit_message": "Update install poetry github action.", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "2720edf687c78c38f1cffe9111361ae2447ce1c5", "commit_date": "Wed Jan 4 19:43:06 2023 +0000", "commit_message": "Removing Python 3.6 from automated tests, since no longer available from GitHub runner.", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "7979159c96b4872a8c93cd736388116d36d73a68", "commit_date": "Wed Jan 4 19:52:15 2023 +0000", "commit_message": "Turning off python 3.6 in pyproject.toml since it is no longer supported (by github, or poetry, or by python).", "files_name": ["pyproject.toml"]}, {"commit_id": "c5d1edeae2bdd64cfe9e7c5eef25cb4519085be6", "commit_date": "Wed Jan 4 19:57:23 2023 +0000", "commit_message": "Turning off python 3.6 in pyproject.toml since it is no longer supported (by github, or poetry, or by python).", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "22a7f85c54dbe50d4ab85639cc2ea4c816201805", "commit_date": "Wed Jan 4 20:12:56 2023 +0000", "commit_message": "Github Codespaces config.", "files_name": [".devcontainer/Dockerfile", ".devcontainer/devcontainer.json"]}, {"commit_id": "5b12a1c421014016aaae82a3e2b58cd4d8ffcacc", "commit_date": "Wed Jan 4 20:24:32 2023 +0000", "commit_message": "Codespaces update.", "files_name": [".devcontainer/Dockerfile", ".devcontainer/devcontainer.json"]}, {"commit_id": "45deb83a9d0b9b54bc7f1cf99a0e04fcb5316377", "commit_date": "Mon Jan 9 12:03:08 2023 +0000", "commit_message": "Bump coverage from 6.5.0 to 7.0.4", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "f083c6f7beaadeb7619c7bec90720f042c122adb", "commit_date": "Mon Jan 9 16:31:15 2023 +0000", "commit_message": "Bump pylint from 2.15.9 to 2.15.10", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "a0d5928bef8dcade7f2dfa5c6426a45674df973a", "commit_date": "Tue Jan 17 08:48:03 2023 -0700", "commit_message": "update action versions", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "9bed94e38f93bee7fc6a99cb0cd01c1205b085bd", "commit_date": "Tue Jan 17 16:06:34 2023 +0000", "commit_message": "Bump coverage from 7.0.4 to 7.0.5", "files_name": ["poetry.lock"]}, {"commit_id": "040f60ac03b47be0d6727e9eefa2101c2c651ee5", "commit_date": "Tue Jan 17 15:29:47 2023 -0700", "commit_message": "Update GH Action Versions", "files_name": [".github/workflows/python-publish.yml"]}, {"commit_id": "5e8cb5b80cd369900f8de3c9f766d38a5048d119", "commit_date": "Tue Jan 17 22:22:18 2023 +0000", "commit_message": "Bump poetry from 1.3.1 to 1.3.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "504c5d6e32ad16daadaec3f09902669b2afbb94f", "commit_date": "Wed Jan 25 12:01:49 2023 +0000", "commit_message": "Bump coverage from 7.0.5 to 7.1.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "a47a9381af85e3b0d388b703f3a2cc880217d58a", "commit_date": "Thu Jan 26 08:39:38 2023 -0700", "commit_message": "Update pyproject.toml", "files_name": ["pyproject.toml"]}, {"commit_id": "129854bfb313d92745e54253e284419b726a353c", "commit_date": "Thu Jan 26 08:40:04 2023 -0700", "commit_message": "Update python-package.yml", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "083ecae310f95dcced98097b958c9ffcf4a9d4a6", "commit_date": "Thu Jan 26 08:40:43 2023 -0700", "commit_message": "Update python-publish.yml", "files_name": [".github/workflows/python-publish.yml"]}, {"commit_id": "aa068dccb594f2344fe8ade6598f376b10c9cc95", "commit_date": "Thu Jan 26 08:45:30 2023 -0700", "commit_message": "Update pyproject.toml", "files_name": ["pyproject.toml"]}, {"commit_id": "9f18722e9193ffc4e23789382241762cfe0d5a8e", "commit_date": "Thu Jan 26 08:50:03 2023 -0700", "commit_message": "Update python-package.yml", "files_name": [".github/workflows/python-package.yml"]}, {"commit_id": "ad9174146ded01d94c222af3563630fbad587133", "commit_date": "Tue Feb 14 12:58:33 2023 +0000", "commit_message": "Bump django from 3.2.16 to 3.2.18", "files_name": ["poetry.lock"]}, {"commit_id": "0dda00c92d916753aca92683304f8655219422a7", "commit_date": "Tue Feb 14 12:57:33 2023 +0000", "commit_message": "Bump pylint from 2.15.10 to 2.16.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "fd9b0a18ffb17b21c9dd7a9ecb16be6df4bc51b8", "commit_date": "Wed Feb 8 05:04:17 2023 +0000", "commit_message": "Bump cryptography from 39.0.0 to 39.0.1", "files_name": ["poetry.lock"]}, {"commit_id": "e8041ad89bad7c008737394caf626d90d36bc25a", "commit_date": "Tue Feb 14 14:31:53 2023 +0000", "commit_message": "Bump black from 20.8b1 to 23.1.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "0855fc2218704952c81dfb7f86b91dffc1c6c13d", "commit_date": "Tue Feb 28 12:58:13 2023 +0000", "commit_message": "Bump poetry from 1.3.2 to 1.4.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "ac7cca0b139a26cb1f96117336d52e338ed5b8f2", "commit_date": "Tue Feb 28 14:20:42 2023 +0000", "commit_message": "Bump coverage from 7.1.0 to 7.2.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "2dbcbfa891eb87f63016a29ec371871a459fe04e", "commit_date": "Fri Mar 3 12:57:15 2023 +0000", "commit_message": "Bump pylint from 2.16.2 to 2.16.3", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "a8c7bcb62d8f77a2efcaa1ddeea7cbd5931bc3d0", "commit_date": "Tue Mar 7 12:56:59 2023 +0000", "commit_message": "Bump pylint from 2.16.3 to 2.16.4", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "3eb340b52030fbc109ce83aab491a4530775ee6c", "commit_date": "Wed Mar 8 12:57:01 2023 +0000", "commit_message": "Bump pylint from 2.16.4 to 2.17.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "3cd4b91bb43be1883dfcc0a2c0bc621fba15a53a", "commit_date": "Mon Mar 20 12:57:44 2023 +0000", "commit_message": "Bump poetry from 1.4.0 to 1.4.1", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "c16453a4d3834485139110d833813199a13bee98", "commit_date": "Mon Mar 20 13:11:26 2023 +0000", "commit_message": "Bump coverage from 7.2.1 to 7.2.2", "files_name": ["poetry.lock"]}, {"commit_id": "cdd7cdd24153a4514216dca8b8a283a88efb0907", "commit_date": "Wed Mar 29 12:58:07 2023 +0000", "commit_message": "Bump black from 23.1.0 to 23.3.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "72be2ab78d5aa6dde74202ec6fbb3cabb260f45b", "commit_date": "Mon Apr 3 13:12:07 2023 +0000", "commit_message": "Bump pylint from 2.17.0 to 2.17.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "f427eedde701346904e2ecc524a75ebd5708afe1", "commit_date": "Fri Apr 21 22:40:25 2023 +0000", "commit_message": "Bump sqlparse from 0.4.3 to 0.4.4", "files_name": ["poetry.lock"]}, {"commit_id": "5bf85dbc152e00d94c23a0fe0a30129ea84cbc4f", "commit_date": "Tue Apr 25 12:56:58 2023 +0000", "commit_message": "Bump pylint from 2.17.2 to 2.17.3", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "eab68476f06eb6e929391a0e6e597a27ca0bd5b6", "commit_date": "Fri Apr 28 12:58:08 2023 +0000", "commit_message": "Bump coverage from 7.2.2 to 7.2.4", "files_name": ["poetry.lock"]}, {"commit_id": "2c2dac2e3dcb9c538e5704dff92293b893123cab", "commit_date": "Fri Apr 28 13:35:52 2023 +0000", "commit_message": "Bump poetry from 1.4.1 to 1.4.2", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "4ea040148f84b4e0de42a3657516b3265d89a0d4", "commit_date": "Thu May 4 12:57:01 2023 +0000", "commit_message": "Bump django from 3.2.18 to 3.2.19", "files_name": ["poetry.lock"]}, {"commit_id": "c46170bb397ab0e9c2b5f4c62645b9b69903fafa", "commit_date": "Mon May 1 12:57:43 2023 +0000", "commit_message": "Bump coverage from 7.2.4 to 7.2.5", "files_name": ["poetry.lock"]}, {"commit_id": "635d5fbc277798cbf8ac6fe4ab2c77670a36819a", "commit_date": "Mon May 8 12:58:22 2023 +0000", "commit_message": "Bump pylint from 2.17.3 to 2.17.4", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "afff2c9ea1c9b7ef2e8b959ada9e71d4222c0bba", "commit_date": "Fri May 19 12:58:08 2023 +0000", "commit_message": "Bump poetry from 1.4.2 to 1.5.0", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "09a14523b1f779558693774463ff5d6701d7c0d9", "commit_date": "Tue May 23 05:29:10 2023 +0000", "commit_message": "Bump requests from 2.28.1 to 2.31.0", "files_name": ["poetry.lock"]}, {"commit_id": "657da737224bc149142cfe6c623bce82b6c69d8f", "commit_date": "Fri Jun 2 20:14:48 2023 +0000", "commit_message": "Bump cryptography from 39.0.1 to 41.0.0", "files_name": ["poetry.lock"]}, {"commit_id": "e07f67f99d39bd55f45f430f081689a8f15e2c5e", "commit_date": "Thu Jun 15 12:47:20 2023 -0600", "commit_message": "Create .readthedocs.yaml", "files_name": [".readthedocs.yaml"]}, {"commit_id": "55851059a914d1e24fddbad29c68390a0140f08c", "commit_date": "Thu Jun 15 13:32:20 2023 -0600", "commit_message": "RTD Update", "files_name": [".gitignore", ".readthedocs.yaml", "docs/index.md", "docs/requirements.txt", "mkdocs.yml"]}, {"commit_id": "826885bf62df8cdf3e1d5f7278ca99b5e26fd7e3", "commit_date": "Thu Jun 15 13:35:43 2023 -0600", "commit_message": "Update .readthedocs.yaml", "files_name": [".readthedocs.yaml"]}, {"commit_id": "a8e5fe7fd2212e820fd2776de99dd2ced1702bde", "commit_date": "Thu Jun 15 15:12:27 2023 -0600", "commit_message": "Update .readthedocs.yaml", "files_name": [".readthedocs.yaml"]}, {"commit_id": "49b40e1beb1bbf3c58bcb21f22a6b295e6afe862", "commit_date": "Thu Jun 15 15:12:48 2023 -0600", "commit_message": "Update .readthedocs.yaml", "files_name": [".readthedocs.yaml"]}], "parents": [{"commit_id_before": "c131a1b1daab533ece466f12d79a9ff903c9cacc", "url_before": "https://api.github.com/repos/cyface/django-termsandconditions/commits/c131a1b1daab533ece466f12d79a9ff903c9cacc", "html_url_before": "https://github.com/cyface/django-termsandconditions/commit/c131a1b1daab533ece466f12d79a9ff903c9cacc"}], "details": [{"raw_url": "https://github.com/cyface/django-termsandconditions/raw/03396a1c2e0af95e12a45c5faef7e47a4b513e1a/termsandconditions%2Ftests.py", "code": "\"\"\"Unit Tests for the termsandconditions module\"\"\"\n\n# pylint: disable=R0904, C0103\nimport time\nfrom importlib import import_module\nimport logging\n\nfrom django.core import mail\nfrom django.core.cache import cache\nfrom django.http import HttpResponseRedirect\nfrom django.conf import settings\nfrom django.test import TestCase, RequestFactory\nfrom django.contrib.auth.models import User, ContentType, Permission\nfrom django.template import Context, Template\n\nfrom .models import TermsAndConditions, UserTermsAndConditions, DEFAULT_TERMS_SLUG\nfrom .pipeline import user_accept_terms\nfrom .templatetags.terms_tags import show_terms_if_not_agreed\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\n\n\nclass TermsAndConditionsTests(TestCase):\n    \"\"\"Tests Terms and Conditions Module\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        LOGGER.debug(\"Test Setup\")\n\n        self.su = User.objects.create_superuser(\"su\", \"su@example.com\", \"superstrong\")\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.user2 = User.objects.create_user(\n            \"user2\", \"user2@user2.com\", \"user2password\"\n        )\n        self.user3 = User.objects.create_user(\n            \"user3\", \"user3@user3.com\", \"user3password\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        self.terms2 = TermsAndConditions.objects.create(\n            id=2,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2012-01-05\",\n        )\n        self.terms3 = TermsAndConditions.objects.create(\n            id=3,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 1.5\",\n            version_number=1.5,\n            date_active=\"2012-01-01\",\n        )\n        self.terms4 = TermsAndConditions.objects.create(\n            id=4,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2100-01-01\",\n        )\n\n        # give user3 permission to skip T&Cs\n        content_type = ContentType.objects.get_for_model(type(self.user3))\n        self.skip_perm = Permission.objects.create(\n            content_type=content_type, name=\"Can skip T&Cs\", codename=\"can_skip_t&c\"\n        )\n        self.user3.user_permissions.add(self.skip_perm)\n\n    def tearDown(self):\n        \"\"\"Teardown for each test\"\"\"\n        LOGGER.debug(\"Test TearDown\")\n        User.objects.all().delete()\n        TermsAndConditions.objects.all().delete()\n        UserTermsAndConditions.objects.all().delete()\n\n    def test_social_redirect(self):\n        \"\"\"Test the agreed_to_terms redirect from social pipeline\"\"\"\n        LOGGER.debug(\"Test the social pipeline\")\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, HttpResponseRedirect)\n\n        # Accept the terms and try again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, dict)\n\n    def test_get_active_terms_list(self):\n        \"\"\"Test get list of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_list()\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_get_active_terms_not_agreed_to(self):\n        \"\"\"Test get T&Cs not agreed to\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user1)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_user_is_excluded(self):\n        \"\"\"Test user3 has perm which excludes them from having to accept T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user3)\n        self.assertEqual([], active_list)\n\n    def test_superuser_is_not_implicitly_excluded(self):\n        \"\"\"Test su should have to accept T&Cs even if they are superuser but don't explicitly have the skip perm\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_cannot_skip(self):\n        \"\"\"Test su still has to accept even if they are explicitly given the skip perm\"\"\"\n        self.su.user_permissions.add(self.skip_perm)\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_excluded(self):\n        \"\"\"Test su doesn't have to accept with TERMS_EXCLUDE_SUPERUSERS set\"\"\"\n        with self.settings(TERMS_EXCLUDE_SUPERUSERS=True):\n            active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n            self.assertEqual([], active_list)\n\n    def test_get_active_terms_ids(self):\n        \"\"\"Test get ids of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_ids()\n        self.assertEqual(2, len(active_list))\n        self.assertEqual(active_list, [3, 2])\n\n    def test_terms_and_conditions_models(self):\n        \"\"\"Various tests of the TermsAndConditions Module\"\"\"\n\n        # Testing Direct Assignment of Acceptance\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms1)\n        UserTermsAndConditions.objects.create(user=self.user2, terms=self.terms3)\n\n        self.assertEquals(1.0, self.user1.userterms.get().terms.version_number)\n        self.assertEquals(1.5, self.user2.userterms.get().terms.version_number)\n\n        self.assertEquals(\"user1\", self.terms1.users.all()[0].get_username())\n\n        # Testing the get_active static method of TermsAndConditions\n        self.assertEquals(\n            2.0, TermsAndConditions.get_active(slug=\"site-terms\").version_number\n        )\n        self.assertEquals(\n            1.5, TermsAndConditions.get_active(slug=\"contrib-terms\").version_number\n        )\n\n        # Testing the unicode method of TermsAndConditions\n        self.assertEquals(\n            \"site-terms-2.00\", str(TermsAndConditions.get_active(slug=\"site-terms\"))\n        )\n        self.assertEquals(\n            \"contrib-terms-1.50\",\n            str(TermsAndConditions.get_active(slug=\"contrib-terms\")),\n        )\n\n    def test_middleware_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if they are logged in, and decorator is on method\"\"\"\n\n        UserTermsAndConditions.objects.all().delete()\n\n        LOGGER.debug(\"Test user1 login for middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /secure/ after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/contrib-terms/?returnTo=/secure/\"\n        )\n\n    def test_terms_required_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if logged in, and decorator is on method\"\"\"\n\n        LOGGER.debug(\"Test /termsrequired/ pre login\")\n        not_logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            not_logged_in_response, \"/accounts/login/?next=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test user1 login\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /termsrequired/ after login\")\n        logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/?returnTo=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test no redirect for /termsrequired/ after accept\")\n        accepted_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/termsrequired/\"}, follow=True\n        )\n        self.assertContains(accepted_response, \"Please Accept\")\n\n        LOGGER.debug(\"Test response after termsrequired accept\")\n        terms_required_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertContains(terms_required_response, \"Please Accept\")\n\n    def test_accept(self):\n        \"\"\"Validate that accepting terms works\"\"\"\n\n        LOGGER.debug(\"Test user1 login for accept\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/ get\")\n        accept_response = self.client.get(\"/terms/accept/\", follow=True)\n        self.assertContains(accept_response, \"Accept\")\n\n        LOGGER.debug(\"Test /terms/accept/ post\")\n        chained_terms_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(chained_terms_response, \"Contributor\")\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/1.5/ post\")\n        accept_version_response = self.client.get(\n            \"/terms/accept/contrib-terms/1.5/\", follow=True\n        )\n        self.assertContains(\n            accept_version_response, \"Contributor Terms and Conditions 1.5\"\n        )\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_version_post_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(accept_version_post_response, \"Secure\")\n\n    def _post_accept(self, return_to):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test user1 login for test_accept_redirect\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/site-terms/1/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": return_to}, follow=True\n        )\n        return accept_response\n\n    def test_accept_redirect_safe(self):\n        accept_response = self._post_accept(\"/secure/\")\n        self.assertRedirects(accept_response, \"/secure/\")\n\n    def test_accept_redirect_unsafe(self):\n        accept_response = self._post_accept(\"http://attacker/\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_2(self):\n        accept_response = self._post_accept(\"//attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_3(self):\n        accept_response = self._post_accept(\"///attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_4(self):\n        accept_response = self._post_accept(\"////attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_store_ip_address(self):\n        \"\"\"Test with IP address storage setting true (default)\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_store_ip_address_multiple(self):\n        \"\"\"Test storing IP address when it is a list\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\",\n            {\"terms\": 2, \"returnTo\": \"/secure/\"},\n            follow=True,\n            REMOTE_ADDR=\"0.0.0.0, 1.1.1.1\",\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_no_ip_address(self):\n        \"\"\"Test with IP address storage setting false\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        with self.settings(TERMS_STORE_IP_ADDRESS=False):\n            self.client.post(\n                \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n            )\n            user_terms = UserTermsAndConditions.objects.all()[0]\n            self.assertFalse(user_terms.ip_address)\n\n    def test_terms_upgrade(self):\n        \"\"\"Validate a user is prompted to accept terms again when new version comes out\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login pre upgrade\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertContains(logged_in_response, \"Contributor\")\n\n        # First, Accept Contributor Terms\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n\n        LOGGER.debug(\"Test upgrade terms\")\n        self.terms5 = TermsAndConditions.objects.create(\n            id=5,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Terms and Conditions2\",\n            version_number=2.5,\n            date_active=\"2012-02-05\",\n        )\n\n        LOGGER.debug(\"Test user1 is redirected when changing pages\")\n        post_upgrade_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            post_upgrade_response, \"/terms/accept/site-terms/?returnTo=/secure/\"\n        )\n\n    def test_no_middleware(self):\n        \"\"\"Test a secure page with the middleware excepting it\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login no middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/securetoo/\", follow=True)\n        self.assertContains(logged_in_response, \"SECOND\")\n\n        LOGGER.debug(\"Test startswith '/admin' pages not redirecting\")\n        admin_response = self.client.get(\"/admin\", follow=True)\n        self.assertContains(admin_response, \"administration\")\n\n    def test_anonymous_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions for Anonymous User\"\"\"\n        active_terms = TermsAndConditions.get_active_terms_list()\n\n        LOGGER.debug(\"Test /terms/ with anon\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in active_terms:\n            self.assertContains(root_response, terms.name)\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms with anon\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/contributor-terms/1.5 with anon\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n\n    def test_user_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions Page for Logged In User\"\"\"\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 2)\n\n        LOGGER.debug(\"Test /terms/ with user1\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n        self.assertContains(root_response, \"Sign Out\")\n\n        # Accept terms and check again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 1)\n        LOGGER.debug(\"Test /terms/ with user1 after accept\")\n        post_accept_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(post_accept_response, terms.text)\n        self.assertNotContains(post_accept_response, self.terms3.name)\n        self.assertContains(post_accept_response, \"Terms and Conditions\")\n        self.assertContains(post_accept_response, \"Sign Out\")\n\n        # Check by slug and version while logged in\n        LOGGER.debug(\"Test /terms/view/site-terms as user1\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms/1.5 as user1\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n        self.assertContains(version_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n    def test_user_pipeline(self):\n        \"\"\"Test the case of a user being partially created via the django-socialauth pipeline\"\"\"\n\n        LOGGER.debug(\"Test /terms/accept/ post for no user\")\n        no_user_response = self.client.post(\"/terms/accept/\", {\"terms\": 2}, follow=True)\n        self.assertContains(no_user_response, \"Home\")\n\n        user = {\"pk\": self.user1.id}\n        kwa = {\"user\": user}\n        partial_pipeline = {\"kwargs\": kwa}\n\n        engine = import_module(settings.SESSION_ENGINE)\n        store = engine.SessionStore()\n        store.save()\n        self.client.cookies[settings.SESSION_COOKIE_NAME] = store.session_key\n\n        session = self.client.session\n        session[\"partial_pipeline\"] = partial_pipeline\n        session.save()\n\n        self.assertTrue(\"partial_pipeline\" in self.client.session)\n\n        LOGGER.debug(\"Test /terms/accept/ post for pipeline user\")\n        pipeline_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/anon\"}, follow=True\n        )\n        self.assertContains(pipeline_response, \"Anon\")\n\n    def test_email_terms(self):\n        \"\"\"Test emailing terms and conditions\"\"\"\n        LOGGER.debug(\"Test /terms/email/\")\n        email_form_response = self.client.get(\"/terms/email/\", follow=True)\n        self.assertContains(email_form_response, \"Email\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_send_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"foo@foo.com\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertEqual(\n            len(mail.outbox), 1\n        )  # Check that there is one email in the test outbox\n        self.assertContains(email_send_response, \"Sent\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_fail_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"INVALID EMAIL ADDRESS\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertContains(email_fail_response, \"Invalid\")\n\n\nclass TermsAndConditionsTemplateTagsTestCase(TestCase):\n    \"\"\"Tests Tags for T&C\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.template_string_1 = (\n            \"{% load terms_tags %}\" \"{% show_terms_if_not_agreed %}\"\n        )\n        self.template_string_2 = (\n            \"{% load terms_tags %}\"\n            '{% show_terms_if_not_agreed slug=\"specific-terms\" %}'\n        )\n        self.template_string_3 = (\n            \"{% load terms_tags %}\" \"{% include terms.text|as_template %}\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        cache.clear()\n\n    def _make_context(self, url):\n        \"\"\"Build Up Context - Used in many tests\"\"\"\n        context = dict()\n        context[\"request\"] = RequestFactory()\n        context[\"request\"].user = self.user1\n        context[\"request\"].META = {\"PATH_INFO\": url}\n        return context\n\n    def render_template(self, string, context=None):\n        \"\"\"a helper method to render simplistic test templates\"\"\"\n        request = RequestFactory().get(\"/test\")\n        request.user = self.user1\n        request.context = context or {}\n        return Template(string).render(Context({\"request\": request}))\n\n    def test_show_terms_if_not_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag renders html code\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms if not agreed to\")\n        rendered = self.render_template(self.template_string_1)\n        terms = TermsAndConditions.get_active()\n        self.assertIn(terms.slug, rendered)\n\n    def test_not_show_terms_if_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag does not load if user agreed terms\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms once agreed to\")\n        terms = TermsAndConditions.get_active()\n        UserTermsAndConditions.objects.create(terms=terms, user=self.user1)\n        rendered = self.render_template(self.template_string_1)\n        self.assertNotIn(terms.slug, rendered)\n\n    def test_show_terms_if_not_agreed_on_protected_url_not_agreed(self):\n        \"\"\"Check terms on protected url if not agreed\"\"\"\n        context = self._make_context(\"/test\")\n        result = show_terms_if_not_agreed(context)\n        terms = TermsAndConditions.get_active(slug=DEFAULT_TERMS_SLUG)\n        self.assertEqual(result.get(\"not_agreed_terms\")[0], terms)\n\n    def test_show_terms_if_not_agreed_on_unprotected_url_not_agreed(self):\n        \"\"\"Check terms on unprotected url if not agreed\"\"\"\n        context = self._make_context(\"/\")\n        result = show_terms_if_not_agreed(context)\n        self.assertDictEqual(result, {\"not_agreed_terms\": False})\n\n    def test_as_template(self):\n        \"\"\"Test as_template template tag\"\"\"\n        terms = TermsAndConditions.get_active()\n        rendered = Template(self.template_string_3).render(Context({\"terms\": terms}))\n        self.assertIn(terms.text, rendered)\n", "code_before": "\"\"\"Unit Tests for the termsandconditions module\"\"\"\n\n# pylint: disable=R0904, C0103\nimport time\nfrom importlib import import_module\nimport logging\n\nfrom django.core import mail\nfrom django.core.cache import cache\nfrom django.http import HttpResponseRedirect\nfrom django.conf import settings\nfrom django.test import TestCase, RequestFactory\nfrom django.contrib.auth.models import User, ContentType, Permission\nfrom django.template import Context, Template\n\nfrom .models import TermsAndConditions, UserTermsAndConditions, DEFAULT_TERMS_SLUG\nfrom .pipeline import user_accept_terms\nfrom .templatetags.terms_tags import show_terms_if_not_agreed\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\n\n\nclass TermsAndConditionsTests(TestCase):\n    \"\"\"Tests Terms and Conditions Module\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        LOGGER.debug(\"Test Setup\")\n\n        self.su = User.objects.create_superuser(\"su\", \"su@example.com\", \"superstrong\")\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.user2 = User.objects.create_user(\n            \"user2\", \"user2@user2.com\", \"user2password\"\n        )\n        self.user3 = User.objects.create_user(\n            \"user3\", \"user3@user3.com\", \"user3password\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        self.terms2 = TermsAndConditions.objects.create(\n            id=2,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2012-01-05\",\n        )\n        self.terms3 = TermsAndConditions.objects.create(\n            id=3,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 1.5\",\n            version_number=1.5,\n            date_active=\"2012-01-01\",\n        )\n        self.terms4 = TermsAndConditions.objects.create(\n            id=4,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2100-01-01\",\n        )\n\n        # give user3 permission to skip T&Cs\n        content_type = ContentType.objects.get_for_model(type(self.user3))\n        self.skip_perm = Permission.objects.create(\n            content_type=content_type, name=\"Can skip T&Cs\", codename=\"can_skip_t&c\"\n        )\n        self.user3.user_permissions.add(self.skip_perm)\n\n    def tearDown(self):\n        \"\"\"Teardown for each test\"\"\"\n        LOGGER.debug(\"Test TearDown\")\n        User.objects.all().delete()\n        TermsAndConditions.objects.all().delete()\n        UserTermsAndConditions.objects.all().delete()\n\n    def test_social_redirect(self):\n        \"\"\"Test the agreed_to_terms redirect from social pipeline\"\"\"\n        LOGGER.debug(\"Test the social pipeline\")\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, HttpResponseRedirect)\n\n        # Accept the terms and try again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, dict)\n\n    def test_get_active_terms_list(self):\n        \"\"\"Test get list of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_list()\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_get_active_terms_not_agreed_to(self):\n        \"\"\"Test get T&Cs not agreed to\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user1)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_user_is_excluded(self):\n        \"\"\"Test user3 has perm which excludes them from having to accept T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user3)\n        self.assertEqual([], active_list)\n\n    def test_superuser_is_not_implicitly_excluded(self):\n        \"\"\"Test su should have to accept T&Cs even if they are superuser but don't explicitly have the skip perm\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_cannot_skip(self):\n        \"\"\"Test su still has to accept even if they are explicitly given the skip perm\"\"\"\n        self.su.user_permissions.add(self.skip_perm)\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_excluded(self):\n        \"\"\"Test su doesn't have to accept with TERMS_EXCLUDE_SUPERUSERS set\"\"\"\n        with self.settings(TERMS_EXCLUDE_SUPERUSERS=True):\n            active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n            self.assertEqual([], active_list)\n\n    def test_get_active_terms_ids(self):\n        \"\"\"Test get ids of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_ids()\n        self.assertEqual(2, len(active_list))\n        self.assertEqual(active_list, [3, 2])\n\n    def test_terms_and_conditions_models(self):\n        \"\"\"Various tests of the TermsAndConditions Module\"\"\"\n\n        # Testing Direct Assignment of Acceptance\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms1)\n        UserTermsAndConditions.objects.create(user=self.user2, terms=self.terms3)\n\n        self.assertEquals(1.0, self.user1.userterms.get().terms.version_number)\n        self.assertEquals(1.5, self.user2.userterms.get().terms.version_number)\n\n        self.assertEquals(\"user1\", self.terms1.users.all()[0].get_username())\n\n        # Testing the get_active static method of TermsAndConditions\n        self.assertEquals(\n            2.0, TermsAndConditions.get_active(slug=\"site-terms\").version_number\n        )\n        self.assertEquals(\n            1.5, TermsAndConditions.get_active(slug=\"contrib-terms\").version_number\n        )\n\n        # Testing the unicode method of TermsAndConditions\n        self.assertEquals(\n            \"site-terms-2.00\", str(TermsAndConditions.get_active(slug=\"site-terms\"))\n        )\n        self.assertEquals(\n            \"contrib-terms-1.50\",\n            str(TermsAndConditions.get_active(slug=\"contrib-terms\")),\n        )\n\n    def test_middleware_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if they are logged in, and decorator is on method\"\"\"\n\n        UserTermsAndConditions.objects.all().delete()\n\n        LOGGER.debug(\"Test user1 login for middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /secure/ after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/contrib-terms/?returnTo=/secure/\"\n        )\n\n    def test_terms_required_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if logged in, and decorator is on method\"\"\"\n\n        LOGGER.debug(\"Test /termsrequired/ pre login\")\n        not_logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            not_logged_in_response, \"/accounts/login/?next=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test user1 login\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /termsrequired/ after login\")\n        logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/?returnTo=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test no redirect for /termsrequired/ after accept\")\n        accepted_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/termsrequired/\"}, follow=True\n        )\n        self.assertContains(accepted_response, \"Please Accept\")\n\n        LOGGER.debug(\"Test response after termsrequired accept\")\n        terms_required_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertContains(terms_required_response, \"Please Accept\")\n\n    def test_accept(self):\n        \"\"\"Validate that accepting terms works\"\"\"\n\n        LOGGER.debug(\"Test user1 login for accept\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/ get\")\n        accept_response = self.client.get(\"/terms/accept/\", follow=True)\n        self.assertContains(accept_response, \"Accept\")\n\n        LOGGER.debug(\"Test /terms/accept/ post\")\n        chained_terms_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(chained_terms_response, \"Contributor\")\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/1.5/ post\")\n        accept_version_response = self.client.get(\n            \"/terms/accept/contrib-terms/1.5/\", follow=True\n        )\n        self.assertContains(\n            accept_version_response, \"Contributor Terms and Conditions 1.5\"\n        )\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_version_post_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(accept_version_post_response, \"Secure\")\n\n    def test_accept_redirect_safe(self):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test user1 login for test_accept_redirect\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/site-terms/1/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertRedirects(accept_response, \"/secure/\")\n\n    def test_accept_redirect_unsafe(self):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"http://attacker/\"}, follow=False\n        )\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_store_ip_address(self):\n        \"\"\"Test with IP address storage setting true (default)\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_store_ip_address_multiple(self):\n        \"\"\"Test storing IP address when it is a list\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\",\n            {\"terms\": 2, \"returnTo\": \"/secure/\"},\n            follow=True,\n            REMOTE_ADDR=\"0.0.0.0, 1.1.1.1\",\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_no_ip_address(self):\n        \"\"\"Test with IP address storage setting false\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        with self.settings(TERMS_STORE_IP_ADDRESS=False):\n            self.client.post(\n                \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n            )\n            user_terms = UserTermsAndConditions.objects.all()[0]\n            self.assertFalse(user_terms.ip_address)\n\n    def test_terms_upgrade(self):\n        \"\"\"Validate a user is prompted to accept terms again when new version comes out\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login pre upgrade\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertContains(logged_in_response, \"Contributor\")\n\n        # First, Accept Contributor Terms\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n\n        LOGGER.debug(\"Test upgrade terms\")\n        self.terms5 = TermsAndConditions.objects.create(\n            id=5,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Terms and Conditions2\",\n            version_number=2.5,\n            date_active=\"2012-02-05\",\n        )\n\n        LOGGER.debug(\"Test user1 is redirected when changing pages\")\n        post_upgrade_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            post_upgrade_response, \"/terms/accept/site-terms/?returnTo=/secure/\"\n        )\n\n    def test_no_middleware(self):\n        \"\"\"Test a secure page with the middleware excepting it\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login no middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/securetoo/\", follow=True)\n        self.assertContains(logged_in_response, \"SECOND\")\n\n        LOGGER.debug(\"Test startswith '/admin' pages not redirecting\")\n        admin_response = self.client.get(\"/admin\", follow=True)\n        self.assertContains(admin_response, \"administration\")\n\n    def test_anonymous_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions for Anonymous User\"\"\"\n        active_terms = TermsAndConditions.get_active_terms_list()\n\n        LOGGER.debug(\"Test /terms/ with anon\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in active_terms:\n            self.assertContains(root_response, terms.name)\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms with anon\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/contributor-terms/1.5 with anon\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n\n    def test_user_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions Page for Logged In User\"\"\"\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 2)\n\n        LOGGER.debug(\"Test /terms/ with user1\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n        self.assertContains(root_response, \"Sign Out\")\n\n        # Accept terms and check again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 1)\n        LOGGER.debug(\"Test /terms/ with user1 after accept\")\n        post_accept_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(post_accept_response, terms.text)\n        self.assertNotContains(post_accept_response, self.terms3.name)\n        self.assertContains(post_accept_response, \"Terms and Conditions\")\n        self.assertContains(post_accept_response, \"Sign Out\")\n\n        # Check by slug and version while logged in\n        LOGGER.debug(\"Test /terms/view/site-terms as user1\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms/1.5 as user1\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n        self.assertContains(version_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n    def test_user_pipeline(self):\n        \"\"\"Test the case of a user being partially created via the django-socialauth pipeline\"\"\"\n\n        LOGGER.debug(\"Test /terms/accept/ post for no user\")\n        no_user_response = self.client.post(\"/terms/accept/\", {\"terms\": 2}, follow=True)\n        self.assertContains(no_user_response, \"Home\")\n\n        user = {\"pk\": self.user1.id}\n        kwa = {\"user\": user}\n        partial_pipeline = {\"kwargs\": kwa}\n\n        engine = import_module(settings.SESSION_ENGINE)\n        store = engine.SessionStore()\n        store.save()\n        self.client.cookies[settings.SESSION_COOKIE_NAME] = store.session_key\n\n        session = self.client.session\n        session[\"partial_pipeline\"] = partial_pipeline\n        session.save()\n\n        self.assertTrue(\"partial_pipeline\" in self.client.session)\n\n        LOGGER.debug(\"Test /terms/accept/ post for pipeline user\")\n        pipeline_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/anon\"}, follow=True\n        )\n        self.assertContains(pipeline_response, \"Anon\")\n\n    def test_email_terms(self):\n        \"\"\"Test emailing terms and conditions\"\"\"\n        LOGGER.debug(\"Test /terms/email/\")\n        email_form_response = self.client.get(\"/terms/email/\", follow=True)\n        self.assertContains(email_form_response, \"Email\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_send_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"foo@foo.com\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertEqual(\n            len(mail.outbox), 1\n        )  # Check that there is one email in the test outbox\n        self.assertContains(email_send_response, \"Sent\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_fail_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"INVALID EMAIL ADDRESS\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertContains(email_fail_response, \"Invalid\")\n\n\nclass TermsAndConditionsTemplateTagsTestCase(TestCase):\n    \"\"\"Tests Tags for T&C\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.template_string_1 = (\n            \"{% load terms_tags %}\" \"{% show_terms_if_not_agreed %}\"\n        )\n        self.template_string_2 = (\n            \"{% load terms_tags %}\"\n            '{% show_terms_if_not_agreed slug=\"specific-terms\" %}'\n        )\n        self.template_string_3 = (\n            \"{% load terms_tags %}\" \"{% include terms.text|as_template %}\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        cache.clear()\n\n    def _make_context(self, url):\n        \"\"\"Build Up Context - Used in many tests\"\"\"\n        context = dict()\n        context[\"request\"] = RequestFactory()\n        context[\"request\"].user = self.user1\n        context[\"request\"].META = {\"PATH_INFO\": url}\n        return context\n\n    def render_template(self, string, context=None):\n        \"\"\"a helper method to render simplistic test templates\"\"\"\n        request = RequestFactory().get(\"/test\")\n        request.user = self.user1\n        request.context = context or {}\n        return Template(string).render(Context({\"request\": request}))\n\n    def test_show_terms_if_not_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag renders html code\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms if not agreed to\")\n        rendered = self.render_template(self.template_string_1)\n        terms = TermsAndConditions.get_active()\n        self.assertIn(terms.slug, rendered)\n\n    def test_not_show_terms_if_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag does not load if user agreed terms\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms once agreed to\")\n        terms = TermsAndConditions.get_active()\n        UserTermsAndConditions.objects.create(terms=terms, user=self.user1)\n        rendered = self.render_template(self.template_string_1)\n        self.assertNotIn(terms.slug, rendered)\n\n    def test_show_terms_if_not_agreed_on_protected_url_not_agreed(self):\n        \"\"\"Check terms on protected url if not agreed\"\"\"\n        context = self._make_context(\"/test\")\n        result = show_terms_if_not_agreed(context)\n        terms = TermsAndConditions.get_active(slug=DEFAULT_TERMS_SLUG)\n        self.assertEqual(result.get(\"not_agreed_terms\")[0], terms)\n\n    def test_show_terms_if_not_agreed_on_unprotected_url_not_agreed(self):\n        \"\"\"Check terms on unprotected url if not agreed\"\"\"\n        context = self._make_context(\"/\")\n        result = show_terms_if_not_agreed(context)\n        self.assertDictEqual(result, {\"not_agreed_terms\": False})\n\n    def test_as_template(self):\n        \"\"\"Test as_template template tag\"\"\"\n        terms = TermsAndConditions.get_active()\n        rendered = Template(self.template_string_3).render(Context({\"terms\": terms}))\n        self.assertIn(terms.text, rendered)\n", "patch": "@@ -242,7 +242,7 @@ def test_accept(self):\n         )\n         self.assertContains(accept_version_post_response, \"Secure\")\n \n-    def test_accept_redirect_safe(self):\n+    def _post_accept(self, return_to):\n         # Pre-accept terms 2 and 3\n         UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n         UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n@@ -253,19 +253,28 @@ def test_accept_redirect_safe(self):\n \n         LOGGER.debug(\"Test /terms/accept/site-terms/1/ post\")\n         accept_response = self.client.post(\n-            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": \"/secure/\"}, follow=True\n+            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": return_to}, follow=True\n         )\n+        return accept_response\n+\n+    def test_accept_redirect_safe(self):\n+        accept_response = self._post_accept(\"/secure/\")\n         self.assertRedirects(accept_response, \"/secure/\")\n \n     def test_accept_redirect_unsafe(self):\n-        # Pre-accept terms 2 and 3\n-        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n-        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n+        accept_response = self._post_accept(\"http://attacker/\")\n+        self.assertRedirects(accept_response, \"/\")\n \n-        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n-        accept_response = self.client.post(\n-            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"http://attacker/\"}, follow=False\n-        )\n+    def test_accept_redirect_unsafe_2(self):\n+        accept_response = self._post_accept(\"//attacker.com\")\n+        self.assertRedirects(accept_response, \"/\")\n+\n+    def test_accept_redirect_unsafe_3(self):\n+        accept_response = self._post_accept(\"///attacker.com\")\n+        self.assertRedirects(accept_response, \"/\")\n+\n+    def test_accept_redirect_unsafe_4(self):\n+        accept_response = self._post_accept(\"////attacker.com\")\n         self.assertRedirects(accept_response, \"/\")\n \n     def test_accept_store_ip_address(self):", "file_path": "files/2022_12/1298", "file_language": "py", "file_name": "termsandconditions/tests.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cyface/django-termsandconditions/raw/03396a1c2e0af95e12a45c5faef7e47a4b513e1a/termsandconditions%2Fviews.py", "code": "\"\"\"Django Views for the termsandconditions module\"\"\"\nfrom urllib.parse import urlparse\n\n# pylint: disable=E1120,R0901,R0904\nfrom django.contrib.auth.models import User\nfrom django.db import IntegrityError\n\nfrom .forms import UserTermsAndConditionsModelForm, EmailTermsForm\nfrom .models import TermsAndConditions, UserTermsAndConditions\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nfrom django.contrib import messages\nfrom django.http import HttpResponseRedirect, Http404\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import DetailView, CreateView, FormView\nfrom django.template.loader import get_template\nfrom django.utils.encoding import iri_to_uri\nimport logging\nfrom smtplib import SMTPException\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\nDEFAULT_TERMS_BASE_TEMPLATE = \"base.html\"\nDEFAULT_TERMS_IP_HEADER_NAME = \"REMOTE_ADDR\"\n\n\nclass GetTermsViewMixin(object):\n    \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n    def get_terms(self, kwargs):\n        \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n        slug = kwargs.get(\"slug\")\n        version = kwargs.get(\"version\")\n\n        if slug and version:\n            terms = [\n                TermsAndConditions.objects.filter(\n                    slug=slug, version_number=version\n                ).latest(\"date_active\")\n            ]\n        elif slug:\n            terms = [TermsAndConditions.get_active(slug)]\n        else:\n            # Return a list of not agreed to terms for the current user for the list view\n            terms = TermsAndConditions.get_active_terms_not_agreed_to(self.request.user)\n        return terms\n\n    def get_return_to(self, from_dict):\n        return_to = from_dict.get(\"returnTo\", \"/\")\n\n        if self.is_safe_url(return_to):\n            # Django recommends to use this together with the helper above\n            return iri_to_uri(return_to)\n\n        LOGGER.debug(\"Unsafe URL found: {}\".format(return_to))\n        return \"/\"\n\n    def is_safe_url(self, url):\n        # In Django 3.0 is_safe_url is renamed, so we import conditionally:\n        # https://docs.djangoproject.com/en/3.2/releases/3.0/#id3\n        try:\n            from django.utils.http import url_has_allowed_host_and_scheme\n        except ImportError:\n            from django.utils.http import (\n                is_safe_url as url_has_allowed_host_and_scheme,\n            )\n\n        return url_has_allowed_host_and_scheme(url, settings.ALLOWED_HOSTS)\n\n\nclass AcceptTermsView(CreateView, GetTermsViewMixin):\n    \"\"\"\n    Terms and Conditions Acceptance view\n\n    url: /terms/accept\n    \"\"\"\n\n    model = UserTermsAndConditions\n    form_class = UserTermsAndConditionsModelForm\n    template_name = \"termsandconditions/tc_accept_terms.html\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C to accept and catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AcceptTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n        return_to = self.get_return_to(self.request.GET)\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Handles POST request.\n        \"\"\"\n        return_url = self.get_return_to(self.request.POST)\n        terms_ids = request.POST.getlist(\"terms\")\n\n        if not terms_ids:  # pragma: nocover\n            return HttpResponseRedirect(return_url)\n\n        if request.user.is_authenticated:\n            user = request.user\n        else:\n            # Get user out of saved pipeline from django-socialauth\n            if \"partial_pipeline\" in request.session:\n                user_pk = request.session[\"partial_pipeline\"][\"kwargs\"][\"user\"][\"pk\"]\n                user = User.objects.get(id=user_pk)\n            else:\n                return HttpResponseRedirect(\"/\")\n\n        store_ip_address = getattr(settings, \"TERMS_STORE_IP_ADDRESS\", True)\n        if store_ip_address:\n            ip_address = request.META.get(\n                getattr(settings, \"TERMS_IP_HEADER_NAME\", DEFAULT_TERMS_IP_HEADER_NAME)\n            )\n            if \",\" in ip_address:\n                ip_address = ip_address.split(\",\")[0].strip()\n        else:\n            ip_address = \"\"\n\n        for terms_id in terms_ids:\n            try:\n                new_user_terms = UserTermsAndConditions(\n                    user=user,\n                    terms=TermsAndConditions.objects.get(pk=int(terms_id)),\n                    ip_address=ip_address,\n                )\n                new_user_terms.save()\n            except IntegrityError:  # pragma: nocover\n                pass\n\n        return HttpResponseRedirect(return_url)\n\n\nclass EmailTermsView(FormView, GetTermsViewMixin):\n    \"\"\"\n    Email Terms and Conditions View\n\n    url: /terms/email\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_email_terms_form.html\"\n\n    form_class = EmailTermsForm\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C send, catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n\n        return_to = self.get_return_to(self.request.GET)\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def form_valid(self, form):\n        \"\"\"Override of CreateView method, sends the email.\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.form_valid\")\n\n        template = get_template(\"termsandconditions/tc_email_terms.html\")\n        template_rendered = template.render({\"terms\": form.cleaned_data.get(\"terms\")})\n\n        LOGGER.debug(\"Email Terms Body:\")\n        LOGGER.debug(template_rendered)\n\n        try:\n            send_mail(\n                form.cleaned_data.get(\"email_subject\", _(\"Terms\")),\n                template_rendered,\n                settings.DEFAULT_FROM_EMAIL,\n                [form.cleaned_data.get(\"email_address\")],\n                fail_silently=False,\n            )\n            messages.add_message(\n                self.request, messages.INFO, _(\"Terms and Conditions Sent.\")\n            )\n        except SMTPException:  # pragma: no cover\n            messages.add_message(\n                self.request,\n                messages.ERROR,\n                _(\"An Error Occurred Sending Your Message.\"),\n            )\n\n        self.success_url = self.get_return_to(form.cleaned_data)\n\n        return super().form_valid(form)\n\n    def form_invalid(self, form):\n        \"\"\"Override of CreateView method, logs invalid email form submissions.\"\"\"\n        LOGGER.debug(\"Invalid Email Form Submitted\")\n        messages.add_message(self.request, messages.ERROR, _(\"Invalid Email Address.\"))\n        return super().form_invalid(form)\n\n\nclass TermsView(DetailView, GetTermsViewMixin):\n    \"\"\"\n    View Unaccepted Terms and Conditions View\n\n    url: /terms/\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_view_terms.html\"\n    context_object_name = \"terms_list\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.TermsView.get_object\")\n        return self.get_terms(self.kwargs)\n\n\nclass TermsActiveView(TermsView):\n    \"\"\"\n    View Active Terms and Conditions View\n\n    url: /terms/active/\n    \"\"\"\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AllTermsView.get_object\")\n        return TermsAndConditions.get_active_terms_list()\n", "code_before": "\"\"\"Django Views for the termsandconditions module\"\"\"\nfrom urllib.parse import urlparse\n\n# pylint: disable=E1120,R0901,R0904\nfrom django.contrib.auth.models import User\nfrom django.db import IntegrityError\n\nfrom .forms import UserTermsAndConditionsModelForm, EmailTermsForm\nfrom .models import TermsAndConditions, UserTermsAndConditions\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nfrom django.contrib import messages\nfrom django.http import HttpResponseRedirect, Http404\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import DetailView, CreateView, FormView\nfrom django.template.loader import get_template\nimport logging\nfrom smtplib import SMTPException\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\nDEFAULT_TERMS_BASE_TEMPLATE = \"base.html\"\nDEFAULT_TERMS_IP_HEADER_NAME = \"REMOTE_ADDR\"\n\n\nclass GetTermsViewMixin(object):\n    \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n    def get_terms(self, kwargs):\n        \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n        slug = kwargs.get(\"slug\")\n        version = kwargs.get(\"version\")\n\n        if slug and version:\n            terms = [\n                TermsAndConditions.objects.filter(\n                    slug=slug, version_number=version\n                ).latest(\"date_active\")\n            ]\n        elif slug:\n            terms = [TermsAndConditions.get_active(slug)]\n        else:\n            # Return a list of not agreed to terms for the current user for the list view\n            terms = TermsAndConditions.get_active_terms_not_agreed_to(self.request.user)\n        return terms\n\n\nclass AcceptTermsView(CreateView, GetTermsViewMixin):\n    \"\"\"\n    Terms and Conditions Acceptance view\n\n    url: /terms/accept\n    \"\"\"\n\n    model = UserTermsAndConditions\n    form_class = UserTermsAndConditionsModelForm\n    template_name = \"termsandconditions/tc_accept_terms.html\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C to accept and catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AcceptTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n        return_to = self.request.GET.get(\"returnTo\", \"/\")\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Handles POST request.\n        \"\"\"\n        return_url = request.POST.get(\"returnTo\", \"/\")\n        terms_ids = request.POST.getlist(\"terms\")\n\n        parsed = urlparse(return_url)\n        if parsed.hostname and parsed.hostname not in settings.ALLOWED_HOSTS:\n            # Make sure the return url is a relative path or a trusted hostname\n            return_url = '/'\n\n        if not terms_ids:  # pragma: nocover\n            return HttpResponseRedirect(return_url)\n\n        if request.user.is_authenticated:\n            user = request.user\n        else:\n            # Get user out of saved pipeline from django-socialauth\n            if \"partial_pipeline\" in request.session:\n                user_pk = request.session[\"partial_pipeline\"][\"kwargs\"][\"user\"][\"pk\"]\n                user = User.objects.get(id=user_pk)\n            else:\n                return HttpResponseRedirect(\"/\")\n\n        store_ip_address = getattr(settings, \"TERMS_STORE_IP_ADDRESS\", True)\n        if store_ip_address:\n            ip_address = request.META.get(\n                getattr(settings, \"TERMS_IP_HEADER_NAME\", DEFAULT_TERMS_IP_HEADER_NAME)\n            )\n            if \",\" in ip_address:\n                ip_address = ip_address.split(\",\")[0].strip()\n        else:\n            ip_address = \"\"\n\n        for terms_id in terms_ids:\n            try:\n                new_user_terms = UserTermsAndConditions(\n                    user=user,\n                    terms=TermsAndConditions.objects.get(pk=int(terms_id)),\n                    ip_address=ip_address,\n                )\n                new_user_terms.save()\n            except IntegrityError:  # pragma: nocover\n                pass\n\n        return HttpResponseRedirect(return_url)\n\n\nclass EmailTermsView(FormView, GetTermsViewMixin):\n    \"\"\"\n    Email Terms and Conditions View\n\n    url: /terms/email\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_email_terms_form.html\"\n\n    form_class = EmailTermsForm\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C send, catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n\n        return_to = self.request.GET.get(\"returnTo\", \"/\")\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def form_valid(self, form):\n        \"\"\"Override of CreateView method, sends the email.\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.form_valid\")\n\n        template = get_template(\"termsandconditions/tc_email_terms.html\")\n        template_rendered = template.render({\"terms\": form.cleaned_data.get(\"terms\")})\n\n        LOGGER.debug(\"Email Terms Body:\")\n        LOGGER.debug(template_rendered)\n\n        try:\n            send_mail(\n                form.cleaned_data.get(\"email_subject\", _(\"Terms\")),\n                template_rendered,\n                settings.DEFAULT_FROM_EMAIL,\n                [form.cleaned_data.get(\"email_address\")],\n                fail_silently=False,\n            )\n            messages.add_message(\n                self.request, messages.INFO, _(\"Terms and Conditions Sent.\")\n            )\n        except SMTPException:  # pragma: no cover\n            messages.add_message(\n                self.request,\n                messages.ERROR,\n                _(\"An Error Occurred Sending Your Message.\"),\n            )\n\n        self.success_url = form.cleaned_data.get(\"returnTo\", \"/\") or \"/\"\n\n        return super().form_valid(form)\n\n    def form_invalid(self, form):\n        \"\"\"Override of CreateView method, logs invalid email form submissions.\"\"\"\n        LOGGER.debug(\"Invalid Email Form Submitted\")\n        messages.add_message(self.request, messages.ERROR, _(\"Invalid Email Address.\"))\n        return super().form_invalid(form)\n\n\nclass TermsView(DetailView, GetTermsViewMixin):\n    \"\"\"\n    View Unaccepted Terms and Conditions View\n\n    url: /terms/\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_view_terms.html\"\n    context_object_name = \"terms_list\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.TermsView.get_object\")\n        return self.get_terms(self.kwargs)\n\n\nclass TermsActiveView(TermsView):\n    \"\"\"\n    View Active Terms and Conditions View\n\n    url: /terms/active/\n    \"\"\"\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AllTermsView.get_object\")\n        return TermsAndConditions.get_active_terms_list()\n", "patch": "@@ -14,6 +14,7 @@\n from django.utils.translation import gettext as _\n from django.views.generic import DetailView, CreateView, FormView\n from django.template.loader import get_template\n+from django.utils.encoding import iri_to_uri\n import logging\n from smtplib import SMTPException\n \n@@ -44,6 +45,28 @@ def get_terms(self, kwargs):\n             terms = TermsAndConditions.get_active_terms_not_agreed_to(self.request.user)\n         return terms\n \n+    def get_return_to(self, from_dict):\n+        return_to = from_dict.get(\"returnTo\", \"/\")\n+\n+        if self.is_safe_url(return_to):\n+            # Django recommends to use this together with the helper above\n+            return iri_to_uri(return_to)\n+\n+        LOGGER.debug(\"Unsafe URL found: {}\".format(return_to))\n+        return \"/\"\n+\n+    def is_safe_url(self, url):\n+        # In Django 3.0 is_safe_url is renamed, so we import conditionally:\n+        # https://docs.djangoproject.com/en/3.2/releases/3.0/#id3\n+        try:\n+            from django.utils.http import url_has_allowed_host_and_scheme\n+        except ImportError:\n+            from django.utils.http import (\n+                is_safe_url as url_has_allowed_host_and_scheme,\n+            )\n+\n+        return url_has_allowed_host_and_scheme(url, settings.ALLOWED_HOSTS)\n+\n \n class AcceptTermsView(CreateView, GetTermsViewMixin):\n     \"\"\"\n@@ -69,22 +92,17 @@ def get_initial(self):\n         LOGGER.debug(\"termsandconditions.views.AcceptTermsView.get_initial\")\n \n         terms = self.get_terms(self.kwargs)\n-        return_to = self.request.GET.get(\"returnTo\", \"/\")\n+        return_to = self.get_return_to(self.request.GET)\n \n         return {\"terms\": terms, \"returnTo\": return_to}\n \n     def post(self, request, *args, **kwargs):\n         \"\"\"\n         Handles POST request.\n         \"\"\"\n-        return_url = request.POST.get(\"returnTo\", \"/\")\n+        return_url = self.get_return_to(self.request.POST)\n         terms_ids = request.POST.getlist(\"terms\")\n \n-        parsed = urlparse(return_url)\n-        if parsed.hostname and parsed.hostname not in settings.ALLOWED_HOSTS:\n-            # Make sure the return url is a relative path or a trusted hostname\n-            return_url = '/'\n-\n         if not terms_ids:  # pragma: nocover\n             return HttpResponseRedirect(return_url)\n \n@@ -147,7 +165,7 @@ def get_initial(self):\n \n         terms = self.get_terms(self.kwargs)\n \n-        return_to = self.request.GET.get(\"returnTo\", \"/\")\n+        return_to = self.get_return_to(self.request.GET)\n \n         return {\"terms\": terms, \"returnTo\": return_to}\n \n@@ -179,7 +197,7 @@ def form_valid(self, form):\n                 _(\"An Error Occurred Sending Your Message.\"),\n             )\n \n-        self.success_url = form.cleaned_data.get(\"returnTo\", \"/\") or \"/\"\n+        self.success_url = self.get_return_to(form.cleaned_data)\n \n         return super().form_valid(form)\n ", "file_path": "files/2022_12/1299", "file_language": "py", "file_name": "termsandconditions/views.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.django.security.injection.open-redirect.open-redirect                                 \n          Data from request (return_url) is passed to redirect(). This is an open redirect and could\n          be exploited. Ensure you are redirecting to safe URLs by using                            \n          django.utils.http.is_safe_url(). See https://cwe.mitre.org/data/definitions/601.html for  \n          more information.                                                                         \n          Details: https://sg.run/Ave2                                                              \n\n           80\u2506 return_url = request.POST.get(\"returnTo\", \"/\")\n           81\u2506 terms_ids = request.POST.getlist(\"terms\")\n           82\u2506 \n           83\u2506 parsed = urlparse(return_url)\n           84\u2506 if parsed.hostname and parsed.hostname not in settings.ALLOWED_HOSTS:\n           85\u2506     # Make sure the return url is a relative path or a trusted hostname\n           86\u2506     return_url = '/'\n           87\u2506 \n           88\u2506 if not terms_ids:  # pragma: nocover\n           89\u2506     return HttpResponseRedirect(return_url)\n           90\u2506 \n           91\u2506 if request.user.is_authenticated:\n           92\u2506     user = request.user\n           93\u2506 else:\n           94\u2506     # Get user out of saved pipeline from django-socialauth\n           95\u2506     if \"partial_pipeline\" in request.session:\n           96\u2506         user_pk = request.session[\"partial_pipeline\"][\"kwargs\"][\"user\"][\"pk\"]\n           97\u2506         user = User.objects.get(id=user_pk)\n           98\u2506     else:\n           99\u2506         return HttpResponseRedirect(\"/\")\n          100\u2506 \n          101\u2506 store_ip_address = getattr(settings, \"TERMS_STORE_IP_ADDRESS\", True)\n          102\u2506 if store_ip_address:\n          103\u2506     ip_address = request.META.get(\n          104\u2506         getattr(settings, \"TERMS_IP_HEADER_NAME\", DEFAULT_TERMS_IP_HEADER_NAME)\n          105\u2506     )\n          106\u2506     if \",\" in ip_address:\n          107\u2506         ip_address = ip_address.split(\",\")[0].strip()\n          108\u2506 else:\n          109\u2506     ip_address = \"\"\n          110\u2506 \n          111\u2506 for terms_id in terms_ids:\n          112\u2506     try:\n          113\u2506         new_user_terms = UserTermsAndConditions(\n          114\u2506             user=user,\n          115\u2506             terms=TermsAndConditions.objects.get(pk=int(terms_id)),\n          116\u2506             ip_address=ip_address,\n          117\u2506         )\n          118\u2506         new_user_terms.save()\n          119\u2506     except IntegrityError:  # pragma: nocover\n          120\u2506         pass\n          121\u2506 \n          122\u2506 return HttpResponseRedirect(return_url)", "       python.django.security.injection.open-redirect.open-redirect                                 \n          Data from request (return_url) is passed to redirect(). This is an open redirect and could\n          be exploited. Ensure you are redirecting to safe URLs by using                            \n          django.utils.http.is_safe_url(). See https://cwe.mitre.org/data/definitions/601.html for  \n          more information.                                                                         \n          Details: https://sg.run/Ave2                                                              \n\n           80\u2506 return_url = request.POST.get(\"returnTo\", \"/\")\n           81\u2506 terms_ids = request.POST.getlist(\"terms\")\n           82\u2506 \n           83\u2506 parsed = urlparse(return_url)\n           84\u2506 if parsed.hostname and parsed.hostname not in settings.ALLOWED_HOSTS:\n           85\u2506     # Make sure the return url is a relative path or a trusted hostname\n           86\u2506     return_url = '/'\n           87\u2506 \n           88\u2506 if not terms_ids:  # pragma: nocover\n           89\u2506     return HttpResponseRedirect(return_url)"]]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
