{"index": 7908, "cve_id": "CVE-2022-0645", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "Open redirect vulnerability via endpoint authorize_and_redirect/?redirect= in GitHub repository posthog/posthog prior to 1.34.1.", "cvss": "6.1", "publish_date": "April 19, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "859d8ed9ac7c5026db09714a26c85c1458abb038", "commit_message": "fix(toolbar): only redirect to hosts in app_urls (#9268)\n\n* fix(toolbar): only redirect to hosts in app_urls\r\n\r\n* fix mypy and regex", "commit_date": "2022-03-29T13:29:57Z", "project": "posthog/posthog", "url": "https://api.github.com/repos/PostHog/posthog/commits/859d8ed9ac7c5026db09714a26c85c1458abb038", "html_url": "https://github.com/PostHog/posthog/commit/859d8ed9ac7c5026db09714a26c85c1458abb038", "windows_before": [{"commit_id": "b88c4d1e3739efe350e74059ad9a7d0d9a49d10f", "commit_date": "Tue Mar 29 09:28:43 2022 +0000", "commit_message": "fix(property-types): do not always describe all properties with detected types (#9278)", "files_name": ["frontend/src/lib/components/PropertiesTable.tsx", "frontend/src/scenes/events/EventDetails.tsx"]}, {"commit_id": "a85cbcb747de1f9e1c1379454afe21abc528e083", "commit_date": "Tue Mar 29 09:20:34 2022 +0000", "commit_message": "fix(plugin-server): only dispatch a new exportHistoricalEvents job if the previous one didn't fail (#9272)", "files_name": ["plugin-server/src/worker/vm/upgrades/historical-export/export-historical-events.ts"]}, {"commit_id": "e5db1e73e439f6fc3b38234ece9450ea22b5866f", "commit_date": "Tue Mar 29 09:19:31 2022 +0100", "commit_message": "chore(contributors): \ud83e\udd16 - Add dannysheridan as a contributor \ud83c\udf89 (#9277)", "files_name": [".all-contributorsrc", "README.md"]}, {"commit_id": "cfa689d91c2ec7aed91976fa71f2b4ac941f607b", "commit_date": "Tue Mar 29 09:07:08 2022 +0100", "commit_message": "chore(deps): Update posthog-js to 1.20.1 (#9275)", "files_name": ["package.json", "yarn.lock"]}, {"commit_id": "6f16babc42f05a1925d6e02399a37c23648e4c96", "commit_date": "Tue Mar 29 06:05:21 2022 +0100", "commit_message": "chore(contributors): \ud83e\udd16 - Add rahul3v as a contributor \ud83c\udf89 (#9274)", "files_name": [".all-contributorsrc", "README.md"]}, {"commit_id": "7c33d4ba4b11b4e64b1c1bc81fdeba6f97e16795", "commit_date": "Mon Mar 28 15:50:44 2022 +0200", "commit_message": "fix(toolbar): extra guarantees around authorization (#9267)", "files_name": ["posthog/test/test_urls.py", "posthog/urls.py"]}, {"commit_id": "2f587d183562fee6fc784d62b9b453f7c7abc1de", "commit_date": "Mon Mar 28 08:13:37 2022 +0100", "commit_message": "chore(property-filtering): removes the datetime property filter flag (#9252)", "files_name": ["cypress/README.md", "cypress/integration/events.js", "frontend/src/lib/components/ActivityLog/__mocks__/activityLogMocks.ts", "frontend/src/lib/components/PropertyFilters/components/OperatorValueSelect.stories.tsx", "frontend/src/lib/components/PropertyFilters/components/OperatorValueSelect.tsx", "frontend/src/lib/components/PropertyFilters/components/TaxonomicPropertyFilter.tsx", "frontend/src/lib/constants.tsx", "frontend/src/lib/utils.test.ts", "frontend/src/lib/utils.tsx", "frontend/src/models/propertyDefinitionsModel.test.ts", "frontend/src/models/propertyDefinitionsModel.ts", "frontend/src/scenes/performance/__mocks__/eventsResponse.json", "posthog/settings/feature_flags.py"]}, {"commit_id": "1b4af333116f6ee5b94a88f0b07e38c7fd7c1137", "commit_date": "Mon Mar 28 08:08:27 2022 +0100", "commit_message": "fix(insights): Increase frequency of insight refresh (#9216)", "files_name": ["task-definition.web.json", "task-definition.worker.json"]}, {"commit_id": "9d5e9b7ca970385d244664566c9cac082a8edb86", "commit_date": "Mon Mar 28 08:02:33 2022 +0100", "commit_message": "feat: tries to add library version to sentry errors (#9260)", "files_name": ["posthog/test/test_utils.py", "posthog/utils.py"]}, {"commit_id": "b7b25c7792982cb7f43af6a7b2eae47fb84481da", "commit_date": "Fri Mar 25 15:37:15 2022 +0000", "commit_message": "fix: default decide endpoint to v2 (#9254)", "files_name": ["posthog/api/decide.py", "posthog/api/test/test_decide.py"]}, {"commit_id": "d3695ca93ea986652dd59a2c88e99de2f843fc29", "commit_date": "Fri Mar 25 13:48:52 2022 +0000", "commit_message": "feat(activity-logging): add paging to the activity log API (#9148)", "files_name": ["frontend/src/lib/components/ActivityLog/ActivityLog.scss", "frontend/src/lib/components/ActivityLog/ActivityLog.tsx", "frontend/src/lib/components/ActivityLog/activityLogLogic.test.tsx", "frontend/src/lib/components/ActivityLog/activityLogLogic.tsx", "frontend/src/lib/components/ActivityLog/humanizeActivity.tsx", "frontend/src/lib/components/PaginationControl/PaginationControl.tsx", "frontend/src/scenes/feature-flags/FeatureFlags.tsx", "frontend/src/scenes/feature-flags/activityDescriptions.tsx", "frontend/src/scenes/feature-flags/featureFlagsLogic.test.ts", "frontend/src/scenes/feature-flags/featureFlagsLogic.ts", "posthog/api/feature_flag.py", "posthog/api/person.py", "posthog/api/test/test_feature_flag.py", "posthog/models/activity_logging/activity_log.py", "posthog/models/activity_logging/serializers.py"]}, {"commit_id": "b436d601f2b74faee77e762d6234e869e9349adf", "commit_date": "Fri Mar 25 11:53:13 2022 +0100", "commit_message": "chore(CD): re-enable PostHog Cloud deploys (#9233)", "files_name": [".github/workflows/build-and-deploy-prod.yml"]}, {"commit_id": "7221733d2bbfec6aa718f56ee351e3c34b470fdd", "commit_date": "Fri Mar 25 10:52:56 2022 +0000", "commit_message": "feat(activity-logging): track UI actions on persons (#9217)", "files_name": ["posthog/api/person.py", "posthog/api/test/test_feature_flag.py", "posthog/api/test/test_person.py", "posthog/models/activity_logging/activity_log.py", "posthog/models/activity_logging/serializers.py"]}, {"commit_id": "9e6e8be74b427b083f777b7b2077e81d46d785f3", "commit_date": "Fri Mar 25 09:36:22 2022 +0200", "commit_message": "fix(migrations): Upgrade infi.orm (#9250)", "files_name": ["requirements.in", "requirements.txt"]}, {"commit_id": "ea10e012b2cb209b987a8fb2882d0f916c21d987", "commit_date": "Thu Mar 24 20:40:12 2022 +0000", "commit_message": "fix: Live Events Icon Safari (#9242)", "files_name": ["frontend/src/lib/components/icons.tsx"]}, {"commit_id": "03b4ebf2850516f0cefcbe29b55d2ce89380570d", "commit_date": "Thu Mar 24 13:20:07 2022 -0700", "commit_message": "chore: remove data management FF (#9224)", "files_name": ["frontend/public/actions-tutorial-grouping.svg", "frontend/public/actions-tutorial-retroactive.svg", "frontend/public/actions-tutorial-standardized.svg", "frontend/src/lib/components/TaxonomicFilter/InfiniteList.tsx", "frontend/src/scenes/actions/ActionsTable.tsx", "frontend/src/scenes/appScenes.ts", "frontend/src/scenes/data-management/event-properties/EventPropertyDefinitionsTable.tsx", "frontend/src/scenes/data-management/events/EventDefinitionsTable.tsx", "frontend/src/scenes/events/EventsTable.tsx", "frontend/src/scenes/events/EventsVolumeTable.tsx", "frontend/src/scenes/events/PropertiesVolumeTable.tsx", "frontend/src/scenes/events/VolumeTable.scss", "frontend/src/scenes/events/VolumeTable.tsx", "frontend/src/scenes/events/definitions/DefinitionDescription.tsx", "frontend/src/scenes/events/definitions/DefinitionDrawer.tsx", "frontend/src/scenes/events/definitions/DefinitionOwnerDropdown.tsx", "frontend/src/scenes/events/definitions/EventPropertiesStats.tsx", "frontend/src/scenes/events/definitions/EventsTableSnippet.tsx", "frontend/src/scenes/events/definitions/VolumeTableRecordDescription.tsx", "frontend/src/scenes/events/definitions/definitionDrawerLogic.ts", "frontend/src/scenes/sceneTypes.ts"]}, {"commit_id": "28e0fb1baa58d0a0748b03a9639fc637af04bf00", "commit_date": "Thu Mar 24 20:17:53 2022 +0000", "commit_message": "feat(activity-logging): add some eye candy to the feature flag activity list (#9229)", "files_name": ["frontend/src/lib/components/ActivityLog/ActivityLog.scss", "frontend/src/scenes/feature-flags/activityDescriptions.tsx"]}, {"commit_id": "128eaa9000ab0f6f739e070decfabc5f4fd55610", "commit_date": "Thu Mar 24 19:32:59 2022 +0000", "commit_message": "feat(data-management): detect boolean properties on ingestion (#9205)", "files_name": ["plugin-server/src/worker/ingestion/property-definitions-auto-discovery.ts", "plugin-server/tests/worker/ingestion/team-manager.test.ts"]}, {"commit_id": "f1f7a87a57eb124f6037210b7bbae3132fe21352", "commit_date": "Thu Mar 24 18:58:49 2022 +0000", "commit_message": "fix: Ugly breakdown pill (#9240)", "files_name": ["frontend/src/styles/style.scss"]}, {"commit_id": "176e56c6a21e6b26fc5ea8ddc7c0387caa3d42fa", "commit_date": "Thu Mar 24 18:20:46 2022 +0000", "commit_message": "fix(docs): Fix serialisation errors for property groups (#9236)", "files_name": ["posthog/api/documentation.py", "posthog/api/insight_serializers.py"]}, {"commit_id": "6e2289680d26f56d897d71dd49d94d827aed8586", "commit_date": "Thu Mar 24 15:50:40 2022 +0000", "commit_message": "chore: enable query by date feature flag for self hosting (#9237)", "files_name": ["posthog/settings/feature_flags.py"]}, {"commit_id": "a5cc29901b5dd2c85ebfc5d3c7508bbe19593ce3", "commit_date": "Thu Mar 24 15:27:54 2022 +0100", "commit_message": "chore(deps): bump node-forge from 1.2.1 to 1.3.0 in /plugin-server (#9195)", "files_name": ["plugin-server/yarn.lock"]}, {"commit_id": "149196d51939242c7460e64a6225c90fa976be9b", "commit_date": "Thu Mar 24 15:27:17 2022 +0100", "commit_message": "chore(deps): bump minimist from 1.2.5 to 1.2.6 (#9231)", "files_name": ["yarn.lock"]}, {"commit_id": "6be881e4ab8850d2dc53eecc9979734b6b09c9dd", "commit_date": "Thu Mar 24 15:27:05 2022 +0100", "commit_message": "chore(deps): bump minimist from 1.2.5 to 1.2.6 in /plugin-server (#9230)", "files_name": ["plugin-server/yarn.lock"]}, {"commit_id": "5dd0cf9312970846b42caadedc1fcab394be2fbd", "commit_date": "Thu Mar 24 13:50:46 2022 +0000", "commit_message": "chore(experiments): release secondary metrics (#9234)", "files_name": ["frontend/src/scenes/experiments/Experiment.tsx", "posthog/settings/feature_flags.py"]}, {"commit_id": "ba08c9c7dd3f61461876e38cb9c062606e6e4007", "commit_date": "Thu Mar 24 14:16:56 2022 +0100", "commit_message": "fix(insights): Add settings link to internal users filter (#9232)", "files_name": ["frontend/src/lib/components/LemonRow/LemonRow.scss", "frontend/src/scenes/insights/TestAccountFilter/TestAccountFilter.tsx"]}, {"commit_id": "7c93054453d270f1008e26883f9268168856e340", "commit_date": "Thu Mar 24 11:38:27 2022 +0100", "commit_message": "refactor(frontend): several tiny refactors vol 2 (#9136)", "files_name": [".storybook/preview.tsx", "frontend/src/lib/components/CommandPalette/commandPaletteLogic.ts", "frontend/src/lib/components/SaveToDashboard/saveToDashboardModalLogic.ts", "frontend/src/mocks/features.ts", "frontend/src/mocks/handlers.ts", "frontend/src/mocks/jest.ts", "frontend/src/scenes/dashboard/Dashboard.stories.tsx", "frontend/src/scenes/dashboard/Dashboards.tsx", "frontend/src/scenes/dashboard/NewDashboardModal.tsx", "frontend/src/scenes/dashboard/newDashboardLogic.ts", "frontend/src/scenes/experiments/experimentLogic.test.ts", "frontend/src/scenes/feature-flags/FeatureFlags.stories.tsx", "frontend/src/scenes/funnels/funnelLogic.test.ts", "frontend/src/scenes/funnels/funnelLogic.ts", "frontend/src/scenes/insights/insightLogic.test.ts", "frontend/src/scenes/organization/Settings/VerifiedDomains/verifiedDomainsLogic.test.ts", "frontend/src/stories/Hello.stories.mdx", "frontend/src/stories/How to build a scene.stories.mdx"]}, {"commit_id": "60d18a5bda0afe3e67b1956cc5072db7b8f7a4ec", "commit_date": "Thu Mar 24 10:35:28 2022 +0000", "commit_message": "docs(api): Document filtering events by event, person_id (#9068)", "files_name": ["posthog/api/event.py"]}, {"commit_id": "7d92100fbb5b16bbf45745d7edf1a90473148a9c", "commit_date": "Thu Mar 24 10:24:46 2022 +0100", "commit_message": "chore(CD): temporary disable PostHog Cloud deploys (#9228)", "files_name": [".github/workflows/build-and-deploy-prod.yml"]}, {"commit_id": "b3403743bdeea1495d610df5f162c9971288a1d4", "commit_date": "Thu Mar 24 10:19:36 2022 +0100", "commit_message": "chore(npm): upgrade typescript (#9223)", "files_name": ["frontend/src/lib/components/DefinitionPopup/definitionPopupLogic.ts", "frontend/src/lib/components/PropertyFilters/components/PropertyValue.tsx", "frontend/src/scenes/actions/actionEditLogic.ts", "frontend/src/scenes/authentication/inviteSignupLogic.ts", "frontend/src/scenes/authentication/passwordResetLogic.ts", "frontend/src/scenes/authentication/signupLogic.ts", "frontend/src/scenes/cohorts/cohortLogic.ts", "frontend/src/scenes/dashboard/dashboardLogic.ts", "frontend/src/scenes/events/createActionFromEvent.tsx", "frontend/src/scenes/experiments/experimentLogic.tsx", "frontend/src/scenes/insights/insightLogic.ts", "frontend/src/scenes/project/Settings/webhookIntegrationLogic.ts", "frontend/src/scenes/sceneLogic.ts", "frontend/src/scenes/userLogic.ts", "frontend/src/toolbar/button/ToolbarButton.tsx", "package.json", "yarn.lock"]}, {"commit_id": "7f3f775aa9e590c8c4b638200edfb1b21831ae55", "commit_date": "Thu Mar 24 07:17:29 2022 +0000", "commit_message": "fix(activity-logging): null rollout percentage is 100 not 0 percent (#9218)", "files_name": ["frontend/src/lib/components/ActivityLog/activityLogLogic.test.tsx", "frontend/src/scenes/feature-flags/activityDescriptions.tsx"]}, {"commit_id": "b1d1e074c2c11786e2482c0b9e5d6bccecd98f05", "commit_date": "Wed Mar 23 15:56:06 2022 -0700", "commit_message": "revert: login redirect changes (#9161)", "files_name": ["frontend/src/scenes/authentication/loginLogic.test.ts", "frontend/src/scenes/authentication/loginLogic.ts", "frontend/src/scenes/sceneLogic.ts"]}], "windows_after": [{"commit_id": "eb59aa794a8afd1750b1b6beab8aef5da74e44e4", "commit_date": "Tue Mar 29 14:36:53 2022 +0000", "commit_message": "chore(contributors): \ud83e\udd16 - Add Cavallando as a contributor \ud83c\udf89 (#9280)", "files_name": [".all-contributorsrc", "README.md"]}, {"commit_id": "97d29492d935f949dc7a37a0638324b75006961e", "commit_date": "Tue Mar 29 08:35:11 2022 -0700", "commit_message": "fix: overflowing funnels (#9259)", "files_name": ["frontend/src/scenes/insights/InsightTabs/FunnelTab/FunnelBreakdown.tsx"]}, {"commit_id": "6c82ac8742d4e248c7b5bf8a52517fe135c0316b", "commit_date": "Tue Mar 29 12:10:06 2022 -0400", "commit_message": "fix(personsmodal): Make sure person modal doesn't cause page to reset (#9247)", "files_name": ["frontend/src/scenes/trends/personsModalLogic.ts"]}, {"commit_id": "eb668d0b7d0b7081547801f977b8497461240236", "commit_date": "Wed Mar 30 09:52:35 2022 +0000", "commit_message": "feat(web-performance): Move waterfall chart onto its own page (#9266)", "files_name": ["frontend/src/lib/api.ts", "frontend/src/lib/components/ResizableTable/tableConfigLogic.test.ts", "frontend/src/lib/components/ResizableTable/tableConfigLogic.ts", "frontend/src/scenes/events/EventsTable.tsx", "frontend/src/scenes/events/eventsTableLogic.test.ts", "frontend/src/scenes/events/eventsTableLogic.ts", "frontend/src/scenes/groups/Group.tsx", "frontend/src/scenes/performance/WebPerformance.scss", "frontend/src/scenes/performance/WebPerformance.stories.tsx", "frontend/src/scenes/performance/WebPerformance.tsx", "frontend/src/scenes/performance/WebPerformanceWaterfallChart.tsx", "frontend/src/scenes/performance/webPerformanceLogic.tsx", "frontend/src/scenes/persons/Person.tsx", "frontend/src/scenes/scenes.ts", "frontend/src/scenes/session-recordings/sessionRecordingLogic.ts", "frontend/src/scenes/urls.ts", "posthog/api/event.py", "posthog/api/test/test_event.py"]}, {"commit_id": "7cee176785d8a3d6674a5d440f5f1a8a2281e292", "commit_date": "Wed Mar 30 14:02:21 2022 +0200", "commit_message": "fix(dashboards): disable width resizing and handles on small screens (#9276)", "files_name": ["frontend/src/lib/components/InsightCard/InsightCard.tsx", "frontend/src/scenes/dashboard/DashboardItems.tsx"]}, {"commit_id": "6b9a755892fac8da18ec6817738d35240fe12099", "commit_date": "Wed Mar 30 15:11:39 2022 +0200", "commit_message": "fix(funnels): element text filter on funnel steps 2 and above (#9283)", "files_name": ["ee/clickhouse/models/property.py", "ee/clickhouse/models/test/__snapshots__/test_property.ambr", "ee/clickhouse/models/test/test_property.py"]}, {"commit_id": "f71142f88b7d8f023f36979b03cbe33d6641c1f7", "commit_date": "Wed Mar 30 15:45:27 2022 +0000", "commit_message": "perf(plugin-server): disable exportHistoricalEvents on cloud (#9298)", "files_name": ["plugin-server/src/worker/vm/vm.ts"]}, {"commit_id": "177218f0b504c71bbedaab39c28d6b1fb5c72d45", "commit_date": "Wed Mar 30 19:59:54 2022 +0000", "commit_message": "feat(activity-logging): adds history tab to the Persons page (#9226)", "files_name": ["frontend/src/lib/api.ts", "frontend/src/lib/components/ActivityLog/ActivityLog.scss", "frontend/src/lib/components/ActivityLog/ActivityLog.stories.tsx", "frontend/src/lib/components/ActivityLog/ActivityLog.tsx", "frontend/src/lib/components/ActivityLog/__mocks__/activityLogMocks.ts", "frontend/src/lib/components/ActivityLog/activityLogLogic.test.tsx", "frontend/src/lib/components/ActivityLog/activityLogLogic.tsx", "frontend/src/lib/components/ActivityLog/humanizeActivity.tsx", "frontend/src/lib/constants.tsx", "frontend/src/scenes/feature-flags/FeatureFlags.tsx", "frontend/src/scenes/feature-flags/activityDescriptions.tsx", "frontend/src/scenes/feature-flags/featureFlagsLogic.test.ts", "frontend/src/scenes/feature-flags/featureFlagsLogic.ts", "frontend/src/scenes/persons/Person.tsx", "frontend/src/scenes/persons/activityDescriptions.tsx", "frontend/src/scenes/persons/personsLogic.ts", "frontend/src/types.ts", "posthog/models/activity_logging/activity_log.py", "posthog/test/test_activity_logging.py"]}, {"commit_id": "3b64c1411a17478dfab0706938f8e7b23470464d", "commit_date": "Wed Mar 30 13:30:00 2022 -0700", "commit_message": "feat: add new LemonInput and use it in TaxonomicFilter (#9202)", "files_name": ["frontend/src/lib/components/LemonButton/LemonButton.scss", "frontend/src/lib/components/LemonInput/LemonInput.scss", "frontend/src/lib/components/LemonInput/LemonInput.stories.tsx", "frontend/src/lib/components/LemonInput/LemonInput.tsx", "frontend/src/lib/components/LemonInput/index.ts", "frontend/src/lib/components/LemonRow/LemonRow.scss", "frontend/src/lib/components/LemonRow/LemonRow.tsx", "frontend/src/lib/components/LemonSelect.tsx", "frontend/src/lib/components/LemonSwitch/LemonSwitch.scss", "frontend/src/lib/components/TaxonomicFilter/InfiniteList.scss", "frontend/src/lib/components/TaxonomicFilter/InfiniteList.tsx", "frontend/src/lib/components/TaxonomicFilter/InfiniteSelectResults.tsx", "frontend/src/lib/components/TaxonomicFilter/TaxonomicFilter.scss", "frontend/src/lib/components/TaxonomicFilter/TaxonomicFilter.tsx", "frontend/src/lib/components/TaxonomicPopup/TaxonomicPopup.tsx", "frontend/src/styles/global.scss", "frontend/src/vars.scss"]}, {"commit_id": "8253c588415b12febd47c2f191b1254ddd9e5461", "commit_date": "Wed Mar 30 21:14:44 2022 +0000", "commit_message": "chore: bump version to 1.34.0 (#9281)", "files_name": ["posthog/async_migrations/test/test_0002_events_sample_by.py", "posthog/async_migrations/test/test_0003_fill_person_distinct_id2.py", "posthog/async_migrations/test/test_0004_replicated_schema.py", "posthog/version.py", "versions.json"]}, {"commit_id": "ee05a333262b3b60e31133dd87d9dd0a1dc17c13", "commit_date": "Wed Mar 30 23:58:57 2022 +0200", "commit_message": "feat(toolbar): support wildcard urls on the toolbar (#9306)", "files_name": ["frontend/src/lib/components/DateFilter/DateFilter.tsx", "frontend/src/toolbar/elements/heatmapLogic.ts", "frontend/src/toolbar/stats/HeatmapStats.tsx", "frontend/src/toolbar/stats/currentPageLogic.ts"]}, {"commit_id": "eb1ea52974ce965a63b6dc77c0fc0c02722bfe98", "commit_date": "Thu Mar 31 10:13:22 2022 +0200", "commit_message": "refactor(utils): Remove old unused functions (#9308)", "files_name": ["posthog/utils.py"]}, {"commit_id": "72c1a159e98b13ea45dc556ed85dd6a6c0b7ed0a", "commit_date": "Thu Mar 31 03:04:12 2022 -0600", "commit_message": "feat(sso): Multitenant SAML (#9225)", "files_name": ["ee/api/authentication.py", "ee/api/test/fixtures/saml_login_response_alt_attribute_names", "ee/api/test/test_authentication.py", "ee/settings.py", "frontend/src/lib/constants.tsx", "frontend/src/scenes/authentication/Login.tsx", "frontend/src/scenes/authentication/loginLogic.ts", "frontend/src/scenes/organization/Settings/VerifiedDomains/AddDomainModal.tsx", "frontend/src/scenes/organization/Settings/VerifiedDomains/ConfigureSAMLModal.tsx", "frontend/src/scenes/organization/Settings/VerifiedDomains/SSOSelect.stories.tsx", "frontend/src/scenes/organization/Settings/VerifiedDomains/SSOSelect.tsx", "frontend/src/scenes/organization/Settings/VerifiedDomains/VerifiedDomains.tsx", "frontend/src/scenes/organization/Settings/VerifiedDomains/__snapshots__/verifiedDomainsLogic.test.ts.snap", "frontend/src/scenes/organization/Settings/VerifiedDomains/verifiedDomainsLogic.ts", "frontend/src/types.ts", "latest_migrations.manifest", "posthog/api/authentication.py", "posthog/api/organization_domain.py", "posthog/api/signup.py", "posthog/api/test/test_authentication.py", "posthog/api/test/test_preflight.py", "posthog/api/test/test_signup.py", "posthog/migrations/0224_saml_multitenant.py", "posthog/models/organization_domain.py", "posthog/settings/__init__.py", "posthog/urls.py", "posthog/utils.py", "posthog/views.py"]}, {"commit_id": "275e3c03bcbc5421e73f6c3e404c791f0ba2f4d1", "commit_date": "Thu Mar 31 12:33:14 2022 +0200", "commit_message": "fix(lemon): forward lemon input ref to input element (#9310)", "files_name": ["frontend/src/lib/components/LemonInput/LemonInput.tsx"]}, {"commit_id": "5a0dd27c6fffe03de65f45207402eb78250146ab", "commit_date": "Thu Mar 31 12:10:24 2022 +0000", "commit_message": "fix(activity-log): do not default to history tab (#9307)", "files_name": ["frontend/src/scenes/persons/personsLogic.ts"]}, {"commit_id": "41e2fca3675f180ccc29a48ce9d705926a51b8c3", "commit_date": "Thu Mar 31 14:28:11 2022 +0200", "commit_message": "fix(migration): fix organisation domain migration with whitelisted domains (#9315)", "files_name": ["posthog/migrations/0223_organizationdomain.py"]}, {"commit_id": "b6d5e8845970985499d6dc0aefad0fe871001bac", "commit_date": "Thu Mar 31 15:20:38 2022 +0200", "commit_message": "fix(cohorts): increase number of parallel calculations on cloud (#9282)", "files_name": ["task-definition.worker.json"]}, {"commit_id": "678b4d6df55bc83e0cdd3c489f4e1b65c0a161f0", "commit_date": "Thu Mar 31 15:26:15 2022 +0200", "commit_message": "feat(insights): remove insight hotkey support and dead code (#9309)", "files_name": ["cypress/integration/insights.js", "frontend/src/layout/navigation/navigationLogic.ts", "frontend/src/lib/hooks/useKeyboardHotkeys.tsx", "frontend/src/lib/utils/eventUsageLogic.ts", "frontend/src/scenes/insights/Insight.tsx", "frontend/src/scenes/insights/InsightsNav.tsx", "frontend/src/types.ts"]}, {"commit_id": "a91a373784ef96e7b9f496965a059ae4bfcf5bb1", "commit_date": "Thu Mar 31 17:41:22 2022 +0200", "commit_message": "feat(toolbar): remove toolbar cookie middleware (#9322)", "files_name": ["posthog/api/authentication.py", "posthog/api/decide.py", "posthog/middleware.py", "posthog/settings/web.py", "posthog/test/test_middleware.py"]}, {"commit_id": "4ddd7d71c96d7ea3d940a57338b4f0ffd3bf8ef2", "commit_date": "Thu Mar 31 15:50:44 2022 +0000", "commit_message": "chore: bump version 1.34.1 (#9319)", "files_name": ["posthog/version.py"]}, {"commit_id": "0425c420e462dbcfb770df588c5058c05752c1ac", "commit_date": "Fri Apr 1 14:07:44 2022 +0200", "commit_message": "fix(recordings): stricter types in logic (#9326)", "files_name": ["frontend/src/lib/utils/eventUsageLogic.ts", "frontend/src/scenes/session-recordings/player/metaLogic.ts", "frontend/src/scenes/session-recordings/sessionRecordingLogic.test.ts", "frontend/src/scenes/session-recordings/sessionRecordingLogic.ts", "frontend/src/types.ts"]}, {"commit_id": "bcd1e0bfefba859ce94dc73b0bd49eae5fce6ac8", "commit_date": "Fri Apr 1 14:46:49 2022 +0200", "commit_message": "fix(insights): pie chart breakdown color sort (#9325)", "files_name": ["frontend/src/scenes/trends/viz/ActionsPie.tsx"]}, {"commit_id": "498d7c4505587d72f6b7b0e2b08f219eb1111671", "commit_date": "Fri Apr 1 14:54:27 2022 +0200", "commit_message": "chore(storybook): homepage story (#9220)", "files_name": ["frontend/src/lib/api.mock.ts", "frontend/src/scenes/organization/Settings/VerifiedDomains/__snapshots__/verifiedDomainsLogic.test.ts.snap", "frontend/src/scenes/project-homepage/ProjectHomepage.stories.tsx"]}, {"commit_id": "35ef8b4d72a4c16c51942f551ee5425ac8f5f296", "commit_date": "Fri Apr 1 15:21:21 2022 +0200", "commit_message": "chore: bump version 1.34.2 (#9327)", "files_name": ["posthog/version.py"]}, {"commit_id": "2da49623785e8c3f93c9809e7b8df58334bb3bdd", "commit_date": "Fri Apr 1 16:04:09 2022 +0200", "commit_message": "feat(plugin-server): use cdn to download mmdb database (#9279)", "files_name": ["plugin-server/jest.setup.fetch-mock.js", "plugin-server/src/config/mmdb-constants.ts", "plugin-server/tests/mmdb.test.ts"]}, {"commit_id": "e960bf3b64c1d6fa70a5b3fd5ec1ed3d1519eddb", "commit_date": "Fri Apr 1 20:34:55 2022 +0100", "commit_message": "perf(funnels): aggregate by distinct id for funnels (#9329)", "files_name": ["ee/clickhouse/models/group.py", "ee/clickhouse/queries/funnels/funnel_event_query.py", "ee/clickhouse/queries/funnels/test/__snapshots__/test_funnel.ambr", "ee/clickhouse/queries/funnels/test/__snapshots__/test_funnel_correlation.ambr", "ee/clickhouse/queries/funnels/test/__snapshots__/test_funnel_strict.ambr", "ee/clickhouse/queries/funnels/test/__snapshots__/test_funnel_unordered.ambr", "ee/clickhouse/queries/funnels/test/test_funnel_strict.py", "ee/clickhouse/queries/retention/retention_event_query.py", "ee/clickhouse/queries/stickiness/stickiness_event_query.py", "ee/clickhouse/views/test/funnel/__snapshots__/test_clickhouse_funnel.ambr", "ee/clickhouse/views/test/funnel/__snapshots__/test_clickhouse_funnel_unordered.ambr"]}], "parents": [{"commit_id_before": "b88c4d1e3739efe350e74059ad9a7d0d9a49d10f", "url_before": "https://api.github.com/repos/PostHog/posthog/commits/b88c4d1e3739efe350e74059ad9a7d0d9a49d10f", "html_url_before": "https://github.com/PostHog/posthog/commit/b88c4d1e3739efe350e74059ad9a7d0d9a49d10f"}], "details": [{"raw_url": "https://github.com/PostHog/posthog/raw/859d8ed9ac7c5026db09714a26c85c1458abb038/posthog%2Fapi%2Fdecide.py", "code": "import re\nimport secrets\nfrom typing import Any, Dict, Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework import status\nfrom sentry_sdk import capture_exception\nfrom statshog.defaults.django import statsd\n\nfrom posthog.api.utils import get_token\nfrom posthog.exceptions import RequestParsingError, generate_exception_response\nfrom posthog.models import Team, User\nfrom posthog.models.feature_flag import get_overridden_feature_flags\nfrom posthog.utils import cors_response, load_data_from_request\n\nfrom .utils import get_project_id\n\n\ndef on_permitted_domain(team: Team, request: HttpRequest) -> bool:\n    origin = parse_domain(request.headers.get(\"Origin\"))\n    referer = parse_domain(request.headers.get(\"Referer\"))\n    return hostname_in_app_urls(team, origin) or hostname_in_app_urls(team, referer)\n\n\ndef hostname_in_app_urls(team: Team, hostname: Optional[str]) -> bool:\n    if not hostname:\n        return False\n\n    permitted_domains = [\"127.0.0.1\", \"localhost\"]\n\n    for url in team.app_urls:\n        host = parse_domain(url)\n        if host:\n            permitted_domains.append(host)\n\n    for permitted_domain in permitted_domains:\n        if \"*\" in permitted_domain:\n            pattern = \"^{}$\".format(re.escape(permitted_domain).replace(\"\\\\*\", \"(.*)\"))\n            if re.search(pattern, hostname):\n                return True\n        elif permitted_domain == hostname:\n            return True\n\n    return False\n\n\ndef decide_editor_params(request: HttpRequest) -> Tuple[Dict[str, Any], bool]:\n    if request.user.is_anonymous:\n        return {}, False\n\n    team = request.user.team\n    if team and on_permitted_domain(team, request):\n        response: Dict[str, Any] = {\"isAuthenticated\": True}\n        editor_params = {}\n\n        if request.user.toolbar_mode != \"disabled\":\n            editor_params[\"toolbarVersion\"] = \"toolbar\"\n\n        if settings.JS_URL:\n            editor_params[\"jsURL\"] = settings.JS_URL\n\n        response[\"editorParams\"] = editor_params\n        return response, not request.user.temporary_token\n    else:\n        return {}, False\n\n\ndef parse_domain(url: Any) -> Optional[str]:\n    return urlparse(url).hostname\n\n\n@csrf_exempt\ndef get_decide(request: HttpRequest):\n    response = {\n        \"config\": {\"enable_collect_everything\": True},\n        \"editorParams\": {},\n        \"isAuthenticated\": False,\n        \"supportedCompression\": [\"gzip\", \"gzip-js\", \"lz64\"],\n    }\n\n    if request.COOKIES.get(settings.TOOLBAR_COOKIE_NAME) and request.user.is_authenticated:\n        response[\"isAuthenticated\"] = True\n        if settings.JS_URL and request.user.toolbar_mode == User.TOOLBAR:\n            response[\"editorParams\"] = {\"jsURL\": settings.JS_URL, \"toolbarVersion\": \"toolbar\"}\n\n    if request.user.is_authenticated:\n        r, update_user_token = decide_editor_params(request)\n        response.update(r)\n        if update_user_token:\n            request.user.temporary_token = secrets.token_urlsafe(32)\n            request.user.save()\n\n    response[\"featureFlags\"] = []\n    response[\"sessionRecording\"] = False\n\n    if request.method == \"POST\":\n        try:\n            data = load_data_from_request(request)\n            api_version_string = request.GET.get(\"v\")\n            # NOTE: This does not support semantic versioning e.g. 2.1.0\n            api_version = int(api_version_string) if api_version_string else 1\n        except ValueError:\n            # default value added because of bug in posthog-js 1.19.0\n            # see https://sentry.io/organizations/posthog2/issues/2738865125/?project=1899813\n            # as a tombstone if the below statsd counter hasn't seen errors for N days\n            # then it is likely that no clients are running posthog-js 1.19.0\n            # and this defaulting could be removed\n            statsd.incr(\n                f\"posthog_cloud_decide_defaulted_api_version_on_value_error\",\n                tags={\"endpoint\": \"decide\", \"api_version_string\": api_version_string},\n            )\n            api_version = 2\n        except RequestParsingError as error:\n            capture_exception(error)  # We still capture this on Sentry to identify actual potential bugs\n            return cors_response(\n                request,\n                generate_exception_response(\"decide\", f\"Malformed request data: {error}\", code=\"malformed_data\"),\n            )\n\n        token = get_token(data, request)\n        team = Team.objects.get_team_from_token(token)\n        if team is None and token:\n            project_id = get_project_id(data, request)\n\n            if not project_id:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Project API key invalid. You can find your project API key in PostHog project settings.\",\n                        code=\"invalid_api_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n\n            user = User.objects.get_from_personal_api_key(token)\n            if user is None:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Invalid Personal API key.\",\n                        code=\"invalid_personal_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n            team = user.teams.get(id=project_id)\n\n        if team:\n            feature_flags = get_overridden_feature_flags(team.pk, data[\"distinct_id\"], data.get(\"groups\", {}))\n            response[\"featureFlags\"] = feature_flags if api_version >= 2 else list(feature_flags.keys())\n\n            if team.session_recording_opt_in and (on_permitted_domain(team, request) or len(team.app_urls) == 0):\n                response[\"sessionRecording\"] = {\"endpoint\": \"/s/\"}\n    statsd.incr(\n        f\"posthog_cloud_raw_endpoint_success\", tags={\"endpoint\": \"decide\",},\n    )\n    return cors_response(request, JsonResponse(response))\n", "code_before": "import re\nimport secrets\nfrom typing import Any, Dict, Optional, Tuple\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework import status\nfrom sentry_sdk import capture_exception\nfrom statshog.defaults.django import statsd\n\nfrom posthog.api.utils import get_token\nfrom posthog.exceptions import RequestParsingError, generate_exception_response\nfrom posthog.models import Team, User\nfrom posthog.models.feature_flag import get_overridden_feature_flags\nfrom posthog.utils import cors_response, load_data_from_request\n\nfrom .utils import get_project_id\n\n\ndef on_permitted_domain(team: Team, request: HttpRequest) -> bool:\n    permitted_domains = [\"127.0.0.1\", \"localhost\"]\n\n    for url in team.app_urls:\n        hostname = parse_domain(url)\n        if hostname:\n            permitted_domains.append(hostname)\n\n    origin = parse_domain(request.headers.get(\"Origin\"))\n    referer = parse_domain(request.headers.get(\"Referer\"))\n    for permitted_domain in permitted_domains:\n        if \"*\" in permitted_domain:\n            pattern = \"^{}$\".format(permitted_domain.replace(\".\", \"\\\\.\").replace(\"*\", \"(.*)\"))\n            if (origin and re.search(pattern, origin)) or (referer and re.search(pattern, referer)):\n                return True\n        else:\n            if permitted_domain == origin or permitted_domain == referer:\n                return True\n    return False\n\n\ndef decide_editor_params(request: HttpRequest) -> Tuple[Dict[str, Any], bool]:\n    if request.user.is_anonymous:\n        return {}, False\n\n    team = request.user.team\n    if team and on_permitted_domain(team, request):\n        response: Dict[str, Any] = {\"isAuthenticated\": True}\n        editor_params = {}\n\n        if request.user.toolbar_mode != \"disabled\":\n            editor_params[\"toolbarVersion\"] = \"toolbar\"\n\n        if settings.JS_URL:\n            editor_params[\"jsURL\"] = settings.JS_URL\n\n        response[\"editorParams\"] = editor_params\n        return response, not request.user.temporary_token\n    else:\n        return {}, False\n\n\ndef parse_domain(url: Any) -> Optional[str]:\n    return urlparse(url).hostname\n\n\n@csrf_exempt\ndef get_decide(request: HttpRequest):\n    response = {\n        \"config\": {\"enable_collect_everything\": True},\n        \"editorParams\": {},\n        \"isAuthenticated\": False,\n        \"supportedCompression\": [\"gzip\", \"gzip-js\", \"lz64\"],\n    }\n\n    if request.COOKIES.get(settings.TOOLBAR_COOKIE_NAME) and request.user.is_authenticated:\n        response[\"isAuthenticated\"] = True\n        if settings.JS_URL and request.user.toolbar_mode == User.TOOLBAR:\n            response[\"editorParams\"] = {\"jsURL\": settings.JS_URL, \"toolbarVersion\": \"toolbar\"}\n\n    if request.user.is_authenticated:\n        r, update_user_token = decide_editor_params(request)\n        response.update(r)\n        if update_user_token:\n            request.user.temporary_token = secrets.token_urlsafe(32)\n            request.user.save()\n\n    response[\"featureFlags\"] = []\n    response[\"sessionRecording\"] = False\n\n    if request.method == \"POST\":\n        try:\n            data = load_data_from_request(request)\n            api_version_string = request.GET.get(\"v\")\n            # NOTE: This does not support semantic versioning e.g. 2.1.0\n            api_version = int(api_version_string) if api_version_string else 1\n        except ValueError:\n            # default value added because of bug in posthog-js 1.19.0\n            # see https://sentry.io/organizations/posthog2/issues/2738865125/?project=1899813\n            # as a tombstone if the below statsd counter hasn't seen errors for N days\n            # then it is likely that no clients are running posthog-js 1.19.0\n            # and this defaulting could be removed\n            statsd.incr(\n                f\"posthog_cloud_decide_defaulted_api_version_on_value_error\",\n                tags={\"endpoint\": \"decide\", \"api_version_string\": api_version_string},\n            )\n            api_version = 2\n        except RequestParsingError as error:\n            capture_exception(error)  # We still capture this on Sentry to identify actual potential bugs\n            return cors_response(\n                request,\n                generate_exception_response(\"decide\", f\"Malformed request data: {error}\", code=\"malformed_data\"),\n            )\n\n        token = get_token(data, request)\n        team = Team.objects.get_team_from_token(token)\n        if team is None and token:\n            project_id = get_project_id(data, request)\n\n            if not project_id:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Project API key invalid. You can find your project API key in PostHog project settings.\",\n                        code=\"invalid_api_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n\n            user = User.objects.get_from_personal_api_key(token)\n            if user is None:\n                return cors_response(\n                    request,\n                    generate_exception_response(\n                        \"decide\",\n                        \"Invalid Personal API key.\",\n                        code=\"invalid_personal_key\",\n                        type=\"authentication_error\",\n                        status_code=status.HTTP_401_UNAUTHORIZED,\n                    ),\n                )\n            team = user.teams.get(id=project_id)\n\n        if team:\n            feature_flags = get_overridden_feature_flags(team.pk, data[\"distinct_id\"], data.get(\"groups\", {}))\n            response[\"featureFlags\"] = feature_flags if api_version >= 2 else list(feature_flags.keys())\n\n            if team.session_recording_opt_in and (on_permitted_domain(team, request) or len(team.app_urls) == 0):\n                response[\"sessionRecording\"] = {\"endpoint\": \"/s/\"}\n    statsd.incr(\n        f\"posthog_cloud_raw_endpoint_success\", tags={\"endpoint\": \"decide\",},\n    )\n    return cors_response(request, JsonResponse(response))\n", "patch": "@@ -20,23 +20,30 @@\n \n \n def on_permitted_domain(team: Team, request: HttpRequest) -> bool:\n+    origin = parse_domain(request.headers.get(\"Origin\"))\n+    referer = parse_domain(request.headers.get(\"Referer\"))\n+    return hostname_in_app_urls(team, origin) or hostname_in_app_urls(team, referer)\n+\n+\n+def hostname_in_app_urls(team: Team, hostname: Optional[str]) -> bool:\n+    if not hostname:\n+        return False\n+\n     permitted_domains = [\"127.0.0.1\", \"localhost\"]\n \n     for url in team.app_urls:\n-        hostname = parse_domain(url)\n-        if hostname:\n-            permitted_domains.append(hostname)\n+        host = parse_domain(url)\n+        if host:\n+            permitted_domains.append(host)\n \n-    origin = parse_domain(request.headers.get(\"Origin\"))\n-    referer = parse_domain(request.headers.get(\"Referer\"))\n     for permitted_domain in permitted_domains:\n         if \"*\" in permitted_domain:\n-            pattern = \"^{}$\".format(permitted_domain.replace(\".\", \"\\\\.\").replace(\"*\", \"(.*)\"))\n-            if (origin and re.search(pattern, origin)) or (referer and re.search(pattern, referer)):\n-                return True\n-        else:\n-            if permitted_domain == origin or permitted_domain == referer:\n+            pattern = \"^{}$\".format(re.escape(permitted_domain).replace(\"\\\\*\", \"(.*)\"))\n+            if re.search(pattern, hostname):\n                 return True\n+        elif permitted_domain == hostname:\n+            return True\n+\n     return False\n \n ", "file_path": "files/2022_4/230", "file_language": "py", "file_name": "posthog/api/decide.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/PostHog/posthog/raw/859d8ed9ac7c5026db09714a26c85c1458abb038/posthog%2Ftest%2Ftest_urls.py", "code": "import uuid\n\nfrom rest_framework import status\n\nfrom posthog.test.base import APIBaseTest\n\n\nclass TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        self.team.app_urls = [\"https://domain.com\", \"https://not.com\"]\n        self.team.save()\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://not-permitted.com\", HTTP_REFERER=\"https://not-permitted.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to a permitted domain.\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )\n", "code_before": "import uuid\n\nfrom rest_framework import status\n\nfrom posthog.test.base import APIBaseTest\n\n\nclass TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )\n", "patch": "@@ -56,6 +56,15 @@ def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n         self.assertEqual(response.status_code, status.HTTP_200_OK)\n \n     def test_authorize_and_redirect_domain(self):\n+        self.team.app_urls = [\"https://domain.com\", \"https://not.com\"]\n+        self.team.save()\n+\n+        response = self.client.get(\n+            \"/authorize_and_redirect/?redirect=https://not-permitted.com\", HTTP_REFERER=\"https://not-permitted.com\"\n+        )\n+        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n+        self.assertTrue(\"Can only redirect to a permitted domain.\" in str(response.content))\n+\n         response = self.client.get(\n             \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n         )", "file_path": "files/2022_4/231", "file_language": "py", "file_name": "posthog/test/test_urls.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )", "target": 0}], "function_after": [{"function": "class TestUrls(APIBaseTest):\n    def test_logout_temporary_token_reset(self):\n\n        # update temporary token\n        self.user.temporary_token = \"token123\"\n        self.user.save()\n\n        # logout\n        with self.settings(TEST=False):\n            response = self.client.post(\"/logout\", follow=True)\n            self.assertRedirects(response, \"/login\")\n\n        # no more token\n        self.user.refresh_from_db()\n        self.assertEqual(self.user.temporary_token, None)\n\n    def test_logged_out_user_is_redirected_to_login(self):\n        self.client.logout()\n\n        response = self.client.get(\"/events\")\n        self.assertRedirects(response, \"/login?next=/events\")\n\n        # Complex URL\n        response = self.client.get(\n            '/insights/new?interval=day&display=ActionsLineGraph&events=[{\"id\":\"$pageview\",\"name\":\"$pageview\",\"type\":\"events\",\"order\":0}]&properties=[]',\n        )\n\n        # Test that the URL is properly encoded to redirect the user to the final destination\n        self.assertRedirects(\n            response,\n            \"/login?next=/insights/new%3Finterval%3Dday%26display%3DActionsLineGraph%26events%3D%5B%257B%2522id%2522%3A%2522%24pageview%2522%2C%2522name%2522%3A%2522%24pageview%2522%2C%2522type%2522%3A%2522events%2522%2C%2522order%2522%3A0%257D%5D%26properties%3D%5B%5D\",\n            fetch_redirect_response=False,\n        )\n\n    def test_unauthenticated_routes_get_loaded_on_the_frontend(self):\n\n        self.client.logout()\n\n        response = self.client.get(\"/signup\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)  # no redirect\n\n        response = self.client.get(f\"/signup/{uuid.uuid4()}\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/preflight\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n        response = self.client.get(f\"/login\")\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n\n    def test_authorize_and_redirect_domain(self):\n        self.team.app_urls = [\"https://domain.com\", \"https://not.com\"]\n        self.team.save()\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://not-permitted.com\", HTTP_REFERER=\"https://not-permitted.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to a permitted domain.\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com\", HTTP_REFERER=\"https://not.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same domain as the referer: not.com\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=http://domain.com\", HTTP_REFERER=\"https://domain.com\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same scheme as the referer: https\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com:443\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: 443\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com:555\", HTTP_REFERER=\"https://domain.com/no-port\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertTrue(\"Can only redirect to the same port as the referer: no port in URL\" in str(response.content))\n\n        response = self.client.get(\n            \"/authorize_and_redirect/?redirect=https://domain.com/sdf\", HTTP_REFERER=\"https://domain.com/asd\"\n        )\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        # TODO: build frontend before backend tests, or find a way to mock the template\n        # self.assertContains(\n        #     response,\n        #     \"Do you want to give the PostHog Toolbar on <strong>https://domain.com/sdf</strong> access to your PostHog data?\",\n        # )", "target": 0}]}, {"raw_url": "https://github.com/PostHog/posthog/raw/859d8ed9ac7c5026db09714a26c85c1458abb038/posthog%2Furls.py", "code": "from typing import Any, Callable, List, Optional, cast\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom django.urls import URLPattern, include, path, re_path\nfrom django.views.decorators import csrf\nfrom django.views.decorators.csrf import csrf_exempt\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView\n\nfrom posthog.api import (\n    api_not_found,\n    authentication,\n    capture,\n    dashboard,\n    decide,\n    organizations_router,\n    project_dashboards_router,\n    projects_router,\n    router,\n    signup,\n    user,\n)\nfrom posthog.api.decide import hostname_in_app_urls\nfrom posthog.demo import demo\nfrom posthog.models import User\n\nfrom .utils import render_template\nfrom .views import health, login_required, preflight_check, robots_txt, security_txt, sso_login, stats\n\nee_urlpatterns: List[Any] = []\ntry:\n    from ee.urls import extend_api_router\n    from ee.urls import urlpatterns as ee_urlpatterns\nexcept ImportError:\n    pass\nelse:\n    extend_api_router(router, projects_router=projects_router, project_dashboards_router=project_dashboards_router)\n\n\ntry:\n    # See https://github.com/PostHog/posthog-cloud/blob/master/multi_tenancy/router.py\n    from multi_tenancy.router import extend_api_router as extend_api_router_cloud  # noqa\nexcept ImportError:\n    pass\nelse:\n    extend_api_router_cloud(router, organizations_router=organizations_router, projects_router=projects_router)\n\n\n@csrf.ensure_csrf_cookie\ndef home(request, *args, **kwargs):\n    return render_template(\"index.html\", request)\n\n\ndef authorize_and_redirect(request: HttpRequest) -> HttpResponse:\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    current_team = cast(User, request.user).team\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if not current_team or not hostname_in_app_urls(current_team, redirect_url.hostname):\n        return HttpResponse(f\"Can only redirect to a permitted domain.\", status=400)\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )\n\n\ndef opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore\n\n\nurlpatterns = [\n    path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n    # Optional UI:\n    path(\"api/schema/swagger-ui/\", SpectacularSwaggerView.as_view(url_name=\"schema\"), name=\"swagger-ui\"),\n    path(\"api/schema/redoc/\", SpectacularRedocView.as_view(url_name=\"schema\"), name=\"redoc\"),\n    # Health check probe endpoints for K8s\n    # NOTE: We have _health, livez, and _readyz. _health is deprecated and\n    # is only included for compatability with old installations. For new\n    # operations livez and readyz should be used.\n    opt_slash_path(\"_health\", health),\n    opt_slash_path(\"_stats\", stats),\n    opt_slash_path(\"_preflight\", preflight_check),\n    # ee\n    *ee_urlpatterns,\n    # api\n    path(\"api/\", include(router.urls)),\n    opt_slash_path(\"api/user/redirect_to_site\", user.redirect_to_site),\n    opt_slash_path(\"api/user/test_slack_webhook\", user.test_slack_webhook),\n    opt_slash_path(\"api/signup\", signup.SignupViewset.as_view()),\n    opt_slash_path(\"api/social_signup\", signup.SocialSignupViewset.as_view()),\n    path(\"api/signup/<str:invite_id>/\", signup.InviteSignupViewset.as_view()),\n    path(\n        \"api/reset/<str:user_uuid>/\",\n        authentication.PasswordResetCompleteViewSet.as_view({\"get\": \"retrieve\", \"post\": \"create\"}),\n    ),\n    re_path(r\"^api.+\", api_not_found),\n    path(\"authorize_and_redirect/\", login_required(authorize_and_redirect)),\n    path(\"shared_dashboard/<str:share_token>\", dashboard.shared_dashboard),\n    re_path(r\"^demo.*\", login_required(demo)),\n    # ingestion\n    opt_slash_path(\"decide\", decide.get_decide),\n    opt_slash_path(\"e\", capture.get_event),\n    opt_slash_path(\"engage\", capture.get_event),\n    opt_slash_path(\"track\", capture.get_event),\n    opt_slash_path(\"capture\", capture.get_event),\n    opt_slash_path(\"batch\", capture.get_event),\n    opt_slash_path(\"s\", capture.get_event),  # session recordings\n    opt_slash_path(\"robots.txt\", robots_txt),\n    opt_slash_path(\".well-known/security.txt\", security_txt),\n    # auth\n    path(\"logout\", authentication.logout, name=\"login\"),\n    path(\"signup/finish/\", signup.finish_social_signup, name=\"signup_finish\"),\n    path(\n        \"login/<str:backend>/\", sso_login, name=\"social_begin\"\n    ),  # overrides from `social_django.urls` to validate proper license\n    path(\"\", include(\"social_django.urls\", namespace=\"social\")),\n]\n\nif settings.TEST:\n\n    # Used in posthog-js e2e tests\n    @csrf_exempt\n    def delete_events(request):\n        from ee.clickhouse.sql.events import TRUNCATE_EVENTS_TABLE_SQL\n        from posthog.client import sync_execute\n\n        sync_execute(TRUNCATE_EVENTS_TABLE_SQL())\n        return HttpResponse()\n\n    urlpatterns.append(path(\"delete_events/\", delete_events))\n\n\n# Routes added individually to remove login requirement\nfrontend_unauthenticated_routes = [\n    \"preflight\",\n    \"signup\",\n    r\"signup\\/[A-Za-z0-9\\-]*\",\n    \"reset\",\n    \"organization/billing/subscribed\",\n    \"login\",\n]\nfor route in frontend_unauthenticated_routes:\n    urlpatterns.append(re_path(route, home))\n\nurlpatterns.append(re_path(r\"^.*\", login_required(home)))\n", "code_before": "from typing import Any, Callable, List, Optional\nfrom urllib.parse import urlparse\n\nfrom django.conf import settings\nfrom django.http import HttpResponse\nfrom django.urls import URLPattern, include, path, re_path\nfrom django.views.decorators import csrf\nfrom django.views.decorators.csrf import csrf_exempt\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView\n\nfrom posthog.api import (\n    api_not_found,\n    authentication,\n    capture,\n    dashboard,\n    decide,\n    organizations_router,\n    project_dashboards_router,\n    projects_router,\n    router,\n    signup,\n    user,\n)\nfrom posthog.demo import demo\n\nfrom .utils import render_template\nfrom .views import health, login_required, preflight_check, robots_txt, security_txt, sso_login, stats\n\nee_urlpatterns: List[Any] = []\ntry:\n    from ee.urls import extend_api_router\n    from ee.urls import urlpatterns as ee_urlpatterns\nexcept ImportError:\n    pass\nelse:\n    extend_api_router(router, projects_router=projects_router, project_dashboards_router=project_dashboards_router)\n\n\ntry:\n    # See https://github.com/PostHog/posthog-cloud/blob/master/multi_tenancy/router.py\n    from multi_tenancy.router import extend_api_router as extend_api_router_cloud  # noqa\nexcept ImportError:\n    pass\nelse:\n    extend_api_router_cloud(router, organizations_router=organizations_router, projects_router=projects_router)\n\n\n@csrf.ensure_csrf_cookie\ndef home(request, *args, **kwargs):\n    return render_template(\"index.html\", request)\n\n\ndef authorize_and_redirect(request):\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )\n\n\ndef opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore\n\n\nurlpatterns = [\n    path(\"api/schema/\", SpectacularAPIView.as_view(), name=\"schema\"),\n    # Optional UI:\n    path(\"api/schema/swagger-ui/\", SpectacularSwaggerView.as_view(url_name=\"schema\"), name=\"swagger-ui\"),\n    path(\"api/schema/redoc/\", SpectacularRedocView.as_view(url_name=\"schema\"), name=\"redoc\"),\n    # Health check probe endpoints for K8s\n    # NOTE: We have _health, livez, and _readyz. _health is deprecated and\n    # is only included for compatability with old installations. For new\n    # operations livez and readyz should be used.\n    opt_slash_path(\"_health\", health),\n    opt_slash_path(\"_stats\", stats),\n    opt_slash_path(\"_preflight\", preflight_check),\n    # ee\n    *ee_urlpatterns,\n    # api\n    path(\"api/\", include(router.urls)),\n    opt_slash_path(\"api/user/redirect_to_site\", user.redirect_to_site),\n    opt_slash_path(\"api/user/test_slack_webhook\", user.test_slack_webhook),\n    opt_slash_path(\"api/signup\", signup.SignupViewset.as_view()),\n    opt_slash_path(\"api/social_signup\", signup.SocialSignupViewset.as_view()),\n    path(\"api/signup/<str:invite_id>/\", signup.InviteSignupViewset.as_view()),\n    path(\n        \"api/reset/<str:user_uuid>/\",\n        authentication.PasswordResetCompleteViewSet.as_view({\"get\": \"retrieve\", \"post\": \"create\"}),\n    ),\n    re_path(r\"^api.+\", api_not_found),\n    path(\"authorize_and_redirect/\", login_required(authorize_and_redirect)),\n    path(\"shared_dashboard/<str:share_token>\", dashboard.shared_dashboard),\n    re_path(r\"^demo.*\", login_required(demo)),\n    # ingestion\n    opt_slash_path(\"decide\", decide.get_decide),\n    opt_slash_path(\"e\", capture.get_event),\n    opt_slash_path(\"engage\", capture.get_event),\n    opt_slash_path(\"track\", capture.get_event),\n    opt_slash_path(\"capture\", capture.get_event),\n    opt_slash_path(\"batch\", capture.get_event),\n    opt_slash_path(\"s\", capture.get_event),  # session recordings\n    opt_slash_path(\"robots.txt\", robots_txt),\n    opt_slash_path(\".well-known/security.txt\", security_txt),\n    # auth\n    path(\"logout\", authentication.logout, name=\"login\"),\n    path(\"signup/finish/\", signup.finish_social_signup, name=\"signup_finish\"),\n    path(\n        \"login/<str:backend>/\", sso_login, name=\"social_begin\"\n    ),  # overrides from `social_django.urls` to validate proper license\n    path(\"\", include(\"social_django.urls\", namespace=\"social\")),\n]\n\nif settings.TEST:\n\n    # Used in posthog-js e2e tests\n    @csrf_exempt\n    def delete_events(request):\n        from ee.clickhouse.sql.events import TRUNCATE_EVENTS_TABLE_SQL\n        from posthog.client import sync_execute\n\n        sync_execute(TRUNCATE_EVENTS_TABLE_SQL())\n        return HttpResponse()\n\n    urlpatterns.append(path(\"delete_events/\", delete_events))\n\n\n# Routes added individually to remove login requirement\nfrontend_unauthenticated_routes = [\n    \"preflight\",\n    \"signup\",\n    r\"signup\\/[A-Za-z0-9\\-]*\",\n    \"reset\",\n    \"organization/billing/subscribed\",\n    \"login\",\n]\nfor route in frontend_unauthenticated_routes:\n    urlpatterns.append(re_path(route, home))\n\nurlpatterns.append(re_path(r\"^.*\", login_required(home)))\n", "patch": "@@ -1,8 +1,8 @@\n-from typing import Any, Callable, List, Optional\n+from typing import Any, Callable, List, Optional, cast\n from urllib.parse import urlparse\n \n from django.conf import settings\n-from django.http import HttpResponse\n+from django.http import HttpRequest, HttpResponse\n from django.urls import URLPattern, include, path, re_path\n from django.views.decorators import csrf\n from django.views.decorators.csrf import csrf_exempt\n@@ -21,7 +21,9 @@\n     signup,\n     user,\n )\n+from posthog.api.decide import hostname_in_app_urls\n from posthog.demo import demo\n+from posthog.models import User\n \n from .utils import render_template\n from .views import health, login_required, preflight_check, robots_txt, security_txt, sso_login, stats\n@@ -50,15 +52,19 @@ def home(request, *args, **kwargs):\n     return render_template(\"index.html\", request)\n \n \n-def authorize_and_redirect(request):\n+def authorize_and_redirect(request: HttpRequest) -> HttpResponse:\n     if not request.GET.get(\"redirect\"):\n         return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n     if not request.META.get(\"HTTP_REFERER\"):\n         return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n \n+    current_team = cast(User, request.user).team\n     referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n     redirect_url = urlparse(request.GET[\"redirect\"])\n \n+    if not current_team or not hostname_in_app_urls(current_team, redirect_url.hostname):\n+        return HttpResponse(f\"Can only redirect to a permitted domain.\", status=400)\n+\n     if referer_url.hostname != redirect_url.hostname:\n         return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n ", "file_path": "files/2022_4/232", "file_language": "py", "file_name": "posthog/urls.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.django.security.audit.xss.direct-use-of-httpresponse.direct-use-of-httpresponse         \n          Detected data rendered directly to the end user via 'HttpResponse' or a similar object. This\n          bypasses Django's built-in cross-site scripting (XSS) defenses and could result in an XSS   \n          vulnerability. Use Django's template engine to safely render HTML.                          \n          Details: https://sg.run/EknN                                                                \n\n           63\u2506 return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\",      \n  status=400)                                                                                                           "]]}, "target": 1, "function_before": [{"function": "def authorize_and_redirect(request):\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )", "target": 1, "line": "@@  -50,15 +52,19  @@ def home(request, *args, **kwargs):\n     return render_template(\"index.html\", request)\n \n \n-def authorize_and_redirect(request):\n+def authorize_and_redirect(request: HttpRequest) -> HttpResponse:\n     if not request.GET.get(\"redirect\"):\n         return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n     if not request.META.get(\"HTTP_REFERER\"):\n         return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n \n+    current_team = cast(User, request.user).team\n     referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n     redirect_url = urlparse(request.GET[\"redirect\"])\n \n+    if not current_team or not hostname_in_app_urls(current_team, redirect_url.hostname):\n+        return HttpResponse(f\"Can only redirect to a permitted domain.\", status=400)\n+\n     if referer_url.hostname != redirect_url.hostname:\n         return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n "}, {"function": "def opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore", "target": 0}], "function_after": [{"function": "def authorize_and_redirect(request: HttpRequest) -> HttpResponse:\n    if not request.GET.get(\"redirect\"):\n        return HttpResponse(\"You need to pass a url to ?redirect=\", status=401)\n    if not request.META.get(\"HTTP_REFERER\"):\n        return HttpResponse('You need to make a request that includes the \"Referer\" header.', status=400)\n\n    current_team = cast(User, request.user).team\n    referer_url = urlparse(request.META[\"HTTP_REFERER\"])\n    redirect_url = urlparse(request.GET[\"redirect\"])\n\n    if not current_team or not hostname_in_app_urls(current_team, redirect_url.hostname):\n        return HttpResponse(f\"Can only redirect to a permitted domain.\", status=400)\n\n    if referer_url.hostname != redirect_url.hostname:\n        return HttpResponse(f\"Can only redirect to the same domain as the referer: {referer_url.hostname}\", status=400)\n\n    if referer_url.scheme != redirect_url.scheme:\n        return HttpResponse(f\"Can only redirect to the same scheme as the referer: {referer_url.scheme}\", status=400)\n\n    if referer_url.port != redirect_url.port:\n        return HttpResponse(\n            f\"Can only redirect to the same port as the referer: {referer_url.port or 'no port in URL'}\", status=400\n        )\n\n    return render_template(\n        \"authorize_and_redirect.html\",\n        request=request,\n        context={\"domain\": redirect_url.hostname, \"redirect_url\": request.GET[\"redirect\"]},\n    )", "target": 0}, {"function": "def opt_slash_path(route: str, view: Callable, name: Optional[str] = None) -> URLPattern:\n    \"\"\"Catches path with or without trailing slash, taking into account query param and hash.\"\"\"\n    # Ignoring the type because while name can be optional on re_path, mypy doesn't agree\n    return re_path(fr\"^{route}/?(?:[?#].*)?$\", view, name=name)  # type: ignore", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
