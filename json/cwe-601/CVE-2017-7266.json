{"index": 1696, "cve_id": "CVE-2017-7266", "cwe_id": ["CWE-601"], "cve_language": "Python", "cve_description": "Netflix Security Monkey before 0.8.0 has an Open Redirect. The logout functionality accepted the \"next\" parameter which then redirects to any domain irrespective of the Host header.", "cvss": "6.1", "publish_date": "March 26, 2017", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "3b4da13efabb05970c80f464a50d3c1c12262466", "commit_message": "Replacing Flask-Security with Flask-Security-Fork. Removing some explicit dependencies to rely on flask-security-fork dependencies. SSO will use flask-security login_user instead of flask-login so that security_trackable works. Replacing current_user.is_authenticated() method with property so  we can use a newer version of flask-login. (#482)", "commit_date": "2016-12-30T07:33:29Z", "project": "netflix/security_monkey", "url": "https://api.github.com/repos/Netflix/security_monkey/commits/3b4da13efabb05970c80f464a50d3c1c12262466", "html_url": "https://github.com/Netflix/security_monkey/commit/3b4da13efabb05970c80f464a50d3c1c12262466", "windows_before": [{"commit_id": "da8c81e53c519907691c13dab1ccf16eae4db622", "commit_date": "Thu Dec 29 14:39:10 2016 -0700", "commit_message": "Fixing a couple dart warnings. (#481)", "files_name": ["dart/lib/component/revision_table_component/revision_table_component.dart", "dart/lib/component/search_bar_component/search_bar_component.dart"]}, {"commit_id": "a83fea9c396fb83b2ce3bfafa064564aced09100", "commit_date": "Thu Dec 29 14:20:43 2016 -0700", "commit_message": "Making gunicorn an optional import to help support dev on Windows. (#480)", "files_name": ["manage.py"]}, {"commit_id": "4042ecd96b33c22eeda445ddcc2acdac78d0fa7f", "commit_date": "Thu Dec 29 13:27:23 2016 -0700", "commit_message": "Fixing manage.py::amazon_accounts() and adding delete_unjustified_issues() (#479)", "files_name": ["manage.py"]}, {"commit_id": "ff0517cab6da3e3b4afc708eddab846346ea89ee", "commit_date": "Fri Dec 9 10:18:28 2016 -0800", "commit_message": "Update aws_accounts.json (#476)", "files_name": ["data/aws_accounts.json"]}, {"commit_id": "265ac92dae427bc6ed6981c7dcf228eae1ffb5b0", "commit_date": "Thu Dec 8 15:27:47 2016 -0800", "commit_message": "Adding cloudtrail:gettrailstatus to docs (#474)", "files_name": ["docs/changelog.rst", "docs/configuration.rst", "docs/quickstart.rst", "scripts/secmonkey_role_setup.py"]}, {"commit_id": "0371c8921715cff8c4c08bbabbc26e8ae9d98b2c", "commit_date": "Thu Dec 8 13:25:51 2016 -0800", "commit_message": "Updating UI Reports Dropdown (#473) \u2614", "files_name": ["dart/web/ui.html"]}, {"commit_id": "a3dde82691a32094c0aaf4c7f0d65c9923f82c7d", "commit_date": "Thu Dec 8 13:24:53 2016 -0800", "commit_message": "Updating KMS Auditor to extract AWS account IDs from the condition block (#472) \ud83d\udd11", "files_name": ["security_monkey/auditors/kms.py"]}, {"commit_id": "3174acd38bc8b8f2c6b980c8caeb2657683e587e", "commit_date": "Thu Dec 8 13:24:09 2016 -0800", "commit_message": "Added cloudtrail status to watcher. Generates an audit issue when clo\u2026 (#470)", "files_name": ["security_monkey/auditors/cloudtrail.py", "security_monkey/watchers/cloud_trail.py"]}, {"commit_id": "83ecbb1eb18c03fa78ff388b06d8a508f6b0d554", "commit_date": "Wed Dec 7 15:31:11 2016 -0800", "commit_message": "Potentially fixing the kms principal-service problem. Issue #468 (#471)", "files_name": ["security_monkey/auditors/kms.py"]}, {"commit_id": "1c32af888fd485564d6176a4257060bc0ed5933b", "commit_date": "Wed Dec 7 15:30:35 2016 -0800", "commit_message": "Further fixing the IAM User auditor to work with the new IAM User format. (#469)", "files_name": ["security_monkey/auditors/iam/iam_user.py"]}, {"commit_id": "31de86f9cf1a82a77eb98f6c54fa67a1f53cdf5b", "commit_date": "Wed Dec 7 10:31:47 2016 -0800", "commit_message": "Add support for filtering by item score. (#467) \ud83d\udcaf", "files_name": ["dart/lib/component/item_table_component/item_table_component.dart", "dart/lib/component/search_bar_component/search_bar_component.dart", "dart/lib/component/search_bar_component/search_bar_component.html", "dart/lib/routing/securitymonkey_router.dart", "security_monkey/datastore.py", "security_monkey/views/item.py"]}, {"commit_id": "e861f366237a6efa3651a31adcb5ef0a1e116abb", "commit_date": "Mon Dec 5 12:54:50 2016 -0800", "commit_message": "Moving the Search page back to default and creating a hyperlink to the dashboard. (#464)", "files_name": ["dart/lib/routing/securitymonkey_router.dart", "dart/web/ui.html"]}, {"commit_id": "fa49ddb970c92cbc4b16ebb52cdd0d49dfe732c0", "commit_date": "Mon Dec 5 11:32:55 2016 -0800", "commit_message": "Updating ephemerals for IAM User. (#463)", "files_name": ["security_monkey/watchers/iam/iam_user.py"]}, {"commit_id": "499e6383f1defa759f2e7b365c9b486f4f5b37ee", "commit_date": "Mon Dec 5 11:32:40 2016 -0800", "commit_message": "Fixing IAM Role/IAM User auditors for new cloudaux format. (#462)", "files_name": ["security_monkey/auditors/iam/iam_policy.py", "security_monkey/auditors/iam/iam_role.py", "security_monkey/auditors/iam/iam_user.py", "security_monkey/tests/test_iam.py"]}, {"commit_id": "587f460697d9e0a71d4e7bff8cd2fb6c41bafbc7", "commit_date": "Mon Dec 5 11:32:27 2016 -0800", "commit_message": "New S3 Permissions and Auditor Fixes (#461)", "files_name": ["docs/changelog.rst", "docs/configuration.rst", "docs/quickstart.rst", "security_monkey/auditors/s3.py"]}, {"commit_id": "18b96852776ec4d6c2c9b9bf95c6f7bf522ee462", "commit_date": "Fri Dec 2 19:58:18 2016 -0800", "commit_message": "Added cloudtrail multiregion audit check (#459) \ud83d\uddfa", "files_name": ["security_monkey/auditors/cloudtrail.py"]}, {"commit_id": "7a402603151896a6e7785c90588a1ef693e5f4c4", "commit_date": "Fri Dec 2 18:01:58 2016 -0800", "commit_message": "S3 Analytics support (#460)", "files_name": ["docs/configuration.rst", "docs/quickstart.rst", "setup.py"]}, {"commit_id": "3cfc540771147d9ccab7288724559b9df4607aec", "commit_date": "Fri Dec 2 11:36:31 2016 -0800", "commit_message": "Preparation for v0.8.0", "files_name": ["Dockerfile", "dart/pubspec.yaml", "docker/nginx/Dockerfile", "docs/api/index.rst", "docs/authors.rst", "docs/changelog.rst", "setup.py"]}, {"commit_id": "11896c788b250748c31596e75d68e5429b43c43c", "commit_date": "Thu Dec 1 10:54:03 2016 -0500", "commit_message": "Increase issue note size (#456) \ud83c\udfb5", "files_name": ["migrations/versions/1c847ae1209a_.py", "security_monkey/auditor.py", "security_monkey/datastore.py"]}, {"commit_id": "508aa6716f4c638230bd263014b42694ab644924", "commit_date": "Thu Dec 1 10:52:41 2016 -0500", "commit_message": "[secmonkey] Add dashboard (#455) \ud83d\udcc8", "files_name": ["dart/lib/component/dashboard_component/dashboard_component.dart", "dart/lib/component/dashboard_component/dashboard_component.html", "dart/lib/routing/securitymonkey_router.dart", "dart/lib/security_monkey.dart", "dart/web/ui.html", "dart/web/views/dashboard.html", "security_monkey/views/item.py", "security_monkey/views/item_issue.py"]}, {"commit_id": "375b367a0b751ad938aab6cd5746ea003fc0bf51", "commit_date": "Tue Nov 29 09:51:00 2016 -0800", "commit_message": "Merge pull request #454 from mikegrima/s3_permissions", "files_name": ["0c7831558afff13468e596be2568a32e0e9731e3 - Tue Nov 29 09:34:57 2016 -0800 : Updated S3 Permissions to reflect latest changes to cloudaux.", "docs/configuration.rst", "docs/quickstart.rst", "setup.py"]}, {"commit_id": "ea952b011ba85cc0e0a79d62713e00cf509c0c05", "commit_date": "Mon Nov 21 15:24:54 2016 -0800", "commit_message": "Fixing two policy diff cases. (#453) \ud83d\udec1", "files_name": ["security_monkey/common/PolicyDiff.py"]}, {"commit_id": "a088c7ecfc66ad9b82902ace5f91650c284cba58", "commit_date": "Mon Nov 21 15:01:54 2016 -0800", "commit_message": "Refactoring s3 watcher to use Netflix CloudAux (#449) \u26c8\ud83c\udf2a", "files_name": ["security_monkey/decorators.py", "security_monkey/watchers/s3.py", "setup.py"]}, {"commit_id": "3da5d101c00d97231d037f28a4360a6546b4a5e1", "commit_date": "Sun Nov 20 01:00:27 2016 -0800", "commit_message": "Adding tests for the policydiff module. (#452) \ud83d\udc89", "files_name": ["security_monkey/common/PolicyDiff.py", "security_monkey/tests/test_policydiff.py"]}, {"commit_id": "3184ef3740121f6b19e1b38c29ecb7af2b9dd9ca", "commit_date": "Fri Nov 18 11:30:33 2016 -0800", "commit_message": "Organizing badges into master/dev branches", "files_name": ["README.rst"]}, {"commit_id": "ca1f52a3d3af33eb0fc92bc45bfb228da7477191", "commit_date": "Fri Nov 18 11:10:49 2016 -0800", "commit_message": "Adding coveralls badge to README.rst", "files_name": ["README.rst"]}, {"commit_id": "fd464bdf48dc308e1b86c0af8994e0aeba22229a", "commit_date": "Fri Nov 18 11:06:48 2016 -0800", "commit_message": "[WIP] Coverage (#451) \ud83d\udc56\ud83d\udc55", "files_name": [".coveragerc", ".travis.yml"]}, {"commit_id": "43e40de46ed8b0d32c48d5082483a21d041e99c9", "commit_date": "Fri Nov 18 18:30:36 2016 +0000", "commit_message": "Removing reference to the removed item.cloud field.", "files_name": ["security_monkey/tests/views/test_view_item.py"]}, {"commit_id": "99d5c9ebc03deb660e456e46bbdb56e4d536019c", "commit_date": "Fri Nov 18 13:18:01 2016 -0500", "commit_message": "Make misfire grace time and reporter start time configurable (#445) \ud83d\udd70 \ud83d\udd25", "files_name": ["env-config/config-deploy.py", "security_monkey/scheduler.py"]}, {"commit_id": "798676e2e2a7c846e0ed28468b01e44bb1b4998a", "commit_date": "Fri Nov 18 13:14:02 2016 -0500", "commit_message": "[secmonkey] Refactor rdsdbcluster array params (#447) \ud83d\udcf6", "files_name": ["security_monkey/watchers/rds/rds_db_cluster.py"]}, {"commit_id": "6f1e49b842b3917f851d2fd357c3b6a598e0ad7e", "commit_date": "Fri Nov 18 13:12:11 2016 -0500", "commit_message": "[secmonkey] Fix item 'first_seen' query (#446) \ud83d\udc53", "files_name": ["security_monkey/tests/__init__.py", "security_monkey/tests/views/__init__.py", "security_monkey/tests/views/test_view_item.py", "security_monkey/views/item.py"]}, {"commit_id": "37393df812baf564b10b681d2a043dcc22d18a3d", "commit_date": "Fri Nov 18 10:10:50 2016 -0800", "commit_message": "Moved test & onelogin requirements to the setup.py extras_require section. (#450) \ud83d\udc19", "files_name": [".travis.yml", "security_monkey/sso/views.py", "setup.py"]}, {"commit_id": "7f8c7f7902208fdb007ddf541de358c4411603f4", "commit_date": "Wed Nov 16 16:28:41 2016 -0800", "commit_message": "Merge pull request #444 from Bridgewater/7871_appscheduler_logging", "files_name": ["eb9288bc2b96224a1529f121811a4f6222e0151a - Wed Nov 16 16:23:30 2016 -0800 : Merge pull request #448 from Bridgewater/7876_store_exception_bug", "4b948f8be8282a543cb383db07033807a65ef123 - Wed Nov 16 16:13:13 2016 -0800 : Adding index to region. Dropping unused item.cloud. (#442) \ud83d\udcc7", "migrations/versions/2ce75615b24d_.py", "security_monkey/datastore.py", "security_monkey/tests/test_exception_logging.py"]}, {"commit_id": "e40cc8a552747ca7089c04f64b8858e00f3cb9bf", "commit_date": "Wed Nov 16 14:20:13 2016 -0800", "commit_message": "Adding optional arg to record_exception decorator", "files_name": ["security_monkey/decorators.py", "security_monkey/watchers/iam/iam_role.py", "security_monkey/watchers/iam/iam_user.py"]}, {"commit_id": "26f322a7ee6554335578ec31f7d74d6f1b6c50f0", "commit_date": "Wed Nov 16 13:42:20 2016 -0800", "commit_message": "Views now sort configs for the web ui.", "files_name": ["security_monkey/common/PolicyDiff.py", "security_monkey/views/item.py", "security_monkey/views/revision.py"]}, {"commit_id": "5f7ecc9097298e44d5819edd461e7e604eeee072", "commit_date": "Wed Nov 16 13:40:17 2016 -0800", "commit_message": "Updating record_exception decorator to pop relevant kwargs before calling wrapped function.", "files_name": ["security_monkey/decorators.py", "security_monkey/watchers/iam/iam_role.py", "security_monkey/watchers/iam/iam_user.py"]}, {"commit_id": "4a4bc13e1b5a52eb3eb6cc2acedf7a4b8f6dd778", "commit_date": "Thu Sep 22 17:35:49 2016 -0400", "commit_message": "Fix exception logging in store_exception", "files_name": ["security_monkey/datastore.py", "security_monkey/tests/test_exception_logging.py"]}, {"commit_id": "c515af5c765ea14047dc83cafbf6df940cb212b0", "commit_date": "Mon Sep 12 17:19:26 2016 -0400", "commit_message": "[secmonkey] Adds exception logging listener for appscheduler", "files_name": ["security_monkey/scheduler.py"]}, {"commit_id": "6e6917c241a1c0b414dc5d79fe96ffb638866054", "commit_date": "Tue Nov 15 14:07:37 2016 -0800", "commit_message": "Adding/moving badges on README.rst", "files_name": ["README.rst"]}, {"commit_id": "714e46ebad08fa25e009996645042c2958d008ef", "commit_date": "Tue Nov 15 13:35:58 2016 -0800", "commit_message": "Auditor ChangeItems now receive ARN (#441) \ud83d\udd28", "files_name": ["security_monkey/auditor.py"]}, {"commit_id": "c4772c67d4c7cb46242397b612ca786b8e45ba9a", "commit_date": "Tue Nov 15 13:35:25 2016 -0800", "commit_message": "Replacing botor lib with Netflix cloudaux. (#439) \ud83c\udf2a", "files_name": ["security_monkey/watchers/iam/iam_role.py", "security_monkey/watchers/iam/iam_user.py", "security_monkey/watchers/route53.py", "setup.py"]}, {"commit_id": "6848e71cddf170285b152dff3da6c795647fa00f", "commit_date": "Tue Nov 15 16:34:35 2016 -0500", "commit_message": "Add support for custom account metadata (#408) \ud83d\udcc3", "files_name": ["dart/lib/component/account_view_component/account_view_component.dart", "dart/lib/component/account_view_component/account_view_component.html", "dart/lib/component/settings_component/settings_component.html", "dart/lib/model/Account.dart", "dart/lib/model/account_config.dart", "dart/lib/model/custom_field_config.dart", "dart/lib/model/hammock_config.dart", "dart/lib/security_monkey.dart"]}], "windows_after": [{"commit_id": "198ed04306311415881469c891029b6597358a73", "commit_date": "Fri Dec 30 23:47:16 2016 -0700", "commit_message": "Fixes issue 477. Replaces explicit check for {} with a simple bool check. (#483)", "files_name": ["security_monkey/auditors/iam/iam_user.py"]}, {"commit_id": "5933ebadf7f44d84f248a2a4a5eb00df0d7a380f", "commit_date": "Wed Jan 4 10:53:54 2017 -0700", "commit_message": "Bumping jinja2 to >= 2.8.1. We should not be impacted by the format string vuln in previou versions. (#484)", "files_name": ["setup.py"]}, {"commit_id": "0ef659610e29b5a3c684132632bf3e8f2c81cc49", "commit_date": "Wed Jan 4 10:55:38 2017 -0700", "commit_message": "Robertoriv feature/check assume role from unknown (#485)", "files_name": ["security_monkey/auditors/iam/iam_role.py"]}, {"commit_id": "00ce33878eced6452da3697a7dd3170f2a6db5d4", "commit_date": "Wed Jan 4 13:01:31 2017 -0500", "commit_message": "Adds upgraded setuptools to Dockerfile. Fixes (#486) (#487)", "files_name": ["Dockerfile"]}, {"commit_id": "8b0c4cd0bf6c749fff00d7f338fad65d3dd36a11", "commit_date": "Thu Jan 5 11:13:22 2017 -0700", "commit_message": "Fixing a bug where we stopped raising an issue when we could not obtain a cert issuer.  The regression happened after moving from M2Crypto to Cryptography. Should fix issue #251. (#489)", "files_name": ["security_monkey/watchers/iam/iam_ssl.py"]}, {"commit_id": "46b73096d4cce5eb8564f11801d338f74a44dad6", "commit_date": "Thu Jan 5 11:13:32 2017 -0700", "commit_message": "Adding ephemeral to rds db instance. Should fix issue #421. (#490)", "files_name": ["security_monkey/watchers/rds/rds_db_instance.py"]}, {"commit_id": "1ad95ef78d7d5063b14de7092a38a029d0414696", "commit_date": "Thu Jan 5 11:13:40 2017 -0700", "commit_message": "Adding a new RDS DB Cluster ephemeral (#491)", "files_name": ["security_monkey/watchers/rds/rds_db_cluster.py"]}, {"commit_id": "d21c5d74bd016a87e545bad819a86033d3cea0a4", "commit_date": "Thu Jan 5 11:13:50 2017 -0700", "commit_message": "Updating S3 Auditor to use ARN class (#492)", "files_name": ["security_monkey/auditors/s3.py"]}, {"commit_id": "4fae5af62b7911802229bce45ae1f14fdca965ee", "commit_date": "Thu Jan 5 11:11:08 2017 -0800", "commit_message": "Fixing typo in dart files. This fixes the web UI.", "files_name": ["dart/lib/component/search_bar_component/search_bar_component.dart"]}, {"commit_id": "eb3faa54f1b441da2745938de2eb94bd57af8408", "commit_date": "Tue Jan 10 15:26:43 2017 -0800", "commit_message": "Refactoring to work with new Flask-WTF. Closes Issue #494. (#495) \u0ca0_\u0ca0", "files_name": ["security_monkey/templates/security/forgot_password.html", "security_monkey/templates/security/login_user.html", "security_monkey/templates/security/register_user.html", "security_monkey/templates/security/reset_password.html", "security_monkey/templates/security/send_confirmation.html", "setup.py"]}, {"commit_id": "7a662de53ec226e40f51b11abdc51a895bf145ee", "commit_date": "Tue Jan 10 15:29:22 2017 -0800", "commit_message": "Initial attempt at Win10 development instructions (#493) \ud83d\udcbb", "files_name": ["docs/contributing.rst", "docs/dev_setup_windows.rst"]}, {"commit_id": "4ef5024c079b7c8c385bbcf8089016c9bf79478c", "commit_date": "Fri Jan 13 05:57:39 2017 +0000", "commit_message": "Bumping cloudaux to 1.0.7", "files_name": ["setup.py"]}, {"commit_id": "3d0e1d5ce8c77cb5e7e6eaad12b0cd7983c5e9f8", "commit_date": "Fri Jan 13 10:30:08 2017 -0800", "commit_message": "Updating changelog in preparation of v0.8.0 release", "files_name": ["docs/changelog.rst"]}, {"commit_id": "870e18bdfbbe6c3e7445cf655c5572cecec5c6f9", "commit_date": "Fri Jan 13 10:43:38 2017 -0800", "commit_message": "Release v0.8.0 (#458) The OA", "files_name": ["f7f1b2560358a4dec0b86c6d9db97d1ed94dff29 - Thu Jan 19 20:32:02 2017 +0000 : Updating ARN.py to look for StringEqualsIgnoreCase in policy condition blocks", "security_monkey/common/arn.py"]}, {"commit_id": "26899fb680d4402cc9aaf07bc975ce19abcb6e15", "commit_date": "Thu Jan 19 12:39:07 2017 -0800", "commit_message": "Merge pull request #500 from Netflix/update_ARN_condition_extraction_stringequalsignorecase", "files_name": ["9ce2240932e728d60ebd10c7f84fec865a173e18 - Thu Apr 14 15:40:40 2016 -0500 : Add additional JIRA configurations", "docs/jirasync.rst", "env-config/config-deploy.py", "security_monkey/jirasync.py"]}, {"commit_id": "c9fbdc8e1d492d25267d9c4b5ec2295c8f51eb41", "commit_date": "Wed Jan 25 15:56:01 2017 +0200", "commit_message": "Plugins support", "files_name": ["docs/plugins.rst", "manage.py", "security_monkey/common/utils.py"]}, {"commit_id": "14e7dbbaf4118bbcecfd0805f41a002d5e1b4b2d", "commit_date": "Fri Oct 21 15:54:26 2016 -0400", "commit_message": "[secmonkey] Organize tests into directories", "files_name": [".travis.yml", "security_monkey/tests/auditors/__init__.py", "security_monkey/tests/auditors/test_arn.py", "security_monkey/tests/auditors/test_elasticsearch_service.py", "security_monkey/tests/auditors/test_iam.py", "security_monkey/tests/core/__init__.py", "security_monkey/tests/core/db_mock.py", "security_monkey/tests/core/monitor_mock.py", "security_monkey/tests/core/test_auditor.py", "security_monkey/tests/core/test_exception_logging.py", "security_monkey/tests/core/test_monitors.py", "security_monkey/tests/core/test_policydiff.py", "security_monkey/tests/core/test_scheduler.py", "security_monkey/tests/interface/__init__.py", "security_monkey/tests/interface/test_manager.py", "security_monkey/tests/test_scheduler.py", "security_monkey/tests/watchers/ec2/test_ebs_snapshot.py", "security_monkey/tests/watchers/ec2/test_ebs_volume.py", "security_monkey/tests/watchers/ec2/test_ec2_image.py", "security_monkey/tests/watchers/ec2/test_ec2_instance.py", "security_monkey/tests/watchers/rds/test_rds_db_instance.py", "security_monkey/tests/watchers/rds/test_rds_security_group.py", "security_monkey/tests/watchers/rds/test_rds_subnet_group.py", "security_monkey/tests/watchers/test_lambda_function.py", "security_monkey/tests/watchers/test_route53.py", "security_monkey/tests/watchers/vpc/test_dhcp.py", "security_monkey/tests/watchers/vpc/test_networkacl.py", "security_monkey/tests/watchers/vpc/test_peering.py", "security_monkey/tests/watchers/vpc/test_route_table.py", "setup.py"]}, {"commit_id": "76e3aa07c03859db98ce1c0b547dc06d659da525", "commit_date": "Thu Jan 12 18:13:01 2017 -0500", "commit_message": "[secmonkey] Fix KMSAuditor exceptions", "files_name": ["security_monkey/auditors/kms.py", "security_monkey/tests/auditors/test_kms.py"]}, {"commit_id": "4ff55b217d6de625c5ef489baca5e115c67fb951", "commit_date": "Thu Jan 26 13:16:02 2017 -0800", "commit_message": "Merge pull request #511 from Bridgewater/9121_KMSAuditorFix \ud83d\udd11", "files_name": ["2edacc7178688dc8cc377fc7b60ef3906588306a - Thu Jan 26 13:19:22 2017 -0800 : Merge pull request #510 from Bridgewater/7940_JiraUpdates \ud83c\udfab", "5f429846be71e8a08653e1b50d77244db3501c38 - Mon Jan 30 09:27:19 2017 -0800 : Merge pull request #504 from redixin/plugins \ud83d\udd0c", "856dc60ce4579d35e1b8f5dff15f44de25fb9b73 - Mon Jan 30 09:44:46 2017 -0800 : Fix for S3 watcher errors.", "security_monkey/tests/test_exception_logging.py", "security_monkey/tests/test_s3.py", "security_monkey/watchers/s3.py"]}, {"commit_id": "3a7b1681db7d698963eb33704bf4fc2a82c2c971", "commit_date": "Tue Jan 24 14:30:46 2017 +1300", "commit_message": "Add ability to press enter to search in search bar component", "files_name": ["dart/lib/component/search_bar_component/search_bar_component.html"]}, {"commit_id": "bc711a831a408144bf052ef259019a748b28267a", "commit_date": "Fri Jan 27 11:15:36 2017 +1300", "commit_message": "Remove broken packages link", "files_name": ["dart/web/css/packages", "dart/web/fonts/packages", "dart/web/images/packages", "dart/web/js/packages", "dart/web/packages", "dart/web/select2-3.4.5/packages", "dart/web/views/packages"]}, {"commit_id": "5ae0c7c33f7ff90f36f86c5f8977f9aaa81c7a3f", "commit_date": "Mon Jan 30 22:58:33 2017 -0800", "commit_message": "Merge pull request #515 from badraufran/feature/enter_key_to_search \u2328\ufe0f", "files_name": ["25048a66b22432e2f1bfcb7981e30db5263ef810 - Wed Feb 1 10:42:58 2017 +1300 : Update dev_setup_osx.rst to get it up-to-date (#514) \ud83d\udcd3", "docs/dev_setup_osx.rst"]}, {"commit_id": "4238ccf113aad995d897139726bae17ebcef59b5", "commit_date": "Tue Jan 31 13:44:33 2017 -0800", "commit_message": "Merge pull request #513 from mikegrima/s3_fix \u26a0\ufe0f\ufe0f", "files_name": ["d3ecc0c97dfba4515266cbfa1d2fb36ba1518888 - Tue Jan 31 13:58:35 2017 -0800 : Merge pull request #516 from badraufran/feature/remove_broken_packages_references \ud83d\udce6", "a7d4cb1cdb61854a27fd7fbcad9f99cc52ac69c0 - Thu Feb 2 13:46:30 2017 +1300 : Update dev_setup_osx", "docs/dev_setup_osx.rst"]}, {"commit_id": "2ee30cc22b08583d102c4a87bb92ad77f823949c", "commit_date": "Wed Feb 1 16:56:01 2017 -0800", "commit_message": "Merge pull request #518 from badraufran/feature/update_dev_setup_osx_brew_python", "files_name": ["a1e3a7acbf6e6d0c250e699957da5e9fa888ed8e - Fri Feb 3 11:25:55 2017 -0800 : Minor reformatting/style changes to Docker docs", "docs/docker.rst"]}, {"commit_id": "42933b32e22f7f21910160b14b7d1a48cf108931", "commit_date": "Fri Feb 3 11:43:34 2017 -0800", "commit_message": "Merge pull request #519 from selmanj/minor_style_changes_docker_documentation", "files_name": ["0ff07d96a22d8de5006c5902fcee7b8452e0c46d - Tue Feb 7 20:43:06 2017 +0000 : Merge branch '9033_TestInDir' of git://github.com/Bridgewater/security_monkey into Bridgewater-9033_TestInDir", "be4b06ab30adcf8aee7c004f35c6574e3225e029 - Tue Feb 7 20:49:28 2017 +0000 : Adding -a to coverage run", ".travis.yml"]}, {"commit_id": "4b496dad1b8e822eee0cf821f024ebf6d96417db", "commit_date": "Tue Feb 7 21:07:41 2017 +0000", "commit_message": "Moving Mike's S3 watcher into the watchers directory.", "files_name": ["security_monkey/tests/watchers/test_s3.py"]}, {"commit_id": "3c40c003569e2798340f880c8abda4e39b3a427a", "commit_date": "Tue Feb 7 21:16:32 2017 +0000", "commit_message": "Fixing import typo.", "files_name": ["security_monkey/tests/watchers/test_s3.py"]}, {"commit_id": "db30af1f440fb43791030d669128719aafb9d85e", "commit_date": "Tue Feb 7 13:30:48 2017 -0800", "commit_message": "Organize tests into directories #521 \ud83d\udee0\ufe0f", "files_name": ["f00a3f8138e4d63efa24c125f58e4bdce30150cc - Thu Jul 7 17:22:08 2016 -0400 : Optimize SQL for account delete", "manage.py", "security_monkey/account_manager.py", "security_monkey/views/account.py"]}, {"commit_id": "5dd4ffc4c68b38f7683ddf47eb08288fe47ef701", "commit_date": "Wed Nov 2 11:09:05 2016 -0400", "commit_message": "[secmonkey] Handle known kms boto exceptions", "files_name": ["security_monkey/watchers/kms.py"]}, {"commit_id": "7452ae846e3a9c8c87b2fe57f4d98f710e86db40", "commit_date": "Fri Feb 10 10:27:21 2017 +0200", "commit_message": "Usage of GOOGLE_HOSTED_DOMAIN in sample configs", "files_name": ["env-config/config-deploy.py", "env-config/config-docker.py", "env-config/config-local.py"]}, {"commit_id": "3ac8957ac39101ee6ce2886350b266f72a2b15c3", "commit_date": "Thu Jan 26 11:54:14 2017 -0500", "commit_message": "[secmonkey] Remove DB mock class", "files_name": ["security_monkey/tests/auditors/test_elasticsearch_service.py", "security_monkey/tests/core/db_mock.py", "security_monkey/tests/core/test_backup.py", "security_monkey/tests/core/test_scheduler.py", "security_monkey/tests/watchers/__init__.py", "security_monkey/tests/watchers/ec2/test_ebs_snapshot.py", "security_monkey/tests/watchers/ec2/test_ebs_volume.py", "security_monkey/tests/watchers/ec2/test_ec2_image.py", "security_monkey/tests/watchers/ec2/test_ec2_instance.py", "security_monkey/tests/watchers/rds/test_rds_db_instance.py", "security_monkey/tests/watchers/rds/test_rds_security_group.py", "security_monkey/tests/watchers/rds/test_rds_subnet_group.py", "security_monkey/tests/watchers/test_lambda_function.py", "security_monkey/tests/watchers/test_route53.py", "security_monkey/tests/watchers/vpc/test_dhcp.py", "security_monkey/tests/watchers/vpc/test_networkacl.py", "security_monkey/tests/watchers/vpc/test_peering.py", "security_monkey/tests/watchers/vpc/test_route_table.py"]}, {"commit_id": "c5e9a0eca0f9e8466c99d5e4247b76cc3441582e", "commit_date": "Thu Sep 1 17:06:21 2016 -0400", "commit_message": "Add bulk enable and disable account service", "files_name": ["dart/lib/component/settings_component/settings_component.dart", "dart/lib/component/settings_component/settings_component.html", "dart/lib/model/AccountBulkUpdate.dart", "dart/lib/model/hammock_config.dart", "dart/lib/security_monkey.dart", "manage.py", "security_monkey/__init__.py", "security_monkey/scheduler.py", "security_monkey/tests/core/test_scheduler.py", "security_monkey/views/account_bulk_update.py", "setup.py"]}, {"commit_id": "9f9f7f8ce18bf05e596144161e6ec73093a7172a", "commit_date": "Fri Feb 10 10:36:49 2017 -0800", "commit_message": "Merge pull request #524 from Bridgewater/9365_RemoveDBMock", "files_name": ["4b9329b33188af647b06891eaa091e87e3989123 - Mon Oct 24 10:45:31 2016 -0500 : [secmonkey] Add sorting to accounts tables", "dart/lib/component/settings_component/settings_component.dart", "dart/lib/component/settings_component/settings_component.html", "security_monkey/views/account.py"]}], "parents": [{"commit_id_before": "da8c81e53c519907691c13dab1ccf16eae4db622", "url_before": "https://api.github.com/repos/Netflix/security_monkey/commits/da8c81e53c519907691c13dab1ccf16eae4db622", "html_url_before": "https://github.com/Netflix/security_monkey/commit/da8c81e53c519907691c13dab1ccf16eae4db622"}], "details": [{"raw_url": "https://github.com/Netflix/security_monkey/raw/3b4da13efabb05970c80f464a50d3c1c12262466/security_monkey%2Fauth%2Fmodules.py", "code": "import itertools\n\nfrom flask import request, abort, _app_ctx_stack, redirect\nfrom flask_security.core import AnonymousUser\nfrom security_monkey.datastore import User\n\ntry:\n    from flask.ext.login import current_user\nexcept ImportError:\n    current_user = None\n\nfrom .models import RBACRole, RBACUserMixin\n\nfrom . import anonymous\n\nfrom flask import Response\nimport json\n\n\nclass AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt\n\n\nclass _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app\n\n\nclass RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated:\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated:\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True\n", "code_before": "import itertools\n\nfrom flask import request, abort, _app_ctx_stack, redirect\nfrom flask_security.core import AnonymousUser\nfrom security_monkey.datastore import User\n\ntry:\n    from flask.ext.login import current_user\nexcept ImportError:\n    current_user = None\n\nfrom .models import RBACRole, RBACUserMixin\n\nfrom . import anonymous\n\nfrom flask import Response\nimport json\n\n\nclass AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt\n\n\nclass _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app\n\n\nclass RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated():\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated():\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True\n", "patch": "@@ -240,7 +240,7 @@ def _check_permission(self, roles, method, resource):\n \n     def _deny_hook(self, resource=None):\n         app = self.get_app()\n-        if current_user.is_authenticated():\n+        if current_user.is_authenticated:\n             status = 403\n         else:\n             status = 401\n@@ -250,7 +250,7 @@ def _deny_hook(self, resource=None):\n                 url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n         else:\n                 url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n-        if current_user.is_authenticated():\n+        if current_user.is_authenticated:\n             auth_dict = {\n                 \"authenticated\": True,\n                 \"user\": current_user.email,", "file_path": "files/2017_3/227", "file_language": "py", "file_name": "security_monkey/auth/modules.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt", "target": 0}, {"function": "class _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app", "target": 0}, {"function": "class RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated():\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated():\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True", "target": 0}], "function_after": [{"function": "class AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt", "target": 0}, {"function": "class _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app", "target": 0}, {"function": "class RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated:\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated:\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True", "target": 0}]}, {"raw_url": "https://github.com/Netflix/security_monkey/raw/3b4da13efabb05970c80f464a50d3c1c12262466/security_monkey%2Fsso%2Fviews.py", "code": "\"\"\"\n.. module: security_monkey.sso.views\n    :platform: Unix\n    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n.. moduleauthor:: Patrick Kelley <patrick@netflix.com>\n\"\"\"\nimport jwt\nimport base64\nimport requests\n\nfrom flask import Blueprint, current_app, redirect, request\n\nfrom flask.ext.restful import reqparse, Resource, Api\nfrom flask.ext.principal import Identity, identity_changed\nfrom flask_security.utils import login_user\n\ntry:\n    from onelogin.saml2.auth import OneLogin_Saml2_Auth\n    from onelogin.saml2.utils import OneLogin_Saml2_Utils\n    onelogin_import_success = True\nexcept ImportError:\n    onelogin_import_success = False\n\nfrom .service import fetch_token_header_payload, get_rsa_public_key\n\nfrom security_monkey.datastore import User\nfrom security_monkey import db, rbac\n\nfrom urlparse import urlparse\n\nmod = Blueprint('sso', __name__)\napi = Api(mod)\n\n\nfrom flask_security.utils import validate_redirect_url\n\n\nclass Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated:\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))\n\n\nclass Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers\n\n\napi.add_resource(Ping, '/auth/ping', endpoint='ping')\napi.add_resource(Google, '/auth/google', endpoint='google')\napi.add_resource(Providers, '/auth/providers', endpoint='providers')\n\nif onelogin_import_success:\n    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')\n", "code_before": "\"\"\"\n.. module: security_monkey.sso.views\n    :platform: Unix\n    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n.. moduleauthor:: Patrick Kelley <patrick@netflix.com>\n\"\"\"\nimport jwt\nimport base64\nimport requests\n\nfrom flask import Blueprint, current_app, redirect, request\n\nfrom flask.ext.restful import reqparse, Resource, Api\nfrom flask.ext.principal import Identity, identity_changed\nfrom flask_login import login_user\n\ntry:\n    from onelogin.saml2.auth import OneLogin_Saml2_Auth\n    from onelogin.saml2.utils import OneLogin_Saml2_Utils\n    onelogin_import_success = True\nexcept ImportError:\n    onelogin_import_success = False\n\nfrom .service import fetch_token_header_payload, get_rsa_public_key\n\nfrom security_monkey.datastore import User\nfrom security_monkey import db, rbac\n\nfrom urlparse import urlparse\n\nmod = Blueprint('sso', __name__)\napi = Api(mod)\n\n\nfrom flask_security.utils import validate_redirect_url\n\n\nclass Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated():\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))\n\n\nclass Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers\n\n\napi.add_resource(Ping, '/auth/ping', endpoint='ping')\napi.add_resource(Google, '/auth/google', endpoint='google')\napi.add_resource(Providers, '/auth/providers', endpoint='providers')\n\nif onelogin_import_success:\n    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')\n", "patch": "@@ -13,7 +13,7 @@\n \n from flask.ext.restful import reqparse, Resource, Api\n from flask.ext.principal import Identity, identity_changed\n-from flask_login import login_user\n+from flask_security.utils import login_user\n \n try:\n     from onelogin.saml2.auth import OneLogin_Saml2_Auth\n@@ -264,7 +264,7 @@ def _consumer(self, auth):\n         auth.process_response()\n         errors = auth.get_errors()\n         if not errors:\n-            if auth.is_authenticated():\n+            if auth.is_authenticated:\n                 return True\n             else:\n                 return False", "file_path": "files/2017_3/228", "file_language": "py", "file_name": "security_monkey/sso/views.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)", "target": 0}, {"function": "class Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)", "target": 0}, {"function": "class OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated():\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))", "target": 0}, {"function": "class Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers", "target": 0}], "function_after": [{"function": "class Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)", "target": 0}, {"function": "class Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)", "target": 0}, {"function": "class OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated:\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))", "target": 0}, {"function": "class Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers", "target": 0}]}, {"raw_url": "https://github.com/Netflix/security_monkey/raw/3b4da13efabb05970c80f464a50d3c1c12262466/security_monkey%2Fviews%2F__init__.py", "code": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom security_monkey import app, db\nfrom flask_wtf.csrf import generate_csrf\nfrom security_monkey.auth.models import RBACRole\nfrom security_monkey.decorators import crossdomain\n\nfrom flask_restful import fields, marshal, Resource, reqparse\nfrom flask_login import current_user\n\nORIGINS = [\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),\n    # Adding this next one so you can also access the dart UI by prepending /static to the path.\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),\n    'https://{}:80'.format(app.config.get('FQDN'))\n]\n\n##### Marshal Datastructures #####\n\n# Used by RevisionGet, RevisionList, ItemList\nREVISION_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'date_last_ephemeral_change': fields.String,\n    'active': fields.Boolean,\n    'item_id': fields.Integer\n}\n\n# Used by RevisionList, ItemGet, ItemList\nITEM_FIELDS = {\n    'id': fields.Integer,\n    'region': fields.String,\n    'name': fields.String\n}\n\n# Used by ItemList, Justify\nAUDIT_FIELDS = {\n    'id': fields.Integer,\n    'score': fields.Integer,\n    'issue': fields.String,\n    'notes': fields.String,\n    'justified': fields.Boolean,\n    'justification': fields.String,\n    'justified_date': fields.String,\n    'item_id': fields.Integer\n}\n\n## Single Use Marshal Objects ##\n\n# SINGLE USE - RevisionGet\nREVISION_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'revision_id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String\n}\n\n# SINGLE USE - ItemGet\nITEM_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String,\n    'item_id': fields.Integer\n}\n\n# SINGLE USE - UserSettings\nUSER_SETTINGS_FIELDS = {\n    # 'id': fields.Integer,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String\n}\n\n# SINGLE USE - AccountGet\nACCOUNT_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'identifier': fields.String,\n    'notes': fields.String,\n    'active': fields.Boolean,\n    'third_party': fields.Boolean,\n    'account_type': fields.String\n}\n\nUSER_FIELDS = {\n    'id': fields.Integer,\n    'active': fields.Boolean,\n    'email': fields.String,\n    'role': fields.String,\n    'confirmed_at': fields.String,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String,\n    'last_login_at': fields.String,\n    'current_login_at': fields.String,\n    'login_count': fields.Integer,\n    'last_login_ip': fields.String,\n    'current_login_ip': fields.String\n}\n\nROLE_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'description': fields.String,\n}\n\nWHITELIST_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'notes': fields.String,\n    'cidr': fields.String\n}\n\nIGNORELIST_FIELDS = {\n    'id': fields.Integer,\n    'prefix': fields.String,\n    'notes': fields.String,\n}\n\nAUDITORSETTING_FIELDS = {\n    'id': fields.Integer,\n    'disabled': fields.Boolean,\n    'issue_text': fields.String\n}\n\nITEM_LINK_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String\n}\n\nclass AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated:\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n\n@app.after_request\n@crossdomain(allowed_origins=ORIGINS)\ndef after(response):\n    response.set_cookie('XSRF-COOKIE', generate_csrf())\n    return response\n", "code_before": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom security_monkey import app, db\nfrom flask_wtf.csrf import generate_csrf\nfrom security_monkey.auth.models import RBACRole\nfrom security_monkey.decorators import crossdomain\n\nfrom flask_restful import fields, marshal, Resource, reqparse\nfrom flask_login import current_user\n\nORIGINS = [\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),\n    # Adding this next one so you can also access the dart UI by prepending /static to the path.\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),\n    'https://{}:80'.format(app.config.get('FQDN'))\n]\n\n##### Marshal Datastructures #####\n\n# Used by RevisionGet, RevisionList, ItemList\nREVISION_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'date_last_ephemeral_change': fields.String,\n    'active': fields.Boolean,\n    'item_id': fields.Integer\n}\n\n# Used by RevisionList, ItemGet, ItemList\nITEM_FIELDS = {\n    'id': fields.Integer,\n    'region': fields.String,\n    'name': fields.String\n}\n\n# Used by ItemList, Justify\nAUDIT_FIELDS = {\n    'id': fields.Integer,\n    'score': fields.Integer,\n    'issue': fields.String,\n    'notes': fields.String,\n    'justified': fields.Boolean,\n    'justification': fields.String,\n    'justified_date': fields.String,\n    'item_id': fields.Integer\n}\n\n## Single Use Marshal Objects ##\n\n# SINGLE USE - RevisionGet\nREVISION_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'revision_id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String\n}\n\n# SINGLE USE - ItemGet\nITEM_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String,\n    'item_id': fields.Integer\n}\n\n# SINGLE USE - UserSettings\nUSER_SETTINGS_FIELDS = {\n    # 'id': fields.Integer,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String\n}\n\n# SINGLE USE - AccountGet\nACCOUNT_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'identifier': fields.String,\n    'notes': fields.String,\n    'active': fields.Boolean,\n    'third_party': fields.Boolean,\n    'account_type': fields.String\n}\n\nUSER_FIELDS = {\n    'id': fields.Integer,\n    'active': fields.Boolean,\n    'email': fields.String,\n    'role': fields.String,\n    'confirmed_at': fields.String,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String,\n    'last_login_at': fields.String,\n    'current_login_at': fields.String,\n    'login_count': fields.Integer,\n    'last_login_ip': fields.String,\n    'current_login_ip': fields.String\n}\n\nROLE_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'description': fields.String,\n}\n\nWHITELIST_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'notes': fields.String,\n    'cidr': fields.String\n}\n\nIGNORELIST_FIELDS = {\n    'id': fields.Integer,\n    'prefix': fields.String,\n    'notes': fields.String,\n}\n\nAUDITORSETTING_FIELDS = {\n    'id': fields.Integer,\n    'disabled': fields.Boolean,\n    'issue_text': fields.String\n}\n\nITEM_LINK_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String\n}\n\nclass AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated():\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n\n@app.after_request\n@crossdomain(allowed_origins=ORIGINS)\ndef after(response):\n    response.set_cookie('XSRF-COOKIE', generate_csrf())\n    return response\n", "patch": "@@ -144,7 +144,7 @@ def __init__(self):\n         self.reqparse = reqparse.RequestParser()\n         super(AuthenticatedService, self).__init__()\n         self.auth_dict = dict()\n-        if current_user.is_authenticated():\n+        if current_user.is_authenticated:\n             roles_marshal = []\n             for role in current_user.roles:\n                 roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))", "file_path": "files/2017_3/229", "file_language": "py", "file_name": "security_monkey/views/__init__.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated():\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }", "target": 0}], "function_after": [{"function": "class AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated:\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }", "target": 0}]}, {"raw_url": "https://github.com/Netflix/security_monkey/raw/3b4da13efabb05970c80f464a50d3c1c12262466/security_monkey%2Fviews%2Flogout.py", "code": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom flask_login import current_user, logout_user\nfrom flask_restful import Resource\n\n\n# End the Flask-Logins session\nfrom security_monkey import rbac\n\n\nclass Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated:\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200\n", "code_before": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom flask_login import current_user, logout_user\nfrom flask_restful import Resource\n\n\n# End the Flask-Logins session\nfrom security_monkey import rbac\n\n\nclass Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated():\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200\n", "patch": "@@ -25,7 +25,7 @@ class Logout(Resource):\n     decorators = [rbac.exempt]\n \n     def get(self):\n-        if not current_user.is_authenticated():\n+        if not current_user.is_authenticated:\n             return \"Must be logged in to log out\", 200\n \n         logout_user()", "file_path": "files/2017_3/230", "file_language": "py", "file_name": "security_monkey/views/logout.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated():\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200", "target": 0}], "function_after": [{"function": "class Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated:\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200", "target": 0}]}, {"raw_url": "https://github.com/Netflix/security_monkey/raw/3b4da13efabb05970c80f464a50d3c1c12262466/setup.py", "code": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom setuptools import setup\n\nsetup(\n    name='security_monkey',\n    version='0.8.0',\n    long_description=__doc__,\n    packages=['security_monkey'],\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\n        'APScheduler==2.1.2',\n        'Flask==0.10.1',\n        'Flask-Mail==0.9.0',\n        'Flask-Migrate==1.3.1',\n        'Flask-Principal==0.4.0',\n        'Flask-RESTful==0.3.3',\n        'Flask-SQLAlchemy==1.0',\n        'Flask-Script==0.6.3',\n        # 'Flask-Security==1.7.4',\n        'Flask-Security-Fork==1.8.2',\n        'Jinja2==2.8',\n        'SQLAlchemy==0.9.2',\n        'boto>=2.41.0',\n        'ipaddr==2.1.11',\n        'itsdangerous==0.23',\n        'psycopg2==2.6.2',\n        'bcrypt==3.1.2',\n        'Sphinx==1.2.2',\n        'gunicorn==18.0',\n        'cryptography==1.7.1',\n        'boto3>=1.4.2',\n        'botocore>=1.4.81',\n        'dpath==1.3.2',\n        'pyyaml==3.11',\n        'jira==0.32',\n        'cloudaux>=1.0.6',\n        'joblib>=0.9.4',\n        'pyjwt>=1.01',\n    ],\n    extras_require = {\n        'onelogin': ['python-saml>=2.2.0'],\n        'tests': [\n            'nose==1.3.0',\n            'mock==1.0.1',\n            'moto==0.4.30',\n            'freezegun>=0.3.7'\n        ]\n    }\n)\n", "code_before": "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom setuptools import setup\n\nsetup(\n    name='security_monkey',\n    version='0.8.0',\n    long_description=__doc__,\n    packages=['security_monkey'],\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\n        'APScheduler==2.1.2',\n        'Flask==0.10.1',\n        'Flask-Login==0.2.10',\n        'Flask-Mail==0.9.0',\n        'Flask-Migrate==1.3.1',\n        'Flask-Principal==0.4.0',\n        'Flask-RESTful==0.3.3',\n        'Flask-SQLAlchemy==1.0',\n        'Flask-Script==0.6.3',\n        'Flask-Security==1.7.4',\n        'Flask-WTF==0.9.5',\n        'Jinja2==2.8',\n        'SQLAlchemy==0.9.2',\n        'boto>=2.41.0',\n        'ipaddr==2.1.11',\n        'itsdangerous==0.23',\n        'psycopg2==2.5.2',\n        'bcrypt==2.0.0',\n        'Sphinx==1.2.2',\n        'gunicorn==18.0',\n        'cryptography==1.3.2',\n        'boto3>=1.4.2',\n        'botocore>=1.4.81',\n        'dpath==1.3.2',\n        'pyyaml==3.11',\n        'jira==0.32',\n        'cloudaux>=1.0.6',\n        'joblib>=0.9.4',\n        'pyjwt>=1.01',\n    ],\n    extras_require = {\n        'onelogin': ['python-saml>=2.2.0'],\n        'tests': [\n            'nose==1.3.0',\n            'mock==1.0.1',\n            'moto==0.4.30',\n            'freezegun>=0.3.7'\n        ]\n    }\n)\n", "patch": "@@ -23,25 +23,24 @@\n     install_requires=[\n         'APScheduler==2.1.2',\n         'Flask==0.10.1',\n-        'Flask-Login==0.2.10',\n         'Flask-Mail==0.9.0',\n         'Flask-Migrate==1.3.1',\n         'Flask-Principal==0.4.0',\n         'Flask-RESTful==0.3.3',\n         'Flask-SQLAlchemy==1.0',\n         'Flask-Script==0.6.3',\n-        'Flask-Security==1.7.4',\n-        'Flask-WTF==0.9.5',\n+        # 'Flask-Security==1.7.4',\n+        'Flask-Security-Fork==1.8.2',\n         'Jinja2==2.8',\n         'SQLAlchemy==0.9.2',\n         'boto>=2.41.0',\n         'ipaddr==2.1.11',\n         'itsdangerous==0.23',\n-        'psycopg2==2.5.2',\n-        'bcrypt==2.0.0',\n+        'psycopg2==2.6.2',\n+        'bcrypt==3.1.2',\n         'Sphinx==1.2.2',\n         'gunicorn==18.0',\n-        'cryptography==1.3.2',\n+        'cryptography==1.7.1',\n         'boto3>=1.4.2',\n         'botocore>=1.4.81',\n         'dpath==1.3.2',", "file_path": "files/2017_3/231", "file_language": "py", "file_name": "setup.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
