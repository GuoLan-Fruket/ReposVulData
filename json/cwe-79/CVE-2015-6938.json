{"index": 944, "cve_id": "CVE-2015-6938", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Cross-site scripting (XSS) vulnerability in the file browser in notebook/notebookapp.py in IPython Notebook before 3.2.2 and Jupyter Notebook 4.0.x before 4.0.5 allows remote attackers to inject arbitrary web script or HTML via a folder name.  NOTE: this was originally reported as a cross-site request forgery (CSRF) vulnerability, but this may be inaccurate.", "cvss": "3.7", "publish_date": "September 21, 2015", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "35f32dd2da804d108a3a3585b69ec3295b2677ed", "commit_message": "Fix XSS reported on Security list\n\nNo CVE-ID yet\n\nAugust 18, 2015\n-----\nReported to Quantopian by Juan Broull\u00f3n <thebrowfc@gmail.com>...\n\nIf you create a new folder in the iPython file browser and set\nJavascript code as its name the code injected will be executed. So, if I\ncreate a folder called \"><img src=x onerror=alert(document.cookie)> and\nthen I access to it, the cookies will be prompted.\n\nThe XSS code is also executed if you access a link pointing directly at\nthe folder.\n\n  jik\n------", "commit_date": "2015-09-01T14:39:01Z", "project": "jupyter/notebook", "url": "https://api.github.com/repos/jupyter/notebook/commits/35f32dd2da804d108a3a3585b69ec3295b2677ed", "html_url": "https://github.com/jupyter/notebook/commit/35f32dd2da804d108a3a3585b69ec3295b2677ed", "windows_before": [{"commit_id": "06da70c53659bc6e22a1a79a1f82a3d33b4e22b5", "commit_date": "Tue Sep 1 14:25:02 2015 +0200", "commit_message": "Remove unused logo", "files_name": ["docs/source/_static/logo.png"]}, {"commit_id": "2f44f3ff097e4171b14667b31806aa5d6ba6fb58", "commit_date": "Tue Sep 1 10:57:52 2015 +0200", "commit_message": "remove leftover of profiles", "files_name": ["notebook/notebookapp.py"]}, {"commit_id": "453bd03ae08ace1dbfad9974f54a3a5daefcc33c", "commit_date": "Mon Aug 31 19:15:05 2015 +0200", "commit_message": "Fix flexbox on celltoolbar and safari.", "files_name": ["notebook/static/notebook/less/celltoolbar.less"]}, {"commit_id": "c640d682fd06eb138c16e1973c992885fa4807be", "commit_date": "Sat Aug 29 14:40:04 2015 +0100", "commit_message": "Update JavaScript Notebook Extensions.rst", "files_name": ["docs/source/examples/Notebook/JavaScript Notebook Extensions.rst"]}, {"commit_id": "474a3bb04e1172e3e2f84cd6d146633f9a1b15ae", "commit_date": "Mon Aug 31 14:14:13 2015 +0200", "commit_message": "Merge pull request #360 from minrk/dispatch-halt-init", "files_name": ["5556beee701ea5d58f1ce46a78c8f199cebf406f - Sun Aug 30 14:20:43 2015 -0500 : Merge pull request #364 from jupyter/revert-268-npm", "74b1c875d39e2aa64d6df65599f11d6b1382e755 - Fri Aug 28 08:08:27 2015 -0700 : don't complete initialization if dispatching to subcommand/non-launch action", "notebook/notebookapp.py"]}, {"commit_id": "2d5d548d79711bcfabba7ab64cbf842cd0a2b1f6", "commit_date": "Thu Aug 27 09:00:15 2015 +0200", "commit_message": "Revert \"Use NPM, node ES5, and browserify.\"", "files_name": [".gitignore", ".jshintrc", "README.md", "bower.json", "notebook/amd.js", "notebook/base/handlers.py", "notebook/build.js", "notebook/static-src/auth/js/loginmain.js", "notebook/static-src/auth/js/main.js", "notebook/static-src/base/js/globals.js", "notebook/static-src/base/js/namespace.js", "notebook/static/auth/js/loginmain.js", "notebook/static/auth/js/loginwidget.js", "notebook/static/auth/js/logoutmain.js", "notebook/static/auth/js/main.js", "notebook/static/base/js/dialog.js", "notebook/static/base/js/events.js", "notebook/static/base/js/keyboard.js", "notebook/static/base/js/namespace.js", "notebook/static/base/js/notificationarea.js", "notebook/static/base/js/notificationwidget.js", "notebook/static/base/js/page.js", "notebook/static/base/js/security.js", "notebook/static/base/js/utils.js", "notebook/static/edit/js/editor.js", "notebook/static/edit/js/main.js", "notebook/static/edit/js/menubar.js", "notebook/static/edit/js/notificationarea.js", "notebook/static/edit/js/savewidget.js", "notebook/static/notebook/js/about.js", "notebook/static/notebook/js/actions.js", "notebook/static/notebook/js/cell.js", "notebook/static/notebook/js/celltoolbar.js", "notebook/static/notebook/js/celltoolbarpresets/default.js", "notebook/static/notebook/js/celltoolbarpresets/example.js", "notebook/static/notebook/js/celltoolbarpresets/rawcell.js", "notebook/static/notebook/js/celltoolbarpresets/slideshow.js", "notebook/static/notebook/js/codecell.js", "notebook/static/notebook/js/codemirror-ipython.js", "notebook/static/notebook/js/codemirror-ipythongfm.js", "notebook/static/notebook/js/commandpalette.js", "notebook/static/notebook/js/completer.js", "notebook/static/notebook/js/contexthint.js", "notebook/static/notebook/js/kernelselector.js", "notebook/static/notebook/js/keyboardmanager.js", "notebook/static/notebook/js/main.js", "notebook/static/notebook/js/maintoolbar.js", "notebook/static/notebook/js/mathjaxutils.js", "notebook/static/notebook/js/menubar.js", "notebook/static/notebook/js/notebook.js", "notebook/static/notebook/js/notificationarea.js", "notebook/static/notebook/js/outputarea.js", "notebook/static/notebook/js/pager.js", "notebook/static/notebook/js/quickhelp.js", "notebook/static/notebook/js/savewidget.js", "notebook/static/notebook/js/scrollmanager.js", "notebook/static/notebook/js/searchandreplace.js", "notebook/static/notebook/js/textcell.js", "notebook/static/notebook/js/toolbar.js", "notebook/static/notebook/js/tooltip.js", "notebook/static/notebook/js/tour.js", "notebook/static/services/config.js", "notebook/static/services/contents.js", "notebook/static/services/kernels/comm.js", "notebook/static/services/kernels/kernel.js", "notebook/static/services/kernels/serialize.js", "notebook/static/services/sessions/session.js", "notebook/static/terminal/js/main.js", "notebook/static/terminal/js/terminado.js", "notebook/static/tree/js/kernellist.js", "notebook/static/tree/js/main.js", "notebook/static/tree/js/newnotebook.js", "notebook/static/tree/js/notebooklist.js", "notebook/static/tree/js/sessionlist.js", "notebook/static/tree/js/terminallist.js", "notebook/templates/edit.html", "notebook/templates/notebook.html", "notebook/templates/page.html", "notebook/templates/terminal.html", "notebook/templates/tree.html", "notebook/tests/base/utils.js", "notebook/tests/util.js", "package.json", "setup.py", "setupbase.py"]}, {"commit_id": "62101281e0aeb538b2a5786d83e26c103f60c912", "commit_date": "Wed Aug 26 16:45:09 2015 -0500", "commit_message": "Merge pull request #268 from jdfreder/npm", "files_name": ["8ca1e85b852e5c2e5cf8d2fddfaa30c57ed4f01d - Wed Aug 26 14:08:53 2015 -0700 : commonjs-ify searchandreplace", "notebook/static-src/notebook/js/main.js", "notebook/static-src/notebook/js/searchandreplace.js"]}, {"commit_id": "511bb689c2954ae24b5f577e58692af5aa5b5505", "commit_date": "Wed Aug 26 14:07:20 2015 -0700", "commit_message": "Move search and replace into the right directory", "files_name": ["notebook/static-src/notebook/js/searchandreplace.js"]}, {"commit_id": "307d9ee49c7680e54fed2f2ee541032979127588", "commit_date": "Wed Aug 26 14:02:53 2015 -0700", "commit_message": "Include components in setup base", "files_name": ["setupbase.py"]}, {"commit_id": "7717a986d115c4db68a482d8e233f4adc06b49ec", "commit_date": "Fri Aug 21 17:28:34 2015 -0700", "commit_message": "Load underscore globally", "files_name": ["notebook/static-src/base/js/globals.js", "notebook/static-src/base/js/keyboard.js", "notebook/static-src/notebook/js/about.js", "notebook/static-src/services/kernels/serialize.js", "package.json"]}, {"commit_id": "03a5b4706789b9e2371728ac88ac760ea04e8919", "commit_date": "Fri Aug 21 17:17:16 2015 -0700", "commit_message": "Assume undefined is idle.", "files_name": ["notebook/tests/util.js"]}, {"commit_id": "b6897009101380f478f236772a8fef27608ee13c", "commit_date": "Fri Aug 21 12:27:52 2015 -0700", "commit_message": "Only build once, via npm postinstall", "files_name": [".travis.yml", "setupbase.py"]}, {"commit_id": "3bc3fda7440c0e29c5a40a57312a7780d2033794", "commit_date": "Fri Aug 21 12:08:27 2015 -0700", "commit_message": "Travis you old fart, get modern with a phantomjs from this century :poop:", "files_name": [".travis.yml"]}, {"commit_id": "7f4101709b5d3ec36ba3ec84c27c57cfa4c81378", "commit_date": "Fri Aug 21 11:55:57 2015 -0700", "commit_message": "Don't use bind", "files_name": ["notebook/static-src/notebook/js/tour.js"]}, {"commit_id": "467ae32b0583438773f82ff8311e43153cfc33f6", "commit_date": "Fri Aug 21 11:43:07 2015 -0700", "commit_message": "Make sure requirejs can't be set more than once.", "files_name": ["notebook/static-src/base/js/globals.js", "notebook/static-src/notebook/js/commandpalette.js", "package.json"]}, {"commit_id": "8c8c95ceca83828f9a9625578dcff75f05eccab5", "commit_date": "Fri Aug 21 09:52:18 2015 -0700", "commit_message": "Load CodeMirror once globally", "files_name": [".jshintrc", "notebook/static-src/base/js/dialog.js", "notebook/static-src/base/js/globals.js", "notebook/static-src/base/js/utils.js", "notebook/static-src/edit/js/editor.js", "notebook/static-src/edit/js/menubar.js", "notebook/static-src/notebook/js/cell.js", "notebook/static-src/notebook/js/codecell.js", "notebook/static-src/notebook/js/completer.js", "notebook/static-src/notebook/js/contexthint.js", "notebook/static-src/notebook/js/main.js", "notebook/static-src/notebook/js/menubar.js", "notebook/static-src/notebook/js/notebook.js", "notebook/static-src/notebook/js/textcell.js", "notebook/static-src/terminal/js/main.js", "notebook/static-src/tree/js/main.js"]}, {"commit_id": "84ce0cee2cab1b60a42e3e63484c34e35cb2e44d", "commit_date": "Fri Aug 21 08:37:17 2015 -0700", "commit_message": "Address @rgbkrk 's comments", "files_name": ["notebook/static-src/auth/js/loginmain.js", "notebook/static-src/auth/js/logoutmain.js", "notebook/static-src/base/js/dialog.js", "notebook/static-src/notebook/js/celltoolbarpresets/example.js", "notebook/static-src/notebook/js/tour.js", "notebook/static-src/services/contents.js"]}, {"commit_id": "c8020384150987db6ee803d9e42e9bc7b1a805dc", "commit_date": "Thu Aug 20 10:45:02 2015 -0700", "commit_message": "Remove jquery, jqueryui, and bootstrap from npm packages", "files_name": ["package.json"]}, {"commit_id": "69bb4b1a0a8feb6c2b885bf964ccd4e5877f00c7", "commit_date": "Thu Aug 20 10:43:20 2015 -0700", "commit_message": "Truely load jquery, jqueryui, and bootstrap as globals.", "files_name": [".jshintrc", "notebook/static-src/auth/js/loginwidget.js", "notebook/static-src/base/js/dialog.js", "notebook/static-src/base/js/events.js", "notebook/static-src/base/js/globals.js", "notebook/static-src/base/js/keyboard.js", "notebook/static-src/base/js/notificationarea.js", "notebook/static-src/base/js/notificationwidget.js", "notebook/static-src/base/js/page.js", "notebook/static-src/base/js/security.js", "notebook/static-src/base/js/utils.js", "notebook/static-src/edit/js/editor.js", "notebook/static-src/edit/js/main.js", "notebook/static-src/edit/js/menubar.js", "notebook/static-src/edit/js/savewidget.js", "notebook/static-src/notebook/js/about.js", "notebook/static-src/notebook/js/cell.js", "notebook/static-src/notebook/js/celltoolbar.js", "notebook/static-src/notebook/js/celltoolbarpresets/default.js", "notebook/static-src/notebook/js/celltoolbarpresets/example.js", "notebook/static-src/notebook/js/celltoolbarpresets/rawcell.js", "notebook/static-src/notebook/js/celltoolbarpresets/slideshow.js", "notebook/static-src/notebook/js/codecell.js", "notebook/static-src/notebook/js/completer.js", "notebook/static-src/notebook/js/kernelselector.js", "notebook/static-src/notebook/js/keyboardmanager.js", "notebook/static-src/notebook/js/main.js"]}], "windows_after": [{"commit_id": "1ecce4aa35825138d2e36b498f0a7295e3f74477", "commit_date": "Tue Sep 1 08:12:07 2015 -0700", "commit_message": "Merge pull request #373 from Carreau/update-logo", "files_name": ["f9885818e24e5d22eb5ca6fd54716be035934931 - Tue Sep 1 18:15:37 2015 +0200 : Merge pull request #372 from Carreau/no-profile", "dffbacb377a8c714acf7d6b8d247050ac0aea5a3 - Tue Sep 1 13:17:38 2015 -0400 : Update tree.html", "notebook/templates/tree.html"]}, {"commit_id": "e7eca491b5b04d185651e9bc6dc71f323a37542a", "commit_date": "Tue Sep 1 20:00:21 2015 +0200", "commit_message": "Merge pull request #377 from dsblank/patch-1", "files_name": ["2c16e34a329411e6b3339f20b81f192a3fe03d16 - Wed Sep 2 08:59:47 2015 +0200 : Merge pull request #340 from captainsafia/merge-cell-fix", "5f2dea1c8e5103cd1ba1da2ef827c6b36ae89d83 - Tue Sep 1 10:54:00 2015 -0600 : superficial english fixes", "docs/source/examples/Notebook/JavaScript Notebook Extensions.rst"]}, {"commit_id": "de925603e47054fd0471918800dbaf31ac2e0466", "commit_date": "Sat Aug 29 12:08:49 2015 +0100", "commit_message": "move typo from rst to ipynb", "files_name": ["docs/source/examples/Notebook/JavaScript Notebook Extensions.ipynb"]}, {"commit_id": "98745984c26c9cdec47e3cf9dc6a2643df7843b0", "commit_date": "Mon Aug 31 18:46:55 2015 +0200", "commit_message": "Remove auto generate `.rst` files", "files_name": ["docs/source/examples/Notebook/Configuring the Notebook and Server.rst", "docs/source/examples/Notebook/Connecting with the Qt Console.rst", "docs/source/examples/Notebook/Custom Keyboard Shortcuts.rst", "docs/source/examples/Notebook/Examples and Tutorials Index.rst", "docs/source/examples/Notebook/Importing Notebooks.rst", "docs/source/examples/Notebook/JavaScript Notebook Extensions.rst", "docs/source/examples/Notebook/Notebook Basics.rst", "docs/source/examples/Notebook/Running Code.rst", "docs/source/examples/Notebook/Typesetting Equations.rst", "docs/source/examples/Notebook/What is the Jupyter Notebook.rst", "docs/source/examples/Notebook/Working With Markdown Cells.rst"]}, {"commit_id": "552fd197d5983b33de0921865568390054631503", "commit_date": "Mon Aug 31 14:15:01 2015 +0200", "commit_message": "port some typos", "files_name": ["docs/source/examples/Notebook/JavaScript Notebook Extensions.ipynb"]}, {"commit_id": "eeb95739914a966f1bbfaf203d7f09ea38576eef", "commit_date": "Wed Sep 2 15:12:04 2015 +0200", "commit_message": "bring more fixes", "files_name": ["docs/source/examples/Notebook/JavaScript Notebook Extensions.ipynb"]}, {"commit_id": "2189b7f6866acb3f7da00ec37b8e2e767b0245d6", "commit_date": "Thu Sep 3 11:16:19 2015 +0200", "commit_message": "Merge pull request #363 from Carreau/docs-typo", "files_name": ["5cd247f5f65fa19f486bd76151f2ffcffb999ef0 - Fri Aug 28 01:21:57 2015 +0200 : swapped glass for keyboard for command palette icon", "notebook/static/notebook/js/actions.js"]}, {"commit_id": "7056b10045d0eed35ca35aff97b787a47729c530", "commit_date": "Thu Sep 3 11:30:26 2015 +0200", "commit_message": "Merge pull request #370 from Carreau/fix-flexbox", "files_name": ["bd03233e8b10eb251fd4aa2367bf1b5164d5c4f8 - Thu Sep 3 11:43:32 2015 +0200 : Merge pull request #382 from Carreau/rebase-358", "d16576eb683d1761b079615768657b63d78047ba - Thu Sep 3 11:47:26 2015 +0200 : Use more pythonic way to check wether module have attribute", "notebook/nbextensions.py"]}, {"commit_id": "39ffd32eba79155853a63a99982b4487762b575d", "commit_date": "Thu Sep 3 12:05:31 2015 +0200", "commit_message": "Merge pull request #383 from Carreau/303", "files_name": ["6880715826ccb1523938b79c31c7ba8168bf0625 - Thu Sep 3 14:31:38 2015 +0100 : Use a 401 status code for invalid login attempts. Fixes #384", "notebook/auth/login.py"]}, {"commit_id": "798fc8acefb0649abaf7fad970231c5f5fe51a69", "commit_date": "Thu Sep 3 22:33:35 2015 +0200", "commit_message": "move swagger API handler off of existing `/api`", "files_name": ["notebook/services/api/handlers.py"]}, {"commit_id": "65484f0b1c152f27c2dd1ef8254e35755eb90ab0", "commit_date": "Thu Sep 3 22:46:23 2015 +0200", "commit_message": "Merge pull request #385 from iiSeymour/master", "files_name": ["3251cb90fae07a32b54afa90946a082e306def6c - Fri Sep 4 15:34:27 2015 +0100 : require bootstrap in base/js/dialog.js", "notebook/static/base/js/dialog.js"]}, {"commit_id": "e79b84cd6b2f30098d42fea4c3d64663fc32540b", "commit_date": "Fri Sep 4 17:09:52 2015 +0200", "commit_message": "Merge pull request #393 from jcb91/master", "files_name": ["931fbb4f50e97a0e84d6a72d6aa4e1946b673b17 - Sun Sep 6 15:22:14 2015 +0200 : Merge pull request #390 from minrk/swagger-api", "0615c251f28b92bf821f085d6356e98d6799d34c - Sun Sep 6 15:51:20 2015 +0200 : add restart-run-all action", "notebook/static/notebook/js/actions.js", "notebook/static/notebook/js/menubar.js"]}, {"commit_id": "31f0ef480b708a3084bc893467c9e73f5e4d77b9", "commit_date": "Sun Sep 6 15:51:34 2015 +0200", "commit_message": "add Restart & Run All to Kernel Menu", "files_name": ["notebook/templates/notebook.html"]}, {"commit_id": "17499ebb49f1361244cb476292adea6f7871f938", "commit_date": "Sun Sep 6 17:57:58 2015 +0200", "commit_message": "Notebook.restart_kernel returns a promise", "files_name": ["notebook/static/notebook/js/actions.js", "notebook/static/notebook/js/notebook.js"]}, {"commit_id": "5e6339180e0c32b5741e8987d5a605cb032e8c4b", "commit_date": "Wed Aug 19 12:52:09 2015 -0700", "commit_message": "remove unconditional IPython import from notebookapp", "files_name": ["notebook/notebookapp.py"]}, {"commit_id": "f1396457fb01ab9d83c07e07d3771ebf9520e0c8", "commit_date": "Thu Aug 20 16:40:42 2015 -0700", "commit_message": "run commands with shell=True", "files_name": ["setupbase.py"]}, {"commit_id": "f175b2391ae468de39831e65674012c9543b0ccb", "commit_date": "Fri Aug 28 08:03:39 2015 -0700", "commit_message": "shell=True wants a string cmd", "files_name": ["setupbase.py"]}, {"commit_id": "bce9c94f32d2257f14895dc0fb3137faaeedb46e", "commit_date": "Sun Sep 6 11:42:57 2015 -0700", "commit_message": "Fix overzealous auto escape", "files_name": ["notebook/templates/notebook.html"]}, {"commit_id": "c451342c81a546f498d7330bf8f6937ab02c78c9", "commit_date": "Sat Jun 27 18:44:38 2015 -0400", "commit_message": "Adding comm_info method", "files_name": ["notebook/static/services/kernels/kernel.js"]}, {"commit_id": "a3fa53f0f40fad61b82e7b06e3da52047ee33e6b", "commit_date": "Mon Sep 7 15:48:17 2015 -0400", "commit_message": "Filter by target name", "files_name": ["notebook/static/services/kernels/kernel.js"]}, {"commit_id": "0641b68d4044585d80b61899b21ff6e984971ce1", "commit_date": "Tue Sep 8 09:16:21 2015 +0200", "commit_message": "Merge pull request #166 from SylvainCorlay/comm_list_shell_message", "files_name": ["159b470c866ff04b264cc804d029a1b85b7d1249 - Tue Sep 8 09:39:39 2015 +0200 : Merge pull request #401 from Carreau/overz", "70e918691467bb0baa197331f335523cff3ef25f - Tue Sep 8 10:08:34 2015 +0200 : bump requirejs waitSeconds to 30", "notebook/templates/page.html"]}, {"commit_id": "c29b8780a37f29d84570610563fb4238cd318025", "commit_date": "Tue Sep 8 09:11:49 2015 -0700", "commit_message": "update shortcut", "files_name": ["docs/source/examples/Notebook/Notebook Basics.ipynb"]}, {"commit_id": "32112d2509dfb3fa24a09fb8c41fe00b2c9ac0ab", "commit_date": "Tue Sep 8 22:36:21 2015 +0200", "commit_message": "Merge pull request #407 from Carreau/fix-shrt", "files_name": ["a7fae2c6f9413877634411670633d98d616d592a - Tue Sep 8 15:41:33 2015 -0700 : Added description text to setup.py", "setup.py"]}, {"commit_id": "f64aa490e3574ee2c2b504d0e0b39641c709a34f", "commit_date": "Mon Jul 20 12:10:25 2015 -0700", "commit_message": "set model mimetype, even when content=False", "files_name": ["notebook/services/contents/filemanager.py", "notebook/services/contents/handlers.py"]}, {"commit_id": "4f0b3b8c10811d460efc67cf61e9f4df83d2a0a7", "commit_date": "Mon Jul 20 12:11:04 2015 -0700", "commit_message": "only redirect to editor for text documents", "files_name": ["notebook/static/tree/js/notebooklist.js"]}, {"commit_id": "23162fd2895ad7445fdbe095b8fc8633d95ec6e6", "commit_date": "Mon Jul 20 12:11:23 2015 -0700", "commit_message": "Don't redirect from /edit/ to /files/", "files_name": ["notebook/static/edit/js/editor.js"]}, {"commit_id": "71cb6b9b69495a85522ef26cab25804946660889", "commit_date": "Wed Sep 9 16:41:45 2015 +0100", "commit_message": "Avoid loading nbextensions twice by keeping track of which have been loaded", "files_name": ["notebook/static/base/js/utils.js"]}, {"commit_id": "6cec1eada4a5980d5910a02aa449e2c12e6822c0", "commit_date": "Wed Sep 9 16:49:29 2015 -0700", "commit_message": "Added long_description to setup.py", "files_name": ["setup.py"]}, {"commit_id": "d43d72f10d8a425432351222129d9100e64e8827", "commit_date": "Wed Sep 9 18:20:06 2015 -0700", "commit_message": "Merge pull request #408 from captainsafia/pypi-description", "files_name": ["8790cc182e1cd93103441ffc8139d49db383c152 - Thu Sep 10 15:30:40 2015 -0500 : Only install ipython as is", "Dockerfile"]}, {"commit_id": "54a6d94447b2d85008ecacb66edc2a2244f1117b", "commit_date": "Thu Sep 10 15:53:37 2015 -0500", "commit_message": "ipykernel direct, no tests in container", "files_name": ["Dockerfile"]}, {"commit_id": "668812ad8590ddb07ce8b85b77735cecf370e8b2", "commit_date": "Thu Sep 10 16:52:31 2015 -0400", "commit_message": ".travis.yml: Test on Python 3.3, as well.", "files_name": [".travis.yml"]}, {"commit_id": "e0190edec132c2678b3c1e9b24d63e9a15c810bf", "commit_date": "Fri Sep 11 10:20:55 2015 +0200", "commit_message": "Merge pull request #417 from rgbkrk/docker-cleanup", "files_name": ["f3dc957ec5fb2c4ee37b3cd23414f7670c2f6cfb - Fri Sep 11 10:24:36 2015 +0200 : Merge pull request #416 from jakirkham/test_python_33", "a0fed9b42bf5055805f2b1cfc164b11f4a6ea567 - Fri Sep 11 10:25:26 2015 +0200 : Merge pull request #409 from jcb91/master", "235c2cc18d0946575bd7238bf3bc0bfdd7e46caf - Fri Sep 11 15:08:42 2015 +0200 : bump term.js to 0.0.7", "bower.json"]}, {"commit_id": "65f15d13868bc3a01ad76b38f2d127cf488aba65", "commit_date": "Fri Sep 11 09:09:22 2015 -0700", "commit_message": "Merge pull request #321 from minrk/shell-true", "files_name": ["f6ef532d6722e969ff332e08866c01d623477d1c - Fri Sep 11 09:16:48 2015 -0700 : Merge pull request #418 from minrk/termjs-007", "abc08607841647854b16005bf7a24ccb71a5a07c - Fri Sep 11 09:22:47 2015 -0700 : Merge pull request #313 from minrk/rm-ipython-import", "e901e4d1f2582d410f7b8de2d312c3e95d04f8df - Fri Sep 11 15:46:35 2015 -0700 : Merge pull request #169 from Security513/master", "806cd1f98991bf7fb2a4291220587f88f2c0659d - Fri Sep 11 16:04:34 2015 -0700 : Merge pull request #400 from minrk/restart-run-all", "498bdb66b319de45b3494f215aa1d38426669463 - Sat Sep 12 09:32:01 2015 +0800 : add a style for password input", "notebook/templates/login.html"]}, {"commit_id": "f9280708b2e438f0b6dcdb834afa95ddc4480bb5", "commit_date": "Sat Sep 12 04:02:34 2015 -0700", "commit_message": "Add examples of latex expressions", "files_name": ["docs/source/examples/Notebook/Working With Markdown Cells.ipynb"]}, {"commit_id": "f493ed924f1fbdabb3227a2d632d1e98aa8e05db", "commit_date": "Sat Sep 12 17:30:28 2015 +0200", "commit_message": "Merge pull request #420 from Jeffiy/master", "files_name": ["7d331cbbc914c00db655a7c5666accf5c53292f9 - Sat Sep 12 22:07:52 2015 +0200 : Merge pull request #421 from germ13/patch-1", "c4f2c5ac233021a12ad748299c7506a0b8c82f39 - Sun Sep 13 18:49:24 2015 -0700 : Acknowledge \"ingnore_minified\" on editor page.", "notebook/static/notebook/js/cell.js", "notebook/templates/edit.html", "notebook/templates/notebook.html"]}, {"commit_id": "172c6e272ffd74962dba5b320fbedcad4bce1ce3", "commit_date": "Mon Sep 14 08:25:38 2015 +0200", "commit_message": "Merge pull request #423 from Carreau/ignore-min-edit", "files_name": ["49f8eaf7b830667b9100b9df39c1368f57518be1 - Mon Sep 14 14:42:35 2015 +0200 : use events.on for notebook first-load", "notebook/static/notebook/js/main.js"]}, {"commit_id": "e33741f93f5784f43ac2fbe5fc45d2480bff7cf4", "commit_date": "Mon Sep 14 14:45:21 2015 +0200", "commit_message": "catch errors in app_initialized callbacks", "files_name": ["notebook/static/notebook/js/main.js"]}, {"commit_id": "937b42fda4362d1c37e4c3601c3feb4e12951045", "commit_date": "Mon Sep 14 09:35:21 2015 -0700", "commit_message": "Only hide top-level-header.", "files_name": ["notebook/static/base/less/page.less", "notebook/static/notebook/less/notebook.less"]}, {"commit_id": "b521d76ebb277ae57a388b4729a04f8d79e858b5", "commit_date": "Mon Sep 14 10:16:01 2015 -0700", "commit_message": "Merge pull request #424 from minrk/custom-js-safe", "files_name": ["5fadb67dda39bafdd36be986b47bad3dfd253b1e - Mon Sep 14 11:20:12 2015 -0700 : Deprecate duplicate functions from utils.", "notebook/static/base/js/utils.js", "notebook/static/notebook/js/completer.js", "notebook/static/notebook/js/tooltip.js"]}, {"commit_id": "c3edf61befd610b3d423617cea2b5cfb0fe0202e", "commit_date": "Mon Sep 14 16:30:16 2015 -0700", "commit_message": "Fix typos.", "files_name": ["notebook/static/base/js/utils.js"]}, {"commit_id": "5162a9ed48cd2634ef39c8be400e0ce551bef586", "commit_date": "Tue Sep 15 08:24:45 2015 +0200", "commit_message": "Merge pull request #426 from Carreau/fix-100", "files_name": ["8f1b2e9fd931ac0e7b28d81d2920b0e8014748e3 - Tue Sep 15 08:28:23 2015 +0200 : Merge pull request #427 from Carreau/fix-245", "9969cce177f46558ca18f11698b57f94b2b02fd7 - Tue Sep 15 10:17:44 2015 -0700 : Added rstrip on notebook_dir to resolve #411", "notebook/notebookapp.py"]}, {"commit_id": "8ec8a520e84104770399bc21ebb599bc88b98335", "commit_date": "Tue Sep 15 10:48:55 2015 -0700", "commit_message": "Merge pull request #404 from minrk/rjs-timeout", "files_name": ["292ba6fd1b2f8bd868a432bc680e6305b8617118 - Tue Sep 15 10:59:31 2015 -0700 : Added tests for notebook path with backslash", "notebook/tests/test_notebookapp.py"]}, {"commit_id": "36d5131a4b9a30e6b5d658a28209d58cbf472a74", "commit_date": "Tue Sep 15 11:58:51 2015 -0700", "commit_message": "Added notebook_dir validations to _validate function", "files_name": ["notebook/notebookapp.py"]}, {"commit_id": "84f1f6fc3d0fbee4444be442585d87ca100d9b9c", "commit_date": "Tue Sep 15 12:22:42 2015 -0700", "commit_message": "Replace backslash with slash", "files_name": ["notebook/notebookapp.py", "notebook/tests/test_notebookapp.py"]}, {"commit_id": "009ae06e6642c1589b2d326bea69b463c0e569d9", "commit_date": "Tue Sep 15 21:55:02 2015 +0200", "commit_message": "Merge pull request #433 from captainsafia/title-double-backslash", "files_name": ["7d3be593a8cc374b9624bdf8464626866eda064f - Tue Sep 15 09:41:00 2015 -0700 : Fix bad message break notebook", "notebook/static/services/kernels/kernel.js"]}, {"commit_id": "1fe6dbb4e440870d418d64164eededbe3800e0ef", "commit_date": "Tue Sep 15 13:54:39 2015 -0700", "commit_message": "Merge pull request #431 from Carreau/fix-58", "files_name": ["2fcf9fcd76fa7bde1e00ca3316f3035381f336a2 - Tue Sep 15 14:39:59 2015 -0700 : Remove bootstrap dependency", "notebook/static/notebook/js/menubar.js"]}, {"commit_id": "dcc8555778c61681184438bca73fef965d5c0726", "commit_date": "Tue Sep 15 15:49:10 2015 -0700", "commit_message": "Merge pull request #435 from jdfreder/removebs", "files_name": ["cc32f165e80bedfde96ef9ea2d7ac0bcb678f4e9 - Wed Sep 16 12:17:48 2015 +0200 : Merge edit-redirect fix", "9f0537d3733c195cd40b4802f438c47a1e42e541 - Tue Sep 15 13:01:29 2015 -0400 : added cross origin websocket handling for terminal, resolves jupyter/notebook#432", "notebook/terminal/handlers.py"]}, {"commit_id": "2e16713e3250d0eb2174e5fb4f8dd21b126578d1", "commit_date": "Wed Sep 16 13:31:23 2015 -0400", "commit_message": "moved check_origin to IPythonHandler", "files_name": ["notebook/base/handlers.py", "notebook/terminal/handlers.py"]}], "parents": [{"commit_id_before": "474a3bb04e1172e3e2f84cd6d146633f9a1b15ae", "url_before": "https://api.github.com/repos/jupyter/notebook/commits/474a3bb04e1172e3e2f84cd6d146633f9a1b15ae", "html_url_before": "https://github.com/jupyter/notebook/commit/474a3bb04e1172e3e2f84cd6d146633f9a1b15ae"}], "details": [{"raw_url": "https://github.com/jupyter/notebook/raw/35f32dd2da804d108a3a3585b69ec3295b2677ed/notebook%2Fnotebookapp.py", "code": "# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport base64\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nimport webbrowser\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\nfrom .base.handlers import Template404\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler, IPythonHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type,\n)\nfrom ipython_genutils import py3compat\nfrom IPython.paths import get_ipython_dir\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n\nclass DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=ipython_app.ignore_minified_js,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n\n", "code_before": "# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport base64\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport ssl\nimport sys\nimport threading\nimport webbrowser\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\nfrom .base.handlers import Template404\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler, IPythonHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type,\n)\nfrom ipython_genutils import py3compat\nfrom IPython.paths import get_ipython_dir\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n\nclass DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = jinja_env_options if jinja_env_options else {}\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=ipython_app.ignore_minified_js,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n\n", "patch": "@@ -159,7 +159,9 @@ def init_settings(self, ipython_app, kernel_manager, contents_manager,\n             _template_path = (_template_path,)\n         template_path = [os.path.expanduser(path) for path in _template_path]\n \n-        jenv_opt = jinja_env_options if jinja_env_options else {}\n+        jenv_opt = {\"autoescape\": True}\n+        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n+\n         env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n         \n         sys_info = get_sys_info()", "file_path": "files/2015_9/607", "file_language": "py", "file_name": "notebook/notebookapp.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2                     \n          Detected direct use of jinja2. If not done properly, this may bypass HTML escaping which   \n          opens up the application to cross-site scripting (XSS) vulnerabilities. Prefer using the   \n          Flask method 'render_template()' and templates with a '.html' extension in order to prevent\n          XSS.                                                                                       \n          Details: https://sg.run/RoKe                                                               \n\n          163\u2506 env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)"]]}, "target": 1, "function_before": [{"function": "def random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))", "target": 0}, {"function": "def load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers", "target": 0}, {"function": "class DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')", "target": 0}, {"function": "class NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = jinja_env_options if jinja_env_options else {}\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=ipython_app.ignore_minified_js,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers", "target": 1, "line": "@@  -159,7 +159,9  @@ def init_settings(self, ipython_app, kernel_manager, contents_manager,\n             _template_path = (_template_path,)\n         template_path = [os.path.expanduser(path) for path in _template_path]\n \n-        jenv_opt = jinja_env_options if jinja_env_options else {}\n+        jenv_opt = {\"autoescape\": True}\n+        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n+\n         env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n         \n         sys_info = get_sys_info()"}, {"function": "class NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])", "target": 0}, {"function": "class NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)", "target": 0}, {"function": "def list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something", "target": 0}], "function_after": [{"function": "def random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))", "target": 0}, {"function": "def load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers", "target": 0}, {"function": "class DeprecationHandler(IPythonHandler):\n    def get(self, url_path):\n        self.set_header(\"Content-Type\", 'text/javascript')\n        self.finish(\"\"\"\n            console.warn('`/static/widgets/js` is deprecated.  Use `/nbextensions/widgets/widgets/js` instead.');\n            define(['%s'], function(x) { return x; });\n        \"\"\" % url_path_join('nbextensions', 'widgets', 'widgets', url_path.rstrip('.js')))\n        self.log.warn('Deprecated widget Javascript path /static/widgets/js/*.js was used')", "target": 0}, {"function": "class NotebookWebApplication(web.Application):\n\n    def __init__(self, ipython_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        settings = self.init_settings(\n            ipython_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, ipython_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            ipython_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=ipython_app.static_file_path,\n            static_custom_path=ipython_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=ipython_app.ignore_minified_js,\n            \n            # authentication\n            cookie_secret=ipython_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=ipython_app.login_handler_class,\n            logout_handler_class=ipython_app.logout_handler_class,\n            password=ipython_app.password,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=ipython_app.jinja_template_vars,\n            nbextensions_path=ipython_app.nbextensions_path,\n            websocket_url=ipython_app.websocket_url,\n            mathjax_url=ipython_app.mathjax_url,\n            config=ipython_app.config,\n            config_dir=ipython_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.append((r'/deprecatedwidgets/(.*)', DeprecationHandler))\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        try:\n            import ipywidgets\n            handlers.append(\n                (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                    'path': ipywidgets.find_static_assets(),\n                    'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                }),\n            )\n        except:\n            app_log.warn('ipywidgets package not installed.  Widgets are unavailable.')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', web.RedirectHandler, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers", "target": 0}, {"function": "class NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers in this profile.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                print(serverinfo['url'], \"::\", serverinfo['notebook_dir'])", "target": 0}, {"function": "class NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    def _log_level_default(self):\n        return logging.INFO\n\n    def _log_datefmt_default(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    def _log_format_default(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    # create requested profiles by default, if they don't exist:\n    auto_create = Bool(True)\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n    def _ip_default(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warn(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    def _ip_changed(self, name, old, new):\n        if new == u'*': self.ip = u''\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n    def _cookie_secret_file_default(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    def _cookie_secret_default(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = base64.encodestring(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warn(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n    def _webapp_settings_changed(self, name, old, new):\n        self.log.warn(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = new\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n    def _enable_mathjax_changed(self, name, old, new):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not new:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n    def _base_url_changed(self, name, old, new):\n        if not new.startswith('/'):\n            self.base_url = '/'+new\n        elif not new.endswith('/'):\n            self.base_url = new+'/'\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n    def _base_project_url_changed(self, name, old, new):\n        self.log.warn(\"base_project_url is deprecated, use base_url\")\n        self.base_url = new\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n    def _static_custom_path_default(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                # FIXME: serve IPython profile while we don't have `jupyter migrate`\n                os.path.join(get_ipython_dir(), 'profile_default', 'static'),\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path once migration is setup\n        path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"The url for MathJax.js.\"\"\"\n    )\n    def _mathjax_url_default(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\",\n                         url_path_join(self.base_url, \"static\")\n        )\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    def _mathjax_url_changed(self, name, old, new):\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    def _info_file_default(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n    def _pylab_changed(self, name, old, new):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if new != 'warn':\n            backend = ' %s' % new\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    def _notebook_dir_default(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    def _notebook_dir_changed(self, name, old, new):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        if not os.path.isabs(new):\n            # If we receive a non-absolute path, make it absolute.\n            self.notebook_dir = os.path.abspath(new)\n            return\n        if not os.path.isdir(new):\n            raise TraitError(\"No such notebook dir: %r\" % new)\n        \n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    server_extensions = List(Unicode(), config=True,\n        help=(\"Python modules to load as notebook server extensions. \"\n              \"This is an experimental API, and may change in future releases.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n        \n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the profile.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n        \n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # Disable SSLv3, since its use is discouraged.\n            ssl_options['ssl_version']=ssl.PROTOCOL_TLSv1\n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another random port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warn(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        return self._url(ip)\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warn\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        for modulename in self.server_extensions:\n            try:\n                mod = importlib.import_module(modulename)\n                func = getattr(mod, 'load_jupyter_server_extension', None)\n                if func is not None:\n                    func(self)\n            except Exception:\n                if self.reraise_server_extension_failures:\n                    raise\n                self.log.warn(\"Error loading server extension %s\", modulename,\n                              exc_info=True)\n    \n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'pid': os.getpid()\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warn('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_path_join('notebooks', *relpath.split(os.sep))\n            else:\n                uri = 'tree'\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n        \n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.cleanup_kernels()\n            self.remove_server_info_file()\n    \n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)", "target": 0}, {"function": "def list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a profile name, find nbserver-* files in the security directory of\n    that profile, and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(file)\n                except OSError:\n                    pass  # TODO: This should warn or log or something", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
