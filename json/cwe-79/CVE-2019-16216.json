{"index": 3854, "cve_id": "CVE-2019-16216", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Zulip server before 2.0.5 incompletely validated the MIME types of uploaded files. A user who is logged into the server could upload files of certain types to mount a stored cross-site scripting attack on other logged-in users. On a Zulip server using the default local uploads backend, the attack is only effective against browsers lacking support for Content-Security-Policy such as Internet Explorer 11. On a Zulip server using the S3 uploads backend, the attack is confined to the origin of the configured S3 uploads hostname and cannot reach the Zulip server itself.", "cvss": "5.4", "publish_date": "September 18, 2019", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "1195841dfb9aa26b3b0dabc6f05d72e4af25be3e", "commit_message": "CVE-2019-16216: Fix MIME type validation.\n\n* Whitelist a small number of image/ types to be served as\n  non-attachments.\n* Serve the file using the type that we validated rather than relying\n  on an independent guess to match.\n\nThis issue can lead to a stored XSS security vulnerability for older\nbrowsers that don't support Content-Security-Policy.\n\nIt primarily affects servers using Zulip's local file uploads backend\nfor servers running Ubuntu 16.04 Xenial or newer; the legacy local\nfile upload backend for (now EOL) Ubuntu 14.04 Trusty was not affected\nand it has limited impact for the S3 upload backend (which uses an\nunprivileged S3 bucket domain to serve files).\n\nThis was fixed in master via 780ecb672b9324ba879056240089e14539cda6e4.\n\nSigned-off-by: Anders Kaseorg <anders@zulipchat.com>", "commit_date": "2019-09-11T22:46:55Z", "project": "zulip/zulip", "url": "https://api.github.com/repos/zulip/zulip/commits/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e", "html_url": "https://github.com/zulip/zulip/commit/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e", "windows_before": [{"commit_id": "780ecb672b9324ba879056240089e14539cda6e4", "commit_date": "Mon Sep 9 15:21:31 2019 -0700", "commit_message": "CVE-2019-16216: Fix MIME type validation.", "files_name": ["zerver/lib/upload.py", "zerver/views/upload.py"]}, {"commit_id": "a1fa0b011e2656bb3c1a08837b9e50ed782a88e4", "commit_date": "Mon Sep 9 19:44:20 2019 +0200", "commit_message": "docs: Fix typo in production/email.md.", "files_name": ["docs/production/email.md"]}, {"commit_id": "6bab61a0d640f417a7b986983067c288a56fb94a", "commit_date": "Tue Sep 10 11:45:00 2019 -0700", "commit_message": "styles: Remove overrides for KaTeX line-height and white-space.", "files_name": ["static/styles/rendered_markdown.scss"]}, {"commit_id": "ea17673885c826d8b6f5c173ce5a4c9395d58084", "commit_date": "Mon Sep 9 12:04:23 2019 +0530", "commit_message": "docs: Include su in email docs restart-server command.", "files_name": ["docs/production/email.md"]}, {"commit_id": "17192ed46b6b231ce62aafb29e90ecb62309011e", "commit_date": "Mon Sep 9 13:06:07 2019 -0700", "commit_message": "Revert \"provision: Give concrete NFS error message on older OSX versions.\"", "files_name": ["tools/setup/generate_zulip_bots_static_files.py"]}, {"commit_id": "574c35c0b84385692d613df443c1266b0e273d29", "commit_date": "Sun Aug 11 13:41:34 2019 +0800", "commit_message": "markdown: Render ordered lists using <ol> markup.", "files_name": ["frontend_tests/node_tests/markdown.js", "static/js/markdown.js", "static/styles/rendered_markdown.scss", "static/third/marked/lib/marked.js", "zerver/lib/bugdown/__init__.py", "zerver/lib/push_notifications.py", "zerver/tests/fixtures/markdown_test_cases.json", "zerver/tests/test_bugdown.py"]}, {"commit_id": "4a176714e177f9f8cc43ac3b5681fd00d364462e", "commit_date": "Sun Sep 8 07:59:31 2019 -1000", "commit_message": "actions: Remove leftover print statement.", "files_name": ["zerver/lib/actions.py"]}, {"commit_id": "9c21fb75cf5fe3873e27dbeb84ad84b7741acccf", "commit_date": "Sun Sep 8 09:42:18 2019 -0700", "commit_message": "requirements: Upgrade twisted to 19.7.0.", "files_name": ["requirements/dev.in", "requirements/dev.txt"]}, {"commit_id": "7e75f987df6b537746fcbcb0614a2f9c42a21024", "commit_date": "Mon Aug 26 12:13:23 2019 -0700", "commit_message": "ldap: Fix logging of warning for deactivated users.", "files_name": ["zerver/management/commands/sync_ldap_user_data.py", "zerver/tests/test_auth_backends.py", "zproject/backends.py"]}, {"commit_id": "d1a2784d52fae52cca03d80887fd9eb35fb92892", "commit_date": "Fri Aug 23 13:02:30 2019 -0700", "commit_message": "ldap: Fix attempting to sync data for deactivated users.", "files_name": ["zerver/tests/test_auth_backends.py", "zproject/backends.py"]}, {"commit_id": "7af04690b946d687a20b04de6a66809c93cbd6aa", "commit_date": "Fri Sep 6 16:33:33 2019 -0700", "commit_message": "requirements: Use PyPI fork of line_profiler supporting Python 3.7.", "files_name": ["requirements/common.in", "requirements/dev.in", "requirements/dev.txt", "requirements/prod.txt", "version.py"]}, {"commit_id": "94251a93414679f78ad5f38848cb57d7e6c3803d", "commit_date": "Thu Sep 5 14:15:24 2019 -0700", "commit_message": "docs: Add a full article on modifying Zulip.", "files_name": ["docs/_templates/layout.html", "docs/production/index.rst", "docs/production/maintain-secure-upgrade.md", "docs/production/modifying-zulip.md"]}, {"commit_id": "81f06ab375433c5ca688ec8961c02c934e6aa981", "commit_date": "Thu Sep 5 19:50:41 2019 -0700", "commit_message": "readme: Remove Travis badge.", "files_name": ["README.md"]}, {"commit_id": "34dee2d953fb9d5c6311ce60cc725807571b7505", "commit_date": "Mon Aug 26 13:57:41 2019 -0700", "commit_message": "readme: Advertise digital ocean droplet and docker install.", "files_name": ["README.md"]}, {"commit_id": "2ce2024bd780c0e36712ebff332fe7e2191758cb", "commit_date": "Wed Sep 4 10:11:25 2019 +0200", "commit_message": "ldap: Fix unintended user deactivation in case of connection failure.", "files_name": ["zerver/tests/test_auth_backends.py", "zproject/backends.py"]}, {"commit_id": "7ca65b2bb56cd333e0f8943f5267161b7db221f0", "commit_date": "Thu Sep 5 11:54:58 2019 -0700", "commit_message": "css: Remove buggy stream settings media CSS for narrow windows.", "files_name": ["static/styles/subscriptions.scss"]}, {"commit_id": "fd5f9be14fadc91a32ae36c7779b016aaa532b2f", "commit_date": "Thu Sep 5 11:47:28 2019 -0700", "commit_message": "stream settings: Use fa-circle-o for link to /help/.", "files_name": ["static/templates/subscription_settings.hbs"]}, {"commit_id": "94c51676fe5609c637d042f316f478fb37a07a9a", "commit_date": "Thu Sep 5 11:46:48 2019 -0700", "commit_message": "stream settings: Use <label> tags for section labels.", "files_name": ["static/templates/subscription_members.hbs", "static/templates/subscription_settings.hbs"]}, {"commit_id": "8b5df8859641d7c9c618ba827b55ae8ac0bcd3b5", "commit_date": "Thu Sep 5 11:41:42 2019 -0700", "commit_message": "css: Make label CSS usable outside settings model.", "files_name": ["static/styles/settings.scss"]}, {"commit_id": "bf7f4f3f1b941f768eb53baec26ccc868902fa36", "commit_date": "Thu Sep 5 11:57:40 2019 +0200", "commit_message": "stream settings: Replace email address hint popup with link to docs.", "files_name": ["frontend_tests/node_tests/templates.js", "static/js/subs.js", "static/styles/subscriptions.scss", "static/templates/email_address_hint.hbs", "static/templates/subscription_settings.hbs"]}, {"commit_id": "dfd6771237d114ffc2ccee3dabfeb0e37fad035f", "commit_date": "Thu Sep 5 11:34:05 2019 +0200", "commit_message": "stream settings: Use the .show-sender version of email address.", "files_name": ["zerver/lib/actions.py", "zerver/lib/email_mirror_helpers.py", "zerver/tests/test_email_mirror.py"]}, {"commit_id": "307d8d87587f0ef7d8f7b6497031635d7993ce93", "commit_date": "Thu Sep 5 11:27:59 2019 +0200", "commit_message": "test_email_mirror: Better document the various address formats.", "files_name": ["zerver/tests/test_email_mirror.py"]}, {"commit_id": "30440cf466252dcfef691fa508aff4bac8ff1bed", "commit_date": "Thu Sep 5 14:30:07 2019 +0200", "commit_message": "mattermost: Fix test flake in test_convert_channel_data.", "files_name": ["zerver/tests/test_mattermost_importer.py"]}, {"commit_id": "df134be23501cb24f5abd548ddcdd5bc0db7d074", "commit_date": "Tue Sep 3 20:45:31 2019 +0530", "commit_message": "webhooks/papertrail: Requests from Papertrail are not JSON requests.", "files_name": ["zerver/webhooks/papertrail/fixtures/incorrect_post.json", "zerver/webhooks/papertrail/tests.py", "zerver/webhooks/papertrail/view.py"]}, {"commit_id": "b3df3f2e221f9473d5e9352979761bd974039108", "commit_date": "Wed Aug 28 00:42:49 2019 +0000", "commit_message": "docs/botserver: Document running custom bot modules.", "files_name": ["templates/zerver/api/deploying-bots.md"]}, {"commit_id": "fc2574fdfd2a3a95a28fa17df2e77cd9b958738c", "commit_date": "Tue Aug 20 16:14:02 2019 -1000", "commit_message": "test_mattermost_importer: Add test coverage.", "files_name": ["tools/test-backend", "zerver/tests/test_mattermost_importer.py"]}, {"commit_id": "a7ec1a089c2b3c5c531dde698df6c1396fb20437", "commit_date": "Tue Sep 3 06:08:14 2019 +0200", "commit_message": "errors: Fix infinite recursion during memcached outages.", "files_name": ["zerver/lib/logging_util.py", "zerver/tests/test_logging_handlers.py"]}, {"commit_id": "177eb2e02ef823a1103eb96cb41e9233bc73899d", "commit_date": "Fri Aug 30 10:16:28 2019 -0700", "commit_message": "webpack: Move CSS minification to optimization stage.", "files_name": ["package.json", "postcss.config.js", "tools/webpack.config.ts", "version.py", "yarn.lock"]}, {"commit_id": "ad116cac4c863878b2e5276a92508a2fb3405887", "commit_date": "Fri Aug 30 15:42:00 2019 -0700", "commit_message": "postcss: Add postcss-calc plugin.", "files_name": ["package.json", "postcss.config.js"]}, {"commit_id": "2bdb115581bda6bdb900c8365ef29c244cd8e8b5", "commit_date": "Fri Aug 30 16:18:03 2019 -0700", "commit_message": "styles: Remove stray semicolon from input.user_status block.", "files_name": ["static/styles/user_status.scss"]}, {"commit_id": "9b0401b76d5412899197f7f827468b24742dee8c", "commit_date": "Fri Aug 30 18:17:31 2019 -0700", "commit_message": "package.json: Use caret ranges for more deduplication opportunities.", "files_name": ["package.json", "version.py", "yarn.lock"]}, {"commit_id": "e57ede9421b0ea01e3494e91850135d771262c57", "commit_date": "Fri Aug 30 18:16:37 2019 -0700", "commit_message": "yarn.lock: Share duplicate packages with yarn-deduplicate.", "files_name": ["package.json", "tools/lint", "tools/run-yarn-deduplicate", "version.py", "yarn.lock"]}, {"commit_id": "e5ab9834c56423f47759bd49906515de9716fd55", "commit_date": "Fri Aug 30 18:49:27 2019 -0700", "commit_message": "logos: Golf harder with svgo 1.3.0.", "files_name": ["static/images/integrations/logos/appfollow.svg", "static/images/integrations/logos/appveyor.svg", "static/images/integrations/logos/basecamp.svg", "static/images/integrations/logos/beeminder.svg", "static/images/integrations/logos/bitbucket.svg", "static/images/integrations/logos/buildbot.svg", "static/images/integrations/logos/capistrano.svg", "static/images/integrations/logos/codebase.svg", "static/images/integrations/logos/codeship.svg", "static/images/integrations/logos/crashlytics.svg", "static/images/integrations/logos/discourse.svg", "static/images/integrations/logos/email.svg", "static/images/integrations/logos/errbot.svg", "static/images/integrations/logos/front.svg", "static/images/integrations/logos/gitlab.svg", "static/images/integrations/logos/gogs.svg", "static/images/integrations/logos/google-calendar.svg", "static/images/integrations/logos/google-hangouts.svg", "static/images/integrations/logos/gosquared.svg", "static/images/integrations/logos/greenhouse.svg", "static/images/integrations/logos/helloworld.svg", "static/images/integrations/logos/heroku.svg", "static/images/integrations/logos/instagra_m.svg", "static/images/integrations/logos/irc.svg", "static/images/integrations/logos/jenkins.svg", "static/images/integrations/logos/jira.svg", "static/images/integrations/logos/mailchimp.svg", "static/images/integrations/logos/matrix.svg", "static/images/integrations/logos/mention.svg", "static/images/integrations/logos/mercurial.svg", "static/images/integrations/logos/nagios.svg", "static/images/integrations/logos/netlify.svg", "static/images/integrations/logos/opbeat.svg", "static/images/integrations/logos/openshift.svg", "static/images/integrations/logos/opsgenie.svg", "static/images/integrations/logos/papertrail.svg", "static/images/integrations/logos/perforce.svg", "static/images/integrations/logos/rss.svg", "static/images/integrations/logos/sentry.svg", "static/images/integrations/logos/statuspage.svg", "static/images/integrations/logos/svn.svg", "static/images/integrations/logos/travis.svg", "static/images/integrations/logos/trello.svg", "static/images/integrations/logos/twitte_r.svg", "static/images/integrations/logos/wordpress.svg", "static/images/integrations/logos/zapier.svg", "static/images/integrations/logos/zendesk.svg"]}, {"commit_id": "70c513a64007c7339cce23ec05a99e9e46400574", "commit_date": "Mon Sep 2 18:47:10 2019 -0700", "commit_message": "analytics: Fix logging for errors connecting to push bouncer.", "files_name": ["zerver/lib/remote_server.py", "zerver/tests/test_push_notifications.py"]}, {"commit_id": "d0634181b57819aa0b0e7c6e30d9d17b439877e6", "commit_date": "Fri Aug 30 10:01:28 2019 -0700", "commit_message": "styles: Fix left sidebar indentation for PostCSS migration.", "files_name": ["static/styles/left-sidebar.scss"]}, {"commit_id": "d70e1bcdb77cba37ccb5a4a3e91e87e7bf3e5671", "commit_date": "Fri Aug 30 00:21:36 2019 +0200", "commit_message": "settings: Add FAKE_EMAIL_DOMAIN setting.", "files_name": ["frontend_tests/casper_tests/06-settings.js", "zerver/lib/create_user.py", "zerver/models.py", "zerver/tests/test_bots.py", "zerver/tests/test_users.py"]}], "windows_after": [{"commit_id": "fcf5936341df0e61f0d66e84202ec86e425d45a7", "commit_date": "Sun Sep 8 15:51:37 2019 -0700", "commit_message": "version: Update version and changelog for Zulip 2.0.5 release.", "files_name": ["docs/conf.py", "docs/overview/changelog.md", "version.py"]}, {"commit_id": "78b018989e84cf7d2198ae5ea95f5fcd4eee19bf", "commit_date": "Thu Sep 12 14:36:45 2019 -0700", "commit_message": "export: Refuse to overwrite an existing directory or tarball.", "files_name": ["zerver/management/commands/export.py"]}, {"commit_id": "2ec946ad4d8935f9c425dcfda01be04f84a830ba", "commit_date": "Thu Sep 12 15:14:32 2019 -0700", "commit_message": "postgres-init-db: Require an Enter press in confirmation prompt.", "files_name": ["scripts/setup/postgres-init-db"]}, {"commit_id": "698b0f1b9195baa77d8f482fd07d32c464e33c9d", "commit_date": "Thu Sep 12 11:06:36 2019 -1000", "commit_message": "test_management_commands: Use subTest with help tests.", "files_name": ["zerver/tests/test_management_commands.py"]}, {"commit_id": "4a64a487d3ca242c6ddaa9dc34e71c555c36b692", "commit_date": "Thu Sep 12 11:38:52 2019 -1000", "commit_message": "bugdown: Remove print statement from fixtures test.", "files_name": ["zerver/tests/test_bugdown.py"]}, {"commit_id": "dbaf6ac7e70dd3463e26b551964ac52a6cd6c745", "commit_date": "Thu Sep 12 20:02:43 2019 -1000", "commit_message": "test_push_notifications: Remove fixtures print statement.", "files_name": ["zerver/tests/test_push_notifications.py"]}, {"commit_id": "e3595e4b3f94750290bb2440786178d301797f13", "commit_date": "Thu Sep 12 20:11:25 2019 -1000", "commit_message": "test_slack_message_conversion: Use subTest for fixtures test.", "files_name": ["zerver/tests/test_slack_message_conversion.py"]}, {"commit_id": "e37c91d195d4a2c83f7b712a839b8165372e2577", "commit_date": "Thu Sep 12 20:23:28 2019 -1000", "commit_message": "test_realm_export: Use stdout_suppressed in tests.", "files_name": ["zerver/tests/test_realm_export.py"]}, {"commit_id": "d2c3ddc76546e1f4e2ac7dbc77aa21c36e5e9880", "commit_date": "Thu Sep 12 20:40:35 2019 -1000", "commit_message": "test_events: Use stdout_suppressed in export test.", "files_name": ["zerver/tests/test_events.py"]}, {"commit_id": "04e6c3bd18e17fbfb1f59e6aedc060fa7f82e957", "commit_date": "Sat Aug 31 13:54:00 2019 -0500", "commit_message": "docs/version-control: Set commit message line limit to 70.", "files_name": ["docs/contributing/version-control.md"]}, {"commit_id": "0a426c6a445f6ee2ab92cf785bbb64cd78ec43d4", "commit_date": "Mon Sep 16 16:31:21 2019 -0700", "commit_message": "settings: Add detailed comments explaining our postgres configuration.", "files_name": ["zproject/settings.py"]}, {"commit_id": "6f6c761d80f60f4f6880e1fc24053293848d4da5", "commit_date": "Mon Sep 16 17:16:44 2019 -0700", "commit_message": "docs: Further expand documentation on using IDs in narrows.", "files_name": ["templates/zerver/api/construct-narrow.md", "templates/zerver/help/search-for-messages.md"]}, {"commit_id": "ed63042480113227cc3d1f4b51da253210c063e0", "commit_date": "Fri Sep 13 11:56:51 2019 -0700", "commit_message": "templates: Replace focusing scripts with autofocus attribute.", "files_name": ["static/js/portico/signup.js", "templates/zerver/accounts_home.html", "templates/zerver/create_realm.html", "templates/zerver/login.html", "templates/zerver/reset.html", "templates/zerver/reset_confirm.html"]}, {"commit_id": "366dce5d52fd7839830e18acd5ec105247d176a7", "commit_date": "Fri Sep 13 16:26:57 2019 -0700", "commit_message": "confirm_preregistrationuser: Uninline script.", "files_name": ["static/js/portico/confirm-preregistrationuser.js", "templates/confirmation/confirm_preregistrationuser.html", "tools/webpack.assets.json"]}, {"commit_id": "9bb7249c4252b76b0a3717f62be494fecb11c31c", "commit_date": "Tue Aug 20 22:49:22 2019 +0300", "commit_message": "portico: Add hover behaviour to `Take the tour` button on /hello.", "files_name": ["static/styles/portico/landing-page.scss"]}, {"commit_id": "b94ea6553bf39c5f53786dab25a63f2bb5ac3bdf", "commit_date": "Tue Aug 20 22:51:32 2019 +0300", "commit_message": "portico: Fix gradient on /hello.", "files_name": ["static/styles/portico/landing-page.scss"]}, {"commit_id": "5b64a27597f460d30543e5f38ae35f782f2be1ea", "commit_date": "Tue Aug 20 22:52:12 2019 +0300", "commit_message": "portico: Add hover behavior for app icons on /hello.", "files_name": ["static/styles/portico/landing-page.scss"]}, {"commit_id": "8828ef72fe3c664cb5bd6f8010e6bd1d08eb5f79", "commit_date": "Tue Aug 20 23:02:06 2019 +0300", "commit_message": "portico: Add hover styling to `Atlassian migration guide` on /hello.", "files_name": ["static/styles/portico/landing-page.scss", "templates/zerver/hello.html"]}, {"commit_id": "2ebbd9a9170110e84fb13ae712dd79ca031a05aa", "commit_date": "Tue Sep 17 11:41:37 2019 -0700", "commit_message": "portico: Fix line-height in hero image description.", "files_name": ["static/styles/portico/landing-page.scss"]}, {"commit_id": "5452c0b4ac130a233a1cf3620803cb24b91e446a", "commit_date": "Thu Sep 12 10:18:30 2019 -0700", "commit_message": "open source: Document some recent and upcoming features.", "files_name": ["templates/zerver/for/open-source.md"]}, {"commit_id": "68f6f622a75e9fed6b035fa7095e4250aee2fc7f", "commit_date": "Thu Sep 12 12:45:16 2019 -0700", "commit_message": "open source: Add a more complete \"why zulip\" explanation.", "files_name": ["templates/zerver/for-open-source.html", "templates/zerver/for/open-source.md"]}, {"commit_id": "3e3deb2f1750b97684abd36b23b01b37dd391690", "commit_date": "Wed Jul 31 12:41:25 2019 +0530", "commit_message": "typeahead: Move tip text to bottom.", "files_name": ["static/styles/compose.scss", "static/third/bootstrap-typeahead/typeahead.js"]}, {"commit_id": "1df5cdc41ae0ec7e1a5df136fd0613e00de9ee4a", "commit_date": "Mon Sep 9 10:00:00 2019 +0530", "commit_message": "typeahead: Align the tip text centered vertically.", "files_name": ["static/styles/compose.scss"]}, {"commit_id": "9b38bcc2a6ac4dea3677f2cc2376bd9f66633ed5", "commit_date": "Fri Sep 13 17:44:46 2019 -0700", "commit_message": "templates: Abstract render_bundle behind a Jinja2 macro.", "files_name": ["docs/subsystems/front-end-build-process.md", "templates/analytics/activity.html", "templates/analytics/stats.html", "templates/analytics/support.html", "templates/confirmation/confirm_preregistrationuser.html", "templates/corporate/billing.html", "templates/corporate/jobs.html", "templates/corporate/upgrade.html", "templates/corporate/zephyr.html", "templates/zerver/app/index.html", "templates/zerver/apps.html", "templates/zerver/archive/index.html", "templates/zerver/atlassian.html", "templates/zerver/base.html", "templates/zerver/dev_login.html", "templates/zerver/digest_base.html", "templates/zerver/documentation_main.html", "templates/zerver/email_log.html", "templates/zerver/features.html", "templates/zerver/for-companies.html", "templates/zerver/for-mystery-hunt.html", "templates/zerver/for-open-source.html", "templates/zerver/for-working-groups-and-communities.html", "templates/zerver/hello.html", "templates/zerver/history.html", "templates/zerver/integrations/development/dev_panel.html", "templates/zerver/integrations/index.html", "templates/zerver/login.html", "templates/zerver/plans.html", "templates/zerver/portico.html", "templates/zerver/portico_signup.html", "templates/zerver/privacy.html", "templates/zerver/realm_creation_failed.html", "templates/zerver/register.html", "templates/zerver/reset_confirm.html", "templates/zerver/security.html", "templates/zerver/team.html", "templates/zerver/terms.html", "templates/zerver/why-zulip.html", "tools/lib/template_parser.py"]}, {"commit_id": "f1ecd3c18b9ae9cf914221d8e29ecf0015067ed0", "commit_date": "Fri Sep 13 17:44:53 2019 -0700", "commit_message": "templates: Defer all script execution.", "files_name": ["templates/zerver/base.html"]}, {"commit_id": "7494f1600c4ab6b505ffe676db007ed6099a667e", "commit_date": "Thu Sep 12 16:15:53 2019 -0700", "commit_message": "templates: Move page_params from an inline script to the <body> dataset.", "files_name": ["analytics/views.py", "corporate/views.py", "docs/THIRDPARTY", "static/js/bundles/common.js", "static/js/js_typings/zulip/index.d.ts", "static/js/page_params.js", "templates/analytics/stats.html", "templates/corporate/upgrade.html", "templates/zerver/app/index.html", "templates/zerver/base.html", "zerver/lib/json_encoder_for_html.py", "zerver/tests/test_home.py", "zerver/tests/test_json_encoder_for_html.py", "zerver/views/home.py"]}, {"commit_id": "fe7d814e8d07867561f11c0bc89076009aa0195a", "commit_date": "Thu Sep 12 16:38:24 2019 -0700", "commit_message": "team: Move contributors_list into page_params.", "files_name": ["static/js/portico/team.js", "templates/zerver/team.html", "zerver/views/users.py"]}, {"commit_id": "2646d70cbd634757ccb38f37117d4ace5a69020d", "commit_date": "Tue Sep 17 12:55:24 2019 -0700", "commit_message": "emails: Add realm name to footer of missed message emails.", "files_name": ["templates/zerver/emails/missed_message.source.html", "templates/zerver/emails/missed_message.txt", "zerver/tests/test_email_notifications.py"]}, {"commit_id": "0815a9bd53bd99f34534f8d6f3bbf0e9385d8eaa", "commit_date": "Wed Sep 18 11:18:12 2019 -0700", "commit_message": "docs: Add a link to changelog from section on deploying master.", "files_name": ["docs/production/modifying-zulip.md"]}, {"commit_id": "edee1251c85c55f5daea7069ca7890d9d29b5622", "commit_date": "Wed Sep 18 11:38:07 2019 -0700", "commit_message": "message_list: Replace buggy rerender_the_whole_thing.", "files_name": ["frontend_tests/node_tests/message_list.js", "static/js/message_list.js", "static/js/message_list_view.js"]}, {"commit_id": "bf5f531e9042c92be958e87772b217839ef0b69f", "commit_date": "Tue Aug 27 10:01:07 2019 +0000", "commit_message": "import_util: Support huddles in SubscriberHandler.", "files_name": ["zerver/data_import/import_util.py", "zerver/tests/test_mattermost_importer.py"]}, {"commit_id": "c4af0b7bc49c8af78f1085af2fbc6d8de5f64a48", "commit_date": "Sat Aug 31 10:46:01 2019 +0000", "commit_message": "mattermost: Support importing messages without team name.", "files_name": ["zerver/data_import/mattermost.py", "zerver/tests/test_mattermost_importer.py"]}, {"commit_id": "356e68e09eefcc3a3eee0f41540198a5dac0c197", "commit_date": "Wed Sep 18 12:11:58 2019 -0700", "commit_message": "test-backend: Temporarily disable coverage requirement for mattermost.", "files_name": ["tools/test-backend"]}, {"commit_id": "75d579847e8770ebdf0aebc19337f3c825794ed4", "commit_date": "Wed Sep 18 16:17:00 2019 -0700", "commit_message": "docs: Update changelog through current master.", "files_name": ["docs/overview/changelog.md"]}, {"commit_id": "cf5d3a3ef34e58a94ccbd84b67635a34f2b8a5f3", "commit_date": "Mon Sep 16 18:57:18 2019 -0300", "commit_message": "left sidebar: Fix bot availability status in \"private messages\".", "files_name": ["frontend_tests/node_tests/pm_list.js", "static/js/pm_list.js"]}, {"commit_id": "fc0554fcb8cfd790e528dcd2b634f9cdea5dc748", "commit_date": "Wed Sep 18 13:33:00 2019 -0700", "commit_message": "emoji: Finish removing leftover code from banned Emoji sets.", "files_name": ["tools/setup/emoji/emoji_setup_utils.py", "tools/setup/emoji/generate_emoji_names_table", "zerver/tests/test_email_notifications.py", "zerver/tests/test_events.py", "zerver/tests/test_users.py"]}, {"commit_id": "990f08da909ed64f0eefebb8805a4b7a878179a6", "commit_date": "Wed Sep 18 12:31:00 2019 -0700", "commit_message": "dependencies: Upgrade nearly all JavaScript dependencies to latest.", "files_name": ["package.json", "version.py", "yarn.lock"]}, {"commit_id": "b72bb8171b699a2f9c72cca12baaf2aa0a8122bb", "commit_date": "Wed Sep 18 19:53:37 2019 -0700", "commit_message": "nginx: Add CORS, HSTS, and X-Frame-Options headers to error responses.", "files_name": ["puppet/zulip/files/nginx/zulip-include-common/api_headers", "puppet/zulip/files/nginx/zulip-include-frontend/app"]}, {"commit_id": "6a08efc065a303a257ca3adce12555b299483b49", "commit_date": "Thu Sep 19 11:32:49 2019 +0530", "commit_message": "typeahead: Precompile regexes for removing diacritics.", "files_name": ["static/js/people.js"]}, {"commit_id": "050f814e47c35c099fc2afb8bf6ae6113ea8e73d", "commit_date": "Thu Sep 19 03:14:12 2019 +0200", "commit_message": "auth: Clean up SOCIAL_AUTH_BACKENDS / OAUTH_BACKEND_NAMES lists.", "files_name": ["zproject/backends.py"]}], "parents": [{"commit_id_before": "dca727f178e8d6fc35674d97df2b70628c2a197c", "url_before": "https://api.github.com/repos/zulip/zulip/commits/dca727f178e8d6fc35674d97df2b70628c2a197c", "html_url_before": "https://github.com/zulip/zulip/commit/dca727f178e8d6fc35674d97df2b70628c2a197c"}], "details": [{"raw_url": "https://github.com/zulip/zulip/raw/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e/zerver%2Flib%2Fupload.py", "code": "from typing import Optional, Tuple\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.core.files import File\nfrom django.http import HttpRequest\nfrom django.db.models import Sum\nfrom jinja2 import Markup as mark_safe\nimport unicodedata\n\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.exceptions import JsonableError, ErrorCode\n\nfrom boto.s3.bucket import Bucket\nfrom boto.s3.key import Key\nfrom boto.s3.connection import S3Connection\nfrom mimetypes import guess_type, guess_extension\n\nfrom zerver.models import get_user_profile_by_id\nfrom zerver.models import Attachment\nfrom zerver.models import Realm, RealmEmoji, UserProfile, Message\n\nimport urllib\nimport base64\nimport os\nimport re\nfrom PIL import Image, ImageOps, ExifTags\nfrom PIL.Image import DecompressionBombError\nfrom PIL.GifImagePlugin import GifImageFile\nimport io\nimport random\nimport logging\n\nDEFAULT_AVATAR_SIZE = 100\nMEDIUM_AVATAR_SIZE = 500\nDEFAULT_EMOJI_SIZE = 64\n\n# These sizes were selected based on looking at the maximum common\n# sizes in a library of animated custom emoji, balanced against the\n# network cost of very large emoji images.\nMAX_EMOJI_GIF_SIZE = 128\nMAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024 * 1024  # 128 kb\n\nINLINE_MIME_TYPES = [\n    \"application/pdf\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/webp\",\n    # To avoid cross-site scripting attacks, DO NOT add types such\n    # as application/xhtml+xml, application/x-shockwave-flash,\n    # image/svg+xml, text/html, or text/xml.\n]\n\n# Performance Note:\n#\n# For writing files to S3, the file could either be stored in RAM\n# (if it is less than 2.5MiB or so) or an actual temporary file on disk.\n#\n# Because we set FILE_UPLOAD_MAX_MEMORY_SIZE to 0, only the latter case\n# should occur in practice.\n#\n# This is great, because passing the pseudofile object that Django gives\n# you to boto would be a pain.\n\n# To come up with a s3 key we randomly generate a \"directory\". The\n# \"file name\" is the original filename provided by the user run\n# through a sanitization function.\n\nclass RealmUploadQuotaError(JsonableError):\n    code = ErrorCode.REALM_UPLOAD_QUOTA\n\nattachment_url_re = re.compile(r'[/\\-]user[\\-_]uploads[/\\.-].*?(?=[ )]|\\Z)')\n\ndef attachment_url_to_path_id(attachment_url: str) -> str:\n    path_id_raw = re.sub(r'[/\\-]user[\\-_]uploads[/\\.-]', '', attachment_url)\n    # Remove any extra '.' after file extension. These are probably added by the user\n    return re.sub('[.]+$', '', path_id_raw, re.M)\n\ndef sanitize_name(value: str) -> str:\n    \"\"\"\n    Sanitizes a value to be safe to store in a Linux filesystem, in\n    S3, and in a URL.  So unicode is allowed, but not special\n    characters other than \".\", \"-\", and \"_\".\n\n    This implementation is based on django.utils.text.slugify; it is\n    modified by:\n    * adding '.' and '_' to the list of allowed characters.\n    * preserving the case of the value.\n    \"\"\"\n    value = unicodedata.normalize('NFKC', value)\n    value = re.sub(r'[^\\w\\s._-]', '', value, flags=re.U).strip()\n    return mark_safe(re.sub(r'[-\\s]+', '-', value, flags=re.U))\n\ndef random_name(bytes: int=60) -> str:\n    return base64.urlsafe_b64encode(os.urandom(bytes)).decode('utf-8')\n\nclass BadImageError(JsonableError):\n    code = ErrorCode.BAD_IMAGE\n\nname_to_tag_num = dict((name, num) for num, name in ExifTags.TAGS.items())\n\n# https://stackoverflow.com/a/6218425\ndef exif_rotate(image: Image) -> Image:\n    if not hasattr(image, '_getexif'):\n        return image\n    exif_data = image._getexif()\n    if exif_data is None:\n        return image\n\n    exif_dict = dict(exif_data.items())\n    orientation = exif_dict.get(name_to_tag_num['Orientation'])\n\n    if orientation == 3:\n        return image.rotate(180, expand=True)\n    elif orientation == 6:\n        return image.rotate(270, expand=True)\n    elif orientation == 8:\n        return image.rotate(90, expand=True)\n\n    return image\n\ndef resize_avatar(image_data: bytes, size: int=DEFAULT_AVATAR_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\ndef resize_logo(image_data: bytes) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im.thumbnail((8*DEFAULT_AVATAR_SIZE, DEFAULT_AVATAR_SIZE), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\n\ndef resize_gif(im: GifImageFile, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    frames = []\n    duration_info = []\n    # If 'loop' info is not set then loop for infinite number of times.\n    loop = im.info.get(\"loop\", 0)\n    for frame_num in range(0, im.n_frames):\n        im.seek(frame_num)\n        new_frame = Image.new(\"RGBA\", im.size)\n        new_frame.paste(im, (0, 0), im.convert(\"RGBA\"))\n        new_frame = ImageOps.fit(new_frame, (size, size), Image.ANTIALIAS)\n        frames.append(new_frame)\n        duration_info.append(im.info['duration'])\n    out = io.BytesIO()\n    frames[0].save(out, save_all=True, optimize=True,\n                   format=\"GIF\", append_images=frames[1:],\n                   duration=duration_info,\n                   loop=loop)\n    return out.getvalue()\n\n\ndef resize_emoji(image_data: bytes, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        image_format = im.format\n        if image_format == \"GIF\":\n            # There are a number of bugs in Pillow.GifImagePlugin which cause\n            # results in resized gifs being broken. To work around this we\n            # only resize under certain conditions to minimize the chance of\n            # creating ugly gifs.\n            should_resize = any((\n                im.size[0] != im.size[1],                            # not square\n                im.size[0] > MAX_EMOJI_GIF_SIZE,                     # dimensions too large\n                len(image_data) > MAX_EMOJI_GIF_FILE_SIZE_BYTES,     # filesize too large\n            ))\n            return resize_gif(im, size) if should_resize else image_data\n        else:\n            im = exif_rotate(im)\n            im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            im.save(out, format=image_format)\n            return out.getvalue()\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n\n\n### Common\n\nclass ZulipUploadBackend:\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile,\n                            target_realm: Optional[Realm]=None) -> str:\n        raise NotImplementedError()\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_message_image(self, path_id: str) -> bool:\n        raise NotImplementedError()\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        raise NotImplementedError()\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        raise NotImplementedError()\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        raise NotImplementedError()\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        raise NotImplementedError()\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        raise NotImplementedError()\n\n\n### S3\n\ndef get_bucket(conn: S3Connection, bucket_name: str) -> Bucket:\n    # Calling get_bucket() with validate=True can apparently lead\n    # to expensive S3 bills:\n    #    http://www.appneta.com/blog/s3-list-get-bucket-default/\n    # The benefits of validation aren't completely clear to us, and\n    # we want to save on our bills, so we set the validate flag to False.\n    # (We think setting validate to True would cause us to fail faster\n    #  in situations where buckets don't exist, but that shouldn't be\n    #  an issue for us.)\n    bucket = conn.get_bucket(bucket_name, validate=False)\n    return bucket\n\ndef upload_image_to_s3(\n        bucket_name: str,\n        file_name: str,\n        content_type: Optional[str],\n        user_profile: UserProfile,\n        contents: bytes) -> None:\n\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    bucket = get_bucket(conn, bucket_name)\n    key = Key(bucket)\n    key.key = file_name\n    key.set_metadata(\"user_profile_id\", str(user_profile.id))\n    key.set_metadata(\"realm_id\", str(user_profile.realm_id))\n\n    headers = {}\n    if content_type is not None:\n        headers[\"Content-Type\"] = content_type\n    if content_type not in INLINE_MIME_TYPES:\n        headers[\"Content-Disposition\"] = \"attachment\"\n\n    key.set_contents_from_string(contents, headers=headers)  # type: ignore # https://github.com/python/typeshed/issues/1552\n\ndef currently_used_upload_space(realm: Realm) -> int:\n    used_space = Attachment.objects.filter(realm=realm).aggregate(Sum('size'))['size__sum']\n    if used_space is None:\n        return 0\n    return used_space\n\ndef check_upload_within_quota(realm: Realm, uploaded_file_size: int) -> None:\n    upload_quota = realm.upload_quota_bytes()\n    if upload_quota is None:\n        return\n    used_space = currently_used_upload_space(realm)\n    if (used_space + uploaded_file_size) > upload_quota:\n        raise RealmUploadQuotaError(_(\"Upload would exceed your organization's upload quota.\"))\n\ndef get_file_info(request: HttpRequest, user_file: File) -> Tuple[str, int, Optional[str]]:\n\n    uploaded_file_name = user_file.name\n    assert isinstance(uploaded_file_name, str)\n\n    content_type = request.GET.get('mimetype')\n    if content_type is None:\n        guessed_type = guess_type(uploaded_file_name)[0]\n        if guessed_type is not None:\n            content_type = guessed_type\n    else:\n        extension = guess_extension(content_type)\n        if extension is not None:\n            uploaded_file_name = uploaded_file_name + extension\n\n    uploaded_file_name = urllib.parse.unquote(uploaded_file_name)\n    uploaded_file_size = user_file.size\n\n    return uploaded_file_name, uploaded_file_size, content_type\n\n\ndef get_signed_upload_url(path: str) -> str:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    return conn.generate_url(15, 'GET', bucket=settings.S3_AUTH_UPLOADS_BUCKET, key=path)\n\ndef get_realm_for_filename(path: str) -> Optional[int]:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    key = get_bucket(conn, settings.S3_AUTH_UPLOADS_BUCKET).get_key(path)\n    if key is None:\n        # This happens if the key does not exist.\n        return None\n    return get_user_profile_by_id(key.metadata[\"user_profile_id\"]).realm_id\n\nclass S3UploadBackend(ZulipUploadBackend):\n    def delete_file_from_s3(self, path_id: str, bucket_name: str) -> bool:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n\n        # check if file exists\n        key = bucket.get_key(path_id)\n        if key is not None:\n            bucket.delete_key(key)\n            return True\n\n        file_name = path_id.split(\"/\")[-1]\n        logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n        return False\n\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        bucket_name = settings.S3_AUTH_UPLOADS_BUCKET\n        if target_realm is None:\n            target_realm = user_profile.realm\n        s3_file_name = \"/\".join([\n            str(target_realm.id),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n        url = \"/user_uploads/%s\" % (s3_file_name,)\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            content_type,\n            user_profile,\n            file_data\n        )\n\n        create_attachment(uploaded_file_name, s3_file_name, user_profile, uploaded_file_size)\n        return url\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return self.delete_file_from_s3(path_id, settings.S3_AUTH_UPLOADS_BUCKET)\n\n    def write_avatar_images(self, s3_file_name: str, target_user_profile: UserProfile,\n                            image_data: bytes, content_type: Optional[str]) -> None:\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            target_user_profile,\n            image_data,\n        )\n\n        # custom 500px wide version\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            target_user_profile,\n            resized_medium\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            'image/png',\n            target_user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        content_type = guess_type(user_file.name)[0]\n        s3_file_name = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(s3_file_name, target_user_profile,\n                                 image_data, content_type)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        self.delete_file_from_s3(path_id + \".original\", bucket_name)\n        self.delete_file_from_s3(path_id + \"-medium.png\", bucket_name)\n        self.delete_file_from_s3(path_id, bucket_name)\n\n    def get_avatar_key(self, file_name: str) -> Key:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket_name = settings.S3_AVATAR_BUCKET\n        bucket = get_bucket(conn, bucket_name)\n\n        key = bucket.get_key(file_name)\n        return key\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        s3_source_file_name = user_avatar_path(source_profile)\n        s3_target_file_name = user_avatar_path(target_profile)\n\n        key = self.get_avatar_key(s3_source_file_name + \".original\")\n        image_data = key.get_contents_as_string()  # type: ignore # https://github.com/python/typeshed/issues/1552\n        content_type = key.content_type\n\n        self.write_avatar_images(s3_target_file_name, target_profile, image_data, content_type)  # type: ignore # image_data is `bytes`, boto subs are wrong\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        medium_suffix = \"-medium.png\" if medium else \"\"\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s%s?x=x\" % (bucket, hash_key, medium_suffix)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        content_type = guess_type(icon_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', 'icon')\n\n        image_data = icon_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s/realm/icon.png?version=%s\" % (bucket, realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        content_type = guess_type(logo_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        if night:\n            basename = 'night_logo'\n        else:\n            basename = 'logo'\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', basename)\n\n        image_data = logo_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_logo(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        if not night:\n            file_name = 'logo.png'\n        else:\n            file_name = 'night_logo.png'\n        return \"https://%s.s3.amazonaws.com/%s/realm/%s?version=%s\" % (bucket, realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            user_profile,\n            resized_medium\n        )\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n        # Also TODO: Migrate to user_avatar_path(user_profile) + \".png\".\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_avatar = resize_avatar(image_data)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            \"image/png\",\n            user_profile,\n            resized_avatar\n        )\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        content_type = guess_type(emoji_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            \".\".join((emoji_path, \"original\")),\n            content_type,\n            user_profile,\n            image_data,\n        )\n        upload_image_to_s3(\n            bucket_name,\n            emoji_path,\n            content_type,\n            user_profile,\n            resized_image_data,\n        )\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id,\n                                                        emoji_file_name=emoji_file_name)\n        return \"https://%s.s3.amazonaws.com/%s\" % (bucket, emoji_path)\n\n\n### Local\n\ndef write_local_file(type: str, path: str, file_data: bytes) -> None:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'wb') as f:\n        f.write(file_data)\n\ndef read_local_file(type: str, path: str) -> bytes:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    with open(file_path, 'rb') as f:\n        return f.read()\n\ndef delete_local_file(type: str, path: str) -> bool:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    if os.path.isfile(file_path):\n        # This removes the file but the empty folders still remain.\n        os.remove(file_path)\n        return True\n    file_name = path.split(\"/\")[-1]\n    logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n    return False\n\ndef get_local_file_path(path_id: str) -> Optional[str]:\n    local_path = os.path.join(settings.LOCAL_UPLOADS_DIR, 'files', path_id)\n    if os.path.isfile(local_path):\n        return local_path\n    else:\n        return None\n\nclass LocalUploadBackend(ZulipUploadBackend):\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        # Split into 256 subdirectories to prevent directories from getting too big\n        path = \"/\".join([\n            str(user_profile.realm_id),\n            format(random.randint(0, 255), 'x'),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n\n        write_local_file('files', path, file_data)\n        create_attachment(uploaded_file_name, path, user_profile, uploaded_file_size)\n        return '/user_uploads/' + path\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return delete_local_file('files', path_id)\n\n    def write_avatar_images(self, file_path: str, image_data: bytes) -> None:\n        write_local_file('avatars', file_path + '.original', image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_data)\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(file_path, image_data)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        delete_local_file(\"avatars\", path_id + \".original\")\n        delete_local_file(\"avatars\", path_id + \".png\")\n        delete_local_file(\"avatars\", path_id + \"-medium.png\")\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        medium_suffix = \"-medium\" if medium else \"\"\n        return \"/user_avatars/%s%s.png?x=x\" % (hash_key, medium_suffix)\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        source_file_path = user_avatar_path(source_profile)\n        target_file_path = user_avatar_path(target_profile)\n\n        image_data = read_local_file('avatars', source_file_path + '.original')\n        self.write_avatar_images(target_file_path, image_data)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n\n        image_data = icon_file.read()\n        write_local_file(\n            upload_path,\n            'icon.original',\n            image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(upload_path, 'icon.png', resized_data)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        return \"/user_avatars/%s/realm/icon.png?version=%s\" % (realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n        if night:\n            original_file = 'night_logo.original'\n            resized_file = 'night_logo.png'\n        else:\n            original_file = 'logo.original'\n            resized_file = 'logo.png'\n        image_data = logo_file.read()\n        write_local_file(\n            upload_path,\n            original_file,\n            image_data)\n\n        resized_data = resize_logo(image_data)\n        write_local_file(upload_path, resized_file, resized_data)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        if night:\n            file_name = 'night_logo.png'\n        else:\n            file_name = 'logo.png'\n        return \"/user_avatars/%s/realm/%s?version=%s\" % (realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \"-medium.png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_avatar = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_avatar)\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id= user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        write_local_file(\n            'avatars',\n            \".\".join((emoji_path, \"original\")),\n            image_data)\n        write_local_file(\n            'avatars',\n            emoji_path,\n            resized_image_data)\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        return os.path.join(\n            \"/user_avatars\",\n            RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id, emoji_file_name=emoji_file_name))\n\n# Common and wrappers\nif settings.LOCAL_UPLOADS_DIR is not None:\n    upload_backend = LocalUploadBackend()  # type: ZulipUploadBackend\nelse:\n    upload_backend = S3UploadBackend()  # nocoverage\n\ndef delete_message_image(path_id: str) -> bool:\n    return upload_backend.delete_message_image(path_id)\n\ndef upload_avatar_image(user_file: File, acting_user_profile: UserProfile,\n                        target_user_profile: UserProfile) -> None:\n    upload_backend.upload_avatar_image(user_file, acting_user_profile, target_user_profile)\n\ndef delete_avatar_image(user_profile: UserProfile) -> None:\n    upload_backend.delete_avatar_image(user_profile)\n\ndef copy_avatar(source_profile: UserProfile, target_profile: UserProfile) -> None:\n    upload_backend.copy_avatar(source_profile, target_profile)\n\ndef upload_icon_image(user_file: File, user_profile: UserProfile) -> None:\n    upload_backend.upload_realm_icon_image(user_file, user_profile)\n\ndef upload_logo_image(user_file: File, user_profile: UserProfile, night: bool) -> None:\n    upload_backend.upload_realm_logo_image(user_file, user_profile, night)\n\ndef upload_emoji_image(emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n    upload_backend.upload_emoji_image(emoji_file, emoji_file_name, user_profile)\n\ndef upload_message_file(uploaded_file_name: str, uploaded_file_size: int,\n                        content_type: Optional[str], file_data: bytes,\n                        user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n    return upload_backend.upload_message_file(uploaded_file_name, uploaded_file_size,\n                                              content_type, file_data, user_profile,\n                                              target_realm=target_realm)\n\ndef claim_attachment(user_profile: UserProfile,\n                     path_id: str,\n                     message: Message,\n                     is_message_realm_public: bool) -> Attachment:\n    attachment = Attachment.objects.get(path_id=path_id)\n    attachment.messages.add(message)\n    attachment.is_realm_public = attachment.is_realm_public or is_message_realm_public\n    attachment.save()\n    return attachment\n\ndef create_attachment(file_name: str, path_id: str, user_profile: UserProfile,\n                      file_size: int) -> bool:\n    attachment = Attachment.objects.create(file_name=file_name, path_id=path_id, owner=user_profile,\n                                           realm=user_profile.realm, size=file_size)\n    from zerver.lib.actions import notify_attachment_update\n    notify_attachment_update(user_profile, 'add', attachment.to_dict())\n    return True\n\ndef upload_message_image_from_request(request: HttpRequest, user_file: File,\n                                      user_profile: UserProfile) -> str:\n    uploaded_file_name, uploaded_file_size, content_type = get_file_info(request, user_file)\n    return upload_message_file(uploaded_file_name, uploaded_file_size,\n                               content_type, user_file.read(), user_profile)\n", "code_before": "from typing import Dict, Optional, Tuple\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.core.files import File\nfrom django.http import HttpRequest\nfrom django.db.models import Sum\nfrom jinja2 import Markup as mark_safe\nimport unicodedata\n\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.exceptions import JsonableError, ErrorCode\n\nfrom boto.s3.bucket import Bucket\nfrom boto.s3.key import Key\nfrom boto.s3.connection import S3Connection\nfrom mimetypes import guess_type, guess_extension\n\nfrom zerver.models import get_user_profile_by_id\nfrom zerver.models import Attachment\nfrom zerver.models import Realm, RealmEmoji, UserProfile, Message\n\nimport urllib\nimport base64\nimport os\nimport re\nfrom PIL import Image, ImageOps, ExifTags\nfrom PIL.Image import DecompressionBombError\nfrom PIL.GifImagePlugin import GifImageFile\nimport io\nimport random\nimport logging\n\nDEFAULT_AVATAR_SIZE = 100\nMEDIUM_AVATAR_SIZE = 500\nDEFAULT_EMOJI_SIZE = 64\n\n# These sizes were selected based on looking at the maximum common\n# sizes in a library of animated custom emoji, balanced against the\n# network cost of very large emoji images.\nMAX_EMOJI_GIF_SIZE = 128\nMAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024 * 1024  # 128 kb\n\n# Performance Note:\n#\n# For writing files to S3, the file could either be stored in RAM\n# (if it is less than 2.5MiB or so) or an actual temporary file on disk.\n#\n# Because we set FILE_UPLOAD_MAX_MEMORY_SIZE to 0, only the latter case\n# should occur in practice.\n#\n# This is great, because passing the pseudofile object that Django gives\n# you to boto would be a pain.\n\n# To come up with a s3 key we randomly generate a \"directory\". The\n# \"file name\" is the original filename provided by the user run\n# through a sanitization function.\n\nclass RealmUploadQuotaError(JsonableError):\n    code = ErrorCode.REALM_UPLOAD_QUOTA\n\nattachment_url_re = re.compile(r'[/\\-]user[\\-_]uploads[/\\.-].*?(?=[ )]|\\Z)')\n\ndef attachment_url_to_path_id(attachment_url: str) -> str:\n    path_id_raw = re.sub(r'[/\\-]user[\\-_]uploads[/\\.-]', '', attachment_url)\n    # Remove any extra '.' after file extension. These are probably added by the user\n    return re.sub('[.]+$', '', path_id_raw, re.M)\n\ndef sanitize_name(value: str) -> str:\n    \"\"\"\n    Sanitizes a value to be safe to store in a Linux filesystem, in\n    S3, and in a URL.  So unicode is allowed, but not special\n    characters other than \".\", \"-\", and \"_\".\n\n    This implementation is based on django.utils.text.slugify; it is\n    modified by:\n    * adding '.' and '_' to the list of allowed characters.\n    * preserving the case of the value.\n    \"\"\"\n    value = unicodedata.normalize('NFKC', value)\n    value = re.sub(r'[^\\w\\s._-]', '', value, flags=re.U).strip()\n    return mark_safe(re.sub(r'[-\\s]+', '-', value, flags=re.U))\n\ndef random_name(bytes: int=60) -> str:\n    return base64.urlsafe_b64encode(os.urandom(bytes)).decode('utf-8')\n\nclass BadImageError(JsonableError):\n    code = ErrorCode.BAD_IMAGE\n\nname_to_tag_num = dict((name, num) for num, name in ExifTags.TAGS.items())\n\n# https://stackoverflow.com/a/6218425\ndef exif_rotate(image: Image) -> Image:\n    if not hasattr(image, '_getexif'):\n        return image\n    exif_data = image._getexif()\n    if exif_data is None:\n        return image\n\n    exif_dict = dict(exif_data.items())\n    orientation = exif_dict.get(name_to_tag_num['Orientation'])\n\n    if orientation == 3:\n        return image.rotate(180, expand=True)\n    elif orientation == 6:\n        return image.rotate(270, expand=True)\n    elif orientation == 8:\n        return image.rotate(90, expand=True)\n\n    return image\n\ndef resize_avatar(image_data: bytes, size: int=DEFAULT_AVATAR_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\ndef resize_logo(image_data: bytes) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = exif_rotate(im)\n        im.thumbnail((8*DEFAULT_AVATAR_SIZE, DEFAULT_AVATAR_SIZE), Image.ANTIALIAS)\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == 'CMYK':\n        im = im.convert('RGB')\n    im.save(out, format='png')\n    return out.getvalue()\n\n\ndef resize_gif(im: GifImageFile, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    frames = []\n    duration_info = []\n    # If 'loop' info is not set then loop for infinite number of times.\n    loop = im.info.get(\"loop\", 0)\n    for frame_num in range(0, im.n_frames):\n        im.seek(frame_num)\n        new_frame = Image.new(\"RGBA\", im.size)\n        new_frame.paste(im, (0, 0), im.convert(\"RGBA\"))\n        new_frame = ImageOps.fit(new_frame, (size, size), Image.ANTIALIAS)\n        frames.append(new_frame)\n        duration_info.append(im.info['duration'])\n    out = io.BytesIO()\n    frames[0].save(out, save_all=True, optimize=True,\n                   format=\"GIF\", append_images=frames[1:],\n                   duration=duration_info,\n                   loop=loop)\n    return out.getvalue()\n\n\ndef resize_emoji(image_data: bytes, size: int=DEFAULT_EMOJI_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        image_format = im.format\n        if image_format == \"GIF\":\n            # There are a number of bugs in Pillow.GifImagePlugin which cause\n            # results in resized gifs being broken. To work around this we\n            # only resize under certain conditions to minimize the chance of\n            # creating ugly gifs.\n            should_resize = any((\n                im.size[0] != im.size[1],                            # not square\n                im.size[0] > MAX_EMOJI_GIF_SIZE,                     # dimensions too large\n                len(image_data) > MAX_EMOJI_GIF_FILE_SIZE_BYTES,     # filesize too large\n            ))\n            return resize_gif(im, size) if should_resize else image_data\n        else:\n            im = exif_rotate(im)\n            im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            im.save(out, format=image_format)\n            return out.getvalue()\n    except IOError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n\n\n### Common\n\nclass ZulipUploadBackend:\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile,\n                            target_realm: Optional[Realm]=None) -> str:\n        raise NotImplementedError()\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_message_image(self, path_id: str) -> bool:\n        raise NotImplementedError()\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        raise NotImplementedError()\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        raise NotImplementedError()\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        raise NotImplementedError()\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        raise NotImplementedError()\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        raise NotImplementedError()\n\n\n### S3\n\ndef get_bucket(conn: S3Connection, bucket_name: str) -> Bucket:\n    # Calling get_bucket() with validate=True can apparently lead\n    # to expensive S3 bills:\n    #    http://www.appneta.com/blog/s3-list-get-bucket-default/\n    # The benefits of validation aren't completely clear to us, and\n    # we want to save on our bills, so we set the validate flag to False.\n    # (We think setting validate to True would cause us to fail faster\n    #  in situations where buckets don't exist, but that shouldn't be\n    #  an issue for us.)\n    bucket = conn.get_bucket(bucket_name, validate=False)\n    return bucket\n\ndef upload_image_to_s3(\n        bucket_name: str,\n        file_name: str,\n        content_type: Optional[str],\n        user_profile: UserProfile,\n        contents: bytes) -> None:\n\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    bucket = get_bucket(conn, bucket_name)\n    key = Key(bucket)\n    key.key = file_name\n    key.set_metadata(\"user_profile_id\", str(user_profile.id))\n    key.set_metadata(\"realm_id\", str(user_profile.realm_id))\n\n    if content_type is not None:\n        headers = {'Content-Type': content_type}  # type: Optional[Dict[str, str]]\n    else:\n        headers = None\n\n    key.set_contents_from_string(contents, headers=headers)  # type: ignore # https://github.com/python/typeshed/issues/1552\n\ndef currently_used_upload_space(realm: Realm) -> int:\n    used_space = Attachment.objects.filter(realm=realm).aggregate(Sum('size'))['size__sum']\n    if used_space is None:\n        return 0\n    return used_space\n\ndef check_upload_within_quota(realm: Realm, uploaded_file_size: int) -> None:\n    upload_quota = realm.upload_quota_bytes()\n    if upload_quota is None:\n        return\n    used_space = currently_used_upload_space(realm)\n    if (used_space + uploaded_file_size) > upload_quota:\n        raise RealmUploadQuotaError(_(\"Upload would exceed your organization's upload quota.\"))\n\ndef get_file_info(request: HttpRequest, user_file: File) -> Tuple[str, int, Optional[str]]:\n\n    uploaded_file_name = user_file.name\n    assert isinstance(uploaded_file_name, str)\n\n    content_type = request.GET.get('mimetype')\n    if content_type is None:\n        guessed_type = guess_type(uploaded_file_name)[0]\n        if guessed_type is not None:\n            content_type = guessed_type\n    else:\n        extension = guess_extension(content_type)\n        if extension is not None:\n            uploaded_file_name = uploaded_file_name + extension\n\n    uploaded_file_name = urllib.parse.unquote(uploaded_file_name)\n    uploaded_file_size = user_file.size\n\n    return uploaded_file_name, uploaded_file_size, content_type\n\n\ndef get_signed_upload_url(path: str) -> str:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    return conn.generate_url(15, 'GET', bucket=settings.S3_AUTH_UPLOADS_BUCKET, key=path)\n\ndef get_realm_for_filename(path: str) -> Optional[int]:\n    conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n    key = get_bucket(conn, settings.S3_AUTH_UPLOADS_BUCKET).get_key(path)\n    if key is None:\n        # This happens if the key does not exist.\n        return None\n    return get_user_profile_by_id(key.metadata[\"user_profile_id\"]).realm_id\n\nclass S3UploadBackend(ZulipUploadBackend):\n    def delete_file_from_s3(self, path_id: str, bucket_name: str) -> bool:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n\n        # check if file exists\n        key = bucket.get_key(path_id)\n        if key is not None:\n            bucket.delete_key(key)\n            return True\n\n        file_name = path_id.split(\"/\")[-1]\n        logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n        return False\n\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        bucket_name = settings.S3_AUTH_UPLOADS_BUCKET\n        if target_realm is None:\n            target_realm = user_profile.realm\n        s3_file_name = \"/\".join([\n            str(target_realm.id),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n        url = \"/user_uploads/%s\" % (s3_file_name,)\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            content_type,\n            user_profile,\n            file_data\n        )\n\n        create_attachment(uploaded_file_name, s3_file_name, user_profile, uploaded_file_size)\n        return url\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return self.delete_file_from_s3(path_id, settings.S3_AUTH_UPLOADS_BUCKET)\n\n    def write_avatar_images(self, s3_file_name: str, target_user_profile: UserProfile,\n                            image_data: bytes, content_type: Optional[str]) -> None:\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            target_user_profile,\n            image_data,\n        )\n\n        # custom 500px wide version\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            target_user_profile,\n            resized_medium\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            'image/png',\n            target_user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        content_type = guess_type(user_file.name)[0]\n        s3_file_name = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(s3_file_name, target_user_profile,\n                                 image_data, content_type)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n        bucket_name = settings.S3_AVATAR_BUCKET\n\n        self.delete_file_from_s3(path_id + \".original\", bucket_name)\n        self.delete_file_from_s3(path_id + \"-medium.png\", bucket_name)\n        self.delete_file_from_s3(path_id, bucket_name)\n\n    def get_avatar_key(self, file_name: str) -> Key:\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket_name = settings.S3_AVATAR_BUCKET\n        bucket = get_bucket(conn, bucket_name)\n\n        key = bucket.get_key(file_name)\n        return key\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        s3_source_file_name = user_avatar_path(source_profile)\n        s3_target_file_name = user_avatar_path(target_profile)\n\n        key = self.get_avatar_key(s3_source_file_name + \".original\")\n        image_data = key.get_contents_as_string()  # type: ignore # https://github.com/python/typeshed/issues/1552\n        content_type = key.content_type\n\n        self.write_avatar_images(s3_target_file_name, target_profile, image_data, content_type)  # type: ignore # image_data is `bytes`, boto subs are wrong\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        medium_suffix = \"-medium.png\" if medium else \"\"\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s%s?x=x\" % (bucket, hash_key, medium_suffix)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        content_type = guess_type(icon_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', 'icon')\n\n        image_data = icon_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        return \"https://%s.s3.amazonaws.com/%s/realm/icon.png?version=%s\" % (bucket, realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        content_type = guess_type(logo_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        if night:\n            basename = 'night_logo'\n        else:\n            basename = 'logo'\n        s3_file_name = os.path.join(str(user_profile.realm.id), 'realm', basename)\n\n        image_data = logo_file.read()\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_logo(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \".png\",\n            'image/png',\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        # ?x=x allows templates to append additional parameters with &s\n        if not night:\n            file_name = 'logo.png'\n        else:\n            file_name = 'night_logo.png'\n        return \"https://%s.s3.amazonaws.com/%s/realm/%s?version=%s\" % (bucket, realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            user_profile,\n            resized_medium\n        )\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n        # Also TODO: Migrate to user_avatar_path(user_profile) + \".png\".\n        s3_file_name = file_path\n\n        bucket_name = settings.S3_AVATAR_BUCKET\n        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)\n        bucket = get_bucket(conn, bucket_name)\n        key = bucket.get_key(file_path + \".original\")\n        image_data = key.get_contents_as_string()\n\n        resized_avatar = resize_avatar(image_data)  # type: ignore # image_data is `bytes`, boto subs are wrong\n        upload_image_to_s3(\n            bucket_name,\n            s3_file_name,\n            \"image/png\",\n            user_profile,\n            resized_avatar\n        )\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        content_type = guess_type(emoji_file.name)[0]\n        bucket_name = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        upload_image_to_s3(\n            bucket_name,\n            \".\".join((emoji_path, \"original\")),\n            content_type,\n            user_profile,\n            image_data,\n        )\n        upload_image_to_s3(\n            bucket_name,\n            emoji_path,\n            content_type,\n            user_profile,\n            resized_image_data,\n        )\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        bucket = settings.S3_AVATAR_BUCKET\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id,\n                                                        emoji_file_name=emoji_file_name)\n        return \"https://%s.s3.amazonaws.com/%s\" % (bucket, emoji_path)\n\n\n### Local\n\ndef write_local_file(type: str, path: str, file_data: bytes) -> None:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'wb') as f:\n        f.write(file_data)\n\ndef read_local_file(type: str, path: str) -> bytes:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    with open(file_path, 'rb') as f:\n        return f.read()\n\ndef delete_local_file(type: str, path: str) -> bool:\n    file_path = os.path.join(settings.LOCAL_UPLOADS_DIR, type, path)\n    if os.path.isfile(file_path):\n        # This removes the file but the empty folders still remain.\n        os.remove(file_path)\n        return True\n    file_name = path.split(\"/\")[-1]\n    logging.warning(\"%s does not exist. Its entry in the database will be removed.\" % (file_name,))\n    return False\n\ndef get_local_file_path(path_id: str) -> Optional[str]:\n    local_path = os.path.join(settings.LOCAL_UPLOADS_DIR, 'files', path_id)\n    if os.path.isfile(local_path):\n        return local_path\n    else:\n        return None\n\nclass LocalUploadBackend(ZulipUploadBackend):\n    def upload_message_file(self, uploaded_file_name: str, uploaded_file_size: int,\n                            content_type: Optional[str], file_data: bytes,\n                            user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n        # Split into 256 subdirectories to prevent directories from getting too big\n        path = \"/\".join([\n            str(user_profile.realm_id),\n            format(random.randint(0, 255), 'x'),\n            random_name(18),\n            sanitize_name(uploaded_file_name)\n        ])\n\n        write_local_file('files', path, file_data)\n        create_attachment(uploaded_file_name, path, user_profile, uploaded_file_size)\n        return '/user_uploads/' + path\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return delete_local_file('files', path_id)\n\n    def write_avatar_images(self, file_path: str, image_data: bytes) -> None:\n        write_local_file('avatars', file_path + '.original', image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_data)\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def upload_avatar_image(self, user_file: File,\n                            acting_user_profile: UserProfile,\n                            target_user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(file_path, image_data)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        delete_local_file(\"avatars\", path_id + \".original\")\n        delete_local_file(\"avatars\", path_id + \".png\")\n        delete_local_file(\"avatars\", path_id + \"-medium.png\")\n\n    def get_avatar_url(self, hash_key: str, medium: bool=False) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        medium_suffix = \"-medium\" if medium else \"\"\n        return \"/user_avatars/%s%s.png?x=x\" % (hash_key, medium_suffix)\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        source_file_path = user_avatar_path(source_profile)\n        target_file_path = user_avatar_path(target_profile)\n\n        image_data = read_local_file('avatars', source_file_path + '.original')\n        self.write_avatar_images(target_file_path, image_data)\n\n    def upload_realm_icon_image(self, icon_file: File, user_profile: UserProfile) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n\n        image_data = icon_file.read()\n        write_local_file(\n            upload_path,\n            'icon.original',\n            image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(upload_path, 'icon.png', resized_data)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        return \"/user_avatars/%s/realm/icon.png?version=%s\" % (realm_id, version)\n\n    def upload_realm_logo_image(self, logo_file: File, user_profile: UserProfile,\n                                night: bool) -> None:\n        upload_path = os.path.join('avatars', str(user_profile.realm.id), 'realm')\n        if night:\n            original_file = 'night_logo.original'\n            resized_file = 'night_logo.png'\n        else:\n            original_file = 'logo.original'\n            resized_file = 'logo.png'\n        image_data = logo_file.read()\n        write_local_file(\n            upload_path,\n            original_file,\n            image_data)\n\n        resized_data = resize_logo(image_data)\n        write_local_file(upload_path, resized_file, resized_data)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        # ?x=x allows templates to append additional parameters with &s\n        if night:\n            file_name = 'night_logo.png'\n        else:\n            file_name = 'logo.png'\n        return \"/user_avatars/%s/realm/%s?version=%s\" % (realm_id, file_name, version)\n\n    def ensure_medium_avatar_image(self, user_profile: UserProfile) -> None:\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \"-medium.png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file('avatars', file_path + '-medium.png', resized_medium)\n\n    def ensure_basic_avatar_image(self, user_profile: UserProfile) -> None:  # nocoverage\n        # TODO: Refactor this to share code with ensure_medium_avatar_image\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".png\")\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(settings.LOCAL_UPLOADS_DIR, \"avatars\", file_path + \".original\")\n        image_data = open(image_path, \"rb\").read()\n        resized_avatar = resize_avatar(image_data)\n        write_local_file('avatars', file_path + '.png', resized_avatar)\n\n    def upload_emoji_image(self, emoji_file: File, emoji_file_name: str,\n                           user_profile: UserProfile) -> None:\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id= user_profile.realm_id,\n            emoji_file_name=emoji_file_name\n        )\n\n        image_data = emoji_file.read()\n        resized_image_data = resize_emoji(image_data)\n        write_local_file(\n            'avatars',\n            \".\".join((emoji_path, \"original\")),\n            image_data)\n        write_local_file(\n            'avatars',\n            emoji_path,\n            resized_image_data)\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int) -> str:\n        return os.path.join(\n            \"/user_avatars\",\n            RealmEmoji.PATH_ID_TEMPLATE.format(realm_id=realm_id, emoji_file_name=emoji_file_name))\n\n# Common and wrappers\nif settings.LOCAL_UPLOADS_DIR is not None:\n    upload_backend = LocalUploadBackend()  # type: ZulipUploadBackend\nelse:\n    upload_backend = S3UploadBackend()  # nocoverage\n\ndef delete_message_image(path_id: str) -> bool:\n    return upload_backend.delete_message_image(path_id)\n\ndef upload_avatar_image(user_file: File, acting_user_profile: UserProfile,\n                        target_user_profile: UserProfile) -> None:\n    upload_backend.upload_avatar_image(user_file, acting_user_profile, target_user_profile)\n\ndef delete_avatar_image(user_profile: UserProfile) -> None:\n    upload_backend.delete_avatar_image(user_profile)\n\ndef copy_avatar(source_profile: UserProfile, target_profile: UserProfile) -> None:\n    upload_backend.copy_avatar(source_profile, target_profile)\n\ndef upload_icon_image(user_file: File, user_profile: UserProfile) -> None:\n    upload_backend.upload_realm_icon_image(user_file, user_profile)\n\ndef upload_logo_image(user_file: File, user_profile: UserProfile, night: bool) -> None:\n    upload_backend.upload_realm_logo_image(user_file, user_profile, night)\n\ndef upload_emoji_image(emoji_file: File, emoji_file_name: str, user_profile: UserProfile) -> None:\n    upload_backend.upload_emoji_image(emoji_file, emoji_file_name, user_profile)\n\ndef upload_message_file(uploaded_file_name: str, uploaded_file_size: int,\n                        content_type: Optional[str], file_data: bytes,\n                        user_profile: UserProfile, target_realm: Optional[Realm]=None) -> str:\n    return upload_backend.upload_message_file(uploaded_file_name, uploaded_file_size,\n                                              content_type, file_data, user_profile,\n                                              target_realm=target_realm)\n\ndef claim_attachment(user_profile: UserProfile,\n                     path_id: str,\n                     message: Message,\n                     is_message_realm_public: bool) -> Attachment:\n    attachment = Attachment.objects.get(path_id=path_id)\n    attachment.messages.add(message)\n    attachment.is_realm_public = attachment.is_realm_public or is_message_realm_public\n    attachment.save()\n    return attachment\n\ndef create_attachment(file_name: str, path_id: str, user_profile: UserProfile,\n                      file_size: int) -> bool:\n    attachment = Attachment.objects.create(file_name=file_name, path_id=path_id, owner=user_profile,\n                                           realm=user_profile.realm, size=file_size)\n    from zerver.lib.actions import notify_attachment_update\n    notify_attachment_update(user_profile, 'add', attachment.to_dict())\n    return True\n\ndef upload_message_image_from_request(request: HttpRequest, user_file: File,\n                                      user_profile: UserProfile) -> str:\n    uploaded_file_name, uploaded_file_size, content_type = get_file_info(request, user_file)\n    return upload_message_file(uploaded_file_name, uploaded_file_size,\n                               content_type, user_file.read(), user_profile)\n", "patch": "@@ -1,4 +1,4 @@\n-from typing import Dict, Optional, Tuple\n+from typing import Optional, Tuple\n \n from django.utils.translation import ugettext as _\n from django.conf import settings\n@@ -41,6 +41,17 @@\n MAX_EMOJI_GIF_SIZE = 128\n MAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024 * 1024  # 128 kb\n \n+INLINE_MIME_TYPES = [\n+    \"application/pdf\",\n+    \"image/gif\",\n+    \"image/jpeg\",\n+    \"image/png\",\n+    \"image/webp\",\n+    # To avoid cross-site scripting attacks, DO NOT add types such\n+    # as application/xhtml+xml, application/x-shockwave-flash,\n+    # image/svg+xml, text/html, or text/xml.\n+]\n+\n # Performance Note:\n #\n # For writing files to S3, the file could either be stored in RAM\n@@ -267,10 +278,11 @@ def upload_image_to_s3(\n     key.set_metadata(\"user_profile_id\", str(user_profile.id))\n     key.set_metadata(\"realm_id\", str(user_profile.realm_id))\n \n+    headers = {}\n     if content_type is not None:\n-        headers = {'Content-Type': content_type}  # type: Optional[Dict[str, str]]\n-    else:\n-        headers = None\n+        headers[\"Content-Type\"] = content_type\n+    if content_type not in INLINE_MIME_TYPES:\n+        headers[\"Content-Disposition\"] = \"attachment\"\n \n     key.set_contents_from_string(contents, headers=headers)  # type: ignore # https://github.com/python/typeshed/issues/1552\n ", "file_path": "files/2019_9\\229", "file_language": "py", "file_name": "zerver/lib/upload.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/zulip/zulip/raw/1195841dfb9aa26b3b0dabc6f05d72e4af25be3e/zerver%2Fviews%2Fupload.py", "code": "# -*- coding: utf-8 -*-\n\nfrom django.http import HttpRequest, HttpResponse, HttpResponseForbidden, \\\n    HttpResponseNotFound\nfrom django.shortcuts import redirect\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.upload import upload_message_image_from_request, get_local_file_path, \\\n    get_signed_upload_url, check_upload_within_quota, INLINE_MIME_TYPES\nfrom zerver.models import UserProfile, validate_attachment_request\nfrom django.conf import settings\nfrom sendfile import sendfile\nfrom mimetypes import guess_type\n\ndef serve_s3(request: HttpRequest, url_path: str) -> HttpResponse:\n    uri = get_signed_upload_url(url_path)\n    return redirect(uri)\n\ndef serve_local(request: HttpRequest, path_id: str) -> HttpResponse:\n    local_path = get_local_file_path(path_id)\n    if local_path is None:\n        return HttpResponseNotFound('<p>File not found</p>')\n\n    # Here we determine whether a browser should treat the file like\n    # an attachment (and thus clicking a link to it should download)\n    # or like a link (and thus clicking a link to it should display it\n    # in a browser tab).  This is controlled by the\n    # Content-Disposition header; `django-sendfile` sends the\n    # attachment-style version of that header if and only if the\n    # attachment argument is passed to it.  For attachments,\n    # django-sendfile sets the response['Content-disposition'] like\n    # this: `attachment; filename=\"b'zulip.txt'\"; filename*=UTF-8''zulip.txt`.\n    #\n    # The \"filename\" field (used to name the file when downloaded) is\n    # unreliable because it doesn't have a well-defined encoding; the\n    # newer filename* field takes precedence, since it uses a\n    # consistent format (urlquoted).  For more details on filename*\n    # and filename, see the below docs:\n    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n    mimetype, encoding = guess_type(local_path)\n    attachment = mimetype not in INLINE_MIME_TYPES\n\n    return sendfile(request, local_path, attachment=attachment,\n                    mimetype=mimetype, encoding=encoding)\n\ndef serve_file_backend(request: HttpRequest, user_profile: UserProfile,\n                       realm_id_str: str, filename: str) -> HttpResponse:\n    path_id = \"%s/%s\" % (realm_id_str, filename)\n    is_authorized = validate_attachment_request(user_profile, path_id)\n\n    if is_authorized is None:\n        return HttpResponseNotFound(_(\"<p>File not found.</p>\"))\n    if not is_authorized:\n        return HttpResponseForbidden(_(\"<p>You are not authorized to view this file.</p>\"))\n    if settings.LOCAL_UPLOADS_DIR is not None:\n        return serve_local(request, path_id)\n\n    return serve_s3(request, path_id)\n\ndef upload_file_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if len(request.FILES) == 0:\n        return json_error(_(\"You must specify a file to upload\"))\n    if len(request.FILES) != 1:\n        return json_error(_(\"You may only upload one file at a time\"))\n\n    user_file = list(request.FILES.values())[0]\n    file_size = user_file._get_size()\n    if settings.MAX_FILE_UPLOAD_SIZE * 1024 * 1024 < file_size:\n        return json_error(_(\"Uploaded file is larger than the allowed limit of %s MB\") % (\n            settings.MAX_FILE_UPLOAD_SIZE))\n    check_upload_within_quota(user_profile.realm, file_size)\n\n    if not isinstance(user_file.name, str):\n        # It seems that in Python 2 unicode strings containing bytes are\n        # rendered differently than ascii strings containing same bytes.\n        #\n        # Example:\n        # >>> print('\\xd3\\x92')\n        # \u04d2\n        # >>> print(u'\\xd3\\x92')\n        # \u00d3\n        #\n        # This is the cause of the problem as user_file.name variable\n        # is received as a unicode which is converted into unicode\n        # strings containing bytes and is rendered incorrectly.\n        #\n        # Example:\n        # >>> import urllib.parse\n        # >>> name = u'%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00b8\u00cc\u0086\u00d1\u0082\u00d0\u00b5  # This is wrong\n        #\n        # >>> name = '%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u0417\u0434\u0440\u0430\u0432\u0435\u0438\u0306\u0442\u0435.txt  # This is correct\n        user_file.name = user_file.name.encode('ascii')\n\n    uri = upload_message_image_from_request(request, user_file, user_profile)\n    return json_success({'uri': uri})\n", "code_before": "# -*- coding: utf-8 -*-\n\nfrom django.http import HttpRequest, HttpResponse, HttpResponseForbidden, \\\n    HttpResponseNotFound\nfrom django.shortcuts import redirect\nfrom django.utils.translation import ugettext as _\n\nfrom zerver.lib.response import json_success, json_error\nfrom zerver.lib.upload import upload_message_image_from_request, get_local_file_path, \\\n    get_signed_upload_url, check_upload_within_quota\nfrom zerver.models import UserProfile, validate_attachment_request\nfrom django.conf import settings\nfrom sendfile import sendfile\nfrom mimetypes import guess_type\n\ndef serve_s3(request: HttpRequest, url_path: str) -> HttpResponse:\n    uri = get_signed_upload_url(url_path)\n    return redirect(uri)\n\ndef serve_local(request: HttpRequest, path_id: str) -> HttpResponse:\n    local_path = get_local_file_path(path_id)\n    if local_path is None:\n        return HttpResponseNotFound('<p>File not found</p>')\n\n    # Here we determine whether a browser should treat the file like\n    # an attachment (and thus clicking a link to it should download)\n    # or like a link (and thus clicking a link to it should display it\n    # in a browser tab).  This is controlled by the\n    # Content-Disposition header; `django-sendfile` sends the\n    # attachment-style version of that header if and only if the\n    # attachment argument is passed to it.  For attachments,\n    # django-sendfile sets the response['Content-disposition'] like\n    # this: `attachment; filename=\"b'zulip.txt'\"; filename*=UTF-8''zulip.txt`.\n    #\n    # The \"filename\" field (used to name the file when downloaded) is\n    # unreliable because it doesn't have a well-defined encoding; the\n    # newer filename* field takes precedence, since it uses a\n    # consistent format (urlquoted).  For more details on filename*\n    # and filename, see the below docs:\n    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n    attachment = True\n    file_type = guess_type(local_path)[0]\n    if file_type is not None and (file_type.startswith(\"image/\") or\n                                  file_type == \"application/pdf\"):\n        attachment = False\n\n    return sendfile(request, local_path, attachment=attachment)\n\ndef serve_file_backend(request: HttpRequest, user_profile: UserProfile,\n                       realm_id_str: str, filename: str) -> HttpResponse:\n    path_id = \"%s/%s\" % (realm_id_str, filename)\n    is_authorized = validate_attachment_request(user_profile, path_id)\n\n    if is_authorized is None:\n        return HttpResponseNotFound(_(\"<p>File not found.</p>\"))\n    if not is_authorized:\n        return HttpResponseForbidden(_(\"<p>You are not authorized to view this file.</p>\"))\n    if settings.LOCAL_UPLOADS_DIR is not None:\n        return serve_local(request, path_id)\n\n    return serve_s3(request, path_id)\n\ndef upload_file_backend(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    if len(request.FILES) == 0:\n        return json_error(_(\"You must specify a file to upload\"))\n    if len(request.FILES) != 1:\n        return json_error(_(\"You may only upload one file at a time\"))\n\n    user_file = list(request.FILES.values())[0]\n    file_size = user_file._get_size()\n    if settings.MAX_FILE_UPLOAD_SIZE * 1024 * 1024 < file_size:\n        return json_error(_(\"Uploaded file is larger than the allowed limit of %s MB\") % (\n            settings.MAX_FILE_UPLOAD_SIZE))\n    check_upload_within_quota(user_profile.realm, file_size)\n\n    if not isinstance(user_file.name, str):\n        # It seems that in Python 2 unicode strings containing bytes are\n        # rendered differently than ascii strings containing same bytes.\n        #\n        # Example:\n        # >>> print('\\xd3\\x92')\n        # \u04d2\n        # >>> print(u'\\xd3\\x92')\n        # \u00d3\n        #\n        # This is the cause of the problem as user_file.name variable\n        # is received as a unicode which is converted into unicode\n        # strings containing bytes and is rendered incorrectly.\n        #\n        # Example:\n        # >>> import urllib.parse\n        # >>> name = u'%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u00d0\u0097\u00d0\u00b4\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00b8\u00cc\u0086\u00d1\u0082\u00d0\u00b5  # This is wrong\n        #\n        # >>> name = '%D0%97%D0%B4%D1%80%D0%B0%D0%B2%D0%B5%D0%B8%CC%86%D1%82%D0%B5.txt'\n        # >>> print(urllib.parse.unquote(name))\n        # \u0417\u0434\u0440\u0430\u0432\u0435\u0438\u0306\u0442\u0435.txt  # This is correct\n        user_file.name = user_file.name.encode('ascii')\n\n    uri = upload_message_image_from_request(request, user_file, user_profile)\n    return json_success({'uri': uri})\n", "patch": "@@ -7,7 +7,7 @@\n \n from zerver.lib.response import json_success, json_error\n from zerver.lib.upload import upload_message_image_from_request, get_local_file_path, \\\n-    get_signed_upload_url, check_upload_within_quota\n+    get_signed_upload_url, check_upload_within_quota, INLINE_MIME_TYPES\n from zerver.models import UserProfile, validate_attachment_request\n from django.conf import settings\n from sendfile import sendfile\n@@ -38,13 +38,11 @@ def serve_local(request: HttpRequest, path_id: str) -> HttpResponse:\n     # consistent format (urlquoted).  For more details on filename*\n     # and filename, see the below docs:\n     # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n-    attachment = True\n-    file_type = guess_type(local_path)[0]\n-    if file_type is not None and (file_type.startswith(\"image/\") or\n-                                  file_type == \"application/pdf\"):\n-        attachment = False\n+    mimetype, encoding = guess_type(local_path)\n+    attachment = mimetype not in INLINE_MIME_TYPES\n \n-    return sendfile(request, local_path, attachment=attachment)\n+    return sendfile(request, local_path, attachment=attachment,\n+                    mimetype=mimetype, encoding=encoding)\n \n def serve_file_backend(request: HttpRequest, user_profile: UserProfile,\n                        realm_id_str: str, filename: str) -> HttpResponse:", "file_path": "files/2019_9\\230", "file_language": "py", "file_name": "zerver/views/upload.py", "outdated_file_modify": 1, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 1, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
