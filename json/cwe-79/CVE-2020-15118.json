{"index": 4787, "cve_id": "CVE-2020-15118", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "In Wagtail before versions 2.7.4 and 2.9.3, when a form page type is made available to Wagtail editors through the `wagtail.contrib.forms` app, and the page template is built using Django's standard form rendering helpers such as form.as_p, any HTML tags used within a form field's help text will be rendered unescaped in the page. Allowing HTML within help text is an intentional design decision by Django; however, as a matter of policy Wagtail does not allow editors to insert arbitrary HTML by default, as this could potentially be used to carry out cross-site scripting attacks, including privilege escalation. This functionality should therefore not have been made available to editor-level users. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.4 (for the LTS 2.7 branch) and Wagtail 2.9.3 (for the current 2.9 branch). In these versions, help text will be escaped to prevent the inclusion of HTML tags. Site owners who wish to re-enable the use of HTML within help text (and are willing to accept the risk of this being exploited by editors) may set WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True in their configuration settings. Site owners who are unable to upgrade to the new versions can secure their form page templates by rendering forms field-by-field as per Django's documentation, but omitting the |safe filter when outputting the help text.", "cvss": "5.4", "publish_date": "July 28, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "d9a41e7f24d08c024acc9a3094940199df94db34", "commit_message": "Escape help text in form builder forms by default\n\nThis can be disabled with the setting WAGTAILFORMS_HELP_TEXT_ALLOW_HTML", "commit_date": "2020-07-20T09:36:28Z", "project": "wagtail/wagtail", "url": "https://api.github.com/repos/wagtail/wagtail/commits/d9a41e7f24d08c024acc9a3094940199df94db34", "html_url": "https://github.com/wagtail/wagtail/commit/d9a41e7f24d08c024acc9a3094940199df94db34", "windows_before": [{"commit_id": "b59a7379300fe74bbd5b536bdfeeb503d6857f8e", "commit_date": "Fri Jul 17 11:03:22 2020 +0900", "commit_message": "Update third_party_tutorials.rst", "files_name": ["docs/advanced_topics/third_party_tutorials.rst"]}, {"commit_id": "b21afba5dc9bdbf5a148cf34acf81d290a9b320a", "commit_date": "Thu Jul 16 10:46:01 2020 +0200", "commit_message": "Reverts wagtail.woff mode back to 755.", "files_name": ["wagtail/admin/static_src/wagtailadmin/fonts/wagtail.woff"]}, {"commit_id": "e097cfaab25bfd0b44a5133f4a43a330a0a16629", "commit_date": "Thu Jul 16 16:20:44 2020 +1000", "commit_message": "Changelog update for #6151 & #6189", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst"]}, {"commit_id": "6bfc3fedde27584e7e32c701a5d2e1785fa94d76", "commit_date": "Thu Jul 16 16:16:09 2020 +1000", "commit_message": "Remove white space at the end if the icon template", "files_name": ["wagtail/admin/templates/wagtailadmin/shared/icon.html"]}, {"commit_id": "42fb2084b72b0f865c11277b816b54a3154f1a1b", "commit_date": "Mon Jun 15 17:02:28 2020 +0100", "commit_message": "Fix icons list sizes in the styleguide", "files_name": ["wagtail/contrib/styleguide/static_src/wagtailstyleguide/scss/styleguide.scss"]}, {"commit_id": "07ad6f20b4c1400d81eaf31297eca9e0c2f8f9ef", "commit_date": "Tue Jun 9 11:28:18 2020 +0100", "commit_message": "Add utility classes for svg icons", "files_name": ["client/scss/components/_icons.scss"]}, {"commit_id": "eb6987beea65ca70ffdc717234497c73c8359499", "commit_date": "Mon Jun 15 13:03:33 2020 +0100", "commit_message": "Update inline dropdown components to use svg", "files_name": ["client/scss/components/_dropdown.scss", "wagtail/admin/static_src/wagtailadmin/js/core.js", "wagtail/admin/templates/wagtailadmin/pages/listing/_button_with_dropdown.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html"]}, {"commit_id": "06c2e74b5c757d5d984c2131281f8b50e6dd2524", "commit_date": "Mon Jun 15 12:31:05 2020 +0100", "commit_message": "Update longrunning buttons to use SVG", "files_name": ["client/scss/components/_button.scss", "client/scss/components/_icons.scss", "wagtail/admin/templates/wagtailadmin/login.html", "wagtail/admin/templates/wagtailadmin/pages/action_menu/publish.html", "wagtail/admin/templates/wagtailadmin/pages/action_menu/save_draft.html", "wagtail/admin/templates/wagtailadmin/reports/base_report.html", "wagtail/admin/tests/pages/test_edit_page.py", "wagtail/contrib/modeladmin/templates/modeladmin/create.html", "wagtail/contrib/modeladmin/templates/modeladmin/edit.html", "wagtail/contrib/settings/templates/wagtailsettings/edit.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html", "wagtail/documents/templates/wagtaildocs/chooser/chooser.html", "wagtail/documents/templates/wagtaildocs/documents/add.html", "wagtail/embeds/templates/wagtailembeds/chooser/chooser.html", "wagtail/images/templates/wagtailimages/chooser/chooser.html", "wagtail/snippets/templates/wagtailsnippets/snippets/create.html", "wagtail/snippets/templates/wagtailsnippets/snippets/edit.html"]}, {"commit_id": "fffb9bae922b9f5708bac87dc0dcc5813bbd3fa0", "commit_date": "Mon Jun 15 12:03:12 2020 +0100", "commit_message": "Update dropdown toggle to use SVG", "files_name": ["client/scss/components/_dropdown.legacy.scss", "wagtail/admin/templates/wagtailadmin/pages/action_menu/menu.html", "wagtail/admin/templates/wagtailadmin/pages/create.html", "wagtail/admin/templates/wagtailadmin/pages/edit.html", "wagtail/admin/templates/wagtailadmin/reports/base_report.html", "wagtail/contrib/forms/templates/wagtailforms/index_submissions.html", "wagtail/contrib/modeladmin/templates/modeladmin/edit.html", "wagtail/contrib/modeladmin/templates/modeladmin/index.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html", "wagtail/snippets/templates/wagtailsnippets/snippets/edit.html"]}, {"commit_id": "f9c11b3646cfd05b178be65126d7bbca35cfde0e", "commit_date": "Mon Jun 15 11:06:29 2020 +0100", "commit_message": "Update icon-only buttons to use SVG", "files_name": ["client/scss/components/_button.scss", "client/scss/components/_icons.scss", "wagtail/admin/static_src/wagtailadmin/js/modal-workflow.js", "wagtail/admin/templates/wagtailadmin/edit_handlers/inline_panel_child.html", "wagtail/contrib/search_promotions/templates/wagtailsearchpromotions/includes/searchpromotion_form.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html"]}, {"commit_id": "50bdd900687c39c4049db6c0046e5a291a124f1b", "commit_date": "Mon Jun 15 10:44:18 2020 +0100", "commit_message": "Update bicolor buttons to use SVGs", "files_name": ["client/scss/components/_button.scss", "wagtail/admin/templates/wagtailadmin/edit_handlers/inline_panel.html", "wagtail/admin/templates/wagtailadmin/edit_handlers/inline_panel_child.html", "wagtail/admin/templates/wagtailadmin/pages/_preview_button_on_edit.html", "wagtail/admin/templates/wagtailadmin/permissions/includes/collection_member_permissions_formset.html", "wagtail/admin/templates/wagtailadmin/reports/base_report.html", "wagtail/admin/templates/wagtailadmin/shared/header.html", "wagtail/admin/templates/wagtailadmin/shared/icon.html", "wagtail/admin/templatetags/wagtailadmin_tags.py", "wagtail/contrib/forms/templates/wagtailforms/index_submissions.html", "wagtail/contrib/modeladmin/templates/modeladmin/index.html", "wagtail/contrib/redirects/templates/wagtailredirects/index.html", "wagtail/contrib/search_promotions/templates/wagtailsearchpromotions/includes/searchpromotion_form.html", "wagtail/contrib/search_promotions/templates/wagtailsearchpromotions/includes/searchpromotions_formset.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html", "wagtail/documents/templates/wagtaildocs/multiple/add.html", "wagtail/images/templates/wagtailimages/images/edit.html", "wagtail/images/templates/wagtailimages/images/index.html", "wagtail/images/templates/wagtailimages/multiple/add.html", "wagtail/snippets/templates/wagtailsnippets/snippets/type_index.html", "wagtail/users/templates/wagtailusers/groups/edit.html", "wagtail/users/templates/wagtailusers/groups/includes/page_permissions_formset.html"]}, {"commit_id": "a24657014ebd48e4d09563446427999939c40e8d", "commit_date": "Wed Jul 15 23:51:08 2020 +0000", "commit_message": "Bump lodash from 4.17.15 to 4.17.19", "files_name": ["package-lock.json"]}, {"commit_id": "78c9ef31d701ad621f66bc6603cd1a5f15419df2", "commit_date": "Wed Jul 15 17:18:46 2020 +0100", "commit_message": "Typo fixes", "files_name": ["docs/reference/settings.rst"]}, {"commit_id": "c8f493c09598d1d93e30120e076d43f4a6cb1311", "commit_date": "Sun Jun 7 08:31:53 2020 +0200", "commit_message": "Add documentation for WAGTAIL_REDIRECTS_FILE_STORAGE setting (#6114)", "files_name": ["docs/reference/settings.rst"]}, {"commit_id": "1ed501e5af4bbda11842e27e6a02452e15bf5770", "commit_date": "Wed Jul 15 16:20:39 2020 +0100", "commit_message": "Sanitise window.location.hash when passing to jquery for tab handling (#6155)", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst", "wagtail/admin/static_src/wagtailadmin/js/core.js"]}, {"commit_id": "2b3f8fe4e1e199cdb7204aa1c25dcb69d545d9f7", "commit_date": "Wed Jul 15 16:01:41 2020 +0200", "commit_message": "Adds the duplicate icon from wagtail-react-streamfield. (#6227)", "files_name": ["client/scss/settings/_variables.icons.scss", "wagtail/admin/static_src/wagtailadmin/fonts/wagtail-icomoon.json", "wagtail/admin/static_src/wagtailadmin/fonts/wagtail.woff", "wagtail/admin/templates/wagtailadmin/icons/duplicate.svg", "wagtail/admin/wagtail_hooks.py", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html"]}, {"commit_id": "9917d7d2e99d0f0ec90fa0a7b04f149bab2d0792", "commit_date": "Tue Jul 14 13:31:07 2020 +0100", "commit_message": "Additional documentation for next_url", "files_name": ["CHANGELOG.txt", "docs/reference/contrib/modeladmin/tips_and_tricks/reversing_urls.rst", "docs/reference/hooks.rst", "docs/releases/2.10.rst"]}, {"commit_id": "e1a8dbf09e45e749d424cdc475711d63679f446a", "commit_date": "Tue Jul 14 12:21:02 2020 +0100", "commit_message": "Fix next_url handling to pass a URL rather than a dict of query parameters", "files_name": ["wagtail/admin/templatetags/wagtailadmin_tags.py", "wagtail/admin/wagtail_hooks.py"]}, {"commit_id": "31a9b285a0445c895aeff02b2abbeda12bf7f3d7", "commit_date": "Tue Jul 14 11:59:48 2020 +0100", "commit_message": "Add test for button URLs including a 'next' parameter", "files_name": ["wagtail/admin/tests/pages/test_content_type_use_view.py"]}, {"commit_id": "d75ab584c7b8d22c4a08f2eecbdf2f64a0ef6a09", "commit_date": "Tue Jul 14 10:53:23 2020 +0100", "commit_message": "Fixing typos", "files_name": ["docs/reference/contrib/modeladmin/inspectview.rst"]}, {"commit_id": "ee954b8fe69d95c68ebf80daffa34c64542f8c69", "commit_date": "Mon Jul 13 18:32:01 2020 +0100", "commit_message": "Release note for #5240", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst"]}, {"commit_id": "af7f446562aafa8c4b195dc3097379a2e813ff2d", "commit_date": "Tue Jul 7 16:31:04 2020 +0100", "commit_message": "Add / update tests", "files_name": ["wagtail/admin/tests/pages/test_edit_page.py", "wagtail/core/tests/test_page_model.py"]}, {"commit_id": "10312cb4da29b842ec04ed3c6f318664a5116749", "commit_date": "Tue Jul 7 16:30:53 2020 +0100", "commit_message": "Raise a custom exception when attempting to edit a page who's model class cannot be found in the codebase", "files_name": ["wagtail/admin/views/pages.py", "wagtail/core/exceptions.py"]}, {"commit_id": "dd680ae4d43a19920e76e77617eefd2758a92657", "commit_date": "Tue Jul 7 16:29:06 2020 +0100", "commit_message": "Factor out content type fetching into a separate Page method, simplify the specific specific_class methods, and improve docstrings", "files_name": ["docs/reference/pages/model_reference.rst", "wagtail/core/models.py"]}, {"commit_id": "5611f5ef6c7947ed1393c83730d1bcda08da39cb", "commit_date": "Sun Jul 12 23:09:00 2020 -0400", "commit_message": "Clarify origin of From address used in password reset emails (#6219)", "files_name": ["CONTRIBUTORS.rst", "docs/reference/settings.rst"]}, {"commit_id": "aacf8ba34aeadee437e32738130331cbd31878c4", "commit_date": "Mon Jul 13 17:20:05 2020 +0100", "commit_message": "isort fix", "files_name": ["wagtail/contrib/forms/models.py"]}, {"commit_id": "b8c36c0d7df23f19f3be61e28246f32484c26644", "commit_date": "Mon Jul 13 17:17:59 2020 +0100", "commit_message": "Move try/except in migrate_legacy_clean_name to cover where the query is executed", "files_name": ["wagtail/contrib/forms/models.py"]}, {"commit_id": "450f1bef3445f1cf1bb70532f52b79482d8ebcdc", "commit_date": "Sun Jul 12 20:30:20 2020 +1000", "commit_message": "add upgrade considerations for hooks function signature changes", "files_name": ["docs/releases/2.10.rst"]}, {"commit_id": "dca628b9882176f3fcef8f4b4786992a6f68a2e3", "commit_date": "Sun Jul 12 20:22:49 2020 +1000", "commit_message": "Add fallback for old signature page listing hooks", "files_name": ["wagtail/admin/templatetags/wagtailadmin_tags.py", "wagtail/admin/widgets.py"]}, {"commit_id": "0546237a1526cc2d17bb37f4503583ffd6b62715", "commit_date": "Mon Jul 13 14:03:18 2020 +0100", "commit_message": "Release note for #6093", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst"]}, {"commit_id": "d0bb803645bc60fd56584339f71a8ff8415f45ea", "commit_date": "Sun May 31 02:03:13 2020 +1000", "commit_message": "Forms - convert clean_name to a field on form field model", "files_name": ["wagtail/contrib/forms/forms.py", "wagtail/contrib/forms/models.py", "wagtail/contrib/forms/tests/test_forms.py", "wagtail/contrib/forms/tests/test_models.py", "wagtail/contrib/forms/tests/test_views.py", "wagtail/contrib/forms/utils.py", "wagtail/tests/testapp/fixtures/test.json", "wagtail/tests/testapp/migrations/0053_formfield_clean_name.py"]}, {"commit_id": "80375f1451d3efeb2c21393fcccda13d0536fc15", "commit_date": "Sun May 31 19:39:02 2020 +1000", "commit_message": "Replace unidecode usage with string_to_ascii from core utils", "files_name": ["wagtail/images/models.py", "wagtail/utils/sendfile.py"]}, {"commit_id": "6b1c356b20f95edab7cf753eddeeea0d989e6a71", "commit_date": "Sun May 31 02:02:46 2020 +1000", "commit_message": "Add core util - string_to_ascii", "files_name": ["wagtail/core/tests/test_utils.py", "wagtail/core/utils.py"]}, {"commit_id": "3d62f5e73230c67219666bbbd4ee29fa2f9dc129", "commit_date": "Sun May 31 02:02:58 2020 +1000", "commit_message": "Add core util tests - camelcase_to_underscore", "files_name": ["wagtail/core/tests/test_utils.py"]}, {"commit_id": "abedff12cd2d3817e442f3e74fbf42b30dd761ab", "commit_date": "Sat May 30 23:51:03 2020 +1000", "commit_message": "Add core util - safe_snake_case", "files_name": ["wagtail/core/tests/test_utils.py", "wagtail/core/utils.py"]}, {"commit_id": "8c306910dd86e09cea11196715da47c6a54c722b", "commit_date": "Fri Feb 21 13:35:53 2020 +0000", "commit_message": "Fix incorrect urls in the docs", "files_name": ["docs/advanced_topics/amp.rst", "docs/advanced_topics/images/image_serve_view.rst", "docs/reference/contrib/sitemaps.rst"]}, {"commit_id": "98c66359a812d466217980a0cf27e2a58f9f951d", "commit_date": "Thu Feb 20 16:39:03 2020 +0000", "commit_message": "Replace a few instances of re_path with path", "files_name": []}], "windows_after": [{"commit_id": "e8d02091eefd93e5ed3fccce3cbdfe2fc781dae0", "commit_date": "Fri Jul 10 15:49:38 2020 +0100", "commit_message": "Add warning about WAGTAILFORMS_HELP_TEXT_ALLOW_HTML", "files_name": ["docs/reference/settings.rst"]}, {"commit_id": "fc5c6bdff2eea9856b7826ea00c76f67af9fa93b", "commit_date": "Fri Jul 10 17:23:18 2020 +0100", "commit_message": "Add test to confirm that labels are escaped", "files_name": ["wagtail/contrib/forms/tests/test_models.py"]}, {"commit_id": "457643e686dc1996c536e6422a7a64f70856e54a", "commit_date": "Mon Jul 20 10:08:46 2020 +0100", "commit_message": "Release note for 2.7.4", "files_name": ["CHANGELOG.txt", "docs/releases/2.7.4.rst", "docs/releases/index.rst"]}, {"commit_id": "5714c2f71d4dcb423b26d41d16fa12ecea4f1855", "commit_date": "Mon Jul 20 10:24:55 2020 +0100", "commit_message": "Release note for 2.9.3", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.3.rst"]}, {"commit_id": "5bc57452753968d582a8c362eee0f2554fc0fd2d", "commit_date": "Mon Jul 20 10:27:35 2020 +0100", "commit_message": "clarify note about nightly build on init.py", "files_name": ["wagtail/__init__.py"]}, {"commit_id": "b98d724def7fc4d9310ecff2501f41b677d155bd", "commit_date": "Mon Jul 20 10:38:39 2020 +0100", "commit_message": "add link to 2.9.3 release notes", "files_name": ["docs/releases/index.rst"]}, {"commit_id": "7b5c064a195b3450ffb812b31f08de1b32046bb0", "commit_date": "Mon Jul 20 11:49:43 2020 +0100", "commit_message": "Fix label escaping test to account for #6093", "files_name": ["wagtail/contrib/forms/tests/test_models.py"]}, {"commit_id": "90c806110be2c6c12e38b0ca59629529ccd93ab9", "commit_date": "Mon Jul 20 17:01:41 2020 +0100", "commit_message": "Use icon tag instead of CSS for lock/unlock messages", "files_name": ["client/scss/components/_messages.scss", "wagtail/admin/templates/wagtailadmin/base.html"]}, {"commit_id": "6b338acdc67e4cd0a6c91191982348a918647476", "commit_date": "Tue Jul 21 13:35:41 2020 +0100", "commit_message": "\"View users of this group\" -> \"View users in this group\"", "files_name": ["wagtail/users/templates/wagtailusers/groups/edit.html"]}, {"commit_id": "9f0dcf0097e653996b25ec77f3d7fe210a447d34", "commit_date": "Tue Jul 21 18:16:36 2020 +0100", "commit_message": "Add skip link for keyboard users. Fix #5406 (#5780)", "files_name": ["CHANGELOG.txt", "client/scss/components/_skiplink.scss", "client/scss/settings/_variables.scss", "client/scss/styles.scss", "client/src/includes/initSkipLink.js", "client/src/index.js", "docs/releases/2.10.rst", "wagtail/admin/static_src/wagtailadmin/app/wagtailadmin.entry.js", "wagtail/admin/static_src/wagtailadmin/js/core.js", "wagtail/admin/templates/wagtailadmin/base.html", "wagtail/admin/templates/wagtailadmin/skeleton.html"]}, {"commit_id": "f9c5bab9cb7c193fb56d6be10a0bc21f24dc93ff", "commit_date": "Tue Jul 21 21:13:25 2020 +0200", "commit_message": "Add chevron to dropdowns that are missing them, and make \"Site\" label translateable (#6242)", "files_name": ["CHANGELOG.txt", "client/scss/components/_forms.scss", "docs/releases/2.10.rst", "wagtail/contrib/settings/templates/wagtailsettings/edit.html", "wagtail/documents/templates/wagtaildocs/multiple/add.html", "wagtail/images/templates/wagtailimages/multiple/add.html"]}, {"commit_id": "45ec139bc5edd3fc1b753b11f2890e7138f752cb", "commit_date": "Wed Jul 22 06:06:45 2020 +1000", "commit_message": "Hide snippets\u2019 bulk delete for screen reader users as well (#6116)", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst", "wagtail/snippets/static_src/wagtailsnippets/js/snippet-multiple-select.js", "wagtail/snippets/templates/wagtailsnippets/snippets/type_index.html"]}, {"commit_id": "1b3d190b3f3fda75314505fa1757811a81512a34", "commit_date": "Wed Jul 22 07:24:14 2020 +1000", "commit_message": "Fix group permission checkboxes not being clickable in IE11. Fix #5903 (#6115)", "files_name": ["CHANGELOG.txt", "client/scss/tools/_mixins.general.scss", "docs/releases/2.10.rst"]}, {"commit_id": "28b117a6bf0d0ba9d2cc34225b2a26285f8102be", "commit_date": "Wed Jul 22 13:52:28 2020 +0100", "commit_message": "Add separate \"accessibility and usability\" section to 2.10 release notes (#6252)", "files_name": ["docs/releases/2.10.rst"]}, {"commit_id": "d90f20a71feded54fb6339ecaa6341a78cd61f9a", "commit_date": "Tue Jul 21 17:42:01 2020 +0100", "commit_message": "Don't catch indexing errors for postgres search", "files_name": ["wagtail/search/backends/base.py", "wagtail/search/backends/elasticsearch2.py", "wagtail/search/index.py"]}, {"commit_id": "ac9dae7cff62caa191948181c4b60257ac0f051e", "commit_date": "Tue Jul 21 17:52:10 2020 +0100", "commit_message": "Don't rewrite the index entries table on every insert", "files_name": ["wagtail/contrib/postgres_search/backend.py"]}, {"commit_id": "b8848ae2f5b2594c2162cee2d76ef92fcc2ed670", "commit_date": "Wed Jul 22 17:44:52 2020 +0100", "commit_message": "Release note for #6250", "files_name": ["CHANGELOG.txt", "docs/releases/2.10.rst"]}, {"commit_id": "f9d20d1fa6cb7a413252e1e4ce8b75806b330866", "commit_date": "Wed Jul 22 10:42:12 2020 +0100", "commit_message": "Fix site delete URL", "files_name": ["wagtail/admin/viewsets/model.py"]}, {"commit_id": "93a8227a52a97086f87895edbf1a8177041e7b4c", "commit_date": "Thu Jul 23 07:55:38 2020 -0500", "commit_message": "Add edit button to draftail images and embeds blocks tooltip. Fix #2674 (#5885)", "files_name": ["client/src/components/Draftail/blocks/EmbedBlock.js", "client/src/components/Draftail/blocks/EmbedBlock.test.js", "client/src/components/Draftail/blocks/ImageBlock.js", "client/src/components/Draftail/blocks/ImageBlock.test.js", "client/src/components/Draftail/blocks/MediaBlock.js", "client/src/components/Draftail/blocks/MediaBlock.test.js", "client/src/components/Draftail/blocks/__snapshots__/EmbedBlock.test.js.snap", "client/src/components/Draftail/blocks/__snapshots__/ImageBlock.test.js.snap", "client/src/components/Draftail/blocks/__snapshots__/MediaBlock.test.js.snap", "client/src/components/Draftail/sources/ModalWorkflowSource.js", "client/src/components/Draftail/sources/ModalWorkflowSource.test.js", "client/tests/stubs.js", "wagtail/admin/localization.py"]}, {"commit_id": "d97f940e58d042ae160be463a14937c1b0ee7718", "commit_date": "Thu Jul 23 13:48:26 2020 +0100", "commit_message": "Release notes for #5885", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/releases/2.10.rst"]}, {"commit_id": "f5313044f927ac564def534cf837b569a8dc13cb", "commit_date": "Tue Nov 5 14:53:05 2019 +0000", "commit_message": "First attempt at Workflow and Task models, along with through class", "files_name": ["wagtail/core/models.py"]}, {"commit_id": "788dd8fb5c8a9422e879f04eb0178549ff5c52a3", "commit_date": "Tue Nov 5 15:16:39 2019 +0000", "commit_message": "Fixes to models so makemigrations succeeds", "files_name": ["wagtail/core/models.py"]}, {"commit_id": "b8cebad1ea13fcdbbaa6579b25521a2f9f59c825", "commit_date": "Tue Nov 5 16:29:35 2019 +0000", "commit_message": "Add tests for Workflow and Task creation and linking, and change related_names to be more usable", "files_name": ["wagtail/core/models.py", "wagtail/core/tests/test_workflow.py"]}, {"commit_id": "16ddbdc36eab259e5928e7bb054e86ca898aa2d5", "commit_date": "Tue Nov 5 17:07:11 2019 +0000", "commit_message": "Add get_workflow and corresponding tests", "files_name": ["wagtail/core/models.py", "wagtail/core/tests/test_workflow.py"]}, {"commit_id": "3db977926089ffca0f5f2d239b7d93b0f34d1be2", "commit_date": "Wed Nov 6 14:37:01 2019 +0000", "commit_message": "Change Workflow to inherit from ClusterableModel and be linked to by WorkflowTask via a ParentalKey, allowing for sensible submission of a Workflow and its Task orders. Change WorkflowTask to inherit from Orderable, allowing use of InlinePanels to set sort order.", "files_name": ["wagtail/core/models.py", "wagtail/core/tests/test_workflow.py"]}, {"commit_id": "00ba5810fcc0bda3bc207b721cae497d8ac44f80", "commit_date": "Fri Nov 8 16:33:36 2019 +0000", "commit_message": "Add unique together on WorkflowTask for 'workflow' and 'task' to avoid duplicates making TaskState queries difficult in future", "files_name": ["wagtail/core/models.py"]}, {"commit_id": "4326017a756dc56af0851b75db8e17cfd42de43d", "commit_date": "Fri Nov 8 17:14:21 2019 +0000", "commit_message": "Add 'active' fields to Task and Workflow, add managers to both, for now with just a .active() method", "files_name": ["wagtail/core/models.py"]}, {"commit_id": "05fbfabb83aba2451c4c71d65934131afa06ae3d", "commit_date": "Fri Nov 8 17:33:48 2019 +0000", "commit_message": "Limit task choices to active Tasks", "files_name": ["wagtail/core/models.py"]}, {"commit_id": "b6b22a7362e2a5591567cb6e006629791e5997c3", "commit_date": "Wed Nov 6 11:28:06 2019 +0000", "commit_message": "Add index for workflows", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/index.html", "wagtail/admin/urls/__init__.py", "wagtail/admin/urls/workflows.py", "wagtail/admin/views/workflows.py", "wagtail/admin/wagtail_hooks.py", "wagtail/core/permissions.py"]}, {"commit_id": "d389e469f2735ecd8f4de2b698bf63683166d03b", "commit_date": "Wed Nov 6 14:09:32 2019 +0000", "commit_message": "Start adding create view", "files_name": ["wagtail/admin/forms/workflows.py", "wagtail/admin/templates/wagtailadmin/workflows/index.html", "wagtail/admin/urls/workflows.py", "wagtail/admin/views/workflows.py"]}, {"commit_id": "2cea9bd44146a7f115ac936e0599ef13a664c66a", "commit_date": "Fri Nov 8 16:29:30 2019 +0000", "commit_message": "Fix index view and add edit, create views for Workflow", "files_name": ["wagtail/admin/forms/workflows.py", "wagtail/admin/templates/wagtailadmin/workflows/create.html", "wagtail/admin/templates/wagtailadmin/workflows/index.html", "wagtail/admin/urls/workflows.py", "wagtail/admin/views/workflows.py", "wagtail/core/models.py"]}, {"commit_id": "3c28ec0a9f2c39b1c084a2d14bbf2ca6b95600ca", "commit_date": "Fri Nov 8 16:54:48 2019 +0000", "commit_message": "Add link to edit page from index and nicer task display. Add button which will eventually disable workflow", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/create.html", "wagtail/admin/templates/wagtailadmin/workflows/edit.html", "wagtail/admin/templates/wagtailadmin/workflows/index.html", "wagtail/admin/views/workflows.py"]}, {"commit_id": "7fceab23062f96f7ceafc7e14a362677c1185812", "commit_date": "Fri Nov 8 17:23:44 2019 +0000", "commit_message": "Add status tag to disabled workflows", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/index.html"]}, {"commit_id": "c38e9cfcd4e826aa337634d8e28f41c07559e5ae", "commit_date": "Tue Nov 12 11:33:57 2019 +0000", "commit_message": "Add remove workflow action to page list. Move save button out of footer to emphasize that removing a page is not an unsaved action", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/edit.html", "wagtail/admin/templates/wagtailadmin/workflows/listing/_list_workflow_pages.html", "wagtail/admin/urls/workflows.py", "wagtail/admin/views/workflows.py"]}, {"commit_id": "a9360b8944e4e387820934f2af43ad9f3575247c", "commit_date": "Wed Nov 13 15:19:46 2019 +0000", "commit_message": "First draft of add to page form with confirmation message", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/add_to_page.html", "wagtail/admin/templates/wagtailadmin/workflows/edit.html", "wagtail/admin/urls/workflows.py", "wagtail/admin/views/workflows.py"]}, {"commit_id": "ef8447a9a360eb1f136b3816800fc26a022ddf0a", "commit_date": "Wed Nov 13 16:11:11 2019 +0000", "commit_message": "Restyle and tidy html for add_to_page", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/add_to_page.html", "wagtail/admin/views/workflows.py"]}, {"commit_id": "4bb2e14339632a1a81ba01557cf130508e9fe45e", "commit_date": "Wed Nov 13 16:28:53 2019 +0000", "commit_message": "Get rid of page chooser when confirmation dialogue visible", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/add_to_page.html", "wagtail/admin/views/workflows.py"]}, {"commit_id": "ecf6bf0f95850784d9e098f4348ce971b66ac9a2", "commit_date": "Wed Nov 13 16:31:46 2019 +0000", "commit_message": "Hide, don't get rid of page field when confirming", "files_name": ["wagtail/admin/templates/wagtailadmin/workflows/add_to_page.html"]}, {"commit_id": "caa2490afd4fd36b8705b022473db3b543ee5751", "commit_date": "Thu Nov 14 11:55:57 2019 +0000", "commit_message": "Begin refactoring: moving edit handlers for Workflow into edit_handlers", "files_name": ["wagtail/admin/edit_handlers.py", "wagtail/admin/templates/wagtailadmin/workflows/add_to_page.html", "wagtail/admin/templates/wagtailadmin/workflows/create.html", "wagtail/admin/templates/wagtailadmin/workflows/edit.html", "wagtail/admin/views/workflows.py"]}, {"commit_id": "8ced475de4c036a35ffb943dac6963952703fa10", "commit_date": "Thu Nov 14 15:23:56 2019 +0000", "commit_message": "Update Workflow link to Page to use OneToOneField through WorkflowPage, rather than ForeignKey. Update get_workflow and tests to match new relation.", "files_name": ["wagtail/core/models.py", "wagtail/core/tests/test_workflow.py"]}, {"commit_id": "968704faf5b953ab4ca26e6a36b8018f7c8243f9", "commit_date": "Thu Nov 14 15:46:08 2019 +0000", "commit_message": "Update queries and AddWorkflowToPageForm to account for change in Workflow-Page linking relation (FK to OneToOneField + linking class)", "files_name": []}], "parents": [{"commit_id_before": "b59a7379300fe74bbd5b536bdfeeb503d6857f8e", "url_before": "https://api.github.com/repos/wagtail/wagtail/commits/b59a7379300fe74bbd5b536bdfeeb503d6857f8e", "html_url_before": "https://github.com/wagtail/wagtail/commit/b59a7379300fe74bbd5b536bdfeeb503d6857f8e"}], "details": [{"raw_url": "https://github.com/wagtail/wagtail/raw/d9a41e7f24d08c024acc9a3094940199df94db34/docs%2Freference%2Fsettings.rst", "code": "========\nSettings\n========\n\nWagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:\n\nSite Name\n=========\n\n.. code-block:: python\n\n  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'\n\nThis is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.\n\n.. _append_slash:\n\nAppend Slash\n============\n\n.. code-block:: python\n\n  # Don't add a trailing slash to Wagtail-served URLs\n  WAGTAIL_APPEND_SLASH = False\n\nSimilar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.\n\n.. note::\n\n  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.\n\n.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html\n\nSearch\n======\n\n.. code-block:: python\n\n  WAGTAILSEARCH_BACKENDS = {\n      'default': {\n          'BACKEND': 'wagtail.search.backends.elasticsearch2',\n          'INDEX': 'myapp'\n      }\n  }\n\nDefine a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.\n\n.. code-block:: python\n\n  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'\n  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'\n\nOverride the templates used by the search front-end views.\n\n.. _wagtailsearch_hits_max_age:\n\n.. code-block:: python\n\n  WAGTAILSEARCH_HITS_MAX_AGE = 14\n\nSet the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.\n\nEmbeds\n======\n\nWagtail supports generating embed code from URLs to content on an external\nproviders such as Youtube or Twitter. By default, Wagtail will fetch the embed\ncode directly from the relevant provider's site using the oEmbed protocol.\nWagtail has a builtin list of the most common providers.\n\nThe embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``\nsetting. This is fully documented in :ref:`configuring_embed_finders`.\n\n.. code-block:: python\n\n    WAGTAILEMBEDS_RESPONSIVE_HTML = True\n\nAdds ``class=\"responsive-object\"`` and an inline ``padding-bottom`` style to embeds,\nto assist in making them responsive. See :ref:`responsive-embeds` for details.\n\nDashboard\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5\n\nThis setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.\n\n\n.. code-block:: python\n\n  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'\n\nAllows the default ``LoginForm`` to be extended with extra fields.\n\n\n.. _wagtail_gravatar_provider_url:\n\n.. code-block:: python\n\n  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'\n\nIf a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.\n\n.. _wagtail_moderation_enabled:\n\n.. code-block:: python\n\n  WAGTAIL_MODERATION_ENABLED = True\n\nChanges whether the Submit for Moderation button is displayed in the action menu.\n\nImages\n======\n\n.. code-block:: python\n\n  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'\n\nThis setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.\n\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB\n\nThis setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels\n\nThis setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True\n\nThis setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20\n\nSpecifies the number of images per page shown on the main Images listing in the Wagtail admin.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20\n\nSpecifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).\n\n.. code-block:: python\n\n    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12\n\nSpecifies the number of images shown per page in the image chooser modal.\n\nDocuments\n=========\n\n.. _wagtaildocs_serve_method:\n\n.. code-block:: python\n\n  WAGTAILDOCS_SERVE_METHOD = 'redirect'\n\nDetermines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.\n\nFor this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:\n\n * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).\n * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.\n * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.\n\nIf ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.\n\nPassword Management\n===================\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their passwords (enabled by default).\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_RESET_ENABLED = True\n\nThis specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_ENABLED = True\n\nThis specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_REQUIRED = True\n\nThis specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).\n\n.. code-block:: python\n\n  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their email (enabled by default).\n\n.. _email_notifications:\n\nEmail Notifications\n===================\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'\n\nWagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_USE_HTML = True\n\nNotification emails are sent in `text/plain` by default, change this to use HTML formatting.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False\n\nNotification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.\n\n.. _update_notifications:\n\nWagtail update notifications\n============================\n\n.. code-block:: python\n\n  WAGTAIL_ENABLE_UPDATE_CHECK = True\n\nFor admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.\n\n\nPrivate pages / documents\n=========================\n\n.. code-block:: python\n\n  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'\n\nThis is the path to the Django template which will be used to display the \"password required\" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.\n\n.. code-block:: python\n\n  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'\n\nAs above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.\n\nLogin page\n==========\n\nThe basic login page can be customised with a custom template.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'\n\nOr the login page can be a redirect to an external or internal URL.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'\n\nFor more details, see the :ref:`login_page` documentation.\n\nCase-Insensitive Tags\n=====================\n\n.. code-block:: python\n\n  TAGGIT_CASE_INSENSITIVE = True\n\nTags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.\n\nMulti-word tags\n===============\n\n.. code-block:: python\n\n  TAG_SPACES_ALLOWED = False\n\nTags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).\n\nTag limit\n=========\n\n.. code-block:: python\n\n  TAG_LIMIT = 5\n\nLimit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.\n\nUnicode Page Slugs\n==================\n\n.. code-block:: python\n\n  WAGTAIL_ALLOW_UNICODE_SLUGS = True\n\nBy default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.\n\n.. _WAGTAIL_AUTO_UPDATE_PREVIEW:\n\nAuto update preview\n===================\n\n.. code-block:: python\n\n  WAGTAIL_AUTO_UPDATE_PREVIEW = False\n\nWhen enabled, data from an edited page is automatically sent to the server\non each change, even without saving. That way, users don\u2019t have to click on\n\u201cPreview\u201d to update the content of the preview page. However, the preview page\ntab is not refreshed automatically, users have to do it manually.\nThis behaviour is disabled by default.\n\nCustom User Edit Forms\n======================\n\nSee :doc:`/advanced_topics/customisation/custom_user_models`.\n\n.. code-block:: python\n\n  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'\n\nAllows the default ``UserEditForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user edit form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'\n\nAllows the default ``UserCreationForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user creation form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CUSTOM_FIELDS = ['country']\n\nA list of the extra custom fields to be appended to the default list.\n\n.. _WAGTAIL_USAGE_COUNT_ENABLED:\n\nUsage for images, documents and snippets\n========================================\n\n.. code-block:: python\n\n    WAGTAIL_USAGE_COUNT_ENABLED = True\n\nWhen enabled Wagtail shows where a particular image, document or snippet is being used on your site.\nThis is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.\n\nA link will appear on the edit page (in the rightmost column) showing you how many times the item is used.\nClicking this link takes you to the \"Usage\" page, which shows you where the snippet, document or image is used.\n\nThe link is also shown on the delete page, above the \"Delete\" button.\n\n.. note::\n\n    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.\n\nDate and DateTime inputs\n========================\n\n.. code-block:: python\n\n    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'\n    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'\n    WAGTAIL_TIME_FORMAT = '%H:%M'\n\n\nSpecifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).\n\n.. _WAGTAIL_USER_TIME_ZONES:\n\nTime zones\n==========\n\nLogged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.\n(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)\n\nThe list of time zones is by default the common_timezones list from pytz.\nIt is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.\nIf there is zero or one time zone permitted, the account settings form will be hidden.\n\n.. code-block:: python\n\n    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']\n\n.. _WAGTAILADMIN_PERMITTED_LANGUAGES:\n\nAdmin languages\n===============\n\nUsers can choose between several languages for the admin interface\nin the account settings. The list of languages is by default all the available\nlanguages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:\n\n.. code-block:: python\n\n    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                        ('pt', 'Portuguese')]\n\nSince the syntax is the same as Django ``LANGUAGES``, you can do this so users\ncan only choose between front office languages:\n\n.. code-block:: python\n\n    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                                    ('pt', 'Portuguese')]\n\nStatic files\n============\n\n.. code-block:: python\n\n    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False\n\nStatic file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.\n\nAPI Settings\n============\n\nFor full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.\n\n.. code-block:: python\n\n    WAGTAILAPI_BASE_URL = 'http://api.example.com/'\n\nRequired when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_LIMIT_MAX = 500\n\nDefault is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_SEARCH_ENABLED = False\n\nDefault is true, setting this to false will disable full text search on all endpoints.\n\n.. code-block:: python\n\n    WAGTAILAPI_USE_FRONTENDCACHE = True\n\nRequires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.\n\nFrontend cache\n==============\n\nFor full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE = {\n        'varnish': {\n            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',\n            'LOCATION': 'http://localhost:8000',\n        },\n    }\n\nSee documentation linked above for full options available.\n\n.. note::\n\n    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]\n\nDefault is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.\n\n.. _WAGTAILADMIN_RICH_TEXT_EDITORS:\n\nRich text\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RICH_TEXT_EDITORS = {\n        'default': {\n            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',\n            'OPTIONS': {\n                'features': ['h2', 'bold', 'italic', 'link', 'document-link']\n            }\n        },\n        'legacy': {\n            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',\n        }\n    }\n\nCustomise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:\n\n * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.\n\n * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).\n\nIf a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.\n\n.. versionchanged:: 2.10\n\n    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.\n\n\n.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:\n\nPage locking\n============\n\n``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users\nfrom editing pages that they have locked.\n\nRedirects\n=========\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'\n\nBy default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'\n\nForm builder\n============\n\n.. versionadded:: 2.7.4/2.9.3\n\n    The ``WAGTAILFORMS_HELP_TEXT_ALLOW_HTML`` option was added.\n\n.. code-block:: python\n\n    WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True\n\nWhen true, HTML tags in form field help text will be rendered unescaped (default: False).\n", "code_before": "========\nSettings\n========\n\nWagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:\n\nSite Name\n=========\n\n.. code-block:: python\n\n  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'\n\nThis is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.\n\n.. _append_slash:\n\nAppend Slash\n============\n\n.. code-block:: python\n\n  # Don't add a trailing slash to Wagtail-served URLs\n  WAGTAIL_APPEND_SLASH = False\n\nSimilar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.\n\n.. note::\n\n  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.\n\n.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html\n\nSearch\n======\n\n.. code-block:: python\n\n  WAGTAILSEARCH_BACKENDS = {\n      'default': {\n          'BACKEND': 'wagtail.search.backends.elasticsearch2',\n          'INDEX': 'myapp'\n      }\n  }\n\nDefine a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.\n\n.. code-block:: python\n\n  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'\n  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'\n\nOverride the templates used by the search front-end views.\n\n.. _wagtailsearch_hits_max_age:\n\n.. code-block:: python\n\n  WAGTAILSEARCH_HITS_MAX_AGE = 14\n\nSet the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.\n\nEmbeds\n======\n\nWagtail supports generating embed code from URLs to content on an external\nproviders such as Youtube or Twitter. By default, Wagtail will fetch the embed\ncode directly from the relevant provider's site using the oEmbed protocol.\nWagtail has a builtin list of the most common providers.\n\nThe embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``\nsetting. This is fully documented in :ref:`configuring_embed_finders`.\n\n.. code-block:: python\n\n    WAGTAILEMBEDS_RESPONSIVE_HTML = True\n\nAdds ``class=\"responsive-object\"`` and an inline ``padding-bottom`` style to embeds,\nto assist in making them responsive. See :ref:`responsive-embeds` for details.\n\nDashboard\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5\n\nThis setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.\n\n\n.. code-block:: python\n\n  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'\n\nAllows the default ``LoginForm`` to be extended with extra fields.\n\n\n.. _wagtail_gravatar_provider_url:\n\n.. code-block:: python\n\n  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'\n\nIf a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.\n\n.. _wagtail_moderation_enabled:\n\n.. code-block:: python\n\n  WAGTAIL_MODERATION_ENABLED = True\n\nChanges whether the Submit for Moderation button is displayed in the action menu.\n\nImages\n======\n\n.. code-block:: python\n\n  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'\n\nThis setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.\n\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB\n\nThis setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels\n\nThis setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True\n\nThis setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20\n\nSpecifies the number of images per page shown on the main Images listing in the Wagtail admin.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20\n\nSpecifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).\n\n.. code-block:: python\n\n    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12\n\nSpecifies the number of images shown per page in the image chooser modal.\n\nDocuments\n=========\n\n.. _wagtaildocs_serve_method:\n\n.. code-block:: python\n\n  WAGTAILDOCS_SERVE_METHOD = 'redirect'\n\nDetermines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.\n\nFor this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:\n\n * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).\n * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.\n * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.\n\nIf ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.\n\nPassword Management\n===================\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their passwords (enabled by default).\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_RESET_ENABLED = True\n\nThis specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_ENABLED = True\n\nThis specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_REQUIRED = True\n\nThis specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).\n\n.. code-block:: python\n\n  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their email (enabled by default).\n\n.. _email_notifications:\n\nEmail Notifications\n===================\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'\n\nWagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_USE_HTML = True\n\nNotification emails are sent in `text/plain` by default, change this to use HTML formatting.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False\n\nNotification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.\n\n.. _update_notifications:\n\nWagtail update notifications\n============================\n\n.. code-block:: python\n\n  WAGTAIL_ENABLE_UPDATE_CHECK = True\n\nFor admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.\n\n\nPrivate pages / documents\n=========================\n\n.. code-block:: python\n\n  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'\n\nThis is the path to the Django template which will be used to display the \"password required\" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.\n\n.. code-block:: python\n\n  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'\n\nAs above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.\n\nLogin page\n==========\n\nThe basic login page can be customised with a custom template.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'\n\nOr the login page can be a redirect to an external or internal URL.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'\n\nFor more details, see the :ref:`login_page` documentation.\n\nCase-Insensitive Tags\n=====================\n\n.. code-block:: python\n\n  TAGGIT_CASE_INSENSITIVE = True\n\nTags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.\n\nMulti-word tags\n===============\n\n.. code-block:: python\n\n  TAG_SPACES_ALLOWED = False\n\nTags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).\n\nTag limit\n=========\n\n.. code-block:: python\n\n  TAG_LIMIT = 5\n\nLimit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.\n\nUnicode Page Slugs\n==================\n\n.. code-block:: python\n\n  WAGTAIL_ALLOW_UNICODE_SLUGS = True\n\nBy default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.\n\n.. _WAGTAIL_AUTO_UPDATE_PREVIEW:\n\nAuto update preview\n===================\n\n.. code-block:: python\n\n  WAGTAIL_AUTO_UPDATE_PREVIEW = False\n\nWhen enabled, data from an edited page is automatically sent to the server\non each change, even without saving. That way, users don\u2019t have to click on\n\u201cPreview\u201d to update the content of the preview page. However, the preview page\ntab is not refreshed automatically, users have to do it manually.\nThis behaviour is disabled by default.\n\nCustom User Edit Forms\n======================\n\nSee :doc:`/advanced_topics/customisation/custom_user_models`.\n\n.. code-block:: python\n\n  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'\n\nAllows the default ``UserEditForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user edit form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'\n\nAllows the default ``UserCreationForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user creation form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CUSTOM_FIELDS = ['country']\n\nA list of the extra custom fields to be appended to the default list.\n\n.. _WAGTAIL_USAGE_COUNT_ENABLED:\n\nUsage for images, documents and snippets\n========================================\n\n.. code-block:: python\n\n    WAGTAIL_USAGE_COUNT_ENABLED = True\n\nWhen enabled Wagtail shows where a particular image, document or snippet is being used on your site.\nThis is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.\n\nA link will appear on the edit page (in the rightmost column) showing you how many times the item is used.\nClicking this link takes you to the \"Usage\" page, which shows you where the snippet, document or image is used.\n\nThe link is also shown on the delete page, above the \"Delete\" button.\n\n.. note::\n\n    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.\n\nDate and DateTime inputs\n========================\n\n.. code-block:: python\n\n    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'\n    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'\n    WAGTAIL_TIME_FORMAT = '%H:%M'\n\n\nSpecifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).\n\n.. _WAGTAIL_USER_TIME_ZONES:\n\nTime zones\n==========\n\nLogged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.\n(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)\n\nThe list of time zones is by default the common_timezones list from pytz.\nIt is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.\nIf there is zero or one time zone permitted, the account settings form will be hidden.\n\n.. code-block:: python\n\n    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']\n\n.. _WAGTAILADMIN_PERMITTED_LANGUAGES:\n\nAdmin languages\n===============\n\nUsers can choose between several languages for the admin interface\nin the account settings. The list of languages is by default all the available\nlanguages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:\n\n.. code-block:: python\n\n    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                        ('pt', 'Portuguese')]\n\nSince the syntax is the same as Django ``LANGUAGES``, you can do this so users\ncan only choose between front office languages:\n\n.. code-block:: python\n\n    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                                    ('pt', 'Portuguese')]\n\nStatic files\n============\n\n.. code-block:: python\n\n    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False\n\nStatic file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.\n\nAPI Settings\n============\n\nFor full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.\n\n.. code-block:: python\n\n    WAGTAILAPI_BASE_URL = 'http://api.example.com/'\n\nRequired when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_LIMIT_MAX = 500\n\nDefault is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_SEARCH_ENABLED = False\n\nDefault is true, setting this to false will disable full text search on all endpoints.\n\n.. code-block:: python\n\n    WAGTAILAPI_USE_FRONTENDCACHE = True\n\nRequires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.\n\nFrontend cache\n==============\n\nFor full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE = {\n        'varnish': {\n            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',\n            'LOCATION': 'http://localhost:8000',\n        },\n    }\n\nSee documentation linked above for full options available.\n\n.. note::\n\n    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]\n\nDefault is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.\n\n.. _WAGTAILADMIN_RICH_TEXT_EDITORS:\n\nRich text\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RICH_TEXT_EDITORS = {\n        'default': {\n            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',\n            'OPTIONS': {\n                'features': ['h2', 'bold', 'italic', 'link', 'document-link']\n            }\n        },\n        'legacy': {\n            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',\n        }\n    }\n\nCustomise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:\n\n * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.\n\n * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).\n\nIf a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.\n\n.. versionchanged:: 2.10\n\n    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.\n\n\n.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:\n\nPage locking\n============\n\n``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users\nfrom editing pages that they have locked.\n\nRedirects\n=========\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'\n\nBy default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'\n", "patch": "@@ -547,3 +547,16 @@ By default the redirect importer keeps track of the uploaded file as a temp file\n .. code-block:: python\n \n    WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'\n+\n+Form builder\n+============\n+\n+.. versionadded:: 2.7.4/2.9.3\n+\n+    The ``WAGTAILFORMS_HELP_TEXT_ALLOW_HTML`` option was added.\n+\n+.. code-block:: python\n+\n+    WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True\n+\n+When true, HTML tags in form field help text will be rendered unescaped (default: False).", "file_path": "files/2020_7/17", "file_language": "rst", "file_name": "docs/reference/settings.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1}, {"raw_url": "https://github.com/wagtail/wagtail/raw/d9a41e7f24d08c024acc9a3094940199df94db34/wagtail%2Fcontrib%2Fforms%2Fforms.py", "code": "from collections import OrderedDict\n\nimport django.forms\nfrom django.conf import settings\nfrom django.utils.html import conditional_escape\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.contrib.forms.utils import get_field_clean_name\n\n\nclass BaseForm(django.forms.Form):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('label_suffix', '')\n\n        self.user = kwargs.pop('user', None)\n        self.page = kwargs.pop('page', None)\n\n        super().__init__(*args, **kwargs)\n\n\nclass FormBuilder:\n    def __init__(self, fields):\n        self.fields = fields\n\n    def create_singleline_field(self, field, options):\n        # TODO: This is a default value - it may need to be changed\n        options['max_length'] = 255\n        return django.forms.CharField(**options)\n\n    def create_multiline_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.Textarea, **options)\n\n    def create_date_field(self, field, options):\n        return django.forms.DateField(**options)\n\n    def create_datetime_field(self, field, options):\n        return django.forms.DateTimeField(**options)\n\n    def create_email_field(self, field, options):\n        return django.forms.EmailField(**options)\n\n    def create_url_field(self, field, options):\n        return django.forms.URLField(**options)\n\n    def create_number_field(self, field, options):\n        return django.forms.DecimalField(**options)\n\n    def create_dropdown_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(**options)\n\n    def create_multiselect_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.MultipleChoiceField(**options)\n\n    def create_radio_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)\n\n    def create_checkboxes_field(self, field, options):\n        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]\n        options['initial'] = [x.strip() for x in field.default_value.split(',')]\n        return django.forms.MultipleChoiceField(\n            widget=django.forms.CheckboxSelectMultiple, **options\n        )\n\n    def create_checkbox_field(self, field, options):\n        return django.forms.BooleanField(**options)\n\n    def create_hidden_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.HiddenInput, **options)\n\n    def get_create_field_function(self, type):\n        \"\"\"\n            Takes string of field type and returns a Django Form Field Instance.\n            Assumes form field creation functions are in the format:\n            'create_fieldtype_field'\n        \"\"\"\n        create_field_function = getattr(self, 'create_%s_field' % type, None)\n        if create_field_function:\n            return create_field_function\n        else:\n            import inspect\n            method_list = [\n                f[0] for f in\n                inspect.getmembers(self.__class__, inspect.isfunction)\n                if f[0].startswith('create_') and f[0].endswith('_field')\n            ]\n            raise AttributeError(\n                \"Could not find function matching format \\\n                create_<fieldname>_field for type: \" + type,\n                \"Must be one of: \" + \", \".join(method_list)\n            )\n\n    @property\n    def formfields(self):\n        formfields = OrderedDict()\n\n        for field in self.fields:\n            options = self.get_field_options(field)\n            create_field = self.get_create_field_function(field.field_type)\n            formfields[field.clean_name] = create_field(field, options)\n\n        return formfields\n\n    def get_field_options(self, field):\n        options = {}\n        options['label'] = field.label\n        if getattr(settings, 'WAGTAILFORMS_HELP_TEXT_ALLOW_HTML', False):\n            options['help_text'] = field.help_text\n        else:\n            options['help_text'] = conditional_escape(field.help_text)\n        options['required'] = field.required\n        options['initial'] = field.default_value\n        return options\n\n    def get_form_class(self):\n        return type(str('WagtailForm'), (BaseForm,), self.formfields)\n\n\nclass SelectDateForm(django.forms.Form):\n    date_from = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})\n    )\n    date_to = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})\n    )\n\n\nclass WagtailAdminFormPageForm(WagtailAdminPageForm):\n\n    def clean(self):\n\n        super().clean()\n\n        # Check for dupe form field labels - fixes #585\n        if 'form_fields' in self.formsets:\n            _forms = self.formsets['form_fields'].forms\n            for f in _forms:\n                f.is_valid()\n\n            for i, form in enumerate(_forms):\n                if 'label' in form.changed_data:\n                    label = form.cleaned_data.get('label')\n                    clean_name = get_field_clean_name(label)\n                    for idx, ff in enumerate(_forms):\n                        # Exclude self\n                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))\n                        if idx != i and clean_name == ff_clean_name:\n                            form.add_error(\n                                'label',\n                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))\n                            )\n", "code_before": "from collections import OrderedDict\n\nimport django.forms\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.contrib.forms.utils import get_field_clean_name\n\n\nclass BaseForm(django.forms.Form):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('label_suffix', '')\n\n        self.user = kwargs.pop('user', None)\n        self.page = kwargs.pop('page', None)\n\n        super().__init__(*args, **kwargs)\n\n\nclass FormBuilder:\n    def __init__(self, fields):\n        self.fields = fields\n\n    def create_singleline_field(self, field, options):\n        # TODO: This is a default value - it may need to be changed\n        options['max_length'] = 255\n        return django.forms.CharField(**options)\n\n    def create_multiline_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.Textarea, **options)\n\n    def create_date_field(self, field, options):\n        return django.forms.DateField(**options)\n\n    def create_datetime_field(self, field, options):\n        return django.forms.DateTimeField(**options)\n\n    def create_email_field(self, field, options):\n        return django.forms.EmailField(**options)\n\n    def create_url_field(self, field, options):\n        return django.forms.URLField(**options)\n\n    def create_number_field(self, field, options):\n        return django.forms.DecimalField(**options)\n\n    def create_dropdown_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(**options)\n\n    def create_multiselect_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.MultipleChoiceField(**options)\n\n    def create_radio_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)\n\n    def create_checkboxes_field(self, field, options):\n        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]\n        options['initial'] = [x.strip() for x in field.default_value.split(',')]\n        return django.forms.MultipleChoiceField(\n            widget=django.forms.CheckboxSelectMultiple, **options\n        )\n\n    def create_checkbox_field(self, field, options):\n        return django.forms.BooleanField(**options)\n\n    def create_hidden_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.HiddenInput, **options)\n\n    def get_create_field_function(self, type):\n        \"\"\"\n            Takes string of field type and returns a Django Form Field Instance.\n            Assumes form field creation functions are in the format:\n            'create_fieldtype_field'\n        \"\"\"\n        create_field_function = getattr(self, 'create_%s_field' % type, None)\n        if create_field_function:\n            return create_field_function\n        else:\n            import inspect\n            method_list = [\n                f[0] for f in\n                inspect.getmembers(self.__class__, inspect.isfunction)\n                if f[0].startswith('create_') and f[0].endswith('_field')\n            ]\n            raise AttributeError(\n                \"Could not find function matching format \\\n                create_<fieldname>_field for type: \" + type,\n                \"Must be one of: \" + \", \".join(method_list)\n            )\n\n    @property\n    def formfields(self):\n        formfields = OrderedDict()\n\n        for field in self.fields:\n            options = self.get_field_options(field)\n            create_field = self.get_create_field_function(field.field_type)\n            formfields[field.clean_name] = create_field(field, options)\n\n        return formfields\n\n    def get_field_options(self, field):\n        options = {}\n        options['label'] = field.label\n        options['help_text'] = field.help_text\n        options['required'] = field.required\n        options['initial'] = field.default_value\n        return options\n\n    def get_form_class(self):\n        return type(str('WagtailForm'), (BaseForm,), self.formfields)\n\n\nclass SelectDateForm(django.forms.Form):\n    date_from = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})\n    )\n    date_to = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})\n    )\n\n\nclass WagtailAdminFormPageForm(WagtailAdminPageForm):\n\n    def clean(self):\n\n        super().clean()\n\n        # Check for dupe form field labels - fixes #585\n        if 'form_fields' in self.formsets:\n            _forms = self.formsets['form_fields'].forms\n            for f in _forms:\n                f.is_valid()\n\n            for i, form in enumerate(_forms):\n                if 'label' in form.changed_data:\n                    label = form.cleaned_data.get('label')\n                    clean_name = get_field_clean_name(label)\n                    for idx, ff in enumerate(_forms):\n                        # Exclude self\n                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))\n                        if idx != i and clean_name == ff_clean_name:\n                            form.add_error(\n                                'label',\n                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))\n                            )\n", "patch": "@@ -1,6 +1,8 @@\n from collections import OrderedDict\n \n import django.forms\n+from django.conf import settings\n+from django.utils.html import conditional_escape\n from django.utils.translation import gettext_lazy as _\n \n from wagtail.admin.forms import WagtailAdminPageForm\n@@ -114,7 +116,10 @@ def formfields(self):\n     def get_field_options(self, field):\n         options = {}\n         options['label'] = field.label\n-        options['help_text'] = field.help_text\n+        if getattr(settings, 'WAGTAILFORMS_HELP_TEXT_ALLOW_HTML', False):\n+            options['help_text'] = field.help_text\n+        else:\n+            options['help_text'] = conditional_escape(field.help_text)\n         options['required'] = field.required\n         options['initial'] = field.default_value\n         return options", "file_path": "files/2020_7/18", "file_language": "py", "file_name": "wagtail/contrib/forms/forms.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/wagtail/wagtail/raw/d9a41e7f24d08c024acc9a3094940199df94db34/wagtail%2Fcontrib%2Fforms%2Ftests%2Ftest_models.py", "code": "# -*- coding: utf-8 -*-\nimport json\n\nfrom django.core import mail\nfrom django.core.checks import Info\nfrom django.test import TestCase, override_settings\n\nfrom wagtail.contrib.forms.models import FormSubmission\nfrom wagtail.contrib.forms.tests.utils import (\n    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,\n    make_types_test_form_page)\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,\n    FormPageWithCustomFormBuilder, JadeFormPage)\nfrom wagtail.tests.utils import WagtailTestUtils\n\n\nclass TestFormSubmission(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n        # HTML in help text should be escaped\n        self.assertContains(response, \"&lt;em&gt;please&lt;/em&gt; be polite\")\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    @override_settings(WAGTAILFORMS_HELP_TEXT_ALLOW_HTML=True)\n    def test_get_form_without_help_text_escaping(self):\n        response = self.client.get('/contact-us/')\n        # HTML in help text should not be escaped\n        self.assertContains(response, \"<em>please</em> be polite\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check the default form_submission is added to the context\n        self.assertContains(response, \"<li>your_email: bob@example.com</li>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = FormSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = FormSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n        # Check that the all the multiple checkbox values are serialised in the\n        # email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"bar\", mail.outbox[0].body)\n        self.assertIn(\"foo\", mail.outbox[0].body)\n        self.assertIn(\"baz\", mail.outbox[0].body)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: \", mail.outbox[0].body)\n\n\nclass TestFormWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission()\n\n        self.user = self.login()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_get_form_with_anonymous_user(self):\n        self.client.logout()\n\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertNotContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check that the custom form_submission is added to the context\n        self.assertContains(response, \"<p>Username: test@email.com</p>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_form_twice(self):\n        # First submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)\n\n        # Check that first form submission was saved correctly\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n\n        # Second submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertContains(response, '<div>The form is already filled.</div>', html=True)\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # Check that first submission exists and second submission wasn't saved\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = CustomFormPageSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = CustomFormPageSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: None\", mail.outbox[0].body)\n\n\nclass TestFormSubmissionWithMultipleRecipients(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission(\n            to_address='to@email.com, another@email.com'\n        )\n\n        self.user = self.login()\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(\n            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()\n        )\n\n\nclass TestFormWithRedirect(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertRedirects(response, '/')\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):\n\n    def setUp(self):\n\n        home_page = Page.objects.get(url_path='/home/')\n        form_page = home_page.add_child(\n            instance=FormPageWithCustomFormBuilder(\n                title='Support Request',\n                slug='support-request',\n                to_address='it@jenkins.com',\n                from_address='support@jenkins.com',\n                subject='Support Request Submitted',\n            )\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Name',\n            field_type='singleline',  # singleline field will be max_length 120\n            required=True,\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Device IP Address',\n            field_type='ipaddress',\n            required=True,\n        )\n\n    def test_get_form(self):\n        response = self.client.get('/support-request/')\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n        self.assertContains(response, '<title>Support Request</title>', html=True)\n        # check that max_length attribute has been passed into form\n        self.assertContains(response, '<input type=\"text\" name=\"name\" required maxlength=\"120\" id=\"id_name\" />', html=True)\n        # check ip address field has rendered\n        self.assertContains(response, '<input type=\"text\" name=\"device_ip_address\" required id=\"id_device_ip_address\" />', html=True)\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'very long name longer than 120 characters' * 3,  # invalid\n            'device_ip_address': '192.0.2.30',  # valid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',  # valid\n            'device_ip_address': '3300.192.0.2.30',  # invalid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',\n            'device_ip_address': '192.0.2.30',\n        })\n\n        # Check response\n        self.assertContains(response, 'Thank you for submitting a Support Request.')\n        self.assertContains(response, 'Ron Johnson')\n        self.assertContains(response, '192.0.2.30')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n\nclass TestCleanedDataEmails(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_types_test_form_page()\n\n    def test_empty_field_presence(self):\n        self.client.post('/contact-us/', {})\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Single line text: \", mail.outbox[0].body)\n        self.assertIn(\"Multiline: \", mail.outbox[0].body)\n        self.assertIn(\"Email: \", mail.outbox[0].body)\n        self.assertIn(\"Number: \", mail.outbox[0].body)\n        self.assertIn(\"URL: \", mail.outbox[0].body)\n        self.assertIn(\"Checkbox: \", mail.outbox[0].body)\n        self.assertIn(\"Checkboxes: \", mail.outbox[0].body)\n        self.assertIn(\"Drop down: \", mail.outbox[0].body)\n        self.assertIn(\"Multiple select: \", mail.outbox[0].body)\n        self.assertIn(\"Radio buttons: \", mail.outbox[0].body)\n        self.assertIn(\"Date: \", mail.outbox[0].body)\n        self.assertIn(\"Datetime: \", mail.outbox[0].body)\n\n    def test_email_field_order(self):\n        self.client.post('/contact-us/', {})\n\n        line_beginnings = [\n            \"Single line text: \",\n            \"Multiline: \",\n            \"Email: \",\n            \"Number: \",\n            \"URL: \",\n            \"Checkbox: \",\n            \"Checkboxes: \",\n            \"Drop down: \",\n            \"Multiple select: \",\n            \"Radio buttons: \",\n            \"Date: \",\n            \"Datetime: \",\n        ]\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        email_lines = mail.outbox[0].body.split('\\n')\n\n        for beginning in line_beginnings:\n            message_line = email_lines.pop(0)\n            self.assertTrue(message_line.startswith(beginning))\n\n    @override_settings(SHORT_DATE_FORMAT='m/d/Y')\n    def test_date_normalization(self):\n        self.client.post('/contact-us/', {\n            'date': '12/31/17',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Date: 12/31/2017\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'date': '12/31/1917',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Date: 12/31/1917\", mail.outbox[1].body)\n\n\n    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')\n    def test_datetime_normalization(self):\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/17 4:00:00',\n        })\n\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Datetime: 12/31/2017 4 a.m.\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/1917 21:19',\n        })\n\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Datetime: 12/31/1917 9:19 p.m.\", mail.outbox[1].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '1910-12-21 21:19:12',\n        })\n\n        self.assertEqual(len(mail.outbox), 3)\n        self.assertIn(\"Datetime: 12/21/1910 9:19 p.m.\", mail.outbox[2].body)\n\n\n\nclass TestIssue798(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific\n\n        # Add a number field to the page\n        FormField.objects.create(\n            page=self.form_page,\n            label=\"Your favourite number\",\n            field_type='number',\n        )\n\n    def test_post(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''},\n            'your_favourite_number': '7.3',\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that form submission was saved correctly\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())\n\n\nclass TestNonHtmlExtension(TestCase):\n    fixtures = ['test.json']\n\n    def test_non_html_extension(self):\n        form_page = JadeFormPage(title=\"test\")\n        self.assertEqual(form_page.landing_page_template, \"tests/form_page_landing.jade\")\n\n\nclass TestLegacyFormFieldCleanNameChecks(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific\n\n\n    def test_form_field_clean_name_update_on_checks(self):\n\n        fields_before_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_before_checks, [\n            ('Your email', ''),\n            ('Your message', ''),\n            ('Your choices', ''),\n        ])\n\n        # running checks should show an info message AND update blank clean_name values\n\n        messages = FormFieldWithCustomSubmission.check()\n\n        self.assertEqual(\n            messages,\n            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]\n        )\n\n\n        fields_after_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_after_checks, [\n            ('Your email', 'your-email'),  # kebab case, legacy format\n            ('Your message', 'your-message'),\n            ('Your choices', 'your-choices'),\n        ])\n\n        # running checks again should return no messages as fields no longer need changing\n        self.assertEqual(FormFieldWithCustomSubmission.check(), [])\n\n        # creating a new field should use the non-legacy clean_name format\n\n        field = FormFieldWithCustomSubmission.objects.create(\n            page=self.form_page,\n            label=\"Your FAVOURITE #number\",\n            field_type='number',\n        )\n\n        self.assertEqual(field.clean_name, 'your_favourite_number')\n", "code_before": "# -*- coding: utf-8 -*-\nimport json\n\nfrom django.core import mail\nfrom django.core.checks import Info\nfrom django.test import TestCase, override_settings\n\nfrom wagtail.contrib.forms.models import FormSubmission\nfrom wagtail.contrib.forms.tests.utils import (\n    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,\n    make_types_test_form_page)\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,\n    FormPageWithCustomFormBuilder, JadeFormPage)\nfrom wagtail.tests.utils import WagtailTestUtils\n\n\nclass TestFormSubmission(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check the default form_submission is added to the context\n        self.assertContains(response, \"<li>your_email: bob@example.com</li>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = FormSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = FormSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n        # Check that the all the multiple checkbox values are serialised in the\n        # email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"bar\", mail.outbox[0].body)\n        self.assertIn(\"foo\", mail.outbox[0].body)\n        self.assertIn(\"baz\", mail.outbox[0].body)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: \", mail.outbox[0].body)\n\n\nclass TestFormWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission()\n\n        self.user = self.login()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_get_form_with_anonymous_user(self):\n        self.client.logout()\n\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertNotContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check that the custom form_submission is added to the context\n        self.assertContains(response, \"<p>Username: test@email.com</p>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_form_twice(self):\n        # First submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)\n\n        # Check that first form submission was saved correctly\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n\n        # Second submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertContains(response, '<div>The form is already filled.</div>', html=True)\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # Check that first submission exists and second submission wasn't saved\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = CustomFormPageSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = CustomFormPageSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: None\", mail.outbox[0].body)\n\n\nclass TestFormSubmissionWithMultipleRecipients(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission(\n            to_address='to@email.com, another@email.com'\n        )\n\n        self.user = self.login()\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(\n            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()\n        )\n\n\nclass TestFormWithRedirect(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertRedirects(response, '/')\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):\n\n    def setUp(self):\n\n        home_page = Page.objects.get(url_path='/home/')\n        form_page = home_page.add_child(\n            instance=FormPageWithCustomFormBuilder(\n                title='Support Request',\n                slug='support-request',\n                to_address='it@jenkins.com',\n                from_address='support@jenkins.com',\n                subject='Support Request Submitted',\n            )\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Name',\n            field_type='singleline',  # singleline field will be max_length 120\n            required=True,\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Device IP Address',\n            field_type='ipaddress',\n            required=True,\n        )\n\n    def test_get_form(self):\n        response = self.client.get('/support-request/')\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n        self.assertContains(response, '<title>Support Request</title>', html=True)\n        # check that max_length attribute has been passed into form\n        self.assertContains(response, '<input type=\"text\" name=\"name\" required maxlength=\"120\" id=\"id_name\" />', html=True)\n        # check ip address field has rendered\n        self.assertContains(response, '<input type=\"text\" name=\"device_ip_address\" required id=\"id_device_ip_address\" />', html=True)\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'very long name longer than 120 characters' * 3,  # invalid\n            'device_ip_address': '192.0.2.30',  # valid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',  # valid\n            'device_ip_address': '3300.192.0.2.30',  # invalid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',\n            'device_ip_address': '192.0.2.30',\n        })\n\n        # Check response\n        self.assertContains(response, 'Thank you for submitting a Support Request.')\n        self.assertContains(response, 'Ron Johnson')\n        self.assertContains(response, '192.0.2.30')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n\nclass TestCleanedDataEmails(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_types_test_form_page()\n\n    def test_empty_field_presence(self):\n        self.client.post('/contact-us/', {})\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Single line text: \", mail.outbox[0].body)\n        self.assertIn(\"Multiline: \", mail.outbox[0].body)\n        self.assertIn(\"Email: \", mail.outbox[0].body)\n        self.assertIn(\"Number: \", mail.outbox[0].body)\n        self.assertIn(\"URL: \", mail.outbox[0].body)\n        self.assertIn(\"Checkbox: \", mail.outbox[0].body)\n        self.assertIn(\"Checkboxes: \", mail.outbox[0].body)\n        self.assertIn(\"Drop down: \", mail.outbox[0].body)\n        self.assertIn(\"Multiple select: \", mail.outbox[0].body)\n        self.assertIn(\"Radio buttons: \", mail.outbox[0].body)\n        self.assertIn(\"Date: \", mail.outbox[0].body)\n        self.assertIn(\"Datetime: \", mail.outbox[0].body)\n\n    def test_email_field_order(self):\n        self.client.post('/contact-us/', {})\n\n        line_beginnings = [\n            \"Single line text: \",\n            \"Multiline: \",\n            \"Email: \",\n            \"Number: \",\n            \"URL: \",\n            \"Checkbox: \",\n            \"Checkboxes: \",\n            \"Drop down: \",\n            \"Multiple select: \",\n            \"Radio buttons: \",\n            \"Date: \",\n            \"Datetime: \",\n        ]\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        email_lines = mail.outbox[0].body.split('\\n')\n\n        for beginning in line_beginnings:\n            message_line = email_lines.pop(0)\n            self.assertTrue(message_line.startswith(beginning))\n\n    @override_settings(SHORT_DATE_FORMAT='m/d/Y')\n    def test_date_normalization(self):\n        self.client.post('/contact-us/', {\n            'date': '12/31/17',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Date: 12/31/2017\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'date': '12/31/1917',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Date: 12/31/1917\", mail.outbox[1].body)\n\n\n    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')\n    def test_datetime_normalization(self):\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/17 4:00:00',\n        })\n\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Datetime: 12/31/2017 4 a.m.\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/1917 21:19',\n        })\n\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Datetime: 12/31/1917 9:19 p.m.\", mail.outbox[1].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '1910-12-21 21:19:12',\n        })\n\n        self.assertEqual(len(mail.outbox), 3)\n        self.assertIn(\"Datetime: 12/21/1910 9:19 p.m.\", mail.outbox[2].body)\n\n\n\nclass TestIssue798(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific\n\n        # Add a number field to the page\n        FormField.objects.create(\n            page=self.form_page,\n            label=\"Your favourite number\",\n            field_type='number',\n        )\n\n    def test_post(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''},\n            'your_favourite_number': '7.3',\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that form submission was saved correctly\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())\n\n\nclass TestNonHtmlExtension(TestCase):\n    fixtures = ['test.json']\n\n    def test_non_html_extension(self):\n        form_page = JadeFormPage(title=\"test\")\n        self.assertEqual(form_page.landing_page_template, \"tests/form_page_landing.jade\")\n\n\nclass TestLegacyFormFieldCleanNameChecks(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific\n\n\n    def test_form_field_clean_name_update_on_checks(self):\n\n        fields_before_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_before_checks, [\n            ('Your email', ''),\n            ('Your message', ''),\n            ('Your choices', ''),\n        ])\n\n        # running checks should show an info message AND update blank clean_name values\n\n        messages = FormFieldWithCustomSubmission.check()\n\n        self.assertEqual(\n            messages,\n            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]\n        )\n\n\n        fields_after_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_after_checks, [\n            ('Your email', 'your-email'),  # kebab case, legacy format\n            ('Your message', 'your-message'),\n            ('Your choices', 'your-choices'),\n        ])\n\n        # running checks again should return no messages as fields no longer need changing\n        self.assertEqual(FormFieldWithCustomSubmission.check(), [])\n\n        # creating a new field should use the non-legacy clean_name format\n\n        field = FormFieldWithCustomSubmission.objects.create(\n            page=self.form_page,\n            label=\"Your FAVOURITE #number\",\n            field_type='number',\n        )\n\n        self.assertEqual(field.clean_name, 'your_favourite_number')\n", "patch": "@@ -29,9 +29,18 @@ def test_get_form(self):\n         self.assertTemplateUsed(response, 'tests/form_page.html')\n         self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n \n+        # HTML in help text should be escaped\n+        self.assertContains(response, \"&lt;em&gt;please&lt;/em&gt; be polite\")\n+\n         # check that variables defined in get_context are passed through to the template (#1429)\n         self.assertContains(response, \"<p>hello world</p>\")\n \n+    @override_settings(WAGTAILFORMS_HELP_TEXT_ALLOW_HTML=True)\n+    def test_get_form_without_help_text_escaping(self):\n+        response = self.client.get('/contact-us/')\n+        # HTML in help text should not be escaped\n+        self.assertContains(response, \"<em>please</em> be polite\")\n+\n     def test_post_invalid_form(self):\n         response = self.client.post('/contact-us/', {\n             'your_email': 'bob',", "file_path": "files/2020_7/19", "file_language": "py", "file_name": "wagtail/contrib/forms/tests/test_models.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/wagtail/wagtail/raw/d9a41e7f24d08c024acc9a3094940199df94db34/wagtail%2Fcontrib%2Fforms%2Ftests%2Futils.py", "code": "# -*- coding: utf-8 -*-\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,\n    FormPageWithRedirect, RedirectFormField)\n\n\ndef make_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n        help_text=\"<em>please</em> be polite\"\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_custom_submission(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('intro', \"<p>Boring intro text</p>\")\n    kwargs.setdefault('thank_you_text', \"<p>Thank you for your patience!</p>\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))\n\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_redirect(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n\n    home_page = Page.objects.get(url_path='/home/')\n    kwargs.setdefault('thank_you_redirect_page', home_page)\n    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))\n    # form_page.thank_you_redirect_page = home_page\n\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_types_test_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Single line text\",\n        field_type='singleline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Multiline\",\n        field_type='multiline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Email\",\n        field_type='email',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=4,\n        label=\"Number\",\n        field_type='number',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=5,\n        label=\"URL\",\n        field_type='url',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=6,\n        label=\"Checkbox\",\n        field_type='checkbox',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=7,\n        label=\"Checkboxes\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=8,\n        label=\"Drop down\",\n        field_type='dropdown',\n        required=False,\n        choices='spam,ham,eggs',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=9,\n        label=\"Multiple select\",\n        field_type='multiselect',\n        required=False,\n        choices='qux,quux,quuz,corge',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=10,\n        label=\"Radio buttons\",\n        field_type='radio',\n        required=False,\n        choices='wibble,wobble,wubble',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=11,\n        label=\"Date\",\n        field_type='date',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=12,\n        label=\"Datetime\",\n        field_type='datetime',\n        required=False,\n    )\n\n    return form_page\n", "code_before": "# -*- coding: utf-8 -*-\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,\n    FormPageWithRedirect, RedirectFormField)\n\n\ndef make_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_custom_submission(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('intro', \"<p>Boring intro text</p>\")\n    kwargs.setdefault('thank_you_text', \"<p>Thank you for your patience!</p>\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))\n\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_redirect(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n\n    home_page = Page.objects.get(url_path='/home/')\n    kwargs.setdefault('thank_you_redirect_page', home_page)\n    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))\n    # form_page.thank_you_redirect_page = home_page\n\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_types_test_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Single line text\",\n        field_type='singleline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Multiline\",\n        field_type='multiline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Email\",\n        field_type='email',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=4,\n        label=\"Number\",\n        field_type='number',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=5,\n        label=\"URL\",\n        field_type='url',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=6,\n        label=\"Checkbox\",\n        field_type='checkbox',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=7,\n        label=\"Checkboxes\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=8,\n        label=\"Drop down\",\n        field_type='dropdown',\n        required=False,\n        choices='spam,ham,eggs',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=9,\n        label=\"Multiple select\",\n        field_type='multiselect',\n        required=False,\n        choices='qux,quux,quuz,corge',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=10,\n        label=\"Radio buttons\",\n        field_type='radio',\n        required=False,\n        choices='wibble,wobble,wubble',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=11,\n        label=\"Date\",\n        field_type='date',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=12,\n        label=\"Datetime\",\n        field_type='datetime',\n        required=False,\n    )\n\n    return form_page\n", "patch": "@@ -28,6 +28,7 @@ def make_form_page(**kwargs):\n         label=\"Your message\",\n         field_type='multiline',\n         required=True,\n+        help_text=\"<em>please</em> be polite\"\n     )\n     FormField.objects.create(\n         page=form_page,", "file_path": "files/2020_7/20", "file_language": "py", "file_name": "wagtail/contrib/forms/tests/utils.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
