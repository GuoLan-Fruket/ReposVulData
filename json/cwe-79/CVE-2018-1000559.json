{"index": 2900, "cve_id": "CVE-2018-1000559", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "qutebrowser version introduced in v0.11.0 (1179ee7a937fb31414d77d9970bac21095358449) contains a Cross Site Scripting (XSS) vulnerability in history command, qute://history page that can result in Via injected JavaScript code, a website can steal the user's browsing history. This attack appear to be exploitable via the victim must open a page with a specially crafted <title> attribute, and then open the qute://history site via the :history command. This vulnerability appears to have been fixed in fixed in v1.3.3 (4c9360237f186681b1e3f2a0f30c45161cf405c7, to be released today) and v1.4.0 (5a7869f2feaa346853d2a85413d6527c87ef0d9f, released later this week).", "cvss": "6.1", "publish_date": "June 26, 2018", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "4c9360237f186681b1e3f2a0f30c45161cf405c7", "commit_message": "Fix XSS issue on qute://history\n\nFixes #4011\n\n(cherry picked from commit 5a7869f2feaa346853d2a85413d6527c87ef0d9f)", "commit_date": "2018-06-21T19:43:53Z", "project": "qutebrowser/qutebrowser", "url": "https://api.github.com/repos/qutebrowser/qutebrowser/commits/4c9360237f186681b1e3f2a0f30c45161cf405c7", "html_url": "https://github.com/qutebrowser/qutebrowser/commit/4c9360237f186681b1e3f2a0f30c45161cf405c7", "windows_before": [{"commit_id": "7a7e04a054fb1f9874dc13586598a11bf0cde8a0", "commit_date": "Thu Jun 21 21:42:44 2018 +0200", "commit_message": "Move fix to v1.3.3 in changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "d961eab1d246c2fd9a209ba322514e1bc401c0f8", "commit_date": "Thu Jun 21 21:42:08 2018 +0200", "commit_message": "Update changelog for v1.3.3", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "5a7869f2feaa346853d2a85413d6527c87ef0d9f", "commit_date": "Thu Jun 21 21:20:19 2018 +0200", "commit_message": "Fix XSS issue on qute://history", "files_name": ["qutebrowser/browser/qutescheme.py", "tests/end2end/data/issue4011.html", "tests/end2end/features/history.feature"]}, {"commit_id": "62d8b5b57497da86ddbfda359ef248e2fe706695", "commit_date": "Thu Jun 21 17:14:29 2018 +0200", "commit_message": "Don't depend on PyQt5.QtQuickWidgets to get RWHV", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/webengine/webview.py", "tests/end2end/fixtures/quteprocess.py"]}, {"commit_id": "c87757a9134b9940409ef78f838c8832c076a0a4", "commit_date": "Thu Jun 21 16:35:17 2018 +0200", "commit_message": "Revert \"Properly add QtQuickWidgets dependency\"", "files_name": ["README.asciidoc", "doc/changelog.asciidoc", "qutebrowser/misc/earlyinit.py"]}, {"commit_id": "9f5ca475c9778041a0c26292f4da7bb3de822bda", "commit_date": "Thu Jun 21 01:44:15 2018 +0200", "commit_message": "Don't try to set focus if prev_focus is None", "files_name": ["qutebrowser/mainwindow/tabbedbrowser.py"]}, {"commit_id": "e7a300865c60f4f306bb7a592e1a57ad01d094c7", "commit_date": "Thu Jun 21 01:43:09 2018 +0200", "commit_message": "Fix lint", "files_name": ["qutebrowser/browser/webengine/spell.py"]}, {"commit_id": "4887385bdd47fffd1b0695cfb8e401fe8cb90dd8", "commit_date": "Thu Jun 21 01:40:36 2018 +0200", "commit_message": "Fix test_dictionary_dir", "files_name": ["tests/unit/browser/webengine/test_spell.py"]}, {"commit_id": "1000a1eac2d79afd25bc3a9bced3120b282390db", "commit_date": "Thu Jun 21 01:01:27 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/4005'", "files_name": ["e5405f0ae940a62d7be756acb1ae9549108742a3 - Thu Jun 21 00:21:52 2018 +0200 : Properly add QtQuickWidgets dependency", "README.asciidoc", "doc/changelog.asciidoc", "qutebrowser/misc/earlyinit.py"]}, {"commit_id": "0e7bbccd71a2a9d0fb18fba32e8389cd19d51aef", "commit_date": "Tue Jun 19 12:06:26 2018 -0400", "commit_message": "Fix stacking tabs setting with new_tab prev", "files_name": ["qutebrowser/mainwindow/tabbedbrowser.py", "tests/end2end/features/tabs.feature"]}, {"commit_id": "1919029858ef25b832790f06b269d334f3d75d76", "commit_date": "Mon Jun 18 18:09:13 2018 -0400", "commit_message": "Add setting for controlling stacking of new tabs", "files_name": ["qutebrowser/config/configdata.yml", "qutebrowser/mainwindow/tabbedbrowser.py", "tests/end2end/features/tabs.feature"]}, {"commit_id": "a73a778b9d55d5e69dcb20bec055636924c15891", "commit_date": "Mon Jun 18 19:11:20 2018 +0200", "commit_message": "Update pytest-qt from 2.4.0 to 2.4.1", "files_name": ["misc/requirements/requirements-tests.txt"]}, {"commit_id": "7c4eaa80b0e9b07f0c08f7b0ed63f31a009abb99", "commit_date": "Mon Jun 18 19:11:19 2018 +0200", "commit_message": "Update hypothesis from 3.57.0 to 3.59.1", "files_name": ["misc/requirements/requirements-tests.txt"]}, {"commit_id": "c3b76d1d01f45339857f46d814b24492f81cbd16", "commit_date": "Mon Jun 18 19:11:17 2018 +0200", "commit_message": "Update cheroot from 6.3.1 to 6.3.2", "files_name": ["misc/requirements/requirements-tests.txt"]}, {"commit_id": "fa0e8c1b51fd828978a7417c3ba9d298a960a534", "commit_date": "Mon Jun 18 19:11:16 2018 +0200", "commit_message": "Update requests from 2.18.4 to 2.19.1", "files_name": ["misc/requirements/requirements-pylint.txt"]}, {"commit_id": "da8f76d0821cc72182e415df2fbccfff9b978523", "commit_date": "Mon Jun 18 19:11:14 2018 +0200", "commit_message": "Update requests from 2.18.4 to 2.19.1", "files_name": ["misc/requirements/requirements-pylint-master.txt"]}, {"commit_id": "91c0aae05b1e81df4caabd4451bf79b97c854202", "commit_date": "Mon Jun 18 19:11:13 2018 +0200", "commit_message": "Update requests from 2.18.4 to 2.19.1", "files_name": ["misc/requirements/requirements-codecov.txt"]}, {"commit_id": "3399f2df9698a3c7bb7b9da3cfa34467f01efcb7", "commit_date": "Sun Jun 17 21:03:44 2018 +0200", "commit_message": "Always clear searches between page loads", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "2029f52fdcc30810db88bf2c68dcbeeaa3cf7d52", "commit_date": "Sun Jun 17 20:52:35 2018 +0200", "commit_message": "Show cause when ~/.netrc can't be read", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/shared.py"]}, {"commit_id": "663d1a4d2f2f9d1797a8bb3c745e954f9f3ab4ab", "commit_date": "Sun Jun 17 19:56:26 2018 +0200", "commit_message": "Read dictionaries from /usr/share/qt on Qt >= 5.10", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/webengine/spell.py", "qutebrowser/browser/webengine/webenginesettings.py", "scripts/dictcli.py"]}, {"commit_id": "0a9806daf3fb93f1525539eb82455305fd79d099", "commit_date": "Sun Jun 17 10:42:45 2018 +0200", "commit_message": "Fixed crash which could occur if user adds nonexistent category to url.open_categories_shown", "files_name": ["qutebrowser/completion/models/urlmodel.py"]}, {"commit_id": "a2b1e041d6ca9c41be34927cca7a1b96a59d06bf", "commit_date": "Sun Jun 17 10:29:57 2018 +0200", "commit_message": "Implemented use of the order of url.open_categories_shown in the :open dialogue.", "files_name": ["qutebrowser/completion/models/urlmodel.py", "qutebrowser/config/configdata.yml"]}, {"commit_id": "a62aeb4abebd9a951b9bf915a4823e64ab71f10d", "commit_date": "Sun Jun 17 05:33:53 2018 +0200", "commit_message": "Added support for searchengines listing in :open dialogue. Added settings for selecting what categories are shown in the :open dialogue.", "files_name": ["doc/help/settings.asciidoc", "qutebrowser/completion/models/urlmodel.py", "qutebrowser/config/configdata.yml"]}, {"commit_id": "7b7e0c93f5b627480cee0a7c110d24cfbbeff3b7", "commit_date": "Sat Jun 16 11:54:53 2018 +0200", "commit_message": "Update Chromium version in changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "e2ef39e8728f54c9de0aa4c21f1e790f4721e638", "commit_date": "Thu Jun 14 23:29:16 2018 +0200", "commit_message": "Add Comment to .desktop file", "files_name": ["misc/qutebrowser.desktop"]}, {"commit_id": "7654467f3610612b76872da4afd6b39214d24781", "commit_date": "Thu Jun 14 17:43:20 2018 +0200", "commit_message": "Remove unused import", "files_name": ["qutebrowser/misc/crashsignal.py"]}, {"commit_id": "b1b06fcb4322d46b65819ce89311224965715c6d", "commit_date": "Thu Jun 14 17:42:33 2018 +0200", "commit_message": "Fix restore test", "files_name": ["tests/end2end/features/keyinput.feature"]}, {"commit_id": "746c2986f038c3c311397db6412aa3b645d4651b", "commit_date": "Thu Jun 14 16:42:24 2018 +0200", "commit_message": "Fix test_stylesheet on Qt 5.11", "files_name": ["tests/helpers/fixtures.py"]}, {"commit_id": "f4386fa9ea4c5ab6c37d023515ad0c29c702423e", "commit_date": "Thu Jun 14 16:35:16 2018 +0200", "commit_message": "Update changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "07cf2f5b60efc7912dad1ed57299c7adec7cc466", "commit_date": "Thu Jun 14 16:09:30 2018 +0200", "commit_message": "Unconditionally restore mode after prompt", "files_name": ["qutebrowser/keyinput/modeman.py"]}, {"commit_id": "4dddc077534fb201954d4c240d0bbfd1df392816", "commit_date": "Thu Jun 14 16:07:39 2018 +0200", "commit_message": "Make sure modeman.enter(KeyMode.normal) does something sensible", "files_name": ["qutebrowser/keyinput/modeman.py"]}, {"commit_id": "11fce30ed0e30c0346c943127a49c8bce39a569a", "commit_date": "Thu Jun 14 15:56:48 2018 +0200", "commit_message": "Stabilize mode_on_change tests", "files_name": ["tests/end2end/features/keyinput.feature"]}, {"commit_id": "1335fccba192e9712c95eb612dc386a7043ef60f", "commit_date": "Thu Jun 14 15:40:58 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/3590' into tab-mode", "files_name": ["e4e982c0a76c3de8de2afc3e7b68ef30321ab520 - Thu Jun 14 14:57:55 2018 +0200 : Remove unused variable", "qutebrowser/misc/crashsignal.py"]}, {"commit_id": "7592186181cc2fb49b6498b3be9c1f683bfd43e1", "commit_date": "Thu Jun 14 14:54:48 2018 +0200", "commit_message": "Update changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "868cd115be9d29873caea5b391bf307685331394", "commit_date": "Thu Jun 14 14:50:45 2018 +0200", "commit_message": "Remove old focus handling code", "files_name": ["qutebrowser/browser/webkit/webview.py"]}, {"commit_id": "cec63ea449b588a193105fcf2b76c5ad80ff7e7a", "commit_date": "Thu Jun 14 14:49:30 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/3906'", "files_name": ["e5b655256821dff1f3f67c974c3922b21eebf563 - Wed Jun 13 15:37:32 2018 -0700 : Clean up and simplify some logic", "qutebrowser/browser/mouse.py", "qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "a0adee55c9114e82b18204996f97c84579500943", "commit_date": "Wed Jun 13 21:07:54 2018 +0200", "commit_message": "Quit hard on ignored exceptions", "files_name": ["qutebrowser/misc/crashsignal.py"]}, {"commit_id": "389c1d11a06ac1694ef4306e3490d2f7ad0fbd64", "commit_date": "Wed Jun 13 20:28:08 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/3990'", "files_name": ["b67733b781b644616989965cc530ecc408569f8a - Wed Jun 13 20:15:16 2018 +0200 : Use ImportError for winreg import", "scripts/dev/build_release.py"]}, {"commit_id": "bcc4bd22ee4351fd6986961bb60e64379ca6b3f1", "commit_date": "Wed Jun 13 20:15:06 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/3991'", "files_name": ["cb2881e0d713f444454c0e218d3ea5e977051396 - Wed Jun 13 19:10:01 2018 +0200 : Use info loglevel for :debug-cache-stats", "qutebrowser/misc/utilcmds.py"]}, {"commit_id": "1541088e76478e532bb6f6e112b81707d47548e7", "commit_date": "Tue Jun 12 17:01:34 2018 +0200", "commit_message": "Use -webkit-filter on old Qt", "files_name": ["qutebrowser/javascript/.eslintrc.yaml", "qutebrowser/javascript/caret.js"]}, {"commit_id": "54356095520048907483cc676e5feaf2282a5fd3", "commit_date": "Tue Jun 12 16:50:32 2018 +0200", "commit_message": "Update changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "c37134861eaf10bb3d0ecca4c4a9f376e6408050", "commit_date": "Tue Jun 12 16:49:54 2018 +0200", "commit_message": "Use ES6 template strings", "files_name": ["qutebrowser/javascript/caret.js"]}, {"commit_id": "772654bcae18a1d6ce1d904a4d4a42da2c68a817", "commit_date": "Tue Jun 12 16:46:03 2018 +0200", "commit_message": "Use calculated background color for newer Qt versions", "files_name": ["qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/javascript/caret.js"]}, {"commit_id": "68a7387b6b9959aa8af70704750b0d58f0dc1345", "commit_date": "Tue Jun 12 16:32:05 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/3940'", "files_name": ["fd4ae2fabe8e8134154dd2853346667cf6430c2c - Tue Jun 12 14:17:10 2018 +0200 : Fix test_set_wrong_backend", "tests/unit/config/test_configcommands.py"]}, {"commit_id": "a1a5885367764f2ca47d6581dde168e9b3b90be5", "commit_date": "Tue Jun 12 14:09:06 2018 +0200", "commit_message": "Set parents for tab sub-objects", "files_name": ["qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/browser/webkit/webkittab.py"]}, {"commit_id": "a6db700886518a09965dbb34950ef634c17722be", "commit_date": "Tue Jun 12 13:44:47 2018 +0200", "commit_message": "Fix HTML5 fullscreen", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "d5dcec43200701d9897913566f0580862ee48e1a", "commit_date": "Tue Jun 12 13:44:41 2018 +0200", "commit_message": "Add changelog entry for Qt update", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "088c7b235d805b70f1be198e4f3c005c4da2ff5e", "commit_date": "Tue Jun 12 11:22:41 2018 +0100", "commit_message": "fix for qt 5.7.1", "files_name": ["qutebrowser/javascript/caret.js"]}, {"commit_id": "6faff11243317bdfdece6c9b5ee5ec188d0fc194", "commit_date": "Tue Jun 12 11:10:03 2018 +0200", "commit_message": "Improve error messages with backend conditionals", "files_name": ["doc/changelog.asciidoc", "qutebrowser/config/config.py", "qutebrowser/config/configexc.py", "tests/unit/config/test_configexc.py"]}, {"commit_id": "2f97a597a44b6efd22dd0fe1a49d83460314e5a4", "commit_date": "Tue Jun 12 10:53:34 2018 +0200", "commit_message": "travis: Run coverage with PyQt 5.10", "files_name": [".travis.yml"]}, {"commit_id": "e066f83a7cb1cd4c7d462470729df899dfc0bbab", "commit_date": "Tue Jun 12 10:52:22 2018 +0200", "commit_message": "Make configinit tests run with all setups", "files_name": ["tests/helpers/utils.py", "tests/unit/config/test_configinit.py"]}, {"commit_id": "5b5657b0d5628076bd564c5f40869231fc135543", "commit_date": "Tue Jun 12 10:38:19 2018 +0200", "commit_message": "Make sure debug_flags is available for unit tests", "files_name": ["tests/helpers/fixtures.py"]}, {"commit_id": "3b0c8e46a39b21c9e79b13e6cd7793cfeee4480d", "commit_date": "Mon Jun 11 10:16:22 2018 +0200", "commit_message": "Add an initial cookie filter for Qt 5.11", "files_name": ["doc/changelog.asciidoc", "doc/help/settings.asciidoc", "qutebrowser/browser/webengine/cookies.py", "qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/config/configdata.yml"]}, {"commit_id": "35a1e118f8d46ec371d58304065302b291414df4", "commit_date": "Tue Jun 12 04:25:13 2018 +0100", "commit_message": "combine style nodes", "files_name": ["qutebrowser/javascript/caret.js"]}, {"commit_id": "093f07f552b2664492e682e04daf042d1bb1ea59", "commit_date": "Mon Jun 11 23:28:04 2018 +0200", "commit_message": "Add content.canvas_reading setting", "files_name": []}], "windows_after": [{"commit_id": "9a5439e5d09c0840918ad37c72e25f9edaef8b2d", "commit_date": "Thu Jun 21 22:22:04 2018 +0200", "commit_message": "Re-add waiting for QQuickWidget", "files_name": ["tests/end2end/fixtures/quteprocess.py"]}, {"commit_id": "0864ad406927a0810aaca307909f8665778e4713", "commit_date": "Thu Jun 21 22:28:27 2018 +0200", "commit_message": "Fix shadowing of 'html' name", "files_name": ["qutebrowser/browser/qutescheme.py"]}, {"commit_id": "66fc3a30dd710712fa5b6d9dc2f6fa92689be021", "commit_date": "Thu Jun 21 23:30:27 2018 +0200", "commit_message": "Update changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "d2254ca48b1f79512727ff4fba38a2b4222c6850", "commit_date": "Thu Jun 21 23:30:51 2018 +0200", "commit_message": "Release v1.3.3", "files_name": ["qutebrowser/__init__.py"]}, {"commit_id": "a02c25dfb1d0db1a850933250b270f1390b43e21", "commit_date": "Sat Jun 23 14:27:07 2018 +0200", "commit_message": "Don't escape URLs for qute://history", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/qutescheme.py", "qutebrowser/javascript/history.js", "tests/end2end/features/history.feature", "tests/end2end/features/test_history_bdd.py", "tests/end2end/fixtures/webserver_sub.py"]}, {"commit_id": "454c532668633d0e53ceab3ae3c4cc05654b3022", "commit_date": "Thu Jun 21 18:58:48 2018 -0400", "commit_message": "Fix behavior when toggling stacking behavior in a single tab", "files_name": ["qutebrowser/config/configdata.yml", "qutebrowser/mainwindow/tabbedbrowser.py"]}, {"commit_id": "e6e844b039130d365b72e1570dab09483cbf47bf", "commit_date": "Sun Jun 24 19:54:24 2018 +0200", "commit_message": "Support URL patterns for content.headers settings", "files_name": ["doc/changelog.asciidoc", "doc/help/settings.asciidoc", "qutebrowser/browser/shared.py", "qutebrowser/browser/webengine/interceptor.py", "qutebrowser/browser/webkit/network/networkmanager.py", "qutebrowser/browser/webkit/webpage.py", "qutebrowser/config/configdata.yml"]}, {"commit_id": "f5e69b2174794bf55fb5dab24f65054ddeeddc4f", "commit_date": "Sun Jun 24 19:57:52 2018 +0200", "commit_message": "Show inspector after creating it", "files_name": ["qutebrowser/browser/commands.py"]}, {"commit_id": "f2f481d991ed73fd54abf79929841ad51a53962d", "commit_date": "Sun Jun 24 21:38:37 2018 +0200", "commit_message": "Support URL patterns for permissions and ssl_strict", "files_name": ["doc/changelog.asciidoc", "doc/help/settings.asciidoc", "qutebrowser/browser/shared.py", "qutebrowser/config/configdata.yml"]}, {"commit_id": "fc19262eaa953c6240f0756930df88e85fe5700b", "commit_date": "Sun Jun 24 22:31:27 2018 +0200", "commit_message": "Fix test_shared.py", "files_name": ["tests/unit/browser/test_shared.py"]}, {"commit_id": "13f765a00089ae6eb5c9dda66b6efc35da58efe2", "commit_date": "Sun Jun 24 22:33:46 2018 +0200", "commit_message": "Fix changelog formatting", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "6c9e23af4a67df4cf3b14f4232e15ef84464cc4d", "commit_date": "Mon Jun 25 08:14:02 2018 +0200", "commit_message": "eslint: Turn off max-lines-per-function", "files_name": ["qutebrowser/javascript/.eslintrc.yaml"]}, {"commit_id": "da0a6305df06f0f53d0460680f7418f80502c5ff", "commit_date": "Mon Jun 25 12:45:17 2018 -0400", "commit_message": "Fix crash when tab is closed after a per-domain forced reload", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "e1bc5389a23900356d20bf5191722c4ccab0c709", "commit_date": "Mon Jun 25 19:21:12 2018 +0200", "commit_message": "Update pyqt5 from 5.10 to 5.11.1", "files_name": ["misc/requirements/requirements-pyqt-old.txt"]}, {"commit_id": "1f19db07856f417d98df8d74d94ab12b04f7430f", "commit_date": "Mon Jun 25 19:21:14 2018 +0200", "commit_message": "Update pyqt5 from 5.10.1 to 5.11.1", "files_name": ["misc/requirements/requirements-pyqt.txt"]}, {"commit_id": "d6554a131eec06eddbfdff64714530862cc49c2f", "commit_date": "Mon Jun 25 19:21:15 2018 +0200", "commit_message": "Update hypothesis from 3.59.1 to 3.61.0", "files_name": ["misc/requirements/requirements-tests.txt"]}, {"commit_id": "b3790f7a7e0eebd862875d8ba2abd8ec34607572", "commit_date": "Mon Jun 25 19:21:17 2018 +0200", "commit_message": "Update pytest from 3.6.1 to 3.6.2", "files_name": ["misc/requirements/requirements-tests.txt"]}, {"commit_id": "228ca732d53a67ed22fce62e9b024d0483b8e4f6", "commit_date": "Mon Jun 25 20:08:24 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pyup-scheduled-update-2018-06-25'", "files_name": ["158ccd7d548931d2fdf5843a747b0891a4ad3a71 - Mon Jun 25 20:08:42 2018 +0200 : Revert \"Update pyqt5 from 5.10 to 5.11.1\"", "misc/requirements/requirements-pyqt-old.txt"]}, {"commit_id": "3f923b41e06e0568385cea9eedaf3cbd0dba5268", "commit_date": "Mon Jun 25 20:08:50 2018 +0200", "commit_message": "Revert \"Update pyqt5 from 5.10.1 to 5.11.1\"", "files_name": ["misc/requirements/requirements-pyqt.txt"]}, {"commit_id": "8a4bba11ed846ffd96adf0089875229506290fc7", "commit_date": "Mon Jun 25 20:35:48 2018 +0200", "commit_message": "Disable certificate workaround on Qt >= 5.9", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/webengine/webview.py"]}, {"commit_id": "81b3ef937ebf202670c1561429552874ed51d32a", "commit_date": "Mon Jun 25 21:04:32 2018 +0200", "commit_message": "Move handling of certificate errors to webenginetab", "files_name": ["qutebrowser/browser/browsertab.py", "qutebrowser/browser/webengine/certificateerror.py", "qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/browser/webengine/webview.py", "qutebrowser/browser/webkit/webkittab.py"]}, {"commit_id": "87778277e012bf931ce15c6b89920c50ea30b589", "commit_date": "Mon Jun 25 22:51:48 2018 +0200", "commit_message": "Fix SSL error page tests", "files_name": ["tests/end2end/features/test_prompts_bdd.py"]}, {"commit_id": "876aa5a9b1b7d33c6e6dd662c73ab435fcf074b6", "commit_date": "Mon Jun 25 22:51:55 2018 +0200", "commit_message": "Fix lint", "files_name": ["qutebrowser/browser/shared.py"]}, {"commit_id": "1bc3d444b6c0e25cc754c34e2b40476cd5ba0464", "commit_date": "Mon Jun 25 23:01:17 2018 +0200", "commit_message": "Stabilize escaping URLs test", "files_name": ["tests/end2end/features/history.feature"]}, {"commit_id": "54ca9b34e529e7d0fc84c77c16cff21ce302381e", "commit_date": "Mon Jun 25 14:28:28 2018 +1200", "commit_message": "greasemonkey: enable running in isolated js worlds", "files_name": ["qutebrowser/browser/greasemonkey.py", "qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "521268a1f719a89e38d779010d4353db612a803f", "commit_date": "Tue Jun 26 12:33:40 2018 +1200", "commit_message": "Update comment.", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "324966cfe7316a395f3b043f734cd090b78d54f7", "commit_date": "Tue Jun 26 13:05:27 2018 +1200", "commit_message": "greasemonkey: also support qute-js-world on 5.7.1", "files_name": ["qutebrowser/browser/webengine/webview.py"]}, {"commit_id": "5f4efced7b17d6538b02caf4e1f22d51e90b6f1d", "commit_date": "Sun May 27 18:03:43 2018 +1200", "commit_message": "Sanitize generated filenames for downloads.", "files_name": ["qutebrowser/browser/downloads.py"]}, {"commit_id": "75c6e087c78bd344f416eb629f22df5b46e28279", "commit_date": "Mon Jun 4 10:54:02 2018 +1200", "commit_message": "Refactor individual tmpdir fixtures.", "files_name": ["tests/helpers/fixtures.py"]}, {"commit_id": "2510fde80fa051c7cbaf9dee9e6095a7ecc5eb54", "commit_date": "Mon Jun 4 10:57:16 2018 +1200", "commit_message": "Add unit test for sanitized download filenames.", "files_name": ["tests/unit/browser/webkit/test_downloads.py"]}, {"commit_id": "d31fa5229dd995041c4369cecf978eab3b0bc1b4", "commit_date": "Tue Jun 5 20:36:07 2018 +1200", "commit_message": "Stringify py.path object for py3.5", "files_name": ["tests/unit/browser/webkit/test_downloads.py"]}, {"commit_id": "ffd6ffef45d04ee0cea99365ce5a5f908451cab2", "commit_date": "Tue Jun 26 15:38:01 2018 +1200", "commit_message": "Add force_encoding call to sanitize_filename.", "files_name": ["qutebrowser/browser/downloads.py", "qutebrowser/utils/utils.py"]}, {"commit_id": "1febcb9fce933a4045395b9b7164c3c0051511a3", "commit_date": "Tue Jun 26 15:39:16 2018 +1200", "commit_message": "Also call sanitize_filename in TempDownloadManager", "files_name": ["qutebrowser/browser/downloads.py"]}, {"commit_id": "747acfe7fad3a0fa70d88b6fa8d2891fd0eecb15", "commit_date": "Tue Jun 26 16:24:37 2018 +1200", "commit_message": "Makes sanitize_filenames platform dependant.", "files_name": ["qutebrowser/utils/utils.py", "tests/unit/browser/webkit/test_downloads.py"]}, {"commit_id": "6f1232e621355f8940993dc5c1bed4252b113aef", "commit_date": "Tue Jun 26 14:25:38 2018 +1200", "commit_message": "greasemonkey: move 5.7.1 injection method into _WebEngineScripts", "files_name": ["qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/browser/webengine/webview.py"]}, {"commit_id": "ee2c7658592d65030c76178267d04ac63213b2d9", "commit_date": "Tue Jun 26 14:45:38 2018 +1200", "commit_message": "greasemonkey: check _widget is not deleted", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "c43d173197b02bd765a47335643d3643b35f687f", "commit_date": "Tue Jun 26 14:54:32 2018 +1200", "commit_message": "greasemonkey: s/userscripts/greasemonkey_scripts/", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "680ae89ffd82795c52c7b2322f19bdd5819de613", "commit_date": "Tue Jun 26 17:47:10 2018 +1200", "commit_message": "Also mock platform to windows for utils tests.", "files_name": ["tests/unit/utils/test_utils.py"]}, {"commit_id": "85a9f6a08abfdeff9d29c1cb8cd3d45ec8c5b0a5", "commit_date": "Tue Jun 26 10:23:48 2018 +0200", "commit_message": "Fix lint", "files_name": ["qutebrowser/browser/webengine/webenginetab.py", "qutebrowser/browser/webengine/webview.py", "tests/end2end/features/test_prompts_bdd.py"]}, {"commit_id": "3312c221c4691357a8564448f4d2c0f686a4944e", "commit_date": "Tue Jun 26 10:26:17 2018 +0200", "commit_message": "Stabilize ssl_strict test", "files_name": ["tests/end2end/features/test_prompts_bdd.py"]}, {"commit_id": "61da5d0c7c30338f52c80a056113844794cba94f", "commit_date": "Tue Jun 26 10:37:17 2018 +0200", "commit_message": "Merge remote-tracking branch 'origin/pr/4017'", "files_name": ["1536843f33d3113c1355ad7cd600dc4e7dd458c9 - Tue Jun 26 10:39:04 2018 +0200 : Only get greasemonkey object once", "qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "ea4ee6f00b35d83339becc08b4596c5e53f880a4", "commit_date": "Tue Jun 26 10:39:33 2018 +0200", "commit_message": "Use the url_changed signal in the tab API", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "8519aa940fc51eaa666e20c8021f4c2fae13c933", "commit_date": "Tue Jun 26 10:40:13 2018 +0200", "commit_message": "Decorate slots properly", "files_name": ["qutebrowser/browser/webengine/webenginetab.py"]}, {"commit_id": "aed964d9f567fe9ad72b595aa8c15c9a3c654c26", "commit_date": "Tue Jun 26 10:41:21 2018 +0200", "commit_message": "Update changelog", "files_name": ["doc/changelog.asciidoc"]}, {"commit_id": "2f612aa6dffb4e60d7cc62881ccfd41a2eb411d2", "commit_date": "Tue Jun 26 15:54:56 2018 +0200", "commit_message": "Update comment", "files_name": ["qutebrowser/utils/version.py"]}, {"commit_id": "a804300dc022afc8870a0ee117cba2c32ee79890", "commit_date": "Tue Jun 26 16:56:22 2018 +0200", "commit_message": "Add missing tests for spell.init()", "files_name": ["tests/unit/browser/webengine/test_spell.py"]}, {"commit_id": "96defc5dc275418c7753f93344066c68e13f69a3", "commit_date": "Wed Jun 27 15:53:58 2018 +0200", "commit_message": "Update PyYAML to 4.1", "files_name": ["misc/requirements/requirements-tests-git.txt", "requirements.txt"]}, {"commit_id": "e9c78b29edf312faeb9d82bd6c0bd576df632cd5", "commit_date": "Wed Jun 27 15:56:31 2018 +0200", "commit_message": "Ignore Python 3.7 collections.abc warning", "files_name": ["pytest.ini", "qutebrowser/utils/log.py"]}, {"commit_id": "a7af5195d14a0604e6809f58e97b168b78493dda", "commit_date": "Thu Jun 28 11:22:44 2018 +0200", "commit_message": "Set title when showing PDF.js error page", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/webkit/webpage.py"]}, {"commit_id": "dbd4ce48e656308aacef313c172b421159f21c8b", "commit_date": "Thu Jun 28 11:43:32 2018 +0200", "commit_message": "Downgrade and filter PyYAML 4.1", "files_name": ["misc/requirements/requirements-qutebrowser.txt-raw", "misc/requirements/requirements-tests-git.txt", "requirements.txt"]}, {"commit_id": "e857400c2cff543a67714afe163970f5b7b7fe48", "commit_date": "Thu Jun 28 13:26:45 2018 +0200", "commit_message": "Add missing str()", "files_name": ["tests/unit/browser/webengine/test_spell.py"]}, {"commit_id": "f7ae7e7d40849ea033050e43d4d8515587c3abf2", "commit_date": "Sat Jun 23 14:32:57 2018 +0200", "commit_message": "Update for PyQt 5.11", "files_name": [".appveyor.yml", ".travis.yml", "README.asciidoc", "doc/contributing.asciidoc", "misc/requirements/requirements-pyqt-old.txt", "misc/requirements/requirements-pyqt-old.txt-raw", "misc/requirements/requirements-pyqt.txt", "tox.ini"]}, {"commit_id": "c3455d9082bf7c32ed3932c9d4ad5edef1c51f0f", "commit_date": "Sat Jun 23 15:57:30 2018 +0200", "commit_message": "Add a wrapper around sip", "files_name": ["doc/changelog.asciidoc", "qutebrowser/browser/browsertab.py", "qutebrowser/browser/downloads.py"]}], "parents": [{"commit_id_before": "10538738e0203a35b312be3d5331a77013bbc090", "url_before": "https://api.github.com/repos/qutebrowser/qutebrowser/commits/10538738e0203a35b312be3d5331a77013bbc090", "html_url_before": "https://github.com/qutebrowser/qutebrowser/commit/10538738e0203a35b312be3d5331a77013bbc090"}], "details": [{"raw_url": "https://github.com/qutebrowser/qutebrowser/raw/4c9360237f186681b1e3f2a0f30c45161cf405c7/qutebrowser%2Fbrowser%2Fqutescheme.py", "code": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Backend-independent qute://* code.\n\nModule attributes:\n    pyeval_output: The output of the last :pyeval command.\n    _HANDLERS: The handlers registered via decorators.\n\"\"\"\n\nimport html\nimport json\nimport os\nimport time\nimport textwrap\nimport mimetypes\nimport urllib\nimport collections\n\nimport pkg_resources\nimport sip\nfrom PyQt5.QtCore import QUrlQuery, QUrl\n\nimport qutebrowser\nfrom qutebrowser.config import config, configdata, configexc, configdiff\nfrom qutebrowser.utils import (version, utils, jinja, log, message, docutils,\n                               objreg, urlutils)\nfrom qutebrowser.misc import objects\n\n\npyeval_output = \":pyeval was never called\"\nspawn_output = \":spawn was never called\"\n\n\n_HANDLERS = {}\n\n\nclass NoHandlerFound(Exception):\n\n    \"\"\"Raised when no handler was found for the given URL.\"\"\"\n\n    pass\n\n\nclass QuteSchemeOSError(Exception):\n\n    \"\"\"Called when there was an OSError inside a handler.\"\"\"\n\n    pass\n\n\nclass QuteSchemeError(Exception):\n\n    \"\"\"Exception to signal that a handler should return an ErrorReply.\n\n    Attributes correspond to the arguments in\n    networkreply.ErrorNetworkReply.\n\n    Attributes:\n        errorstring: Error string to print.\n        error: Numerical error value.\n    \"\"\"\n\n    def __init__(self, errorstring, error):\n        self.errorstring = errorstring\n        self.error = error\n        super().__init__(errorstring)\n\n\nclass Redirect(Exception):\n\n    \"\"\"Exception to signal a redirect should happen.\n\n    Attributes:\n        url: The URL to redirect to, as a QUrl.\n    \"\"\"\n\n    def __init__(self, url):\n        super().__init__(url.toDisplayString())\n        self.url = url\n\n\nclass add_handler:  # noqa: N801,N806 pylint: disable=invalid-name\n\n    \"\"\"Decorator to register a qute://* URL handler.\n\n    Attributes:\n        _name: The 'foo' part of qute://foo\n        backend: Limit which backends the handler can run with.\n    \"\"\"\n\n    def __init__(self, name, backend=None):\n        self._name = name\n        self._backend = backend\n        self._function = None\n\n    def __call__(self, function):\n        self._function = function\n        _HANDLERS[self._name] = self.wrapper\n        return function\n\n    def wrapper(self, *args, **kwargs):\n        \"\"\"Call the underlying function.\"\"\"\n        if self._backend is not None and objects.backend != self._backend:\n            return self.wrong_backend_handler(*args, **kwargs)\n        else:\n            return self._function(*args, **kwargs)\n\n    def wrong_backend_handler(self, url):\n        \"\"\"Show an error page about using the invalid backend.\"\"\"\n        html = jinja.render('error.html',\n                            title=\"Error while opening qute://url\",\n                            url=url.toDisplayString(),\n                            error='{} is not available with this '\n                                  'backend'.format(url.toDisplayString()))\n        return 'text/html', html\n\n\ndef data_for_url(url):\n    \"\"\"Get the data to show for the given URL.\n\n    Args:\n        url: The QUrl to show.\n\n    Return:\n        A (mimetype, data) tuple.\n    \"\"\"\n    norm_url = url.adjusted(QUrl.NormalizePathSegments |\n                            QUrl.StripTrailingSlash)\n    if norm_url != url:\n        raise Redirect(norm_url)\n\n    path = url.path()\n    host = url.host()\n    query = urlutils.query_string(url)\n    # A url like \"qute:foo\" is split as \"scheme:path\", not \"scheme:host\".\n    log.misc.debug(\"url: {}, path: {}, host {}\".format(\n        url.toDisplayString(), path, host))\n    if not path or not host:\n        new_url = QUrl()\n        new_url.setScheme('qute')\n        # When path is absent, e.g. qute://help (with no trailing slash)\n        if host:\n            new_url.setHost(host)\n        # When host is absent, e.g. qute:help\n        else:\n            new_url.setHost(path)\n\n        new_url.setPath('/')\n        if query:\n            new_url.setQuery(query)\n        if new_url.host():  # path was a valid host\n            raise Redirect(new_url)\n\n    try:\n        handler = _HANDLERS[host]\n    except KeyError:\n        raise NoHandlerFound(url)\n\n    try:\n        mimetype, data = handler(url)\n    except OSError as e:\n        # FIXME:qtwebengine how to handle this?\n        raise QuteSchemeOSError(e)\n    except QuteSchemeError as e:\n        raise\n\n    assert mimetype is not None, url\n    if mimetype == 'text/html' and isinstance(data, str):\n        # We let handlers return HTML as text\n        data = data.encode('utf-8', errors='xmlcharrefreplace')\n\n    return mimetype, data\n\n\n@add_handler('bookmarks')\ndef qute_bookmarks(_url):\n    \"\"\"Handler for qute://bookmarks. Display all quickmarks / bookmarks.\"\"\"\n    bookmarks = sorted(objreg.get('bookmark-manager').marks.items(),\n                       key=lambda x: x[1])  # Sort by title\n    quickmarks = sorted(objreg.get('quickmark-manager').marks.items(),\n                        key=lambda x: x[0])  # Sort by name\n\n    html = jinja.render('bookmarks.html',\n                        title='Bookmarks',\n                        bookmarks=bookmarks,\n                        quickmarks=quickmarks)\n    return 'text/html', html\n\n\n@add_handler('tabs')\ndef qute_tabs(_url):\n    \"\"\"Handler for qute://tabs. Display information about all open tabs.\"\"\"\n    tabs = collections.defaultdict(list)\n    for win_id, window in objreg.window_registry.items():\n        if sip.isdeleted(window):\n            continue\n        tabbed_browser = objreg.get('tabbed-browser',\n                                    scope='window',\n                                    window=win_id)\n        for tab in tabbed_browser.widgets():\n            if tab.url() not in [QUrl(\"qute://tabs/\"), QUrl(\"qute://tabs\")]:\n                urlstr = tab.url().toDisplayString()\n                tabs[str(win_id)].append((tab.title(), urlstr))\n\n    html = jinja.render('tabs.html',\n                        title='Tabs',\n                        tab_list_by_window=tabs)\n    return 'text/html', html\n\n\ndef history_data(start_time, offset=None):\n    \"\"\"Return history data.\n\n    Arguments:\n        start_time: select history starting from this timestamp.\n        offset: number of items to skip\n    \"\"\"\n    # history atimes are stored as ints, ensure start_time is not a float\n    start_time = int(start_time)\n    hist = objreg.get('web-history')\n    if offset is not None:\n        entries = hist.entries_before(start_time, limit=1000, offset=offset)\n    else:\n        # end is 24hrs earlier than start\n        end_time = start_time - 24*60*60\n        entries = hist.entries_between(end_time, start_time)\n\n    return [{\"url\": html.escape(e.url),\n             \"title\": html.escape(e.title) or html.escape(e.url),\n             \"time\": e.atime} for e in entries]\n\n\n@add_handler('history')\ndef qute_history(url):\n    \"\"\"Handler for qute://history. Display and serve history.\"\"\"\n    if url.path() == '/data':\n        try:\n            offset = QUrlQuery(url).queryItemValue(\"offset\")\n            offset = int(offset) if offset else None\n        except ValueError as e:\n            raise QuteSchemeError(\"Query parameter offset is invalid\", e)\n        # Use start_time in query or current time.\n        try:\n            start_time = QUrlQuery(url).queryItemValue(\"start_time\")\n            start_time = float(start_time) if start_time else time.time()\n        except ValueError as e:\n            raise QuteSchemeError(\"Query parameter start_time is invalid\", e)\n\n        return 'text/html', json.dumps(history_data(start_time, offset))\n    else:\n        return 'text/html', jinja.render(\n            'history.html',\n            title='History',\n            gap_interval=config.val.history_gap_interval\n        )\n\n\n@add_handler('javascript')\ndef qute_javascript(url):\n    \"\"\"Handler for qute://javascript.\n\n    Return content of file given as query parameter.\n    \"\"\"\n    path = url.path()\n    if path:\n        path = \"javascript\" + os.sep.join(path.split('/'))\n        return 'text/html', utils.read_file(path, binary=False)\n    else:\n        raise QuteSchemeError(\"No file specified\", ValueError())\n\n\n@add_handler('pyeval')\ndef qute_pyeval(_url):\n    \"\"\"Handler for qute://pyeval.\"\"\"\n    html = jinja.render('pre.html', title='pyeval', content=pyeval_output)\n    return 'text/html', html\n\n\n@add_handler('spawn-output')\ndef qute_spawn_output(_url):\n    \"\"\"Handler for qute://spawn-output.\"\"\"\n    html = jinja.render('pre.html', title='spawn output', content=spawn_output)\n    return 'text/html', html\n\n\n@add_handler('version')\n@add_handler('verizon')\ndef qute_version(_url):\n    \"\"\"Handler for qute://version.\"\"\"\n    html = jinja.render('version.html', title='Version info',\n                        version=version.version(),\n                        copyright=qutebrowser.__copyright__)\n    return 'text/html', html\n\n\n@add_handler('plainlog')\ndef qute_plainlog(url):\n    \"\"\"Handler for qute://plainlog.\n\n    An optional query parameter specifies the minimum log level to print.\n    For example, qute://log?level=warning prints warnings and errors.\n    Level can be one of: vdebug, debug, info, warning, error, critical.\n    \"\"\"\n    if log.ram_handler is None:\n        text = \"Log output was disabled.\"\n    else:\n        level = QUrlQuery(url).queryItemValue('level')\n        if not level:\n            level = 'vdebug'\n        text = log.ram_handler.dump_log(html=False, level=level)\n    html = jinja.render('pre.html', title='log', content=text)\n    return 'text/html', html\n\n\n@add_handler('log')\ndef qute_log(url):\n    \"\"\"Handler for qute://log.\n\n    An optional query parameter specifies the minimum log level to print.\n    For example, qute://log?level=warning prints warnings and errors.\n    Level can be one of: vdebug, debug, info, warning, error, critical.\n    \"\"\"\n    if log.ram_handler is None:\n        html_log = None\n    else:\n        level = QUrlQuery(url).queryItemValue('level')\n        if not level:\n            level = 'vdebug'\n        html_log = log.ram_handler.dump_log(html=True, level=level)\n\n    html = jinja.render('log.html', title='log', content=html_log)\n    return 'text/html', html\n\n\n@add_handler('gpl')\ndef qute_gpl(_url):\n    \"\"\"Handler for qute://gpl. Return HTML content as string.\"\"\"\n    return 'text/html', utils.read_file('html/license.html')\n\n\n@add_handler('help')\ndef qute_help(url):\n    \"\"\"Handler for qute://help.\"\"\"\n    urlpath = url.path()\n    if not urlpath or urlpath == '/':\n        urlpath = 'index.html'\n    else:\n        urlpath = urlpath.lstrip('/')\n    if not docutils.docs_up_to_date(urlpath):\n        message.error(\"Your documentation is outdated! Please re-run \"\n                      \"scripts/asciidoc2html.py.\")\n\n    path = 'html/doc/{}'.format(urlpath)\n    if not urlpath.endswith('.html'):\n        try:\n            bdata = utils.read_file(path, binary=True)\n        except OSError as e:\n            raise QuteSchemeOSError(e)\n        mimetype, _encoding = mimetypes.guess_type(urlpath)\n        assert mimetype is not None, url\n        return mimetype, bdata\n\n    try:\n        data = utils.read_file(path)\n    except OSError:\n        # No .html around, let's see if we find the asciidoc\n        asciidoc_path = path.replace('.html', '.asciidoc')\n        if asciidoc_path.startswith('html/doc/'):\n            asciidoc_path = asciidoc_path.replace('html/doc/', '../doc/help/')\n\n        try:\n            asciidoc = utils.read_file(asciidoc_path)\n        except OSError:\n            asciidoc = None\n\n        if asciidoc is None:\n            raise\n\n        preamble = textwrap.dedent(\"\"\"\n            There was an error loading the documentation!\n\n            This most likely means the documentation was not generated\n            properly. If you are running qutebrowser from the git repository,\n            please (re)run scripts/asciidoc2html.py and reload this page.\n\n            If you're running a released version this is a bug, please use\n            :report to report it.\n\n            Falling back to the plaintext version.\n\n            ---------------------------------------------------------------\n\n\n        \"\"\")\n        return 'text/plain', (preamble + asciidoc).encode('utf-8')\n    else:\n        return 'text/html', data\n\n\n@add_handler('backend-warning')\ndef qute_backend_warning(_url):\n    \"\"\"Handler for qute://backend-warning.\"\"\"\n    html = jinja.render('backend-warning.html',\n                        distribution=version.distribution(),\n                        Distribution=version.Distribution,\n                        version=pkg_resources.parse_version,\n                        title=\"Legacy backend warning\")\n    return 'text/html', html\n\n\ndef _qute_settings_set(url):\n    \"\"\"Handler for qute://settings/set.\"\"\"\n    query = QUrlQuery(url)\n    option = query.queryItemValue('option', QUrl.FullyDecoded)\n    value = query.queryItemValue('value', QUrl.FullyDecoded)\n\n    # https://github.com/qutebrowser/qutebrowser/issues/727\n    if option == 'content.javascript.enabled' and value == 'false':\n        msg = (\"Refusing to disable javascript via qute://settings \"\n               \"as it needs javascript support.\")\n        message.error(msg)\n        return 'text/html', b'error: ' + msg.encode('utf-8')\n\n    try:\n        config.instance.set_str(option, value, save_yaml=True)\n        return 'text/html', b'ok'\n    except configexc.Error as e:\n        message.error(str(e))\n        return 'text/html', b'error: ' + str(e).encode('utf-8')\n\n\n@add_handler('settings')\ndef qute_settings(url):\n    \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\"\n    if url.path() == '/set':\n        return _qute_settings_set(url)\n\n    html = jinja.render('settings.html', title='settings',\n                        configdata=configdata,\n                        confget=config.instance.get_str)\n    return 'text/html', html\n\n\n@add_handler('bindings')\ndef qute_bindings(_url):\n    \"\"\"Handler for qute://bindings. View keybindings.\"\"\"\n    bindings = {}\n    defaults = config.val.bindings.default\n    modes = set(defaults.keys()).union(config.val.bindings.commands)\n    modes.remove('normal')\n    modes = ['normal'] + sorted(list(modes))\n    for mode in modes:\n        bindings[mode] = config.key_instance.get_bindings_for(mode)\n\n    html = jinja.render('bindings.html', title='Bindings',\n                        bindings=bindings)\n    return 'text/html', html\n\n\n@add_handler('back')\ndef qute_back(url):\n    \"\"\"Handler for qute://back.\n\n    Simple page to free ram / lazy load a site, goes back on focusing the tab.\n    \"\"\"\n    html = jinja.render(\n        'back.html',\n        title='Suspended: ' + urllib.parse.unquote(url.fragment()))\n    return 'text/html', html\n\n\n@add_handler('configdiff')\ndef qute_configdiff(url):\n    \"\"\"Handler for qute://configdiff.\"\"\"\n    if url.path() == '/old':\n        try:\n            return 'text/html', configdiff.get_diff()\n        except OSError as e:\n            error = (b'Failed to read old config: ' +\n                     str(e.strerror).encode('utf-8'))\n            return 'text/plain', error\n    else:\n        data = config.instance.dump_userconfig().encode('utf-8')\n        return 'text/plain', data\n\n\n@add_handler('pastebin-version')\ndef qute_pastebin_version(_url):\n    \"\"\"Handler that pastebins the version string.\"\"\"\n    version.pastebin_version()\n    return 'text/plain', b'Paste called.'\n", "code_before": "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:\n\n# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>\n#\n# This file is part of qutebrowser.\n#\n# qutebrowser is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# qutebrowser is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Backend-independent qute://* code.\n\nModule attributes:\n    pyeval_output: The output of the last :pyeval command.\n    _HANDLERS: The handlers registered via decorators.\n\"\"\"\n\nimport json\nimport os\nimport time\nimport textwrap\nimport mimetypes\nimport urllib\nimport collections\n\nimport pkg_resources\nimport sip\nfrom PyQt5.QtCore import QUrlQuery, QUrl\n\nimport qutebrowser\nfrom qutebrowser.config import config, configdata, configexc, configdiff\nfrom qutebrowser.utils import (version, utils, jinja, log, message, docutils,\n                               objreg, urlutils)\nfrom qutebrowser.misc import objects\n\n\npyeval_output = \":pyeval was never called\"\nspawn_output = \":spawn was never called\"\n\n\n_HANDLERS = {}\n\n\nclass NoHandlerFound(Exception):\n\n    \"\"\"Raised when no handler was found for the given URL.\"\"\"\n\n    pass\n\n\nclass QuteSchemeOSError(Exception):\n\n    \"\"\"Called when there was an OSError inside a handler.\"\"\"\n\n    pass\n\n\nclass QuteSchemeError(Exception):\n\n    \"\"\"Exception to signal that a handler should return an ErrorReply.\n\n    Attributes correspond to the arguments in\n    networkreply.ErrorNetworkReply.\n\n    Attributes:\n        errorstring: Error string to print.\n        error: Numerical error value.\n    \"\"\"\n\n    def __init__(self, errorstring, error):\n        self.errorstring = errorstring\n        self.error = error\n        super().__init__(errorstring)\n\n\nclass Redirect(Exception):\n\n    \"\"\"Exception to signal a redirect should happen.\n\n    Attributes:\n        url: The URL to redirect to, as a QUrl.\n    \"\"\"\n\n    def __init__(self, url):\n        super().__init__(url.toDisplayString())\n        self.url = url\n\n\nclass add_handler:  # noqa: N801,N806 pylint: disable=invalid-name\n\n    \"\"\"Decorator to register a qute://* URL handler.\n\n    Attributes:\n        _name: The 'foo' part of qute://foo\n        backend: Limit which backends the handler can run with.\n    \"\"\"\n\n    def __init__(self, name, backend=None):\n        self._name = name\n        self._backend = backend\n        self._function = None\n\n    def __call__(self, function):\n        self._function = function\n        _HANDLERS[self._name] = self.wrapper\n        return function\n\n    def wrapper(self, *args, **kwargs):\n        \"\"\"Call the underlying function.\"\"\"\n        if self._backend is not None and objects.backend != self._backend:\n            return self.wrong_backend_handler(*args, **kwargs)\n        else:\n            return self._function(*args, **kwargs)\n\n    def wrong_backend_handler(self, url):\n        \"\"\"Show an error page about using the invalid backend.\"\"\"\n        html = jinja.render('error.html',\n                            title=\"Error while opening qute://url\",\n                            url=url.toDisplayString(),\n                            error='{} is not available with this '\n                                  'backend'.format(url.toDisplayString()))\n        return 'text/html', html\n\n\ndef data_for_url(url):\n    \"\"\"Get the data to show for the given URL.\n\n    Args:\n        url: The QUrl to show.\n\n    Return:\n        A (mimetype, data) tuple.\n    \"\"\"\n    norm_url = url.adjusted(QUrl.NormalizePathSegments |\n                            QUrl.StripTrailingSlash)\n    if norm_url != url:\n        raise Redirect(norm_url)\n\n    path = url.path()\n    host = url.host()\n    query = urlutils.query_string(url)\n    # A url like \"qute:foo\" is split as \"scheme:path\", not \"scheme:host\".\n    log.misc.debug(\"url: {}, path: {}, host {}\".format(\n        url.toDisplayString(), path, host))\n    if not path or not host:\n        new_url = QUrl()\n        new_url.setScheme('qute')\n        # When path is absent, e.g. qute://help (with no trailing slash)\n        if host:\n            new_url.setHost(host)\n        # When host is absent, e.g. qute:help\n        else:\n            new_url.setHost(path)\n\n        new_url.setPath('/')\n        if query:\n            new_url.setQuery(query)\n        if new_url.host():  # path was a valid host\n            raise Redirect(new_url)\n\n    try:\n        handler = _HANDLERS[host]\n    except KeyError:\n        raise NoHandlerFound(url)\n\n    try:\n        mimetype, data = handler(url)\n    except OSError as e:\n        # FIXME:qtwebengine how to handle this?\n        raise QuteSchemeOSError(e)\n    except QuteSchemeError as e:\n        raise\n\n    assert mimetype is not None, url\n    if mimetype == 'text/html' and isinstance(data, str):\n        # We let handlers return HTML as text\n        data = data.encode('utf-8', errors='xmlcharrefreplace')\n\n    return mimetype, data\n\n\n@add_handler('bookmarks')\ndef qute_bookmarks(_url):\n    \"\"\"Handler for qute://bookmarks. Display all quickmarks / bookmarks.\"\"\"\n    bookmarks = sorted(objreg.get('bookmark-manager').marks.items(),\n                       key=lambda x: x[1])  # Sort by title\n    quickmarks = sorted(objreg.get('quickmark-manager').marks.items(),\n                        key=lambda x: x[0])  # Sort by name\n\n    html = jinja.render('bookmarks.html',\n                        title='Bookmarks',\n                        bookmarks=bookmarks,\n                        quickmarks=quickmarks)\n    return 'text/html', html\n\n\n@add_handler('tabs')\ndef qute_tabs(_url):\n    \"\"\"Handler for qute://tabs. Display information about all open tabs.\"\"\"\n    tabs = collections.defaultdict(list)\n    for win_id, window in objreg.window_registry.items():\n        if sip.isdeleted(window):\n            continue\n        tabbed_browser = objreg.get('tabbed-browser',\n                                    scope='window',\n                                    window=win_id)\n        for tab in tabbed_browser.widgets():\n            if tab.url() not in [QUrl(\"qute://tabs/\"), QUrl(\"qute://tabs\")]:\n                urlstr = tab.url().toDisplayString()\n                tabs[str(win_id)].append((tab.title(), urlstr))\n\n    html = jinja.render('tabs.html',\n                        title='Tabs',\n                        tab_list_by_window=tabs)\n    return 'text/html', html\n\n\ndef history_data(start_time, offset=None):\n    \"\"\"Return history data.\n\n    Arguments:\n        start_time: select history starting from this timestamp.\n        offset: number of items to skip\n    \"\"\"\n    # history atimes are stored as ints, ensure start_time is not a float\n    start_time = int(start_time)\n    hist = objreg.get('web-history')\n    if offset is not None:\n        entries = hist.entries_before(start_time, limit=1000, offset=offset)\n    else:\n        # end is 24hrs earlier than start\n        end_time = start_time - 24*60*60\n        entries = hist.entries_between(end_time, start_time)\n\n    return [{\"url\": e.url, \"title\": e.title or e.url, \"time\": e.atime}\n            for e in entries]\n\n\n@add_handler('history')\ndef qute_history(url):\n    \"\"\"Handler for qute://history. Display and serve history.\"\"\"\n    if url.path() == '/data':\n        try:\n            offset = QUrlQuery(url).queryItemValue(\"offset\")\n            offset = int(offset) if offset else None\n        except ValueError as e:\n            raise QuteSchemeError(\"Query parameter offset is invalid\", e)\n        # Use start_time in query or current time.\n        try:\n            start_time = QUrlQuery(url).queryItemValue(\"start_time\")\n            start_time = float(start_time) if start_time else time.time()\n        except ValueError as e:\n            raise QuteSchemeError(\"Query parameter start_time is invalid\", e)\n\n        return 'text/html', json.dumps(history_data(start_time, offset))\n    else:\n        return 'text/html', jinja.render(\n            'history.html',\n            title='History',\n            gap_interval=config.val.history_gap_interval\n        )\n\n\n@add_handler('javascript')\ndef qute_javascript(url):\n    \"\"\"Handler for qute://javascript.\n\n    Return content of file given as query parameter.\n    \"\"\"\n    path = url.path()\n    if path:\n        path = \"javascript\" + os.sep.join(path.split('/'))\n        return 'text/html', utils.read_file(path, binary=False)\n    else:\n        raise QuteSchemeError(\"No file specified\", ValueError())\n\n\n@add_handler('pyeval')\ndef qute_pyeval(_url):\n    \"\"\"Handler for qute://pyeval.\"\"\"\n    html = jinja.render('pre.html', title='pyeval', content=pyeval_output)\n    return 'text/html', html\n\n\n@add_handler('spawn-output')\ndef qute_spawn_output(_url):\n    \"\"\"Handler for qute://spawn-output.\"\"\"\n    html = jinja.render('pre.html', title='spawn output', content=spawn_output)\n    return 'text/html', html\n\n\n@add_handler('version')\n@add_handler('verizon')\ndef qute_version(_url):\n    \"\"\"Handler for qute://version.\"\"\"\n    html = jinja.render('version.html', title='Version info',\n                        version=version.version(),\n                        copyright=qutebrowser.__copyright__)\n    return 'text/html', html\n\n\n@add_handler('plainlog')\ndef qute_plainlog(url):\n    \"\"\"Handler for qute://plainlog.\n\n    An optional query parameter specifies the minimum log level to print.\n    For example, qute://log?level=warning prints warnings and errors.\n    Level can be one of: vdebug, debug, info, warning, error, critical.\n    \"\"\"\n    if log.ram_handler is None:\n        text = \"Log output was disabled.\"\n    else:\n        level = QUrlQuery(url).queryItemValue('level')\n        if not level:\n            level = 'vdebug'\n        text = log.ram_handler.dump_log(html=False, level=level)\n    html = jinja.render('pre.html', title='log', content=text)\n    return 'text/html', html\n\n\n@add_handler('log')\ndef qute_log(url):\n    \"\"\"Handler for qute://log.\n\n    An optional query parameter specifies the minimum log level to print.\n    For example, qute://log?level=warning prints warnings and errors.\n    Level can be one of: vdebug, debug, info, warning, error, critical.\n    \"\"\"\n    if log.ram_handler is None:\n        html_log = None\n    else:\n        level = QUrlQuery(url).queryItemValue('level')\n        if not level:\n            level = 'vdebug'\n        html_log = log.ram_handler.dump_log(html=True, level=level)\n\n    html = jinja.render('log.html', title='log', content=html_log)\n    return 'text/html', html\n\n\n@add_handler('gpl')\ndef qute_gpl(_url):\n    \"\"\"Handler for qute://gpl. Return HTML content as string.\"\"\"\n    return 'text/html', utils.read_file('html/license.html')\n\n\n@add_handler('help')\ndef qute_help(url):\n    \"\"\"Handler for qute://help.\"\"\"\n    urlpath = url.path()\n    if not urlpath or urlpath == '/':\n        urlpath = 'index.html'\n    else:\n        urlpath = urlpath.lstrip('/')\n    if not docutils.docs_up_to_date(urlpath):\n        message.error(\"Your documentation is outdated! Please re-run \"\n                      \"scripts/asciidoc2html.py.\")\n\n    path = 'html/doc/{}'.format(urlpath)\n    if not urlpath.endswith('.html'):\n        try:\n            bdata = utils.read_file(path, binary=True)\n        except OSError as e:\n            raise QuteSchemeOSError(e)\n        mimetype, _encoding = mimetypes.guess_type(urlpath)\n        assert mimetype is not None, url\n        return mimetype, bdata\n\n    try:\n        data = utils.read_file(path)\n    except OSError:\n        # No .html around, let's see if we find the asciidoc\n        asciidoc_path = path.replace('.html', '.asciidoc')\n        if asciidoc_path.startswith('html/doc/'):\n            asciidoc_path = asciidoc_path.replace('html/doc/', '../doc/help/')\n\n        try:\n            asciidoc = utils.read_file(asciidoc_path)\n        except OSError:\n            asciidoc = None\n\n        if asciidoc is None:\n            raise\n\n        preamble = textwrap.dedent(\"\"\"\n            There was an error loading the documentation!\n\n            This most likely means the documentation was not generated\n            properly. If you are running qutebrowser from the git repository,\n            please (re)run scripts/asciidoc2html.py and reload this page.\n\n            If you're running a released version this is a bug, please use\n            :report to report it.\n\n            Falling back to the plaintext version.\n\n            ---------------------------------------------------------------\n\n\n        \"\"\")\n        return 'text/plain', (preamble + asciidoc).encode('utf-8')\n    else:\n        return 'text/html', data\n\n\n@add_handler('backend-warning')\ndef qute_backend_warning(_url):\n    \"\"\"Handler for qute://backend-warning.\"\"\"\n    html = jinja.render('backend-warning.html',\n                        distribution=version.distribution(),\n                        Distribution=version.Distribution,\n                        version=pkg_resources.parse_version,\n                        title=\"Legacy backend warning\")\n    return 'text/html', html\n\n\ndef _qute_settings_set(url):\n    \"\"\"Handler for qute://settings/set.\"\"\"\n    query = QUrlQuery(url)\n    option = query.queryItemValue('option', QUrl.FullyDecoded)\n    value = query.queryItemValue('value', QUrl.FullyDecoded)\n\n    # https://github.com/qutebrowser/qutebrowser/issues/727\n    if option == 'content.javascript.enabled' and value == 'false':\n        msg = (\"Refusing to disable javascript via qute://settings \"\n               \"as it needs javascript support.\")\n        message.error(msg)\n        return 'text/html', b'error: ' + msg.encode('utf-8')\n\n    try:\n        config.instance.set_str(option, value, save_yaml=True)\n        return 'text/html', b'ok'\n    except configexc.Error as e:\n        message.error(str(e))\n        return 'text/html', b'error: ' + str(e).encode('utf-8')\n\n\n@add_handler('settings')\ndef qute_settings(url):\n    \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\"\n    if url.path() == '/set':\n        return _qute_settings_set(url)\n\n    html = jinja.render('settings.html', title='settings',\n                        configdata=configdata,\n                        confget=config.instance.get_str)\n    return 'text/html', html\n\n\n@add_handler('bindings')\ndef qute_bindings(_url):\n    \"\"\"Handler for qute://bindings. View keybindings.\"\"\"\n    bindings = {}\n    defaults = config.val.bindings.default\n    modes = set(defaults.keys()).union(config.val.bindings.commands)\n    modes.remove('normal')\n    modes = ['normal'] + sorted(list(modes))\n    for mode in modes:\n        bindings[mode] = config.key_instance.get_bindings_for(mode)\n\n    html = jinja.render('bindings.html', title='Bindings',\n                        bindings=bindings)\n    return 'text/html', html\n\n\n@add_handler('back')\ndef qute_back(url):\n    \"\"\"Handler for qute://back.\n\n    Simple page to free ram / lazy load a site, goes back on focusing the tab.\n    \"\"\"\n    html = jinja.render(\n        'back.html',\n        title='Suspended: ' + urllib.parse.unquote(url.fragment()))\n    return 'text/html', html\n\n\n@add_handler('configdiff')\ndef qute_configdiff(url):\n    \"\"\"Handler for qute://configdiff.\"\"\"\n    if url.path() == '/old':\n        try:\n            return 'text/html', configdiff.get_diff()\n        except OSError as e:\n            error = (b'Failed to read old config: ' +\n                     str(e.strerror).encode('utf-8'))\n            return 'text/plain', error\n    else:\n        data = config.instance.dump_userconfig().encode('utf-8')\n        return 'text/plain', data\n\n\n@add_handler('pastebin-version')\ndef qute_pastebin_version(_url):\n    \"\"\"Handler that pastebins the version string.\"\"\"\n    version.pastebin_version()\n    return 'text/plain', b'Paste called.'\n", "patch": "@@ -24,6 +24,7 @@\n     _HANDLERS: The handlers registered via decorators.\n \"\"\"\n \n+import html\n import json\n import os\n import time\n@@ -241,8 +242,9 @@ def history_data(start_time, offset=None):\n         end_time = start_time - 24*60*60\n         entries = hist.entries_between(end_time, start_time)\n \n-    return [{\"url\": e.url, \"title\": e.title or e.url, \"time\": e.atime}\n-            for e in entries]\n+    return [{\"url\": html.escape(e.url),\n+             \"title\": html.escape(e.title) or html.escape(e.url),\n+             \"time\": e.atime} for e in entries]\n \n \n @add_handler('history')", "file_path": "files/2018_6\\16", "file_language": "py", "file_name": "qutebrowser/browser/qutescheme.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/qutebrowser/qutebrowser/raw/4c9360237f186681b1e3f2a0f30c45161cf405c7/tests%2Fend2end%2Fdata%2Fissue4011.html", "code": "<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>&lt;img src=&quot;x&quot; onerror=&quot;console.log('XSS')&quot;&gt;foo</title>\n    </head>\n    <body>\n        foo\n    </body>\n</html>\n", "code_before": "", "patch": "@@ -0,0 +1,10 @@\n+<!DOCTYPE html>\n+<html>\n+    <head>\n+        <meta charset=\"utf-8\">\n+        <title>&lt;img src=&quot;x&quot; onerror=&quot;console.log('XSS')&quot;&gt;foo</title>\n+    </head>\n+    <body>\n+        foo\n+    </body>\n+</html>", "file_path": "files/2018_6\\17", "file_language": "html", "file_name": "tests/end2end/data/issue4011.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/qutebrowser/qutebrowser/raw/4c9360237f186681b1e3f2a0f30c45161cf405c7/tests%2Fend2end%2Ffeatures%2Fhistory.feature", "code": "# vim: ft=cucumber fileencoding=utf-8 sts=4 sw=4 et:\n\nFeature: Page history\n\n    Make sure the global page history is saved correctly.\n\n    Background:\n        Given I run :history-clear --force\n\n    Scenario: Simple history saving\n        When I open data/numbers/1.txt\n        And I open data/numbers/2.txt\n        Then the history should contain:\n            http://localhost:(port)/data/numbers/1.txt\n            http://localhost:(port)/data/numbers/2.txt\n\n    Scenario: History item with title\n        When I open data/title.html\n        Then the history should contain:\n            http://localhost:(port)/data/title.html Test title\n\n    Scenario: History item with redirect\n        When I open redirect-to?url=data/title.html without waiting\n        And I wait until data/title.html is loaded\n        Then the history should contain:\n            r http://localhost:(port)/redirect-to?url=data/title.html Test title\n            http://localhost:(port)/data/title.html Test title\n\n    Scenario: History item with spaces in URL\n        When I open data/title with spaces.html\n        Then the history should contain:\n            http://localhost:(port)/data/title%20with%20spaces.html Test title\n\n    @unicode_locale\n    Scenario: History item with umlauts\n        When I open data/\u00e4\u00f6\u00fc.html\n        Then the history should contain:\n            http://localhost:(port)/data/%C3%A4%C3%B6%C3%BC.html Ch\u00e4sch\u00fcechli\n\n    @flaky @qtwebengine_todo: Error page message is not implemented\n    Scenario: History with an error\n        When I run :open file:///does/not/exist\n        And I wait for \"Error while loading file:///does/not/exist: Error opening /does/not/exist: *\" in the log\n        Then the history should contain:\n            file:///does/not/exist Error loading page: file:///does/not/exist\n\n    @qtwebengine_todo: Error page message is not implemented\n    Scenario: History with a 404\n        When I open 404 without waiting\n        And I wait for \"Error while loading http://localhost:*/404: NOT FOUND\" in the log\n        Then the history should contain:\n            http://localhost:(port)/404 Error loading page: http://localhost:(port)/404\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: History with invalid URL\n        When I run :tab-only\n        And I open data/javascript/window_open.html\n        And I run :click-element id open-invalid\n        Then \"Changing title for idx 1 to 'about:blank'\" should be logged\n\n    Scenario: History with data URL\n        When I open data/data_link.html\n        And I run :click-element id link\n        And I wait until data:;base64,cXV0ZWJyb3dzZXI= is loaded\n        Then the history should contain:\n            http://localhost:(port)/data/data_link.html data: link\n\n    Scenario: History with view-source URL\n        When I open data/title.html\n        And I run :view-source\n        And I wait for regex \"Changing title for idx \\d+ to 'view-source:(http://)?localhost:\\d+/data/title.html'\" in the log\n        Then the history should contain:\n            http://localhost:(port)/data/title.html Test title\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: Clearing history\n        When I run :tab-only\n        And I open data/title.html\n        And I run :history-clear --force\n        Then the history should be empty\n\n    Scenario: Clearing history with confirmation\n        When I open data/title.html\n        And I run :history-clear\n        And I wait for \"Asking question <* title='Clear all browsing history?'>, *\" in the log\n        And I run :prompt-accept yes\n        Then the history should be empty\n\n    Scenario: History with yanked URL and 'add to history' flag\n        When I open data/hints/html/simple.html\n        And I hint with args \"--add-history links yank\" and follow a\n        Then the history should contain:\n            http://localhost:(port)/data/hints/html/simple.html Simple link\n            http://localhost:(port)/data/hello.txt\n\n    Scenario: Listing history\n        When I open data/numbers/3.txt\n        And I open data/numbers/4.txt\n        And I open qute://history\n        Then the page should contain the plaintext \"3.txt\"\n        Then the page should contain the plaintext \"4.txt\"\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: Listing history with qute:history redirect\n        When I open data/numbers/3.txt\n        And I open data/numbers/4.txt\n        And I open qute:history without waiting\n        And I wait until qute://history is loaded\n        Then the page should contain the plaintext \"3.txt\"\n        Then the page should contain the plaintext \"4.txt\"\n\n    Scenario: XSS in :history\n        When I open data/issue4011.html\n        And I open qute://history\n        Then the javascript message \"XSS\" should not be logged\n", "code_before": "# vim: ft=cucumber fileencoding=utf-8 sts=4 sw=4 et:\n\nFeature: Page history\n\n    Make sure the global page history is saved correctly.\n\n    Background:\n        Given I run :history-clear --force\n\n    Scenario: Simple history saving\n        When I open data/numbers/1.txt\n        And I open data/numbers/2.txt\n        Then the history should contain:\n            http://localhost:(port)/data/numbers/1.txt\n            http://localhost:(port)/data/numbers/2.txt\n\n    Scenario: History item with title\n        When I open data/title.html\n        Then the history should contain:\n            http://localhost:(port)/data/title.html Test title\n\n    Scenario: History item with redirect\n        When I open redirect-to?url=data/title.html without waiting\n        And I wait until data/title.html is loaded\n        Then the history should contain:\n            r http://localhost:(port)/redirect-to?url=data/title.html Test title\n            http://localhost:(port)/data/title.html Test title\n\n    Scenario: History item with spaces in URL\n        When I open data/title with spaces.html\n        Then the history should contain:\n            http://localhost:(port)/data/title%20with%20spaces.html Test title\n\n    @unicode_locale\n    Scenario: History item with umlauts\n        When I open data/\u00e4\u00f6\u00fc.html\n        Then the history should contain:\n            http://localhost:(port)/data/%C3%A4%C3%B6%C3%BC.html Ch\u00e4sch\u00fcechli\n\n    @flaky @qtwebengine_todo: Error page message is not implemented\n    Scenario: History with an error\n        When I run :open file:///does/not/exist\n        And I wait for \"Error while loading file:///does/not/exist: Error opening /does/not/exist: *\" in the log\n        Then the history should contain:\n            file:///does/not/exist Error loading page: file:///does/not/exist\n\n    @qtwebengine_todo: Error page message is not implemented\n    Scenario: History with a 404\n        When I open 404 without waiting\n        And I wait for \"Error while loading http://localhost:*/404: NOT FOUND\" in the log\n        Then the history should contain:\n            http://localhost:(port)/404 Error loading page: http://localhost:(port)/404\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: History with invalid URL\n        When I run :tab-only\n        And I open data/javascript/window_open.html\n        And I run :click-element id open-invalid\n        Then \"Changing title for idx 1 to 'about:blank'\" should be logged\n\n    Scenario: History with data URL\n        When I open data/data_link.html\n        And I run :click-element id link\n        And I wait until data:;base64,cXV0ZWJyb3dzZXI= is loaded\n        Then the history should contain:\n            http://localhost:(port)/data/data_link.html data: link\n\n    Scenario: History with view-source URL\n        When I open data/title.html\n        And I run :view-source\n        And I wait for regex \"Changing title for idx \\d+ to 'view-source:(http://)?localhost:\\d+/data/title.html'\" in the log\n        Then the history should contain:\n            http://localhost:(port)/data/title.html Test title\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: Clearing history\n        When I run :tab-only\n        And I open data/title.html\n        And I run :history-clear --force\n        Then the history should be empty\n\n    Scenario: Clearing history with confirmation\n        When I open data/title.html\n        And I run :history-clear\n        And I wait for \"Asking question <* title='Clear all browsing history?'>, *\" in the log\n        And I run :prompt-accept yes\n        Then the history should be empty\n\n    Scenario: History with yanked URL and 'add to history' flag\n        When I open data/hints/html/simple.html\n        And I hint with args \"--add-history links yank\" and follow a\n        Then the history should contain:\n            http://localhost:(port)/data/hints/html/simple.html Simple link\n            http://localhost:(port)/data/hello.txt\n\n    Scenario: Listing history\n        When I open data/numbers/3.txt\n        And I open data/numbers/4.txt\n        And I open qute://history\n        Then the page should contain the plaintext \"3.txt\"\n        Then the page should contain the plaintext \"4.txt\"\n\n    # Hangs a lot on AppVeyor\n    @posix\n    Scenario: Listing history with qute:history redirect\n        When I open data/numbers/3.txt\n        And I open data/numbers/4.txt\n        And I open qute:history without waiting\n        And I wait until qute://history is loaded\n        Then the page should contain the plaintext \"3.txt\"\n        Then the page should contain the plaintext \"4.txt\"\n", "patch": "@@ -111,3 +111,8 @@ Feature: Page history\n         And I wait until qute://history is loaded\n         Then the page should contain the plaintext \"3.txt\"\n         Then the page should contain the plaintext \"4.txt\"\n+\n+    Scenario: XSS in :history\n+        When I open data/issue4011.html\n+        And I open qute://history\n+        Then the javascript message \"XSS\" should not be logged", "file_path": "files/2018_6\\18", "file_language": "feature", "file_name": "tests/end2end/features/history.feature", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
