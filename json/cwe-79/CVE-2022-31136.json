{"index": 8602, "cve_id": "CVE-2022-31136", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Bookwyrm is an open source social reading and reviewing program. Versions of Bookwyrm prior to 0.4.1 did not properly sanitize html being rendered to users. Unprivileged users are able to inject scripts into user profiles, book descriptions, and statuses. These vulnerabilities may be exploited as cross site scripting attacks on users viewing these fields. Users are advised to upgrade to version 0.4.1. There are no known workarounds for this issue.", "cvss": "6.1", "publish_date": "July 7, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "fe33fdcf564a6a5667aef75d5456bea08feab50d", "commit_message": "Merge pull request #2173 from bookwyrm-social/html-sanitizer\n\nHtml sanitizer", "commit_date": "2022-07-04T21:07:36Z", "project": "bookwyrm-social/bookwyrm", "url": "https://api.github.com/repos/bookwyrm-social/bookwyrm/commits/fe33fdcf564a6a5667aef75d5456bea08feab50d", "html_url": "https://github.com/bookwyrm-social/bookwyrm/commit/fe33fdcf564a6a5667aef75d5456bea08feab50d", "windows_before": [{"commit_id": "70beb24d95657d5186d73d71599088046dd5e891", "commit_date": "Mon Jul 4 13:34:09 2022 -0700", "commit_message": "Removed misleading test", "files_name": ["bookwyrm/tests/test_sanitize_html.py"]}, {"commit_id": "13376f89708fea095d97fdeed6950da701aa52d9", "commit_date": "Mon Jul 4 13:24:13 2022 -0700", "commit_message": "Catches missing reference to previous sanitizer", "files_name": ["bookwyrm/status.py"]}, {"commit_id": "62aa4bf869625186e0c7f24d259cfb2caac6f4d3", "commit_date": "Mon Jul 4 13:21:18 2022 -0700", "commit_message": "Tick version number", "files_name": ["bookwyrm/settings.py"]}, {"commit_id": "7f78140015d6e2c9bac86ba9931911009c407dba", "commit_date": "Mon Jul 4 13:14:22 2022 -0700", "commit_message": "Uses library for html cleanup", "files_name": ["bookwyrm/models/fields.py", "bookwyrm/sanitize_html.py", "bookwyrm/tests/test_sanitize_html.py", "bookwyrm/utils/sanitizer.py", "bookwyrm/views/status.py", "requirements.txt"]}, {"commit_id": "58b23a74da94795691c4e57df32b7095fb0dec8a", "commit_date": "Sun Jul 3 11:27:02 2022 -0700", "commit_message": "Merge pull request #2169 from bookwyrm-social/inventaire-import", "files_name": ["5d363da175faa8289d94e51778af281add117178 - Sun Jul 3 11:05:20 2022 -0700 : Handle getting edition data as dict or string", "bookwyrm/connectors/inventaire.py"]}, {"commit_id": "0b900dc1ac665b5aab57447cf4a7a239fb39922d", "commit_date": "Sun Jul 3 10:49:14 2022 -0700", "commit_message": "Merge pull request #2166 from bookwyrm-social/email-config-warning", "files_name": ["89165fd909ba4f4033f706569d77b2fd5348c8e8 - Sun Jul 3 08:28:24 2022 -0700 : Creates helper function for creating charts", "bookwyrm/views/admin/dashboard.py"]}, {"commit_id": "6e7c9b76c6971f2f13df47c173a79db8fb9c7a1f", "commit_date": "Sun Jul 3 06:49:42 2022 -0700", "commit_message": "Merge pull request #2167 from bookwyrm-social/follow-button", "files_name": ["d1180d4216d62df3fae336cc236b5f9d1b71ca59 - Sun Jul 3 17:24:33 2022 +1000 : linting fix for linting fix", "bookwyrm/static/js/guided_tour.js"]}, {"commit_id": "b82cf887e26d445de155bd5bad372b8e6d3c570e", "commit_date": "Sun Jul 3 17:14:13 2022 +1000", "commit_message": "linting fixes", "files_name": ["bookwyrm/migrations/0151_user_show_guided_tour.py", "bookwyrm/static/js/guided_tour.js", "bookwyrm/views/__init__.py", "bookwyrm/views/user.py"]}, {"commit_id": "f8e51b5826f50c46072a5704f4e4f7c5e17a092a", "commit_date": "Sun Jul 3 16:24:34 2022 +1000", "commit_message": "format guided tour js with prettier", "files_name": ["bookwyrm/static/js/guided_tour.js"]}, {"commit_id": "0e9dc66ffacd7ac0c2ff82070b9efb9a543fbe8f", "commit_date": "Sun Jul 3 16:18:50 2022 +1000", "commit_message": "Merge branch 'main' into tour", "files_name": ["04324c00b42b278aad882caa517186d9f2a49317 - Sun Jul 3 16:12:17 2022 +1000 : back button on all tour modals", "bookwyrm/templates/guided_tour/book.html", "bookwyrm/templates/guided_tour/user_groups.html", "bookwyrm/templates/guided_tour/user_profile.html"]}, {"commit_id": "39efb908700084498f6982eea86ac14820e9c86f", "commit_date": "Sun Jul 3 16:10:32 2022 +1000", "commit_message": "add noscript message for guided tour", "files_name": ["bookwyrm/templates/layout.html"]}, {"commit_id": "3f67bc3b614a5607a175d60fafd1574dcf2c88ea", "commit_date": "Sun Jul 3 15:57:10 2022 +1000", "commit_message": "standardise ids for tour anchors", "files_name": ["bookwyrm/templates/book/book.html", "bookwyrm/templates/feed/suggested_books.html", "bookwyrm/templates/groups/form.html", "bookwyrm/templates/groups/group.html", "bookwyrm/templates/groups/members.html", "bookwyrm/templates/guided_tour/book.html", "bookwyrm/templates/guided_tour/group.html", "bookwyrm/templates/guided_tour/home.html", "bookwyrm/templates/guided_tour/lists.html", "bookwyrm/templates/guided_tour/search.html", "bookwyrm/templates/guided_tour/user_books.html", "bookwyrm/templates/guided_tour/user_groups.html", "bookwyrm/templates/guided_tour/user_profile.html", "bookwyrm/templates/layout.html", "bookwyrm/templates/lists/form.html", "bookwyrm/templates/lists/lists.html", "bookwyrm/templates/search/book.html", "bookwyrm/templates/search/layout.html", "bookwyrm/templates/shelf/shelf.html", "bookwyrm/templates/snippets/privacy_select_no_followers.html", "bookwyrm/templates/snippets/shelve_button/shelve_button.html", "bookwyrm/templates/user/groups.html", "bookwyrm/templates/user/layout.html"]}, {"commit_id": "a8940b8e12118f6f60b1ac1c6cb373bf98faa241", "commit_date": "Sun Jul 3 14:48:23 2022 +1000", "commit_message": "Fix order of tour", "files_name": ["bookwyrm/templates/guided_tour/book.html", "bookwyrm/templates/guided_tour/group.html", "bookwyrm/templates/guided_tour/home.html", "bookwyrm/templates/guided_tour/lists.html", "bookwyrm/templates/guided_tour/search.html", "bookwyrm/templates/guided_tour/user_books.html", "bookwyrm/templates/guided_tour/user_groups.html", "bookwyrm/templates/guided_tour/user_profile.html"]}, {"commit_id": "e16506c1dfbc570172810c668f65716542106bf8", "commit_date": "Sat Jul 2 21:25:07 2022 -0700", "commit_message": "Fixes logic error in checking relationships", "files_name": ["bookwyrm/models/relationship.py", "bookwyrm/templatetags/interaction.py"]}, {"commit_id": "516c4a9790f1142d2baa4ef641f5a0fc680de07b", "commit_date": "Sat Jul 2 21:02:44 2022 -0700", "commit_message": "Add warning to dashboard if email sender looks misconfigured", "files_name": ["bookwyrm/templates/settings/dashboard/dashboard.html", "bookwyrm/views/admin/dashboard.py"]}, {"commit_id": "4ccbfb6b312ab42d0294f9072ff668c740aaf815", "commit_date": "Sat Jul 2 20:07:00 2022 -0700", "commit_message": "Merge pull request #2057 from bookwyrm-social/list-privacy", "files_name": ["6e70ceb094ed5ea0139b8ac7d689e476eca3350f - Sat Jul 2 19:43:59 2022 -0700 : More mocks", "bookwyrm/tests/lists_stream/test_signals.py", "bookwyrm/tests/lists_stream/test_stream.py", "bookwyrm/tests/lists_stream/test_tasks.py", "bookwyrm/tests/models/test_group.py"]}, {"commit_id": "06b4a55979879dc05eedf1ec5e9e0151c644292c", "commit_date": "Sun Jul 3 09:10:43 2022 +1000", "commit_message": "add lists to guided tour", "files_name": ["bookwyrm/templates/guided_tour/lists.html", "bookwyrm/templates/lists/form.html", "bookwyrm/templates/lists/lists.html"]}, {"commit_id": "46421f9672d73d8414d638cac391faa90b3c698a", "commit_date": "Sat Jul 2 13:48:15 2022 -0700", "commit_message": "Mocks for lists model", "files_name": ["bookwyrm/tests/models/test_list.py"]}, {"commit_id": "495bf203b073bc0bf8c7538ae74fc4ce239f1e74", "commit_date": "Sat Jul 2 13:45:53 2022 -0700", "commit_message": "Mocks inbox and search tests", "files_name": ["bookwyrm/tests/views/inbox/test_inbox_remove.py", "bookwyrm/tests/views/inbox/test_inbox_update.py", "bookwyrm/tests/views/test_search.py"]}, {"commit_id": "3ad0a5d07357d60597667605ec12e43f7606b90a", "commit_date": "Sat Jul 2 13:06:29 2022 -0700", "commit_message": "Use update_fields to limit `remove_list_task`s", "files_name": ["bookwyrm/lists_stream.py", "bookwyrm/models/list.py", "bookwyrm/tests/views/lists/test_curate.py", "bookwyrm/tests/views/lists/test_embed.py", "bookwyrm/tests/views/lists/test_list.py", "bookwyrm/tests/views/lists/test_list_item.py", "bookwyrm/tests/views/lists/test_lists.py"]}, {"commit_id": "13605b7d6af3c5d08c9fb9f003047f55be642552", "commit_date": "Sat Jul 2 12:17:14 2022 -0700", "commit_message": "Merge pull request #2164 from bookwyrm-social/federated-servers-admin", "files_name": ["aae02dff9a7fedf9155ed64679970075755040e6 - Sat Jul 2 12:16:39 2022 -0700 : Merge branch 'main' into list-privacy", "94a6675dc47843f7f7fe049a047d1dc2e9c42a59 - Sat Jul 2 12:07:22 2022 -0700 : Pylint fixes", "bookwyrm/importers/calibre_import.py", "bookwyrm/tests/test_postgres.py", "bookwyrm/utils/isni.py", "docker-compose.yml"]}, {"commit_id": "13e23a868d6180ca28cc02204627c8f89ad19fe2", "commit_date": "Sat Jul 2 11:07:11 2022 -0700", "commit_message": "Adds instance name filter to federated instance list view", "files_name": ["bookwyrm/templates/settings/federation/instance_filters.html", "bookwyrm/views/admin/federation.py"]}, {"commit_id": "43f3d698215f5f685bae3954964d82d0dc16b940", "commit_date": "Sat Jul 2 11:11:48 2022 -0700", "commit_message": "Merge pull request #2163 from bookwyrm-social/revert-2143-async_broadcast", "files_name": ["e0a67f5e18ec5efb594772aee4ff825e5c23044f - Sat Jul 2 11:06:48 2022 -0700 : Uses := syntax in user admin view", "bookwyrm/views/admin/user_admin.py"]}, {"commit_id": "cbb979242d70c363b58a6ab50163024566c01709", "commit_date": "Sat Jul 2 10:56:18 2022 -0700", "commit_message": "Revert \"Use async requests for broadcasting\"", "files_name": ["bookwyrm/models/activitypub_mixin.py"]}, {"commit_id": "f68c80dfff0ba6d0223c0d834849156b3f65ee36", "commit_date": "Sat Jul 2 10:50:17 2022 -0700", "commit_message": "Adds line length and import-error to .pylintrc", "files_name": [".pylintrc"]}, {"commit_id": "f5d6a18ce0acea6a6ece14e09096c110cd49da21", "commit_date": "Sat Jul 2 10:49:57 2022 -0700", "commit_message": "Alphabetize list of software options in federated instances list", "files_name": ["bookwyrm/views/admin/federation.py"]}, {"commit_id": "be76fe149477b5ccb9e2535b68dbecb62daab58b", "commit_date": "Sat Jul 2 10:23:02 2022 -0700", "commit_message": "Merge pull request #2143 from bookwyrm-social/async_broadcast", "files_name": ["827a63b4eb57d3b4ebde95bceef0c5024eacaadb - Sat Jul 2 18:46:16 2022 +1000 : add shelves to guided tour", "bookwyrm/templates/guided_tour/user_books.html"]}, {"commit_id": "d1079a1f7df18b6ca59c8cf4e148abc9e638d4f6", "commit_date": "Sat Jul 2 18:44:18 2022 +1000", "commit_message": "remove console log from guided_tour.js", "files_name": ["bookwyrm/static/js/guided_tour.js"]}, {"commit_id": "e7b0a84ded42f075a76c1a49b987c3722426caa8", "commit_date": "Thu Jun 30 11:47:23 2022 -0700", "commit_message": "Merge pull request #2142 from bookwyrm-social/load-data-duration", "files_name": ["4e2fcc552aea4fc41dd1d8f9cf5a319576bc1685 - Thu Jun 30 10:37:21 2022 -0700 : Merge pull request #2160 from bookwyrm-social/locales", "beb85ba94f25162634f784403fee05113f87d8bc - Thu Jun 30 10:23:25 2022 -0700 : Updates locales", "locale/de_DE/LC_MESSAGES/django.mo", "locale/de_DE/LC_MESSAGES/django.po", "locale/en_US/LC_MESSAGES/django.po", "locale/es_ES/LC_MESSAGES/django.mo", "locale/es_ES/LC_MESSAGES/django.po", "locale/fi_FI/LC_MESSAGES/django.mo", "locale/fi_FI/LC_MESSAGES/django.po", "locale/fr_FR/LC_MESSAGES/django.mo", "locale/fr_FR/LC_MESSAGES/django.po", "locale/gl_ES/LC_MESSAGES/django.mo", "locale/gl_ES/LC_MESSAGES/django.po", "locale/it_IT/LC_MESSAGES/django.mo", "locale/it_IT/LC_MESSAGES/django.po", "locale/lt_LT/LC_MESSAGES/django.mo", "locale/lt_LT/LC_MESSAGES/django.po", "locale/no_NO/LC_MESSAGES/django.mo", "locale/no_NO/LC_MESSAGES/django.po", "locale/pt_BR/LC_MESSAGES/django.mo", "locale/pt_BR/LC_MESSAGES/django.po", "locale/pt_PT/LC_MESSAGES/django.mo", "locale/pt_PT/LC_MESSAGES/django.po", "locale/ro_RO/LC_MESSAGES/django.mo", "locale/ro_RO/LC_MESSAGES/django.po", "locale/sv_SE/LC_MESSAGES/django.mo", "locale/sv_SE/LC_MESSAGES/django.po", "locale/zh_Hans/LC_MESSAGES/django.mo", "locale/zh_Hans/LC_MESSAGES/django.po", "locale/zh_Hant/LC_MESSAGES/django.mo", "locale/zh_Hant/LC_MESSAGES/django.po"]}, {"commit_id": "5f266c0cfdef914feb9828186d6406eb084981e9", "commit_date": "Thu Jun 30 09:52:06 2022 -0700", "commit_message": "Merge pull request #2159 from JamieSlome/main", "files_name": ["1609b9b74cbec5a7fc82fae0a5ffcc791bf0b80e - Thu Jun 30 05:46:41 2022 +0100 : Create SECURITY.md", "SECURITY.md"]}, {"commit_id": "bc4a1c6c41a60436c143ada8e8f38a9f51628240", "commit_date": "Sun Jun 19 14:06:36 2022 +1000", "commit_message": "Guided tour of book page", "files_name": ["bookwyrm/templates/book/book.html", "bookwyrm/templates/guided_tour/book.html"]}, {"commit_id": "ff37b77be91d2b7237020af87ee01acdebf1fabc", "commit_date": "Sun Jun 19 11:13:04 2022 +1000", "commit_message": "clean up search guided tour code", "files_name": ["bookwyrm/templates/guided_tour/search.html"]}], "windows_after": [{"commit_id": "a718a168a31a15c45197eba747e4a5b3ce746113", "commit_date": "Mon Jul 4 17:38:21 2022 -0700", "commit_message": "Merge branch 'main' into notifications", "files_name": ["f1f78c9cde91596a339d5200dda98eae8f69d4fa - Mon Jul 4 17:56:38 2022 -0700 : Merge pull request #2177 from bookwyrm-social/deleted-user-color", "c7ecbb2fdf253e69d3155f04a4f581aa81e68775 - Mon Jul 4 18:42:56 2022 -0700 : New migration file", "bookwyrm/migrations/0149_remove_notification_related_book.py", "bookwyrm/migrations/0151_auto_20220705_0049.py"]}, {"commit_id": "0cc2bc269e6304e2a468c4174dc7e4480875c8fc", "commit_date": "Mon Jul 4 18:51:07 2022 -0700", "commit_message": "Updates view", "files_name": ["bookwyrm/views/notifications.py"]}, {"commit_id": "a9a2da0957a4b5a4b193660f97e95a2099ea10e8", "commit_date": "Mon Jul 4 19:20:04 2022 -0700", "commit_message": "Keep status as a single field", "files_name": ["bookwyrm/migrations/0151_auto_20220705_0049.py", "bookwyrm/models/notification.py"]}, {"commit_id": "62e57ac9319aae8b1b412a97231f67b29641bc6e", "commit_date": "Mon Jul 4 19:48:10 2022 -0700", "commit_message": "Adds notify and unnotify helper class methods", "files_name": ["bookwyrm/models/notification.py"]}, {"commit_id": "dc8e61f316e13360edc5d3fbcf8a8ab9d84eb4bd", "commit_date": "Mon Jul 4 19:57:58 2022 -0700", "commit_message": "Updates reports created in automod task", "files_name": ["bookwyrm/models/antispam.py"]}, {"commit_id": "b193652a67924a7dc2213cd1a78d1bcdf5ea54d7", "commit_date": "Mon Jul 4 19:58:27 2022 -0700", "commit_message": "Python formatting", "files_name": ["bookwyrm/migrations/0151_auto_20220705_0049.py", "bookwyrm/models/notification.py"]}, {"commit_id": "72a8229a5ceddfa6f8f604419c7ff62527f36e7a", "commit_date": "Mon Jul 4 20:05:39 2022 -0700", "commit_message": "Updates group notifications", "files_name": ["bookwyrm/models/group.py"]}, {"commit_id": "03f5a3f2c1de6720f7cc4958b9a84caa0e90d865", "commit_date": "Mon Jul 4 20:19:18 2022 -0700", "commit_message": "Use enums for notification types", "files_name": ["bookwyrm/migrations/0152_remove_notification_notification_type_valid.py", "bookwyrm/models/notification.py"]}, {"commit_id": "aeefd5a3e9d2667de0579cf35758331a22dd3958", "commit_date": "Mon Jul 4 20:24:29 2022 -0700", "commit_message": "Use signal for creating group invite notification", "files_name": ["bookwyrm/models/group.py", "bookwyrm/models/notification.py"]}, {"commit_id": "9948dd235659ed82d1f6e930714f334392d84a2d", "commit_date": "Mon Jul 4 20:26:38 2022 -0700", "commit_message": "Use enums in more models", "files_name": ["bookwyrm/migrations/0152_remove_notification_notification_type_valid.py", "bookwyrm/models/antispam.py", "bookwyrm/models/list.py", "bookwyrm/models/relationship.py"]}, {"commit_id": "801ba03aaf2b25a87f12e4466cce89bac2897c9d", "commit_date": "Mon Jul 4 20:32:13 2022 -0700", "commit_message": "Keep group as a foreign key field", "files_name": ["bookwyrm/migrations/0151_auto_20220705_0049.py", "bookwyrm/models/notification.py"]}, {"commit_id": "971bed994257f6f5f8718e1ea7470e78ed72a44c", "commit_date": "Mon Jul 4 21:32:35 2022 -0700", "commit_message": "Notification field is read, not unread", "files_name": ["bookwyrm/models/antispam.py", "bookwyrm/models/notification.py"]}, {"commit_id": "f76d661e07a2e4378732786ba2283626c410b273", "commit_date": "Mon Jul 4 21:32:53 2022 -0700", "commit_message": "Updates templates for fav notifications", "files_name": ["bookwyrm/templates/notifications/items/fav.html", "bookwyrm/templates/notifications/items/layout.html", "bookwyrm/templates/notifications/items/report.html", "bookwyrm/views/notifications.py"]}, {"commit_id": "e2a50230c7a96361b6c46a5ab2af55a9d9fa71e8", "commit_date": "Mon Jul 4 21:44:55 2022 -0700", "commit_message": "Fixes setting acces level to \"user\"", "files_name": ["bookwyrm/forms/__init__.py", "bookwyrm/forms/groups.py", "bookwyrm/forms/user_admin.py", "bookwyrm/views/admin/user_admin.py"]}, {"commit_id": "97b53d49985156b6735322ef5116093e97145fe8", "commit_date": "Tue Jul 5 12:08:30 2022 -0700", "commit_message": "Merge pull request #2180 from bookwyrm-social/set-access-level-user", "files_name": ["fc375bbab4cb94498c63d211b28134df646e0d07 - Tue Jul 5 12:21:22 2022 -0700 : Finishes fav status translation strings", "bookwyrm/templates/notifications/items/fav.html"]}, {"commit_id": "ee71f5df21886ca3aa128a706f5a1c81c60aa7c9", "commit_date": "Tue Jul 5 12:28:48 2022 -0700", "commit_message": "Updates language on boosts", "files_name": ["bookwyrm/templates/notifications/items/boost.html", "bookwyrm/templates/notifications/items/fav.html"]}, {"commit_id": "9e94a13acf59e113148f9d20e8cfbe971353b123", "commit_date": "Tue Jul 5 12:37:35 2022 -0700", "commit_message": "Updates mention and reply notifications", "files_name": ["bookwyrm/templates/notifications/items/mention.html", "bookwyrm/templates/notifications/items/reply.html"]}, {"commit_id": "79f3382eceb4a34dfe75c1f5bc222d1db5a0983a", "commit_date": "Tue Jul 5 12:48:10 2022 -0700", "commit_message": "Updates reports notification", "files_name": ["bookwyrm/templates/notifications/items/report.html"]}, {"commit_id": "c65381adf9e687309934ec0e9604f806c66035f9", "commit_date": "Tue Jul 5 12:49:02 2022 -0700", "commit_message": "Comma format count of other users in a notification", "files_name": ["bookwyrm/templates/notifications/items/layout.html"]}, {"commit_id": "736d29ea201632bcd47bf57d40777499a369bff8", "commit_date": "Tue Jul 5 13:05:01 2022 -0700", "commit_message": "Updates group leave and remove notifications", "files_name": ["bookwyrm/models/notification.py", "bookwyrm/templates/notifications/items/accept.html", "bookwyrm/templates/notifications/items/invite.html", "bookwyrm/templates/notifications/items/leave.html", "bookwyrm/views/group.py"]}, {"commit_id": "41f42e33ed3d271b575866c805242855fcf9dc39", "commit_date": "Tue Jul 5 13:28:09 2022 -0700", "commit_message": "Moves list add notification into notification model", "files_name": ["bookwyrm/models/list.py", "bookwyrm/models/notification.py"]}, {"commit_id": "8cbf8f62c776663562d20c43391493774e26fd53", "commit_date": "Tue Jul 5 14:15:12 2022 -0700", "commit_message": "List add notifications", "files_name": ["bookwyrm/models/list.py", "bookwyrm/models/notification.py", "bookwyrm/templates/notifications/items/add.html"]}, {"commit_id": "7508ae9eaef9b2216606ef9beff8ffdd9c81c786", "commit_date": "Tue Jul 5 14:25:42 2022 -0700", "commit_message": "Separate vars for user count and display counts", "files_name": ["bookwyrm/templates/notifications/items/boost.html", "bookwyrm/templates/notifications/items/fav.html", "bookwyrm/templates/notifications/items/follow.html", "bookwyrm/templates/notifications/items/layout.html"]}, {"commit_id": "e54c563865ee1c326e0abe804559e9fffbcd0695", "commit_date": "Tue Jul 5 14:44:15 2022 -0700", "commit_message": "Consistent use of plurals", "files_name": ["bookwyrm/models/list.py", "bookwyrm/models/notification.py", "bookwyrm/templates/notifications/items/follow.html", "bookwyrm/templates/notifications/items/layout.html"]}, {"commit_id": "7fe722b595a76c411192d72cff82e6bd079fdbfe", "commit_date": "Tue Jul 5 15:03:20 2022 -0700", "commit_message": "Fixes follow request notifications", "files_name": ["bookwyrm/models/notification.py", "bookwyrm/models/relationship.py", "bookwyrm/templates/notifications/items/follow_request.html"]}, {"commit_id": "1e0055663bf6c704149fa29bae05d487f2808c93", "commit_date": "Tue Jul 5 22:45:57 2022 +0000", "commit_message": "Bump django from 3.2.13 to 3.2.14", "files_name": ["requirements.txt"]}, {"commit_id": "f7e02061cbeb7342d337dcd01482935c4e3b0b59", "commit_date": "Tue Jul 5 16:01:03 2022 -0700", "commit_message": "Merge pull request #2183 from bookwyrm-social/dependabot/pip/django-3.2.14", "files_name": ["37bcb031f73529502c2642a8decf0677a12fbafc - Tue Jul 5 16:03:25 2022 -0700 : Adds notification model unit tests", "bookwyrm/tests/models/test_list.py", "bookwyrm/tests/models/test_notification.py", "bookwyrm/tests/models/test_status_model.py"]}, {"commit_id": "24349b0a4cd047c1551981663013a8119d4ed423", "commit_date": "Tue Jul 5 16:20:27 2022 -0700", "commit_message": "Updates notification view tests", "files_name": ["bookwyrm/tests/views/test_interaction.py", "bookwyrm/tests/views/test_notifications.py"]}, {"commit_id": "0be4fec167642f5cf36e6e6b03138994c6a2c56a", "commit_date": "Tue Jul 5 16:51:03 2022 -0700", "commit_message": "Don't assume that link domains have a known user", "files_name": ["bookwyrm/templates/book/file_links/edit_links.html", "bookwyrm/templates/settings/link_domains/link_table.html"]}, {"commit_id": "4f386e8c4ed82ff3da0555e515808862af93dbab", "commit_date": "Tue Jul 5 17:19:03 2022 -0700", "commit_message": "Allow reports with no associated user", "files_name": ["bookwyrm/emailing.py", "bookwyrm/models/report.py", "bookwyrm/templates/email/moderation_report/html_content.html", "bookwyrm/templates/email/moderation_report/text_content.html", "bookwyrm/templates/settings/reports/report.html", "bookwyrm/templates/settings/reports/report_header.html", "bookwyrm/urls.py", "bookwyrm/views/report.py"]}, {"commit_id": "d4f8a5f4480e37746102fdbd683c4292e4cb6ace", "commit_date": "Tue Jul 5 17:43:03 2022 -0700", "commit_message": "Fixes links to report modals", "files_name": ["bookwyrm/templates/book/file_links/edit_links.html", "bookwyrm/templates/book/file_links/verification_modal.html"]}, {"commit_id": "cccf0ec3a0d93956acc83b03c4e505ae55fdbabe", "commit_date": "Tue Jul 5 17:51:12 2022 -0700", "commit_message": "Merge pull request #2184 from bookwyrm-social/userless-link-domain", "files_name": ["003ef65db56ab09bf25d917073a77f402fe907f2 - Tue Jul 5 18:01:10 2022 -0700 : Adds missing migration", "bookwyrm/migrations/0151_alter_report_user.py"]}, {"commit_id": "e8a570b687a131e8adecd3d886343cb75e1d2cda", "commit_date": "Tue Jul 5 18:09:45 2022 -0700", "commit_message": "Merge pull request #2185 from bookwyrm-social/userless-link-domain", "files_name": ["b61a4ab99492dc2cfe111111897b12cefa5a9284 - Wed Jul 6 08:51:35 2022 -0700 : Adds tests for unnotify", "bookwyrm/tests/models/test_notification.py"]}, {"commit_id": "afd3b27d78bfdecf54a95f8f5a17a84a546a6900", "commit_date": "Wed Jul 6 09:47:33 2022 -0700", "commit_message": "Adds coverage command to bw-dev", "files_name": ["bw-dev"]}, {"commit_id": "c48fbd8753ba3926a8f40187cd838055c5258e77", "commit_date": "Wed Jul 6 09:47:48 2022 -0700", "commit_message": "Separates reporting and report admins tests", "files_name": ["bookwyrm/tests/views/admin/test_reports.py", "bookwyrm/tests/views/test_report.py"]}, {"commit_id": "f4dd14acadbd3524c673d592eef0efbed0cc8fc1", "commit_date": "Wed Jul 6 10:05:22 2022 -0700", "commit_message": "Adds more webfinger tests for helper functions", "files_name": ["bookwyrm/tests/views/test_helpers.py", "bookwyrm/tests/views/test_report.py"]}, {"commit_id": "f5638c1e44839d0d593d98338157eeefd42f0e96", "commit_date": "Wed Jul 6 10:05:55 2022 -0700", "commit_message": "Removed unused helper function", "files_name": ["bookwyrm/views/helpers.py"]}, {"commit_id": "87434fbb9df733cc9552402cfedc242c4c950cdd", "commit_date": "Wed Jul 6 10:38:22 2022 -0700", "commit_message": "Adds a couple more edit book views tests", "files_name": ["bookwyrm/tests/views/books/test_edit_book.py"]}, {"commit_id": "574c1db7325e38cd693046bcef4ef47e2d0d2753", "commit_date": "Wed Jul 6 10:50:50 2022 -0700", "commit_message": "Adds more templatetag tests", "files_name": ["bookwyrm/templatetags/utilities.py", "bookwyrm/tests/templatetags/test_utilities.py"]}, {"commit_id": "7a9d320afd21fdb62693c2a11938341b1a298ab4", "commit_date": "Wed Jul 6 10:52:50 2022 -0700", "commit_message": "Expands automod view test", "files_name": ["bookwyrm/tests/views/admin/test_automod.py", "bookwyrm/views/admin/automod.py"]}, {"commit_id": "9c21d1c06fb692d7a23389ed9e3137f5a1123a19", "commit_date": "Wed Jul 6 11:15:05 2022 -0700", "commit_message": "Adds more automod tests", "files_name": ["bookwyrm/tests/views/admin/test_automod.py"]}, {"commit_id": "b2a8a0409238b6e109aaa8b4d46f06b7c0b55772", "commit_date": "Wed Jul 6 11:24:04 2022 -0700", "commit_message": "Removes unnecessary imports", "files_name": ["bookwyrm/tests/views/admin/test_reports.py"]}, {"commit_id": "476a7b73a2124668b9cf9f3fe2da3bd6dc3cb195", "commit_date": "Wed Jul 6 11:32:49 2022 -0700", "commit_message": "Merge pull request #2186 from bookwyrm-social/test-coverage", "files_name": ["9fceeb3eda0145ae85ad4ff079a9ebb3faed2c86 - Wed Jul 6 12:17:24 2022 -0700 : Adds another missing migration", "bookwyrm/migrations/0152_alter_report_user.py"]}, {"commit_id": "079f6d304e0d6ad89da4be94a6f48d79f6c25004", "commit_date": "Wed Jul 6 12:22:07 2022 -0700", "commit_message": "Python formatting", "files_name": ["bookwyrm/migrations/0152_alter_report_user.py"]}, {"commit_id": "d09aa2ded299818dff201b2e742984f8f533ebd8", "commit_date": "Wed Jul 6 12:33:07 2022 -0700", "commit_message": "Merge pull request #2187 from bookwyrm-social/missing-migration", "files_name": ["2cda9d556740296c6382ce3f7360bbc3185e0d3c - Wed Jul 6 14:27:51 2022 -0700 : Test leaving a group (as opposed to being removed)", "bookwyrm/tests/views/test_group.py"]}, {"commit_id": "dda61263295dcafb3039449ca061acad53bf0a85", "commit_date": "Wed Jul 6 14:31:53 2022 -0700", "commit_message": "Fixes typo in group notification", "files_name": ["bookwyrm/tests/views/test_group.py", "bookwyrm/views/group.py"]}], "parents": [{"commit_id_before": "58b23a74da94795691c4e57df32b7095fb0dec8a", "url_before": "https://api.github.com/repos/bookwyrm-social/bookwyrm/commits/58b23a74da94795691c4e57df32b7095fb0dec8a", "html_url_before": "https://github.com/bookwyrm-social/bookwyrm/commit/58b23a74da94795691c4e57df32b7095fb0dec8a"}, {"commit_id_before": "9d9b7f366a2b6b711c5b6f3609286a26f98486de", "url_before": "https://api.github.com/repos/bookwyrm-social/bookwyrm/commits/9d9b7f366a2b6b711c5b6f3609286a26f98486de", "html_url_before": "https://github.com/bookwyrm-social/bookwyrm/commit/9d9b7f366a2b6b711c5b6f3609286a26f98486de"}], "details": [{"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Fmodels%2Ffields.py", "code": "\"\"\" activitypub-aware django model fields \"\"\"\nfrom dataclasses import MISSING\nimport re\nfrom uuid import uuid4\nfrom urllib.parse import urljoin\n\nimport dateutil.parser\nfrom dateutil.parser import ParserError\nfrom django.contrib.postgres.fields import ArrayField as DjangoArrayField\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.forms import ClearableFileInput, ImageField as DjangoImageField\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom django.utils.encoding import filepath_to_uri\n\nfrom bookwyrm import activitypub\nfrom bookwyrm.connectors import get_image\nfrom bookwyrm.utils.sanitizer import clean\nfrom bookwyrm.settings import MEDIA_FULL_URL\n\n\ndef validate_remote_id(value):\n    \"\"\"make sure the remote_id looks like a url\"\"\"\n    if not value or not re.match(r\"^http.?:\\/\\/[^\\s]+$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid remote_id\"),\n            params={\"value\": value},\n        )\n\n\ndef validate_localname(value):\n    \"\"\"make sure localnames look okay\"\"\"\n    if not re.match(r\"^[A-Za-z\\-_\\.0-9]+$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid username\"),\n            params={\"value\": value},\n        )\n\n\ndef validate_username(value):\n    \"\"\"make sure usernames look okay\"\"\"\n    if not re.match(r\"^[A-Za-z\\-_\\.0-9]+@[A-Za-z\\-_\\.0-9]+\\.[a-z]{2,}$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid username\"),\n            params={\"value\": value},\n        )\n\n\nclass ActivitypubFieldMixin:\n    \"\"\"make a database field serializable\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        activitypub_field=None,\n        activitypub_wrapper=None,\n        deduplication_field=False,\n        **kwargs,\n    ):\n        self.deduplication_field = deduplication_field\n        if activitypub_wrapper:\n            self.activitypub_wrapper = activitypub_field\n            self.activitypub_field = activitypub_wrapper\n        else:\n            self.activitypub_field = activitypub_field\n        super().__init__(*args, **kwargs)\n\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        \"\"\"helper function for assinging a value to the field. Returns if changed\"\"\"\n        try:\n            value = getattr(data, self.get_activitypub_field())\n        except AttributeError:\n            # masssively hack-y workaround for boosts\n            if self.get_activitypub_field() != \"attributedTo\":\n                raise\n            value = getattr(data, \"actor\")\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING or formatted == {}:\n            return False\n\n        current_value = (\n            getattr(instance, self.name) if hasattr(instance, self.name) else None\n        )\n        # if we're not in overwrite mode, only continue updating the field if its unset\n        if current_value and not overwrite:\n            return False\n\n        # the field is unchanged\n        if current_value == formatted:\n            return False\n\n        setattr(instance, self.name, formatted)\n        return True\n\n    def set_activity_from_field(self, activity, instance):\n        \"\"\"update the json object\"\"\"\n        value = getattr(instance, self.name)\n        formatted = self.field_to_activity(value)\n        if formatted is None:\n            return\n\n        key = self.get_activitypub_field()\n        # TODO: surely there's a better way\n        if instance.__class__.__name__ == \"Boost\" and key == \"attributedTo\":\n            key = \"actor\"\n        if isinstance(activity.get(key), list):\n            activity[key] += formatted\n        else:\n            activity[key] = formatted\n\n    def field_to_activity(self, value):\n        \"\"\"formatter to convert a model value into activitypub\"\"\"\n        if hasattr(self, \"activitypub_wrapper\"):\n            return {self.activitypub_wrapper: value}\n        return value\n\n    def field_from_activity(self, value):\n        \"\"\"formatter to convert activitypub into a model value\"\"\"\n        if value and hasattr(self, \"activitypub_wrapper\"):\n            value = value.get(self.activitypub_wrapper)\n        return value\n\n    def get_activitypub_field(self):\n        \"\"\"model_field_name to activitypubFieldName\"\"\"\n        if self.activitypub_field:\n            return self.activitypub_field\n        name = self.name.rsplit(\".\", maxsplit=1)[-1]\n        components = name.split(\"_\")\n        return components[0] + \"\".join(x.title() for x in components[1:])\n\n\nclass ActivitypubRelatedFieldMixin(ActivitypubFieldMixin):\n    \"\"\"default (de)serialization for foreign key and one to one\"\"\"\n\n    def __init__(self, *args, load_remote=True, **kwargs):\n        self.load_remote = load_remote\n        super().__init__(*args, **kwargs)\n\n    def field_from_activity(self, value):\n        if not value:\n            return None\n\n        related_model = self.related_model\n        if hasattr(value, \"id\") and value.id:\n            if not self.load_remote:\n                # only look in the local database\n                return related_model.find_existing(value.serialize())\n            # this is an activitypub object, which we can deserialize\n            return value.to_model(model=related_model)\n        try:\n            # make sure the value looks like a remote id\n            validate_remote_id(value)\n        except ValidationError:\n            # we don't know what this is, ignore it\n            return None\n        # gets or creates the model field from the remote id\n        if not self.load_remote:\n            # only look in the local database\n            return related_model.find_existing_by_remote_id(value)\n        return activitypub.resolve_remote_id(value, model=related_model)\n\n\nclass RemoteIdField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"a url that serves as a unique identifier\"\"\"\n\n    def __init__(self, *args, max_length=255, validators=None, **kwargs):\n        validators = validators or [validate_remote_id]\n        super().__init__(*args, max_length=max_length, validators=validators, **kwargs)\n        # for this field, the default is true. false everywhere else.\n        self.deduplication_field = kwargs.get(\"deduplication_field\", True)\n\n\nclass UsernameField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"activitypub-aware username field\"\"\"\n\n    def __init__(self, activitypub_field=\"preferredUsername\", **kwargs):\n        self.activitypub_field = activitypub_field\n        # I don't totally know why pylint is mad at this, but it makes it work\n        super(ActivitypubFieldMixin, self).__init__(  # pylint: disable=bad-super-call\n            _(\"username\"),\n            max_length=150,\n            unique=True,\n            validators=[validate_username],\n            error_messages={\n                \"unique\": _(\"A user with that username already exists.\"),\n            },\n        )\n\n    def deconstruct(self):\n        \"\"\"implementation of models.Field deconstruct\"\"\"\n        name, path, args, kwargs = super().deconstruct()\n        del kwargs[\"verbose_name\"]\n        del kwargs[\"max_length\"]\n        del kwargs[\"unique\"]\n        del kwargs[\"validators\"]\n        del kwargs[\"error_messages\"]\n        return name, path, args, kwargs\n\n    def field_to_activity(self, value):\n        return value.split(\"@\")[0]\n\n\nPrivacyLevels = [\n    (\"public\", _(\"Public\")),\n    (\"unlisted\", _(\"Unlisted\")),\n    (\"followers\", _(\"Followers\")),\n    (\"direct\", _(\"Private\")),\n]\n\n\nclass PrivacyField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"this maps to two differente activitypub fields\"\"\"\n\n    public = \"https://www.w3.org/ns/activitystreams#Public\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, max_length=255, choices=PrivacyLevels, default=\"public\")\n\n    # pylint: disable=invalid-name\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        if not overwrite:\n            return False\n\n        original = getattr(instance, self.name)\n        to = data.to\n        cc = data.cc\n\n        # we need to figure out who this is to get their followers link\n        for field in [\"attributedTo\", \"owner\", \"actor\"]:\n            if hasattr(data, field):\n                user_field = field\n                break\n        if not user_field:\n            raise ValidationError(\"No user field found for privacy\", data)\n        user = activitypub.resolve_remote_id(getattr(data, user_field), model=\"User\")\n\n        if to == [self.public]:\n            setattr(instance, self.name, \"public\")\n        elif to == [user.followers_url]:\n            setattr(instance, self.name, \"followers\")\n        elif cc == []:\n            setattr(instance, self.name, \"direct\")\n        elif self.public in cc:\n            setattr(instance, self.name, \"unlisted\")\n        else:\n            setattr(instance, self.name, \"followers\")\n        return original == getattr(instance, self.name)\n\n    def set_activity_from_field(self, activity, instance):\n        # explicitly to anyone mentioned (statuses only)\n        mentions = []\n        if hasattr(instance, \"mention_users\"):\n            mentions = [u.remote_id for u in instance.mention_users.all()]\n        # this is a link to the followers list\n        # pylint: disable=protected-access\n        followers = instance.user.followers_url\n        if instance.privacy == \"public\":\n            activity[\"to\"] = [self.public]\n            activity[\"cc\"] = [followers] + mentions\n        elif instance.privacy == \"unlisted\":\n            activity[\"to\"] = [followers]\n            activity[\"cc\"] = [self.public] + mentions\n        elif instance.privacy == \"followers\":\n            activity[\"to\"] = [followers]\n            activity[\"cc\"] = mentions\n        if instance.privacy == \"direct\":\n            activity[\"to\"] = mentions\n            activity[\"cc\"] = []\n\n\nclass ForeignKey(ActivitypubRelatedFieldMixin, models.ForeignKey):\n    \"\"\"activitypub-aware foreign key field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.remote_id\n\n\nclass OneToOneField(ActivitypubRelatedFieldMixin, models.OneToOneField):\n    \"\"\"activitypub-aware foreign key field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.to_activity()\n\n\nclass ManyToManyField(ActivitypubFieldMixin, models.ManyToManyField):\n    \"\"\"activitypub-aware many to many field\"\"\"\n\n    def __init__(self, *args, link_only=False, **kwargs):\n        self.link_only = link_only\n        super().__init__(*args, **kwargs)\n\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        \"\"\"helper function for assigning a value to the field\"\"\"\n        if not overwrite and getattr(instance, self.name).exists():\n            return False\n\n        value = getattr(data, self.get_activitypub_field())\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING:\n            return False\n        getattr(instance, self.name).set(formatted)\n        instance.save(broadcast=False)\n        return True\n\n    def field_to_activity(self, value):\n        if self.link_only:\n            return f\"{value.instance.remote_id}/{self.name}\"\n        return [i.remote_id for i in value.all()]\n\n    def field_from_activity(self, value):\n        if value is None or value is MISSING:\n            return None\n        if not isinstance(value, list):\n            # If this is a link, we currently aren't doing anything with it\n            return None\n        items = []\n        for remote_id in value:\n            try:\n                validate_remote_id(remote_id)\n            except ValidationError:\n                continue\n            items.append(\n                activitypub.resolve_remote_id(remote_id, model=self.related_model)\n            )\n        return items\n\n\nclass TagField(ManyToManyField):\n    \"\"\"special case of many to many that uses Tags\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.activitypub_field = \"tag\"\n\n    def field_to_activity(self, value):\n        tags = []\n        for item in value.all():\n            activity_type = item.__class__.__name__\n            if activity_type == \"User\":\n                activity_type = \"Mention\"\n            tags.append(\n                activitypub.Link(\n                    href=item.remote_id,\n                    name=getattr(item, item.name_field),\n                    type=activity_type,\n                )\n            )\n        return tags\n\n    def field_from_activity(self, value):\n        if not isinstance(value, list):\n            return None\n        items = []\n        for link_json in value:\n            link = activitypub.Link(**link_json)\n            tag_type = link.type if link.type != \"Mention\" else \"Person\"\n            if tag_type == \"Book\":\n                tag_type = \"Edition\"\n            if tag_type != self.related_model.activity_serializer.type:\n                # tags can contain multiple types\n                continue\n            items.append(\n                activitypub.resolve_remote_id(link.href, model=self.related_model)\n            )\n        return items\n\n\nclass ClearableFileInputWithWarning(ClearableFileInput):\n    \"\"\"max file size warning\"\"\"\n\n    template_name = \"widgets/clearable_file_input_with_warning.html\"\n\n\nclass CustomImageField(DjangoImageField):\n    \"\"\"overwrites image field for form\"\"\"\n\n    widget = ClearableFileInputWithWarning\n\n\nclass ImageField(ActivitypubFieldMixin, models.ImageField):\n    \"\"\"activitypub-aware image field\"\"\"\n\n    def __init__(self, *args, alt_field=None, **kwargs):\n        self.alt_field = alt_field\n        super().__init__(*args, **kwargs)\n\n    # pylint: disable=arguments-differ,arguments-renamed\n    def set_field_from_activity(self, instance, data, save=True, overwrite=True):\n        \"\"\"helper function for assinging a value to the field\"\"\"\n        value = getattr(data, self.get_activitypub_field())\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING:\n            return False\n\n        if (\n            not overwrite\n            and hasattr(instance, self.name)\n            and getattr(instance, self.name)\n        ):\n            return False\n\n        getattr(instance, self.name).save(*formatted, save=save)\n        return True\n\n    def set_activity_from_field(self, activity, instance):\n        value = getattr(instance, self.name)\n        if value is None:\n            return\n        alt_text = getattr(instance, self.alt_field)\n        formatted = self.field_to_activity(value, alt_text)\n\n        key = self.get_activitypub_field()\n        activity[key] = formatted\n\n    def field_to_activity(self, value, alt=None):\n        url = get_absolute_url(value)\n\n        if not url:\n            return None\n\n        return activitypub.Document(url=url, name=alt)\n\n    def field_from_activity(self, value):\n        image_slug = value\n        # when it's an inline image (User avatar/icon, Book cover), it's a json\n        # blob, but when it's an attached image, it's just a url\n        if hasattr(image_slug, \"url\"):\n            url = image_slug.url\n        elif isinstance(image_slug, str):\n            url = image_slug\n        else:\n            return None\n\n        try:\n            validate_remote_id(url)\n        except ValidationError:\n            return None\n\n        image_content, extension = get_image(url)\n        if not image_content:\n            return None\n\n        image_name = f\"{uuid4()}.{extension}\"\n        return [image_name, image_content]\n\n    def formfield(self, **kwargs):\n        \"\"\"special case for forms\"\"\"\n        return super().formfield(\n            **{\n                \"form_class\": CustomImageField,\n                **kwargs,\n            }\n        )\n\n\ndef get_absolute_url(value):\n    \"\"\"returns an absolute URL for the image\"\"\"\n    name = getattr(value, \"name\")\n    if not name:\n        return None\n\n    url = filepath_to_uri(name)\n    if url is not None:\n        url = url.lstrip(\"/\")\n    url = urljoin(MEDIA_FULL_URL, url)\n\n    return url\n\n\nclass DateTimeField(ActivitypubFieldMixin, models.DateTimeField):\n    \"\"\"activitypub-aware datetime field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.isoformat()\n\n    def field_from_activity(self, value):\n        try:\n            date_value = dateutil.parser.parse(value)\n            try:\n                return timezone.make_aware(date_value)\n            except ValueError:\n                return date_value\n        except (ParserError, TypeError):\n            return None\n\n\nclass HtmlField(ActivitypubFieldMixin, models.TextField):\n    \"\"\"a text field for storing html\"\"\"\n\n    def field_from_activity(self, value):\n        if not value or value == MISSING:\n            return None\n        return clean(value)\n\n\nclass ArrayField(ActivitypubFieldMixin, DjangoArrayField):\n    \"\"\"activitypub-aware array field\"\"\"\n\n    def field_to_activity(self, value):\n        return [str(i) for i in value]\n\n\nclass CharField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"activitypub-aware char field\"\"\"\n\n\nclass URLField(ActivitypubFieldMixin, models.URLField):\n    \"\"\"activitypub-aware url field\"\"\"\n\n\nclass TextField(ActivitypubFieldMixin, models.TextField):\n    \"\"\"activitypub-aware text field\"\"\"\n\n\nclass BooleanField(ActivitypubFieldMixin, models.BooleanField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n\nclass IntegerField(ActivitypubFieldMixin, models.IntegerField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n\nclass DecimalField(ActivitypubFieldMixin, models.DecimalField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return float(value)\n", "code_before": "\"\"\" activitypub-aware django model fields \"\"\"\nfrom dataclasses import MISSING\nimport re\nfrom uuid import uuid4\nfrom urllib.parse import urljoin\n\nimport dateutil.parser\nfrom dateutil.parser import ParserError\nfrom django.contrib.postgres.fields import ArrayField as DjangoArrayField\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.forms import ClearableFileInput, ImageField as DjangoImageField\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom django.utils.encoding import filepath_to_uri\n\nfrom bookwyrm import activitypub\nfrom bookwyrm.connectors import get_image\nfrom bookwyrm.utils.sanitizer import clean\nfrom bookwyrm.settings import MEDIA_FULL_URL\n\n\ndef validate_remote_id(value):\n    \"\"\"make sure the remote_id looks like a url\"\"\"\n    if not value or not re.match(r\"^http.?:\\/\\/[^\\s]+$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid remote_id\"),\n            params={\"value\": value},\n        )\n\n\ndef validate_localname(value):\n    \"\"\"make sure localnames look okay\"\"\"\n    if not re.match(r\"^[A-Za-z\\-_\\.0-9]+$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid username\"),\n            params={\"value\": value},\n        )\n\n\ndef validate_username(value):\n    \"\"\"make sure usernames look okay\"\"\"\n    if not re.match(r\"^[A-Za-z\\-_\\.0-9]+@[A-Za-z\\-_\\.0-9]+\\.[a-z]{2,}$\", value):\n        raise ValidationError(\n            _(\"%(value)s is not a valid username\"),\n            params={\"value\": value},\n        )\n\n\nclass ActivitypubFieldMixin:\n    \"\"\"make a database field serializable\"\"\"\n\n    def __init__(\n        self,\n        *args,\n        activitypub_field=None,\n        activitypub_wrapper=None,\n        deduplication_field=False,\n        **kwargs,\n    ):\n        self.deduplication_field = deduplication_field\n        if activitypub_wrapper:\n            self.activitypub_wrapper = activitypub_field\n            self.activitypub_field = activitypub_wrapper\n        else:\n            self.activitypub_field = activitypub_field\n        super().__init__(*args, **kwargs)\n\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        \"\"\"helper function for assinging a value to the field. Returns if changed\"\"\"\n        try:\n            value = getattr(data, self.get_activitypub_field())\n        except AttributeError:\n            # masssively hack-y workaround for boosts\n            if self.get_activitypub_field() != \"attributedTo\":\n                raise\n            value = getattr(data, \"actor\")\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING or formatted == {}:\n            return False\n\n        current_value = (\n            getattr(instance, self.name) if hasattr(instance, self.name) else None\n        )\n        # if we're not in overwrite mode, only continue updating the field if its unset\n        if current_value and not overwrite:\n            return False\n\n        # the field is unchanged\n        if current_value == formatted:\n            return False\n\n        setattr(instance, self.name, formatted)\n        return True\n\n    def set_activity_from_field(self, activity, instance):\n        \"\"\"update the json object\"\"\"\n        value = getattr(instance, self.name)\n        formatted = self.field_to_activity(value)\n        if formatted is None:\n            return\n\n        key = self.get_activitypub_field()\n        # TODO: surely there's a better way\n        if instance.__class__.__name__ == \"Boost\" and key == \"attributedTo\":\n            key = \"actor\"\n        if isinstance(activity.get(key), list):\n            activity[key] += formatted\n        else:\n            activity[key] = formatted\n\n    def field_to_activity(self, value):\n        \"\"\"formatter to convert a model value into activitypub\"\"\"\n        if hasattr(self, \"activitypub_wrapper\"):\n            return {self.activitypub_wrapper: value}\n        return value\n\n    def field_from_activity(self, value):\n        \"\"\"formatter to convert activitypub into a model value\"\"\"\n        if value and hasattr(self, \"activitypub_wrapper\"):\n            value = value.get(self.activitypub_wrapper)\n        return value\n\n    def get_activitypub_field(self):\n        \"\"\"model_field_name to activitypubFieldName\"\"\"\n        if self.activitypub_field:\n            return self.activitypub_field\n        name = self.name.rsplit(\".\", maxsplit=1)[-1]\n        components = name.split(\"_\")\n        return components[0] + \"\".join(x.title() for x in components[1:])\n\n\nclass ActivitypubRelatedFieldMixin(ActivitypubFieldMixin):\n    \"\"\"default (de)serialization for foreign key and one to one\"\"\"\n\n    def __init__(self, *args, load_remote=True, **kwargs):\n        self.load_remote = load_remote\n        super().__init__(*args, **kwargs)\n\n    def field_from_activity(self, value):\n        if not value:\n            return None\n\n        related_model = self.related_model\n        if hasattr(value, \"id\") and value.id:\n            if not self.load_remote:\n                # only look in the local database\n                return related_model.find_existing(value.serialize())\n            # this is an activitypub object, which we can deserialize\n            return value.to_model(model=related_model)\n        try:\n            # make sure the value looks like a remote id\n            validate_remote_id(value)\n        except ValidationError:\n            # we don't know what this is, ignore it\n            return None\n        # gets or creates the model field from the remote id\n        if not self.load_remote:\n            # only look in the local database\n            return related_model.find_existing_by_remote_id(value)\n        return activitypub.resolve_remote_id(value, model=related_model)\n\n\nclass RemoteIdField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"a url that serves as a unique identifier\"\"\"\n\n    def __init__(self, *args, max_length=255, validators=None, **kwargs):\n        validators = validators or [validate_remote_id]\n        super().__init__(*args, max_length=max_length, validators=validators, **kwargs)\n        # for this field, the default is true. false everywhere else.\n        self.deduplication_field = kwargs.get(\"deduplication_field\", True)\n\n\nclass UsernameField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"activitypub-aware username field\"\"\"\n\n    def __init__(self, activitypub_field=\"preferredUsername\", **kwargs):\n        self.activitypub_field = activitypub_field\n        # I don't totally know why pylint is mad at this, but it makes it work\n        super(ActivitypubFieldMixin, self).__init__(  # pylint: disable=bad-super-call\n            _(\"username\"),\n            max_length=150,\n            unique=True,\n            validators=[validate_username],\n            error_messages={\n                \"unique\": _(\"A user with that username already exists.\"),\n            },\n        )\n\n    def deconstruct(self):\n        \"\"\"implementation of models.Field deconstruct\"\"\"\n        name, path, args, kwargs = super().deconstruct()\n        del kwargs[\"verbose_name\"]\n        del kwargs[\"max_length\"]\n        del kwargs[\"unique\"]\n        del kwargs[\"validators\"]\n        del kwargs[\"error_messages\"]\n        return name, path, args, kwargs\n\n    def field_to_activity(self, value):\n        return value.split(\"@\")[0]\n\n\nPrivacyLevels = [\n    (\"public\", _(\"Public\")),\n    (\"unlisted\", _(\"Unlisted\")),\n    (\"followers\", _(\"Followers\")),\n    (\"direct\", _(\"Private\")),\n]\n\n\nclass PrivacyField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"this maps to two differente activitypub fields\"\"\"\n\n    public = \"https://www.w3.org/ns/activitystreams#Public\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, max_length=255, choices=PrivacyLevels, default=\"public\")\n\n    # pylint: disable=invalid-name\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        if not overwrite:\n            return False\n\n        original = getattr(instance, self.name)\n        to = data.to\n        cc = data.cc\n\n        # we need to figure out who this is to get their followers link\n        for field in [\"attributedTo\", \"owner\", \"actor\"]:\n            if hasattr(data, field):\n                user_field = field\n                break\n        if not user_field:\n            raise ValidationError(\"No user field found for privacy\", data)\n        user = activitypub.resolve_remote_id(getattr(data, user_field), model=\"User\")\n\n        if to == [self.public]:\n            setattr(instance, self.name, \"public\")\n        elif to == [user.followers_url]:\n            setattr(instance, self.name, \"followers\")\n        elif cc == []:\n            setattr(instance, self.name, \"direct\")\n        elif self.public in cc:\n            setattr(instance, self.name, \"unlisted\")\n        else:\n            setattr(instance, self.name, \"followers\")\n        return original == getattr(instance, self.name)\n\n    def set_activity_from_field(self, activity, instance):\n        # explicitly to anyone mentioned (statuses only)\n        mentions = []\n        if hasattr(instance, \"mention_users\"):\n            mentions = [u.remote_id for u in instance.mention_users.all()]\n        # this is a link to the followers list\n        # pylint: disable=protected-access\n        followers = instance.user.followers_url\n        if instance.privacy == \"public\":\n            activity[\"to\"] = [self.public]\n            activity[\"cc\"] = [followers] + mentions\n        elif instance.privacy == \"unlisted\":\n            activity[\"to\"] = [followers]\n            activity[\"cc\"] = [self.public] + mentions\n        elif instance.privacy == \"followers\":\n            activity[\"to\"] = [followers]\n            activity[\"cc\"] = mentions\n        if instance.privacy == \"direct\":\n            activity[\"to\"] = mentions\n            activity[\"cc\"] = []\n\n\nclass ForeignKey(ActivitypubRelatedFieldMixin, models.ForeignKey):\n    \"\"\"activitypub-aware foreign key field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.remote_id\n\n\nclass OneToOneField(ActivitypubRelatedFieldMixin, models.OneToOneField):\n    \"\"\"activitypub-aware foreign key field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.to_activity()\n\n\nclass ManyToManyField(ActivitypubFieldMixin, models.ManyToManyField):\n    \"\"\"activitypub-aware many to many field\"\"\"\n\n    def __init__(self, *args, link_only=False, **kwargs):\n        self.link_only = link_only\n        super().__init__(*args, **kwargs)\n\n    def set_field_from_activity(self, instance, data, overwrite=True):\n        \"\"\"helper function for assigning a value to the field\"\"\"\n        if not overwrite and getattr(instance, self.name).exists():\n            return False\n\n        value = getattr(data, self.get_activitypub_field())\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING:\n            return False\n        getattr(instance, self.name).set(formatted)\n        instance.save(broadcast=False)\n        return True\n\n    def field_to_activity(self, value):\n        if self.link_only:\n            return f\"{value.instance.remote_id}/{self.name}\"\n        return [i.remote_id for i in value.all()]\n\n    def field_from_activity(self, value):\n        if value is None or value is MISSING:\n            return None\n        if not isinstance(value, list):\n            # If this is a link, we currently aren't doing anything with it\n            return None\n        items = []\n        for remote_id in value:\n            try:\n                validate_remote_id(remote_id)\n            except ValidationError:\n                continue\n            items.append(\n                activitypub.resolve_remote_id(remote_id, model=self.related_model)\n            )\n        return items\n\n\nclass TagField(ManyToManyField):\n    \"\"\"special case of many to many that uses Tags\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.activitypub_field = \"tag\"\n\n    def field_to_activity(self, value):\n        tags = []\n        for item in value.all():\n            activity_type = item.__class__.__name__\n            if activity_type == \"User\":\n                activity_type = \"Mention\"\n            tags.append(\n                activitypub.Link(\n                    href=item.remote_id,\n                    name=getattr(item, item.name_field),\n                    type=activity_type,\n                )\n            )\n        return tags\n\n    def field_from_activity(self, value):\n        if not isinstance(value, list):\n            return None\n        items = []\n        for link_json in value:\n            link = activitypub.Link(**link_json)\n            tag_type = link.type if link.type != \"Mention\" else \"Person\"\n            if tag_type == \"Book\":\n                tag_type = \"Edition\"\n            if tag_type != self.related_model.activity_serializer.type:\n                # tags can contain multiple types\n                continue\n            items.append(\n                activitypub.resolve_remote_id(link.href, model=self.related_model)\n            )\n        return items\n\n\nclass ClearableFileInputWithWarning(ClearableFileInput):\n    \"\"\"max file size warning\"\"\"\n\n    template_name = \"widgets/clearable_file_input_with_warning.html\"\n\n\nclass CustomImageField(DjangoImageField):\n    \"\"\"overwrites image field for form\"\"\"\n\n    widget = ClearableFileInputWithWarning\n\n\nclass ImageField(ActivitypubFieldMixin, models.ImageField):\n    \"\"\"activitypub-aware image field\"\"\"\n\n    def __init__(self, *args, alt_field=None, **kwargs):\n        self.alt_field = alt_field\n        super().__init__(*args, **kwargs)\n\n    # pylint: disable=arguments-differ,arguments-renamed\n    def set_field_from_activity(self, instance, data, save=True, overwrite=True):\n        \"\"\"helper function for assinging a value to the field\"\"\"\n        value = getattr(data, self.get_activitypub_field())\n        formatted = self.field_from_activity(value)\n        if formatted is None or formatted is MISSING:\n            return False\n\n        if (\n            not overwrite\n            and hasattr(instance, self.name)\n            and getattr(instance, self.name)\n        ):\n            return False\n\n        getattr(instance, self.name).save(*formatted, save=save)\n        return True\n\n    def set_activity_from_field(self, activity, instance):\n        value = getattr(instance, self.name)\n        if value is None:\n            return\n        alt_text = getattr(instance, self.alt_field)\n        formatted = self.field_to_activity(value, alt_text)\n\n        key = self.get_activitypub_field()\n        activity[key] = formatted\n\n    def field_to_activity(self, value, alt=None):\n        url = get_absolute_url(value)\n\n        if not url:\n            return None\n\n        return activitypub.Document(url=url, name=alt)\n\n    def field_from_activity(self, value):\n        image_slug = value\n        # when it's an inline image (User avatar/icon, Book cover), it's a json\n        # blob, but when it's an attached image, it's just a url\n        if hasattr(image_slug, \"url\"):\n            url = image_slug.url\n        elif isinstance(image_slug, str):\n            url = image_slug\n        else:\n            return None\n\n        try:\n            validate_remote_id(url)\n        except ValidationError:\n            return None\n\n        image_content, extension = get_image(url)\n        if not image_content:\n            return None\n\n        image_name = f\"{uuid4()}.{extension}\"\n        return [image_name, image_content]\n\n    def formfield(self, **kwargs):\n        \"\"\"special case for forms\"\"\"\n        return super().formfield(\n            **{\n                \"form_class\": CustomImageField,\n                **kwargs,\n            }\n        )\n\n\ndef get_absolute_url(value):\n    \"\"\"returns an absolute URL for the image\"\"\"\n    name = getattr(value, \"name\")\n    if not name:\n        return None\n\n    url = filepath_to_uri(name)\n    if url is not None:\n        url = url.lstrip(\"/\")\n    url = urljoin(MEDIA_FULL_URL, url)\n\n    return url\n\n\nclass DateTimeField(ActivitypubFieldMixin, models.DateTimeField):\n    \"\"\"activitypub-aware datetime field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return value.isoformat()\n\n    def field_from_activity(self, value):\n        try:\n            date_value = dateutil.parser.parse(value)\n            try:\n                return timezone.make_aware(date_value)\n            except ValueError:\n                return date_value\n        except (ParserError, TypeError):\n            return None\n\n\nclass HtmlField(ActivitypubFieldMixin, models.TextField):\n    \"\"\"a text field for storing html\"\"\"\n\n    def field_from_activity(self, value):\n        if not value or value == MISSING:\n            return None\n        return clean(value)\n\n\nclass ArrayField(ActivitypubFieldMixin, DjangoArrayField):\n    \"\"\"activitypub-aware array field\"\"\"\n\n    def field_to_activity(self, value):\n        return [str(i) for i in value]\n\n\nclass CharField(ActivitypubFieldMixin, models.CharField):\n    \"\"\"activitypub-aware char field\"\"\"\n\n\nclass URLField(ActivitypubFieldMixin, models.URLField):\n    \"\"\"activitypub-aware url field\"\"\"\n\n\nclass TextField(ActivitypubFieldMixin, models.TextField):\n    \"\"\"activitypub-aware text field\"\"\"\n\n\nclass BooleanField(ActivitypubFieldMixin, models.BooleanField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n\nclass IntegerField(ActivitypubFieldMixin, models.IntegerField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n\nclass DecimalField(ActivitypubFieldMixin, models.DecimalField):\n    \"\"\"activitypub-aware boolean field\"\"\"\n\n    def field_to_activity(self, value):\n        if not value:\n            return None\n        return float(value)\n", "patch": "@@ -16,7 +16,7 @@\n \n from bookwyrm import activitypub\n from bookwyrm.connectors import get_image\n-from bookwyrm.sanitize_html import InputHtmlParser\n+from bookwyrm.utils.sanitizer import clean\n from bookwyrm.settings import MEDIA_FULL_URL\n \n \n@@ -497,9 +497,7 @@ class HtmlField(ActivitypubFieldMixin, models.TextField):\n     def field_from_activity(self, value):\n         if not value or value == MISSING:\n             return None\n-        sanitizer = InputHtmlParser()\n-        sanitizer.feed(value)\n-        return sanitizer.get_output()\n+        return clean(value)\n \n \n class ArrayField(ActivitypubFieldMixin, DjangoArrayField):", "file_path": "files/2022_7/329", "file_language": "py", "file_name": "bookwyrm/models/fields.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/58b23a74da94795691c4e57df32b7095fb0dec8a/bookwyrm%2Fsanitize_html.py", "code": "\"\"\" html parser to clean up incoming text from unknown sources \"\"\"\nfrom html.parser import HTMLParser\n\n\nclass InputHtmlParser(HTMLParser):  # pylint: disable=abstract-method\n    \"\"\"Removes any html that isn't allowed_tagsed from a block\"\"\"\n\n    def __init__(self):\n        HTMLParser.__init__(self)\n        self.allowed_tags = [\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ]\n        self.allowed_attrs = [\"href\", \"rel\", \"src\", \"alt\"]\n        self.tag_stack = []\n        self.output = []\n        # if the html appears invalid, we just won't allow any at all\n        self.allow_html = True\n\n    def handle_starttag(self, tag, attrs):\n        \"\"\"check if the tag is valid\"\"\"\n        if self.allow_html and tag in self.allowed_tags:\n            allowed_attrs = \" \".join(\n                f'{a}=\"{v}\"' for a, v in attrs if a in self.allowed_attrs\n            )\n            reconstructed = f\"<{tag}\"\n            if allowed_attrs:\n                reconstructed += \" \" + allowed_attrs\n            reconstructed += \">\"\n            self.output.append((\"tag\", reconstructed))\n            self.tag_stack.append(tag)\n        else:\n            self.output.append((\"data\", \"\"))\n\n    def handle_endtag(self, tag):\n        \"\"\"keep the close tag\"\"\"\n        if not self.allow_html or tag not in self.allowed_tags:\n            self.output.append((\"data\", \"\"))\n            return\n\n        if not self.tag_stack or self.tag_stack[-1] != tag:\n            # the end tag doesn't match the most recent start tag\n            self.allow_html = False\n            self.output.append((\"data\", \"\"))\n            return\n\n        self.tag_stack = self.tag_stack[:-1]\n        self.output.append((\"tag\", f\"</{tag}>\"))\n\n    def handle_data(self, data):\n        \"\"\"extract the answer, if we're in an answer tag\"\"\"\n        self.output.append((\"data\", data))\n\n    def get_output(self):\n        \"\"\"convert the output from a list of tuples to a string\"\"\"\n        if self.tag_stack:\n            self.allow_html = False\n        if not self.allow_html:\n            return \"\".join(v for (k, v) in self.output if k == \"data\")\n        return \"\".join(v for (k, v) in self.output)\n", "code_before": "\"\"\" html parser to clean up incoming text from unknown sources \"\"\"\nfrom html.parser import HTMLParser\n\n\nclass InputHtmlParser(HTMLParser):  # pylint: disable=abstract-method\n    \"\"\"Removes any html that isn't allowed_tagsed from a block\"\"\"\n\n    def __init__(self):\n        HTMLParser.__init__(self)\n        self.allowed_tags = [\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ]\n        self.allowed_attrs = [\"href\", \"rel\", \"src\", \"alt\"]\n        self.tag_stack = []\n        self.output = []\n        # if the html appears invalid, we just won't allow any at all\n        self.allow_html = True\n\n    def handle_starttag(self, tag, attrs):\n        \"\"\"check if the tag is valid\"\"\"\n        if self.allow_html and tag in self.allowed_tags:\n            allowed_attrs = \" \".join(\n                f'{a}=\"{v}\"' for a, v in attrs if a in self.allowed_attrs\n            )\n            reconstructed = f\"<{tag}\"\n            if allowed_attrs:\n                reconstructed += \" \" + allowed_attrs\n            reconstructed += \">\"\n            self.output.append((\"tag\", reconstructed))\n            self.tag_stack.append(tag)\n        else:\n            self.output.append((\"data\", \"\"))\n\n    def handle_endtag(self, tag):\n        \"\"\"keep the close tag\"\"\"\n        if not self.allow_html or tag not in self.allowed_tags:\n            self.output.append((\"data\", \"\"))\n            return\n\n        if not self.tag_stack or self.tag_stack[-1] != tag:\n            # the end tag doesn't match the most recent start tag\n            self.allow_html = False\n            self.output.append((\"data\", \"\"))\n            return\n\n        self.tag_stack = self.tag_stack[:-1]\n        self.output.append((\"tag\", f\"</{tag}>\"))\n\n    def handle_data(self, data):\n        \"\"\"extract the answer, if we're in an answer tag\"\"\"\n        self.output.append((\"data\", data))\n\n    def get_output(self):\n        \"\"\"convert the output from a list of tuples to a string\"\"\"\n        if self.tag_stack:\n            self.allow_html = False\n        if not self.allow_html:\n            return \"\".join(v for (k, v) in self.output if k == \"data\")\n        return \"\".join(v for (k, v) in self.output)\n", "patch": "@@ -1,71 +0,0 @@\n-\"\"\" html parser to clean up incoming text from unknown sources \"\"\"\n-from html.parser import HTMLParser\n-\n-\n-class InputHtmlParser(HTMLParser):  # pylint: disable=abstract-method\n-    \"\"\"Removes any html that isn't allowed_tagsed from a block\"\"\"\n-\n-    def __init__(self):\n-        HTMLParser.__init__(self)\n-        self.allowed_tags = [\n-            \"p\",\n-            \"blockquote\",\n-            \"br\",\n-            \"b\",\n-            \"i\",\n-            \"strong\",\n-            \"em\",\n-            \"pre\",\n-            \"a\",\n-            \"span\",\n-            \"ul\",\n-            \"ol\",\n-            \"li\",\n-        ]\n-        self.allowed_attrs = [\"href\", \"rel\", \"src\", \"alt\"]\n-        self.tag_stack = []\n-        self.output = []\n-        # if the html appears invalid, we just won't allow any at all\n-        self.allow_html = True\n-\n-    def handle_starttag(self, tag, attrs):\n-        \"\"\"check if the tag is valid\"\"\"\n-        if self.allow_html and tag in self.allowed_tags:\n-            allowed_attrs = \" \".join(\n-                f'{a}=\"{v}\"' for a, v in attrs if a in self.allowed_attrs\n-            )\n-            reconstructed = f\"<{tag}\"\n-            if allowed_attrs:\n-                reconstructed += \" \" + allowed_attrs\n-            reconstructed += \">\"\n-            self.output.append((\"tag\", reconstructed))\n-            self.tag_stack.append(tag)\n-        else:\n-            self.output.append((\"data\", \"\"))\n-\n-    def handle_endtag(self, tag):\n-        \"\"\"keep the close tag\"\"\"\n-        if not self.allow_html or tag not in self.allowed_tags:\n-            self.output.append((\"data\", \"\"))\n-            return\n-\n-        if not self.tag_stack or self.tag_stack[-1] != tag:\n-            # the end tag doesn't match the most recent start tag\n-            self.allow_html = False\n-            self.output.append((\"data\", \"\"))\n-            return\n-\n-        self.tag_stack = self.tag_stack[:-1]\n-        self.output.append((\"tag\", f\"</{tag}>\"))\n-\n-    def handle_data(self, data):\n-        \"\"\"extract the answer, if we're in an answer tag\"\"\"\n-        self.output.append((\"data\", data))\n-\n-    def get_output(self):\n-        \"\"\"convert the output from a list of tuples to a string\"\"\"\n-        if self.tag_stack:\n-            self.allow_html = False\n-        if not self.allow_html:\n-            return \"\".join(v for (k, v) in self.output if k == \"data\")\n-        return \"\".join(v for (k, v) in self.output)", "file_path": "files/2022_7/330", "file_language": "py", "file_name": "bookwyrm/sanitize_html.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class InputHtmlParser(HTMLParser):  # pylint: disable=abstract-method\n    \"\"\"Removes any html that isn't allowed_tagsed from a block\"\"\"\n\n    def __init__(self):\n        HTMLParser.__init__(self)\n        self.allowed_tags = [\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ]\n        self.allowed_attrs = [\"href\", \"rel\", \"src\", \"alt\"]\n        self.tag_stack = []\n        self.output = []\n        # if the html appears invalid, we just won't allow any at all\n        self.allow_html = True\n\n    def handle_starttag(self, tag, attrs):\n        \"\"\"check if the tag is valid\"\"\"\n        if self.allow_html and tag in self.allowed_tags:\n            allowed_attrs = \" \".join(\n                f'{a}=\"{v}\"' for a, v in attrs if a in self.allowed_attrs\n            )\n            reconstructed = f\"<{tag}\"\n            if allowed_attrs:\n                reconstructed += \" \" + allowed_attrs\n            reconstructed += \">\"\n            self.output.append((\"tag\", reconstructed))\n            self.tag_stack.append(tag)\n        else:\n            self.output.append((\"data\", \"\"))\n\n    def handle_endtag(self, tag):\n        \"\"\"keep the close tag\"\"\"\n        if not self.allow_html or tag not in self.allowed_tags:\n            self.output.append((\"data\", \"\"))\n            return\n\n        if not self.tag_stack or self.tag_stack[-1] != tag:\n            # the end tag doesn't match the most recent start tag\n            self.allow_html = False\n            self.output.append((\"data\", \"\"))\n            return\n\n        self.tag_stack = self.tag_stack[:-1]\n        self.output.append((\"tag\", f\"</{tag}>\"))\n\n    def handle_data(self, data):\n        \"\"\"extract the answer, if we're in an answer tag\"\"\"\n        self.output.append((\"data\", data))\n\n    def get_output(self):\n        \"\"\"convert the output from a list of tuples to a string\"\"\"\n        if self.tag_stack:\n            self.allow_html = False\n        if not self.allow_html:\n            return \"\".join(v for (k, v) in self.output if k == \"data\")\n        return \"\".join(v for (k, v) in self.output)", "target": 0}], "function_after": [{"function": "class InputHtmlParser(HTMLParser):  # pylint: disable=abstract-method\n    \"\"\"Removes any html that isn't allowed_tagsed from a block\"\"\"\n\n    def __init__(self):\n        HTMLParser.__init__(self)\n        self.allowed_tags = [\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ]\n        self.allowed_attrs = [\"href\", \"rel\", \"src\", \"alt\"]\n        self.tag_stack = []\n        self.output = []\n        # if the html appears invalid, we just won't allow any at all\n        self.allow_html = True\n\n    def handle_starttag(self, tag, attrs):\n        \"\"\"check if the tag is valid\"\"\"\n        if self.allow_html and tag in self.allowed_tags:\n            allowed_attrs = \" \".join(\n                f'{a}=\"{v}\"' for a, v in attrs if a in self.allowed_attrs\n            )\n            reconstructed = f\"<{tag}\"\n            if allowed_attrs:\n                reconstructed += \" \" + allowed_attrs\n            reconstructed += \">\"\n            self.output.append((\"tag\", reconstructed))\n            self.tag_stack.append(tag)\n        else:\n            self.output.append((\"data\", \"\"))\n\n    def handle_endtag(self, tag):\n        \"\"\"keep the close tag\"\"\"\n        if not self.allow_html or tag not in self.allowed_tags:\n            self.output.append((\"data\", \"\"))\n            return\n\n        if not self.tag_stack or self.tag_stack[-1] != tag:\n            # the end tag doesn't match the most recent start tag\n            self.allow_html = False\n            self.output.append((\"data\", \"\"))\n            return\n\n        self.tag_stack = self.tag_stack[:-1]\n        self.output.append((\"tag\", f\"</{tag}>\"))\n\n    def handle_data(self, data):\n        \"\"\"extract the answer, if we're in an answer tag\"\"\"\n        self.output.append((\"data\", data))\n\n    def get_output(self):\n        \"\"\"convert the output from a list of tuples to a string\"\"\"\n        if self.tag_stack:\n            self.allow_html = False\n        if not self.allow_html:\n            return \"\".join(v for (k, v) in self.output if k == \"data\")\n        return \"\".join(v for (k, v) in self.output)", "target": 0}]}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Fsettings.py", "code": "\"\"\" bookwyrm settings and configuration \"\"\"\nimport os\nfrom environs import Env\n\nimport requests\nfrom django.utils.translation import gettext_lazy as _\n\n\n# pylint: disable=line-too-long\n\nenv = Env()\nenv.read_env()\nDOMAIN = env(\"DOMAIN\")\nVERSION = \"0.4.1\"\n\nRELEASE_API = env(\n    \"RELEASE_API\",\n    \"https://api.github.com/repos/bookwyrm-social/bookwyrm/releases/latest\",\n)\n\nPAGE_LENGTH = env(\"PAGE_LENGTH\", 15)\nDEFAULT_LANGUAGE = env(\"DEFAULT_LANGUAGE\", \"English\")\n\nJS_CACHE = \"e678183b\"\n\n# email\nEMAIL_BACKEND = env(\"EMAIL_BACKEND\", \"django.core.mail.backends.smtp.EmailBackend\")\nEMAIL_HOST = env(\"EMAIL_HOST\")\nEMAIL_PORT = env(\"EMAIL_PORT\", 587)\nEMAIL_HOST_USER = env(\"EMAIL_HOST_USER\")\nEMAIL_HOST_PASSWORD = env(\"EMAIL_HOST_PASSWORD\")\nEMAIL_USE_TLS = env.bool(\"EMAIL_USE_TLS\", True)\nEMAIL_USE_SSL = env.bool(\"EMAIL_USE_SSL\", False)\nEMAIL_SENDER_NAME = env(\"EMAIL_SENDER_NAME\", \"admin\")\nEMAIL_SENDER_DOMAIN = env(\"EMAIL_SENDER_DOMAIN\", DOMAIN)\nEMAIL_SENDER = f\"{EMAIL_SENDER_NAME}@{EMAIL_SENDER_DOMAIN}\"\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nLOCALE_PATHS = [\n    os.path.join(BASE_DIR, \"locale\"),\n]\nLANGUAGE_COOKIE_NAME = env.str(\"LANGUAGE_COOKIE_NAME\", \"django_language\")\n\nSTATIC_ROOT = os.path.join(BASE_DIR, env(\"STATIC_ROOT\", \"static\"))\nMEDIA_ROOT = os.path.join(BASE_DIR, env(\"MEDIA_ROOT\", \"images\"))\n\nDEFAULT_AUTO_FIELD = \"django.db.models.AutoField\"\n\n# Preview image\nENABLE_PREVIEW_IMAGES = env.bool(\"ENABLE_PREVIEW_IMAGES\", False)\nPREVIEW_BG_COLOR = env.str(\"PREVIEW_BG_COLOR\", \"use_dominant_color_light\")\nPREVIEW_TEXT_COLOR = env.str(\"PREVIEW_TEXT_COLOR\", \"#363636\")\nPREVIEW_IMG_WIDTH = env.int(\"PREVIEW_IMG_WIDTH\", 1200)\nPREVIEW_IMG_HEIGHT = env.int(\"PREVIEW_IMG_HEIGHT\", 630)\nPREVIEW_DEFAULT_COVER_COLOR = env.str(\"PREVIEW_DEFAULT_COVER_COLOR\", \"#002549\")\nPREVIEW_DEFAULT_FONT = env.str(\"PREVIEW_DEFAULT_FONT\", \"Source Han Sans\")\n\nFONTS = {\n    \"Source Han Sans\": {\n        \"directory\": \"source_han_sans\",\n        \"filename\": \"SourceHanSans-VF.ttf.ttc\",\n        \"url\": \"https://github.com/adobe-fonts/source-han-sans/raw/release/Variable/OTC/SourceHanSans-VF.ttf.ttc\",\n    }\n}\nFONT_DIR = os.path.join(STATIC_ROOT, \"fonts\")\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = env(\"SECRET_KEY\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = env.bool(\"DEBUG\", True)\nUSE_HTTPS = env.bool(\"USE_HTTPS\", not DEBUG)\n\nALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", [\"*\"])\n\n# Application definition\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"django.contrib.humanize\",\n    \"sass_processor\",\n    \"bookwyrm\",\n    \"celery\",\n    \"django_celery_beat\",\n    \"imagekit\",\n    \"storages\",\n]\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.locale.LocaleMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"bookwyrm.middleware.TimezoneMiddleware\",\n    \"bookwyrm.middleware.IPBlocklistMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\n\nROOT_URLCONF = \"bookwyrm.urls\"\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [\"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n                \"bookwyrm.context_processors.site_settings\",\n            ],\n        },\n    },\n]\n\nLOG_LEVEL = env(\"LOG_LEVEL\", \"INFO\").upper()\n# Override aspects of the default handler to our taste\n# See https://docs.djangoproject.com/en/3.2/topics/logging/#default-logging-configuration\n# for a reference to the defaults we're overriding\n#\n# It seems that in order to override anything you have to include its\n# entire dependency tree (handlers and filters) which makes this a\n# bit verbose\nLOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"filters\": {\n        # These are copied from the default configuration, required for\n        # implementing mail_admins below\n        \"require_debug_false\": {\n            \"()\": \"django.utils.log.RequireDebugFalse\",\n        },\n        \"require_debug_true\": {\n            \"()\": \"django.utils.log.RequireDebugTrue\",\n        },\n    },\n    \"handlers\": {\n        # Overrides the default handler to make it log to console\n        # regardless of the DEBUG setting (default is to not log to\n        # console if DEBUG=False)\n        \"console\": {\n            \"level\": LOG_LEVEL,\n            \"class\": \"logging.StreamHandler\",\n        },\n        # This is copied as-is from the default logger, and is\n        # required for the django section below\n        \"mail_admins\": {\n            \"level\": \"ERROR\",\n            \"filters\": [\"require_debug_false\"],\n            \"class\": \"django.utils.log.AdminEmailHandler\",\n        },\n    },\n    \"loggers\": {\n        # Install our new console handler for Django's logger, and\n        # override the log level while we're at it\n        \"django\": {\n            \"handlers\": [\"console\", \"mail_admins\"],\n            \"level\": LOG_LEVEL,\n        },\n        \"django.utils.autoreload\": {\n            \"level\": \"INFO\",\n        },\n        # Add a bookwyrm-specific logger\n        \"bookwyrm\": {\n            \"handlers\": [\"console\"],\n            \"level\": LOG_LEVEL,\n        },\n    },\n}\n\nSTATICFILES_FINDERS = [\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n    \"sass_processor.finders.CssFinder\",\n]\n\nSASS_PROCESSOR_INCLUDE_FILE_PATTERN = r\"^.+\\.[s]{0,1}(?:a|c)ss$\"\nSASS_PROCESSOR_ENABLED = True\n\n# minify css is production but not dev\nif not DEBUG:\n    SASS_OUTPUT_STYLE = \"compressed\"\n\nWSGI_APPLICATION = \"bookwyrm.wsgi.application\"\n\n# redis/activity streams settings\nREDIS_ACTIVITY_HOST = env(\"REDIS_ACTIVITY_HOST\", \"localhost\")\nREDIS_ACTIVITY_PORT = env(\"REDIS_ACTIVITY_PORT\", 6379)\nREDIS_ACTIVITY_PASSWORD = env(\"REDIS_ACTIVITY_PASSWORD\", None)\nREDIS_ACTIVITY_DB_INDEX = env(\"REDIS_ACTIVITY_DB_INDEX\", 0)\n\nMAX_STREAM_LENGTH = int(env(\"MAX_STREAM_LENGTH\", 200))\n\nSTREAMS = [\n    {\"key\": \"home\", \"name\": _(\"Home Timeline\"), \"shortname\": _(\"Home\")},\n    {\"key\": \"books\", \"name\": _(\"Books Timeline\"), \"shortname\": _(\"Books\")},\n]\n\n# Search configuration\n# total time in seconds that the instance will spend searching connectors\nSEARCH_TIMEOUT = int(env(\"SEARCH_TIMEOUT\", 8))\n# timeout for a query to an individual connector\nQUERY_TIMEOUT = int(env(\"QUERY_TIMEOUT\", 5))\n\n# Redis cache backend\nif env(\"USE_DUMMY_CACHE\", False):\n    CACHES = {\n        \"default\": {\n            \"BACKEND\": \"django.core.cache.backends.dummy.DummyCache\",\n        }\n    }\nelse:\n    CACHES = {\n        \"default\": {\n            \"BACKEND\": \"django_redis.cache.RedisCache\",\n            \"LOCATION\": f\"redis://:{REDIS_ACTIVITY_PASSWORD}@{REDIS_ACTIVITY_HOST}:{REDIS_ACTIVITY_PORT}/{REDIS_ACTIVITY_DB_INDEX}\",\n            \"OPTIONS\": {\n                \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n            },\n        }\n    }\n\n    SESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\n    SESSION_CACHE_ALIAS = \"default\"\n\n# Database\n# https://docs.djangoproject.com/en/3.2/ref/settings/#databases\n\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.postgresql_psycopg2\",\n        \"NAME\": env(\"POSTGRES_DB\", \"bookwyrm\"),\n        \"USER\": env(\"POSTGRES_USER\", \"bookwyrm\"),\n        \"PASSWORD\": env(\"POSTGRES_PASSWORD\", \"bookwyrm\"),\n        \"HOST\": env(\"POSTGRES_HOST\", \"\"),\n        \"PORT\": env(\"PGPORT\", 5432),\n    },\n}\n\n\nLOGIN_URL = \"/login/\"\nAUTH_USER_MODEL = \"bookwyrm.User\"\n\n# Password validation\n# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/3.2/topics/i18n/\n\nLANGUAGE_CODE = env(\"LANGUAGE_CODE\", \"en-us\")\nLANGUAGES = [\n    (\"en-us\", _(\"English\")),\n    (\"de-de\", _(\"Deutsch (German)\")),\n    (\"es-es\", _(\"Espa\u00f1ol (Spanish)\")),\n    (\"gl-es\", _(\"Galego (Galician)\")),\n    (\"it-it\", _(\"Italiano (Italian)\")),\n    (\"fi-fi\", _(\"Suomi (Finnish)\")),\n    (\"fr-fr\", _(\"Fran\u00e7ais (French)\")),\n    (\"lt-lt\", _(\"Lietuvi\u0173 (Lithuanian)\")),\n    (\"no-no\", _(\"Norsk (Norwegian)\")),\n    (\"pt-br\", _(\"Portugu\u00eas do Brasil (Brazilian Portuguese)\")),\n    (\"pt-pt\", _(\"Portugu\u00eas Europeu (European Portuguese)\")),\n    (\"ro-ro\", _(\"Rom\u00e2n\u0103 (Romanian)\")),\n    (\"sv-se\", _(\"Svenska (Swedish)\")),\n    (\"zh-hans\", _(\"\u7b80\u4f53\u4e2d\u6587 (Simplified Chinese)\")),\n    (\"zh-hant\", _(\"\u7e41\u9ad4\u4e2d\u6587 (Traditional Chinese)\")),\n]\n\n\nTIME_ZONE = \"UTC\"\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = True\n\n\nagent = requests.utils.default_user_agent()\nUSER_AGENT = f\"{agent} (BookWyrm/{VERSION}; +https://{DOMAIN}/)\"\n\n# Imagekit generated thumbnails\nENABLE_THUMBNAIL_GENERATION = env.bool(\"ENABLE_THUMBNAIL_GENERATION\", False)\nIMAGEKIT_CACHEFILE_DIR = \"thumbnails\"\nIMAGEKIT_DEFAULT_CACHEFILE_STRATEGY = \"bookwyrm.thumbnail_generation.Strategy\"\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\n\nPROJECT_DIR = os.path.dirname(os.path.abspath(__file__))\n\n# Storage\n\nPROTOCOL = \"http\"\nif USE_HTTPS:\n    PROTOCOL = \"https\"\n\nUSE_S3 = env.bool(\"USE_S3\", False)\n\nif USE_S3:\n    # AWS settings\n    AWS_ACCESS_KEY_ID = env(\"AWS_ACCESS_KEY_ID\")\n    AWS_SECRET_ACCESS_KEY = env(\"AWS_SECRET_ACCESS_KEY\")\n    AWS_STORAGE_BUCKET_NAME = env(\"AWS_STORAGE_BUCKET_NAME\")\n    AWS_S3_CUSTOM_DOMAIN = env(\"AWS_S3_CUSTOM_DOMAIN\")\n    AWS_S3_REGION_NAME = env(\"AWS_S3_REGION_NAME\", \"\")\n    AWS_S3_ENDPOINT_URL = env(\"AWS_S3_ENDPOINT_URL\")\n    AWS_DEFAULT_ACL = \"public-read\"\n    AWS_S3_OBJECT_PARAMETERS = {\"CacheControl\": \"max-age=86400\"}\n    # S3 Static settings\n    STATIC_LOCATION = \"static\"\n    STATIC_URL = f\"{PROTOCOL}://{AWS_S3_CUSTOM_DOMAIN}/{STATIC_LOCATION}/\"\n    STATICFILES_STORAGE = \"bookwyrm.storage_backends.StaticStorage\"\n    # S3 Media settings\n    MEDIA_LOCATION = \"images\"\n    MEDIA_URL = f\"{PROTOCOL}://{AWS_S3_CUSTOM_DOMAIN}/{MEDIA_LOCATION}/\"\n    MEDIA_FULL_URL = MEDIA_URL\n    STATIC_FULL_URL = STATIC_URL\n    DEFAULT_FILE_STORAGE = \"bookwyrm.storage_backends.ImagesStorage\"\nelse:\n    STATIC_URL = \"/static/\"\n    MEDIA_URL = \"/images/\"\n    MEDIA_FULL_URL = f\"{PROTOCOL}://{DOMAIN}{MEDIA_URL}\"\n    STATIC_FULL_URL = f\"{PROTOCOL}://{DOMAIN}{STATIC_URL}\"\n\nOTEL_EXPORTER_OTLP_ENDPOINT = env(\"OTEL_EXPORTER_OTLP_ENDPOINT\", None)\nOTEL_EXPORTER_OTLP_HEADERS = env(\"OTEL_EXPORTER_OTLP_HEADERS\", None)\nOTEL_SERVICE_NAME = env(\"OTEL_SERVICE_NAME\", None)\n", "code_before": "\"\"\" bookwyrm settings and configuration \"\"\"\nimport os\nfrom environs import Env\n\nimport requests\nfrom django.utils.translation import gettext_lazy as _\n\n\n# pylint: disable=line-too-long\n\nenv = Env()\nenv.read_env()\nDOMAIN = env(\"DOMAIN\")\nVERSION = \"0.4.1\"\n\nRELEASE_API = env(\n    \"RELEASE_API\",\n    \"https://api.github.com/repos/bookwyrm-social/bookwyrm/releases/latest\",\n)\n\nPAGE_LENGTH = env(\"PAGE_LENGTH\", 15)\nDEFAULT_LANGUAGE = env(\"DEFAULT_LANGUAGE\", \"English\")\n\nJS_CACHE = \"e678183b\"\n\n# email\nEMAIL_BACKEND = env(\"EMAIL_BACKEND\", \"django.core.mail.backends.smtp.EmailBackend\")\nEMAIL_HOST = env(\"EMAIL_HOST\")\nEMAIL_PORT = env(\"EMAIL_PORT\", 587)\nEMAIL_HOST_USER = env(\"EMAIL_HOST_USER\")\nEMAIL_HOST_PASSWORD = env(\"EMAIL_HOST_PASSWORD\")\nEMAIL_USE_TLS = env.bool(\"EMAIL_USE_TLS\", True)\nEMAIL_USE_SSL = env.bool(\"EMAIL_USE_SSL\", False)\nEMAIL_SENDER_NAME = env(\"EMAIL_SENDER_NAME\", \"admin\")\nEMAIL_SENDER_DOMAIN = env(\"EMAIL_SENDER_DOMAIN\", DOMAIN)\nEMAIL_SENDER = f\"{EMAIL_SENDER_NAME}@{EMAIL_SENDER_DOMAIN}\"\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nLOCALE_PATHS = [\n    os.path.join(BASE_DIR, \"locale\"),\n]\nLANGUAGE_COOKIE_NAME = env.str(\"LANGUAGE_COOKIE_NAME\", \"django_language\")\n\nSTATIC_ROOT = os.path.join(BASE_DIR, env(\"STATIC_ROOT\", \"static\"))\nMEDIA_ROOT = os.path.join(BASE_DIR, env(\"MEDIA_ROOT\", \"images\"))\n\nDEFAULT_AUTO_FIELD = \"django.db.models.AutoField\"\n\n# Preview image\nENABLE_PREVIEW_IMAGES = env.bool(\"ENABLE_PREVIEW_IMAGES\", False)\nPREVIEW_BG_COLOR = env.str(\"PREVIEW_BG_COLOR\", \"use_dominant_color_light\")\nPREVIEW_TEXT_COLOR = env.str(\"PREVIEW_TEXT_COLOR\", \"#363636\")\nPREVIEW_IMG_WIDTH = env.int(\"PREVIEW_IMG_WIDTH\", 1200)\nPREVIEW_IMG_HEIGHT = env.int(\"PREVIEW_IMG_HEIGHT\", 630)\nPREVIEW_DEFAULT_COVER_COLOR = env.str(\"PREVIEW_DEFAULT_COVER_COLOR\", \"#002549\")\nPREVIEW_DEFAULT_FONT = env.str(\"PREVIEW_DEFAULT_FONT\", \"Source Han Sans\")\n\nFONTS = {\n    \"Source Han Sans\": {\n        \"directory\": \"source_han_sans\",\n        \"filename\": \"SourceHanSans-VF.ttf.ttc\",\n        \"url\": \"https://github.com/adobe-fonts/source-han-sans/raw/release/Variable/OTC/SourceHanSans-VF.ttf.ttc\",\n    }\n}\nFONT_DIR = os.path.join(STATIC_ROOT, \"fonts\")\n\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = env(\"SECRET_KEY\")\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = env.bool(\"DEBUG\", True)\nUSE_HTTPS = env.bool(\"USE_HTTPS\", not DEBUG)\n\nALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", [\"*\"])\n\n# Application definition\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"django.contrib.humanize\",\n    \"sass_processor\",\n    \"bookwyrm\",\n    \"celery\",\n    \"django_celery_beat\",\n    \"imagekit\",\n    \"storages\",\n]\n\nMIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.locale.LocaleMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"bookwyrm.middleware.TimezoneMiddleware\",\n    \"bookwyrm.middleware.IPBlocklistMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n]\n\nROOT_URLCONF = \"bookwyrm.urls\"\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [\"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n                \"bookwyrm.context_processors.site_settings\",\n            ],\n        },\n    },\n]\n\nLOG_LEVEL = env(\"LOG_LEVEL\", \"INFO\").upper()\n# Override aspects of the default handler to our taste\n# See https://docs.djangoproject.com/en/3.2/topics/logging/#default-logging-configuration\n# for a reference to the defaults we're overriding\n#\n# It seems that in order to override anything you have to include its\n# entire dependency tree (handlers and filters) which makes this a\n# bit verbose\nLOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"filters\": {\n        # These are copied from the default configuration, required for\n        # implementing mail_admins below\n        \"require_debug_false\": {\n            \"()\": \"django.utils.log.RequireDebugFalse\",\n        },\n        \"require_debug_true\": {\n            \"()\": \"django.utils.log.RequireDebugTrue\",\n        },\n    },\n    \"handlers\": {\n        # Overrides the default handler to make it log to console\n        # regardless of the DEBUG setting (default is to not log to\n        # console if DEBUG=False)\n        \"console\": {\n            \"level\": LOG_LEVEL,\n            \"class\": \"logging.StreamHandler\",\n        },\n        # This is copied as-is from the default logger, and is\n        # required for the django section below\n        \"mail_admins\": {\n            \"level\": \"ERROR\",\n            \"filters\": [\"require_debug_false\"],\n            \"class\": \"django.utils.log.AdminEmailHandler\",\n        },\n    },\n    \"loggers\": {\n        # Install our new console handler for Django's logger, and\n        # override the log level while we're at it\n        \"django\": {\n            \"handlers\": [\"console\", \"mail_admins\"],\n            \"level\": LOG_LEVEL,\n        },\n        \"django.utils.autoreload\": {\n            \"level\": \"INFO\",\n        },\n        # Add a bookwyrm-specific logger\n        \"bookwyrm\": {\n            \"handlers\": [\"console\"],\n            \"level\": LOG_LEVEL,\n        },\n    },\n}\n\nSTATICFILES_FINDERS = [\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n    \"sass_processor.finders.CssFinder\",\n]\n\nSASS_PROCESSOR_INCLUDE_FILE_PATTERN = r\"^.+\\.[s]{0,1}(?:a|c)ss$\"\nSASS_PROCESSOR_ENABLED = True\n\n# minify css is production but not dev\nif not DEBUG:\n    SASS_OUTPUT_STYLE = \"compressed\"\n\nWSGI_APPLICATION = \"bookwyrm.wsgi.application\"\n\n# redis/activity streams settings\nREDIS_ACTIVITY_HOST = env(\"REDIS_ACTIVITY_HOST\", \"localhost\")\nREDIS_ACTIVITY_PORT = env(\"REDIS_ACTIVITY_PORT\", 6379)\nREDIS_ACTIVITY_PASSWORD = env(\"REDIS_ACTIVITY_PASSWORD\", None)\nREDIS_ACTIVITY_DB_INDEX = env(\"REDIS_ACTIVITY_DB_INDEX\", 0)\n\nMAX_STREAM_LENGTH = int(env(\"MAX_STREAM_LENGTH\", 200))\n\nSTREAMS = [\n    {\"key\": \"home\", \"name\": _(\"Home Timeline\"), \"shortname\": _(\"Home\")},\n    {\"key\": \"books\", \"name\": _(\"Books Timeline\"), \"shortname\": _(\"Books\")},\n]\n\n# Search configuration\n# total time in seconds that the instance will spend searching connectors\nSEARCH_TIMEOUT = int(env(\"SEARCH_TIMEOUT\", 8))\n# timeout for a query to an individual connector\nQUERY_TIMEOUT = int(env(\"QUERY_TIMEOUT\", 5))\n\n# Redis cache backend\nif env(\"USE_DUMMY_CACHE\", False):\n    CACHES = {\n        \"default\": {\n            \"BACKEND\": \"django.core.cache.backends.dummy.DummyCache\",\n        }\n    }\nelse:\n    CACHES = {\n        \"default\": {\n            \"BACKEND\": \"django_redis.cache.RedisCache\",\n            \"LOCATION\": f\"redis://:{REDIS_ACTIVITY_PASSWORD}@{REDIS_ACTIVITY_HOST}:{REDIS_ACTIVITY_PORT}/{REDIS_ACTIVITY_DB_INDEX}\",\n            \"OPTIONS\": {\n                \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n            },\n        }\n    }\n\n    SESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\n    SESSION_CACHE_ALIAS = \"default\"\n\n# Database\n# https://docs.djangoproject.com/en/3.2/ref/settings/#databases\n\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.postgresql_psycopg2\",\n        \"NAME\": env(\"POSTGRES_DB\", \"bookwyrm\"),\n        \"USER\": env(\"POSTGRES_USER\", \"bookwyrm\"),\n        \"PASSWORD\": env(\"POSTGRES_PASSWORD\", \"bookwyrm\"),\n        \"HOST\": env(\"POSTGRES_HOST\", \"\"),\n        \"PORT\": env(\"PGPORT\", 5432),\n    },\n}\n\n\nLOGIN_URL = \"/login/\"\nAUTH_USER_MODEL = \"bookwyrm.User\"\n\n# Password validation\n# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n    },\n    {\n        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n    },\n]\n\n\n# Internationalization\n# https://docs.djangoproject.com/en/3.2/topics/i18n/\n\nLANGUAGE_CODE = env(\"LANGUAGE_CODE\", \"en-us\")\nLANGUAGES = [\n    (\"en-us\", _(\"English\")),\n    (\"de-de\", _(\"Deutsch (German)\")),\n    (\"es-es\", _(\"Espa\u00f1ol (Spanish)\")),\n    (\"gl-es\", _(\"Galego (Galician)\")),\n    (\"it-it\", _(\"Italiano (Italian)\")),\n    (\"fi-fi\", _(\"Suomi (Finnish)\")),\n    (\"fr-fr\", _(\"Fran\u00e7ais (French)\")),\n    (\"lt-lt\", _(\"Lietuvi\u0173 (Lithuanian)\")),\n    (\"no-no\", _(\"Norsk (Norwegian)\")),\n    (\"pt-br\", _(\"Portugu\u00eas do Brasil (Brazilian Portuguese)\")),\n    (\"pt-pt\", _(\"Portugu\u00eas Europeu (European Portuguese)\")),\n    (\"ro-ro\", _(\"Rom\u00e2n\u0103 (Romanian)\")),\n    (\"sv-se\", _(\"Svenska (Swedish)\")),\n    (\"zh-hans\", _(\"\u7b80\u4f53\u4e2d\u6587 (Simplified Chinese)\")),\n    (\"zh-hant\", _(\"\u7e41\u9ad4\u4e2d\u6587 (Traditional Chinese)\")),\n]\n\n\nTIME_ZONE = \"UTC\"\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = True\n\n\nagent = requests.utils.default_user_agent()\nUSER_AGENT = f\"{agent} (BookWyrm/{VERSION}; +https://{DOMAIN}/)\"\n\n# Imagekit generated thumbnails\nENABLE_THUMBNAIL_GENERATION = env.bool(\"ENABLE_THUMBNAIL_GENERATION\", False)\nIMAGEKIT_CACHEFILE_DIR = \"thumbnails\"\nIMAGEKIT_DEFAULT_CACHEFILE_STRATEGY = \"bookwyrm.thumbnail_generation.Strategy\"\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\n\nPROJECT_DIR = os.path.dirname(os.path.abspath(__file__))\n\n# Storage\n\nPROTOCOL = \"http\"\nif USE_HTTPS:\n    PROTOCOL = \"https\"\n\nUSE_S3 = env.bool(\"USE_S3\", False)\n\nif USE_S3:\n    # AWS settings\n    AWS_ACCESS_KEY_ID = env(\"AWS_ACCESS_KEY_ID\")\n    AWS_SECRET_ACCESS_KEY = env(\"AWS_SECRET_ACCESS_KEY\")\n    AWS_STORAGE_BUCKET_NAME = env(\"AWS_STORAGE_BUCKET_NAME\")\n    AWS_S3_CUSTOM_DOMAIN = env(\"AWS_S3_CUSTOM_DOMAIN\")\n    AWS_S3_REGION_NAME = env(\"AWS_S3_REGION_NAME\", \"\")\n    AWS_S3_ENDPOINT_URL = env(\"AWS_S3_ENDPOINT_URL\")\n    AWS_DEFAULT_ACL = \"public-read\"\n    AWS_S3_OBJECT_PARAMETERS = {\"CacheControl\": \"max-age=86400\"}\n    # S3 Static settings\n    STATIC_LOCATION = \"static\"\n    STATIC_URL = f\"{PROTOCOL}://{AWS_S3_CUSTOM_DOMAIN}/{STATIC_LOCATION}/\"\n    STATICFILES_STORAGE = \"bookwyrm.storage_backends.StaticStorage\"\n    # S3 Media settings\n    MEDIA_LOCATION = \"images\"\n    MEDIA_URL = f\"{PROTOCOL}://{AWS_S3_CUSTOM_DOMAIN}/{MEDIA_LOCATION}/\"\n    MEDIA_FULL_URL = MEDIA_URL\n    STATIC_FULL_URL = STATIC_URL\n    DEFAULT_FILE_STORAGE = \"bookwyrm.storage_backends.ImagesStorage\"\nelse:\n    STATIC_URL = \"/static/\"\n    MEDIA_URL = \"/images/\"\n    MEDIA_FULL_URL = f\"{PROTOCOL}://{DOMAIN}{MEDIA_URL}\"\n    STATIC_FULL_URL = f\"{PROTOCOL}://{DOMAIN}{STATIC_URL}\"\n\nOTEL_EXPORTER_OTLP_ENDPOINT = env(\"OTEL_EXPORTER_OTLP_ENDPOINT\", None)\nOTEL_EXPORTER_OTLP_HEADERS = env(\"OTEL_EXPORTER_OTLP_HEADERS\", None)\nOTEL_SERVICE_NAME = env(\"OTEL_SERVICE_NAME\", None)\n", "patch": "@@ -11,7 +11,7 @@\n env = Env()\n env.read_env()\n DOMAIN = env(\"DOMAIN\")\n-VERSION = \"0.4.0\"\n+VERSION = \"0.4.1\"\n \n RELEASE_API = env(\n     \"RELEASE_API\",", "file_path": "files/2022_7/331", "file_language": "py", "file_name": "bookwyrm/settings.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Fstatus.py", "code": "\"\"\" Handle user activity \"\"\"\nfrom django.db import transaction\n\nfrom bookwyrm import models\nfrom bookwyrm.utils import sanitizer\n\n\ndef create_generated_note(user, content, mention_books=None, privacy=\"public\"):\n    \"\"\"a note created by the app about user activity\"\"\"\n    # sanitize input html\n    content = sanitizer.clean(content)\n\n    with transaction.atomic():\n        # create but don't save\n        status = models.GeneratedNote(user=user, content=content, privacy=privacy)\n        # we have to save it to set the related fields, but hold off on telling\n        # folks about it because it is not ready\n        status.save(broadcast=False)\n\n        if mention_books:\n            status.mention_books.set(mention_books)\n        status.save(created=True)\n    return status\n", "code_before": "\"\"\" Handle user activity \"\"\"\nfrom django.db import transaction\n\nfrom bookwyrm import models\nfrom bookwyrm.utils import sanitizer\n\n\ndef create_generated_note(user, content, mention_books=None, privacy=\"public\"):\n    \"\"\"a note created by the app about user activity\"\"\"\n    # sanitize input html\n    content = sanitizer.clean(content)\n\n    with transaction.atomic():\n        # create but don't save\n        status = models.GeneratedNote(user=user, content=content, privacy=privacy)\n        # we have to save it to set the related fields, but hold off on telling\n        # folks about it because it is not ready\n        status.save(broadcast=False)\n\n        if mention_books:\n            status.mention_books.set(mention_books)\n        status.save(created=True)\n    return status\n", "patch": "@@ -2,15 +2,13 @@\n from django.db import transaction\n \n from bookwyrm import models\n-from bookwyrm.sanitize_html import InputHtmlParser\n+from bookwyrm.utils import sanitizer\n \n \n def create_generated_note(user, content, mention_books=None, privacy=\"public\"):\n     \"\"\"a note created by the app about user activity\"\"\"\n     # sanitize input html\n-    parser = InputHtmlParser()\n-    parser.feed(content)\n-    content = parser.get_output()\n+    content = sanitizer.clean(content)\n \n     with transaction.atomic():\n         # create but don't save", "file_path": "files/2022_7/332", "file_language": "py", "file_name": "bookwyrm/status.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def create_generated_note(user, content, mention_books=None, privacy=\"public\"):\n    \"\"\"a note created by the app about user activity\"\"\"\n    # sanitize input html\n    content = sanitizer.clean(content)\n\n    with transaction.atomic():\n        # create but don't save\n        status = models.GeneratedNote(user=user, content=content, privacy=privacy)\n        # we have to save it to set the related fields, but hold off on telling\n        # folks about it because it is not ready\n        status.save(broadcast=False)\n\n        if mention_books:\n            status.mention_books.set(mention_books)\n        status.save(created=True)\n    return status", "target": 0}], "function_after": [{"function": "def create_generated_note(user, content, mention_books=None, privacy=\"public\"):\n    \"\"\"a note created by the app about user activity\"\"\"\n    # sanitize input html\n    content = sanitizer.clean(content)\n\n    with transaction.atomic():\n        # create but don't save\n        status = models.GeneratedNote(user=user, content=content, privacy=privacy)\n        # we have to save it to set the related fields, but hold off on telling\n        # folks about it because it is not ready\n        status.save(broadcast=False)\n\n        if mention_books:\n            status.mention_books.set(mention_books)\n        status.save(created=True)\n    return status", "target": 0}]}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Ftests%2Ftest_sanitize_html.py", "code": "\"\"\" make sure only valid html gets to the app \"\"\"\nfrom django.test import TestCase\n\nfrom bookwyrm.utils.sanitizer import clean\n\n\nclass Sanitizer(TestCase):\n    \"\"\"sanitizer tests\"\"\"\n\n    def test_no_html(self):\n        \"\"\"just text\"\"\"\n        input_text = \"no      html  \"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html(self):\n        \"\"\"leave the html untouched\"\"\"\n        input_text = \"<b>yes    </b> <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_attrs(self):\n        \"\"\"and don't remove useful attributes\"\"\"\n        input_text = '<a href=\"fish.com\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_invalid_attrs(self):\n        \"\"\"do remove un-approved attributes\"\"\"\n        input_text = '<a href=\"fish.com\" fish=\"hello\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(output, '<a href=\"fish.com\">yes    </a> <i>html</i>')\n\n    def test_invalid_html(self):\n        \"\"\"don't allow malformed html\"\"\"\n        input_text = \"<b>yes  <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(\"<b>yes  <i>html</i></b>\", output)\n\n        input_text = \"yes <i></b>html   </i>\"\n        output = clean(input_text)\n        self.assertEqual(\"yes <i>html   </i>\", output)\n\n    def test_disallowed_html(self):\n        \"\"\"remove disallowed html but keep allowed html\"\"\"\n        input_text = \"<div>  yes <i>html</i></div>\"\n        output = clean(input_text)\n        self.assertEqual(\"  yes <i>html</i>\", output)\n", "code_before": "\"\"\" make sure only valid html gets to the app \"\"\"\nfrom django.test import TestCase\n\nfrom bookwyrm.utils.sanitizer import clean\n\n\nclass Sanitizer(TestCase):\n    \"\"\"sanitizer tests\"\"\"\n\n    def test_no_html(self):\n        \"\"\"just text\"\"\"\n        input_text = \"no      html  \"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html(self):\n        \"\"\"leave the html untouched\"\"\"\n        input_text = \"<b>yes    </b> <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_attrs(self):\n        \"\"\"and don't remove useful attributes\"\"\"\n        input_text = '<a href=\"fish.com\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_invalid_attrs(self):\n        \"\"\"do remove un-approved attributes\"\"\"\n        input_text = '<a href=\"fish.com\" fish=\"hello\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(output, '<a href=\"fish.com\">yes    </a> <i>html</i>')\n\n    def test_invalid_html(self):\n        \"\"\"don't allow malformed html\"\"\"\n        input_text = \"<b>yes  <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(\"<b>yes  <i>html</i></b>\", output)\n\n        input_text = \"yes <i></b>html   </i>\"\n        output = clean(input_text)\n        self.assertEqual(\"yes <i>html   </i>\", output)\n\n    def test_disallowed_html(self):\n        \"\"\"remove disallowed html but keep allowed html\"\"\"\n        input_text = \"<div>  yes <i>html</i></div>\"\n        output = clean(input_text)\n        self.assertEqual(\"  yes <i>html</i>\", output)\n", "patch": "@@ -1,7 +1,7 @@\n \"\"\" make sure only valid html gets to the app \"\"\"\n from django.test import TestCase\n \n-from bookwyrm.sanitize_html import InputHtmlParser\n+from bookwyrm.utils.sanitizer import clean\n \n \n class Sanitizer(TestCase):\n@@ -10,53 +10,39 @@ class Sanitizer(TestCase):\n     def test_no_html(self):\n         \"\"\"just text\"\"\"\n         input_text = \"no      html  \"\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n+        output = clean(input_text)\n         self.assertEqual(input_text, output)\n \n     def test_valid_html(self):\n         \"\"\"leave the html untouched\"\"\"\n         input_text = \"<b>yes    </b> <i>html</i>\"\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n+        output = clean(input_text)\n         self.assertEqual(input_text, output)\n \n     def test_valid_html_attrs(self):\n         \"\"\"and don't remove useful attributes\"\"\"\n         input_text = '<a href=\"fish.com\">yes    </a> <i>html</i>'\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n+        output = clean(input_text)\n         self.assertEqual(input_text, output)\n \n     def test_valid_html_invalid_attrs(self):\n         \"\"\"do remove un-approved attributes\"\"\"\n         input_text = '<a href=\"fish.com\" fish=\"hello\">yes    </a> <i>html</i>'\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n+        output = clean(input_text)\n         self.assertEqual(output, '<a href=\"fish.com\">yes    </a> <i>html</i>')\n \n     def test_invalid_html(self):\n-        \"\"\"remove all html when the html is malformed\"\"\"\n+        \"\"\"don't allow malformed html\"\"\"\n         input_text = \"<b>yes  <i>html</i>\"\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n-        self.assertEqual(\"yes  html\", output)\n+        output = clean(input_text)\n+        self.assertEqual(\"<b>yes  <i>html</i></b>\", output)\n \n         input_text = \"yes <i></b>html   </i>\"\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n-        self.assertEqual(\"yes html   \", output)\n+        output = clean(input_text)\n+        self.assertEqual(\"yes <i>html   </i>\", output)\n \n     def test_disallowed_html(self):\n         \"\"\"remove disallowed html but keep allowed html\"\"\"\n         input_text = \"<div>  yes <i>html</i></div>\"\n-        parser = InputHtmlParser()\n-        parser.feed(input_text)\n-        output = parser.get_output()\n+        output = clean(input_text)\n         self.assertEqual(\"  yes <i>html</i>\", output)", "file_path": "files/2022_7/333", "file_language": "py", "file_name": "bookwyrm/tests/test_sanitize_html.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class Sanitizer(TestCase):\n    \"\"\"sanitizer tests\"\"\"\n\n    def test_no_html(self):\n        \"\"\"just text\"\"\"\n        input_text = \"no      html  \"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html(self):\n        \"\"\"leave the html untouched\"\"\"\n        input_text = \"<b>yes    </b> <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_attrs(self):\n        \"\"\"and don't remove useful attributes\"\"\"\n        input_text = '<a href=\"fish.com\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_invalid_attrs(self):\n        \"\"\"do remove un-approved attributes\"\"\"\n        input_text = '<a href=\"fish.com\" fish=\"hello\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(output, '<a href=\"fish.com\">yes    </a> <i>html</i>')\n\n    def test_invalid_html(self):\n        \"\"\"don't allow malformed html\"\"\"\n        input_text = \"<b>yes  <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(\"<b>yes  <i>html</i></b>\", output)\n\n        input_text = \"yes <i></b>html   </i>\"\n        output = clean(input_text)\n        self.assertEqual(\"yes <i>html   </i>\", output)\n\n    def test_disallowed_html(self):\n        \"\"\"remove disallowed html but keep allowed html\"\"\"\n        input_text = \"<div>  yes <i>html</i></div>\"\n        output = clean(input_text)\n        self.assertEqual(\"  yes <i>html</i>\", output)", "target": 0}], "function_after": [{"function": "class Sanitizer(TestCase):\n    \"\"\"sanitizer tests\"\"\"\n\n    def test_no_html(self):\n        \"\"\"just text\"\"\"\n        input_text = \"no      html  \"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html(self):\n        \"\"\"leave the html untouched\"\"\"\n        input_text = \"<b>yes    </b> <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_attrs(self):\n        \"\"\"and don't remove useful attributes\"\"\"\n        input_text = '<a href=\"fish.com\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(input_text, output)\n\n    def test_valid_html_invalid_attrs(self):\n        \"\"\"do remove un-approved attributes\"\"\"\n        input_text = '<a href=\"fish.com\" fish=\"hello\">yes    </a> <i>html</i>'\n        output = clean(input_text)\n        self.assertEqual(output, '<a href=\"fish.com\">yes    </a> <i>html</i>')\n\n    def test_invalid_html(self):\n        \"\"\"don't allow malformed html\"\"\"\n        input_text = \"<b>yes  <i>html</i>\"\n        output = clean(input_text)\n        self.assertEqual(\"<b>yes  <i>html</i></b>\", output)\n\n        input_text = \"yes <i></b>html   </i>\"\n        output = clean(input_text)\n        self.assertEqual(\"yes <i>html   </i>\", output)\n\n    def test_disallowed_html(self):\n        \"\"\"remove disallowed html but keep allowed html\"\"\"\n        input_text = \"<div>  yes <i>html</i></div>\"\n        output = clean(input_text)\n        self.assertEqual(\"  yes <i>html</i>\", output)", "target": 0}]}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Futils%2Fsanitizer.py", "code": "\"\"\"Clean user-provided text\"\"\"\nimport bleach\n\n\ndef clean(input_text):\n    \"\"\"Run through \"bleach\" \"\"\"\n    return bleach.clean(\n        input_text,\n        tags=[\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ],\n        attributes=[\"href\", \"rel\", \"src\", \"alt\"],\n        strip=True,\n    )\n", "code_before": "\"\"\"Clean user-provided text\"\"\"\nimport bleach\n\n\ndef clean(input_text):\n    \"\"\"Run through \"bleach\" \"\"\"\n    return bleach.clean(\n        input_text,\n        tags=[\n            \"p\",\n            \"blockquote\",\n            \"br\",\n            \"b\",\n            \"i\",\n            \"strong\",\n            \"em\",\n            \"pre\",\n            \"a\",\n            \"span\",\n            \"ul\",\n            \"ol\",\n            \"li\",\n        ],\n        attributes=[\"href\", \"rel\", \"src\", \"alt\"],\n        strip=True,\n    )\n", "patch": "@@ -0,0 +1,26 @@\n+\"\"\"Clean user-provided text\"\"\"\n+import bleach\n+\n+\n+def clean(input_text):\n+    \"\"\"Run through \"bleach\" \"\"\"\n+    return bleach.clean(\n+        input_text,\n+        tags=[\n+            \"p\",\n+            \"blockquote\",\n+            \"br\",\n+            \"b\",\n+            \"i\",\n+            \"strong\",\n+            \"em\",\n+            \"pre\",\n+            \"a\",\n+            \"span\",\n+            \"ul\",\n+            \"ol\",\n+            \"li\",\n+        ],\n+        attributes=[\"href\", \"rel\", \"src\", \"alt\"],\n+        strip=True,\n+    )", "file_path": "files/2022_7/334", "file_language": "py", "file_name": "bookwyrm/utils/sanitizer.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/bookwyrm%2Fviews%2Fstatus.py", "code": "\"\"\" what are we here for if not for posting \"\"\"\nimport re\nimport logging\nfrom urllib.parse import urlparse\n\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.validators import URLValidator\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse, HttpResponseBadRequest, Http404\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.template.response import TemplateResponse\nfrom django.utils import timezone\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django.views.decorators.http import require_POST\n\nfrom markdown import markdown\nfrom bookwyrm import forms, models\nfrom bookwyrm.settings import DOMAIN\nfrom bookwyrm.utils import regex, sanitizer\nfrom .helpers import handle_remote_webfinger, is_api_request\nfrom .helpers import load_date_in_user_tz_as_utc\n\nlogger = logging.getLogger(__name__)\n\n\n# pylint: disable= no-self-use\n@method_decorator(login_required, name=\"dispatch\")\nclass EditStatus(View):\n    \"\"\"the view for *posting*\"\"\"\n\n    def get(self, request, status_id):  # pylint: disable=unused-argument\n        \"\"\"load the edit panel\"\"\"\n        status = get_object_or_404(\n            models.Status.objects.select_subclasses(), id=status_id\n        )\n        status.raise_not_editable(request.user)\n\n        status_type = \"reply\" if status.reply_parent else status.status_type.lower()\n        data = {\n            \"type\": status_type,\n            \"book\": getattr(status, \"book\", None),\n            \"draft\": status,\n        }\n        return TemplateResponse(request, \"compose.html\", data)\n\n\n# pylint: disable= no-self-use\n@method_decorator(login_required, name=\"dispatch\")\nclass CreateStatus(View):\n    \"\"\"the view for *posting*\"\"\"\n\n    def get(self, request, status_type):  # pylint: disable=unused-argument\n        \"\"\"compose view (...not used?)\"\"\"\n        book = get_object_or_404(models.Edition, id=request.GET.get(\"book\"))\n        data = {\"book\": book}\n        return TemplateResponse(request, \"compose.html\", data)\n\n    # pylint: disable=too-many-branches\n    def post(self, request, status_type, existing_status_id=None):\n        \"\"\"create status of whatever type\"\"\"\n        created = not existing_status_id\n        existing_status = None\n        if existing_status_id:\n            existing_status = get_object_or_404(\n                models.Status.objects.select_subclasses(), id=existing_status_id\n            )\n            existing_status.raise_not_editable(request.user)\n            existing_status.edited_date = timezone.now()\n\n        status_type = status_type[0].upper() + status_type[1:]\n\n        try:\n            form = getattr(forms, f\"{status_type}Form\")(\n                request.POST, instance=existing_status\n            )\n        except AttributeError as err:\n            logger.exception(err)\n            return HttpResponseBadRequest()\n\n        if not form.is_valid():\n            if is_api_request(request):\n                logger.exception(form.errors)\n                return HttpResponseBadRequest()\n            return redirect(request.headers.get(\"Referer\", \"/\"))\n\n        status = form.save(commit=False)\n        # save the plain, unformatted version of the status for future editing\n        status.raw_content = status.content\n        if hasattr(status, \"quote\"):\n            status.raw_quote = status.quote\n\n        status.sensitive = status.content_warning not in [None, \"\"]\n        status.save(broadcast=False)\n\n        # inspect the text for user tags\n        content = status.content\n        for (mention_text, mention_user) in find_mentions(content):\n            # add them to status mentions fk\n            status.mention_users.add(mention_user)\n\n            # turn the mention into a link\n            content = re.sub(\n                rf\"{mention_text}([^@]|$)\",\n                rf'<a href=\"{mention_user.remote_id}\">{mention_text}</a>\\g<1>',\n                content,\n            )\n        # add reply parent to mentions\n        if status.reply_parent:\n            status.mention_users.add(status.reply_parent.user)\n\n        # deduplicate mentions\n        status.mention_users.set(set(status.mention_users.all()))\n\n        # don't apply formatting to generated notes\n        if not isinstance(status, models.GeneratedNote) and content:\n            status.content = to_markdown(content)\n        # do apply formatting to quotes\n        if hasattr(status, \"quote\"):\n            status.quote = to_markdown(status.quote)\n\n        status.save(created=created)\n\n        # update a readthrough, if needed\n        if bool(request.POST.get(\"id\")):\n            try:\n                edit_readthrough(request)\n            except Http404:\n                pass\n\n        if is_api_request(request):\n            return HttpResponse()\n        return redirect(\"/\")\n\n\n@method_decorator(login_required, name=\"dispatch\")\nclass DeleteStatus(View):\n    \"\"\"tombstone that bad boy\"\"\"\n\n    def post(self, request, status_id):\n        \"\"\"delete and tombstone a status\"\"\"\n        status = get_object_or_404(models.Status, id=status_id)\n\n        # don't let people delete other people's statuses\n        status.raise_not_deletable(request.user)\n\n        # perform deletion\n        status.delete()\n        return redirect(request.headers.get(\"Referer\", \"/\"))\n\n\n@login_required\n@require_POST\ndef update_progress(request, book_id):  # pylint: disable=unused-argument\n    \"\"\"Either it's just a progress update, or it's a comment with a progress update\"\"\"\n    if request.POST.get(\"post-status\"):\n        return CreateStatus.as_view()(request, \"comment\")\n    return edit_readthrough(request)\n\n\n@login_required\n@require_POST\ndef edit_readthrough(request):\n    \"\"\"can't use the form because the dates are too finnicky\"\"\"\n    # TODO: remove this, it duplicates the code in the ReadThrough view\n    readthrough = get_object_or_404(models.ReadThrough, id=request.POST.get(\"id\"))\n    readthrough.raise_not_editable(request.user)\n\n    readthrough.start_date = load_date_in_user_tz_as_utc(\n        request.POST.get(\"start_date\"), request.user\n    )\n    readthrough.finish_date = load_date_in_user_tz_as_utc(\n        request.POST.get(\"finish_date\"), request.user\n    )\n\n    progress = request.POST.get(\"progress\")\n    try:\n        progress = int(progress)\n        readthrough.progress = progress\n    except (ValueError, TypeError):\n        pass\n\n    progress_mode = request.POST.get(\"progress_mode\")\n    try:\n        progress_mode = models.ProgressMode(progress_mode)\n        readthrough.progress_mode = progress_mode\n    except ValueError:\n        pass\n\n    readthrough.save()\n\n    # record the progress update individually\n    # use default now for date field\n    readthrough.create_update()\n\n    if is_api_request(request):\n        return HttpResponse()\n    return redirect(request.headers.get(\"Referer\", \"/\"))\n\n\ndef find_mentions(content):\n    \"\"\"detect @mentions in raw status content\"\"\"\n    if not content:\n        return\n    for match in re.finditer(regex.STRICT_USERNAME, content):\n        username = match.group().strip().split(\"@\")[1:]\n        if len(username) == 1:\n            # this looks like a local user (@user), fill in the domain\n            username.append(DOMAIN)\n        username = \"@\".join(username)\n\n        mention_user = handle_remote_webfinger(username)\n        if not mention_user:\n            # we can ignore users we don't know about\n            continue\n        yield (match.group(), mention_user)\n\n\ndef format_links(content):\n    \"\"\"detect and format links\"\"\"\n    validator = URLValidator()\n    formatted_content = \"\"\n    split_content = re.split(r\"(\\s+)\", content)\n\n    for potential_link in split_content:\n        if not potential_link:\n            continue\n        wrapped = _wrapped(potential_link)\n        if wrapped:\n            wrapper_close = potential_link[-1]\n            formatted_content += potential_link[0]\n            potential_link = potential_link[1:-1]\n\n        try:\n            # raises an error on anything that's not a valid link\n            validator(potential_link)\n\n            # use everything but the scheme in the presentation of the link\n            url = urlparse(potential_link)\n            link = url.netloc + url.path + url.params\n            if url.query != \"\":\n                link += \"?\" + url.query\n            if url.fragment != \"\":\n                link += \"#\" + url.fragment\n\n            formatted_content += f'<a href=\"{potential_link}\">{link}</a>'\n        except (ValidationError, UnicodeError):\n            formatted_content += potential_link\n\n        if wrapped:\n            formatted_content += wrapper_close\n\n    return formatted_content\n\n\ndef _wrapped(text):\n    \"\"\"check if a line of text is wrapped\"\"\"\n    wrappers = [(\"(\", \")\"), (\"[\", \"]\"), (\"{\", \"}\")]\n    for wrapper in wrappers:\n        if text[0] == wrapper[0] and text[-1] == wrapper[-1]:\n            return True\n    return False\n\n\ndef to_markdown(content):\n    \"\"\"catch links and convert to markdown\"\"\"\n    content = format_links(content)\n    content = markdown(content)\n    # sanitize resulting html\n    return sanitizer.clean(content)\n", "code_before": "\"\"\" what are we here for if not for posting \"\"\"\nimport re\nimport logging\nfrom urllib.parse import urlparse\n\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.validators import URLValidator\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse, HttpResponseBadRequest, Http404\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.template.response import TemplateResponse\nfrom django.utils import timezone\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\nfrom django.views.decorators.http import require_POST\n\nfrom markdown import markdown\nfrom bookwyrm import forms, models\nfrom bookwyrm.settings import DOMAIN\nfrom bookwyrm.utils import regex, sanitizer\nfrom .helpers import handle_remote_webfinger, is_api_request\nfrom .helpers import load_date_in_user_tz_as_utc\n\nlogger = logging.getLogger(__name__)\n\n\n# pylint: disable= no-self-use\n@method_decorator(login_required, name=\"dispatch\")\nclass EditStatus(View):\n    \"\"\"the view for *posting*\"\"\"\n\n    def get(self, request, status_id):  # pylint: disable=unused-argument\n        \"\"\"load the edit panel\"\"\"\n        status = get_object_or_404(\n            models.Status.objects.select_subclasses(), id=status_id\n        )\n        status.raise_not_editable(request.user)\n\n        status_type = \"reply\" if status.reply_parent else status.status_type.lower()\n        data = {\n            \"type\": status_type,\n            \"book\": getattr(status, \"book\", None),\n            \"draft\": status,\n        }\n        return TemplateResponse(request, \"compose.html\", data)\n\n\n# pylint: disable= no-self-use\n@method_decorator(login_required, name=\"dispatch\")\nclass CreateStatus(View):\n    \"\"\"the view for *posting*\"\"\"\n\n    def get(self, request, status_type):  # pylint: disable=unused-argument\n        \"\"\"compose view (...not used?)\"\"\"\n        book = get_object_or_404(models.Edition, id=request.GET.get(\"book\"))\n        data = {\"book\": book}\n        return TemplateResponse(request, \"compose.html\", data)\n\n    # pylint: disable=too-many-branches\n    def post(self, request, status_type, existing_status_id=None):\n        \"\"\"create status of whatever type\"\"\"\n        created = not existing_status_id\n        existing_status = None\n        if existing_status_id:\n            existing_status = get_object_or_404(\n                models.Status.objects.select_subclasses(), id=existing_status_id\n            )\n            existing_status.raise_not_editable(request.user)\n            existing_status.edited_date = timezone.now()\n\n        status_type = status_type[0].upper() + status_type[1:]\n\n        try:\n            form = getattr(forms, f\"{status_type}Form\")(\n                request.POST, instance=existing_status\n            )\n        except AttributeError as err:\n            logger.exception(err)\n            return HttpResponseBadRequest()\n\n        if not form.is_valid():\n            if is_api_request(request):\n                logger.exception(form.errors)\n                return HttpResponseBadRequest()\n            return redirect(request.headers.get(\"Referer\", \"/\"))\n\n        status = form.save(commit=False)\n        # save the plain, unformatted version of the status for future editing\n        status.raw_content = status.content\n        if hasattr(status, \"quote\"):\n            status.raw_quote = status.quote\n\n        status.sensitive = status.content_warning not in [None, \"\"]\n        status.save(broadcast=False)\n\n        # inspect the text for user tags\n        content = status.content\n        for (mention_text, mention_user) in find_mentions(content):\n            # add them to status mentions fk\n            status.mention_users.add(mention_user)\n\n            # turn the mention into a link\n            content = re.sub(\n                rf\"{mention_text}([^@]|$)\",\n                rf'<a href=\"{mention_user.remote_id}\">{mention_text}</a>\\g<1>',\n                content,\n            )\n        # add reply parent to mentions\n        if status.reply_parent:\n            status.mention_users.add(status.reply_parent.user)\n\n        # deduplicate mentions\n        status.mention_users.set(set(status.mention_users.all()))\n\n        # don't apply formatting to generated notes\n        if not isinstance(status, models.GeneratedNote) and content:\n            status.content = to_markdown(content)\n        # do apply formatting to quotes\n        if hasattr(status, \"quote\"):\n            status.quote = to_markdown(status.quote)\n\n        status.save(created=created)\n\n        # update a readthrough, if needed\n        if bool(request.POST.get(\"id\")):\n            try:\n                edit_readthrough(request)\n            except Http404:\n                pass\n\n        if is_api_request(request):\n            return HttpResponse()\n        return redirect(\"/\")\n\n\n@method_decorator(login_required, name=\"dispatch\")\nclass DeleteStatus(View):\n    \"\"\"tombstone that bad boy\"\"\"\n\n    def post(self, request, status_id):\n        \"\"\"delete and tombstone a status\"\"\"\n        status = get_object_or_404(models.Status, id=status_id)\n\n        # don't let people delete other people's statuses\n        status.raise_not_deletable(request.user)\n\n        # perform deletion\n        status.delete()\n        return redirect(request.headers.get(\"Referer\", \"/\"))\n\n\n@login_required\n@require_POST\ndef update_progress(request, book_id):  # pylint: disable=unused-argument\n    \"\"\"Either it's just a progress update, or it's a comment with a progress update\"\"\"\n    if request.POST.get(\"post-status\"):\n        return CreateStatus.as_view()(request, \"comment\")\n    return edit_readthrough(request)\n\n\n@login_required\n@require_POST\ndef edit_readthrough(request):\n    \"\"\"can't use the form because the dates are too finnicky\"\"\"\n    # TODO: remove this, it duplicates the code in the ReadThrough view\n    readthrough = get_object_or_404(models.ReadThrough, id=request.POST.get(\"id\"))\n    readthrough.raise_not_editable(request.user)\n\n    readthrough.start_date = load_date_in_user_tz_as_utc(\n        request.POST.get(\"start_date\"), request.user\n    )\n    readthrough.finish_date = load_date_in_user_tz_as_utc(\n        request.POST.get(\"finish_date\"), request.user\n    )\n\n    progress = request.POST.get(\"progress\")\n    try:\n        progress = int(progress)\n        readthrough.progress = progress\n    except (ValueError, TypeError):\n        pass\n\n    progress_mode = request.POST.get(\"progress_mode\")\n    try:\n        progress_mode = models.ProgressMode(progress_mode)\n        readthrough.progress_mode = progress_mode\n    except ValueError:\n        pass\n\n    readthrough.save()\n\n    # record the progress update individually\n    # use default now for date field\n    readthrough.create_update()\n\n    if is_api_request(request):\n        return HttpResponse()\n    return redirect(request.headers.get(\"Referer\", \"/\"))\n\n\ndef find_mentions(content):\n    \"\"\"detect @mentions in raw status content\"\"\"\n    if not content:\n        return\n    for match in re.finditer(regex.STRICT_USERNAME, content):\n        username = match.group().strip().split(\"@\")[1:]\n        if len(username) == 1:\n            # this looks like a local user (@user), fill in the domain\n            username.append(DOMAIN)\n        username = \"@\".join(username)\n\n        mention_user = handle_remote_webfinger(username)\n        if not mention_user:\n            # we can ignore users we don't know about\n            continue\n        yield (match.group(), mention_user)\n\n\ndef format_links(content):\n    \"\"\"detect and format links\"\"\"\n    validator = URLValidator()\n    formatted_content = \"\"\n    split_content = re.split(r\"(\\s+)\", content)\n\n    for potential_link in split_content:\n        if not potential_link:\n            continue\n        wrapped = _wrapped(potential_link)\n        if wrapped:\n            wrapper_close = potential_link[-1]\n            formatted_content += potential_link[0]\n            potential_link = potential_link[1:-1]\n\n        try:\n            # raises an error on anything that's not a valid link\n            validator(potential_link)\n\n            # use everything but the scheme in the presentation of the link\n            url = urlparse(potential_link)\n            link = url.netloc + url.path + url.params\n            if url.query != \"\":\n                link += \"?\" + url.query\n            if url.fragment != \"\":\n                link += \"#\" + url.fragment\n\n            formatted_content += f'<a href=\"{potential_link}\">{link}</a>'\n        except (ValidationError, UnicodeError):\n            formatted_content += potential_link\n\n        if wrapped:\n            formatted_content += wrapper_close\n\n    return formatted_content\n\n\ndef _wrapped(text):\n    \"\"\"check if a line of text is wrapped\"\"\"\n    wrappers = [(\"(\", \")\"), (\"[\", \"]\"), (\"{\", \"}\")]\n    for wrapper in wrappers:\n        if text[0] == wrapper[0] and text[-1] == wrapper[-1]:\n            return True\n    return False\n\n\ndef to_markdown(content):\n    \"\"\"catch links and convert to markdown\"\"\"\n    content = format_links(content)\n    content = markdown(content)\n    # sanitize resulting html\n    return sanitizer.clean(content)\n", "patch": "@@ -16,9 +16,8 @@\n \n from markdown import markdown\n from bookwyrm import forms, models\n-from bookwyrm.sanitize_html import InputHtmlParser\n from bookwyrm.settings import DOMAIN\n-from bookwyrm.utils import regex\n+from bookwyrm.utils import regex, sanitizer\n from .helpers import handle_remote_webfinger, is_api_request\n from .helpers import load_date_in_user_tz_as_utc\n \n@@ -268,6 +267,4 @@ def to_markdown(content):\n     content = format_links(content)\n     content = markdown(content)\n     # sanitize resulting html\n-    sanitizer = InputHtmlParser()\n-    sanitizer.feed(content)\n-    return sanitizer.get_output()\n+    return sanitizer.clean(content)", "file_path": "files/2022_7/335", "file_language": "py", "file_name": "bookwyrm/views/status.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def find_mentions(content):\n    \"\"\"detect @mentions in raw status content\"\"\"\n    if not content:\n        return\n    for match in re.finditer(regex.STRICT_USERNAME, content):\n        username = match.group().strip().split(\"@\")[1:]\n        if len(username) == 1:\n            # this looks like a local user (@user), fill in the domain\n            username.append(DOMAIN)\n        username = \"@\".join(username)\n\n        mention_user = handle_remote_webfinger(username)\n        if not mention_user:\n            # we can ignore users we don't know about\n            continue\n        yield (match.group(), mention_user)", "target": 0}, {"function": "def format_links(content):\n    \"\"\"detect and format links\"\"\"\n    validator = URLValidator()\n    formatted_content = \"\"\n    split_content = re.split(r\"(\\s+)\", content)\n\n    for potential_link in split_content:\n        if not potential_link:\n            continue\n        wrapped = _wrapped(potential_link)\n        if wrapped:\n            wrapper_close = potential_link[-1]\n            formatted_content += potential_link[0]\n            potential_link = potential_link[1:-1]\n\n        try:\n            # raises an error on anything that's not a valid link\n            validator(potential_link)\n\n            # use everything but the scheme in the presentation of the link\n            url = urlparse(potential_link)\n            link = url.netloc + url.path + url.params\n            if url.query != \"\":\n                link += \"?\" + url.query\n            if url.fragment != \"\":\n                link += \"#\" + url.fragment\n\n            formatted_content += f'<a href=\"{potential_link}\">{link}</a>'\n        except (ValidationError, UnicodeError):\n            formatted_content += potential_link\n\n        if wrapped:\n            formatted_content += wrapper_close\n\n    return formatted_content", "target": 0}, {"function": "def _wrapped(text):\n    \"\"\"check if a line of text is wrapped\"\"\"\n    wrappers = [(\"(\", \")\"), (\"[\", \"]\"), (\"{\", \"}\")]\n    for wrapper in wrappers:\n        if text[0] == wrapper[0] and text[-1] == wrapper[-1]:\n            return True\n    return False", "target": 0}, {"function": "def to_markdown(content):\n    \"\"\"catch links and convert to markdown\"\"\"\n    content = format_links(content)\n    content = markdown(content)\n    # sanitize resulting html\n    return sanitizer.clean(content)", "target": 0}], "function_after": [{"function": "def find_mentions(content):\n    \"\"\"detect @mentions in raw status content\"\"\"\n    if not content:\n        return\n    for match in re.finditer(regex.STRICT_USERNAME, content):\n        username = match.group().strip().split(\"@\")[1:]\n        if len(username) == 1:\n            # this looks like a local user (@user), fill in the domain\n            username.append(DOMAIN)\n        username = \"@\".join(username)\n\n        mention_user = handle_remote_webfinger(username)\n        if not mention_user:\n            # we can ignore users we don't know about\n            continue\n        yield (match.group(), mention_user)", "target": 0}, {"function": "def format_links(content):\n    \"\"\"detect and format links\"\"\"\n    validator = URLValidator()\n    formatted_content = \"\"\n    split_content = re.split(r\"(\\s+)\", content)\n\n    for potential_link in split_content:\n        if not potential_link:\n            continue\n        wrapped = _wrapped(potential_link)\n        if wrapped:\n            wrapper_close = potential_link[-1]\n            formatted_content += potential_link[0]\n            potential_link = potential_link[1:-1]\n\n        try:\n            # raises an error on anything that's not a valid link\n            validator(potential_link)\n\n            # use everything but the scheme in the presentation of the link\n            url = urlparse(potential_link)\n            link = url.netloc + url.path + url.params\n            if url.query != \"\":\n                link += \"?\" + url.query\n            if url.fragment != \"\":\n                link += \"#\" + url.fragment\n\n            formatted_content += f'<a href=\"{potential_link}\">{link}</a>'\n        except (ValidationError, UnicodeError):\n            formatted_content += potential_link\n\n        if wrapped:\n            formatted_content += wrapper_close\n\n    return formatted_content", "target": 0}, {"function": "def _wrapped(text):\n    \"\"\"check if a line of text is wrapped\"\"\"\n    wrappers = [(\"(\", \")\"), (\"[\", \"]\"), (\"{\", \"}\")]\n    for wrapper in wrappers:\n        if text[0] == wrapper[0] and text[-1] == wrapper[-1]:\n            return True\n    return False", "target": 0}, {"function": "def to_markdown(content):\n    \"\"\"catch links and convert to markdown\"\"\"\n    content = format_links(content)\n    content = markdown(content)\n    # sanitize resulting html\n    return sanitizer.clean(content)", "target": 0}]}, {"raw_url": "https://github.com/bookwyrm-social/bookwyrm/raw/fe33fdcf564a6a5667aef75d5456bea08feab50d/requirements.txt", "code": "aiohttp==3.8.1\nbleach==5.0.1\ncelery==5.2.2\ncolorthief==0.2.1\nDjango==3.2.13\ndjango-celery-beat==2.2.1\ndjango-compressor==2.4.1\ndjango-imagekit==4.1.0\ndjango-model-utils==4.0.0\ndjango-sass-processor==1.0.1\nenvirons==9.3.4\nflower==1.0.0\nlibsass==0.21.0\nMarkdown==3.3.3\nPillow>=9.0.0\npsycopg2==2.8.4\npycryptodome==3.9.4\npython-dateutil==2.8.1\nredis==3.4.1\nrequests==2.22.0\nresponses==0.10.14\npytz>=2021.1\nboto3==1.17.88\ndjango-storages==1.11.1\ndjango-redis==5.2.0\nopentelemetry-api==1.8.0\nopentelemetry-sdk==1.8.0\nopentelemetry-exporter-otlp-proto-grpc==1.8.0\nopentelemetry-instrumentation-django==0.27b0\nopentelemetry-instrumentation-celery==0.27b0\n\n# Dev\npytest-django==4.1.0\npytest==6.1.2\npytest-cov==2.10.1\npytest-env==0.6.2\npytest-xdist==2.3.0\npytidylib==0.3.2\npylint==2.14.0\n", "code_before": "aiohttp==3.8.1\nbleach==5.0.1\ncelery==5.2.2\ncolorthief==0.2.1\nDjango==3.2.13\ndjango-celery-beat==2.2.1\ndjango-compressor==2.4.1\ndjango-imagekit==4.1.0\ndjango-model-utils==4.0.0\ndjango-sass-processor==1.0.1\nenvirons==9.3.4\nflower==1.0.0\nlibsass==0.21.0\nMarkdown==3.3.3\nPillow>=9.0.0\npsycopg2==2.8.4\npycryptodome==3.9.4\npython-dateutil==2.8.1\nredis==3.4.1\nrequests==2.22.0\nresponses==0.10.14\npytz>=2021.1\nboto3==1.17.88\ndjango-storages==1.11.1\ndjango-redis==5.2.0\nopentelemetry-api==1.8.0\nopentelemetry-sdk==1.8.0\nopentelemetry-exporter-otlp-proto-grpc==1.8.0\nopentelemetry-instrumentation-django==0.27b0\nopentelemetry-instrumentation-celery==0.27b0\n\n# Dev\npytest-django==4.1.0\npytest==6.1.2\npytest-cov==2.10.1\npytest-env==0.6.2\npytest-xdist==2.3.0\npytidylib==0.3.2\npylint==2.14.0\n", "patch": "@@ -1,4 +1,5 @@\n aiohttp==3.8.1\n+bleach==5.0.1\n celery==5.2.2\n colorthief==0.2.1\n Django==3.2.13", "file_path": "files/2022_7/336", "file_language": "txt", "file_name": "requirements.txt", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
