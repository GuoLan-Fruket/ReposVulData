{"index": 6634, "cve_id": "CVE-2021-42134", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "The Unicorn framework before 0.36.1 for Django allows XSS via a component. NOTE: this issue exists because of an incomplete fix for CVE-2021-42053.", "cvss": "6.1", "publish_date": "October 10, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "3a832a9e3f6455ddd3b87f646247269918ad10c6", "commit_message": "More complete handling for preventing XSS attacks.", "commit_date": "2021-10-09T02:09:35Z", "project": "adamghill/django-unicorn", "url": "https://api.github.com/repos/adamghill/django-unicorn/commits/3a832a9e3f6455ddd3b87f646247269918ad10c6", "html_url": "https://github.com/adamghill/django-unicorn/commit/3a832a9e3f6455ddd3b87f646247269918ad10c6", "windows_before": [{"commit_id": "a28a81cde59e9e91412394196303912acdff2b31", "commit_date": "Thu Oct 7 23:01:01 2021 -0400", "commit_message": "Fix tests for nicer error messages.", "files_name": ["django_unicorn/components/unicorn_view.py", "tests/views/message/test_message.py"]}, {"commit_id": "ab6be5e1e742df4ac5dbb19da29e06a0d41118c4", "commit_date": "Thu Oct 7 21:32:46 2021 -0400", "commit_message": "Update changelog.", "files_name": ["django_unicorn/CHANGELOG.md"]}, {"commit_id": "64b51389d66f6f17d67e9a01120b3b5bf276dca0", "commit_date": "Thu Oct 7 21:20:42 2021 -0400", "commit_message": "Merge branch 'master' of github.com:adamghill/django-unicorn", "files_name": ["68591f08ef830de96e77a89819715bb6d7cee97e - Fri Sep 24 13:03:21 2021 +0200 : show underlying error when component is not picklable", "django_unicorn/utils.py"]}, {"commit_id": "361fb1c0a0c6dfc8991f574b8705416b1a389319", "commit_date": "Sat Sep 18 11:22:24 2021 +0200", "commit_message": "be more verbose when components can't be loaded", "files_name": ["django_unicorn/components/unicorn_view.py"]}, {"commit_id": "3b86d1c269a5bfb0ee8db41183675194c50dfb2e", "commit_date": "Thu Oct 7 19:13:18 2021 -0400", "commit_message": "Bump to 0.36.0.", "files_name": ["pyproject.toml"]}, {"commit_id": "aa5b9835d946bd9893ef02e556859e3ea62cc5e2", "commit_date": "Sun Oct 3 18:48:29 2021 -0400", "commit_message": "Escape component values.", "files_name": ["django_unicorn/components/unicorn_view.py", "django_unicorn/utils.py", "tests/components/test_component.py"]}, {"commit_id": "b11b4c121b5684b042b46a88a1266e0326d64cc5", "commit_date": "Wed Sep 15 22:26:25 2021 -0400", "commit_message": "Re-format for `black`.", "files_name": ["tests/components/test_get_locations.py"]}, {"commit_id": "9c19071eb3b829000572d5d1965d71d64de0f6ca", "commit_date": "Wed Sep 15 22:15:49 2021 -0400", "commit_message": "Bump version to 0.35.3.", "files_name": ["pyproject.toml"]}, {"commit_id": "8465100e1b111e9ee8b74dcea6552036f5c7dd43", "commit_date": "Thu Sep 16 02:13:01 2021 +0000", "commit_message": "docs: update .all-contributorsrc [skip ci]", "files_name": [".all-contributorsrc"]}, {"commit_id": "bca94c5b6d0a34abecfc03c53d415d18c8aa5371", "commit_date": "Thu Sep 16 02:13:00 2021 +0000", "commit_message": "docs: update README.md [skip ci]", "files_name": ["README.md"]}, {"commit_id": "5064af1c6e3a4a7a721aaf32124d0d5117861f6a", "commit_date": "Wed Sep 15 21:43:02 2021 -0400", "commit_message": "Bump to 0.35.2.", "files_name": ["django_unicorn/static/unicorn/js/unicorn.min.js", "pyproject.toml"]}, {"commit_id": "a9004e4a6e17b759885f9f445dbf58232cccdebb", "commit_date": "Wed Sep 15 21:41:49 2021 -0400", "commit_message": "Bump to 0.35.1.", "files_name": ["pyproject.toml"]}, {"commit_id": "ec1fffcd2cb2450bc8b39642ed8f96600bc46cb1", "commit_date": "Mon Sep 13 13:53:01 2021 +0530", "commit_message": "Use rindex when handling installed app that points to an app config", "files_name": ["django_unicorn/components/unicorn_view.py", "tests/components/test_get_locations.py"]}, {"commit_id": "2af6f731d52c8c836d6213d695439c0ea86f5a92", "commit_date": "Thu Sep 16 02:11:22 2021 +0000", "commit_message": "docs: update .all-contributorsrc [skip ci]", "files_name": [".all-contributorsrc"]}, {"commit_id": "5e9ed6e48696cbbdcae2cc0a6ded62bd0013df16", "commit_date": "Thu Sep 16 02:11:21 2021 +0000", "commit_message": "docs: update README.md [skip ci]", "files_name": ["README.md"]}, {"commit_id": "ee45c093e2ac8f81d5da37f7194cf1398235fed4", "commit_date": "Wed Sep 15 21:39:55 2021 -0400", "commit_message": "Check to see if visibility elements should be re-initialized.", "files_name": ["django_unicorn/static/unicorn/js/messageSender.js", "example/unicorn/components/js.py", "example/unicorn/templates/unicorn/js.html"]}, {"commit_id": "7fa885b8423f4772766649b042c45bf77fc8b54b", "commit_date": "Tue Sep 14 22:20:46 2021 -0400", "commit_message": "Re-init visibility elements after a component gets updated.", "files_name": ["django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/messageSender.js"]}, {"commit_id": "a06e94a0674f111977879b5142d9217b376881c0", "commit_date": "Thu Sep 9 17:44:23 2021 -0400", "commit_message": "Bump version to 0.35.0.", "files_name": ["django_unicorn/static/unicorn/js/unicorn.min.js", "pyproject.toml"]}, {"commit_id": "44066424e019aad10792474b0284230f35bbe1f1", "commit_date": "Wed Sep 8 21:27:33 2021 -0400", "commit_message": "Call a method when an element becomes visible.", "files_name": ["django_unicorn/static/unicorn/js/attribute.js", "django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/element.js", "example/unicorn/components/js.py", "example/unicorn/templates/unicorn/js.html", "tests/js/element/visibility.test.js"]}, {"commit_id": "018f4a532d96eb8eab89e7d7a3bce3b5dded118f", "commit_date": "Mon Sep 6 16:13:07 2021 -0400", "commit_message": "Remove the legacy db model implementation.", "files_name": ["django_unicorn/decorators.py", "django_unicorn/static/unicorn/js/attribute.js", "django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/element.js", "django_unicorn/static/unicorn/js/eventListeners.js", "django_unicorn/static/unicorn/js/unicorn.js", "django_unicorn/static/unicorn/js/utils.js", "django_unicorn/views/__init__.py", "django_unicorn/views/action_parsers/db_input.py", "tests/decorators/test_db_model.py", "tests/js/element/action.test.js", "tests/views/message/test_db_input.py"]}, {"commit_id": "b90fa83bd80df8e3617c2ccd25ce07f47271cc2d", "commit_date": "Mon Sep 6 17:11:09 2021 -0400", "commit_message": "Update hello world component example.", "files_name": ["example/unicorn/components/hello_world.py", "example/unicorn/templates/unicorn/hello-world-test.html"]}, {"commit_id": "2d48fcaee581062c0e07a8eae97bec941db077e8", "commit_date": "Mon Sep 6 09:24:34 2021 -0400", "commit_message": "Trigger a component update by triggering an event for a model element.", "files_name": ["django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/unicorn.js", "tests/js/component/models.test.js"]}, {"commit_id": "bd7aed4639f0ce5f0dfc17b04ed6e30505a271b5", "commit_date": "Sat Aug 28 13:38:02 2021 -0400", "commit_message": "Bump version to 0.34.0.", "files_name": ["django_unicorn/static/unicorn/js/unicorn.min.js", "pyproject.toml"]}, {"commit_id": "6d72278c0f5d9feda161cc6760dd23d109d50eb5", "commit_date": "Sat Aug 28 13:33:04 2021 -0400", "commit_message": "Cache methods separately based on the type of the argument.", "files_name": ["django_unicorn/call_method_parser.py", "django_unicorn/serializer.py"]}, {"commit_id": "89ccff3ce40a5781a91abd5c20ad027cb1b2c028", "commit_date": "Sat Aug 14 09:55:13 2021 -0400", "commit_message": "Initial prototype for lifecycle events.", "files_name": ["django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/messageSender.js", "django_unicorn/static/unicorn/js/store.js", "django_unicorn/static/unicorn/js/unicorn.js", "example/unicorn/templates/unicorn/hello-world-test.html"]}, {"commit_id": "9f78a0db6d1e776ce36f765b537440e00af9b341", "commit_date": "Fri Aug 27 21:25:00 2021 -0400", "commit_message": "Add more urls.", "files_name": ["pyproject.toml"]}, {"commit_id": "91bff45fe8b9188f41143197d7ed4cc2e05967f7", "commit_date": "Sat Aug 28 01:21:32 2021 +0000", "commit_message": "docs: update .all-contributorsrc [skip ci]", "files_name": [".all-contributorsrc"]}, {"commit_id": "4e3227571cd7e8efd188a9c92f2e5231d7935cd5", "commit_date": "Sat Aug 28 01:21:31 2021 +0000", "commit_message": "docs: update README.md [skip ci]", "files_name": ["README.md"]}, {"commit_id": "a54cdaf933b7541601029aaa84e823af595e5c26", "commit_date": "Fri Aug 27 21:19:28 2021 -0400", "commit_message": "Merge remote-tracking branch 'joshiggins/filter-treewalker'", "files_name": ["f374165cff8720bf1597143d4bab0683ddfa8cea - Sun Aug 22 17:39:25 2021 -0400 : Add skipped test that is incomplete.", "tests/js/utils.js", "tests/js/utils/walk.test.js"]}, {"commit_id": "080e0be6ad9994c14f416def55653760fc4aea0d", "commit_date": "Sun Aug 22 17:39:11 2021 -0400", "commit_message": "Add button below nested component.", "files_name": ["example/unicorn/templates/unicorn/nested/table.html"]}, {"commit_id": "05fddce12b03d872d1687e9a6442c61cb33921e5", "commit_date": "Sun Aug 22 17:38:52 2021 -0400", "commit_message": "Slight formatting changes.", "files_name": ["django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/utils.js"]}, {"commit_id": "82fe61cd4383a10041acb1094d39a7695853c7d0", "commit_date": "Sun Aug 22 17:11:09 2021 +0100", "commit_message": "use filter to skip nested components in refreshEventListeners", "files_name": ["django_unicorn/static/unicorn/js/component.js"]}, {"commit_id": "634ae5569780b7373cbd766871035559f424bdab", "commit_date": "Sun Aug 22 17:06:48 2021 +0100", "commit_message": "add optional filter arg to utils.walk and two filters filter implements NodeFilter interface, default is FilterAny", "files_name": ["django_unicorn/static/unicorn/js/utils.js"]}, {"commit_id": "49eea6d576419c1492ee47c97e3c5071f68e366d", "commit_date": "Thu Aug 12 23:06:44 2021 -0400", "commit_message": "Bump to 0.33.0.", "files_name": ["pyproject.toml"]}, {"commit_id": "b6d5604770ec8f4c080cac3430da8a13b6e72eaa", "commit_date": "Thu Aug 12 22:58:02 2021 -0400", "commit_message": "Handle component templates with comments or blank strings before a root element.", "files_name": ["django_unicorn/components/unicorn_template_response.py", "django_unicorn/views/__init__.py", "example/unicorn/templates/unicorn/objects.html", "tests/components/test_unicorn_template_response.py"]}, {"commit_id": "c4e5ace2662ae96758f8429cbc36bac4a60d25d1", "commit_date": "Thu Aug 12 22:13:23 2021 -0400", "commit_message": "Bump version to 0.32.0.", "files_name": ["django_unicorn/static/unicorn/js/unicorn.min.js", "pyproject.toml"]}, {"commit_id": "7b8b07bdd67230ae0e4be873fc25e8275c5ffb96", "commit_date": "Thu Jul 22 20:02:00 2021 -0400", "commit_message": "Add `debounce` support to actions.", "files_name": ["django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/element.js", "django_unicorn/static/unicorn/js/eventListeners.js", "django_unicorn/static/unicorn/js/unicorn.js", "example/unicorn/templates/unicorn/objects.html", "tests/js/element/action.test.js"]}, {"commit_id": "3d4368499fe701e099840cf960580da688bd6fb9", "commit_date": "Sun Jul 11 21:45:43 2021 -0400", "commit_message": "Bump version to 0.31.0.", "files_name": ["pyproject.toml"]}, {"commit_id": "f0ecf5ed7b1b9cc481e9c159a113cccb6c7e70a4", "commit_date": "Sun Jul 11 16:27:33 2021 -0400", "commit_message": "Move static assets from `django_unicorn` to `unicorn`. https://github.com/adamghill/django-unicorn/issues/239", "files_name": ["django_unicorn/static/unicorn/js/.babelrc.json", "django_unicorn/static/unicorn/js/attribute.js", "django_unicorn/static/unicorn/js/component.js", "django_unicorn/static/unicorn/js/delayers.js", "django_unicorn/static/unicorn/js/element.js", "django_unicorn/static/unicorn/js/eventListeners.js", "django_unicorn/static/unicorn/js/messageSender.js", "django_unicorn/static/unicorn/js/morphdom/2.6.1/morphdom-umd.min.js", "django_unicorn/static/unicorn/js/morphdom/2.6.1/morphdom.js", "django_unicorn/static/unicorn/js/morphdom/2.6.1/options.js", "django_unicorn/static/unicorn/js/store.js", "django_unicorn/static/unicorn/js/unicorn.js", "django_unicorn/static/unicorn/js/unicorn.min.js", "django_unicorn/static/unicorn/js/utils.js", "django_unicorn/templates/unicorn/scripts.html", "rollup.config.js", "tests/js/component/actions.test.js", "tests/js/component/messageSender.test.js", "tests/js/unicorn/call.test.js", "tests/js/unicorn/getComponent.test.js", "tests/js/unicorn/init.test.js", "tests/js/utils.js", "tests/js/utils/args.test.js", "tests/js/utils/contains.test.js", "tests/js/utils/isEmpty.test.js"]}], "windows_after": [{"commit_id": "14c6e0a96c0bbfef1987613f022f8bd728b70f44", "commit_date": "Fri Oct 8 22:11:31 2021 -0400", "commit_message": "Bump to 0.36.1.", "files_name": ["pyproject.toml"]}, {"commit_id": "91539a656a532e0cb4ef68edf921c2c3b7d31a6a", "commit_date": "Fri Oct 8 22:21:21 2021 -0400", "commit_message": "Reformat with black.", "files_name": ["django_unicorn/utils.py"]}, {"commit_id": "175378c2ab4373ac204611b777fe3f86f4a56fc3", "commit_date": "Sat Oct 9 14:00:45 2021 +0000", "commit_message": "docs: update README.md [skip ci]", "files_name": ["README.md"]}, {"commit_id": "d5aa052227d0cea3513a5a16793c11a6e9ac27e4", "commit_date": "Sat Oct 9 14:00:46 2021 +0000", "commit_message": "docs: update .all-contributorsrc [skip ci]", "files_name": [".all-contributorsrc"]}, {"commit_id": "77582441ee4556652393e701152aab70adab95e7", "commit_date": "Sat Oct 9 10:04:52 2021 -0400", "commit_message": "Add changelog for 0.36.1.", "files_name": ["django_unicorn/CHANGELOG.md"]}, {"commit_id": "521b573cdea12a368310680e29be69dfee3dc065", "commit_date": "Mon Oct 25 21:23:26 2021 -0400", "commit_message": "Revert loading and dirty elements when there is a 304 or 500 from the server.", "files_name": ["django_unicorn/static/unicorn/js/element.js", "django_unicorn/static/unicorn/js/messageSender.js", "tests/js/element/action.test.js"]}, {"commit_id": "a1567596a68c2f189ccfd6cfb57e6749ae0e6838", "commit_date": "Mon Oct 25 21:42:57 2021 -0400", "commit_message": "Bump to 0.37.0.", "files_name": ["django_unicorn/static/unicorn/js/unicorn.min.js", "pyproject.toml"]}, {"commit_id": "dcfc8d63b7dc8a6d946e624fc707644d7dd25186", "commit_date": "Mon Oct 25 21:53:16 2021 -0400", "commit_message": "Update changelog.", "files_name": ["django_unicorn/CHANGELOG.md"]}, {"commit_id": "1b84d2d6a1f4fa4086668208d423b990efb767bc", "commit_date": "Sat Nov 20 16:48:37 2021 -0500", "commit_message": "Remove `playwright` because it it was never used for testing.", "files_name": ["package-lock.json", "package.json"]}, {"commit_id": "93fe3d2a6f746283f68ff083c43661b74f659ad0", "commit_date": "Sat Nov 20 16:48:59 2021 -0500", "commit_message": "Bump `orjson` to fix some installation issues.", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "ac05a04b43ea3b83cba1a36e449033f8b7b03d48", "commit_date": "Sat Nov 20 17:30:41 2021 -0500", "commit_message": "Be able to exclude attributes from JavaScript. Especially useful for preventing many-to-many fields from being re-created un-expectantly.", "files_name": ["django_unicorn/components/unicorn_view.py", "django_unicorn/serializer.py", "tests/serializer/test_dumps.py"]}, {"commit_id": "bc899510d7930f98a56dec74dd25be4e06fe8bfd", "commit_date": "Sat Nov 20 17:54:52 2021 -0500", "commit_message": "Bump required Python to 3.6.2 and `black`.", "files_name": ["poetry.lock", "pyproject.toml"]}, {"commit_id": "127b3c2f8248999a11cc88bc2a06d99cffe7c34a", "commit_date": "Sat Nov 20 19:38:40 2021 -0500", "commit_message": "Re-run `black` format.", "files_name": ["conftest.py", "django_unicorn/call_method_parser.py", "django_unicorn/components/unicorn_view.py", "django_unicorn/management/commands/startunicorn.py", "django_unicorn/utils.py", "django_unicorn/views/__init__.py", "django_unicorn/views/action_parsers/call_method.py", "django_unicorn/views/utils.py", "example/project/settings.py", "tests/call_method_parser/test_parse_call_method_name.py", "tests/components/test_get_locations.py", "tests/serializer/test_dumps.py", "tests/views/action_parsers/utils/test_set_property_value.py", "tests/views/message/test_call_method.py", "tests/views/message/test_call_method_multiple.py", "tests/views/message/test_calls.py", "tests/views/message/test_hash.py", "tests/views/message/test_set_property.py", "tests/views/message/test_sync_input.py", "tests/views/message/test_target.py", "tests/views/message/test_type_hints.py", "tests/views/message/utils.py", "tests/views/test_process_component_request.py", "tests/views/test_unicorn_set_property_value.py", "tests/views/utils/test_construct_model.py"]}, {"commit_id": "36cb9d2641a0a54a1676b410cf3d713f597300e8", "commit_date": "Sat Nov 20 19:41:21 2021 -0500", "commit_message": "`isort` for imports.", "files_name": ["django_unicorn/serializer.py"]}, {"commit_id": "75850a217e9ddf66c72d9c1f068c90d402e69ad6", "commit_date": "Sat Nov 20 19:41:43 2021 -0500", "commit_message": "Use `extend-exclude` instead of just `exclude` for black.", "files_name": [".github/workflows/python.yml"]}, {"commit_id": "bf5988fd29e92fcbb8883ddbdc5c15a2e613bd32", "commit_date": "Sun Nov 21 15:29:08 2021 -0500", "commit_message": "Bump version to 0.37.1.", "files_name": ["django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "3e1fa4b8845ddde3b602629663be10a39388b185", "commit_date": "Sun Nov 21 16:58:14 2021 -0500", "commit_message": "Update developing.md.", "files_name": ["DEVELOPING.md"]}, {"commit_id": "3047ae160fd087bcfd787410dcd648fb787ba7c7", "commit_date": "Sun Nov 21 19:26:54 2021 -0500", "commit_message": "Add tests for field attributes in `javascript_exclude`.", "files_name": ["django_unicorn/components/unicorn_view.py", "tests/components/test_component.py"]}, {"commit_id": "21ee16d219385d9014359f39013748442af3bc03", "commit_date": "Sun Nov 21 19:28:39 2021 -0500", "commit_message": "Bump to 0.37.2.", "files_name": ["django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "288448d9974b2664536a9f7cd7423b9d978f2490", "commit_date": "Sun Nov 21 18:32:31 2021 -0500", "commit_message": "Keep request context in unicorn component templates.", "files_name": ["conftest.py", "django_unicorn/components/unicorn_view.py", "django_unicorn/templatetags/unicorn.py", "example/unicorn/templates/unicorn/hello-world-test.html", "tests/templates/test_component_kwargs.html", "tests/templates/test_template.html", "tests/templatetags/test_unicorn_render.py", "tests/urls.py"]}, {"commit_id": "e184233a59c3d3d210f2270309a944a436260c57", "commit_date": "Sun Nov 21 19:30:33 2021 -0500", "commit_message": "Merge branch 'request-context'", "files_name": ["4c13834fd785f5d6bc9d4f70759823ec69637e59 - Sun Nov 21 19:37:57 2021 -0500 : Bump to 0.38.0.", "django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "4b79f488d9db1ff9a6ffc31a81d95492783e8e5b", "commit_date": "Sun Nov 21 22:58:39 2021 -0500", "commit_message": "Clear `extra_context` so that the component can be cached correctly.", "files_name": ["django_unicorn/utils.py", "tests/test_utils.py"]}, {"commit_id": "4212685942d64e8aca8fea80986e3d6779e9ff66", "commit_date": "Sun Nov 21 23:00:47 2021 -0500", "commit_message": "Bump to 0.38.1.", "files_name": ["django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "41ee601423a8d88f3a235866c76fdc0721268518", "commit_date": "Mon Nov 22 22:11:13 2021 -0500", "commit_message": "Raise exception when an invalid `exclude` or `javascript_exclude` is included.", "files_name": ["django_unicorn/components/unicorn_view.py", "django_unicorn/serializer.py", "django_unicorn/utils.py", "example/unicorn/components/models.py", "tests/components/test_component.py", "tests/serializer/test_dumps.py", "tests/test_utils.py"]}, {"commit_id": "4efce0d33e10d51d53ada59e131c43e8c9773589", "commit_date": "Wed Dec 1 21:10:06 2021 -0500", "commit_message": "Use `all` instead of `values_list` so that any data cached by `prefetch_related` will be re-used. https://github.com/adamghill/django-unicorn/issues/303", "files_name": ["django_unicorn/serializer.py"]}, {"commit_id": "d39e296818f6b821b41a9df31b778f60c9302f9e", "commit_date": "Thu Dec 2 22:21:44 2021 -0500", "commit_message": "Handle excluding many-to-many fields with `javascript_exclude`.", "files_name": ["django_unicorn/serializer.py", "tests/components/test_component.py", "tests/serializer/test_dumps.py"]}, {"commit_id": "c4f560d66c39fbfbfb43dce56f200ccdd7430f39", "commit_date": "Thu Dec 2 23:34:39 2021 -0500", "commit_message": "Bump to 0.39.0.", "files_name": ["django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "5c3e98f6c13a91a00d90dc07e0ad8cbf4135f89f", "commit_date": "Sat Dec 4 09:33:16 2021 -0500", "commit_message": "Make sure that many-to-many fields get excluded from JavaScript as expected.", "files_name": ["django_unicorn/serializer.py"]}, {"commit_id": "44930b18faa125cf4a835cdd218ab3f8f2e903cc", "commit_date": "Sat Dec 4 16:43:06 2021 -0500", "commit_message": "Remove excluding many-to-many functionality because handling this with prefetch is preferable.", "files_name": ["django_unicorn/serializer.py", "tests/serializer/test_dumps.py"]}, {"commit_id": "d77d48d3904bc7f64f9c43865fbdf7fe40fee790", "commit_date": "Sat Dec 4 16:49:13 2021 -0500", "commit_message": "Bump version to 0.39.1.", "files_name": ["django_unicorn/CHANGELOG.md"]}, {"commit_id": "2a27106479f33a8d6a114095639feeef7e51df70", "commit_date": "Sun Apr 11 19:03:42 2021 -0400", "commit_message": "Direct view lets components be included in urls with requiring to be included in a regular Django template.", "files_name": ["django_unicorn/components/unicorn_template_response.py", "django_unicorn/components/unicorn_view.py", "django_unicorn/errors.py", "django_unicorn/views/__init__.py", "example/unicorn/components/direct_view.py", "example/unicorn/templates/unicorn/direct-view.html", "example/www/templates/www/base.html", "example/www/urls.py", "tests/components/test_convert_to_dash_case.py", "tests/components/test_unicorn_template_response.py", "tests/templatetags/test_unicorn_render.py"]}, {"commit_id": "6e068538ca29a9f9f6f36c4d6c6a8c20e2a71b43", "commit_date": "Sat Dec 18 15:23:46 2021 -0500", "commit_message": "Add `DEFAULT_AUTO_FIELD` setting.", "files_name": ["example/project/settings.py"]}, {"commit_id": "47893a7d35c229052c09b5c1f4b503d2858af848", "commit_date": "Sun Dec 5 08:00:06 2021 -0500", "commit_message": "Actually bump version to 0.39.1.", "files_name": ["pyproject.toml"]}, {"commit_id": "e2af6433ad593aa7ab50b2e241285252307413af", "commit_date": "Sat Dec 18 16:41:59 2021 -0500", "commit_message": "Handle creating nested components from `startunicorn`. https://github.com/adamghill/django-unicorn/issues/299", "files_name": ["django_unicorn/management/commands/startunicorn.py"]}, {"commit_id": "5e9142b8a7e13b862ece419d567e805cc783b517", "commit_date": "Sat Dec 18 16:47:05 2021 -0500", "commit_message": "Bump versions.", "files_name": ["poetry.lock"]}, {"commit_id": "4f1ca05d3fd389b7196e37bd307d2d91b75404d7", "commit_date": "Sat Dec 18 17:01:51 2021 -0500", "commit_message": "Bump version to 0.40.0.", "files_name": ["django_unicorn/CHANGELOG.md", "pyproject.toml"]}, {"commit_id": "5c31533f72eacce0f1ca8ab535f45b518598f587", "commit_date": "Fri Dec 17 10:25:21 2021 +0100", "commit_message": "feature: #235 Allow dynamic component parameter", "files_name": ["django_unicorn/templatetags/unicorn.py"]}, {"commit_id": "c52972a7fcc653f089c831f577d69376f612dfe3", "commit_date": "Mon Dec 20 09:59:51 2021 +0100", "commit_message": "test: Add test with context variable", "files_name": ["tests/templatetags/test_unicorn.py", "tests/templatetags/test_unicorn_render.py"]}, {"commit_id": "b045f1a978db613edd5864a9ee2ee105e4b4d140", "commit_date": "Wed Dec 22 19:30:53 2021 -0500", "commit_message": "Raise explicit error if the component name cannot be resolved from the context.", "files_name": ["django_unicorn/errors.py", "django_unicorn/templatetags/unicorn.py", "tests/templatetags/test_unicorn_render.py"]}], "parents": [{"commit_id_before": "a28a81cde59e9e91412394196303912acdff2b31", "url_before": "https://api.github.com/repos/adamghill/django-unicorn/commits/a28a81cde59e9e91412394196303912acdff2b31", "html_url_before": "https://github.com/adamghill/django-unicorn/commit/a28a81cde59e9e91412394196303912acdff2b31"}], "details": [{"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/django_unicorn%2Fcomponents%2Funicorn_template_response.py", "code": "import logging\n\nfrom django.template.response import TemplateResponse\n\nimport orjson\nfrom bs4 import BeautifulSoup\nfrom bs4.dammit import EntitySubstitution\nfrom bs4.element import Tag\nfrom bs4.formatter import HTMLFormatter\n\nfrom django_unicorn.utils import sanitize_html\n\nfrom ..decorators import timed\nfrom ..utils import generate_checksum\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnsortedAttributes(HTMLFormatter):\n    \"\"\"\n    Prevent beautifulsoup from re-ordering attributes.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(entity_substitution=EntitySubstitution.substitute_html)\n\n    def attributes(self, tag: Tag):\n        for k, v in tag.attrs.items():\n            yield k, v\n\n\nclass UnicornTemplateResponse(TemplateResponse):\n    def __init__(\n        self,\n        template,\n        request,\n        context=None,\n        content_type=None,\n        status=None,\n        charset=None,\n        using=None,\n        component=None,\n        init_js=False,\n        **kwargs,\n    ):\n        super().__init__(\n            template=template,\n            request=request,\n            context=context,\n            content_type=content_type,\n            status=status,\n            charset=charset,\n            using=using,\n        )\n\n        self.component = component\n        self.init_js = init_js\n\n    @timed\n    def render(self):\n        response = super().render()\n\n        if not self.component or not self.component.component_id:\n            return response\n\n        content = response.content.decode(\"utf-8\")\n\n        frontend_context_variables = self.component.get_frontend_context_variables()\n        frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n        checksum = generate_checksum(orjson.dumps(frontend_context_variables_dict))\n\n        soup = BeautifulSoup(content, features=\"html.parser\")\n        root_element = get_root_element(soup)\n        root_element[\"unicorn:id\"] = self.component.component_id\n        root_element[\"unicorn:name\"] = self.component.component_name\n        root_element[\"unicorn:key\"] = self.component.component_key\n        root_element[\"unicorn:checksum\"] = checksum\n\n        # Generate the hash based on the rendered content (without script tag)\n        hash = generate_checksum(UnicornTemplateResponse._desoupify(soup))\n\n        if self.init_js:\n            init = {\n                \"id\": self.component.component_id,\n                \"name\": self.component.component_name,\n                \"key\": self.component.component_key,\n                \"data\": orjson.loads(frontend_context_variables),\n                \"calls\": self.component.calls,\n                \"hash\": hash,\n            }\n            init = orjson.dumps(init).decode(\"utf-8\")\n            json_element_id = f\"unicorn:data:{self.component.component_id}\"\n            init_script = f\"Unicorn.componentInit(JSON.parse(document.getElementById('{json_element_id}').textContent));\"\n\n            json_tag = soup.new_tag(\"script\")\n            json_tag[\"type\"] = \"application/json\"\n            json_tag[\"id\"] = json_element_id\n            json_tag.string = sanitize_html(init)\n\n            if self.component.parent:\n                self.component._init_script = init_script\n                self.component._json_tag = json_tag\n            else:\n                json_tags = []\n                json_tags.append(json_tag)\n\n                for child in self.component.children:\n                    init_script = f\"{init_script} {child._init_script}\"\n                    json_tags.append(child._json_tag)\n\n                script_tag = soup.new_tag(\"script\")\n                script_tag[\"type\"] = \"module\"\n                script_tag.string = f\"if (typeof Unicorn === 'undefined') {{ console.error('Unicorn is missing. Do you need {{% load unicorn %}} or {{% unicorn_scripts %}}?') }} else {{ {init_script} }}\"\n                root_element.insert_after(script_tag)\n\n                for t in json_tags:\n                    root_element.insert_after(t)\n\n        rendered_template = UnicornTemplateResponse._desoupify(soup)\n        self.component.rendered(rendered_template)\n\n        response.content = rendered_template\n\n        return response\n\n    @staticmethod\n    def _desoupify(soup):\n        soup.smooth()\n        return soup.encode(formatter=UnsortedAttributes()).decode(\"utf-8\")\n\n\ndef get_root_element(soup: BeautifulSoup) -> Tag:\n    \"\"\"\n    Gets the first tag element.\n\n    Returns:\n        BeautifulSoup tag element.\n\n        Raises an Exception if an element cannot be found.\n    \"\"\"\n    for element in soup.contents:\n        if isinstance(element, Tag) and element.name:\n            return element\n\n    raise Exception(\"No root element found\")\n", "code_before": "import logging\n\nfrom django.template.response import TemplateResponse\nfrom django.utils.safestring import mark_safe\n\nimport orjson\nfrom bs4 import BeautifulSoup\nfrom bs4.element import Tag\nfrom bs4.formatter import HTMLFormatter\n\nfrom django_unicorn.utils import sanitize_html\n\nfrom ..decorators import timed\nfrom ..utils import generate_checksum\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnsortedAttributes(HTMLFormatter):\n    \"\"\"\n    Prevent beautifulsoup from re-ordering attributes.\n    \"\"\"\n\n    def attributes(self, tag: Tag):\n        for k, v in tag.attrs.items():\n            yield k, v\n\n\nclass UnicornTemplateResponse(TemplateResponse):\n    def __init__(\n        self,\n        template,\n        request,\n        context=None,\n        content_type=None,\n        status=None,\n        charset=None,\n        using=None,\n        component=None,\n        init_js=False,\n        **kwargs,\n    ):\n        super().__init__(\n            template=template,\n            request=request,\n            context=context,\n            content_type=content_type,\n            status=status,\n            charset=charset,\n            using=using,\n        )\n\n        self.component = component\n        self.init_js = init_js\n\n    @timed\n    def render(self):\n        response = super().render()\n\n        if not self.component or not self.component.component_id:\n            return response\n\n        content = response.content.decode(\"utf-8\")\n\n        frontend_context_variables = self.component.get_frontend_context_variables()\n        frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n        checksum = generate_checksum(orjson.dumps(frontend_context_variables_dict))\n\n        soup = BeautifulSoup(content, features=\"html.parser\")\n        root_element = get_root_element(soup)\n        root_element[\"unicorn:id\"] = self.component.component_id\n        root_element[\"unicorn:name\"] = self.component.component_name\n        root_element[\"unicorn:key\"] = self.component.component_key\n        root_element[\"unicorn:checksum\"] = checksum\n\n        # Generate the hash based on the rendered content (without script tag)\n        hash = generate_checksum(UnicornTemplateResponse._desoupify(soup))\n\n        if self.init_js:\n            init = {\n                \"id\": self.component.component_id,\n                \"name\": self.component.component_name,\n                \"key\": self.component.component_key,\n                \"data\": orjson.loads(frontend_context_variables),\n                \"calls\": self.component.calls,\n                \"hash\": hash,\n            }\n            init = orjson.dumps(init).decode(\"utf-8\")\n            json_element_id = f\"unicorn:data:{self.component.component_id}\"\n            init_script = f\"Unicorn.componentInit(JSON.parse(document.getElementById('{json_element_id}').textContent));\"\n\n            json_tag = soup.new_tag(\"script\")\n            json_tag[\"type\"] = \"application/json\"\n            json_tag[\"id\"] = json_element_id\n            json_tag.string = sanitize_html(init)\n\n            if self.component.parent:\n                self.component._init_script = init_script\n                self.component._json_tag = json_tag\n            else:\n                json_tags = []\n                json_tags.append(json_tag)\n\n                for child in self.component.children:\n                    init_script = f\"{init_script} {child._init_script}\"\n                    json_tags.append(child._json_tag)\n\n                script_tag = soup.new_tag(\"script\")\n                script_tag[\"type\"] = \"module\"\n                script_tag.string = f\"if (typeof Unicorn === 'undefined') {{ console.error('Unicorn is missing. Do you need {{% load unicorn %}} or {{% unicorn_scripts %}}?') }} else {{ {init_script} }}\"\n                root_element.insert_after(script_tag)\n\n                for t in json_tags:\n                    root_element.insert_after(t)\n\n        rendered_template = UnicornTemplateResponse._desoupify(soup)\n        rendered_template = mark_safe(rendered_template)\n        self.component.rendered(rendered_template)\n\n        response.content = rendered_template\n\n        return response\n\n    @staticmethod\n    def _desoupify(soup):\n        soup.smooth()\n        return soup.encode(formatter=UnsortedAttributes()).decode(\"utf-8\")\n\n\ndef get_root_element(soup: BeautifulSoup) -> Tag:\n    \"\"\"\n    Gets the first tag element.\n\n    Returns:\n        BeautifulSoup tag element.\n\n        Raises an Exception if an element cannot be found.\n    \"\"\"\n    for element in soup.contents:\n        if isinstance(element, Tag) and element.name:\n            return element\n\n    raise Exception(\"No root element found\")\n", "patch": "@@ -1,10 +1,10 @@\n import logging\n \n from django.template.response import TemplateResponse\n-from django.utils.safestring import mark_safe\n \n import orjson\n from bs4 import BeautifulSoup\n+from bs4.dammit import EntitySubstitution\n from bs4.element import Tag\n from bs4.formatter import HTMLFormatter\n \n@@ -22,6 +22,9 @@ class UnsortedAttributes(HTMLFormatter):\n     Prevent beautifulsoup from re-ordering attributes.\n     \"\"\"\n \n+    def __init__(self):\n+        super().__init__(entity_substitution=EntitySubstitution.substitute_html)\n+\n     def attributes(self, tag: Tag):\n         for k, v in tag.attrs.items():\n             yield k, v\n@@ -115,7 +118,6 @@ def render(self):\n                     root_element.insert_after(t)\n \n         rendered_template = UnicornTemplateResponse._desoupify(soup)\n-        rendered_template = mark_safe(rendered_template)\n         self.component.rendered(rendered_template)\n \n         response.content = rendered_template", "file_path": "files/2021_10/787", "file_language": "py", "file_name": "django_unicorn/components/unicorn_template_response.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.django.security.audit.avoid-mark-safe.avoid-mark-safe                                   \n          'mark_safe()' is used to mark a string as \"safe\" for HTML output. This disables escaping and\n          could therefore subject the content to XSS attacks. Use 'django.utils.html.format_html()' to\n          build HTML for rendering instead.                                                           \n          Details: https://sg.run/yd0P                                                                \n          118\u2506 rendered_template = mark_safe(rendered_template)"]]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/django_unicorn%2Fcomponents%2Funicorn_view.py", "code": "import importlib\nimport inspect\nimport logging\nimport pickle\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db.models import Model\nfrom django.http import HttpRequest\nfrom django.views.generic.base import TemplateView\n\nfrom cachetools.lru import LRUCache\n\nfrom django_unicorn.settings import get_cache_alias\n\nfrom .. import serializer\nfrom ..decorators import timed\nfrom ..errors import ComponentLoadError, UnicornCacheError\nfrom ..settings import get_setting\nfrom ..utils import get_cacheable_component\nfrom .fields import UnicornField\nfrom .unicorn_template_response import UnicornTemplateResponse\n\n\nlogger = logging.getLogger(__name__)\n\n\n# TODO: Make maxsize configurable\nlocation_cache = LRUCache(maxsize=100)\n\n# Module cache to store the found component class by id\nviews_cache = LRUCache(maxsize=100)\n\n# Module cache for constructed component classes\n# This can create a subtle race condition so a more long-term solution needs to be found\nconstructed_views_cache = LRUCache(maxsize=100)\nCOMPONENTS_MODULE_CACHE_ENABLED = \"pytest\" not in sys.modules\n\n\ndef convert_to_snake_case(s: str) -> str:\n    # TODO: Better handling of dash->snake\n    return s.replace(\"-\", \"_\")\n\n\ndef convert_to_pascal_case(s: str) -> str:\n    # TODO: Better handling of dash/snake->pascal-case\n    s = convert_to_snake_case(s)\n    return \"\".join(word.title() for word in s.split(\"_\"))\n\n\ndef get_locations(component_name):\n    locations = []\n\n    if \".\" in component_name:\n        # Handle component names that specify a folder structure\n        component_name = component_name.replace(\"/\", \".\")\n\n        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)\n        class_name = component_name.split(\".\")[-1:][0]\n        module_name = component_name.replace(\".\" + class_name, \"\")\n        locations.append((class_name, module_name))\n\n        # Assume if it ends with \"View\", then we don't need to add other\n        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):\n            return locations\n\n    # Handle component names that specify a folder structure\n    component_name = component_name.replace(\"/\", \".\")\n\n    # Use conventions to find the component class\n    class_name = convert_to_pascal_case(component_name)\n\n    if \".\" in class_name:\n        if class_name.split(\".\")[-1:]:\n            class_name = class_name.split(\".\")[-1:][0]\n\n    class_name = f\"{class_name}View\"\n    module_name = convert_to_snake_case(component_name)\n\n    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)\n\n    assert (\n        isinstance(unicorn_apps, list)\n        or isinstance(unicorn_apps, tuple)\n        or isinstance(unicorn_apps, set)\n    ), \"APPS is expected to be a list, tuple or set\"\n\n    for app in unicorn_apps:\n        # Handle an installed app that actually points to an app config\n        if \".apps.\" in app:\n            app_config_idx = app.rindex(\".apps.\")\n            app = app[:app_config_idx]\n\n        app_module_name = f\"{app}.components.{module_name}\"\n        locations.append((class_name, app_module_name))\n\n    return locations\n\n\n@timed\ndef construct_component(\n    component_class,\n    component_id,\n    component_name,\n    component_key,\n    parent,\n    request,\n    **kwargs,\n):\n    \"\"\"\n    Constructs a class instance.\n    \"\"\"\n    component = component_class(\n        component_id=component_id,\n        component_name=component_name,\n        component_key=component_key,\n        parent=parent,\n        request=request,\n        **kwargs,\n    )\n\n    component.calls = []\n    component.children = []\n    component._children_set = False\n\n    component.mount()\n    component.hydrate()\n    component.complete()\n    component._validate_called = False\n\n    return component\n\n\nclass UnicornView(TemplateView):\n    response_class = UnicornTemplateResponse\n    component_name: str = \"\"\n    component_key: str = \"\"\n    request = None\n    parent = None\n    children = []\n\n    # Caches to reduce the amount of time introspecting the class\n    _methods_cache: Dict[str, Callable] = {}\n    _attribute_names_cache: List[str] = []\n    _hook_methods_cache: List[str] = []\n\n    # Dictionary with key: attribute name; value: pickled attribute value\n    _resettable_attributes_cache: Dict[str, Any] = {}\n\n    # JavaScript method calls\n    calls = []\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        assert self.component_name, \"Component name is required\"\n\n        if \"id\" in kwargs and kwargs[\"id\"]:\n            # Sometimes the component_id is initially in kwargs[\"id\"]\n            self.component_id = kwargs[\"id\"]\n\n        assert hasattr(self, \"component_id\"), \"Component id is required\"\n        assert self.component_id, \"Component id is required\"\n        self.component_cache_key = f\"unicorn:component:{self.component_id}\"\n\n        if \"request\" in kwargs:\n            self.setup(kwargs[\"request\"])\n\n        if \"parent\" in kwargs:\n            self.parent = kwargs[\"parent\"]\n\n        self._init_script: str = \"\"\n        self._children_set = False\n        self._validate_called = False\n        self.errors = {}\n        self._set_default_template_name()\n        self._set_caches()\n\n    @timed\n    def _set_default_template_name(self) -> None:\n        \"\"\"\n        Sets a default template name based on component's name if necessary.\n        \"\"\"\n        get_template_names_is_valid = False\n\n        try:\n            # Check for get_template_names by explicitly calling it since it\n            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.\n            self.get_template_names()\n            get_template_names_is_valid = True\n        except ImproperlyConfigured:\n            pass\n\n        if not self.template_name and not get_template_names_is_valid:\n            # Convert component name with a dot to a folder structure\n            template_name = self.component_name.replace(\".\", \"/\")\n            self.template_name = f\"unicorn/{template_name}.html\"\n\n    @timed\n    def _set_caches(self) -> None:\n        \"\"\"\n        Setup some initial \"caches\" to prevent Python from having to introspect\n        a component UnicornView for methods and properties multiple times.\n        \"\"\"\n        self._attribute_names_cache = self._attribute_names()\n        self._set_hook_methods_cache()\n        self._methods_cache = self._methods()\n        self._set_resettable_attributes_cache()\n\n    @timed\n    def reset(self):\n        for (\n            attribute_name,\n            pickled_value,\n        ) in self._resettable_attributes_cache.items():\n            try:\n                attribute_value = pickle.loads(pickled_value)\n                self._set_property(attribute_name, attribute_value)\n            except TypeError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"\n                )\n                pass\n            except pickle.PickleError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"\n                )\n                pass\n\n    def call(self, function_name, *args):\n        \"\"\"\n        Add a JavaScript method name and arguments to be called after the component is rendered.\n        \"\"\"\n        self.calls.append({\"fn\": function_name, \"args\": args})\n\n    def mount(self):\n        \"\"\"\n        Hook that gets called when the component is first created.\n        \"\"\"\n        pass\n\n    def hydrate(self):\n        \"\"\"\n        Hook that gets called when the component's data is hydrated.\n        \"\"\"\n        pass\n\n    def complete(self):\n        \"\"\"\n        Hook that gets called after all component methods are executed.\n        \"\"\"\n        pass\n\n    def rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component has been rendered.\n        \"\"\"\n        pass\n\n    def parent_rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component's parent has been rendered.\n        \"\"\"\n        pass\n\n    def updating(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is about to get updated.\n        \"\"\"\n        pass\n\n    def updated(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is updated.\n        \"\"\"\n        pass\n\n    def calling(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is about to get called.\n        \"\"\"\n        pass\n\n    def called(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is called.\n        \"\"\"\n        pass\n\n    @timed\n    def render(self, init_js=False) -> str:\n        \"\"\"\n        Renders a UnicornView component with the public properties available. Delegates to a\n        UnicornTemplateResponse to actually render a response.\n \n        Args:\n            param init_js: Whether or not to include the Javascript required to initialize the component.\n        \"\"\"\n\n        response = self.render_to_response(\n            context=self.get_context_data(), component=self, init_js=init_js,\n        )\n\n        # render_to_response() could only return a HttpResponse, so check for render()\n        if hasattr(response, \"render\"):\n            response.render()\n\n        rendered_component = response.content.decode(\"utf-8\")\n\n        # Set the current component as a child of the parent if there is a parent\n        # If no parent, mark that the component has its children set.\n        # This works because the nested (internal) components get rendered first before the parent,\n        # so once we hit a component without a parent we know all of the children have been rendered correctly\n        # TODO: This might fall apart with a third layer of nesting components\n        if self.parent:\n            if not self.parent._children_set:\n                self.parent.children.append(self)\n        else:\n            self._children_set = True\n\n        return rendered_component\n\n    @timed\n    def get_frontend_context_variables(self) -> str:\n        \"\"\"\n        Get publicly available properties and output them in a string-encoded JSON object.\n        \"\"\"\n\n        frontend_context_variables = {}\n        attributes = self._attributes()\n        frontend_context_variables.update(attributes)\n\n        # Remove any field in `javascript_exclude` from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):\n            if isinstance(self.Meta.javascript_exclude, Sequence):\n                for field_name in self.Meta.javascript_exclude:\n                    if field_name in frontend_context_variables:\n                        del frontend_context_variables[field_name]\n\n        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields\n        form = self._get_form(attributes)\n\n        if form:\n            form.is_valid()\n\n            for key in attributes.keys():\n                if key in form.fields:\n                    field = form.fields[key]\n\n                    if key in form.cleaned_data:\n                        cleaned_value = form.cleaned_data[key]\n                        value = field.widget.format_value(cleaned_value)\n\n                        # Don't update the frontend variable if the only change is\n                        # stripping off the whitespace from the field value\n                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n                        if (\n                            not hasattr(frontend_context_variables[key], \"strip\")\n                            or frontend_context_variables[key].strip() != value\n                        ):\n                            frontend_context_variables[key] = value\n\n        encoded_frontend_context_variables = serializer.dumps(\n            frontend_context_variables\n        )\n\n        return encoded_frontend_context_variables\n\n    @timed\n    def _get_form(self, data):\n        if hasattr(self, \"form_class\"):\n            try:\n                form = self.form_class(data)\n                form.is_valid()\n\n                return form\n            except Exception as e:\n                logger.exception(e)\n\n    @timed\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Overrides the standard `get_context_data` to add in publicly available\n        properties and methods.\n        \"\"\"\n\n        context = super().get_context_data(**kwargs)\n\n        attributes = self._attributes()\n        context.update(attributes)\n        context.update(self._methods())\n        context.update({\"unicorn\": {\"errors\": self.errors}})\n\n        return context\n\n    @timed\n    def is_valid(self, model_names: List = None) -> bool:\n        return len(self.validate(model_names).keys()) == 0\n\n    @timed\n    def validate(self, model_names: List = None) -> Dict:\n        \"\"\"\n        Validates the data using the `form_class` set on the component.\n\n        Args:\n            model_names: Only include validation errors for specified fields. If none, validate everything.\n        \"\"\"\n        # TODO: Handle form.non_field_errors()?\n\n        if self._validate_called:\n            return self.errors\n\n        self._validate_called = True\n\n        data = self._attributes()\n        form = self._get_form(data)\n\n        if form:\n            form_errors = form.errors.get_json_data(escape_html=True)\n\n            # This code is confusing, but handles this use-case:\n            # the component has two models, one that starts with an error and one\n            # that is valid. Validating the valid one should not show an error for\n            # the invalid one. Only after the invalid field is updated, should the\n            # error show up and persist, even after updating the valid form.\n            if self.errors:\n                keys_to_remove = []\n\n                for key, value in self.errors.items():\n                    if key in form_errors:\n                        self.errors[key] = value\n                    else:\n                        keys_to_remove.append(key)\n\n                for key in keys_to_remove:\n                    self.errors.pop(key)\n\n            if model_names is not None:\n                for key, value in form_errors.items():\n                    if key in model_names:\n                        self.errors[key] = value\n            else:\n                self.errors.update(form_errors)\n\n        return self.errors\n\n    @timed\n    def _attribute_names(self) -> List[str]:\n        \"\"\"\n        Gets publicly available attribute names. Cached in `_attribute_names_cache`.\n        \"\"\"\n        non_callables = [\n            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))\n        ]\n        attribute_names = [name for name in non_callables if self._is_public(name)]\n\n        return attribute_names\n\n    @timed\n    def _attributes(self) -> Dict[str, Any]:\n        \"\"\"\n        Get publicly available attributes and their values from the component.\n        \"\"\"\n\n        attribute_names = self._attribute_names_cache\n        attributes = {}\n\n        for attribute_name in attribute_names:\n            attributes[attribute_name] = getattr(self, attribute_name)\n\n        return attributes\n\n    @timed\n    def _set_property(self, name, value):\n        # Get the correct value type by using the form if it is available\n        data = self._attributes()\n        data[name] = value\n        form = self._get_form(data)\n\n        if form and name in form.fields and name in form.cleaned_data:\n            # The Django form CharField validator will remove whitespace\n            # from the field value. Ignore that update if it's the\n            # only thing different from the validator\n            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():\n                value = form.cleaned_data[name]\n\n        updating_function_name = f\"updating_{name}\"\n        if hasattr(self, updating_function_name):\n            getattr(self, updating_function_name)(value)\n\n        try:\n            setattr(self, name, value)\n\n            updated_function_name = f\"updated_{name}\"\n\n            if hasattr(self, updated_function_name):\n                getattr(self, updated_function_name)(value)\n        except AttributeError as e:\n            raise\n\n    @timed\n    def _methods(self) -> Dict[str, Callable]:\n        \"\"\"\n        Get publicly available method names and their functions from the component.\n        Cached in `_methods_cache`.\n        \"\"\"\n\n        if self._methods_cache:\n            return self._methods_cache\n\n        member_methods = inspect.getmembers(self, inspect.ismethod)\n        public_methods = [\n            method for method in member_methods if self._is_public(method[0])\n        ]\n        methods = {k: v for (k, v) in public_methods}\n        self._methods_cache = methods\n\n        return methods\n\n    @timed\n    def _set_hook_methods_cache(self) -> None:\n        \"\"\"\n        Caches the updating/updated attribute function names defined on the component.\n        \"\"\"\n        self._hook_methods_cache = []\n\n        for attribute_name in self._attribute_names_cache:\n            updating_function_name = f\"updating_{attribute_name}\"\n            updated_function_name = f\"updated_{attribute_name}\"\n            hook_function_names = [updating_function_name, updated_function_name]\n\n            for function_name in hook_function_names:\n                if hasattr(self, function_name):\n                    self._hook_methods_cache.append(function_name)\n\n    @timed\n    def _set_resettable_attributes_cache(self) -> None:\n        \"\"\"\n        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.\n        Cache is a dictionary with key: attribute name; value: pickled attribute value\n\n        Examples:\n            - `UnicornField`\n            - Django Models without a defined pk\n        \"\"\"\n        self._resettable_attributes_cache = {}\n\n        for attribute_name, attribute_value in self._attributes().items():\n            if isinstance(attribute_value, UnicornField):\n                self._resettable_attributes_cache[attribute_name] = pickle.dumps(\n                    attribute_value\n                )\n            elif isinstance(attribute_value, Model):\n                if not attribute_value.pk:\n                    if attribute_name not in self._resettable_attributes_cache:\n                        try:\n                            self._resettable_attributes_cache[\n                                attribute_name\n                            ] = pickle.dumps(attribute_value)\n                        except pickle.PickleError:\n                            logger.warn(\n                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"\n                            )\n                            pass\n\n    def _is_public(self, name: str) -> bool:\n        \"\"\"\n        Determines if the name should be sent in the context.\n        \"\"\"\n\n        # Ignore some standard attributes from TemplateView\n        protected_names = (\n            \"render\",\n            \"request\",\n            \"args\",\n            \"kwargs\",\n            \"content_type\",\n            \"extra_context\",\n            \"http_method_names\",\n            \"template_engine\",\n            \"template_name\",\n            \"dispatch\",\n            \"id\",\n            \"get\",\n            \"get_context_data\",\n            \"get_template_names\",\n            \"render_to_response\",\n            \"http_method_not_allowed\",\n            \"options\",\n            \"setup\",\n            \"fill\",\n            # Component methods\n            \"component_id\",\n            \"component_name\",\n            \"component_key\",\n            \"reset\",\n            \"mount\",\n            \"hydrate\",\n            \"updating\",\n            \"update\",\n            \"calling\",\n            \"called\",\n            \"complete\",\n            \"rendered\",\n            \"parent_rendered\",\n            \"validate\",\n            \"is_valid\",\n            \"get_frontend_context_variables\",\n            \"errors\",\n            \"updated\",\n            \"parent\",\n            \"children\",\n            \"call\",\n            \"calls\",\n            \"component_cache_key\",\n        )\n        excludes = []\n\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):\n            if isinstance(self.Meta.exclude, Sequence):\n                excludes = self.Meta.exclude\n\n        return not (\n            name.startswith(\"_\")\n            or name in protected_names\n            or name in self._hook_methods_cache\n            or name in excludes\n        )\n\n    @staticmethod\n    @timed\n    def create(\n        component_id: str,\n        component_name: str,\n        component_key: str = \"\",\n        parent: \"UnicornView\" = None,\n        request: HttpRequest = None,\n        use_cache=True,\n        kwargs: Dict[str, Any] = {},\n    ) -> \"UnicornView\":\n        \"\"\"\n        Find and instantiate a component class based on `component_name`.\n\n        Args:\n            param component_id: Id of the component. Required.\n            param component_name: Name of the component. Used to locate the correct `UnicornView`\n                component class and template if necessary. Required.\n            param component_key: Key of the component to allow multiple components of the same name\n                to be differentiated. Optional.\n            param parent: The parent component of the current component.\n            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.\n        \n        Returns:\n            Instantiated `UnicornView` component.\n            Raises `ComponentLoadError` if the component could not be loaded.\n        \"\"\"\n        assert component_id, \"Component id is required\"\n        assert component_name, \"Component name is required\"\n\n        @timed\n        def _get_component_class(\n            module_name: str, class_name: str\n        ) -> Type[UnicornView]:\n            \"\"\"\n            Imports a component based on module and class name.\n            \"\"\"\n            module = importlib.import_module(module_name)\n            component_class = getattr(module, class_name)\n\n            return component_class\n\n        cache = caches[get_cache_alias()]\n        component_cache_key = f\"unicorn:component:{component_id}\"\n        cached_component = cache.get(component_cache_key)\n\n        if cached_component:\n            # Get the newest version of the parent from cache if it is available\n            # This needs to happen for Django cache because instances is pickled, so\n            # a change in the view won't be reflected automatically (like with the module\n            # cache) so it needs to be retrieved manually.\n            if cached_component.parent:\n                cached_parent_component = cache.get(\n                    cached_component.parent.component_cache_key\n                )\n\n                if cached_parent_component:\n                    cached_component.parent = cached_parent_component\n                    cached_component.parent.setup(request)\n        else:\n            cached_component = constructed_views_cache.get(component_id)\n\n        if use_cache and cached_component:\n            # Note that `hydrate()` and `complete` don't need to be called here\n            # because this path only happens for re-rendering from the view\n            cached_component.setup(request)\n            cached_component._validate_called = False\n            cached_component.calls = []\n            logger.debug(f\"Retrieve {component_id} from constructed views cache\")\n\n            return cached_component\n\n        if component_id in views_cache:\n            (component_class, parent, kwargs) = views_cache[component_id]\n\n            component = construct_component(\n                component_class=component_class,\n                component_id=component_id,\n                component_name=component_name,\n                component_key=component_key,\n                parent=parent,\n                request=request,\n                **kwargs,\n            )\n            logger.debug(f\"Retrieve {component_id} from views cache\")\n\n            return component\n\n        locations = []\n\n        if component_name in location_cache:\n            locations.append(location_cache[component_name])\n        else:\n            locations = get_locations(component_name)\n\n        # Store the last exception that got raised while looking for a component in case it is useful context\n        last_exception: Union[\n            Optional[ModuleNotFoundError], Optional[AttributeError]\n        ] = None\n\n        for (class_name, module_name) in locations:\n            try:\n                component_class = _get_component_class(module_name, class_name)\n                component = construct_component(\n                    component_class=component_class,\n                    component_id=component_id,\n                    component_name=component_name,\n                    component_key=component_key,\n                    parent=parent,\n                    request=request,\n                    **kwargs,\n                )\n\n                # Put the location for the component name in a module cache\n                location_cache[component_name] = (class_name, module_name)\n\n                # Put the component's class in a module cache\n                views_cache[component_id] = (component_class, parent, kwargs)\n\n                # Put the instantiated component into a module cache and the Django cache\n                cacheable_component = None\n\n                try:\n                    cacheable_component = get_cacheable_component(component)\n                except UnicornCacheError as e:\n                    logger.warning(e)\n\n                if cacheable_component:\n                    if COMPONENTS_MODULE_CACHE_ENABLED:\n                        constructed_views_cache[component_id] = cacheable_component\n\n                    cache.set(\n                        cacheable_component.component_cache_key, cacheable_component\n                    )\n\n                return component\n            except ModuleNotFoundError as e:\n                last_exception = e\n            except AttributeError as e:\n                last_exception = e\n\n        raise ComponentLoadError(\n            f\"'{component_name}' component could not be loaded: {last_exception}\"\n        ) from last_exception\n", "code_before": "import importlib\nimport inspect\nimport logging\nimport pickle\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom django.conf import settings\nfrom django.core.cache import caches\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db.models import Model\nfrom django.http import HttpRequest\nfrom django.utils.html import conditional_escape\nfrom django.views.generic.base import TemplateView\n\nfrom cachetools.lru import LRUCache\n\nfrom django_unicorn.settings import get_cache_alias\n\nfrom .. import serializer\nfrom ..decorators import timed\nfrom ..errors import ComponentLoadError, UnicornCacheError\nfrom ..settings import get_setting\nfrom ..utils import get_cacheable_component\nfrom .fields import UnicornField\nfrom .unicorn_template_response import UnicornTemplateResponse\n\n\nlogger = logging.getLogger(__name__)\n\n\n# TODO: Make maxsize configurable\nlocation_cache = LRUCache(maxsize=100)\n\n# Module cache to store the found component class by id\nviews_cache = LRUCache(maxsize=100)\n\n# Module cache for constructed component classes\n# This can create a subtle race condition so a more long-term solution needs to be found\nconstructed_views_cache = LRUCache(maxsize=100)\nCOMPONENTS_MODULE_CACHE_ENABLED = \"pytest\" not in sys.modules\n\n\ndef convert_to_snake_case(s: str) -> str:\n    # TODO: Better handling of dash->snake\n    return s.replace(\"-\", \"_\")\n\n\ndef convert_to_pascal_case(s: str) -> str:\n    # TODO: Better handling of dash/snake->pascal-case\n    s = convert_to_snake_case(s)\n    return \"\".join(word.title() for word in s.split(\"_\"))\n\n\ndef get_locations(component_name):\n    locations = []\n\n    if \".\" in component_name:\n        # Handle component names that specify a folder structure\n        component_name = component_name.replace(\"/\", \".\")\n\n        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)\n        class_name = component_name.split(\".\")[-1:][0]\n        module_name = component_name.replace(\".\" + class_name, \"\")\n        locations.append((class_name, module_name))\n\n        # Assume if it ends with \"View\", then we don't need to add other\n        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):\n            return locations\n\n    # Handle component names that specify a folder structure\n    component_name = component_name.replace(\"/\", \".\")\n\n    # Use conventions to find the component class\n    class_name = convert_to_pascal_case(component_name)\n\n    if \".\" in class_name:\n        if class_name.split(\".\")[-1:]:\n            class_name = class_name.split(\".\")[-1:][0]\n\n    class_name = f\"{class_name}View\"\n    module_name = convert_to_snake_case(component_name)\n\n    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)\n\n    assert (\n        isinstance(unicorn_apps, list)\n        or isinstance(unicorn_apps, tuple)\n        or isinstance(unicorn_apps, set)\n    ), \"APPS is expected to be a list, tuple or set\"\n\n    for app in unicorn_apps:\n        # Handle an installed app that actually points to an app config\n        if \".apps.\" in app:\n            app_config_idx = app.rindex(\".apps.\")\n            app = app[:app_config_idx]\n\n        app_module_name = f\"{app}.components.{module_name}\"\n        locations.append((class_name, app_module_name))\n\n    return locations\n\n\n@timed\ndef construct_component(\n    component_class,\n    component_id,\n    component_name,\n    component_key,\n    parent,\n    request,\n    **kwargs,\n):\n    \"\"\"\n    Constructs a class instance.\n    \"\"\"\n    component = component_class(\n        component_id=component_id,\n        component_name=component_name,\n        component_key=component_key,\n        parent=parent,\n        request=request,\n        **kwargs,\n    )\n\n    component.calls = []\n    component.children = []\n    component._children_set = False\n\n    component.mount()\n    component.hydrate()\n    component.complete()\n    component._validate_called = False\n\n    return component\n\n\nclass UnicornView(TemplateView):\n    response_class = UnicornTemplateResponse\n    component_name: str = \"\"\n    component_key: str = \"\"\n    request = None\n    parent = None\n    children = []\n\n    # Caches to reduce the amount of time introspecting the class\n    _methods_cache: Dict[str, Callable] = {}\n    _attribute_names_cache: List[str] = []\n    _hook_methods_cache: List[str] = []\n\n    # Dictionary with key: attribute name; value: pickled attribute value\n    _resettable_attributes_cache: Dict[str, Any] = {}\n\n    # JavaScript method calls\n    calls = []\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        assert self.component_name, \"Component name is required\"\n\n        if \"id\" in kwargs and kwargs[\"id\"]:\n            # Sometimes the component_id is initially in kwargs[\"id\"]\n            self.component_id = kwargs[\"id\"]\n\n        assert hasattr(self, \"component_id\"), \"Component id is required\"\n        assert self.component_id, \"Component id is required\"\n        self.component_cache_key = f\"unicorn:component:{self.component_id}\"\n\n        if \"request\" in kwargs:\n            self.setup(kwargs[\"request\"])\n\n        if \"parent\" in kwargs:\n            self.parent = kwargs[\"parent\"]\n\n        self._init_script: str = \"\"\n        self._children_set = False\n        self._validate_called = False\n        self.errors = {}\n        self._set_default_template_name()\n        self._set_caches()\n\n    @timed\n    def _set_default_template_name(self) -> None:\n        \"\"\"\n        Sets a default template name based on component's name if necessary.\n        \"\"\"\n        get_template_names_is_valid = False\n\n        try:\n            # Check for get_template_names by explicitly calling it since it\n            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.\n            self.get_template_names()\n            get_template_names_is_valid = True\n        except ImproperlyConfigured:\n            pass\n\n        if not self.template_name and not get_template_names_is_valid:\n            # Convert component name with a dot to a folder structure\n            template_name = self.component_name.replace(\".\", \"/\")\n            self.template_name = f\"unicorn/{template_name}.html\"\n\n    @timed\n    def _set_caches(self) -> None:\n        \"\"\"\n        Setup some initial \"caches\" to prevent Python from having to introspect\n        a component UnicornView for methods and properties multiple times.\n        \"\"\"\n        self._attribute_names_cache = self._attribute_names()\n        self._set_hook_methods_cache()\n        self._methods_cache = self._methods()\n        self._set_resettable_attributes_cache()\n\n    @timed\n    def reset(self):\n        for (\n            attribute_name,\n            pickled_value,\n        ) in self._resettable_attributes_cache.items():\n            try:\n                attribute_value = pickle.loads(pickled_value)\n                self._set_property(attribute_name, attribute_value)\n            except TypeError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"\n                )\n                pass\n            except pickle.PickleError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"\n                )\n                pass\n\n    def call(self, function_name, *args):\n        \"\"\"\n        Add a JavaScript method name and arguments to be called after the component is rendered.\n        \"\"\"\n        self.calls.append({\"fn\": function_name, \"args\": args})\n\n    def mount(self):\n        \"\"\"\n        Hook that gets called when the component is first created.\n        \"\"\"\n        pass\n\n    def hydrate(self):\n        \"\"\"\n        Hook that gets called when the component's data is hydrated.\n        \"\"\"\n        pass\n\n    def complete(self):\n        \"\"\"\n        Hook that gets called after all component methods are executed.\n        \"\"\"\n        pass\n\n    def rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component has been rendered.\n        \"\"\"\n        pass\n\n    def parent_rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component's parent has been rendered.\n        \"\"\"\n        pass\n\n    def updating(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is about to get updated.\n        \"\"\"\n        pass\n\n    def updated(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is updated.\n        \"\"\"\n        pass\n\n    def calling(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is about to get called.\n        \"\"\"\n        pass\n\n    def called(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is called.\n        \"\"\"\n        pass\n\n    @timed\n    def render(self, init_js=False) -> str:\n        \"\"\"\n        Renders a UnicornView component with the public properties available. Delegates to a\n        UnicornTemplateResponse to actually render a response.\n \n        Args:\n            param init_js: Whether or not to include the Javascript required to initialize the component.\n        \"\"\"\n\n        response = self.render_to_response(\n            context=self.get_context_data(), component=self, init_js=init_js,\n        )\n\n        # render_to_response() could only return a HttpResponse, so check for render()\n        if hasattr(response, \"render\"):\n            response.render()\n\n        rendered_component = response.content.decode(\"utf-8\")\n\n        # Set the current component as a child of the parent if there is a parent\n        # If no parent, mark that the component has its children set.\n        # This works because the nested (internal) components get rendered first before the parent,\n        # so once we hit a component without a parent we know all of the children have been rendered correctly\n        # TODO: This might fall apart with a third layer of nesting components\n        if self.parent:\n            if not self.parent._children_set:\n                self.parent.children.append(self)\n        else:\n            self._children_set = True\n\n        return rendered_component\n\n    @timed\n    def get_frontend_context_variables(self) -> str:\n        \"\"\"\n        Get publicly available properties and output them in a string-encoded JSON object.\n        \"\"\"\n\n        frontend_context_variables = {}\n        attributes = self._attributes()\n        frontend_context_variables.update(attributes)\n\n        # Remove any field in `javascript_exclude` from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):\n            if isinstance(self.Meta.javascript_exclude, Sequence):\n                for field_name in self.Meta.javascript_exclude:\n                    if field_name in frontend_context_variables:\n                        del frontend_context_variables[field_name]\n\n        safe_fields = []\n        # Keep a list of fields that are safe to not sanitize from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"safe\"):\n            if isinstance(self.Meta.safe, Sequence):\n                for field_name in self.Meta.safe:\n                    if field_name in frontend_context_variables:\n                        safe_fields.append(field_name)\n\n        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields\n        form = self._get_form(attributes)\n\n        if form:\n            form.is_valid()\n\n            for key in attributes.keys():\n                if key in form.fields:\n                    field = form.fields[key]\n\n                    if key in form.cleaned_data:\n                        cleaned_value = form.cleaned_data[key]\n                        value = field.widget.format_value(cleaned_value)\n\n                        # Don't update the frontend variable if the only change is\n                        # stripping off the whitespace from the field value\n                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n                        if (\n                            not hasattr(frontend_context_variables[key], \"strip\")\n                            or frontend_context_variables[key].strip() != value\n                        ):\n                            frontend_context_variables[key] = value\n\n        for (\n            frontend_context_variable_key,\n            frontend_context_variable_value,\n        ) in frontend_context_variables.items():\n            if (\n                isinstance(frontend_context_variable_value, str)\n                and frontend_context_variable_key not in safe_fields\n            ):\n                frontend_context_variables[frontend_context_variable_key] = escape(\n                    frontend_context_variable_value\n                )\n\n        encoded_frontend_context_variables = serializer.dumps(\n            frontend_context_variables\n        )\n\n        return encoded_frontend_context_variables\n\n    @timed\n    def _get_form(self, data):\n        if hasattr(self, \"form_class\"):\n            try:\n                form = self.form_class(data)\n                form.is_valid()\n\n                return form\n            except Exception as e:\n                logger.exception(e)\n\n    @timed\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Overrides the standard `get_context_data` to add in publicly available\n        properties and methods.\n        \"\"\"\n\n        context = super().get_context_data(**kwargs)\n\n        attributes = self._attributes()\n        context.update(attributes)\n        context.update(self._methods())\n        context.update({\"unicorn\": {\"errors\": self.errors}})\n\n        return context\n\n    @timed\n    def is_valid(self, model_names: List = None) -> bool:\n        return len(self.validate(model_names).keys()) == 0\n\n    @timed\n    def validate(self, model_names: List = None) -> Dict:\n        \"\"\"\n        Validates the data using the `form_class` set on the component.\n\n        Args:\n            model_names: Only include validation errors for specified fields. If none, validate everything.\n        \"\"\"\n        # TODO: Handle form.non_field_errors()?\n\n        if self._validate_called:\n            return self.errors\n\n        self._validate_called = True\n\n        data = self._attributes()\n        form = self._get_form(data)\n\n        if form:\n            form_errors = form.errors.get_json_data(escape_html=True)\n\n            # This code is confusing, but handles this use-case:\n            # the component has two models, one that starts with an error and one\n            # that is valid. Validating the valid one should not show an error for\n            # the invalid one. Only after the invalid field is updated, should the\n            # error show up and persist, even after updating the valid form.\n            if self.errors:\n                keys_to_remove = []\n\n                for key, value in self.errors.items():\n                    if key in form_errors:\n                        self.errors[key] = value\n                    else:\n                        keys_to_remove.append(key)\n\n                for key in keys_to_remove:\n                    self.errors.pop(key)\n\n            if model_names is not None:\n                for key, value in form_errors.items():\n                    if key in model_names:\n                        self.errors[key] = value\n            else:\n                self.errors.update(form_errors)\n\n        return self.errors\n\n    @timed\n    def _attribute_names(self) -> List[str]:\n        \"\"\"\n        Gets publicly available attribute names. Cached in `_attribute_names_cache`.\n        \"\"\"\n        non_callables = [\n            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))\n        ]\n        attribute_names = [name for name in non_callables if self._is_public(name)]\n\n        return attribute_names\n\n    @timed\n    def _attributes(self) -> Dict[str, Any]:\n        \"\"\"\n        Get publicly available attributes and their values from the component.\n        \"\"\"\n\n        attribute_names = self._attribute_names_cache\n        attributes = {}\n\n        for attribute_name in attribute_names:\n            attributes[attribute_name] = getattr(self, attribute_name)\n\n        return attributes\n\n    @timed\n    def _set_property(self, name, value):\n        # Get the correct value type by using the form if it is available\n        data = self._attributes()\n        data[name] = value\n        form = self._get_form(data)\n\n        if form and name in form.fields and name in form.cleaned_data:\n            # The Django form CharField validator will remove whitespace\n            # from the field value. Ignore that update if it's the\n            # only thing different from the validator\n            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():\n                value = form.cleaned_data[name]\n\n        updating_function_name = f\"updating_{name}\"\n        if hasattr(self, updating_function_name):\n            getattr(self, updating_function_name)(value)\n\n        try:\n            setattr(self, name, value)\n\n            updated_function_name = f\"updated_{name}\"\n\n            if hasattr(self, updated_function_name):\n                getattr(self, updated_function_name)(value)\n        except AttributeError as e:\n            raise\n\n    @timed\n    def _methods(self) -> Dict[str, Callable]:\n        \"\"\"\n        Get publicly available method names and their functions from the component.\n        Cached in `_methods_cache`.\n        \"\"\"\n\n        if self._methods_cache:\n            return self._methods_cache\n\n        member_methods = inspect.getmembers(self, inspect.ismethod)\n        public_methods = [\n            method for method in member_methods if self._is_public(method[0])\n        ]\n        methods = {k: v for (k, v) in public_methods}\n        self._methods_cache = methods\n\n        return methods\n\n    @timed\n    def _set_hook_methods_cache(self) -> None:\n        \"\"\"\n        Caches the updating/updated attribute function names defined on the component.\n        \"\"\"\n        self._hook_methods_cache = []\n\n        for attribute_name in self._attribute_names_cache:\n            updating_function_name = f\"updating_{attribute_name}\"\n            updated_function_name = f\"updated_{attribute_name}\"\n            hook_function_names = [updating_function_name, updated_function_name]\n\n            for function_name in hook_function_names:\n                if hasattr(self, function_name):\n                    self._hook_methods_cache.append(function_name)\n\n    @timed\n    def _set_resettable_attributes_cache(self) -> None:\n        \"\"\"\n        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.\n        Cache is a dictionary with key: attribute name; value: pickled attribute value\n\n        Examples:\n            - `UnicornField`\n            - Django Models without a defined pk\n        \"\"\"\n        self._resettable_attributes_cache = {}\n\n        for attribute_name, attribute_value in self._attributes().items():\n            if isinstance(attribute_value, UnicornField):\n                self._resettable_attributes_cache[attribute_name] = pickle.dumps(\n                    attribute_value\n                )\n            elif isinstance(attribute_value, Model):\n                if not attribute_value.pk:\n                    if attribute_name not in self._resettable_attributes_cache:\n                        try:\n                            self._resettable_attributes_cache[\n                                attribute_name\n                            ] = pickle.dumps(attribute_value)\n                        except pickle.PickleError:\n                            logger.warn(\n                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"\n                            )\n                            pass\n\n    def _is_public(self, name: str) -> bool:\n        \"\"\"\n        Determines if the name should be sent in the context.\n        \"\"\"\n\n        # Ignore some standard attributes from TemplateView\n        protected_names = (\n            \"render\",\n            \"request\",\n            \"args\",\n            \"kwargs\",\n            \"content_type\",\n            \"extra_context\",\n            \"http_method_names\",\n            \"template_engine\",\n            \"template_name\",\n            \"dispatch\",\n            \"id\",\n            \"get\",\n            \"get_context_data\",\n            \"get_template_names\",\n            \"render_to_response\",\n            \"http_method_not_allowed\",\n            \"options\",\n            \"setup\",\n            \"fill\",\n            # Component methods\n            \"component_id\",\n            \"component_name\",\n            \"component_key\",\n            \"reset\",\n            \"mount\",\n            \"hydrate\",\n            \"updating\",\n            \"update\",\n            \"calling\",\n            \"called\",\n            \"complete\",\n            \"rendered\",\n            \"parent_rendered\",\n            \"validate\",\n            \"is_valid\",\n            \"get_frontend_context_variables\",\n            \"errors\",\n            \"updated\",\n            \"parent\",\n            \"children\",\n            \"call\",\n            \"calls\",\n            \"component_cache_key\",\n        )\n        excludes = []\n\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):\n            if isinstance(self.Meta.exclude, Sequence):\n                excludes = self.Meta.exclude\n\n        return not (\n            name.startswith(\"_\")\n            or name in protected_names\n            or name in self._hook_methods_cache\n            or name in excludes\n        )\n\n    @staticmethod\n    @timed\n    def create(\n        component_id: str,\n        component_name: str,\n        component_key: str = \"\",\n        parent: \"UnicornView\" = None,\n        request: HttpRequest = None,\n        use_cache=True,\n        kwargs: Dict[str, Any] = {},\n    ) -> \"UnicornView\":\n        \"\"\"\n        Find and instantiate a component class based on `component_name`.\n\n        Args:\n            param component_id: Id of the component. Required.\n            param component_name: Name of the component. Used to locate the correct `UnicornView`\n                component class and template if necessary. Required.\n            param component_key: Key of the component to allow multiple components of the same name\n                to be differentiated. Optional.\n            param parent: The parent component of the current component.\n            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.\n        \n        Returns:\n            Instantiated `UnicornView` component.\n            Raises `ComponentLoadError` if the component could not be loaded.\n        \"\"\"\n        assert component_id, \"Component id is required\"\n        assert component_name, \"Component name is required\"\n\n        @timed\n        def _get_component_class(\n            module_name: str, class_name: str\n        ) -> Type[UnicornView]:\n            \"\"\"\n            Imports a component based on module and class name.\n            \"\"\"\n            module = importlib.import_module(module_name)\n            component_class = getattr(module, class_name)\n\n            return component_class\n\n        cache = caches[get_cache_alias()]\n        component_cache_key = f\"unicorn:component:{component_id}\"\n        cached_component = cache.get(component_cache_key)\n\n        if cached_component:\n            # Get the newest version of the parent from cache if it is available\n            # This needs to happen for Django cache because instances is pickled, so\n            # a change in the view won't be reflected automatically (like with the module\n            # cache) so it needs to be retrieved manually.\n            if cached_component.parent:\n                cached_parent_component = cache.get(\n                    cached_component.parent.component_cache_key\n                )\n\n                if cached_parent_component:\n                    cached_component.parent = cached_parent_component\n                    cached_component.parent.setup(request)\n        else:\n            cached_component = constructed_views_cache.get(component_id)\n\n        if use_cache and cached_component:\n            # Note that `hydrate()` and `complete` don't need to be called here\n            # because this path only happens for re-rendering from the view\n            cached_component.setup(request)\n            cached_component._validate_called = False\n            cached_component.calls = []\n            logger.debug(f\"Retrieve {component_id} from constructed views cache\")\n\n            return cached_component\n\n        if component_id in views_cache:\n            (component_class, parent, kwargs) = views_cache[component_id]\n\n            component = construct_component(\n                component_class=component_class,\n                component_id=component_id,\n                component_name=component_name,\n                component_key=component_key,\n                parent=parent,\n                request=request,\n                **kwargs,\n            )\n            logger.debug(f\"Retrieve {component_id} from views cache\")\n\n            return component\n\n        locations = []\n\n        if component_name in location_cache:\n            locations.append(location_cache[component_name])\n        else:\n            locations = get_locations(component_name)\n\n        # Store the last exception that got raised while looking for a component in case it is useful context\n        last_exception: Union[\n            Optional[ModuleNotFoundError], Optional[AttributeError]\n        ] = None\n\n        for (class_name, module_name) in locations:\n            try:\n                component_class = _get_component_class(module_name, class_name)\n                component = construct_component(\n                    component_class=component_class,\n                    component_id=component_id,\n                    component_name=component_name,\n                    component_key=component_key,\n                    parent=parent,\n                    request=request,\n                    **kwargs,\n                )\n\n                # Put the location for the component name in a module cache\n                location_cache[component_name] = (class_name, module_name)\n\n                # Put the component's class in a module cache\n                views_cache[component_id] = (component_class, parent, kwargs)\n\n                # Put the instantiated component into a module cache and the Django cache\n                cacheable_component = None\n\n                try:\n                    cacheable_component = get_cacheable_component(component)\n                except UnicornCacheError as e:\n                    logger.warning(e)\n\n                if cacheable_component:\n                    if COMPONENTS_MODULE_CACHE_ENABLED:\n                        constructed_views_cache[component_id] = cacheable_component\n\n                    cache.set(\n                        cacheable_component.component_cache_key, cacheable_component\n                    )\n\n                return component\n            except ModuleNotFoundError as e:\n                last_exception = e\n            except AttributeError as e:\n                last_exception = e\n\n        raise ComponentLoadError(\n            f\"'{component_name}' component could not be loaded: {last_exception}\"\n        ) from last_exception\n", "patch": "@@ -10,7 +10,6 @@\n from django.core.exceptions import ImproperlyConfigured\n from django.db.models import Model\n from django.http import HttpRequest\n-from django.utils.html import conditional_escape\n from django.views.generic.base import TemplateView\n \n from cachetools.lru import LRUCache\n@@ -341,14 +340,6 @@ def get_frontend_context_variables(self) -> str:\n                     if field_name in frontend_context_variables:\n                         del frontend_context_variables[field_name]\n \n-        safe_fields = []\n-        # Keep a list of fields that are safe to not sanitize from `frontend_context_variables`\n-        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"safe\"):\n-            if isinstance(self.Meta.safe, Sequence):\n-                for field_name in self.Meta.safe:\n-                    if field_name in frontend_context_variables:\n-                        safe_fields.append(field_name)\n-\n         # Add cleaned values to `frontend_content_variables` based on the widget in form's fields\n         form = self._get_form(attributes)\n \n@@ -372,18 +363,6 @@ def get_frontend_context_variables(self) -> str:\n                         ):\n                             frontend_context_variables[key] = value\n \n-        for (\n-            frontend_context_variable_key,\n-            frontend_context_variable_value,\n-        ) in frontend_context_variables.items():\n-            if (\n-                isinstance(frontend_context_variable_value, str)\n-                and frontend_context_variable_key not in safe_fields\n-            ):\n-                frontend_context_variables[frontend_context_variable_key] = escape(\n-                    frontend_context_variable_value\n-                )\n-\n         encoded_frontend_context_variables = serializer.dumps(\n             frontend_context_variables\n         )", "file_path": "files/2021_10/788", "file_language": "py", "file_name": "django_unicorn/components/unicorn_view.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def convert_to_snake_case(s: str) -> str:\n    # TODO: Better handling of dash->snake\n    return s.replace(\"-\", \"_\")", "target": 0}, {"function": "def convert_to_pascal_case(s: str) -> str:\n    # TODO: Better handling of dash/snake->pascal-case\n    s = convert_to_snake_case(s)\n    return \"\".join(word.title() for word in s.split(\"_\"))", "target": 0}, {"function": "def get_locations(component_name):\n    locations = []\n\n    if \".\" in component_name:\n        # Handle component names that specify a folder structure\n        component_name = component_name.replace(\"/\", \".\")\n\n        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)\n        class_name = component_name.split(\".\")[-1:][0]\n        module_name = component_name.replace(\".\" + class_name, \"\")\n        locations.append((class_name, module_name))\n\n        # Assume if it ends with \"View\", then we don't need to add other\n        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):\n            return locations\n\n    # Handle component names that specify a folder structure\n    component_name = component_name.replace(\"/\", \".\")\n\n    # Use conventions to find the component class\n    class_name = convert_to_pascal_case(component_name)\n\n    if \".\" in class_name:\n        if class_name.split(\".\")[-1:]:\n            class_name = class_name.split(\".\")[-1:][0]\n\n    class_name = f\"{class_name}View\"\n    module_name = convert_to_snake_case(component_name)\n\n    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)\n\n    assert (\n        isinstance(unicorn_apps, list)\n        or isinstance(unicorn_apps, tuple)\n        or isinstance(unicorn_apps, set)\n    ), \"APPS is expected to be a list, tuple or set\"\n\n    for app in unicorn_apps:\n        # Handle an installed app that actually points to an app config\n        if \".apps.\" in app:\n            app_config_idx = app.rindex(\".apps.\")\n            app = app[:app_config_idx]\n\n        app_module_name = f\"{app}.components.{module_name}\"\n        locations.append((class_name, app_module_name))\n\n    return locations", "target": 0}, {"function": "class UnicornView(TemplateView):\n    response_class = UnicornTemplateResponse\n    component_name: str = \"\"\n    component_key: str = \"\"\n    request = None\n    parent = None\n    children = []\n\n    # Caches to reduce the amount of time introspecting the class\n    _methods_cache: Dict[str, Callable] = {}\n    _attribute_names_cache: List[str] = []\n    _hook_methods_cache: List[str] = []\n\n    # Dictionary with key: attribute name; value: pickled attribute value\n    _resettable_attributes_cache: Dict[str, Any] = {}\n\n    # JavaScript method calls\n    calls = []\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        assert self.component_name, \"Component name is required\"\n\n        if \"id\" in kwargs and kwargs[\"id\"]:\n            # Sometimes the component_id is initially in kwargs[\"id\"]\n            self.component_id = kwargs[\"id\"]\n\n        assert hasattr(self, \"component_id\"), \"Component id is required\"\n        assert self.component_id, \"Component id is required\"\n        self.component_cache_key = f\"unicorn:component:{self.component_id}\"\n\n        if \"request\" in kwargs:\n            self.setup(kwargs[\"request\"])\n\n        if \"parent\" in kwargs:\n            self.parent = kwargs[\"parent\"]\n\n        self._init_script: str = \"\"\n        self._children_set = False\n        self._validate_called = False\n        self.errors = {}\n        self._set_default_template_name()\n        self._set_caches()\n\n    @timed\n    def _set_default_template_name(self) -> None:\n        \"\"\"\n        Sets a default template name based on component's name if necessary.\n        \"\"\"\n        get_template_names_is_valid = False\n\n        try:\n            # Check for get_template_names by explicitly calling it since it\n            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.\n            self.get_template_names()\n            get_template_names_is_valid = True\n        except ImproperlyConfigured:\n            pass\n\n        if not self.template_name and not get_template_names_is_valid:\n            # Convert component name with a dot to a folder structure\n            template_name = self.component_name.replace(\".\", \"/\")\n            self.template_name = f\"unicorn/{template_name}.html\"\n\n    @timed\n    def _set_caches(self) -> None:\n        \"\"\"\n        Setup some initial \"caches\" to prevent Python from having to introspect\n        a component UnicornView for methods and properties multiple times.\n        \"\"\"\n        self._attribute_names_cache = self._attribute_names()\n        self._set_hook_methods_cache()\n        self._methods_cache = self._methods()\n        self._set_resettable_attributes_cache()\n\n    @timed\n    def reset(self):\n        for (\n            attribute_name,\n            pickled_value,\n        ) in self._resettable_attributes_cache.items():\n            try:\n                attribute_value = pickle.loads(pickled_value)\n                self._set_property(attribute_name, attribute_value)\n            except TypeError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"\n                )\n                pass\n            except pickle.PickleError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"\n                )\n                pass\n\n    def call(self, function_name, *args):\n        \"\"\"\n        Add a JavaScript method name and arguments to be called after the component is rendered.\n        \"\"\"\n        self.calls.append({\"fn\": function_name, \"args\": args})\n\n    def mount(self):\n        \"\"\"\n        Hook that gets called when the component is first created.\n        \"\"\"\n        pass\n\n    def hydrate(self):\n        \"\"\"\n        Hook that gets called when the component's data is hydrated.\n        \"\"\"\n        pass\n\n    def complete(self):\n        \"\"\"\n        Hook that gets called after all component methods are executed.\n        \"\"\"\n        pass\n\n    def rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component has been rendered.\n        \"\"\"\n        pass\n\n    def parent_rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component's parent has been rendered.\n        \"\"\"\n        pass\n\n    def updating(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is about to get updated.\n        \"\"\"\n        pass\n\n    def updated(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is updated.\n        \"\"\"\n        pass\n\n    def calling(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is about to get called.\n        \"\"\"\n        pass\n\n    def called(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is called.\n        \"\"\"\n        pass\n\n    @timed\n    def render(self, init_js=False) -> str:\n        \"\"\"\n        Renders a UnicornView component with the public properties available. Delegates to a\n        UnicornTemplateResponse to actually render a response.\n \n        Args:\n            param init_js: Whether or not to include the Javascript required to initialize the component.\n        \"\"\"\n\n        response = self.render_to_response(\n            context=self.get_context_data(), component=self, init_js=init_js,\n        )\n\n        # render_to_response() could only return a HttpResponse, so check for render()\n        if hasattr(response, \"render\"):\n            response.render()\n\n        rendered_component = response.content.decode(\"utf-8\")\n\n        # Set the current component as a child of the parent if there is a parent\n        # If no parent, mark that the component has its children set.\n        # This works because the nested (internal) components get rendered first before the parent,\n        # so once we hit a component without a parent we know all of the children have been rendered correctly\n        # TODO: This might fall apart with a third layer of nesting components\n        if self.parent:\n            if not self.parent._children_set:\n                self.parent.children.append(self)\n        else:\n            self._children_set = True\n\n        return rendered_component\n\n    @timed\n    def get_frontend_context_variables(self) -> str:\n        \"\"\"\n        Get publicly available properties and output them in a string-encoded JSON object.\n        \"\"\"\n\n        frontend_context_variables = {}\n        attributes = self._attributes()\n        frontend_context_variables.update(attributes)\n\n        # Remove any field in `javascript_exclude` from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):\n            if isinstance(self.Meta.javascript_exclude, Sequence):\n                for field_name in self.Meta.javascript_exclude:\n                    if field_name in frontend_context_variables:\n                        del frontend_context_variables[field_name]\n\n        safe_fields = []\n        # Keep a list of fields that are safe to not sanitize from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"safe\"):\n            if isinstance(self.Meta.safe, Sequence):\n                for field_name in self.Meta.safe:\n                    if field_name in frontend_context_variables:\n                        safe_fields.append(field_name)\n\n        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields\n        form = self._get_form(attributes)\n\n        if form:\n            form.is_valid()\n\n            for key in attributes.keys():\n                if key in form.fields:\n                    field = form.fields[key]\n\n                    if key in form.cleaned_data:\n                        cleaned_value = form.cleaned_data[key]\n                        value = field.widget.format_value(cleaned_value)\n\n                        # Don't update the frontend variable if the only change is\n                        # stripping off the whitespace from the field value\n                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n                        if (\n                            not hasattr(frontend_context_variables[key], \"strip\")\n                            or frontend_context_variables[key].strip() != value\n                        ):\n                            frontend_context_variables[key] = value\n\n        for (\n            frontend_context_variable_key,\n            frontend_context_variable_value,\n        ) in frontend_context_variables.items():\n            if (\n                isinstance(frontend_context_variable_value, str)\n                and frontend_context_variable_key not in safe_fields\n            ):\n                frontend_context_variables[frontend_context_variable_key] = escape(\n                    frontend_context_variable_value\n                )\n\n        encoded_frontend_context_variables = serializer.dumps(\n            frontend_context_variables\n        )\n\n        return encoded_frontend_context_variables\n\n    @timed\n    def _get_form(self, data):\n        if hasattr(self, \"form_class\"):\n            try:\n                form = self.form_class(data)\n                form.is_valid()\n\n                return form\n            except Exception as e:\n                logger.exception(e)\n\n    @timed\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Overrides the standard `get_context_data` to add in publicly available\n        properties and methods.\n        \"\"\"\n\n        context = super().get_context_data(**kwargs)\n\n        attributes = self._attributes()\n        context.update(attributes)\n        context.update(self._methods())\n        context.update({\"unicorn\": {\"errors\": self.errors}})\n\n        return context\n\n    @timed\n    def is_valid(self, model_names: List = None) -> bool:\n        return len(self.validate(model_names).keys()) == 0\n\n    @timed\n    def validate(self, model_names: List = None) -> Dict:\n        \"\"\"\n        Validates the data using the `form_class` set on the component.\n\n        Args:\n            model_names: Only include validation errors for specified fields. If none, validate everything.\n        \"\"\"\n        # TODO: Handle form.non_field_errors()?\n\n        if self._validate_called:\n            return self.errors\n\n        self._validate_called = True\n\n        data = self._attributes()\n        form = self._get_form(data)\n\n        if form:\n            form_errors = form.errors.get_json_data(escape_html=True)\n\n            # This code is confusing, but handles this use-case:\n            # the component has two models, one that starts with an error and one\n            # that is valid. Validating the valid one should not show an error for\n            # the invalid one. Only after the invalid field is updated, should the\n            # error show up and persist, even after updating the valid form.\n            if self.errors:\n                keys_to_remove = []\n\n                for key, value in self.errors.items():\n                    if key in form_errors:\n                        self.errors[key] = value\n                    else:\n                        keys_to_remove.append(key)\n\n                for key in keys_to_remove:\n                    self.errors.pop(key)\n\n            if model_names is not None:\n                for key, value in form_errors.items():\n                    if key in model_names:\n                        self.errors[key] = value\n            else:\n                self.errors.update(form_errors)\n\n        return self.errors\n\n    @timed\n    def _attribute_names(self) -> List[str]:\n        \"\"\"\n        Gets publicly available attribute names. Cached in `_attribute_names_cache`.\n        \"\"\"\n        non_callables = [\n            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))\n        ]\n        attribute_names = [name for name in non_callables if self._is_public(name)]\n\n        return attribute_names\n\n    @timed\n    def _attributes(self) -> Dict[str, Any]:\n        \"\"\"\n        Get publicly available attributes and their values from the component.\n        \"\"\"\n\n        attribute_names = self._attribute_names_cache\n        attributes = {}\n\n        for attribute_name in attribute_names:\n            attributes[attribute_name] = getattr(self, attribute_name)\n\n        return attributes\n\n    @timed\n    def _set_property(self, name, value):\n        # Get the correct value type by using the form if it is available\n        data = self._attributes()\n        data[name] = value\n        form = self._get_form(data)\n\n        if form and name in form.fields and name in form.cleaned_data:\n            # The Django form CharField validator will remove whitespace\n            # from the field value. Ignore that update if it's the\n            # only thing different from the validator\n            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():\n                value = form.cleaned_data[name]\n\n        updating_function_name = f\"updating_{name}\"\n        if hasattr(self, updating_function_name):\n            getattr(self, updating_function_name)(value)\n\n        try:\n            setattr(self, name, value)\n\n            updated_function_name = f\"updated_{name}\"\n\n            if hasattr(self, updated_function_name):\n                getattr(self, updated_function_name)(value)\n        except AttributeError as e:\n            raise\n\n    @timed\n    def _methods(self) -> Dict[str, Callable]:\n        \"\"\"\n        Get publicly available method names and their functions from the component.\n        Cached in `_methods_cache`.\n        \"\"\"\n\n        if self._methods_cache:\n            return self._methods_cache\n\n        member_methods = inspect.getmembers(self, inspect.ismethod)\n        public_methods = [\n            method for method in member_methods if self._is_public(method[0])\n        ]\n        methods = {k: v for (k, v) in public_methods}\n        self._methods_cache = methods\n\n        return methods\n\n    @timed\n    def _set_hook_methods_cache(self) -> None:\n        \"\"\"\n        Caches the updating/updated attribute function names defined on the component.\n        \"\"\"\n        self._hook_methods_cache = []\n\n        for attribute_name in self._attribute_names_cache:\n            updating_function_name = f\"updating_{attribute_name}\"\n            updated_function_name = f\"updated_{attribute_name}\"\n            hook_function_names = [updating_function_name, updated_function_name]\n\n            for function_name in hook_function_names:\n                if hasattr(self, function_name):\n                    self._hook_methods_cache.append(function_name)\n\n    @timed\n    def _set_resettable_attributes_cache(self) -> None:\n        \"\"\"\n        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.\n        Cache is a dictionary with key: attribute name; value: pickled attribute value\n\n        Examples:\n            - `UnicornField`\n            - Django Models without a defined pk\n        \"\"\"\n        self._resettable_attributes_cache = {}\n\n        for attribute_name, attribute_value in self._attributes().items():\n            if isinstance(attribute_value, UnicornField):\n                self._resettable_attributes_cache[attribute_name] = pickle.dumps(\n                    attribute_value\n                )\n            elif isinstance(attribute_value, Model):\n                if not attribute_value.pk:\n                    if attribute_name not in self._resettable_attributes_cache:\n                        try:\n                            self._resettable_attributes_cache[\n                                attribute_name\n                            ] = pickle.dumps(attribute_value)\n                        except pickle.PickleError:\n                            logger.warn(\n                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"\n                            )\n                            pass\n\n    def _is_public(self, name: str) -> bool:\n        \"\"\"\n        Determines if the name should be sent in the context.\n        \"\"\"\n\n        # Ignore some standard attributes from TemplateView\n        protected_names = (\n            \"render\",\n            \"request\",\n            \"args\",\n            \"kwargs\",\n            \"content_type\",\n            \"extra_context\",\n            \"http_method_names\",\n            \"template_engine\",\n            \"template_name\",\n            \"dispatch\",\n            \"id\",\n            \"get\",\n            \"get_context_data\",\n            \"get_template_names\",\n            \"render_to_response\",\n            \"http_method_not_allowed\",\n            \"options\",\n            \"setup\",\n            \"fill\",\n            # Component methods\n            \"component_id\",\n            \"component_name\",\n            \"component_key\",\n            \"reset\",\n            \"mount\",\n            \"hydrate\",\n            \"updating\",\n            \"update\",\n            \"calling\",\n            \"called\",\n            \"complete\",\n            \"rendered\",\n            \"parent_rendered\",\n            \"validate\",\n            \"is_valid\",\n            \"get_frontend_context_variables\",\n            \"errors\",\n            \"updated\",\n            \"parent\",\n            \"children\",\n            \"call\",\n            \"calls\",\n            \"component_cache_key\",\n        )\n        excludes = []\n\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):\n            if isinstance(self.Meta.exclude, Sequence):\n                excludes = self.Meta.exclude\n\n        return not (\n            name.startswith(\"_\")\n            or name in protected_names\n            or name in self._hook_methods_cache\n            or name in excludes\n        )\n\n    @staticmethod\n    @timed\n    def create(\n        component_id: str,\n        component_name: str,\n        component_key: str = \"\",\n        parent: \"UnicornView\" = None,\n        request: HttpRequest = None,\n        use_cache=True,\n        kwargs: Dict[str, Any] = {},\n    ) -> \"UnicornView\":\n        \"\"\"\n        Find and instantiate a component class based on `component_name`.\n\n        Args:\n            param component_id: Id of the component. Required.\n            param component_name: Name of the component. Used to locate the correct `UnicornView`\n                component class and template if necessary. Required.\n            param component_key: Key of the component to allow multiple components of the same name\n                to be differentiated. Optional.\n            param parent: The parent component of the current component.\n            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.\n        \n        Returns:\n            Instantiated `UnicornView` component.\n            Raises `ComponentLoadError` if the component could not be loaded.\n        \"\"\"\n        assert component_id, \"Component id is required\"\n        assert component_name, \"Component name is required\"\n\n        @timed\n        def _get_component_class(\n            module_name: str, class_name: str\n        ) -> Type[UnicornView]:\n            \"\"\"\n            Imports a component based on module and class name.\n            \"\"\"\n            module = importlib.import_module(module_name)\n            component_class = getattr(module, class_name)\n\n            return component_class\n\n        cache = caches[get_cache_alias()]\n        component_cache_key = f\"unicorn:component:{component_id}\"\n        cached_component = cache.get(component_cache_key)\n\n        if cached_component:\n            # Get the newest version of the parent from cache if it is available\n            # This needs to happen for Django cache because instances is pickled, so\n            # a change in the view won't be reflected automatically (like with the module\n            # cache) so it needs to be retrieved manually.\n            if cached_component.parent:\n                cached_parent_component = cache.get(\n                    cached_component.parent.component_cache_key\n                )\n\n                if cached_parent_component:\n                    cached_component.parent = cached_parent_component\n                    cached_component.parent.setup(request)\n        else:\n            cached_component = constructed_views_cache.get(component_id)\n\n        if use_cache and cached_component:\n            # Note that `hydrate()` and `complete` don't need to be called here\n            # because this path only happens for re-rendering from the view\n            cached_component.setup(request)\n            cached_component._validate_called = False\n            cached_component.calls = []\n            logger.debug(f\"Retrieve {component_id} from constructed views cache\")\n\n            return cached_component\n\n        if component_id in views_cache:\n            (component_class, parent, kwargs) = views_cache[component_id]\n\n            component = construct_component(\n                component_class=component_class,\n                component_id=component_id,\n                component_name=component_name,\n                component_key=component_key,\n                parent=parent,\n                request=request,\n                **kwargs,\n            )\n            logger.debug(f\"Retrieve {component_id} from views cache\")\n\n            return component\n\n        locations = []\n\n        if component_name in location_cache:\n            locations.append(location_cache[component_name])\n        else:\n            locations = get_locations(component_name)\n\n        # Store the last exception that got raised while looking for a component in case it is useful context\n        last_exception: Union[\n            Optional[ModuleNotFoundError], Optional[AttributeError]\n        ] = None\n\n        for (class_name, module_name) in locations:\n            try:\n                component_class = _get_component_class(module_name, class_name)\n                component = construct_component(\n                    component_class=component_class,\n                    component_id=component_id,\n                    component_name=component_name,\n                    component_key=component_key,\n                    parent=parent,\n                    request=request,\n                    **kwargs,\n                )\n\n                # Put the location for the component name in a module cache\n                location_cache[component_name] = (class_name, module_name)\n\n                # Put the component's class in a module cache\n                views_cache[component_id] = (component_class, parent, kwargs)\n\n                # Put the instantiated component into a module cache and the Django cache\n                cacheable_component = None\n\n                try:\n                    cacheable_component = get_cacheable_component(component)\n                except UnicornCacheError as e:\n                    logger.warning(e)\n\n                if cacheable_component:\n                    if COMPONENTS_MODULE_CACHE_ENABLED:\n                        constructed_views_cache[component_id] = cacheable_component\n\n                    cache.set(\n                        cacheable_component.component_cache_key, cacheable_component\n                    )\n\n                return component\n            except ModuleNotFoundError as e:\n                last_exception = e\n            except AttributeError as e:\n                last_exception = e\n\n        raise ComponentLoadError(\n            f\"'{component_name}' component could not be loaded: {last_exception}\"\n        ) from last_exception", "target": 0}], "function_after": [{"function": "def convert_to_snake_case(s: str) -> str:\n    # TODO: Better handling of dash->snake\n    return s.replace(\"-\", \"_\")", "target": 0}, {"function": "def convert_to_pascal_case(s: str) -> str:\n    # TODO: Better handling of dash/snake->pascal-case\n    s = convert_to_snake_case(s)\n    return \"\".join(word.title() for word in s.split(\"_\"))", "target": 0}, {"function": "def get_locations(component_name):\n    locations = []\n\n    if \".\" in component_name:\n        # Handle component names that specify a folder structure\n        component_name = component_name.replace(\"/\", \".\")\n\n        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)\n        class_name = component_name.split(\".\")[-1:][0]\n        module_name = component_name.replace(\".\" + class_name, \"\")\n        locations.append((class_name, module_name))\n\n        # Assume if it ends with \"View\", then we don't need to add other\n        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):\n            return locations\n\n    # Handle component names that specify a folder structure\n    component_name = component_name.replace(\"/\", \".\")\n\n    # Use conventions to find the component class\n    class_name = convert_to_pascal_case(component_name)\n\n    if \".\" in class_name:\n        if class_name.split(\".\")[-1:]:\n            class_name = class_name.split(\".\")[-1:][0]\n\n    class_name = f\"{class_name}View\"\n    module_name = convert_to_snake_case(component_name)\n\n    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)\n\n    assert (\n        isinstance(unicorn_apps, list)\n        or isinstance(unicorn_apps, tuple)\n        or isinstance(unicorn_apps, set)\n    ), \"APPS is expected to be a list, tuple or set\"\n\n    for app in unicorn_apps:\n        # Handle an installed app that actually points to an app config\n        if \".apps.\" in app:\n            app_config_idx = app.rindex(\".apps.\")\n            app = app[:app_config_idx]\n\n        app_module_name = f\"{app}.components.{module_name}\"\n        locations.append((class_name, app_module_name))\n\n    return locations", "target": 0}, {"function": "class UnicornView(TemplateView):\n    response_class = UnicornTemplateResponse\n    component_name: str = \"\"\n    component_key: str = \"\"\n    request = None\n    parent = None\n    children = []\n\n    # Caches to reduce the amount of time introspecting the class\n    _methods_cache: Dict[str, Callable] = {}\n    _attribute_names_cache: List[str] = []\n    _hook_methods_cache: List[str] = []\n\n    # Dictionary with key: attribute name; value: pickled attribute value\n    _resettable_attributes_cache: Dict[str, Any] = {}\n\n    # JavaScript method calls\n    calls = []\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        assert self.component_name, \"Component name is required\"\n\n        if \"id\" in kwargs and kwargs[\"id\"]:\n            # Sometimes the component_id is initially in kwargs[\"id\"]\n            self.component_id = kwargs[\"id\"]\n\n        assert hasattr(self, \"component_id\"), \"Component id is required\"\n        assert self.component_id, \"Component id is required\"\n        self.component_cache_key = f\"unicorn:component:{self.component_id}\"\n\n        if \"request\" in kwargs:\n            self.setup(kwargs[\"request\"])\n\n        if \"parent\" in kwargs:\n            self.parent = kwargs[\"parent\"]\n\n        self._init_script: str = \"\"\n        self._children_set = False\n        self._validate_called = False\n        self.errors = {}\n        self._set_default_template_name()\n        self._set_caches()\n\n    @timed\n    def _set_default_template_name(self) -> None:\n        \"\"\"\n        Sets a default template name based on component's name if necessary.\n        \"\"\"\n        get_template_names_is_valid = False\n\n        try:\n            # Check for get_template_names by explicitly calling it since it\n            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.\n            self.get_template_names()\n            get_template_names_is_valid = True\n        except ImproperlyConfigured:\n            pass\n\n        if not self.template_name and not get_template_names_is_valid:\n            # Convert component name with a dot to a folder structure\n            template_name = self.component_name.replace(\".\", \"/\")\n            self.template_name = f\"unicorn/{template_name}.html\"\n\n    @timed\n    def _set_caches(self) -> None:\n        \"\"\"\n        Setup some initial \"caches\" to prevent Python from having to introspect\n        a component UnicornView for methods and properties multiple times.\n        \"\"\"\n        self._attribute_names_cache = self._attribute_names()\n        self._set_hook_methods_cache()\n        self._methods_cache = self._methods()\n        self._set_resettable_attributes_cache()\n\n    @timed\n    def reset(self):\n        for (\n            attribute_name,\n            pickled_value,\n        ) in self._resettable_attributes_cache.items():\n            try:\n                attribute_value = pickle.loads(pickled_value)\n                self._set_property(attribute_name, attribute_value)\n            except TypeError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"\n                )\n                pass\n            except pickle.PickleError:\n                logger.warn(\n                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"\n                )\n                pass\n\n    def call(self, function_name, *args):\n        \"\"\"\n        Add a JavaScript method name and arguments to be called after the component is rendered.\n        \"\"\"\n        self.calls.append({\"fn\": function_name, \"args\": args})\n\n    def mount(self):\n        \"\"\"\n        Hook that gets called when the component is first created.\n        \"\"\"\n        pass\n\n    def hydrate(self):\n        \"\"\"\n        Hook that gets called when the component's data is hydrated.\n        \"\"\"\n        pass\n\n    def complete(self):\n        \"\"\"\n        Hook that gets called after all component methods are executed.\n        \"\"\"\n        pass\n\n    def rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component has been rendered.\n        \"\"\"\n        pass\n\n    def parent_rendered(self, html):\n        \"\"\"\n        Hook that gets called after the component's parent has been rendered.\n        \"\"\"\n        pass\n\n    def updating(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is about to get updated.\n        \"\"\"\n        pass\n\n    def updated(self, name, value):\n        \"\"\"\n        Hook that gets called when a component's data is updated.\n        \"\"\"\n        pass\n\n    def calling(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is about to get called.\n        \"\"\"\n        pass\n\n    def called(self, name, args):\n        \"\"\"\n        Hook that gets called when a component's method is called.\n        \"\"\"\n        pass\n\n    @timed\n    def render(self, init_js=False) -> str:\n        \"\"\"\n        Renders a UnicornView component with the public properties available. Delegates to a\n        UnicornTemplateResponse to actually render a response.\n \n        Args:\n            param init_js: Whether or not to include the Javascript required to initialize the component.\n        \"\"\"\n\n        response = self.render_to_response(\n            context=self.get_context_data(), component=self, init_js=init_js,\n        )\n\n        # render_to_response() could only return a HttpResponse, so check for render()\n        if hasattr(response, \"render\"):\n            response.render()\n\n        rendered_component = response.content.decode(\"utf-8\")\n\n        # Set the current component as a child of the parent if there is a parent\n        # If no parent, mark that the component has its children set.\n        # This works because the nested (internal) components get rendered first before the parent,\n        # so once we hit a component without a parent we know all of the children have been rendered correctly\n        # TODO: This might fall apart with a third layer of nesting components\n        if self.parent:\n            if not self.parent._children_set:\n                self.parent.children.append(self)\n        else:\n            self._children_set = True\n\n        return rendered_component\n\n    @timed\n    def get_frontend_context_variables(self) -> str:\n        \"\"\"\n        Get publicly available properties and output them in a string-encoded JSON object.\n        \"\"\"\n\n        frontend_context_variables = {}\n        attributes = self._attributes()\n        frontend_context_variables.update(attributes)\n\n        # Remove any field in `javascript_exclude` from `frontend_context_variables`\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):\n            if isinstance(self.Meta.javascript_exclude, Sequence):\n                for field_name in self.Meta.javascript_exclude:\n                    if field_name in frontend_context_variables:\n                        del frontend_context_variables[field_name]\n\n        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields\n        form = self._get_form(attributes)\n\n        if form:\n            form.is_valid()\n\n            for key in attributes.keys():\n                if key in form.fields:\n                    field = form.fields[key]\n\n                    if key in form.cleaned_data:\n                        cleaned_value = form.cleaned_data[key]\n                        value = field.widget.format_value(cleaned_value)\n\n                        # Don't update the frontend variable if the only change is\n                        # stripping off the whitespace from the field value\n                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n                        if (\n                            not hasattr(frontend_context_variables[key], \"strip\")\n                            or frontend_context_variables[key].strip() != value\n                        ):\n                            frontend_context_variables[key] = value\n\n        encoded_frontend_context_variables = serializer.dumps(\n            frontend_context_variables\n        )\n\n        return encoded_frontend_context_variables\n\n    @timed\n    def _get_form(self, data):\n        if hasattr(self, \"form_class\"):\n            try:\n                form = self.form_class(data)\n                form.is_valid()\n\n                return form\n            except Exception as e:\n                logger.exception(e)\n\n    @timed\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Overrides the standard `get_context_data` to add in publicly available\n        properties and methods.\n        \"\"\"\n\n        context = super().get_context_data(**kwargs)\n\n        attributes = self._attributes()\n        context.update(attributes)\n        context.update(self._methods())\n        context.update({\"unicorn\": {\"errors\": self.errors}})\n\n        return context\n\n    @timed\n    def is_valid(self, model_names: List = None) -> bool:\n        return len(self.validate(model_names).keys()) == 0\n\n    @timed\n    def validate(self, model_names: List = None) -> Dict:\n        \"\"\"\n        Validates the data using the `form_class` set on the component.\n\n        Args:\n            model_names: Only include validation errors for specified fields. If none, validate everything.\n        \"\"\"\n        # TODO: Handle form.non_field_errors()?\n\n        if self._validate_called:\n            return self.errors\n\n        self._validate_called = True\n\n        data = self._attributes()\n        form = self._get_form(data)\n\n        if form:\n            form_errors = form.errors.get_json_data(escape_html=True)\n\n            # This code is confusing, but handles this use-case:\n            # the component has two models, one that starts with an error and one\n            # that is valid. Validating the valid one should not show an error for\n            # the invalid one. Only after the invalid field is updated, should the\n            # error show up and persist, even after updating the valid form.\n            if self.errors:\n                keys_to_remove = []\n\n                for key, value in self.errors.items():\n                    if key in form_errors:\n                        self.errors[key] = value\n                    else:\n                        keys_to_remove.append(key)\n\n                for key in keys_to_remove:\n                    self.errors.pop(key)\n\n            if model_names is not None:\n                for key, value in form_errors.items():\n                    if key in model_names:\n                        self.errors[key] = value\n            else:\n                self.errors.update(form_errors)\n\n        return self.errors\n\n    @timed\n    def _attribute_names(self) -> List[str]:\n        \"\"\"\n        Gets publicly available attribute names. Cached in `_attribute_names_cache`.\n        \"\"\"\n        non_callables = [\n            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))\n        ]\n        attribute_names = [name for name in non_callables if self._is_public(name)]\n\n        return attribute_names\n\n    @timed\n    def _attributes(self) -> Dict[str, Any]:\n        \"\"\"\n        Get publicly available attributes and their values from the component.\n        \"\"\"\n\n        attribute_names = self._attribute_names_cache\n        attributes = {}\n\n        for attribute_name in attribute_names:\n            attributes[attribute_name] = getattr(self, attribute_name)\n\n        return attributes\n\n    @timed\n    def _set_property(self, name, value):\n        # Get the correct value type by using the form if it is available\n        data = self._attributes()\n        data[name] = value\n        form = self._get_form(data)\n\n        if form and name in form.fields and name in form.cleaned_data:\n            # The Django form CharField validator will remove whitespace\n            # from the field value. Ignore that update if it's the\n            # only thing different from the validator\n            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip\n            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():\n                value = form.cleaned_data[name]\n\n        updating_function_name = f\"updating_{name}\"\n        if hasattr(self, updating_function_name):\n            getattr(self, updating_function_name)(value)\n\n        try:\n            setattr(self, name, value)\n\n            updated_function_name = f\"updated_{name}\"\n\n            if hasattr(self, updated_function_name):\n                getattr(self, updated_function_name)(value)\n        except AttributeError as e:\n            raise\n\n    @timed\n    def _methods(self) -> Dict[str, Callable]:\n        \"\"\"\n        Get publicly available method names and their functions from the component.\n        Cached in `_methods_cache`.\n        \"\"\"\n\n        if self._methods_cache:\n            return self._methods_cache\n\n        member_methods = inspect.getmembers(self, inspect.ismethod)\n        public_methods = [\n            method for method in member_methods if self._is_public(method[0])\n        ]\n        methods = {k: v for (k, v) in public_methods}\n        self._methods_cache = methods\n\n        return methods\n\n    @timed\n    def _set_hook_methods_cache(self) -> None:\n        \"\"\"\n        Caches the updating/updated attribute function names defined on the component.\n        \"\"\"\n        self._hook_methods_cache = []\n\n        for attribute_name in self._attribute_names_cache:\n            updating_function_name = f\"updating_{attribute_name}\"\n            updated_function_name = f\"updated_{attribute_name}\"\n            hook_function_names = [updating_function_name, updated_function_name]\n\n            for function_name in hook_function_names:\n                if hasattr(self, function_name):\n                    self._hook_methods_cache.append(function_name)\n\n    @timed\n    def _set_resettable_attributes_cache(self) -> None:\n        \"\"\"\n        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.\n        Cache is a dictionary with key: attribute name; value: pickled attribute value\n\n        Examples:\n            - `UnicornField`\n            - Django Models without a defined pk\n        \"\"\"\n        self._resettable_attributes_cache = {}\n\n        for attribute_name, attribute_value in self._attributes().items():\n            if isinstance(attribute_value, UnicornField):\n                self._resettable_attributes_cache[attribute_name] = pickle.dumps(\n                    attribute_value\n                )\n            elif isinstance(attribute_value, Model):\n                if not attribute_value.pk:\n                    if attribute_name not in self._resettable_attributes_cache:\n                        try:\n                            self._resettable_attributes_cache[\n                                attribute_name\n                            ] = pickle.dumps(attribute_value)\n                        except pickle.PickleError:\n                            logger.warn(\n                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"\n                            )\n                            pass\n\n    def _is_public(self, name: str) -> bool:\n        \"\"\"\n        Determines if the name should be sent in the context.\n        \"\"\"\n\n        # Ignore some standard attributes from TemplateView\n        protected_names = (\n            \"render\",\n            \"request\",\n            \"args\",\n            \"kwargs\",\n            \"content_type\",\n            \"extra_context\",\n            \"http_method_names\",\n            \"template_engine\",\n            \"template_name\",\n            \"dispatch\",\n            \"id\",\n            \"get\",\n            \"get_context_data\",\n            \"get_template_names\",\n            \"render_to_response\",\n            \"http_method_not_allowed\",\n            \"options\",\n            \"setup\",\n            \"fill\",\n            # Component methods\n            \"component_id\",\n            \"component_name\",\n            \"component_key\",\n            \"reset\",\n            \"mount\",\n            \"hydrate\",\n            \"updating\",\n            \"update\",\n            \"calling\",\n            \"called\",\n            \"complete\",\n            \"rendered\",\n            \"parent_rendered\",\n            \"validate\",\n            \"is_valid\",\n            \"get_frontend_context_variables\",\n            \"errors\",\n            \"updated\",\n            \"parent\",\n            \"children\",\n            \"call\",\n            \"calls\",\n            \"component_cache_key\",\n        )\n        excludes = []\n\n        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):\n            if isinstance(self.Meta.exclude, Sequence):\n                excludes = self.Meta.exclude\n\n        return not (\n            name.startswith(\"_\")\n            or name in protected_names\n            or name in self._hook_methods_cache\n            or name in excludes\n        )\n\n    @staticmethod\n    @timed\n    def create(\n        component_id: str,\n        component_name: str,\n        component_key: str = \"\",\n        parent: \"UnicornView\" = None,\n        request: HttpRequest = None,\n        use_cache=True,\n        kwargs: Dict[str, Any] = {},\n    ) -> \"UnicornView\":\n        \"\"\"\n        Find and instantiate a component class based on `component_name`.\n\n        Args:\n            param component_id: Id of the component. Required.\n            param component_name: Name of the component. Used to locate the correct `UnicornView`\n                component class and template if necessary. Required.\n            param component_key: Key of the component to allow multiple components of the same name\n                to be differentiated. Optional.\n            param parent: The parent component of the current component.\n            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.\n        \n        Returns:\n            Instantiated `UnicornView` component.\n            Raises `ComponentLoadError` if the component could not be loaded.\n        \"\"\"\n        assert component_id, \"Component id is required\"\n        assert component_name, \"Component name is required\"\n\n        @timed\n        def _get_component_class(\n            module_name: str, class_name: str\n        ) -> Type[UnicornView]:\n            \"\"\"\n            Imports a component based on module and class name.\n            \"\"\"\n            module = importlib.import_module(module_name)\n            component_class = getattr(module, class_name)\n\n            return component_class\n\n        cache = caches[get_cache_alias()]\n        component_cache_key = f\"unicorn:component:{component_id}\"\n        cached_component = cache.get(component_cache_key)\n\n        if cached_component:\n            # Get the newest version of the parent from cache if it is available\n            # This needs to happen for Django cache because instances is pickled, so\n            # a change in the view won't be reflected automatically (like with the module\n            # cache) so it needs to be retrieved manually.\n            if cached_component.parent:\n                cached_parent_component = cache.get(\n                    cached_component.parent.component_cache_key\n                )\n\n                if cached_parent_component:\n                    cached_component.parent = cached_parent_component\n                    cached_component.parent.setup(request)\n        else:\n            cached_component = constructed_views_cache.get(component_id)\n\n        if use_cache and cached_component:\n            # Note that `hydrate()` and `complete` don't need to be called here\n            # because this path only happens for re-rendering from the view\n            cached_component.setup(request)\n            cached_component._validate_called = False\n            cached_component.calls = []\n            logger.debug(f\"Retrieve {component_id} from constructed views cache\")\n\n            return cached_component\n\n        if component_id in views_cache:\n            (component_class, parent, kwargs) = views_cache[component_id]\n\n            component = construct_component(\n                component_class=component_class,\n                component_id=component_id,\n                component_name=component_name,\n                component_key=component_key,\n                parent=parent,\n                request=request,\n                **kwargs,\n            )\n            logger.debug(f\"Retrieve {component_id} from views cache\")\n\n            return component\n\n        locations = []\n\n        if component_name in location_cache:\n            locations.append(location_cache[component_name])\n        else:\n            locations = get_locations(component_name)\n\n        # Store the last exception that got raised while looking for a component in case it is useful context\n        last_exception: Union[\n            Optional[ModuleNotFoundError], Optional[AttributeError]\n        ] = None\n\n        for (class_name, module_name) in locations:\n            try:\n                component_class = _get_component_class(module_name, class_name)\n                component = construct_component(\n                    component_class=component_class,\n                    component_id=component_id,\n                    component_name=component_name,\n                    component_key=component_key,\n                    parent=parent,\n                    request=request,\n                    **kwargs,\n                )\n\n                # Put the location for the component name in a module cache\n                location_cache[component_name] = (class_name, module_name)\n\n                # Put the component's class in a module cache\n                views_cache[component_id] = (component_class, parent, kwargs)\n\n                # Put the instantiated component into a module cache and the Django cache\n                cacheable_component = None\n\n                try:\n                    cacheable_component = get_cacheable_component(component)\n                except UnicornCacheError as e:\n                    logger.warning(e)\n\n                if cacheable_component:\n                    if COMPONENTS_MODULE_CACHE_ENABLED:\n                        constructed_views_cache[component_id] = cacheable_component\n\n                    cache.set(\n                        cacheable_component.component_cache_key, cacheable_component\n                    )\n\n                return component\n            except ModuleNotFoundError as e:\n                last_exception = e\n            except AttributeError as e:\n                last_exception = e\n\n        raise ComponentLoadError(\n            f\"'{component_name}' component could not be loaded: {last_exception}\"\n        ) from last_exception", "target": 0}]}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/django_unicorn%2Fviews%2F__init__.py", "code": "import copy\nimport logging\nfrom functools import wraps\nfrom typing import Dict, Sequence\n\nfrom django.core.cache import caches\nfrom django.http import HttpRequest, JsonResponse\nfrom django.http.response import HttpResponseNotModified\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.http import require_POST\n\nimport orjson\nfrom bs4 import BeautifulSoup\n\nfrom django_unicorn.components import UnicornView\nfrom django_unicorn.components.unicorn_template_response import get_root_element\nfrom django_unicorn.decorators import timed\nfrom django_unicorn.errors import RenderNotModified, UnicornCacheError, UnicornViewError\nfrom django_unicorn.serializer import dumps, loads\nfrom django_unicorn.settings import (\n    get_cache_alias,\n    get_serial_enabled,\n    get_serial_timeout,\n)\nfrom django_unicorn.utils import generate_checksum, get_cacheable_component\nfrom django_unicorn.views.action_parsers import call_method, sync_input\nfrom django_unicorn.views.objects import ComponentRequest\nfrom django_unicorn.views.utils import set_property_from_data\n\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef handle_error(view_func):\n    \"\"\"\n    Returns a JSON response with an error if necessary.\n    \"\"\"\n\n    def wrapped_view(*args, **kwargs):\n        try:\n            return view_func(*args, **kwargs)\n        except UnicornViewError as e:\n            return JsonResponse({\"error\": str(e)})\n        except RenderNotModified:\n            return HttpResponseNotModified()\n        except AssertionError as e:\n            return JsonResponse({\"error\": str(e)})\n\n    return wraps(view_func)(wrapped_view)\n\n\ndef _process_component_request(\n    request: HttpRequest, component_request: ComponentRequest\n) -> Dict:\n    \"\"\"\n    Process a `ComponentRequest`:\n        1. construct a Component view\n        2. set all of the properties on the view from the data\n        3. execute the type\n            - update the properties based on the payload for \"syncInput\"\n            - call the method specified for \"callMethod\"\n        4. validate any fields specified in a Django form\n        5. construct a `dict` that will get returned in a `JsonResponse` later on\n\n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_request: Component request to process.\n\n    Returns:\n        `dict` with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    component = UnicornView.create(\n        component_id=component_request.id,\n        component_name=component_request.name,\n        request=request,\n    )\n\n    # Get a deepcopy of the data passed in to determine what fields are updated later\n    original_data = copy.deepcopy(component_request.data)\n\n    # Set component properties based on request data\n    for (property_name, property_value) in component_request.data.items():\n        set_property_from_data(component, property_name, property_value)\n    component.hydrate()\n\n    validate_all_fields = False\n    is_reset_called = False\n    is_refresh_called = False\n    return_data = None\n    partials = []\n\n    for action in component_request.action_queue:\n        if action.partial:\n            partials.append(action.partial)\n        else:\n            partials = action.partials\n\n        if action.action_type == \"syncInput\":\n            sync_input.handle(component_request, component, action.payload)\n        elif action.action_type == \"callMethod\":\n            (\n                component,\n                _is_refresh_called,\n                _is_reset_called,\n                _validate_all_fields,\n                return_data,\n            ) = call_method.handle(component_request, component, action.payload)\n\n            is_refresh_called = is_refresh_called | _is_refresh_called\n            is_reset_called = is_reset_called | _is_reset_called\n            validate_all_fields = validate_all_fields | _validate_all_fields\n        else:\n            raise UnicornViewError(f\"Unknown action_type '{action.action_type}'\")\n\n    component.complete()\n\n    # Re-load frontend context variables to deal with non-serializable properties\n    component_request.data = orjson.loads(component.get_frontend_context_variables())\n\n    # Get set of attributes that should be marked as `safe`\n    safe_fields = []\n    if hasattr(component, \"Meta\") and hasattr(component.Meta, \"safe\"):\n        if isinstance(component.Meta.safe, Sequence):\n            for field_name in component.Meta.safe:\n                if field_name in component._attributes().keys():\n                    safe_fields.append(field_name)\n\n    # Mark safe attributes as such before rendering\n    for field_name in safe_fields:\n        value = getattr(component, field_name)\n        if isinstance(value, str):\n            setattr(component, field_name, mark_safe(value))\n\n    # Send back all available data for reset or refresh actions\n    updated_data = component_request.data\n\n    if not is_reset_called:\n        if not is_refresh_called:\n            updated_data = {}\n\n            for key, value in original_data.items():\n                if value != component_request.data.get(key):\n                    updated_data[key] = component_request.data.get(key)\n\n        if validate_all_fields:\n            component.validate()\n        else:\n            component.validate(model_names=list(updated_data.keys()))\n\n    rendered_component = component.render()\n    component.rendered(rendered_component)\n\n    cache = caches[get_cache_alias()]\n\n    try:\n        cache.set(component.component_cache_key, get_cacheable_component(component))\n    except UnicornCacheError as e:\n        logger.warning(e)\n\n    partial_doms = []\n\n    if partials and all(partials):\n        soup = BeautifulSoup(rendered_component, features=\"html.parser\")\n\n        for partial in partials:\n            partial_found = False\n            only_id = False\n            only_key = False\n\n            target = partial.get(\"target\")\n\n            if not target:\n                target = partial.get(\"key\")\n\n                if target:\n                    only_key = True\n\n            if not target:\n                target = partial.get(\"id\")\n\n                if target:\n                    only_id = True\n\n            assert target, \"Partial target is required\"\n\n            if not only_id:\n                for element in soup.find_all():\n                    if (\n                        \"unicorn:key\" in element.attrs\n                        and element.attrs[\"unicorn:key\"] == target\n                    ):\n                        partial_doms.append({\"key\": target, \"dom\": str(element)})\n                        partial_found = True\n                        break\n\n            if not partial_found and not only_key:\n                for element in soup.find_all():\n                    if \"id\" in element.attrs and element.attrs[\"id\"] == target:\n                        partial_doms.append({\"id\": target, \"dom\": str(element)})\n                        partial_found = True\n                        break\n\n    res = {\n        \"id\": component_request.id,\n        \"data\": updated_data,\n        \"errors\": component.errors,\n        \"calls\": component.calls,\n        \"checksum\": generate_checksum(orjson.dumps(component_request.data)),\n    }\n\n    if partial_doms:\n        res.update({\"partials\": partial_doms})\n    else:\n        hash = generate_checksum(rendered_component)\n\n        if (\n            component_request.hash == hash\n            and (not return_data or not return_data.value)\n            and not component.calls\n        ):\n            raise RenderNotModified()\n\n        # Make sure that partials with comments or blank lines before the root element only return the root element\n        soup = BeautifulSoup(rendered_component, features=\"html.parser\")\n        rendered_component = str(get_root_element(soup))\n\n        res.update(\n            {\"dom\": rendered_component, \"hash\": hash,}\n        )\n\n    if return_data:\n        res.update(\n            {\"return\": return_data.get_data(),}\n        )\n\n        if return_data.redirect:\n            res.update(\n                {\"redirect\": return_data.redirect,}\n            )\n\n        if return_data.poll:\n            res.update(\n                {\"poll\": return_data.poll,}\n            )\n\n    parent_component = component.parent\n\n    if parent_component:\n        # TODO: Should parent_component.hydrate() be called?\n        parent_frontend_context_variables = loads(\n            parent_component.get_frontend_context_variables()\n        )\n        parent_checksum = generate_checksum(dumps(parent_frontend_context_variables))\n\n        parent = {\n            \"id\": parent_component.component_id,\n            \"checksum\": parent_checksum,\n        }\n\n        if not partial_doms:\n            parent_dom = parent_component.render()\n            component.parent_rendered(parent_dom)\n\n            try:\n                cache.set(\n                    parent_component.component_cache_key,\n                    get_cacheable_component(parent_component),\n                )\n            except UnicornCacheError as e:\n                logger.warning(e)\n\n            parent.update(\n                {\n                    \"dom\": parent_dom,\n                    \"data\": parent_frontend_context_variables,\n                    \"errors\": parent_component.errors,\n                }\n            )\n\n        res.update({\"parent\": parent})\n\n    return res\n\n\ndef _handle_component_request(\n    request: HttpRequest, component_request: ComponentRequest\n) -> Dict:\n    \"\"\"\n    Process a `ComponentRequest` by adding it to the cache and then either:\n        - processing all of the component requests in the cache and returning the resulting value if\n            it is the first component request for that particular component name + component id combination\n        - return a `dict` saying that the request has been queued\n    \n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_request: Component request to process.\n    \n    Returns:\n        `dict` with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    # If serial isn't enabled or the wrong cache, just process the request like normal\n    if not get_serial_enabled():\n        return _process_component_request(request, component_request)\n\n    cache = caches[get_cache_alias()]\n\n    # Add the current request `ComponentRequest` to the cache\n    queue_cache_key = f\"unicorn:queue:{component_request.id}\"\n    component_requests = cache.get(queue_cache_key) or []\n\n    # Remove `request` from `ComponentRequest` before caching because it is not pickleable\n    component_request.request = None\n    component_requests.append(component_request)\n\n    cache.set(\n        queue_cache_key, component_requests, timeout=get_serial_timeout(),\n    )\n\n    if len(component_requests) > 1:\n        original_epoch = component_requests[0].epoch\n        return {\n            \"queued\": True,\n            \"epoch\": component_request.epoch,\n            \"original_epoch\": original_epoch,\n        }\n\n    return _handle_queued_component_requests(\n        request, component_request.name, queue_cache_key\n    )\n\n\ndef _handle_queued_component_requests(\n    request: HttpRequest, component_name: str, queue_cache_key\n) -> Dict:\n    \"\"\"\n    Process the current component requests that are stored in cache.\n    Also recursively checks for new requests that might have happened\n    while executing the first request, merges them together and returns\n    the correct appropriate data.\n\n    Args:\n        param request: HttpRequest for the view.\n        param: component_name: Name of the component, e.g. \"hello-world\".\n        param: queue_cache_key: Cache key created from component id which should be unique\n            for any particular user's request lifecycle.\n    \n    Returns:\n        JSON with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    cache = caches[get_cache_alias()]\n\n    # Handle current request and any others in the cache by first sorting all of the current requests by ascending order\n    component_requests = cache.get(queue_cache_key)\n\n    if not component_requests or not isinstance(component_requests, list):\n        raise UnicornViewError(f\"No request found for {queue_cache_key}\")\n\n    component_requests = sorted(component_requests, key=lambda r: r.epoch)\n    first_component_request = component_requests[0]\n\n    try:\n        # Can't store request on a `ComponentRequest` and cache it because `HttpRequest` isn't pickleable\n        first_json_result = _process_component_request(request, first_component_request)\n    except RenderNotModified:\n        # Catching this and re-raising, but need the finally clause to clear the cache\n        raise\n    finally:\n        # Re-check for requests after the first request is processed\n        component_requests = cache.get(queue_cache_key)\n\n        # Check that the request is in the cache before popping it off\n        if component_requests:\n            component_requests.pop(0)\n            cache.set(\n                queue_cache_key, component_requests, timeout=get_serial_timeout(),\n            )\n\n    if component_requests:\n        # Create one new `component_request` from all of the queued requests that can be processed\n        merged_component_request = None\n\n        for additional_component_request in copy.deepcopy(component_requests):\n            if merged_component_request:\n                # Add new component request action queue to the merged component request\n                merged_component_request.action_queue.extend(\n                    additional_component_request.action_queue\n                )\n\n                # Originally, the thought was to merge the `additional_component_request.data` into\n                # the `merged_component_request.data`, but I can't figure out a way to do that in a sane\n                # manner. This means that for rapidly fired events that mutate `data`, that new\n                # `data` with be \"thrown away\".\n                # Relevant test: test_call_method_multiple.py::test_message_call_method_multiple_with_updated_data\n            else:\n                merged_component_request = additional_component_request\n\n                # Set new component request data from the first component request's resulting data\n                for key, val in first_json_result.get(\"data\", {}).items():\n                    merged_component_request.data[key] = val\n\n            component_requests.pop(0)\n            cache.set(\n                queue_cache_key, component_requests, timeout=get_serial_timeout(),\n            )\n\n        merged_json_result = _handle_component_request(\n            request, merged_component_request\n        )\n\n        return merged_json_result\n\n    return first_json_result\n\n\n@timed\n@handle_error\n@csrf_protect\n@require_POST\ndef message(request: HttpRequest, component_name: str = None) -> JsonResponse:\n    \"\"\"\n    Endpoint that instantiates the component and does the correct action\n    (set an attribute or call a method) depending on the JSON payload in the body.\n\n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_name: Name of the component, e.g. \"hello-world\".\n    \n    Returns:\n        `JsonRequest` with the following structure in the body:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n\n    assert component_name, \"Missing component name in url\"\n\n    component_request = ComponentRequest(request, component_name)\n    json_result = _handle_component_request(request, component_request)\n\n    return JsonResponse(json_result)\n", "code_before": "import copy\nimport logging\nfrom functools import wraps\nfrom typing import Dict\n\nfrom django.core.cache import caches\nfrom django.http import HttpRequest, JsonResponse\nfrom django.http.response import HttpResponseNotModified\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.http import require_POST\n\nimport orjson\nfrom bs4 import BeautifulSoup\n\nfrom django_unicorn.components import UnicornView\nfrom django_unicorn.components.unicorn_template_response import get_root_element\nfrom django_unicorn.decorators import timed\nfrom django_unicorn.errors import RenderNotModified, UnicornCacheError, UnicornViewError\nfrom django_unicorn.serializer import dumps, loads\nfrom django_unicorn.settings import (\n    get_cache_alias,\n    get_serial_enabled,\n    get_serial_timeout,\n)\nfrom django_unicorn.utils import generate_checksum, get_cacheable_component\nfrom django_unicorn.views.action_parsers import call_method, sync_input\nfrom django_unicorn.views.objects import ComponentRequest\nfrom django_unicorn.views.utils import set_property_from_data\n\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef handle_error(view_func):\n    \"\"\"\n    Returns a JSON response with an error if necessary.\n    \"\"\"\n\n    def wrapped_view(*args, **kwargs):\n        try:\n            return view_func(*args, **kwargs)\n        except UnicornViewError as e:\n            return JsonResponse({\"error\": str(e)})\n        except RenderNotModified:\n            return HttpResponseNotModified()\n        except AssertionError as e:\n            return JsonResponse({\"error\": str(e)})\n\n    return wraps(view_func)(wrapped_view)\n\n\ndef _process_component_request(\n    request: HttpRequest, component_request: ComponentRequest\n) -> Dict:\n    \"\"\"\n    Process a `ComponentRequest`:\n        1. construct a Component view\n        2. set all of the properties on the view from the data\n        3. execute the type\n            - update the properties based on the payload for \"syncInput\"\n            - call the method specified for \"callMethod\"\n        4. validate any fields specified in a Django form\n        5. construct a `dict` that will get returned in a `JsonResponse` later on\n\n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_request: Component request to process.\n\n    Returns:\n        `dict` with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    component = UnicornView.create(\n        component_id=component_request.id,\n        component_name=component_request.name,\n        request=request,\n    )\n\n    # Get a deepcopy of the data passed in to determine what fields are updated later\n    original_data = copy.deepcopy(component_request.data)\n\n    # Set component properties based on request data\n    for (property_name, property_value) in component_request.data.items():\n        set_property_from_data(component, property_name, property_value)\n    component.hydrate()\n\n    validate_all_fields = False\n    is_reset_called = False\n    is_refresh_called = False\n    return_data = None\n    partials = []\n\n    for action in component_request.action_queue:\n        if action.partial:\n            partials.append(action.partial)\n        else:\n            partials = action.partials\n\n        if action.action_type == \"syncInput\":\n            sync_input.handle(component_request, component, action.payload)\n        elif action.action_type == \"callMethod\":\n            (\n                component,\n                _is_refresh_called,\n                _is_reset_called,\n                _validate_all_fields,\n                return_data,\n            ) = call_method.handle(component_request, component, action.payload)\n\n            is_refresh_called = is_refresh_called | _is_refresh_called\n            is_reset_called = is_reset_called | _is_reset_called\n            validate_all_fields = validate_all_fields | _validate_all_fields\n        else:\n            raise UnicornViewError(f\"Unknown action_type '{action.action_type}'\")\n\n    component.complete()\n\n    # Re-load frontend context variables to deal with non-serializable properties\n    component_request.data = orjson.loads(component.get_frontend_context_variables())\n\n    # Send back all available data for reset or refresh actions\n    updated_data = component_request.data\n\n    if not is_reset_called:\n        if not is_refresh_called:\n            updated_data = {}\n\n            for key, value in original_data.items():\n                if value != component_request.data.get(key):\n                    updated_data[key] = component_request.data.get(key)\n\n        if validate_all_fields:\n            component.validate()\n        else:\n            component.validate(model_names=list(updated_data.keys()))\n\n    rendered_component = component.render()\n    component.rendered(rendered_component)\n\n    cache = caches[get_cache_alias()]\n\n    try:\n        cache.set(component.component_cache_key, get_cacheable_component(component))\n    except UnicornCacheError as e:\n        logger.warning(e)\n\n    partial_doms = []\n\n    if partials and all(partials):\n        soup = BeautifulSoup(rendered_component, features=\"html.parser\")\n\n        for partial in partials:\n            partial_found = False\n            only_id = False\n            only_key = False\n\n            target = partial.get(\"target\")\n\n            if not target:\n                target = partial.get(\"key\")\n\n                if target:\n                    only_key = True\n\n            if not target:\n                target = partial.get(\"id\")\n\n                if target:\n                    only_id = True\n\n            assert target, \"Partial target is required\"\n\n            if not only_id:\n                for element in soup.find_all():\n                    if (\n                        \"unicorn:key\" in element.attrs\n                        and element.attrs[\"unicorn:key\"] == target\n                    ):\n                        partial_doms.append({\"key\": target, \"dom\": str(element)})\n                        partial_found = True\n                        break\n\n            if not partial_found and not only_key:\n                for element in soup.find_all():\n                    if \"id\" in element.attrs and element.attrs[\"id\"] == target:\n                        partial_doms.append({\"id\": target, \"dom\": str(element)})\n                        partial_found = True\n                        break\n\n    res = {\n        \"id\": component_request.id,\n        \"data\": updated_data,\n        \"errors\": component.errors,\n        \"calls\": component.calls,\n        \"checksum\": generate_checksum(orjson.dumps(component_request.data)),\n    }\n\n    if partial_doms:\n        res.update({\"partials\": partial_doms})\n    else:\n        hash = generate_checksum(rendered_component)\n\n        if (\n            component_request.hash == hash\n            and (not return_data or not return_data.value)\n            and not component.calls\n        ):\n            raise RenderNotModified()\n\n        # Make sure that partials with comments or blank lines before the root element only return the root element\n        soup = BeautifulSoup(rendered_component, features=\"html.parser\")\n        rendered_component = str(get_root_element(soup))\n\n        res.update(\n            {\"dom\": rendered_component, \"hash\": hash,}\n        )\n\n    if return_data:\n        res.update(\n            {\"return\": return_data.get_data(),}\n        )\n\n        if return_data.redirect:\n            res.update(\n                {\"redirect\": return_data.redirect,}\n            )\n\n        if return_data.poll:\n            res.update(\n                {\"poll\": return_data.poll,}\n            )\n\n    parent_component = component.parent\n\n    if parent_component:\n        # TODO: Should parent_component.hydrate() be called?\n        parent_frontend_context_variables = loads(\n            parent_component.get_frontend_context_variables()\n        )\n        parent_checksum = generate_checksum(dumps(parent_frontend_context_variables))\n\n        parent = {\n            \"id\": parent_component.component_id,\n            \"checksum\": parent_checksum,\n        }\n\n        if not partial_doms:\n            parent_dom = parent_component.render()\n            component.parent_rendered(parent_dom)\n\n            try:\n                cache.set(\n                    parent_component.component_cache_key,\n                    get_cacheable_component(parent_component),\n                )\n            except UnicornCacheError as e:\n                logger.warning(e)\n\n            parent.update(\n                {\n                    \"dom\": parent_dom,\n                    \"data\": parent_frontend_context_variables,\n                    \"errors\": parent_component.errors,\n                }\n            )\n\n        res.update({\"parent\": parent})\n\n    return res\n\n\ndef _handle_component_request(\n    request: HttpRequest, component_request: ComponentRequest\n) -> Dict:\n    \"\"\"\n    Process a `ComponentRequest` by adding it to the cache and then either:\n        - processing all of the component requests in the cache and returning the resulting value if\n            it is the first component request for that particular component name + component id combination\n        - return a `dict` saying that the request has been queued\n    \n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_request: Component request to process.\n    \n    Returns:\n        `dict` with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    # If serial isn't enabled or the wrong cache, just process the request like normal\n    if not get_serial_enabled():\n        return _process_component_request(request, component_request)\n\n    cache = caches[get_cache_alias()]\n\n    # Add the current request `ComponentRequest` to the cache\n    queue_cache_key = f\"unicorn:queue:{component_request.id}\"\n    component_requests = cache.get(queue_cache_key) or []\n\n    # Remove `request` from `ComponentRequest` before caching because it is not pickleable\n    component_request.request = None\n    component_requests.append(component_request)\n\n    cache.set(\n        queue_cache_key, component_requests, timeout=get_serial_timeout(),\n    )\n\n    if len(component_requests) > 1:\n        original_epoch = component_requests[0].epoch\n        return {\n            \"queued\": True,\n            \"epoch\": component_request.epoch,\n            \"original_epoch\": original_epoch,\n        }\n\n    return _handle_queued_component_requests(\n        request, component_request.name, queue_cache_key\n    )\n\n\ndef _handle_queued_component_requests(\n    request: HttpRequest, component_name: str, queue_cache_key\n) -> Dict:\n    \"\"\"\n    Process the current component requests that are stored in cache.\n    Also recursively checks for new requests that might have happened\n    while executing the first request, merges them together and returns\n    the correct appropriate data.\n\n    Args:\n        param request: HttpRequest for the view.\n        param: component_name: Name of the component, e.g. \"hello-world\".\n        param: queue_cache_key: Cache key created from component id which should be unique\n            for any particular user's request lifecycle.\n    \n    Returns:\n        JSON with the following structure:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n    cache = caches[get_cache_alias()]\n\n    # Handle current request and any others in the cache by first sorting all of the current requests by ascending order\n    component_requests = cache.get(queue_cache_key)\n\n    if not component_requests or not isinstance(component_requests, list):\n        raise UnicornViewError(f\"No request found for {queue_cache_key}\")\n\n    component_requests = sorted(component_requests, key=lambda r: r.epoch)\n    first_component_request = component_requests[0]\n\n    try:\n        # Can't store request on a `ComponentRequest` and cache it because `HttpRequest` isn't pickleable\n        first_json_result = _process_component_request(request, first_component_request)\n    except RenderNotModified:\n        # Catching this and re-raising, but need the finally clause to clear the cache\n        raise\n    finally:\n        # Re-check for requests after the first request is processed\n        component_requests = cache.get(queue_cache_key)\n\n        # Check that the request is in the cache before popping it off\n        if component_requests:\n            component_requests.pop(0)\n            cache.set(\n                queue_cache_key, component_requests, timeout=get_serial_timeout(),\n            )\n\n    if component_requests:\n        # Create one new `component_request` from all of the queued requests that can be processed\n        merged_component_request = None\n\n        for additional_component_request in copy.deepcopy(component_requests):\n            if merged_component_request:\n                # Add new component request action queue to the merged component request\n                merged_component_request.action_queue.extend(\n                    additional_component_request.action_queue\n                )\n\n                # Originally, the thought was to merge the `additional_component_request.data` into\n                # the `merged_component_request.data`, but I can't figure out a way to do that in a sane\n                # manner. This means that for rapidly fired events that mutate `data`, that new\n                # `data` with be \"thrown away\".\n                # Relevant test: test_call_method_multiple.py::test_message_call_method_multiple_with_updated_data\n            else:\n                merged_component_request = additional_component_request\n\n                # Set new component request data from the first component request's resulting data\n                for key, val in first_json_result.get(\"data\", {}).items():\n                    merged_component_request.data[key] = val\n\n            component_requests.pop(0)\n            cache.set(\n                queue_cache_key, component_requests, timeout=get_serial_timeout(),\n            )\n\n        merged_json_result = _handle_component_request(\n            request, merged_component_request\n        )\n\n        return merged_json_result\n\n    return first_json_result\n\n\n@timed\n@handle_error\n@csrf_protect\n@require_POST\ndef message(request: HttpRequest, component_name: str = None) -> JsonResponse:\n    \"\"\"\n    Endpoint that instantiates the component and does the correct action\n    (set an attribute or call a method) depending on the JSON payload in the body.\n\n    Args:\n        param request: HttpRequest for the function-based view.\n        param: component_name: Name of the component, e.g. \"hello-world\".\n    \n    Returns:\n        `JsonRequest` with the following structure in the body:\n        {\n            \"id\": component_id,\n            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed\n            \"data\": {},  // updated data after actions in the payload are completed\n            \"errors\": {},  // form validation errors\n            \"return\": {}, // optional return value from an executed action\n            \"parent\": {},  // optional representation of the parent component\n        }\n    \"\"\"\n\n    assert component_name, \"Missing component name in url\"\n\n    component_request = ComponentRequest(request, component_name)\n    json_result = _handle_component_request(request, component_request)\n\n    return JsonResponse(json_result)\n", "patch": "@@ -1,11 +1,12 @@\n import copy\n import logging\n from functools import wraps\n-from typing import Dict\n+from typing import Dict, Sequence\n \n from django.core.cache import caches\n from django.http import HttpRequest, JsonResponse\n from django.http.response import HttpResponseNotModified\n+from django.utils.safestring import mark_safe\n from django.views.decorators.csrf import csrf_protect\n from django.views.decorators.http import require_POST\n \n@@ -126,6 +127,20 @@ def _process_component_request(\n     # Re-load frontend context variables to deal with non-serializable properties\n     component_request.data = orjson.loads(component.get_frontend_context_variables())\n \n+    # Get set of attributes that should be marked as `safe`\n+    safe_fields = []\n+    if hasattr(component, \"Meta\") and hasattr(component.Meta, \"safe\"):\n+        if isinstance(component.Meta.safe, Sequence):\n+            for field_name in component.Meta.safe:\n+                if field_name in component._attributes().keys():\n+                    safe_fields.append(field_name)\n+\n+    # Mark safe attributes as such before rendering\n+    for field_name in safe_fields:\n+        value = getattr(component, field_name)\n+        if isinstance(value, str):\n+            setattr(component, field_name, mark_safe(value))\n+\n     # Send back all available data for reset or refresh actions\n     updated_data = component_request.data\n ", "file_path": "files/2021_10/789", "file_language": "py", "file_name": "django_unicorn/views/__init__.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Fcomponents%2Ftest_component.py", "code": "import types\n\nimport orjson\nimport pytest\n\nfrom django_unicorn.components import UnicornView\n\n\nclass ExampleComponent(UnicornView):\n    name = \"World\"\n\n    def get_name(self):\n        return \"World\"\n\n\n@pytest.fixture()\ndef component():\n    return ExampleComponent(component_id=\"asdf1234\", component_name=\"example\")\n\n\ndef test_init_with_template_name():\n    class TestComponent(UnicornView):\n        template_name = \"unicorn/test.html\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name == \"unicorn/test.html\"\n\n\ndef test_init_with_get_template_names():\n    class TestComponent(UnicornView):\n        def get_template_names(self):\n            return []\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name is None\n\n\ndef test_init_attribute_names_cache(component):\n    attribute_names_cache = component._attribute_names_cache\n    assert len(attribute_names_cache) == 1\n    assert attribute_names_cache[0] == \"name\"\n\n\ndef test_init_attribute_names(component):\n    attribute_names = component._attribute_names()\n    assert len(attribute_names) == 1\n    assert attribute_names[0] == \"name\"\n\n\ndef test_init_attributes(component):\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"\n\n\ndef test_init_properties():\n    class TestComponent(UnicornView):\n        @property\n        def name(self):\n            return \"World\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"\n\n\ndef test_init_methods_cache(component):\n    assert len(component._methods_cache) == 1\n\n\ndef test_init_methods(component):\n    methods = component._methods()\n    assert len(methods) == 1\n    assert methods[\"get_name\"]() == \"World\"\n\n\ndef test_get_frontend_context_variables(component):\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert frontend_context_variables_dict.get(\"name\") == \"World\"\n\n\ndef test_get_context_data(component):\n    context_data = component.get_context_data()\n    assert (\n        len(context_data) == 4\n    )  # `unicorn` and `view` are added to context data by default\n    assert context_data.get(\"name\") == \"World\"\n    assert isinstance(context_data.get(\"get_name\"), types.MethodType)\n\n\ndef test_is_public(component):\n    assert component._is_public(\"test_name\")\n\n\ndef test_is_public_protected(component):\n    assert component._is_public(\"_test_name\") == False\n\n\ndef test_is_public_http_method_names(component):\n    assert component._is_public(\"http_method_names\") == False\n\n\ndef test_meta_javascript_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            javascript_exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" in component.get_context_data()\n\n\ndef test_meta_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" not in component.get_context_data()\n", "code_before": "import types\n\nimport orjson\nimport pytest\n\nfrom django_unicorn.components import UnicornView\n\n\nclass ExampleComponent(UnicornView):\n    name = \"World\"\n\n    def get_name(self):\n        return \"World\"\n\n\n@pytest.fixture()\ndef component():\n    return ExampleComponent(component_id=\"asdf1234\", component_name=\"example\")\n\n\ndef test_init_with_template_name():\n    class TestComponent(UnicornView):\n        template_name = \"unicorn/test.html\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name == \"unicorn/test.html\"\n\n\ndef test_init_with_get_template_names():\n    class TestComponent(UnicornView):\n        def get_template_names(self):\n            return []\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name is None\n\n\ndef test_init_attribute_names_cache(component):\n    attribute_names_cache = component._attribute_names_cache\n    assert len(attribute_names_cache) == 1\n    assert attribute_names_cache[0] == \"name\"\n\n\ndef test_init_attribute_names(component):\n    attribute_names = component._attribute_names()\n    assert len(attribute_names) == 1\n    assert attribute_names[0] == \"name\"\n\n\ndef test_init_attributes(component):\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"\n\n\ndef test_init_properties():\n    class TestComponent(UnicornView):\n        @property\n        def name(self):\n            return \"World\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"\n\n\ndef test_init_methods_cache(component):\n    assert len(component._methods_cache) == 1\n\n\ndef test_init_methods(component):\n    methods = component._methods()\n    assert len(methods) == 1\n    assert methods[\"get_name\"]() == \"World\"\n\n\ndef test_get_frontend_context_variables(component):\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert frontend_context_variables_dict.get(\"name\") == \"World\"\n\n\ndef test_get_frontend_context_variables_xss(component):\n    # Set component.name to a potential XSS attack\n    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert (\n        frontend_context_variables_dict.get(\"name\")\n        == \"&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;\"\n    )\n\n\ndef test_get_frontend_context_variables_safe(component):\n    # Set component.name to a potential XSS attack\n    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n\n    class Meta:\n        safe = [\n            \"name\",\n        ]\n\n    setattr(component, \"Meta\", Meta())\n\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert (\n        frontend_context_variables_dict.get(\"name\")\n        == '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n    )\n\n\ndef test_get_context_data(component):\n    context_data = component.get_context_data()\n    assert (\n        len(context_data) == 4\n    )  # `unicorn` and `view` are added to context data by default\n    assert context_data.get(\"name\") == \"World\"\n    assert isinstance(context_data.get(\"get_name\"), types.MethodType)\n\n\ndef test_is_public(component):\n    assert component._is_public(\"test_name\")\n\n\ndef test_is_public_protected(component):\n    assert component._is_public(\"_test_name\") == False\n\n\ndef test_is_public_http_method_names(component):\n    assert component._is_public(\"http_method_names\") == False\n\n\ndef test_meta_javascript_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            javascript_exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" in component.get_context_data()\n\n\ndef test_meta_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" not in component.get_context_data()\n", "patch": "@@ -82,39 +82,6 @@ def test_get_frontend_context_variables(component):\n     assert frontend_context_variables_dict.get(\"name\") == \"World\"\n \n \n-def test_get_frontend_context_variables_xss(component):\n-    # Set component.name to a potential XSS attack\n-    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n-\n-    frontend_context_variables = component.get_frontend_context_variables()\n-    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n-    assert len(frontend_context_variables_dict) == 1\n-    assert (\n-        frontend_context_variables_dict.get(\"name\")\n-        == \"&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;\"\n-    )\n-\n-\n-def test_get_frontend_context_variables_safe(component):\n-    # Set component.name to a potential XSS attack\n-    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n-\n-    class Meta:\n-        safe = [\n-            \"name\",\n-        ]\n-\n-    setattr(component, \"Meta\", Meta())\n-\n-    frontend_context_variables = component.get_frontend_context_variables()\n-    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n-    assert len(frontend_context_variables_dict) == 1\n-    assert (\n-        frontend_context_variables_dict.get(\"name\")\n-        == '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n-    )\n-\n-\n def test_get_context_data(component):\n     context_data = component.get_context_data()\n     assert (", "file_path": "files/2021_10/790", "file_language": "py", "file_name": "tests/components/test_component.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class ExampleComponent(UnicornView):\n    name = \"World\"\n\n    def get_name(self):\n        return \"World\"", "target": 0}, {"function": "def test_init_with_template_name():\n    class TestComponent(UnicornView):\n        template_name = \"unicorn/test.html\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name == \"unicorn/test.html\"", "target": 0}, {"function": "def test_init_with_get_template_names():\n    class TestComponent(UnicornView):\n        def get_template_names(self):\n            return []\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name is None", "target": 0}, {"function": "def test_init_attribute_names_cache(component):\n    attribute_names_cache = component._attribute_names_cache\n    assert len(attribute_names_cache) == 1\n    assert attribute_names_cache[0] == \"name\"", "target": 0}, {"function": "def test_init_attribute_names(component):\n    attribute_names = component._attribute_names()\n    assert len(attribute_names) == 1\n    assert attribute_names[0] == \"name\"", "target": 0}, {"function": "def test_init_attributes(component):\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"", "target": 0}, {"function": "def test_init_properties():\n    class TestComponent(UnicornView):\n        @property\n        def name(self):\n            return \"World\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"", "target": 0}, {"function": "def test_init_methods_cache(component):\n    assert len(component._methods_cache) == 1", "target": 0}, {"function": "def test_init_methods(component):\n    methods = component._methods()\n    assert len(methods) == 1\n    assert methods[\"get_name\"]() == \"World\"", "target": 0}, {"function": "def test_get_frontend_context_variables(component):\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert frontend_context_variables_dict.get(\"name\") == \"World\"", "target": 0}, {"function": "def test_get_frontend_context_variables_xss(component):\n    # Set component.name to a potential XSS attack\n    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert (\n        frontend_context_variables_dict.get(\"name\")\n        == \"&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;\"\n    )", "target": 0}, {"function": "def test_get_frontend_context_variables_safe(component):\n    # Set component.name to a potential XSS attack\n    component.name = '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n\n    class Meta:\n        safe = [\n            \"name\",\n        ]\n\n    setattr(component, \"Meta\", Meta())\n\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert (\n        frontend_context_variables_dict.get(\"name\")\n        == '<a><style>@keyframes x{}</style><a style=\"animation-name:x\" onanimationend=\"alert(1)\"></a>'\n    )", "target": 0}, {"function": "def test_get_context_data(component):\n    context_data = component.get_context_data()\n    assert (\n        len(context_data) == 4\n    )  # `unicorn` and `view` are added to context data by default\n    assert context_data.get(\"name\") == \"World\"\n    assert isinstance(context_data.get(\"get_name\"), types.MethodType)", "target": 0}, {"function": "def test_is_public(component):\n    assert component._is_public(\"test_name\")", "target": 0}, {"function": "def test_is_public_protected(component):\n    assert component._is_public(\"_test_name\") == False", "target": 0}, {"function": "def test_is_public_http_method_names(component):\n    assert component._is_public(\"http_method_names\") == False", "target": 0}, {"function": "def test_meta_javascript_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            javascript_exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" in component.get_context_data()", "target": 0}, {"function": "def test_meta_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" not in component.get_context_data()", "target": 0}], "function_after": [{"function": "class ExampleComponent(UnicornView):\n    name = \"World\"\n\n    def get_name(self):\n        return \"World\"", "target": 0}, {"function": "def test_init_with_template_name():\n    class TestComponent(UnicornView):\n        template_name = \"unicorn/test.html\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name == \"unicorn/test.html\"", "target": 0}, {"function": "def test_init_with_get_template_names():\n    class TestComponent(UnicornView):\n        def get_template_names(self):\n            return []\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert component.template_name is None", "target": 0}, {"function": "def test_init_attribute_names_cache(component):\n    attribute_names_cache = component._attribute_names_cache\n    assert len(attribute_names_cache) == 1\n    assert attribute_names_cache[0] == \"name\"", "target": 0}, {"function": "def test_init_attribute_names(component):\n    attribute_names = component._attribute_names()\n    assert len(attribute_names) == 1\n    assert attribute_names[0] == \"name\"", "target": 0}, {"function": "def test_init_attributes(component):\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"", "target": 0}, {"function": "def test_init_properties():\n    class TestComponent(UnicornView):\n        @property\n        def name(self):\n            return \"World\"\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    attributes = component._attributes()\n    assert len(attributes) == 1\n    assert attributes[\"name\"] == \"World\"", "target": 0}, {"function": "def test_init_methods_cache(component):\n    assert len(component._methods_cache) == 1", "target": 0}, {"function": "def test_init_methods(component):\n    methods = component._methods()\n    assert len(methods) == 1\n    assert methods[\"get_name\"]() == \"World\"", "target": 0}, {"function": "def test_get_frontend_context_variables(component):\n    frontend_context_variables = component.get_frontend_context_variables()\n    frontend_context_variables_dict = orjson.loads(frontend_context_variables)\n    assert len(frontend_context_variables_dict) == 1\n    assert frontend_context_variables_dict.get(\"name\") == \"World\"", "target": 0}, {"function": "def test_get_context_data(component):\n    context_data = component.get_context_data()\n    assert (\n        len(context_data) == 4\n    )  # `unicorn` and `view` are added to context data by default\n    assert context_data.get(\"name\") == \"World\"\n    assert isinstance(context_data.get(\"get_name\"), types.MethodType)", "target": 0}, {"function": "def test_is_public(component):\n    assert component._is_public(\"test_name\")", "target": 0}, {"function": "def test_is_public_protected(component):\n    assert component._is_public(\"_test_name\") == False", "target": 0}, {"function": "def test_is_public_http_method_names(component):\n    assert component._is_public(\"http_method_names\") == False", "target": 0}, {"function": "def test_meta_javascript_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            javascript_exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" in component.get_context_data()", "target": 0}, {"function": "def test_meta_exclude():\n    class TestComponent(UnicornView):\n        name = \"World\"\n\n        class Meta:\n            exclude = (\"name\",)\n\n    component = TestComponent(component_id=\"asdf1234\", component_name=\"hello-world\")\n    assert \"name\" not in component.get_frontend_context_variables()\n    assert \"name\" not in component.get_context_data()", "target": 0}]}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Fcomponents%2Ftest_unicorn_template_response.py", "code": "import pytest\nfrom bs4 import BeautifulSoup\n\nfrom django_unicorn.components.unicorn_template_response import (\n    UnicornTemplateResponse,\n    get_root_element,\n)\n\n\ndef test_get_root_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_with_comment():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<!-- some comment --><div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_with_blank_string():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_no_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n\n    with pytest.raises(Exception):\n        actual = get_root_element(soup)\n\n        assert str(actual) == expected\n\n\ndef test_desoupify():\n    html = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;!\\n</div>\\n\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n    expected = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=\\\"animation-name:x\\\" onanimationend=\\\"alert(1)\\\"&gt;&lt;/a&gt;!\\n</div>\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n\n    soup = BeautifulSoup(html, \"html.parser\")\n\n    actual = UnicornTemplateResponse._desoupify(soup)\n\n    assert expected == actual\n", "code_before": "import pytest\nfrom bs4 import BeautifulSoup\n\nfrom django_unicorn.components.unicorn_template_response import get_root_element\n\n\ndef test_get_root_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_with_comment():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<!-- some comment --><div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_with_blank_string():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected\n\n\ndef test_get_root_element_no_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n\n    with pytest.raises(Exception):\n        actual = get_root_element(soup)\n\n        assert str(actual) == expected\n", "patch": "@@ -1,7 +1,10 @@\n import pytest\n from bs4 import BeautifulSoup\n \n-from django_unicorn.components.unicorn_template_response import get_root_element\n+from django_unicorn.components.unicorn_template_response import (\n+    UnicornTemplateResponse,\n+    get_root_element,\n+)\n \n \n def test_get_root_element():\n@@ -44,3 +47,14 @@ def test_get_root_element_no_element():\n         actual = get_root_element(soup)\n \n         assert str(actual) == expected\n+\n+\n+def test_desoupify():\n+    html = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;!\\n</div>\\n\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n+    expected = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=\\\"animation-name:x\\\" onanimationend=\\\"alert(1)\\\"&gt;&lt;/a&gt;!\\n</div>\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n+\n+    soup = BeautifulSoup(html, \"html.parser\")\n+\n+    actual = UnicornTemplateResponse._desoupify(soup)\n+\n+    assert expected == actual", "file_path": "files/2021_10/791", "file_language": "py", "file_name": "tests/components/test_unicorn_template_response.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_get_root_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_with_comment():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<!-- some comment --><div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_with_blank_string():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_no_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n\n    with pytest.raises(Exception):\n        actual = get_root_element(soup)\n\n        assert str(actual) == expected", "target": 0}], "function_after": [{"function": "def test_get_root_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_with_comment():\n    expected = \"<div>test</div>\"\n\n    component_html = \"<!-- some comment --><div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_with_blank_string():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n<div>test</div>\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n    actual = get_root_element(soup)\n\n    assert str(actual) == expected", "target": 0}, {"function": "def test_get_root_element_no_element():\n    expected = \"<div>test</div>\"\n\n    component_html = \"\\n\"\n    soup = BeautifulSoup(component_html, features=\"html.parser\")\n\n    with pytest.raises(Exception):\n        actual = get_root_element(soup)\n\n        assert str(actual) == expected", "target": 0}, {"function": "def test_desoupify():\n    html = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=&quot;animation-name:x&quot; onanimationend=&quot;alert(1)&quot;&gt;&lt;/a&gt;!\\n</div>\\n\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n    expected = \"<div>&lt;a&gt;&lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;a style=\\\"animation-name:x\\\" onanimationend=\\\"alert(1)\\\"&gt;&lt;/a&gt;!\\n</div>\\n<script type=\\\"application/javascript\\\">\\n  window.addEventListener('DOMContentLoaded', (event) => {\\n    Unicorn.addEventListener('updated', (component) => console.log('got updated', component));\\n  });\\n</script>\"\n\n    soup = BeautifulSoup(html, \"html.parser\")\n\n    actual = UnicornTemplateResponse._desoupify(soup)\n\n    assert expected == actual", "target": 0}]}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Ftemplates%2Ftest_component_kwargs.html", "code": "<div>\n  <b>{{ hello }}</b>\n</div>", "code_before": "<div>\n    ->{{ hello }}<-\n</div>", "patch": "@@ -1,3 +1,3 @@\n <div>\n-    ->{{ hello }}<-\n+  <b>{{ hello }}</b>\n </div>\n\\ No newline at end of file", "file_path": "files/2021_10/792", "file_language": "html", "file_name": "tests/templates/test_component_kwargs.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Ftemplates%2Ftest_component_kwargs_with_html_entity.html", "code": "<div>\n  ->{{ hello }}<-\n</div>", "code_before": "", "patch": "@@ -0,0 +1,3 @@\n+<div>\n+  ->{{ hello }}<-\n+</div>\n\\ No newline at end of file", "file_path": "files/2021_10/793", "file_language": "html", "file_name": "tests/templates/test_component_kwargs_with_html_entity.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Ftemplates%2Ftest_component_variable.html", "code": "<div>\n  {{ hello }}\n</div>", "code_before": "", "patch": "@@ -0,0 +1,3 @@\n+<div>\n+  {{ hello }}\n+</div>\n\\ No newline at end of file", "file_path": "files/2021_10/794", "file_language": "html", "file_name": "tests/templates/test_component_variable.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Ftemplatetags%2Ftest_unicorn_render.py", "code": "import re\n\nfrom django.template.base import Token, TokenType\n\nimport pytest\n\nfrom django_unicorn.components import UnicornView\nfrom django_unicorn.templatetags.unicorn import unicorn\nfrom django_unicorn.utils import generate_checksum\nfrom example.coffee.models import Flavor\n\n\nclass FakeComponentParent(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n\nclass FakeComponentKwargs(UnicornView):\n    template_name = \"templates/test_component_kwargs.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")\n\n\nclass FakeComponentKwargsWithHtmlEntity(UnicornView):\n    template_name = \"templates/test_component_kwargs_with_html_entity.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")\n\n\nclass FakeComponentModel(UnicornView):\n    template_name = \"templates/test_component_model.html\"\n    model_id = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.model_id = kwargs.get(\"model_id\")\n\n\nclass FakeComponentCalls(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall\")\n\n\nclass FakeComponentCalls2(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall2\", \"hello\")\n\n\ndef test_unicorn_render_kwarg():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg='tested!'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    actual = unicorn_node.render(context)\n\n    assert \"<b>tested!</b>\" in actual\n\n\ndef test_unicorn_render_context_variable():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"<b>variable!</b>\" in actual\n\n\ndef test_unicorn_render_with_invalid_html():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargsWithHtmlEntity' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"-&gt;variable!&lt;-\" in actual\n\n\ndef test_unicorn_render_parent(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert unicorn_node.parent\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs\"\n    )\n\n\ndef test_unicorn_render_parent_with_key(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view key='blob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:blob\"\n    )\n\n\ndef test_unicorn_render_parent_with_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view id='flob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:flob\"\n    )\n\n\ndef test_unicorn_render_parent_with_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view pk=99\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:99\"\n    )\n\n\ndef test_unicorn_render_parent_with_model_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    # Fake a model that only has an id\n    class Model:\n        def __init__(self):\n            self.id = 178\n\n        def to_json(self):\n            return {\"id\": self.id}\n\n    context = {\"view\": view, \"model\": Model()}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:178\"\n    )\n\n\n@pytest.mark.django_db\ndef test_unicorn_render_parent_with_model_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    flavor = Flavor(pk=187)\n    context = {\"view\": view, \"model\": flavor}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:187\"\n    )\n\n\ndef test_unicorn_render_id_use_pk():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentModel' model_id=model.id\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"model\": {\"pk\": 123}}\n    actual = unicorn_node.render(context)\n\n    assert \"==123==\" in actual\n\n\ndef test_unicorn_render_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n\n\ndef test_unicorn_render_child_component_no_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    html = unicorn_node.render(context)\n\n    assert \"<script\" not in html\n\n\ndef test_unicorn_render_parent_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n\n\ndef test_unicorn_render_calls(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall\",\"args\":[]}]' in html\n\n\ndef test_unicorn_render_calls_with_arg(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls2'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall2\",\"args\":[\"hello\"]}]' in html\n\n\ndef test_unicorn_render_calls_no_mount_call(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[]' in html\n\n\ndef test_unicorn_render_hash(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"hash\":\"' in html\n\n    # Assert that the content hash is correct\n    script_idx = html.index(\"<script\")\n    rendered_content = html[:script_idx]\n    expected_hash = generate_checksum(rendered_content)\n    assert f'\"hash\":\"{expected_hash}\"' in html\n", "code_before": "import re\n\nfrom django.template.base import Token, TokenType\n\nimport pytest\n\nfrom django_unicorn.components import UnicornView\nfrom django_unicorn.templatetags.unicorn import unicorn\nfrom django_unicorn.utils import generate_checksum\nfrom example.coffee.models import Flavor\n\n\nclass FakeComponentParent(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n\nclass FakeComponentKwargs(UnicornView):\n    template_name = \"templates/test_component_kwargs.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")\n\n\nclass FakeComponentModel(UnicornView):\n    template_name = \"templates/test_component_model.html\"\n    model_id = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.model_id = kwargs.get(\"model_id\")\n\n\nclass FakeComponentCalls(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall\")\n\n\nclass FakeComponentCalls2(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall2\", \"hello\")\n\n\ndef test_unicorn_render_kwarg():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg='tested!'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    actual = unicorn_node.render(context)\n\n    assert \"->tested!<-\" in actual\n\n\ndef test_unicorn_render_context_variable():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"->variable!<-\" in actual\n\n\ndef test_unicorn_render_parent(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert unicorn_node.parent\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs\"\n    )\n\n\ndef test_unicorn_render_parent_with_key(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view key='blob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:blob\"\n    )\n\n\ndef test_unicorn_render_parent_with_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view id='flob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:flob\"\n    )\n\n\ndef test_unicorn_render_parent_with_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view pk=99\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:99\"\n    )\n\n\ndef test_unicorn_render_parent_with_model_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    # Fake a model that only has an id\n    class Model:\n        def __init__(self):\n            self.id = 178\n\n        def to_json(self):\n            return {\"id\": self.id}\n\n    context = {\"view\": view, \"model\": Model()}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:178\"\n    )\n\n\n@pytest.mark.django_db\ndef test_unicorn_render_parent_with_model_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    flavor = Flavor(pk=187)\n    context = {\"view\": view, \"model\": flavor}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:187\"\n    )\n\n\ndef test_unicorn_render_id_use_pk():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentModel' model_id=model.id\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"model\": {\"pk\": 123}}\n    actual = unicorn_node.render(context)\n\n    assert \"==123==\" in actual\n\n\ndef test_unicorn_render_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n\n\ndef test_unicorn_render_child_component_no_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    html = unicorn_node.render(context)\n\n    assert \"<script\" not in html\n\n\ndef test_unicorn_render_parent_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n\n\ndef test_unicorn_render_calls(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall\",\"args\":[]}]' in html\n\n\ndef test_unicorn_render_calls_with_arg(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls2'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall2\",\"args\":[\"hello\"]}]' in html\n\n\ndef test_unicorn_render_calls_no_mount_call(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[]' in html\n\n\ndef test_unicorn_render_hash(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"hash\":\"' in html\n\n    # Assert that the content hash is correct\n    script_idx = html.index(\"<script\")\n    rendered_content = html[:script_idx]\n    expected_hash = generate_checksum(rendered_content)\n    assert f'\"hash\":\"{expected_hash}\"' in html\n", "patch": "@@ -23,6 +23,15 @@ def __init__(self, *args, **kwargs):\n         self.hello = kwargs.get(\"test_kwarg\")\n \n \n+class FakeComponentKwargsWithHtmlEntity(UnicornView):\n+    template_name = \"templates/test_component_kwargs_with_html_entity.html\"\n+    hello = \"world\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(**kwargs)\n+        self.hello = kwargs.get(\"test_kwarg\")\n+\n+\n class FakeComponentModel(UnicornView):\n     template_name = \"templates/test_component_model.html\"\n     model_id = None\n@@ -55,7 +64,7 @@ def test_unicorn_render_kwarg():\n     context = {}\n     actual = unicorn_node.render(context)\n \n-    assert \"->tested!<-\" in actual\n+    assert \"<b>tested!</b>\" in actual\n \n \n def test_unicorn_render_context_variable():\n@@ -67,7 +76,19 @@ def test_unicorn_render_context_variable():\n     context = {\"test_var\": {\"nested\": \"variable!\"}}\n     actual = unicorn_node.render(context)\n \n-    assert \"->variable!<-\" in actual\n+    assert \"<b>variable!</b>\" in actual\n+\n+\n+def test_unicorn_render_with_invalid_html():\n+    token = Token(\n+        TokenType.TEXT,\n+        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargsWithHtmlEntity' test_kwarg=test_var.nested\",\n+    )\n+    unicorn_node = unicorn(None, token)\n+    context = {\"test_var\": {\"nested\": \"variable!\"}}\n+    actual = unicorn_node.render(context)\n+\n+    assert \"-&gt;variable!&lt;-\" in actual\n \n \n def test_unicorn_render_parent(settings):", "file_path": "files/2021_10/795", "file_language": "py", "file_name": "tests/templatetags/test_unicorn_render.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class FakeComponentParent(UnicornView):\n    template_name = \"templates/test_component_parent.html\"", "target": 0}, {"function": "class FakeComponentKwargs(UnicornView):\n    template_name = \"templates/test_component_kwargs.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")", "target": 0}, {"function": "class FakeComponentModel(UnicornView):\n    template_name = \"templates/test_component_model.html\"\n    model_id = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.model_id = kwargs.get(\"model_id\")", "target": 0}, {"function": "class FakeComponentCalls(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall\")", "target": 0}, {"function": "class FakeComponentCalls2(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall2\", \"hello\")", "target": 0}, {"function": "def test_unicorn_render_kwarg():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg='tested!'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    actual = unicorn_node.render(context)\n\n    assert \"->tested!<-\" in actual", "target": 0}, {"function": "def test_unicorn_render_context_variable():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"->variable!<-\" in actual", "target": 0}, {"function": "def test_unicorn_render_parent(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert unicorn_node.parent\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_key(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view key='blob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:blob\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view id='flob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:flob\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view pk=99\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:99\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_model_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    # Fake a model that only has an id\n    class Model:\n        def __init__(self):\n            self.id = 178\n\n        def to_json(self):\n            return {\"id\": self.id}\n\n    context = {\"view\": view, \"model\": Model()}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:178\"\n    )", "target": 0}, {"function": "def test_unicorn_render_id_use_pk():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentModel' model_id=model.id\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"model\": {\"pk\": 123}}\n    actual = unicorn_node.render(context)\n\n    assert \"==123==\" in actual", "target": 0}, {"function": "def test_unicorn_render_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1", "target": 0}, {"function": "def test_unicorn_render_child_component_no_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    html = unicorn_node.render(context)\n\n    assert \"<script\" not in html", "target": 0}, {"function": "def test_unicorn_render_parent_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1", "target": 0}, {"function": "def test_unicorn_render_calls(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall\",\"args\":[]}]' in html", "target": 0}, {"function": "def test_unicorn_render_calls_with_arg(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls2'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall2\",\"args\":[\"hello\"]}]' in html", "target": 0}, {"function": "def test_unicorn_render_calls_no_mount_call(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[]' in html", "target": 0}, {"function": "def test_unicorn_render_hash(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"hash\":\"' in html\n\n    # Assert that the content hash is correct\n    script_idx = html.index(\"<script\")\n    rendered_content = html[:script_idx]\n    expected_hash = generate_checksum(rendered_content)\n    assert f'\"hash\":\"{expected_hash}\"' in html", "target": 0}], "function_after": [{"function": "class FakeComponentParent(UnicornView):\n    template_name = \"templates/test_component_parent.html\"", "target": 0}, {"function": "class FakeComponentKwargs(UnicornView):\n    template_name = \"templates/test_component_kwargs.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")", "target": 0}, {"function": "class FakeComponentKwargsWithHtmlEntity(UnicornView):\n    template_name = \"templates/test_component_kwargs_with_html_entity.html\"\n    hello = \"world\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.hello = kwargs.get(\"test_kwarg\")", "target": 0}, {"function": "class FakeComponentModel(UnicornView):\n    template_name = \"templates/test_component_model.html\"\n    model_id = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(**kwargs)\n        self.model_id = kwargs.get(\"model_id\")", "target": 0}, {"function": "class FakeComponentCalls(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall\")", "target": 0}, {"function": "class FakeComponentCalls2(UnicornView):\n    template_name = \"templates/test_component_parent.html\"\n\n    def mount(self):\n        self.call(\"testCall2\", \"hello\")", "target": 0}, {"function": "def test_unicorn_render_kwarg():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg='tested!'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    actual = unicorn_node.render(context)\n\n    assert \"<b>tested!</b>\" in actual", "target": 0}, {"function": "def test_unicorn_render_context_variable():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"<b>variable!</b>\" in actual", "target": 0}, {"function": "def test_unicorn_render_with_invalid_html():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargsWithHtmlEntity' test_kwarg=test_var.nested\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"test_var\": {\"nested\": \"variable!\"}}\n    actual = unicorn_node.render(context)\n\n    assert \"-&gt;variable!&lt;-\" in actual", "target": 0}, {"function": "def test_unicorn_render_parent(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert unicorn_node.parent\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_key(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view key='blob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:blob\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view id='flob'\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:flob\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_pk(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view pk=99\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:99\"\n    )", "target": 0}, {"function": "def test_unicorn_render_parent_with_model_id(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view model=model\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n\n    # Fake a model that only has an id\n    class Model:\n        def __init__(self):\n            self.id = 178\n\n        def to_json(self):\n            return {\"id\": self.id}\n\n    context = {\"view\": view, \"model\": Model()}\n    unicorn_node.render(context)\n\n    assert (\n        unicorn_node.component_id\n        == \"asdf:tests.templatetags.test_unicorn_render.FakeComponentKwargs:178\"\n    )", "target": 0}, {"function": "def test_unicorn_render_id_use_pk():\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentModel' model_id=model.id\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {\"model\": {\"pk\": 123}}\n    actual = unicorn_node.render(context)\n\n    assert \"==123==\" in actual", "target": 0}, {"function": "def test_unicorn_render_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1", "target": 0}, {"function": "def test_unicorn_render_child_component_no_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentKwargs' parent=view\",\n    )\n    unicorn_node = unicorn(None, token)\n    view = FakeComponentParent(component_name=\"test\", component_id=\"asdf\")\n    context = {\"view\": view}\n    html = unicorn_node.render(context)\n\n    assert \"<script\" not in html", "target": 0}, {"function": "def test_unicorn_render_parent_component_one_script_tag(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1", "target": 0}, {"function": "def test_unicorn_render_calls(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall\",\"args\":[]}]' in html", "target": 0}, {"function": "def test_unicorn_render_calls_with_arg(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentCalls2'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[{\"fn\":\"testCall2\",\"args\":[\"hello\"]}]' in html", "target": 0}, {"function": "def test_unicorn_render_calls_no_mount_call(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"calls\":[]' in html", "target": 0}, {"function": "def test_unicorn_render_hash(settings):\n    settings.DEBUG = True\n    token = Token(\n        TokenType.TEXT,\n        \"unicorn 'tests.templatetags.test_unicorn_render.FakeComponentParent'\",\n    )\n    unicorn_node = unicorn(None, token)\n    context = {}\n    html = unicorn_node.render(context)\n\n    assert '<script type=\"module\"' in html\n    assert len(re.findall('<script type=\"module\"', html)) == 1\n    assert '\"hash\":\"' in html\n\n    # Assert that the content hash is correct\n    script_idx = html.index(\"<script\")\n    rendered_content = html[:script_idx]\n    expected_hash = generate_checksum(rendered_content)\n    assert f'\"hash\":\"{expected_hash}\"' in html", "target": 0}]}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Fviews%2Fmessage%2Ftest_sync_input.py", "code": "from tests.views.message.utils import post_and_get_response\n\n\ndef test_message_nested_sync_input(client):\n    data = {\"dictionary\": {\"name\": \"test\"}}\n    action_queue = [\n        {\"payload\": {\"name\": \"dictionary.name\", \"value\": \"test1\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.fake_components.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"dictionary\") == {\"name\": \"test1\"}\n", "code_before": "import orjson\n\nfrom tests.views.message.utils import post_and_get_response\n\n\ndef test_message_nested_sync_input(client):\n    data = {\"dictionary\": {\"name\": \"test\"}}\n    action_queue = [\n        {\"payload\": {\"name\": \"dictionary.name\", \"value\": \"test1\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.fake_components.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"dictionary\") == {\"name\": \"test1\"}\n", "patch": "@@ -1,5 +1,3 @@\n-import orjson\n-\n from tests.views.message.utils import post_and_get_response\n \n ", "file_path": "files/2021_10/796", "file_language": "py", "file_name": "tests/views/message/test_sync_input.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_message_nested_sync_input(client):\n    data = {\"dictionary\": {\"name\": \"test\"}}\n    action_queue = [\n        {\"payload\": {\"name\": \"dictionary.name\", \"value\": \"test1\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.fake_components.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"dictionary\") == {\"name\": \"test1\"}", "target": 0}], "function_after": [{"function": "def test_message_nested_sync_input(client):\n    data = {\"dictionary\": {\"name\": \"test\"}}\n    action_queue = [\n        {\"payload\": {\"name\": \"dictionary.name\", \"value\": \"test1\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.fake_components.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"dictionary\") == {\"name\": \"test1\"}", "target": 0}]}, {"raw_url": "https://github.com/adamghill/django-unicorn/raw/3a832a9e3f6455ddd3b87f646247269918ad10c6/tests%2Fviews%2Ftest_process_component_request.py", "code": "from django_unicorn.components import UnicornView\nfrom tests.views.message.utils import post_and_get_response\n\n\nclass FakeComponent(UnicornView):\n    template_name = \"templates/test_component_variable.html\"\n\n    hello = \"\"\n\n\nclass FakeComponentSafe(UnicornView):\n    template_name = \"templates/test_component_variable.html\"\n\n    hello = \"\"\n\n    class Meta:\n        safe = (\"hello\",)\n\n\ndef test_html_entities_encoded(client):\n    data = {\"hello\": \"test\"}\n    action_queue = [\n        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.test_process_component_request.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n    assert \"&lt;b&gt;test1&lt;/b&gt;\" in response[\"dom\"]\n\n\ndef test_safe_html_entities_not_encoded(client):\n    data = {\"hello\": \"test\"}\n    action_queue = [\n        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.test_process_component_request.FakeComponentSafe\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n    assert \"<b>test1</b>\" in response[\"dom\"]\n", "code_before": "", "patch": "@@ -0,0 +1,51 @@\n+from django_unicorn.components import UnicornView\n+from tests.views.message.utils import post_and_get_response\n+\n+\n+class FakeComponent(UnicornView):\n+    template_name = \"templates/test_component_variable.html\"\n+\n+    hello = \"\"\n+\n+\n+class FakeComponentSafe(UnicornView):\n+    template_name = \"templates/test_component_variable.html\"\n+\n+    hello = \"\"\n+\n+    class Meta:\n+        safe = (\"hello\",)\n+\n+\n+def test_html_entities_encoded(client):\n+    data = {\"hello\": \"test\"}\n+    action_queue = [\n+        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n+    ]\n+    response = post_and_get_response(\n+        client,\n+        url=\"/message/tests.views.test_process_component_request.FakeComponent\",\n+        data=data,\n+        action_queue=action_queue,\n+    )\n+\n+    assert not response[\"errors\"]\n+    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n+    assert \"&lt;b&gt;test1&lt;/b&gt;\" in response[\"dom\"]\n+\n+\n+def test_safe_html_entities_not_encoded(client):\n+    data = {\"hello\": \"test\"}\n+    action_queue = [\n+        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n+    ]\n+    response = post_and_get_response(\n+        client,\n+        url=\"/message/tests.views.test_process_component_request.FakeComponentSafe\",\n+        data=data,\n+        action_queue=action_queue,\n+    )\n+\n+    assert not response[\"errors\"]\n+    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n+    assert \"<b>test1</b>\" in response[\"dom\"]", "file_path": "files/2021_10/797", "file_language": "py", "file_name": "tests/views/test_process_component_request.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": [{"function": "class FakeComponent(UnicornView):\n    template_name = \"templates/test_component_variable.html\"\n\n    hello = \"\"", "target": 0}, {"function": "class FakeComponentSafe(UnicornView):\n    template_name = \"templates/test_component_variable.html\"\n\n    hello = \"\"\n\n    class Meta:\n        safe = (\"hello\",)", "target": 0}, {"function": "def test_html_entities_encoded(client):\n    data = {\"hello\": \"test\"}\n    action_queue = [\n        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.test_process_component_request.FakeComponent\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n    assert \"&lt;b&gt;test1&lt;/b&gt;\" in response[\"dom\"]", "target": 0}, {"function": "def test_safe_html_entities_not_encoded(client):\n    data = {\"hello\": \"test\"}\n    action_queue = [\n        {\"payload\": {\"name\": \"hello\", \"value\": \"<b>test1</b>\"}, \"type\": \"syncInput\",}\n    ]\n    response = post_and_get_response(\n        client,\n        url=\"/message/tests.views.test_process_component_request.FakeComponentSafe\",\n        data=data,\n        action_queue=action_queue,\n    )\n\n    assert not response[\"errors\"]\n    assert response[\"data\"].get(\"hello\") == \"<b>test1</b>\"\n    assert \"<b>test1</b>\" in response[\"dom\"]", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
