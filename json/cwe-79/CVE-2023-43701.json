{"index": 12648, "cve_id": "CVE-2023-43701", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Improper payload validation and an improper REST API response type, made it possible for an authenticated malicious actor to store malicious code into Chart's metadata, this code could get executed if a user specifically accesses a specific deprecated API endpoint.\u00a0This issue affects Apache Superset versions prior to 2.1.2.\u00a0\nUsers are recommended to upgrade to version 2.1.2, which fixes this issue.", "cvss": "4.3", "publish_date": "November 27, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "NONE", "A": "NONE", "commit_id": "d80f326d531f04bc871e55bf3ca2a33d7faff808", "commit_message": "chore(view_api): return application/json as content-type for api/v1/form_data endpoint (#24758)\n\n(cherry picked from commit 0631a8086cd95f3b6e88b31d29c7fbc2e1d20b25)", "commit_date": "2023-10-19T23:32:15Z", "project": "apache/superset", "url": "https://api.github.com/repos/apache/superset/commits/d80f326d531f04bc871e55bf3ca2a33d7faff808", "html_url": "https://github.com/apache/superset/commit/d80f326d531f04bc871e55bf3ca2a33d7faff808", "windows_before": [{"commit_id": "ee2369019694c55111bf4030e808cf6fd1fbf315", "commit_date": "Fri Oct 20 01:30:34 2023 +0200", "commit_message": "feat: add France's regions to country map visualization (#25676)", "files_name": ["superset-frontend/plugins/legacy-plugin-chart-country-map/src/countries.ts", "superset-frontend/plugins/legacy-plugin-chart-country-map/src/countries/france_regions.geojson"]}, {"commit_id": "def7cd1b89f755985ee03f0681ad254823389a85", "commit_date": "Thu Oct 19 23:16:02 2023 +0200", "commit_message": "chore: helm chart: bump appVersion to 3.0.1 (#25709)", "files_name": ["helm/superset/Chart.yaml", "helm/superset/README.md"]}, {"commit_id": "505678b37bdacc7e6088e66a714b30ceb8c7f8a4", "commit_date": "Thu Oct 19 21:26:20 2023 +0200", "commit_message": "chore: Change the format for sha512 sum for releases (#25577)", "files_name": ["scripts/sign.sh"]}, {"commit_id": "39ad3226c7bb7a3c1ad731d3e5063e70a5adba08", "commit_date": "Fri Oct 20 01:05:58 2023 +0700", "commit_message": "feat: add database and schema names to dataset option (#25569)", "files_name": ["superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/DatasetSelect.tsx", "superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FiltersConfigForm.tsx", "superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/utils.ts", "superset-frontend/src/features/datasets/DatasetSelectLabel/index.tsx", "superset-frontend/src/pages/ChartCreation/index.tsx"]}, {"commit_id": "dfff3c1cbaccc416315aa09efd9b32430f473ef0", "commit_date": "Thu Oct 19 14:04:29 2023 -0400", "commit_message": "feat: Funnel/tooltip-customization (#25666)", "files_name": ["superset-frontend/plugins/plugin-chart-echarts/src/Funnel/controlPanel.tsx", "superset-frontend/plugins/plugin-chart-echarts/src/Funnel/transformProps.ts", "superset-frontend/plugins/plugin-chart-echarts/src/Funnel/types.ts"]}, {"commit_id": "da42bf2dbb82a40d5ffcc9bfdc46584cb36af616", "commit_date": "Thu Oct 19 21:03:44 2023 +0300", "commit_message": "fix: remove unnecessary redirect (#25679)", "files_name": ["superset-frontend/src/SqlLab/components/ResultSet/ResultSet.test.tsx", "superset-frontend/src/SqlLab/components/SaveDatasetModal/SaveDatasetModal.test.tsx", "superset-frontend/src/SqlLab/components/SaveDatasetModal/index.tsx"]}, {"commit_id": "07796b752872de1feb161a613ed22d2a8dbf4a4c", "commit_date": "Thu Oct 19 12:03:16 2023 -0600", "commit_message": "build(deps-dev): bump @types/cookie from 0.5.1 to 0.5.3 in /superset-websocket (#25689)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "e29e2684d01ac76db34e5f990f810456e9433970", "commit_date": "Thu Oct 19 12:02:50 2023 -0600", "commit_message": "build(deps-dev): bump @types/uuid from 9.0.4 to 9.0.6 in /superset-websocket (#25701)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "bac5a8554105605f0ef3bb09a7f144b688e5e24f", "commit_date": "Thu Oct 19 23:32:07 2023 +0530", "commit_message": "docs(README): remove typo (#25710)", "files_name": ["README.md"]}, {"commit_id": "1d37f3a15b3ab87ddf064c3a51685d85c6be9d5b", "commit_date": "Thu Oct 19 09:50:30 2023 -0700", "commit_message": "build(deps-dev): bump @types/node from 20.8.6 to 20.8.7 in /superset-websocket (#25700)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "4e94fc4cff9e7dff2ddd7c176b647bdb19b9b1e2", "commit_date": "Thu Oct 19 14:38:13 2023 +0100", "commit_message": "fix(sqllab): reinstate \"Force trino client async execution\" (#25680)", "files_name": ["docs/docs/databases/installing-database-drivers.mdx", "docs/docs/frequently-asked-questions.mdx", "docs/docs/installation/configuring-superset.mdx", "superset/config.py", "superset/db_engine_specs/base.py", "superset/db_engine_specs/trino.py", "superset/sql_lab.py", "tests/unit_tests/db_engine_specs/test_trino.py", "tests/unit_tests/sql_lab_test.py"]}, {"commit_id": "e7cdfeeb2c6af386ae1d9d13c460485b25407652", "commit_date": "Thu Oct 19 04:39:16 2023 +0200", "commit_message": "feat: Add week time grain for Elasticsearch datasets (#25683)", "files_name": ["superset/db_engine_specs/elasticsearch.py", "tests/integration_tests/db_engine_specs/elasticsearch_tests.py"]}, {"commit_id": "26498fc09921bbfc5a2fbaa286586b07ca5835e3", "commit_date": "Wed Oct 18 16:59:30 2023 -0700", "commit_message": "chore: add latest-official docker tag (#25322)", "files_name": [".github/workflows/docker-release.yml", ".github/workflows/docker.yml", "scripts/docker_build_push.sh", "scripts/tag_latest_release.sh", "tests/unit_tests/fixtures/bash_mock.py", "tests/unit_tests/scripts/docker_build_push_test.py", "tests/unit_tests/scripts/tag_latest_release_test.py"]}, {"commit_id": "be8265794059d8bbe216a4cb22c7a3f6adf4bcb3", "commit_date": "Wed Oct 18 21:54:27 2023 +0200", "commit_message": "fix(dremio): Fixes issue with Dremio SQL generation for Charts with Series Limit (#25657)", "files_name": ["superset/db_engine_specs/dremio.py"]}, {"commit_id": "dc06fb8b11876ecb039d1eb4efb925138cc5cf2e", "commit_date": "Wed Oct 18 15:48:18 2023 -0300", "commit_message": "chore: Adds 3.0.1 data to CHANGELOG.md (#25691)", "files_name": ["CHANGELOG.md"]}, {"commit_id": "8b32b2abd33bd9c3bc3ac47a6c7ec9a89beff62d", "commit_date": "Wed Oct 18 10:22:31 2023 -0700", "commit_message": "build(deps-dev): bump @types/jsonwebtoken from 9.0.3 to 9.0.4 in /superset-websocket (#25688)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "a27a809f0702a4fc8128b97831fd5ab26e101a84", "commit_date": "Tue Oct 17 23:39:15 2023 -0400", "commit_message": "fix(tags): +n tags for listview (#25603)", "files_name": ["superset-frontend/src/components/Tags/Tag.test.tsx", "superset-frontend/src/components/Tags/Tag.tsx", "superset-frontend/src/components/Tags/TagsList.tsx", "superset-frontend/src/types/TagType.ts"]}, {"commit_id": "32e37d8cda46f7760220601908e4c4dd7ca5b5b4", "commit_date": "Tue Oct 17 15:58:43 2023 -0700", "commit_message": "chore: Cleanup hostNamesConfig.js (#25543)", "files_name": ["superset-frontend/src/utils/hostNamesConfig.js"]}, {"commit_id": "16cc089b198dcdebc2422845aa08d18233c6b3a4", "commit_date": "Tue Oct 17 15:33:07 2023 -0400", "commit_message": "fix: warning of nth-child (#23638)", "files_name": ["superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx", "superset-frontend/plugins/legacy-preset-chart-nvd3/src/ReactNVD3.jsx", "superset-frontend/src/SqlLab/components/SaveDatasetActionButton/index.tsx", "superset-frontend/src/components/ButtonGroup/index.tsx", "superset-frontend/src/components/DropdownButton/index.tsx", "superset-frontend/src/components/DropdownSelectableIcon/index.tsx"]}, {"commit_id": "deef3b04ebed1178259af5909779392cfa0cd630", "commit_date": "Tue Oct 17 14:03:35 2023 -0400", "commit_message": "feat(sqllab): ResultTable extension (#25423)", "files_name": ["superset-frontend/packages/superset-ui-core/src/ui-overrides/types.ts", "superset-frontend/src/SqlLab/components/ResultSet/index.tsx", "superset-frontend/src/components/FilterableTable/FilterableTable.test.tsx", "superset-frontend/src/components/FilterableTable/index.tsx", "superset-frontend/src/components/FilterableTable/useCellContentParser.test.ts", "superset-frontend/src/components/FilterableTable/useCellContentParser.ts", "superset-frontend/src/components/FilterableTable/utils.test.tsx", "superset-frontend/src/components/FilterableTable/utils.tsx", "superset-frontend/src/components/JsonModal/JsonModal.test.tsx", "superset-frontend/src/components/JsonModal/index.tsx"]}, {"commit_id": "150e5c90f7cbcfc66dbd7a8bdbac8750d52a4bba", "commit_date": "Tue Oct 17 19:43:38 2023 +0200", "commit_message": "docs: make project-specific security page more prominent (#25654)", "files_name": ["docs/docs/security/security.mdx", "docs/docusaurus.config.js"]}, {"commit_id": "f473d13d0d89de5990209ff81b17dfe2cee884d3", "commit_date": "Tue Oct 17 18:28:09 2023 +0100", "commit_message": "fix: improve upload ZIP file validation (#25658)", "files_name": ["superset/commands/importers/v1/utils.py", "superset/config.py", "superset/utils/core.py", "tests/unit_tests/utils/test_core.py"]}, {"commit_id": "cb963585ad9190db62b5e59dd25ecfb841de415a", "commit_date": "Tue Oct 17 09:51:35 2023 -0700", "commit_message": "chore: sync lock files (#25667)", "files_name": ["requirements/base.txt"]}, {"commit_id": "1991d240bfd0024abf1414f1367e62a23c2bca65", "commit_date": "Tue Oct 17 09:50:33 2023 -0700", "commit_message": "build(deps-dev): bump @babel/traverse from 7.16.0 to 7.23.2 in /superset-websocket (#25661)", "files_name": ["superset-websocket/package-lock.json"]}, {"commit_id": "51c56dd2a0f52fa092862f8bc5833749f9adc1ba", "commit_date": "Tue Oct 17 11:45:25 2023 -0500", "commit_message": "fix(header navlinks): link navlinks to path prefix (#25495)", "files_name": ["superset-frontend/src/features/home/Menu.test.tsx", "superset-frontend/src/features/home/Menu.tsx"]}, {"commit_id": "e58a3aba545fd03f2af33b0075c4cacf09f776a3", "commit_date": "Mon Oct 16 14:00:09 2023 -0400", "commit_message": "fix: permalink save/overwrites in explore (#25112)", "files_name": ["superset-frontend/src/explore/components/SaveModal.test.jsx", "superset-frontend/src/explore/components/SaveModal.tsx"]}, {"commit_id": "18a1c8d7d84be81fdb250a61514b96c77c8f032a", "commit_date": "Mon Oct 16 09:57:32 2023 -0700", "commit_message": "build(deps-dev): bump @types/node from 20.8.5 to 20.8.6 in /superset-websocket (#25653)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "a0a0d8043fe7004134bf89a05e6b5f6ee41399e5", "commit_date": "Mon Oct 16 09:49:55 2023 -0700", "commit_message": "fix(import): Make sure query context is overwritten for overwriting imports (#25493)", "files_name": ["superset/charts/commands/importers/v1/__init__.py", "superset/commands/importers/v1/assets.py", "superset/dashboards/commands/importers/v1/__init__.py"]}, {"commit_id": "8c6bd4ef047b1914b7e3023d6b559b4bdae13b65", "commit_date": "Sun Oct 15 07:40:10 2023 -0700", "commit_message": "chore: bump pip-tools (#25645)", "files_name": ["requirements/development.txt", "requirements/integration.txt", "requirements/testing.txt"]}, {"commit_id": "99f79f5143c417497ffde326a8393ab60aa71e7e", "commit_date": "Fri Oct 13 22:30:19 2023 +0300", "commit_message": "fix: avoid 500 errors with SQLLAB_BACKEND_PERSISTENCE (#25553)", "files_name": ["superset/views/sql_lab/views.py", "tests/integration_tests/core_tests.py"]}, {"commit_id": "56f74e5215d3f11159c37aee5c2b160610062e38", "commit_date": "Sat Oct 14 03:29:34 2023 +0800", "commit_message": "docs: invert logo color for dark theme in README (#25537)", "files_name": ["README.md", "superset-frontend/src/assets/branding/superset-logo-horiz-apache-dark.png", "superset-frontend/src/assets/branding/superset-logo-horiz-apache-dark.svg"]}, {"commit_id": "e8783033f85d27863fc0f8316f9a5c2a9541a794", "commit_date": "Fri Oct 13 13:28:24 2023 -0600", "commit_message": "chore: adding resource links to readme (#25629)", "files_name": ["README.md"]}, {"commit_id": "5054b9fadeea28885526861e3c7db5ed0e36464b", "commit_date": "Fri Oct 13 14:00:09 2023 -0400", "commit_message": "build(ci): Provide diff for pre-commit failures (#25638)", "files_name": [".github/workflows/superset-python-misc.yml"]}, {"commit_id": "9074f72959956701bc46406ffb503670d9859b22", "commit_date": "Fri Oct 13 13:13:59 2023 -0400", "commit_message": "fix(tags): Polish + Better messaging for skipped tags with bad permissions (#25578)", "files_name": ["superset-frontend/src/features/tags/BulkTagModal.tsx", "superset-frontend/src/pages/AllEntities/index.tsx", "superset-frontend/src/pages/ChartList/ChartList.test.jsx", "superset-frontend/src/pages/ChartList/index.tsx", "superset-frontend/src/pages/DashboardList/DashboardList.test.jsx", "superset-frontend/src/pages/DashboardList/index.tsx", "superset-frontend/src/pages/SavedQueryList/SavedQueryList.test.jsx", "superset-frontend/src/pages/SavedQueryList/index.tsx", "superset/tags/api.py", "superset/tags/commands/create.py", "superset/tags/commands/update.py", "tests/integration_tests/tags/api_tests.py"]}, {"commit_id": "b370c66308e1bc84031ed7aae855aa72c20fbd11", "commit_date": "Fri Oct 13 13:07:54 2023 -0400", "commit_message": "fix(sqllab): template validation error within comments (#25626)", "files_name": ["superset/sqllab/query_render.py", "tests/integration_tests/sqllab_tests.py"]}, {"commit_id": "4a01b6006ce249c3034e4891fbd56361ca6977dc", "commit_date": "Fri Oct 13 10:54:50 2023 -0600", "commit_message": "build(deps-dev): bump @types/node from 20.8.4 to 20.8.5 in /superset-websocket (#25632)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "bfcca8cbab00e06d8d508056cf6aabecd030e65b", "commit_date": "Fri Oct 13 12:37:51 2023 -0400", "commit_message": "chore(helm): spelling: initialize (#25455)", "files_name": ["helm/superset/Chart.yaml", "helm/superset/README.md", "helm/superset/values.yaml"]}, {"commit_id": "59fc5a6184d47c359fd830fd1a9bded531e3594c", "commit_date": "Fri Oct 13 20:48:08 2023 +0530", "commit_message": "docs: BugHerd Tasks 88, 89, 90, 91 (#25567)", "files_name": ["docs/docs/installation/configuring-superset.mdx", "docs/docs/installation/installing-superset-from-scratch.mdx", "docs/docs/security/security.mdx"]}, {"commit_id": "a520124a78286aea0f9a7ad491d041bbca2c3596", "commit_date": "Fri Oct 13 11:17:45 2023 -0400", "commit_message": "fix(sqllab): Mistitled for new tab after rename (#25523)", "files_name": ["superset-frontend/src/SqlLab/actions/sqlLab.js", "superset-frontend/src/SqlLab/actions/sqlLab.test.js"]}, {"commit_id": "003001f19f9857f4ddca88046685077020ea90c4", "commit_date": "Fri Oct 13 11:16:50 2023 -0400", "commit_message": "fix(sqllab): Allow opening of SQL Lab in new browser tab  (#25582)", "files_name": ["superset-frontend/src/components/Chart/chartAction.js", "superset-frontend/src/explore/components/ExploreChartHeader/index.jsx", "superset-frontend/src/explore/components/controls/DatasourceControl/index.jsx", "superset-frontend/src/explore/components/controls/ViewQueryModalFooter.tsx"]}], "windows_after": [{"commit_id": "75a74313799b70b636c88cf421fd4d1118cc8a61", "commit_date": "Fri Oct 20 10:32:14 2023 +0300", "commit_message": "fix(chore): dashboard requests to database equal the number of slices it has (#24709)", "files_name": ["superset/daos/dashboard.py"]}, {"commit_id": "8fb0c8da56f572c086126cc5ca16676ce74e7a3c", "commit_date": "Fri Oct 20 11:33:40 2023 +0100", "commit_message": "fix: bump to FAB 4.3.9 remove CSP exception (#25712)", "files_name": ["requirements/base.txt", "setup.py", "superset/config.py"]}, {"commit_id": "9972ac69088ae0bf4b72d2340ee7ba62a4760ac3", "commit_date": "Fri Oct 20 19:05:05 2023 +0200", "commit_message": "refactor: use DATE_TRUNC for Elasticsearch time grain (#25717)", "files_name": ["superset/db_engine_specs/elasticsearch.py", "tests/integration_tests/db_engine_specs/elasticsearch_tests.py"]}, {"commit_id": "4ac8f826f2bf1048f5998dcedfbd774f0f764504", "commit_date": "Fri Oct 20 12:07:03 2023 -0600", "commit_message": "fix(driver): bumping DuckDB to 0.9.2 (#25718)", "files_name": ["setup.py"]}, {"commit_id": "ed87470bcc8c85d403bc42c337352ec1e682ced0", "commit_date": "Fri Oct 20 17:46:57 2023 -0400", "commit_message": "fix(metadb): handle durations (#25727)", "files_name": ["superset/extensions/metadb.py"]}, {"commit_id": "4aef7710725a1813a43b438454a7b1ddb8b8ebf8", "commit_date": "Mon Oct 23 07:46:01 2023 -0700", "commit_message": "chore: updated base DAO find_by_id to return generic type (#25726)", "files_name": ["superset/daos/base.py"]}, {"commit_id": "cbbf2bed6e430d531c753be1f16bd7f23563270d", "commit_date": "Mon Oct 23 09:50:02 2023 -0700", "commit_message": "build(deps-dev): bump eslint from 8.51.0 to 8.52.0 in /superset-websocket (#25735)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "e4173d90c8ccef58a87ec7ac00b57c1ec9317c11", "commit_date": "Mon Oct 23 13:51:48 2023 -0300", "commit_message": "fix(horizontal filter label): show full tooltip with ellipsis (#25732)", "files_name": ["superset-frontend/src/dashboard/components/nativeFilters/FilterBar/FilterControls/FilterControl.tsx"]}, {"commit_id": "861ee8b3c6886a61c6d9ed3f819f7bc35ab2867d", "commit_date": "Mon Oct 23 11:28:41 2023 -0700", "commit_message": "chore(websocket): [WIP] Making JWT algos configurable (#25521)", "files_name": ["superset-websocket/config.example.json", "superset-websocket/src/config.ts", "superset-websocket/src/index.ts"]}, {"commit_id": "419d12281612bd0cd1bdca121efbb39f02d7cb1e", "commit_date": "Tue Oct 24 12:53:00 2023 +0800", "commit_message": "chore: bump pymssql version (#25737)", "files_name": ["setup.py"]}, {"commit_id": "27a06f57e18cc9bf63c3c3155ac8fc3db21d158f", "commit_date": "Tue Oct 24 21:02:24 2023 +0530", "commit_message": "style(readme): reformatted  (#25721)", "files_name": ["README.md"]}, {"commit_id": "e2fe96778887d203a852cf09def151ff024cfaf7", "commit_date": "Wed Oct 25 15:39:49 2023 +0300", "commit_message": "fix: Revert \"fix(Charts): Set max row limit + removed the option to use an empty row limit value\" (#25753)", "files_name": ["superset-frontend/packages/superset-ui-chart-controls/src/shared-controls/sharedControls.tsx", "superset-frontend/packages/superset-ui-core/src/validator/index.ts", "superset-frontend/packages/superset-ui-core/src/validator/validateMaxValue.ts", "superset-frontend/packages/superset-ui-core/test/validator/validateMaxValue.test.ts"]}, {"commit_id": "cee85327339e948dc25e77153c90abb731144f5b", "commit_date": "Wed Oct 25 14:44:44 2023 -0400", "commit_message": "fix(README): mismatched picture tags (#25739)", "files_name": ["README.md"]}, {"commit_id": "c7f8d11a7eca33b7eed187f4e757fd7b9f45f9be", "commit_date": "Wed Oct 25 16:49:32 2023 -0400", "commit_message": "fix: dataset update uniqueness (#25756)", "files_name": ["superset/daos/dataset.py", "superset/datasets/commands/update.py", "tests/unit_tests/dao/dataset_test.py"]}, {"commit_id": "2a2bc82a8bbf900c825ba44e8b0f3f320b5962e0", "commit_date": "Thu Oct 26 12:44:41 2023 -0700", "commit_message": "fix(sqllab): slow pop datasource query (#25741)", "files_name": ["superset-frontend/src/SqlLab/actions/sqlLab.js"]}, {"commit_id": "bda43ac0f6be3523230ccd5703b57547e8aed6f3", "commit_date": "Fri Oct 27 10:37:32 2023 +0200", "commit_message": "chore: Add config options for Playwright wait_until and default timeout (#25765)", "files_name": ["superset/config.py", "superset/utils/webdriver.py"]}, {"commit_id": "ed14f36c558459c6dd231dcbcdf6fe52ca15998e", "commit_date": "Fri Oct 27 11:04:33 2023 -0700", "commit_message": "fix: allow for backward compatible errors (#25640)", "files_name": ["superset-frontend/src/components/Datasource/DatasourceEditor.jsx", "superset-frontend/src/components/Datasource/DatasourceModal.test.jsx", "superset-frontend/src/components/Datasource/DatasourceModal.tsx", "superset-frontend/src/components/ErrorMessage/types.ts", "superset-frontend/src/utils/errorMessages.ts"]}, {"commit_id": "5659c87ed2da1ebafe3578cac9c3c52aeb256c5d", "commit_date": "Mon Oct 30 09:50:44 2023 -0400", "commit_message": "fix: DB-specific quoting in Jinja macro (#25779)", "files_name": ["superset/jinja_context.py", "tests/unit_tests/jinja_context_test.py"]}, {"commit_id": "74dbada473e150203986f22c5e38ac314c551f9c", "commit_date": "Mon Oct 30 20:54:33 2023 -0500", "commit_message": "feat(Export as PDF - rasterized): Adding rasterized pdf functionality to dashboard (#25696)", "files_name": ["superset-frontend/package-lock.json", "superset-frontend/package.json", "superset-frontend/src/dashboard/components/Header/HeaderActionsDropdown/HeaderActionsDropdown.test.tsx", "superset-frontend/src/dashboard/components/Header/HeaderActionsDropdown/index.jsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/DownloadAsImage.test.tsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/DownloadAsImage.tsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/DownloadAsPdf.test.tsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/DownloadAsPdf.tsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/DownloadMenuItems.test.tsx", "superset-frontend/src/dashboard/components/menu/DownloadMenuItems/index.tsx", "superset-frontend/src/logger/LogUtils.ts", "superset-frontend/src/types/dom-to-pdf.d.ts", "superset-frontend/src/utils/downloadAsImage.ts", "superset-frontend/src/utils/downloadAsPdf.ts"]}, {"commit_id": "0f01d9b08f5c5b5cb21d2e48caeb1a7632fbd16a", "commit_date": "Tue Oct 31 13:19:55 2023 +1100", "commit_message": "feat(helm): Add option to deploy extra containers to init job (#25783)", "files_name": ["helm/superset/Chart.yaml", "helm/superset/README.md", "helm/superset/templates/init-job.yaml", "helm/superset/values.yaml"]}, {"commit_id": "5e6d05b3fdf9e14dcbb962f62fd8dbe6604b4470", "commit_date": "Tue Oct 31 23:12:31 2023 +1100", "commit_message": "fix(helm): Fix init extra containers (#25803)", "files_name": ["helm/superset/Chart.yaml", "helm/superset/README.md", "helm/superset/templates/init-job.yaml"]}, {"commit_id": "ae703b48fca3cad0ccafa01e7aa8ca49d72836cc", "commit_date": "Tue Oct 31 06:21:47 2023 -0700", "commit_message": "fix: Revert \"fix: Apply normalization to all dttm columns (#25147)\" (#25801)", "files_name": ["superset/common/query_context_factory.py", "superset/common/query_context_processor.py", "superset/common/query_object_factory.py", "tests/integration_tests/query_context_tests.py", "tests/unit_tests/common/test_query_object_factory.py"]}, {"commit_id": "7804d1451e88a20ce512db6a5a89a4cf4c6ddd90", "commit_date": "Tue Oct 31 08:23:42 2023 -0700", "commit_message": "chore(security): Make get_database_perm/get_dataset_perm return optional (#24046)", "files_name": ["superset/security/manager.py"]}, {"commit_id": "8737a8a54669037473a89688b9029bc9f3b4ad09", "commit_date": "Tue Oct 31 08:24:41 2023 -0700", "commit_message": "fix: Resolve issue #24195 (#25804)", "files_name": ["superset-frontend/src/constants.ts"]}, {"commit_id": "d2f511abba5240c137405267e0ebe30b9e3504d4", "commit_date": "Tue Oct 31 16:05:18 2023 +0000", "commit_message": "feat: support server-side sessions (#25795)", "files_name": ["docs/docs/security/security.mdx", "requirements/base.txt", "requirements/testing.txt", "setup.py", "superset/config.py", "superset/initialization/__init__.py"]}, {"commit_id": "1eba7121aa1c40fdaa55d1a55024c55c63901b4c", "commit_date": "Tue Oct 31 13:23:44 2023 -0300", "commit_message": "fix(SQL field in edit dataset modal): display full sql query (#25768)", "files_name": ["superset-frontend/src/components/Datasource/DatasourceEditor.jsx"]}, {"commit_id": "2177a50c7afeb7ab2e7b13425532e5bce502983e", "commit_date": "Tue Oct 31 10:23:58 2023 -0600", "commit_message": "build(deps): bump browserify-sign from 4.2.1 to 4.2.2 in /superset-frontend (#25778)", "files_name": ["superset-frontend/package-lock.json"]}, {"commit_id": "1e37f0b41782d35d68f657bfa87aeb9055d1e6e7", "commit_date": "Tue Oct 31 10:17:51 2023 -0700", "commit_message": "chore(celery): Cleanup config and async query specifications (#25314)", "files_name": ["docs/docs/installation/alerts-reports.mdx", "docs/docs/installation/async-queries-celery.mdx", "docs/docs/installation/cache.mdx", "docs/docs/installation/running-on-kubernetes.mdx", "helm/superset/Chart.yaml", "helm/superset/README.md", "helm/superset/templates/_helpers.tpl", "superset/config.py", "tests/integration_tests/superset_test_config.py", "tests/integration_tests/superset_test_config_thumbnails.py"]}, {"commit_id": "3f28eebb2061b53c0a15c24588261b6a71fbb799", "commit_date": "Wed Nov 1 05:03:03 2023 -0700", "commit_message": "fix(sqllab): infinite fetching status after results are landed (#25814)", "files_name": ["superset-frontend/src/SqlLab/reducers/sqlLab.js", "superset-frontend/src/SqlLab/reducers/sqlLab.test.js"]}, {"commit_id": "e1eb985aa82b95f5d8f0a907c3aa5d8ed0595c84", "commit_date": "Wed Nov 1 15:25:40 2023 +0000", "commit_message": "docs: Add Cyberhaven to Users list (#25530)", "files_name": ["RESOURCES/INTHEWILD.md"]}, {"commit_id": "f265b2c1ae1b95ab1789f98d62ea939d0d2e82d3", "commit_date": "Wed Nov 1 11:35:48 2023 -0700", "commit_message": "build(deps-dev): bump @types/node from 20.8.7 to 20.8.10 in /superset-websocket (#25816)", "files_name": ["superset-websocket/package-lock.json", "superset-websocket/package.json"]}, {"commit_id": "a249e418b360de85c30d50643e0e4c6477926e97", "commit_date": "Wed Nov 1 12:37:10 2023 -0600", "commit_message": "chore(issues): config.yaml added with feature request link to open a discussion (#25823)", "files_name": [".github/ISSUE_TEMPLATE/config.yml"]}, {"commit_id": "a3686459a9ac4a4b916c111971de85800c0e7dee", "commit_date": "Wed Nov 1 12:37:21 2023 -0600", "commit_message": "chore: Update sip.md to have a better call to action (#25822)", "files_name": [".github/ISSUE_TEMPLATE/sip.md"]}, {"commit_id": "6ace22da87306313f4fb4281e536e7664a2b8dcc", "commit_date": "Wed Nov 1 16:52:14 2023 -0700", "commit_message": "chore(websocket): Adding support for redis username in websocket server (#25826)", "files_name": ["superset-websocket/config.test.json", "superset-websocket/package-lock.json", "superset-websocket/package.json", "superset-websocket/spec/config.test.ts", "superset-websocket/spec/index.test.ts", "superset-websocket/src/config.ts", "superset-websocket/src/index.ts"]}, {"commit_id": "aaf7d6b7e4a4fcaf12f620b181675d0974ec0418", "commit_date": "Thu Nov 2 11:02:47 2023 -0300", "commit_message": "chore: Removes border of the color picker control (#25812)", "files_name": ["superset-frontend/src/explore/components/controls/ColorPickerControl.jsx"]}, {"commit_id": "b58cc24bd4d5144a3328c7c8bdb0166eddc2b5f2", "commit_date": "Thu Nov 2 17:39:45 2023 +0000", "commit_message": "chore(docker-compose): more host network specifiers (#25817)", "files_name": ["docker-compose.yml"]}, {"commit_id": "5690946b1a97a7d1a8a53e64a5148cd3eaa2f21b", "commit_date": "Fri Nov 3 03:00:11 2023 +0800", "commit_message": "feat: support databend for superset (#23308)", "files_name": ["README.md", "docs/docs/databases/databend.mdx", "setup.py", "superset-frontend/src/assets/images/databend.svg", "superset/db_engine_specs/databend.py", "tests/unit_tests/db_engine_specs/test_databend.py"]}, {"commit_id": "508721bd9735d94c899d9afbee1eb9dd725209c4", "commit_date": "Thu Nov 2 21:22:44 2023 +0200", "commit_message": "docs: Update location of `async_query_manager.py` (#25531)", "files_name": ["superset-websocket/README.md"]}, {"commit_id": "c3f3ec56d6d82201c34f36b75a243e8fec2c5dde", "commit_date": "Fri Nov 3 19:49:33 2023 +0800", "commit_message": "fix: databend png pic (#25851)", "files_name": ["superset-frontend/src/assets/images/databend.png", "superset-frontend/src/assets/images/databend.svg"]}, {"commit_id": "ff8bc3c426a43292d5410d0e5143fd9fb91bd434", "commit_date": "Fri Nov 3 09:47:18 2023 -0300", "commit_message": "chore: Updates Databend image extension reference in README.md (#25852)", "files_name": ["README.md"]}, {"commit_id": "8061d5cce982b0b828f5de69647a1f5b75f41a46", "commit_date": "Fri Nov 3 10:35:43 2023 -0300", "commit_message": "fix: Fires onChange when clearing all values of single select (#25853)", "files_name": ["superset-frontend/src/components/Select/AsyncSelect.test.tsx", "superset-frontend/src/components/Select/Select.test.tsx", "superset-frontend/src/components/Select/Select.tsx"]}, {"commit_id": "d619078d25dde63c55e9afd87e98f05d4fb82b86", "commit_date": "Fri Nov 3 13:24:15 2023 -0300", "commit_message": "feat: Improves the Waterfall chart (#25557)", "files_name": ["superset-frontend/packages/superset-ui-core/src/color/index.ts", "superset-frontend/packages/superset-ui-core/src/color/types.ts", "superset-frontend/packages/superset-ui-core/src/color/utils.ts", "superset-frontend/packages/superset-ui-core/test/color/utils.test.ts", "superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts", "superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts", "superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts"]}], "parents": [{"commit_id_before": "1f104a0c502047a8c60b0a52add5cbe3694e1d26", "url_before": "https://api.github.com/repos/apache/superset/commits/1f104a0c502047a8c60b0a52add5cbe3694e1d26", "html_url_before": "https://github.com/apache/superset/commit/1f104a0c502047a8c60b0a52add5cbe3694e1d26"}], "details": [{"raw_url": "https://github.com/apache/superset/raw/d80f326d531f04bc871e55bf3ca2a33d7faff808/superset%2Fviews%2Fapi.py", "code": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\nfrom __future__ import annotations\n\nfrom typing import Any, TYPE_CHECKING\n\nimport simplejson as json\nfrom flask import request\nfrom flask_appbuilder import expose\nfrom flask_appbuilder.api import rison\nfrom flask_appbuilder.security.decorators import has_access_api\nfrom flask_babel import lazy_gettext as _\n\nfrom superset import db, event_logger\nfrom superset.charts.commands.exceptions import (\n    TimeRangeAmbiguousError,\n    TimeRangeParseFailError,\n)\nfrom superset.legacy import update_time_range\nfrom superset.models.slice import Slice\nfrom superset.superset_typing import FlaskResponse\nfrom superset.utils import core as utils\nfrom superset.utils.date_parser import get_since_until\nfrom superset.views.base import api, BaseSupersetView, handle_api_exception\n\nif TYPE_CHECKING:\n    from superset.common.query_context_factory import QueryContextFactory\n\nget_time_range_schema = {\"type\": \"string\"}\n\n\nclass Api(BaseSupersetView):\n    query_context_factory = None\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/query/\", methods=[\"POST\"])\n    def query(self) -> FlaskResponse:\n        \"\"\"\n        Takes a query_obj constructed in the client and returns payload data response\n        for the given query_obj.\n\n        raises SupersetSecurityException: If the user cannot access the resource\n        \"\"\"\n        query_context = self.get_query_context_factory().create(\n            **json.loads(request.form[\"query_context\"])\n        )\n        query_context.raise_for_access()\n        result = query_context.get_payload()\n        payload_json = result[\"queries\"]\n        return json.dumps(\n            payload_json, default=utils.json_int_dttm_ser, ignore_nan=True\n        )\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/form_data/\", methods=[\"GET\"])\n    def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n        \"\"\"\n        Get the formdata stored in the database for existing slice.\n        params: slice_id: integer\n        \"\"\"\n        form_data = {}\n        slice_id = request.args.get(\"slice_id\")\n        if slice_id:\n            slc = db.session.query(Slice).filter_by(id=slice_id).one_or_none()\n            if slc:\n                form_data = slc.form_data.copy()\n\n        update_time_range(form_data)\n\n        return self.json_response(form_data)\n\n    @api\n    @handle_api_exception\n    @has_access_api\n    @rison(get_time_range_schema)\n    @expose(\"/v1/time_range/\", methods=[\"GET\"])\n    def time_range(self, **kwargs: Any) -> FlaskResponse:\n        \"\"\"Get actually time range from human readable string or datetime expression\"\"\"\n        time_range = kwargs[\"rison\"]\n        try:\n            since, until = get_since_until(time_range)\n            result = {\n                \"since\": since.isoformat() if since else \"\",\n                \"until\": until.isoformat() if until else \"\",\n                \"timeRange\": time_range,\n            }\n            return self.json_response({\"result\": result})\n        except (ValueError, TimeRangeParseFailError, TimeRangeAmbiguousError) as error:\n            error_msg = {\"message\": _(\"Unexpected time range: %s\" % error)}\n            return self.json_response(error_msg, 400)\n\n    def get_query_context_factory(self) -> QueryContextFactory:\n        if self.query_context_factory is None:\n            # pylint: disable=import-outside-toplevel\n            from superset.common.query_context_factory import QueryContextFactory\n\n            self.query_context_factory = QueryContextFactory()\n        return self.query_context_factory\n", "code_before": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\nfrom __future__ import annotations\n\nfrom typing import Any, TYPE_CHECKING\n\nimport simplejson as json\nfrom flask import request\nfrom flask_appbuilder import expose\nfrom flask_appbuilder.api import rison\nfrom flask_appbuilder.security.decorators import has_access_api\nfrom flask_babel import lazy_gettext as _\n\nfrom superset import db, event_logger\nfrom superset.charts.commands.exceptions import (\n    TimeRangeAmbiguousError,\n    TimeRangeParseFailError,\n)\nfrom superset.legacy import update_time_range\nfrom superset.models.slice import Slice\nfrom superset.superset_typing import FlaskResponse\nfrom superset.utils import core as utils\nfrom superset.utils.date_parser import get_since_until\nfrom superset.views.base import api, BaseSupersetView, handle_api_exception\n\nif TYPE_CHECKING:\n    from superset.common.query_context_factory import QueryContextFactory\n\nget_time_range_schema = {\"type\": \"string\"}\n\n\nclass Api(BaseSupersetView):\n    query_context_factory = None\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/query/\", methods=[\"POST\"])\n    def query(self) -> FlaskResponse:\n        \"\"\"\n        Takes a query_obj constructed in the client and returns payload data response\n        for the given query_obj.\n\n        raises SupersetSecurityException: If the user cannot access the resource\n        \"\"\"\n        query_context = self.get_query_context_factory().create(\n            **json.loads(request.form[\"query_context\"])\n        )\n        query_context.raise_for_access()\n        result = query_context.get_payload()\n        payload_json = result[\"queries\"]\n        return json.dumps(\n            payload_json, default=utils.json_int_dttm_ser, ignore_nan=True\n        )\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/form_data/\", methods=[\"GET\"])\n    def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n        \"\"\"\n        Get the formdata stored in the database for existing slice.\n        params: slice_id: integer\n        \"\"\"\n        form_data = {}\n        slice_id = request.args.get(\"slice_id\")\n        if slice_id:\n            slc = db.session.query(Slice).filter_by(id=slice_id).one_or_none()\n            if slc:\n                form_data = slc.form_data.copy()\n\n        update_time_range(form_data)\n\n        return json.dumps(form_data)\n\n    @api\n    @handle_api_exception\n    @has_access_api\n    @rison(get_time_range_schema)\n    @expose(\"/v1/time_range/\", methods=[\"GET\"])\n    def time_range(self, **kwargs: Any) -> FlaskResponse:\n        \"\"\"Get actually time range from human readable string or datetime expression\"\"\"\n        time_range = kwargs[\"rison\"]\n        try:\n            since, until = get_since_until(time_range)\n            result = {\n                \"since\": since.isoformat() if since else \"\",\n                \"until\": until.isoformat() if until else \"\",\n                \"timeRange\": time_range,\n            }\n            return self.json_response({\"result\": result})\n        except (ValueError, TimeRangeParseFailError, TimeRangeAmbiguousError) as error:\n            error_msg = {\"message\": _(\"Unexpected time range: %s\" % error)}\n            return self.json_response(error_msg, 400)\n\n    def get_query_context_factory(self) -> QueryContextFactory:\n        if self.query_context_factory is None:\n            # pylint: disable=import-outside-toplevel\n            from superset.common.query_context_factory import QueryContextFactory\n\n            self.query_context_factory = QueryContextFactory()\n        return self.query_context_factory\n", "patch": "@@ -87,7 +87,7 @@ def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n \n         update_time_range(form_data)\n \n-        return json.dumps(form_data)\n+        return self.json_response(form_data)\n \n     @api\n     @handle_api_exception", "file_path": "files/2023_11/74", "file_language": "py", "file_name": "superset/views/api.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class Api(BaseSupersetView):\n    query_context_factory = None\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/query/\", methods=[\"POST\"])\n    def query(self) -> FlaskResponse:\n        \"\"\"\n        Takes a query_obj constructed in the client and returns payload data response\n        for the given query_obj.\n\n        raises SupersetSecurityException: If the user cannot access the resource\n        \"\"\"\n        query_context = self.get_query_context_factory().create(\n            **json.loads(request.form[\"query_context\"])\n        )\n        query_context.raise_for_access()\n        result = query_context.get_payload()\n        payload_json = result[\"queries\"]\n        return json.dumps(\n            payload_json, default=utils.json_int_dttm_ser, ignore_nan=True\n        )\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/form_data/\", methods=[\"GET\"])\n    def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n        \"\"\"\n        Get the formdata stored in the database for existing slice.\n        params: slice_id: integer\n        \"\"\"\n        form_data = {}\n        slice_id = request.args.get(\"slice_id\")\n        if slice_id:\n            slc = db.session.query(Slice).filter_by(id=slice_id).one_or_none()\n            if slc:\n                form_data = slc.form_data.copy()\n\n        update_time_range(form_data)\n\n        return json.dumps(form_data)\n\n    @api\n    @handle_api_exception\n    @has_access_api\n    @rison(get_time_range_schema)\n    @expose(\"/v1/time_range/\", methods=[\"GET\"])\n    def time_range(self, **kwargs: Any) -> FlaskResponse:\n        \"\"\"Get actually time range from human readable string or datetime expression\"\"\"\n        time_range = kwargs[\"rison\"]\n        try:\n            since, until = get_since_until(time_range)\n            result = {\n                \"since\": since.isoformat() if since else \"\",\n                \"until\": until.isoformat() if until else \"\",\n                \"timeRange\": time_range,\n            }\n            return self.json_response({\"result\": result})\n        except (ValueError, TimeRangeParseFailError, TimeRangeAmbiguousError) as error:\n            error_msg = {\"message\": _(\"Unexpected time range: %s\" % error)}\n            return self.json_response(error_msg, 400)\n\n    def get_query_context_factory(self) -> QueryContextFactory:\n        if self.query_context_factory is None:\n            # pylint: disable=import-outside-toplevel\n            from superset.common.query_context_factory import QueryContextFactory\n\n            self.query_context_factory = QueryContextFactory()\n        return self.query_context_factory", "target": 0}], "function_after": [{"function": "class Api(BaseSupersetView):\n    query_context_factory = None\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/query/\", methods=[\"POST\"])\n    def query(self) -> FlaskResponse:\n        \"\"\"\n        Takes a query_obj constructed in the client and returns payload data response\n        for the given query_obj.\n\n        raises SupersetSecurityException: If the user cannot access the resource\n        \"\"\"\n        query_context = self.get_query_context_factory().create(\n            **json.loads(request.form[\"query_context\"])\n        )\n        query_context.raise_for_access()\n        result = query_context.get_payload()\n        payload_json = result[\"queries\"]\n        return json.dumps(\n            payload_json, default=utils.json_int_dttm_ser, ignore_nan=True\n        )\n\n    @event_logger.log_this\n    @api\n    @handle_api_exception\n    @has_access_api\n    @expose(\"/v1/form_data/\", methods=[\"GET\"])\n    def query_form_data(self) -> FlaskResponse:  # pylint: disable=no-self-use\n        \"\"\"\n        Get the formdata stored in the database for existing slice.\n        params: slice_id: integer\n        \"\"\"\n        form_data = {}\n        slice_id = request.args.get(\"slice_id\")\n        if slice_id:\n            slc = db.session.query(Slice).filter_by(id=slice_id).one_or_none()\n            if slc:\n                form_data = slc.form_data.copy()\n\n        update_time_range(form_data)\n\n        return self.json_response(form_data)\n\n    @api\n    @handle_api_exception\n    @has_access_api\n    @rison(get_time_range_schema)\n    @expose(\"/v1/time_range/\", methods=[\"GET\"])\n    def time_range(self, **kwargs: Any) -> FlaskResponse:\n        \"\"\"Get actually time range from human readable string or datetime expression\"\"\"\n        time_range = kwargs[\"rison\"]\n        try:\n            since, until = get_since_until(time_range)\n            result = {\n                \"since\": since.isoformat() if since else \"\",\n                \"until\": until.isoformat() if until else \"\",\n                \"timeRange\": time_range,\n            }\n            return self.json_response({\"result\": result})\n        except (ValueError, TimeRangeParseFailError, TimeRangeAmbiguousError) as error:\n            error_msg = {\"message\": _(\"Unexpected time range: %s\" % error)}\n            return self.json_response(error_msg, 400)\n\n    def get_query_context_factory(self) -> QueryContextFactory:\n        if self.query_context_factory is None:\n            # pylint: disable=import-outside-toplevel\n            from superset.common.query_context_factory import QueryContextFactory\n\n            self.query_context_factory = QueryContextFactory()\n        return self.query_context_factory", "target": 0}]}, {"raw_url": "https://github.com/apache/superset/raw/d80f326d531f04bc871e55bf3ca2a33d7faff808/tests%2Fintegration_tests%2Fcharts%2Fapi_tests.py", "code": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# isort:skip_file\n\"\"\"Unit tests for Superset\"\"\"\nimport json\nimport logging\nfrom io import BytesIO\nfrom zipfile import is_zipfile, ZipFile\n\nimport prison\nimport pytest\nimport yaml\nfrom sqlalchemy import and_\nfrom sqlalchemy.sql import func\n\nfrom superset.connectors.sqla.models import SqlaTable\nfrom superset.extensions import cache_manager, db\nfrom superset.models.core import Database, FavStar, FavStarClassName\nfrom superset.models.dashboard import Dashboard\nfrom superset.reports.models import ReportSchedule, ReportScheduleType\nfrom superset.models.slice import Slice\nfrom superset.utils.core import get_example_default_schema\n\nfrom tests.integration_tests.base_api_tests import ApiOwnersTestCaseMixin\nfrom tests.integration_tests.base_tests import SupersetTestCase\nfrom tests.integration_tests.fixtures.birth_names_dashboard import (\n    load_birth_names_dashboard_with_slices,\n    load_birth_names_data,\n)\nfrom tests.integration_tests.fixtures.energy_dashboard import (\n    load_energy_table_with_slice,\n    load_energy_table_data,\n)\nfrom tests.integration_tests.fixtures.importexport import (\n    chart_config,\n    chart_metadata_config,\n    database_config,\n    dataset_config,\n    dataset_metadata_config,\n)\nfrom tests.integration_tests.fixtures.unicode_dashboard import (\n    load_unicode_dashboard_with_slice,\n    load_unicode_data,\n)\nfrom tests.integration_tests.fixtures.world_bank_dashboard import (\n    load_world_bank_dashboard_with_slices,\n    load_world_bank_data,\n)\nfrom tests.integration_tests.insert_chart_mixin import InsertChartMixin\nfrom tests.integration_tests.test_app import app\nfrom tests.integration_tests.utils.get_dashboards import get_dashboards_ids\n\nCHART_DATA_URI = \"api/v1/chart/data\"\nCHARTS_FIXTURE_COUNT = 10\n\n\nclass TestChartApi(SupersetTestCase, ApiOwnersTestCaseMixin, InsertChartMixin):\n    resource_name = \"chart\"\n\n    @pytest.fixture(autouse=True)\n    def clear_data_cache(self):\n        with app.app_context():\n            cache_manager.data_cache.clear()\n            yield\n\n    @pytest.fixture()\n    def create_charts(self):\n        with self.create_app().app_context():\n            charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"name{cx}\", [admin.id], 1))\n            fav_charts = []\n            for cx in range(round(CHARTS_FIXTURE_COUNT / 2)):\n                fav_star = FavStar(\n                    user_id=admin.id, class_name=\"slice\", obj_id=charts[cx].id\n                )\n                db.session.add(fav_star)\n                db.session.commit()\n                fav_charts.append(fav_star)\n            yield charts\n\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            for fav_chart in fav_charts:\n                db.session.delete(fav_chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_charts_created_by_gamma(self):\n        with self.create_app().app_context():\n            charts = []\n            user = self.get_user(\"gamma\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"gamma{cx}\", [user.id], 1))\n            yield charts\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_certified_charts(self):\n        with self.create_app().app_context():\n            certified_charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT):\n                certified_charts.append(\n                    self.insert_chart(\n                        f\"certified{cx}\",\n                        [admin.id],\n                        1,\n                        certified_by=\"John Doe\",\n                        certification_details=\"Sample certification\",\n                    )\n                )\n\n            yield certified_charts\n\n            # rollback changes\n            for chart in certified_charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_chart_with_report(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n            chart = self.insert_chart(f\"chart_report\", [admin.id], 1)\n            report_schedule = ReportSchedule(\n                type=ReportScheduleType.REPORT,\n                name=\"report_with_chart\",\n                crontab=\"* * * * *\",\n                chart=chart,\n            )\n            db.session.commit()\n\n            yield chart\n\n            # rollback changes\n            db.session.delete(report_schedule)\n            db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def add_dashboard_to_chart(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n\n            self.chart = self.insert_chart(\"My chart\", [admin.id], 1)\n\n            self.original_dashboard = Dashboard()\n            self.original_dashboard.dashboard_title = \"Original Dashboard\"\n            self.original_dashboard.slug = \"slug\"\n            self.original_dashboard.owners = [admin]\n            self.original_dashboard.slices = [self.chart]\n            self.original_dashboard.published = False\n            db.session.add(self.original_dashboard)\n\n            self.new_dashboard = Dashboard()\n            self.new_dashboard.dashboard_title = \"New Dashboard\"\n            self.new_dashboard.slug = \"new_slug\"\n            self.new_dashboard.owners = [admin]\n            self.new_dashboard.slices = []\n            self.new_dashboard.published = False\n            db.session.add(self.new_dashboard)\n\n            db.session.commit()\n\n            yield self.chart\n\n            db.session.delete(self.original_dashboard)\n            db.session.delete(self.new_dashboard)\n            db.session.delete(self.chart)\n            db.session.commit()\n\n    def test_info_security_chart(self):\n        \"\"\"\n        Chart API: Test info security\n        \"\"\"\n        self.login(username=\"admin\")\n        params = {\"keys\": [\"permissions\"]}\n        uri = f\"api/v1/chart/_info?q={prison.dumps(params)}\"\n        rv = self.get_assert_metric(uri, \"info\")\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert set(data[\"permissions\"]) == {\"can_read\", \"can_write\", \"can_export\"}\n\n    def create_chart_import(self):\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n        return buf\n\n    def test_delete_chart(self):\n        \"\"\"\n        Chart API: Test delete\n        \"\"\"\n        admin_id = self.get_user(\"admin\").id\n        chart_id = self.insert_chart(\"name\", [admin_id], 1).id\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_charts(self):\n        \"\"\"\n        Chart API: Test delete bulk\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [admin.id], 1, admin).id\n            )\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 200)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_bad_request(self):\n        \"\"\"\n        Chart API: Test delete bulk bad request\n        \"\"\"\n        chart_ids = [1, \"a\"]\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_delete_not_found_chart(self):\n        \"\"\"\n        Chart API: Test not found delete\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_id = 1000\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\")\n    def test_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart = (\n            db.session.query(Slice)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_bulk_charts_not_found(self):\n        \"\"\"\n        Chart API: Test delete bulk not found\n        \"\"\"\n        max_id = db.session.query(func.max(Slice.id)).scalar()\n        chart_ids = [max_id + 1, max_id + 2]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\", \"create_charts\")\n    def test_bulk_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test bulk delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_with_report = (\n            db.session.query(Slice.id)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n\n        charts = db.session.query(Slice.id).filter(Slice.slice_name.like(\"name%\")).all()\n        chart_ids = [chart.id for chart in charts]\n        chart_ids.append(chart_with_report.id)\n\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_id = self.insert_chart(\"title\", [gamma_id], 1).id\n\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete bulk not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [gamma_id], 1).id\n            )\n\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n        self.login(username=\"alpha2\", password=\"password\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_delete_bulk_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete bulk try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n\n        chart_count = 4\n        charts = list()\n        for chart_name_index in range(chart_count):\n            charts.append(\n                self.insert_chart(f\"title{chart_name_index}\", [user_alpha1.id], 1)\n            )\n\n        owned_chart = self.insert_chart(\"title_owned\", [user_alpha2.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n\n        # verify we can't delete not owned charts\n        arguments = [chart.id for chart in charts]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        # # nothing is deleted in bulk with a list of owned and not owned charts\n        arguments = [chart.id for chart in charts] + [owned_chart.id]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        for chart in charts:\n            db.session.delete(chart)\n        db.session.delete(owned_chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_create_chart(self):\n        \"\"\"\n        Chart API: Test create chart\n        \"\"\"\n        dashboards_ids = get_dashboards_ids(db, [\"world_health\", \"births\"])\n        admin_id = self.get_user(\"admin\").id\n        chart_data = {\n            \"slice_name\": \"name1\",\n            \"description\": \"description1\",\n            \"owners\": [admin_id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"1234\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"dashboards\": dashboards_ids,\n            \"certified_by\": \"John Doe\",\n            \"certification_details\": \"Sample certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_simple_chart(self):\n        \"\"\"\n        Chart API: Test create simple chart\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test create validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    def test_create_chart_validate_params(self):\n        \"\"\"\n        Chart API: Test create validate params json\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"params\": '{\"A:\"a\"}',\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_create_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test create validate datasource\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"unknown\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 0,\n            \"datasource_type\": \"table\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_update_chart(self):\n        \"\"\"\n        Chart API: Test update\n        \"\"\"\n        schema = get_example_default_schema()\n        full_table_name = f\"{schema}.birth_names\" if schema else \"birth_names\"\n\n        admin = self.get_user(\"admin\")\n        gamma = self.get_user(\"gamma\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\n            \"title\", [admin.id], birth_names_table_id, admin\n        ).id\n        dash_id = db.session.query(Dashboard.id).filter_by(slug=\"births\").first()[0]\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"description\": \"description1\",\n            \"owners\": [gamma.id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"\"\"{\"a\": 1}\"\"\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": birth_names_table_id,\n            \"datasource_type\": \"table\",\n            \"dashboards\": [dash_id],\n            \"certified_by\": \"Mario Rossi\",\n            \"certification_details\": \"Edited certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        related_dashboard = db.session.query(Dashboard).filter_by(slug=\"births\").first()\n        self.assertEqual(model.created_by, admin)\n        self.assertEqual(model.slice_name, \"title1_changed\")\n        self.assertEqual(model.description, \"description1\")\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        self.assertEqual(model.viz_type, \"viz_type1\")\n        self.assertEqual(model.params, \"\"\"{\"a\": 1}\"\"\")\n        self.assertEqual(model.cache_timeout, 1000)\n        self.assertEqual(model.datasource_id, birth_names_table_id)\n        self.assertEqual(model.datasource_type, \"table\")\n        self.assertEqual(model.datasource_name, full_table_name)\n        self.assertEqual(model.certified_by, \"Mario Rossi\")\n        self.assertEqual(model.certification_details, \"Edited certification\")\n        self.assertIn(model.id, [slice.id for slice in related_dashboard.slices])\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_disabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = False\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = False\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_enabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = True\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = True\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"/superset/profile/admin\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_list_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(\"api/v1/chart/\", \"get_list\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        current_chart = [d for d in res if d[\"id\"] == chart_id][0]\n        self.assertEqual(current_chart[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", current_chart[\"changed_by\"].keys())\n        self.assertNotIn(\"username\", current_chart[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(uri, \"get\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        self.assertEqual(res[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", res[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_not_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner implicitly adds logged in owner\n        \"\"\"\n        gamma = self.get_user(\"gamma_no_csv\")\n        alpha = self.get_user(\"alpha\")\n        chart_id = self.insert_chart(\"title\", [gamma.id], 1).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [alpha.id],\n        }\n        self.login(username=gamma.username)\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        assert rv.status_code == 200\n        model = db.session.query(Slice).get(chart_id)\n        assert model.slice_name == new_name\n        assert alpha in model.owners\n        assert gamma in model.owners\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner as admin to other than current user\n        \"\"\"\n        gamma = self.get_user(\"gamma\")\n        admin = self.get_user(\"admin\")\n        chart_id = self.insert_chart(\"title\", [admin.id], 1).id\n        chart_data = {\"slice_name\": \"title1_changed\", \"owners\": [gamma.id]}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_update_chart_new_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [self.new_dashboard.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.new_dashboard, self.chart.dashboards)\n        self.assertNotIn(self.original_dashboard, self.chart.dashboards)\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_not_update_chart_none_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\"slice_name\": \"title1_changed_again\"}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.original_dashboard, self.chart.dashboards)\n        self.assertEqual(len(self.chart.dashboards), 1)\n\n    def test_update_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test update not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n        chart_data = {\"slice_name\": \"title1_changed\"}\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_linked_with_not_owned_dashboard(self):\n        \"\"\"\n        Chart API: Test update chart which is linked to not owned dashboard\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        original_dashboard = Dashboard()\n        original_dashboard.dashboard_title = \"Original Dashboard\"\n        original_dashboard.slug = \"slug\"\n        original_dashboard.owners = [user_alpha1]\n        original_dashboard.slices = [chart]\n        original_dashboard.published = False\n        db.session.add(original_dashboard)\n\n        new_dashboard = Dashboard()\n        new_dashboard.dashboard_title = \"Cloned Dashboard\"\n        new_dashboard.slug = \"new_slug\"\n        new_dashboard.owners = [user_alpha2]\n        new_dashboard.slices = [chart]\n        new_dashboard.published = False\n        db.session.add(new_dashboard)\n\n        self.login(username=\"alpha1\", password=\"password\")\n        chart_data_with_invalid_dashboard = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, 0],\n        }\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, new_dashboard.id],\n        }\n        uri = f\"api/v1/chart/{chart.id}\"\n\n        rv = self.put_assert_metric(uri, chart_data_with_invalid_dashboard, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"dashboards\": [\"Dashboards do not exist\"]}}\n        self.assertEqual(response, expected_response)\n\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n\n        db.session.delete(chart)\n        db.session.delete(original_dashboard)\n        db.session.delete(new_dashboard)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test update validate datasource\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", owners=[admin.id], datasource_id=1)\n        self.login(username=\"admin\")\n\n        chart_data = {\"datasource_id\": 1, \"datasource_type\": \"unknown\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n\n        chart_data = {\"datasource_id\": 0, \"datasource_type\": \"table\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_update_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test update validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.client.post(uri, json=chart_data)\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    @pytest.mark.usefixtures(\"load_world_bank_dashboard_with_slices\")\n    def test_get_chart(self):\n        \"\"\"\n        Chart API: Test get chart\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", [admin.id], 1)\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 200)\n        expected_result = {\n            \"cache_timeout\": None,\n            \"certified_by\": None,\n            \"certification_details\": None,\n            \"dashboards\": [],\n            \"description\": None,\n            \"owners\": [\n                {\n                    \"id\": 1,\n                    \"first_name\": \"admin\",\n                    \"last_name\": \"user\",\n                }\n            ],\n            \"params\": None,\n            \"slice_name\": \"title\",\n            \"viz_type\": None,\n            \"query_context\": None,\n            \"is_managed_externally\": False,\n        }\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertIn(\"changed_on_delta_humanized\", data[\"result\"])\n        self.assertIn(\"id\", data[\"result\"])\n        self.assertIn(\"thumbnail_url\", data[\"result\"])\n        self.assertIn(\"url\", data[\"result\"])\n        for key, value in data[\"result\"].items():\n            # We can't assert timestamp values or id/urls\n            if key not in (\n                \"changed_on_delta_humanized\",\n                \"id\",\n                \"thumbnail_url\",\n                \"url\",\n            ):\n                self.assertEqual(value, expected_result[key])\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_get_chart_not_found(self):\n        \"\"\"\n        Chart API: Test get chart not found\n        \"\"\"\n        chart_id = 1000\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_get_chart_no_data_access(self):\n        \"\"\"\n        Chart API: Test get chart without data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        chart_no_access = (\n            db.session.query(Slice)\n            .filter_by(slice_name=\"Girl Name Cloud\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart_no_access.id}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\n        \"load_energy_table_with_slice\",\n        \"load_birth_names_dashboard_with_slices\",\n        \"load_unicode_dashboard_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n    )\n    def test_get_charts(self):\n        \"\"\"\n        Chart API: Test get charts\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 34)\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboards(self):\n        \"\"\"\n        Chart API: Test get charts with related dashboards\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\"col\": \"slice_name\", \"opr\": \"eq\", \"value\": self.chart.slice_name}\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"dashboards\"] == [\n            {\n                \"id\": self.original_dashboard.id,\n                \"dashboard_title\": self.original_dashboard.dashboard_title,\n            }\n        ]\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboard_filter(self):\n        \"\"\"\n        Chart API: Test get charts with dashboard filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"dashboards\",\n                    \"opr\": \"rel_m_m\",\n                    \"value\": self.original_dashboard.id,\n                }\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        result = data[\"result\"]\n        assert len(result) == 1\n        assert result[0][\"slice_name\"] == self.chart.slice_name\n\n    def test_get_charts_changed_on(self):\n        \"\"\"\n        Dashboard API: Test get charts changed on\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"foo_a\", [admin.id], 1, description=\"ZY_bar\")\n\n        self.login(username=\"admin\")\n\n        arguments = {\n            \"order_column\": \"changed_on_delta_humanized\",\n            \"order_direction\": \"desc\",\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"changed_on_delta_humanized\"] in (\n            \"now\",\n            \"a second ago\",\n        )\n\n        # rollback changes\n        db.session.delete(chart)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_filter(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\"filters\": [{\"col\": \"slice_name\", \"opr\": \"sw\", \"value\": \"G\"}]}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 5)\n\n    @pytest.fixture()\n    def load_energy_charts(self):\n        with app.app_context():\n            admin = self.get_user(\"admin\")\n            energy_table = (\n                db.session.query(SqlaTable)\n                .filter_by(table_name=\"energy_usage\")\n                .one_or_none()\n            )\n            energy_table_id = 1\n            if energy_table:\n                energy_table_id = energy_table.id\n            chart1 = self.insert_chart(\n                \"foo_a\", [admin.id], energy_table_id, description=\"ZY_bar\"\n            )\n            chart2 = self.insert_chart(\n                \"zy_foo\", [admin.id], energy_table_id, description=\"desc1\"\n            )\n            chart3 = self.insert_chart(\n                \"foo_b\", [admin.id], energy_table_id, description=\"desc1zy_\"\n            )\n            chart4 = self.insert_chart(\n                \"foo_c\", [admin.id], energy_table_id, viz_type=\"viz_zy_\"\n            )\n            chart5 = self.insert_chart(\n                \"bar\", [admin.id], energy_table_id, description=\"foo\"\n            )\n\n            yield\n            # rollback changes\n            db.session.delete(chart1)\n            db.session.delete(chart2)\n            db.session.delete(chart3)\n            db.session.delete(chart4)\n            db.session.delete(chart5)\n            db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_get_charts_custom_filter(self):\n        \"\"\"\n        Chart API: Test get charts custom filter\n        \"\"\"\n\n        arguments = {\n            \"filters\": [{\"col\": \"slice_name\", \"opr\": \"chart_all_text\", \"value\": \"zy_\"}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"viz_type\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 4)\n\n        expected_response = [\n            {\"description\": \"ZY_bar\", \"slice_name\": \"foo_a\", \"viz_type\": None},\n            {\"description\": \"desc1zy_\", \"slice_name\": \"foo_b\", \"viz_type\": None},\n            {\"description\": None, \"slice_name\": \"foo_c\", \"viz_type\": \"viz_zy_\"},\n            {\"description\": \"desc1\", \"slice_name\": \"zy_foo\", \"viz_type\": None},\n        ]\n        for index, item in enumerate(data[\"result\"]):\n            self.assertEqual(\n                item[\"description\"], expected_response[index][\"description\"]\n            )\n            self.assertEqual(item[\"slice_name\"], expected_response[index][\"slice_name\"])\n            self.assertEqual(item[\"viz_type\"], expected_response[index][\"viz_type\"])\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"load_energy_charts\")\n    def test_admin_gets_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"table.table_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        data = rv.json\n        assert rv.status_code == 200\n        assert data[\"count\"] > 0\n        for chart in data[\"result\"]:\n            print(chart)\n            assert (\n                \"energy\"\n                in \" \".join(\n                    [\n                        chart[\"slice_name\"] or \"\",\n                        chart[\"description\"] or \"\",\n                        chart[\"table\"][\"table_name\"] or \"\",\n                    ]\n                ).lower()\n            )\n\n    @pytest.mark.usefixtures(\"create_certified_charts\")\n    def test_gets_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": True,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], CHARTS_FIXTURE_COUNT)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_gets_not_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": False,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 17)\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_user_gets_none_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_charts_favorite_filter(self):\n        \"\"\"\n        Chart API: Test get charts favorite filter\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_query = db.session.query(FavStar.obj_id).filter(\n            and_(FavStar.user_id == admin.id, FavStar.class_name == \"slice\")\n        )\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_is_favorite\", \"value\": True}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n        # Test not favorite charts\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(~Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n        arguments[\"filters\"][0][\"value\"] = False\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n    @pytest.mark.usefixtures(\"create_charts_created_by_gamma\")\n    def test_get_charts_created_by_me_filter(self):\n        \"\"\"\n        Chart API: Test get charts with created by me special filter\n        \"\"\"\n        gamma_user = self.get_user(\"gamma\")\n        expected_models = (\n            db.session.query(Slice).filter(Slice.created_by_fk == gamma_user.id).all()\n        )\n        arguments = {\n            \"filters\": [\n                {\"col\": \"created_by\", \"opr\": \"chart_created_by_me\", \"value\": \"me\"}\n            ],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_current_user_favorite_status(self):\n        \"\"\"\n        Dataset API: Test get current user favorite stars\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_ids = [\n            star.obj_id\n            for star in db.session.query(FavStar.obj_id)\n            .filter(\n                and_(\n                    FavStar.user_id == admin.id,\n                    FavStar.class_name == FavStarClassName.CHART,\n                )\n            )\n            .all()\n        ]\n\n        assert users_favorite_ids\n        arguments = [s.id for s in db.session.query(Slice.id).all()]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/favorite_status/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        for res in data[\"result\"]:\n            if res[\"id\"] in users_favorite_ids:\n                assert res[\"value\"]\n\n    def test_get_time_range(self):\n        \"\"\"\n        Chart API: Test get actually time range from human readable string\n        \"\"\"\n        self.login(username=\"admin\")\n        humanize_time_range = \"100 years ago : now\"\n        uri = f\"api/v1/time_range/?q={prison.dumps(humanize_time_range)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(len(data[\"result\"]), 3)\n\n    def test_query_form_data(self):\n        \"\"\"\n        Chart API: Test query form data\n        \"\"\"\n        self.login(username=\"admin\")\n        slice = db.session.query(Slice).first()\n        uri = f\"api/v1/form_data/?slice_id={slice.id if slice else None}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(rv.content_type, \"application/json\")\n        if slice:\n            self.assertEqual(data[\"slice_id\"], slice.id)\n\n    @pytest.mark.usefixtures(\n        \"load_unicode_dashboard_with_slice\",\n        \"load_energy_table_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_page(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        # Assuming we have 34 sample charts\n        self.login(username=\"admin\")\n        arguments = {\"page_size\": 10, \"page\": 0}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 10)\n\n        arguments = {\"page_size\": 10, \"page\": 3}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 4)\n\n    def test_get_charts_no_data_access(self):\n        \"\"\"\n        Chart API: Test get charts no data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        uri = \"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    def test_export_chart(self):\n        \"\"\"\n        Chart API: Test export chart\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 200\n\n        buf = BytesIO(rv.data)\n        assert is_zipfile(buf)\n\n    def test_export_chart_not_found(self):\n        \"\"\"\n        Chart API: Test export chart not found\n        \"\"\"\n        # Just one does not exist and we get 404\n        argument = [-1, 1]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 404\n\n    def test_export_chart_gamma(self):\n        \"\"\"\n        Chart API: Test export chart has gamma\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"gamma\")\n        rv = self.client.get(uri)\n\n        assert rv.status_code == 404\n\n    def test_import_chart(self):\n        \"\"\"\n        Chart API: Test import chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        assert database.database_name == \"imported_database\"\n\n        assert len(database.tables) == 1\n        dataset = database.tables[0]\n        assert dataset.table_name == \"imported_dataset\"\n        assert str(dataset.uuid) == dataset_config[\"uuid\"]\n\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n        assert chart.table == dataset\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_overwrite(self):\n        \"\"\"\n        Chart API: Test import existing chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # import again without overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"charts/imported_chart.yaml\": \"Chart already exists and `overwrite=true` was not passed\",\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": \"Issue 1010 - Superset encountered an error while running a command.\",\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n        # import with overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n            \"overwrite\": \"true\",\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # clean up\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        dataset = database.tables[0]\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_invalid(self):\n        \"\"\"\n        Chart API: Test import invalid chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"metadata.yaml\": {\"type\": [\"Must be equal to Slice.\"]},\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": (\n                                    \"Issue 1010 - Superset encountered an \"\n                                    \"error while running a command.\"\n                                ),\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n    def test_gets_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": True}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n\n    def test_gets_not_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": False}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n", "code_before": "# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n# isort:skip_file\n\"\"\"Unit tests for Superset\"\"\"\nimport json\nimport logging\nfrom io import BytesIO\nfrom zipfile import is_zipfile, ZipFile\n\nimport prison\nimport pytest\nimport yaml\nfrom sqlalchemy import and_\nfrom sqlalchemy.sql import func\n\nfrom superset.connectors.sqla.models import SqlaTable\nfrom superset.extensions import cache_manager, db\nfrom superset.models.core import Database, FavStar, FavStarClassName\nfrom superset.models.dashboard import Dashboard\nfrom superset.reports.models import ReportSchedule, ReportScheduleType\nfrom superset.models.slice import Slice\nfrom superset.utils.core import get_example_default_schema\n\nfrom tests.integration_tests.base_api_tests import ApiOwnersTestCaseMixin\nfrom tests.integration_tests.base_tests import SupersetTestCase\nfrom tests.integration_tests.fixtures.birth_names_dashboard import (\n    load_birth_names_dashboard_with_slices,\n    load_birth_names_data,\n)\nfrom tests.integration_tests.fixtures.energy_dashboard import (\n    load_energy_table_with_slice,\n    load_energy_table_data,\n)\nfrom tests.integration_tests.fixtures.importexport import (\n    chart_config,\n    chart_metadata_config,\n    database_config,\n    dataset_config,\n    dataset_metadata_config,\n)\nfrom tests.integration_tests.fixtures.unicode_dashboard import (\n    load_unicode_dashboard_with_slice,\n    load_unicode_data,\n)\nfrom tests.integration_tests.fixtures.world_bank_dashboard import (\n    load_world_bank_dashboard_with_slices,\n    load_world_bank_data,\n)\nfrom tests.integration_tests.insert_chart_mixin import InsertChartMixin\nfrom tests.integration_tests.test_app import app\nfrom tests.integration_tests.utils.get_dashboards import get_dashboards_ids\n\nCHART_DATA_URI = \"api/v1/chart/data\"\nCHARTS_FIXTURE_COUNT = 10\n\n\nclass TestChartApi(SupersetTestCase, ApiOwnersTestCaseMixin, InsertChartMixin):\n    resource_name = \"chart\"\n\n    @pytest.fixture(autouse=True)\n    def clear_data_cache(self):\n        with app.app_context():\n            cache_manager.data_cache.clear()\n            yield\n\n    @pytest.fixture()\n    def create_charts(self):\n        with self.create_app().app_context():\n            charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"name{cx}\", [admin.id], 1))\n            fav_charts = []\n            for cx in range(round(CHARTS_FIXTURE_COUNT / 2)):\n                fav_star = FavStar(\n                    user_id=admin.id, class_name=\"slice\", obj_id=charts[cx].id\n                )\n                db.session.add(fav_star)\n                db.session.commit()\n                fav_charts.append(fav_star)\n            yield charts\n\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            for fav_chart in fav_charts:\n                db.session.delete(fav_chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_charts_created_by_gamma(self):\n        with self.create_app().app_context():\n            charts = []\n            user = self.get_user(\"gamma\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"gamma{cx}\", [user.id], 1))\n            yield charts\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_certified_charts(self):\n        with self.create_app().app_context():\n            certified_charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT):\n                certified_charts.append(\n                    self.insert_chart(\n                        f\"certified{cx}\",\n                        [admin.id],\n                        1,\n                        certified_by=\"John Doe\",\n                        certification_details=\"Sample certification\",\n                    )\n                )\n\n            yield certified_charts\n\n            # rollback changes\n            for chart in certified_charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_chart_with_report(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n            chart = self.insert_chart(f\"chart_report\", [admin.id], 1)\n            report_schedule = ReportSchedule(\n                type=ReportScheduleType.REPORT,\n                name=\"report_with_chart\",\n                crontab=\"* * * * *\",\n                chart=chart,\n            )\n            db.session.commit()\n\n            yield chart\n\n            # rollback changes\n            db.session.delete(report_schedule)\n            db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def add_dashboard_to_chart(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n\n            self.chart = self.insert_chart(\"My chart\", [admin.id], 1)\n\n            self.original_dashboard = Dashboard()\n            self.original_dashboard.dashboard_title = \"Original Dashboard\"\n            self.original_dashboard.slug = \"slug\"\n            self.original_dashboard.owners = [admin]\n            self.original_dashboard.slices = [self.chart]\n            self.original_dashboard.published = False\n            db.session.add(self.original_dashboard)\n\n            self.new_dashboard = Dashboard()\n            self.new_dashboard.dashboard_title = \"New Dashboard\"\n            self.new_dashboard.slug = \"new_slug\"\n            self.new_dashboard.owners = [admin]\n            self.new_dashboard.slices = []\n            self.new_dashboard.published = False\n            db.session.add(self.new_dashboard)\n\n            db.session.commit()\n\n            yield self.chart\n\n            db.session.delete(self.original_dashboard)\n            db.session.delete(self.new_dashboard)\n            db.session.delete(self.chart)\n            db.session.commit()\n\n    def test_info_security_chart(self):\n        \"\"\"\n        Chart API: Test info security\n        \"\"\"\n        self.login(username=\"admin\")\n        params = {\"keys\": [\"permissions\"]}\n        uri = f\"api/v1/chart/_info?q={prison.dumps(params)}\"\n        rv = self.get_assert_metric(uri, \"info\")\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert set(data[\"permissions\"]) == {\"can_read\", \"can_write\", \"can_export\"}\n\n    def create_chart_import(self):\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n        return buf\n\n    def test_delete_chart(self):\n        \"\"\"\n        Chart API: Test delete\n        \"\"\"\n        admin_id = self.get_user(\"admin\").id\n        chart_id = self.insert_chart(\"name\", [admin_id], 1).id\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_charts(self):\n        \"\"\"\n        Chart API: Test delete bulk\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [admin.id], 1, admin).id\n            )\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 200)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_bad_request(self):\n        \"\"\"\n        Chart API: Test delete bulk bad request\n        \"\"\"\n        chart_ids = [1, \"a\"]\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_delete_not_found_chart(self):\n        \"\"\"\n        Chart API: Test not found delete\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_id = 1000\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\")\n    def test_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart = (\n            db.session.query(Slice)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_bulk_charts_not_found(self):\n        \"\"\"\n        Chart API: Test delete bulk not found\n        \"\"\"\n        max_id = db.session.query(func.max(Slice.id)).scalar()\n        chart_ids = [max_id + 1, max_id + 2]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\", \"create_charts\")\n    def test_bulk_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test bulk delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_with_report = (\n            db.session.query(Slice.id)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n\n        charts = db.session.query(Slice.id).filter(Slice.slice_name.like(\"name%\")).all()\n        chart_ids = [chart.id for chart in charts]\n        chart_ids.append(chart_with_report.id)\n\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_id = self.insert_chart(\"title\", [gamma_id], 1).id\n\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete bulk not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [gamma_id], 1).id\n            )\n\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n        self.login(username=\"alpha2\", password=\"password\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_delete_bulk_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete bulk try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n\n        chart_count = 4\n        charts = list()\n        for chart_name_index in range(chart_count):\n            charts.append(\n                self.insert_chart(f\"title{chart_name_index}\", [user_alpha1.id], 1)\n            )\n\n        owned_chart = self.insert_chart(\"title_owned\", [user_alpha2.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n\n        # verify we can't delete not owned charts\n        arguments = [chart.id for chart in charts]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        # # nothing is deleted in bulk with a list of owned and not owned charts\n        arguments = [chart.id for chart in charts] + [owned_chart.id]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        for chart in charts:\n            db.session.delete(chart)\n        db.session.delete(owned_chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_create_chart(self):\n        \"\"\"\n        Chart API: Test create chart\n        \"\"\"\n        dashboards_ids = get_dashboards_ids(db, [\"world_health\", \"births\"])\n        admin_id = self.get_user(\"admin\").id\n        chart_data = {\n            \"slice_name\": \"name1\",\n            \"description\": \"description1\",\n            \"owners\": [admin_id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"1234\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"dashboards\": dashboards_ids,\n            \"certified_by\": \"John Doe\",\n            \"certification_details\": \"Sample certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_simple_chart(self):\n        \"\"\"\n        Chart API: Test create simple chart\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test create validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    def test_create_chart_validate_params(self):\n        \"\"\"\n        Chart API: Test create validate params json\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"params\": '{\"A:\"a\"}',\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_create_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test create validate datasource\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"unknown\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 0,\n            \"datasource_type\": \"table\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_update_chart(self):\n        \"\"\"\n        Chart API: Test update\n        \"\"\"\n        schema = get_example_default_schema()\n        full_table_name = f\"{schema}.birth_names\" if schema else \"birth_names\"\n\n        admin = self.get_user(\"admin\")\n        gamma = self.get_user(\"gamma\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\n            \"title\", [admin.id], birth_names_table_id, admin\n        ).id\n        dash_id = db.session.query(Dashboard.id).filter_by(slug=\"births\").first()[0]\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"description\": \"description1\",\n            \"owners\": [gamma.id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"\"\"{\"a\": 1}\"\"\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": birth_names_table_id,\n            \"datasource_type\": \"table\",\n            \"dashboards\": [dash_id],\n            \"certified_by\": \"Mario Rossi\",\n            \"certification_details\": \"Edited certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        related_dashboard = db.session.query(Dashboard).filter_by(slug=\"births\").first()\n        self.assertEqual(model.created_by, admin)\n        self.assertEqual(model.slice_name, \"title1_changed\")\n        self.assertEqual(model.description, \"description1\")\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        self.assertEqual(model.viz_type, \"viz_type1\")\n        self.assertEqual(model.params, \"\"\"{\"a\": 1}\"\"\")\n        self.assertEqual(model.cache_timeout, 1000)\n        self.assertEqual(model.datasource_id, birth_names_table_id)\n        self.assertEqual(model.datasource_type, \"table\")\n        self.assertEqual(model.datasource_name, full_table_name)\n        self.assertEqual(model.certified_by, \"Mario Rossi\")\n        self.assertEqual(model.certification_details, \"Edited certification\")\n        self.assertIn(model.id, [slice.id for slice in related_dashboard.slices])\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_disabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = False\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = False\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_enabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = True\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = True\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"/superset/profile/admin\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_list_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(\"api/v1/chart/\", \"get_list\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        current_chart = [d for d in res if d[\"id\"] == chart_id][0]\n        self.assertEqual(current_chart[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", current_chart[\"changed_by\"].keys())\n        self.assertNotIn(\"username\", current_chart[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(uri, \"get\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        self.assertEqual(res[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", res[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_not_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner implicitly adds logged in owner\n        \"\"\"\n        gamma = self.get_user(\"gamma_no_csv\")\n        alpha = self.get_user(\"alpha\")\n        chart_id = self.insert_chart(\"title\", [gamma.id], 1).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [alpha.id],\n        }\n        self.login(username=gamma.username)\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        assert rv.status_code == 200\n        model = db.session.query(Slice).get(chart_id)\n        assert model.slice_name == new_name\n        assert alpha in model.owners\n        assert gamma in model.owners\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner as admin to other than current user\n        \"\"\"\n        gamma = self.get_user(\"gamma\")\n        admin = self.get_user(\"admin\")\n        chart_id = self.insert_chart(\"title\", [admin.id], 1).id\n        chart_data = {\"slice_name\": \"title1_changed\", \"owners\": [gamma.id]}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_update_chart_new_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [self.new_dashboard.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.new_dashboard, self.chart.dashboards)\n        self.assertNotIn(self.original_dashboard, self.chart.dashboards)\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_not_update_chart_none_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\"slice_name\": \"title1_changed_again\"}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.original_dashboard, self.chart.dashboards)\n        self.assertEqual(len(self.chart.dashboards), 1)\n\n    def test_update_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test update not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n        chart_data = {\"slice_name\": \"title1_changed\"}\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_linked_with_not_owned_dashboard(self):\n        \"\"\"\n        Chart API: Test update chart which is linked to not owned dashboard\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        original_dashboard = Dashboard()\n        original_dashboard.dashboard_title = \"Original Dashboard\"\n        original_dashboard.slug = \"slug\"\n        original_dashboard.owners = [user_alpha1]\n        original_dashboard.slices = [chart]\n        original_dashboard.published = False\n        db.session.add(original_dashboard)\n\n        new_dashboard = Dashboard()\n        new_dashboard.dashboard_title = \"Cloned Dashboard\"\n        new_dashboard.slug = \"new_slug\"\n        new_dashboard.owners = [user_alpha2]\n        new_dashboard.slices = [chart]\n        new_dashboard.published = False\n        db.session.add(new_dashboard)\n\n        self.login(username=\"alpha1\", password=\"password\")\n        chart_data_with_invalid_dashboard = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, 0],\n        }\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, new_dashboard.id],\n        }\n        uri = f\"api/v1/chart/{chart.id}\"\n\n        rv = self.put_assert_metric(uri, chart_data_with_invalid_dashboard, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"dashboards\": [\"Dashboards do not exist\"]}}\n        self.assertEqual(response, expected_response)\n\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n\n        db.session.delete(chart)\n        db.session.delete(original_dashboard)\n        db.session.delete(new_dashboard)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test update validate datasource\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", owners=[admin.id], datasource_id=1)\n        self.login(username=\"admin\")\n\n        chart_data = {\"datasource_id\": 1, \"datasource_type\": \"unknown\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n\n        chart_data = {\"datasource_id\": 0, \"datasource_type\": \"table\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_update_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test update validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.client.post(uri, json=chart_data)\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    @pytest.mark.usefixtures(\"load_world_bank_dashboard_with_slices\")\n    def test_get_chart(self):\n        \"\"\"\n        Chart API: Test get chart\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", [admin.id], 1)\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 200)\n        expected_result = {\n            \"cache_timeout\": None,\n            \"certified_by\": None,\n            \"certification_details\": None,\n            \"dashboards\": [],\n            \"description\": None,\n            \"owners\": [\n                {\n                    \"id\": 1,\n                    \"first_name\": \"admin\",\n                    \"last_name\": \"user\",\n                }\n            ],\n            \"params\": None,\n            \"slice_name\": \"title\",\n            \"viz_type\": None,\n            \"query_context\": None,\n            \"is_managed_externally\": False,\n        }\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertIn(\"changed_on_delta_humanized\", data[\"result\"])\n        self.assertIn(\"id\", data[\"result\"])\n        self.assertIn(\"thumbnail_url\", data[\"result\"])\n        self.assertIn(\"url\", data[\"result\"])\n        for key, value in data[\"result\"].items():\n            # We can't assert timestamp values or id/urls\n            if key not in (\n                \"changed_on_delta_humanized\",\n                \"id\",\n                \"thumbnail_url\",\n                \"url\",\n            ):\n                self.assertEqual(value, expected_result[key])\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_get_chart_not_found(self):\n        \"\"\"\n        Chart API: Test get chart not found\n        \"\"\"\n        chart_id = 1000\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_get_chart_no_data_access(self):\n        \"\"\"\n        Chart API: Test get chart without data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        chart_no_access = (\n            db.session.query(Slice)\n            .filter_by(slice_name=\"Girl Name Cloud\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart_no_access.id}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\n        \"load_energy_table_with_slice\",\n        \"load_birth_names_dashboard_with_slices\",\n        \"load_unicode_dashboard_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n    )\n    def test_get_charts(self):\n        \"\"\"\n        Chart API: Test get charts\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 34)\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboards(self):\n        \"\"\"\n        Chart API: Test get charts with related dashboards\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\"col\": \"slice_name\", \"opr\": \"eq\", \"value\": self.chart.slice_name}\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"dashboards\"] == [\n            {\n                \"id\": self.original_dashboard.id,\n                \"dashboard_title\": self.original_dashboard.dashboard_title,\n            }\n        ]\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboard_filter(self):\n        \"\"\"\n        Chart API: Test get charts with dashboard filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"dashboards\",\n                    \"opr\": \"rel_m_m\",\n                    \"value\": self.original_dashboard.id,\n                }\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        result = data[\"result\"]\n        assert len(result) == 1\n        assert result[0][\"slice_name\"] == self.chart.slice_name\n\n    def test_get_charts_changed_on(self):\n        \"\"\"\n        Dashboard API: Test get charts changed on\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"foo_a\", [admin.id], 1, description=\"ZY_bar\")\n\n        self.login(username=\"admin\")\n\n        arguments = {\n            \"order_column\": \"changed_on_delta_humanized\",\n            \"order_direction\": \"desc\",\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"changed_on_delta_humanized\"] in (\n            \"now\",\n            \"a second ago\",\n        )\n\n        # rollback changes\n        db.session.delete(chart)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_filter(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\"filters\": [{\"col\": \"slice_name\", \"opr\": \"sw\", \"value\": \"G\"}]}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 5)\n\n    @pytest.fixture()\n    def load_energy_charts(self):\n        with app.app_context():\n            admin = self.get_user(\"admin\")\n            energy_table = (\n                db.session.query(SqlaTable)\n                .filter_by(table_name=\"energy_usage\")\n                .one_or_none()\n            )\n            energy_table_id = 1\n            if energy_table:\n                energy_table_id = energy_table.id\n            chart1 = self.insert_chart(\n                \"foo_a\", [admin.id], energy_table_id, description=\"ZY_bar\"\n            )\n            chart2 = self.insert_chart(\n                \"zy_foo\", [admin.id], energy_table_id, description=\"desc1\"\n            )\n            chart3 = self.insert_chart(\n                \"foo_b\", [admin.id], energy_table_id, description=\"desc1zy_\"\n            )\n            chart4 = self.insert_chart(\n                \"foo_c\", [admin.id], energy_table_id, viz_type=\"viz_zy_\"\n            )\n            chart5 = self.insert_chart(\n                \"bar\", [admin.id], energy_table_id, description=\"foo\"\n            )\n\n            yield\n            # rollback changes\n            db.session.delete(chart1)\n            db.session.delete(chart2)\n            db.session.delete(chart3)\n            db.session.delete(chart4)\n            db.session.delete(chart5)\n            db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_get_charts_custom_filter(self):\n        \"\"\"\n        Chart API: Test get charts custom filter\n        \"\"\"\n\n        arguments = {\n            \"filters\": [{\"col\": \"slice_name\", \"opr\": \"chart_all_text\", \"value\": \"zy_\"}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"viz_type\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 4)\n\n        expected_response = [\n            {\"description\": \"ZY_bar\", \"slice_name\": \"foo_a\", \"viz_type\": None},\n            {\"description\": \"desc1zy_\", \"slice_name\": \"foo_b\", \"viz_type\": None},\n            {\"description\": None, \"slice_name\": \"foo_c\", \"viz_type\": \"viz_zy_\"},\n            {\"description\": \"desc1\", \"slice_name\": \"zy_foo\", \"viz_type\": None},\n        ]\n        for index, item in enumerate(data[\"result\"]):\n            self.assertEqual(\n                item[\"description\"], expected_response[index][\"description\"]\n            )\n            self.assertEqual(item[\"slice_name\"], expected_response[index][\"slice_name\"])\n            self.assertEqual(item[\"viz_type\"], expected_response[index][\"viz_type\"])\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"load_energy_charts\")\n    def test_admin_gets_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"table.table_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        data = rv.json\n        assert rv.status_code == 200\n        assert data[\"count\"] > 0\n        for chart in data[\"result\"]:\n            print(chart)\n            assert (\n                \"energy\"\n                in \" \".join(\n                    [\n                        chart[\"slice_name\"] or \"\",\n                        chart[\"description\"] or \"\",\n                        chart[\"table\"][\"table_name\"] or \"\",\n                    ]\n                ).lower()\n            )\n\n    @pytest.mark.usefixtures(\"create_certified_charts\")\n    def test_gets_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": True,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], CHARTS_FIXTURE_COUNT)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_gets_not_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": False,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 17)\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_user_gets_none_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_charts_favorite_filter(self):\n        \"\"\"\n        Chart API: Test get charts favorite filter\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_query = db.session.query(FavStar.obj_id).filter(\n            and_(FavStar.user_id == admin.id, FavStar.class_name == \"slice\")\n        )\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_is_favorite\", \"value\": True}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n        # Test not favorite charts\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(~Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n        arguments[\"filters\"][0][\"value\"] = False\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n    @pytest.mark.usefixtures(\"create_charts_created_by_gamma\")\n    def test_get_charts_created_by_me_filter(self):\n        \"\"\"\n        Chart API: Test get charts with created by me special filter\n        \"\"\"\n        gamma_user = self.get_user(\"gamma\")\n        expected_models = (\n            db.session.query(Slice).filter(Slice.created_by_fk == gamma_user.id).all()\n        )\n        arguments = {\n            \"filters\": [\n                {\"col\": \"created_by\", \"opr\": \"chart_created_by_me\", \"value\": \"me\"}\n            ],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_current_user_favorite_status(self):\n        \"\"\"\n        Dataset API: Test get current user favorite stars\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_ids = [\n            star.obj_id\n            for star in db.session.query(FavStar.obj_id)\n            .filter(\n                and_(\n                    FavStar.user_id == admin.id,\n                    FavStar.class_name == FavStarClassName.CHART,\n                )\n            )\n            .all()\n        ]\n\n        assert users_favorite_ids\n        arguments = [s.id for s in db.session.query(Slice.id).all()]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/favorite_status/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        for res in data[\"result\"]:\n            if res[\"id\"] in users_favorite_ids:\n                assert res[\"value\"]\n\n    def test_get_time_range(self):\n        \"\"\"\n        Chart API: Test get actually time range from human readable string\n        \"\"\"\n        self.login(username=\"admin\")\n        humanize_time_range = \"100 years ago : now\"\n        uri = f\"api/v1/time_range/?q={prison.dumps(humanize_time_range)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(len(data[\"result\"]), 3)\n\n    @pytest.mark.usefixtures(\n        \"load_unicode_dashboard_with_slice\",\n        \"load_energy_table_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_page(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        # Assuming we have 34 sample charts\n        self.login(username=\"admin\")\n        arguments = {\"page_size\": 10, \"page\": 0}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 10)\n\n        arguments = {\"page_size\": 10, \"page\": 3}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 4)\n\n    def test_get_charts_no_data_access(self):\n        \"\"\"\n        Chart API: Test get charts no data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        uri = \"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    def test_export_chart(self):\n        \"\"\"\n        Chart API: Test export chart\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 200\n\n        buf = BytesIO(rv.data)\n        assert is_zipfile(buf)\n\n    def test_export_chart_not_found(self):\n        \"\"\"\n        Chart API: Test export chart not found\n        \"\"\"\n        # Just one does not exist and we get 404\n        argument = [-1, 1]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 404\n\n    def test_export_chart_gamma(self):\n        \"\"\"\n        Chart API: Test export chart has gamma\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"gamma\")\n        rv = self.client.get(uri)\n\n        assert rv.status_code == 404\n\n    def test_import_chart(self):\n        \"\"\"\n        Chart API: Test import chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        assert database.database_name == \"imported_database\"\n\n        assert len(database.tables) == 1\n        dataset = database.tables[0]\n        assert dataset.table_name == \"imported_dataset\"\n        assert str(dataset.uuid) == dataset_config[\"uuid\"]\n\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n        assert chart.table == dataset\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_overwrite(self):\n        \"\"\"\n        Chart API: Test import existing chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # import again without overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"charts/imported_chart.yaml\": \"Chart already exists and `overwrite=true` was not passed\",\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": \"Issue 1010 - Superset encountered an error while running a command.\",\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n        # import with overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n            \"overwrite\": \"true\",\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # clean up\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        dataset = database.tables[0]\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_invalid(self):\n        \"\"\"\n        Chart API: Test import invalid chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"metadata.yaml\": {\"type\": [\"Must be equal to Slice.\"]},\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": (\n                                    \"Issue 1010 - Superset encountered an \"\n                                    \"error while running a command.\"\n                                ),\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n    def test_gets_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": True}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n\n    def test_gets_not_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": False}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n", "patch": "@@ -1371,6 +1371,20 @@ def test_get_time_range(self):\n         self.assertEqual(rv.status_code, 200)\n         self.assertEqual(len(data[\"result\"]), 3)\n \n+    def test_query_form_data(self):\n+        \"\"\"\n+        Chart API: Test query form data\n+        \"\"\"\n+        self.login(username=\"admin\")\n+        slice = db.session.query(Slice).first()\n+        uri = f\"api/v1/form_data/?slice_id={slice.id if slice else None}\"\n+        rv = self.client.get(uri)\n+        data = json.loads(rv.data.decode(\"utf-8\"))\n+        self.assertEqual(rv.status_code, 200)\n+        self.assertEqual(rv.content_type, \"application/json\")\n+        if slice:\n+            self.assertEqual(data[\"slice_id\"], slice.id)\n+\n     @pytest.mark.usefixtures(\n         \"load_unicode_dashboard_with_slice\",\n         \"load_energy_table_with_slice\",", "file_path": "files/2023_11/75", "file_language": "py", "file_name": "tests/integration_tests/charts/api_tests.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class TestChartApi(SupersetTestCase, ApiOwnersTestCaseMixin, InsertChartMixin):\n    resource_name = \"chart\"\n\n    @pytest.fixture(autouse=True)\n    def clear_data_cache(self):\n        with app.app_context():\n            cache_manager.data_cache.clear()\n            yield\n\n    @pytest.fixture()\n    def create_charts(self):\n        with self.create_app().app_context():\n            charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"name{cx}\", [admin.id], 1))\n            fav_charts = []\n            for cx in range(round(CHARTS_FIXTURE_COUNT / 2)):\n                fav_star = FavStar(\n                    user_id=admin.id, class_name=\"slice\", obj_id=charts[cx].id\n                )\n                db.session.add(fav_star)\n                db.session.commit()\n                fav_charts.append(fav_star)\n            yield charts\n\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            for fav_chart in fav_charts:\n                db.session.delete(fav_chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_charts_created_by_gamma(self):\n        with self.create_app().app_context():\n            charts = []\n            user = self.get_user(\"gamma\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"gamma{cx}\", [user.id], 1))\n            yield charts\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_certified_charts(self):\n        with self.create_app().app_context():\n            certified_charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT):\n                certified_charts.append(\n                    self.insert_chart(\n                        f\"certified{cx}\",\n                        [admin.id],\n                        1,\n                        certified_by=\"John Doe\",\n                        certification_details=\"Sample certification\",\n                    )\n                )\n\n            yield certified_charts\n\n            # rollback changes\n            for chart in certified_charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_chart_with_report(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n            chart = self.insert_chart(f\"chart_report\", [admin.id], 1)\n            report_schedule = ReportSchedule(\n                type=ReportScheduleType.REPORT,\n                name=\"report_with_chart\",\n                crontab=\"* * * * *\",\n                chart=chart,\n            )\n            db.session.commit()\n\n            yield chart\n\n            # rollback changes\n            db.session.delete(report_schedule)\n            db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def add_dashboard_to_chart(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n\n            self.chart = self.insert_chart(\"My chart\", [admin.id], 1)\n\n            self.original_dashboard = Dashboard()\n            self.original_dashboard.dashboard_title = \"Original Dashboard\"\n            self.original_dashboard.slug = \"slug\"\n            self.original_dashboard.owners = [admin]\n            self.original_dashboard.slices = [self.chart]\n            self.original_dashboard.published = False\n            db.session.add(self.original_dashboard)\n\n            self.new_dashboard = Dashboard()\n            self.new_dashboard.dashboard_title = \"New Dashboard\"\n            self.new_dashboard.slug = \"new_slug\"\n            self.new_dashboard.owners = [admin]\n            self.new_dashboard.slices = []\n            self.new_dashboard.published = False\n            db.session.add(self.new_dashboard)\n\n            db.session.commit()\n\n            yield self.chart\n\n            db.session.delete(self.original_dashboard)\n            db.session.delete(self.new_dashboard)\n            db.session.delete(self.chart)\n            db.session.commit()\n\n    def test_info_security_chart(self):\n        \"\"\"\n        Chart API: Test info security\n        \"\"\"\n        self.login(username=\"admin\")\n        params = {\"keys\": [\"permissions\"]}\n        uri = f\"api/v1/chart/_info?q={prison.dumps(params)}\"\n        rv = self.get_assert_metric(uri, \"info\")\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert set(data[\"permissions\"]) == {\"can_read\", \"can_write\", \"can_export\"}\n\n    def create_chart_import(self):\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n        return buf\n\n    def test_delete_chart(self):\n        \"\"\"\n        Chart API: Test delete\n        \"\"\"\n        admin_id = self.get_user(\"admin\").id\n        chart_id = self.insert_chart(\"name\", [admin_id], 1).id\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_charts(self):\n        \"\"\"\n        Chart API: Test delete bulk\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [admin.id], 1, admin).id\n            )\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 200)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_bad_request(self):\n        \"\"\"\n        Chart API: Test delete bulk bad request\n        \"\"\"\n        chart_ids = [1, \"a\"]\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_delete_not_found_chart(self):\n        \"\"\"\n        Chart API: Test not found delete\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_id = 1000\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\")\n    def test_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart = (\n            db.session.query(Slice)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_bulk_charts_not_found(self):\n        \"\"\"\n        Chart API: Test delete bulk not found\n        \"\"\"\n        max_id = db.session.query(func.max(Slice.id)).scalar()\n        chart_ids = [max_id + 1, max_id + 2]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\", \"create_charts\")\n    def test_bulk_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test bulk delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_with_report = (\n            db.session.query(Slice.id)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n\n        charts = db.session.query(Slice.id).filter(Slice.slice_name.like(\"name%\")).all()\n        chart_ids = [chart.id for chart in charts]\n        chart_ids.append(chart_with_report.id)\n\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_id = self.insert_chart(\"title\", [gamma_id], 1).id\n\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete bulk not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [gamma_id], 1).id\n            )\n\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n        self.login(username=\"alpha2\", password=\"password\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_delete_bulk_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete bulk try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n\n        chart_count = 4\n        charts = list()\n        for chart_name_index in range(chart_count):\n            charts.append(\n                self.insert_chart(f\"title{chart_name_index}\", [user_alpha1.id], 1)\n            )\n\n        owned_chart = self.insert_chart(\"title_owned\", [user_alpha2.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n\n        # verify we can't delete not owned charts\n        arguments = [chart.id for chart in charts]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        # # nothing is deleted in bulk with a list of owned and not owned charts\n        arguments = [chart.id for chart in charts] + [owned_chart.id]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        for chart in charts:\n            db.session.delete(chart)\n        db.session.delete(owned_chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_create_chart(self):\n        \"\"\"\n        Chart API: Test create chart\n        \"\"\"\n        dashboards_ids = get_dashboards_ids(db, [\"world_health\", \"births\"])\n        admin_id = self.get_user(\"admin\").id\n        chart_data = {\n            \"slice_name\": \"name1\",\n            \"description\": \"description1\",\n            \"owners\": [admin_id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"1234\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"dashboards\": dashboards_ids,\n            \"certified_by\": \"John Doe\",\n            \"certification_details\": \"Sample certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_simple_chart(self):\n        \"\"\"\n        Chart API: Test create simple chart\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test create validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    def test_create_chart_validate_params(self):\n        \"\"\"\n        Chart API: Test create validate params json\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"params\": '{\"A:\"a\"}',\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_create_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test create validate datasource\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"unknown\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 0,\n            \"datasource_type\": \"table\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_update_chart(self):\n        \"\"\"\n        Chart API: Test update\n        \"\"\"\n        schema = get_example_default_schema()\n        full_table_name = f\"{schema}.birth_names\" if schema else \"birth_names\"\n\n        admin = self.get_user(\"admin\")\n        gamma = self.get_user(\"gamma\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\n            \"title\", [admin.id], birth_names_table_id, admin\n        ).id\n        dash_id = db.session.query(Dashboard.id).filter_by(slug=\"births\").first()[0]\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"description\": \"description1\",\n            \"owners\": [gamma.id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"\"\"{\"a\": 1}\"\"\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": birth_names_table_id,\n            \"datasource_type\": \"table\",\n            \"dashboards\": [dash_id],\n            \"certified_by\": \"Mario Rossi\",\n            \"certification_details\": \"Edited certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        related_dashboard = db.session.query(Dashboard).filter_by(slug=\"births\").first()\n        self.assertEqual(model.created_by, admin)\n        self.assertEqual(model.slice_name, \"title1_changed\")\n        self.assertEqual(model.description, \"description1\")\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        self.assertEqual(model.viz_type, \"viz_type1\")\n        self.assertEqual(model.params, \"\"\"{\"a\": 1}\"\"\")\n        self.assertEqual(model.cache_timeout, 1000)\n        self.assertEqual(model.datasource_id, birth_names_table_id)\n        self.assertEqual(model.datasource_type, \"table\")\n        self.assertEqual(model.datasource_name, full_table_name)\n        self.assertEqual(model.certified_by, \"Mario Rossi\")\n        self.assertEqual(model.certification_details, \"Edited certification\")\n        self.assertIn(model.id, [slice.id for slice in related_dashboard.slices])\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_disabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = False\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = False\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_enabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = True\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = True\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"/superset/profile/admin\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_list_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(\"api/v1/chart/\", \"get_list\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        current_chart = [d for d in res if d[\"id\"] == chart_id][0]\n        self.assertEqual(current_chart[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", current_chart[\"changed_by\"].keys())\n        self.assertNotIn(\"username\", current_chart[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(uri, \"get\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        self.assertEqual(res[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", res[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_not_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner implicitly adds logged in owner\n        \"\"\"\n        gamma = self.get_user(\"gamma_no_csv\")\n        alpha = self.get_user(\"alpha\")\n        chart_id = self.insert_chart(\"title\", [gamma.id], 1).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [alpha.id],\n        }\n        self.login(username=gamma.username)\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        assert rv.status_code == 200\n        model = db.session.query(Slice).get(chart_id)\n        assert model.slice_name == new_name\n        assert alpha in model.owners\n        assert gamma in model.owners\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner as admin to other than current user\n        \"\"\"\n        gamma = self.get_user(\"gamma\")\n        admin = self.get_user(\"admin\")\n        chart_id = self.insert_chart(\"title\", [admin.id], 1).id\n        chart_data = {\"slice_name\": \"title1_changed\", \"owners\": [gamma.id]}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_update_chart_new_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [self.new_dashboard.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.new_dashboard, self.chart.dashboards)\n        self.assertNotIn(self.original_dashboard, self.chart.dashboards)\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_not_update_chart_none_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\"slice_name\": \"title1_changed_again\"}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.original_dashboard, self.chart.dashboards)\n        self.assertEqual(len(self.chart.dashboards), 1)\n\n    def test_update_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test update not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n        chart_data = {\"slice_name\": \"title1_changed\"}\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_linked_with_not_owned_dashboard(self):\n        \"\"\"\n        Chart API: Test update chart which is linked to not owned dashboard\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        original_dashboard = Dashboard()\n        original_dashboard.dashboard_title = \"Original Dashboard\"\n        original_dashboard.slug = \"slug\"\n        original_dashboard.owners = [user_alpha1]\n        original_dashboard.slices = [chart]\n        original_dashboard.published = False\n        db.session.add(original_dashboard)\n\n        new_dashboard = Dashboard()\n        new_dashboard.dashboard_title = \"Cloned Dashboard\"\n        new_dashboard.slug = \"new_slug\"\n        new_dashboard.owners = [user_alpha2]\n        new_dashboard.slices = [chart]\n        new_dashboard.published = False\n        db.session.add(new_dashboard)\n\n        self.login(username=\"alpha1\", password=\"password\")\n        chart_data_with_invalid_dashboard = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, 0],\n        }\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, new_dashboard.id],\n        }\n        uri = f\"api/v1/chart/{chart.id}\"\n\n        rv = self.put_assert_metric(uri, chart_data_with_invalid_dashboard, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"dashboards\": [\"Dashboards do not exist\"]}}\n        self.assertEqual(response, expected_response)\n\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n\n        db.session.delete(chart)\n        db.session.delete(original_dashboard)\n        db.session.delete(new_dashboard)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test update validate datasource\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", owners=[admin.id], datasource_id=1)\n        self.login(username=\"admin\")\n\n        chart_data = {\"datasource_id\": 1, \"datasource_type\": \"unknown\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n\n        chart_data = {\"datasource_id\": 0, \"datasource_type\": \"table\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_update_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test update validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.client.post(uri, json=chart_data)\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    @pytest.mark.usefixtures(\"load_world_bank_dashboard_with_slices\")\n    def test_get_chart(self):\n        \"\"\"\n        Chart API: Test get chart\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", [admin.id], 1)\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 200)\n        expected_result = {\n            \"cache_timeout\": None,\n            \"certified_by\": None,\n            \"certification_details\": None,\n            \"dashboards\": [],\n            \"description\": None,\n            \"owners\": [\n                {\n                    \"id\": 1,\n                    \"first_name\": \"admin\",\n                    \"last_name\": \"user\",\n                }\n            ],\n            \"params\": None,\n            \"slice_name\": \"title\",\n            \"viz_type\": None,\n            \"query_context\": None,\n            \"is_managed_externally\": False,\n        }\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertIn(\"changed_on_delta_humanized\", data[\"result\"])\n        self.assertIn(\"id\", data[\"result\"])\n        self.assertIn(\"thumbnail_url\", data[\"result\"])\n        self.assertIn(\"url\", data[\"result\"])\n        for key, value in data[\"result\"].items():\n            # We can't assert timestamp values or id/urls\n            if key not in (\n                \"changed_on_delta_humanized\",\n                \"id\",\n                \"thumbnail_url\",\n                \"url\",\n            ):\n                self.assertEqual(value, expected_result[key])\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_get_chart_not_found(self):\n        \"\"\"\n        Chart API: Test get chart not found\n        \"\"\"\n        chart_id = 1000\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_get_chart_no_data_access(self):\n        \"\"\"\n        Chart API: Test get chart without data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        chart_no_access = (\n            db.session.query(Slice)\n            .filter_by(slice_name=\"Girl Name Cloud\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart_no_access.id}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\n        \"load_energy_table_with_slice\",\n        \"load_birth_names_dashboard_with_slices\",\n        \"load_unicode_dashboard_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n    )\n    def test_get_charts(self):\n        \"\"\"\n        Chart API: Test get charts\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 34)\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboards(self):\n        \"\"\"\n        Chart API: Test get charts with related dashboards\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\"col\": \"slice_name\", \"opr\": \"eq\", \"value\": self.chart.slice_name}\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"dashboards\"] == [\n            {\n                \"id\": self.original_dashboard.id,\n                \"dashboard_title\": self.original_dashboard.dashboard_title,\n            }\n        ]\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboard_filter(self):\n        \"\"\"\n        Chart API: Test get charts with dashboard filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"dashboards\",\n                    \"opr\": \"rel_m_m\",\n                    \"value\": self.original_dashboard.id,\n                }\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        result = data[\"result\"]\n        assert len(result) == 1\n        assert result[0][\"slice_name\"] == self.chart.slice_name\n\n    def test_get_charts_changed_on(self):\n        \"\"\"\n        Dashboard API: Test get charts changed on\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"foo_a\", [admin.id], 1, description=\"ZY_bar\")\n\n        self.login(username=\"admin\")\n\n        arguments = {\n            \"order_column\": \"changed_on_delta_humanized\",\n            \"order_direction\": \"desc\",\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"changed_on_delta_humanized\"] in (\n            \"now\",\n            \"a second ago\",\n        )\n\n        # rollback changes\n        db.session.delete(chart)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_filter(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\"filters\": [{\"col\": \"slice_name\", \"opr\": \"sw\", \"value\": \"G\"}]}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 5)\n\n    @pytest.fixture()\n    def load_energy_charts(self):\n        with app.app_context():\n            admin = self.get_user(\"admin\")\n            energy_table = (\n                db.session.query(SqlaTable)\n                .filter_by(table_name=\"energy_usage\")\n                .one_or_none()\n            )\n            energy_table_id = 1\n            if energy_table:\n                energy_table_id = energy_table.id\n            chart1 = self.insert_chart(\n                \"foo_a\", [admin.id], energy_table_id, description=\"ZY_bar\"\n            )\n            chart2 = self.insert_chart(\n                \"zy_foo\", [admin.id], energy_table_id, description=\"desc1\"\n            )\n            chart3 = self.insert_chart(\n                \"foo_b\", [admin.id], energy_table_id, description=\"desc1zy_\"\n            )\n            chart4 = self.insert_chart(\n                \"foo_c\", [admin.id], energy_table_id, viz_type=\"viz_zy_\"\n            )\n            chart5 = self.insert_chart(\n                \"bar\", [admin.id], energy_table_id, description=\"foo\"\n            )\n\n            yield\n            # rollback changes\n            db.session.delete(chart1)\n            db.session.delete(chart2)\n            db.session.delete(chart3)\n            db.session.delete(chart4)\n            db.session.delete(chart5)\n            db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_get_charts_custom_filter(self):\n        \"\"\"\n        Chart API: Test get charts custom filter\n        \"\"\"\n\n        arguments = {\n            \"filters\": [{\"col\": \"slice_name\", \"opr\": \"chart_all_text\", \"value\": \"zy_\"}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"viz_type\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 4)\n\n        expected_response = [\n            {\"description\": \"ZY_bar\", \"slice_name\": \"foo_a\", \"viz_type\": None},\n            {\"description\": \"desc1zy_\", \"slice_name\": \"foo_b\", \"viz_type\": None},\n            {\"description\": None, \"slice_name\": \"foo_c\", \"viz_type\": \"viz_zy_\"},\n            {\"description\": \"desc1\", \"slice_name\": \"zy_foo\", \"viz_type\": None},\n        ]\n        for index, item in enumerate(data[\"result\"]):\n            self.assertEqual(\n                item[\"description\"], expected_response[index][\"description\"]\n            )\n            self.assertEqual(item[\"slice_name\"], expected_response[index][\"slice_name\"])\n            self.assertEqual(item[\"viz_type\"], expected_response[index][\"viz_type\"])\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"load_energy_charts\")\n    def test_admin_gets_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"table.table_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        data = rv.json\n        assert rv.status_code == 200\n        assert data[\"count\"] > 0\n        for chart in data[\"result\"]:\n            print(chart)\n            assert (\n                \"energy\"\n                in \" \".join(\n                    [\n                        chart[\"slice_name\"] or \"\",\n                        chart[\"description\"] or \"\",\n                        chart[\"table\"][\"table_name\"] or \"\",\n                    ]\n                ).lower()\n            )\n\n    @pytest.mark.usefixtures(\"create_certified_charts\")\n    def test_gets_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": True,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], CHARTS_FIXTURE_COUNT)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_gets_not_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": False,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 17)\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_user_gets_none_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_charts_favorite_filter(self):\n        \"\"\"\n        Chart API: Test get charts favorite filter\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_query = db.session.query(FavStar.obj_id).filter(\n            and_(FavStar.user_id == admin.id, FavStar.class_name == \"slice\")\n        )\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_is_favorite\", \"value\": True}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n        # Test not favorite charts\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(~Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n        arguments[\"filters\"][0][\"value\"] = False\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n    @pytest.mark.usefixtures(\"create_charts_created_by_gamma\")\n    def test_get_charts_created_by_me_filter(self):\n        \"\"\"\n        Chart API: Test get charts with created by me special filter\n        \"\"\"\n        gamma_user = self.get_user(\"gamma\")\n        expected_models = (\n            db.session.query(Slice).filter(Slice.created_by_fk == gamma_user.id).all()\n        )\n        arguments = {\n            \"filters\": [\n                {\"col\": \"created_by\", \"opr\": \"chart_created_by_me\", \"value\": \"me\"}\n            ],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_current_user_favorite_status(self):\n        \"\"\"\n        Dataset API: Test get current user favorite stars\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_ids = [\n            star.obj_id\n            for star in db.session.query(FavStar.obj_id)\n            .filter(\n                and_(\n                    FavStar.user_id == admin.id,\n                    FavStar.class_name == FavStarClassName.CHART,\n                )\n            )\n            .all()\n        ]\n\n        assert users_favorite_ids\n        arguments = [s.id for s in db.session.query(Slice.id).all()]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/favorite_status/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        for res in data[\"result\"]:\n            if res[\"id\"] in users_favorite_ids:\n                assert res[\"value\"]\n\n    def test_get_time_range(self):\n        \"\"\"\n        Chart API: Test get actually time range from human readable string\n        \"\"\"\n        self.login(username=\"admin\")\n        humanize_time_range = \"100 years ago : now\"\n        uri = f\"api/v1/time_range/?q={prison.dumps(humanize_time_range)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(len(data[\"result\"]), 3)\n\n    @pytest.mark.usefixtures(\n        \"load_unicode_dashboard_with_slice\",\n        \"load_energy_table_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_page(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        # Assuming we have 34 sample charts\n        self.login(username=\"admin\")\n        arguments = {\"page_size\": 10, \"page\": 0}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 10)\n\n        arguments = {\"page_size\": 10, \"page\": 3}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 4)\n\n    def test_get_charts_no_data_access(self):\n        \"\"\"\n        Chart API: Test get charts no data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        uri = \"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    def test_export_chart(self):\n        \"\"\"\n        Chart API: Test export chart\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 200\n\n        buf = BytesIO(rv.data)\n        assert is_zipfile(buf)\n\n    def test_export_chart_not_found(self):\n        \"\"\"\n        Chart API: Test export chart not found\n        \"\"\"\n        # Just one does not exist and we get 404\n        argument = [-1, 1]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 404\n\n    def test_export_chart_gamma(self):\n        \"\"\"\n        Chart API: Test export chart has gamma\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"gamma\")\n        rv = self.client.get(uri)\n\n        assert rv.status_code == 404\n\n    def test_import_chart(self):\n        \"\"\"\n        Chart API: Test import chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        assert database.database_name == \"imported_database\"\n\n        assert len(database.tables) == 1\n        dataset = database.tables[0]\n        assert dataset.table_name == \"imported_dataset\"\n        assert str(dataset.uuid) == dataset_config[\"uuid\"]\n\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n        assert chart.table == dataset\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_overwrite(self):\n        \"\"\"\n        Chart API: Test import existing chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # import again without overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"charts/imported_chart.yaml\": \"Chart already exists and `overwrite=true` was not passed\",\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": \"Issue 1010 - Superset encountered an error while running a command.\",\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n        # import with overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n            \"overwrite\": \"true\",\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # clean up\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        dataset = database.tables[0]\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_invalid(self):\n        \"\"\"\n        Chart API: Test import invalid chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"metadata.yaml\": {\"type\": [\"Must be equal to Slice.\"]},\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": (\n                                    \"Issue 1010 - Superset encountered an \"\n                                    \"error while running a command.\"\n                                ),\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n    def test_gets_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": True}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n\n    def test_gets_not_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": False}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)", "target": 0}], "function_after": [{"function": "class TestChartApi(SupersetTestCase, ApiOwnersTestCaseMixin, InsertChartMixin):\n    resource_name = \"chart\"\n\n    @pytest.fixture(autouse=True)\n    def clear_data_cache(self):\n        with app.app_context():\n            cache_manager.data_cache.clear()\n            yield\n\n    @pytest.fixture()\n    def create_charts(self):\n        with self.create_app().app_context():\n            charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"name{cx}\", [admin.id], 1))\n            fav_charts = []\n            for cx in range(round(CHARTS_FIXTURE_COUNT / 2)):\n                fav_star = FavStar(\n                    user_id=admin.id, class_name=\"slice\", obj_id=charts[cx].id\n                )\n                db.session.add(fav_star)\n                db.session.commit()\n                fav_charts.append(fav_star)\n            yield charts\n\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            for fav_chart in fav_charts:\n                db.session.delete(fav_chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_charts_created_by_gamma(self):\n        with self.create_app().app_context():\n            charts = []\n            user = self.get_user(\"gamma\")\n            for cx in range(CHARTS_FIXTURE_COUNT - 1):\n                charts.append(self.insert_chart(f\"gamma{cx}\", [user.id], 1))\n            yield charts\n            # rollback changes\n            for chart in charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_certified_charts(self):\n        with self.create_app().app_context():\n            certified_charts = []\n            admin = self.get_user(\"admin\")\n            for cx in range(CHARTS_FIXTURE_COUNT):\n                certified_charts.append(\n                    self.insert_chart(\n                        f\"certified{cx}\",\n                        [admin.id],\n                        1,\n                        certified_by=\"John Doe\",\n                        certification_details=\"Sample certification\",\n                    )\n                )\n\n            yield certified_charts\n\n            # rollback changes\n            for chart in certified_charts:\n                db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def create_chart_with_report(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n            chart = self.insert_chart(f\"chart_report\", [admin.id], 1)\n            report_schedule = ReportSchedule(\n                type=ReportScheduleType.REPORT,\n                name=\"report_with_chart\",\n                crontab=\"* * * * *\",\n                chart=chart,\n            )\n            db.session.commit()\n\n            yield chart\n\n            # rollback changes\n            db.session.delete(report_schedule)\n            db.session.delete(chart)\n            db.session.commit()\n\n    @pytest.fixture()\n    def add_dashboard_to_chart(self):\n        with self.create_app().app_context():\n            admin = self.get_user(\"admin\")\n\n            self.chart = self.insert_chart(\"My chart\", [admin.id], 1)\n\n            self.original_dashboard = Dashboard()\n            self.original_dashboard.dashboard_title = \"Original Dashboard\"\n            self.original_dashboard.slug = \"slug\"\n            self.original_dashboard.owners = [admin]\n            self.original_dashboard.slices = [self.chart]\n            self.original_dashboard.published = False\n            db.session.add(self.original_dashboard)\n\n            self.new_dashboard = Dashboard()\n            self.new_dashboard.dashboard_title = \"New Dashboard\"\n            self.new_dashboard.slug = \"new_slug\"\n            self.new_dashboard.owners = [admin]\n            self.new_dashboard.slices = []\n            self.new_dashboard.published = False\n            db.session.add(self.new_dashboard)\n\n            db.session.commit()\n\n            yield self.chart\n\n            db.session.delete(self.original_dashboard)\n            db.session.delete(self.new_dashboard)\n            db.session.delete(self.chart)\n            db.session.commit()\n\n    def test_info_security_chart(self):\n        \"\"\"\n        Chart API: Test info security\n        \"\"\"\n        self.login(username=\"admin\")\n        params = {\"keys\": [\"permissions\"]}\n        uri = f\"api/v1/chart/_info?q={prison.dumps(params)}\"\n        rv = self.get_assert_metric(uri, \"info\")\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert set(data[\"permissions\"]) == {\"can_read\", \"can_write\", \"can_export\"}\n\n    def create_chart_import(self):\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n        return buf\n\n    def test_delete_chart(self):\n        \"\"\"\n        Chart API: Test delete\n        \"\"\"\n        admin_id = self.get_user(\"admin\").id\n        chart_id = self.insert_chart(\"name\", [admin_id], 1).id\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_charts(self):\n        \"\"\"\n        Chart API: Test delete bulk\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [admin.id], 1, admin).id\n            )\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 200)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_bad_request(self):\n        \"\"\"\n        Chart API: Test delete bulk bad request\n        \"\"\"\n        chart_ids = [1, \"a\"]\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_delete_not_found_chart(self):\n        \"\"\"\n        Chart API: Test not found delete\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_id = 1000\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\")\n    def test_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart = (\n            db.session.query(Slice)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_bulk_charts_not_found(self):\n        \"\"\"\n        Chart API: Test delete bulk not found\n        \"\"\"\n        max_id = db.session.query(func.max(Slice.id)).scalar()\n        chart_ids = [max_id + 1, max_id + 2]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"create_chart_with_report\", \"create_charts\")\n    def test_bulk_delete_chart_with_report(self):\n        \"\"\"\n        Chart API: Test bulk delete with associated report\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_with_report = (\n            db.session.query(Slice.id)\n            .filter(Slice.slice_name == \"chart_report\")\n            .one_or_none()\n        )\n\n        charts = db.session.query(Slice.id).filter(Slice.slice_name.like(\"name%\")).all()\n        chart_ids = [chart.id for chart in charts]\n        chart_ids.append(chart_with_report.id)\n\n        uri = f\"api/v1/chart/?q={prison.dumps(chart_ids)}\"\n        rv = self.client.delete(uri)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 422)\n        expected_response = {\n            \"message\": \"There are associated alerts or reports: report_with_chart\"\n        }\n        self.assertEqual(response, expected_response)\n\n    def test_delete_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_id = self.insert_chart(\"title\", [gamma_id], 1).id\n\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertEqual(model, None)\n\n    def test_delete_bulk_chart_admin_not_owned(self):\n        \"\"\"\n        Chart API: Test admin delete bulk not owned\n        \"\"\"\n        gamma_id = self.get_user(\"gamma\").id\n        chart_count = 4\n        chart_ids = list()\n        for chart_name_index in range(chart_count):\n            chart_ids.append(\n                self.insert_chart(f\"title{chart_name_index}\", [gamma_id], 1).id\n            )\n\n        self.login(username=\"admin\")\n        argument = chart_ids\n        uri = f\"api/v1/chart/?q={prison.dumps(argument)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        expected_response = {\"message\": f\"Deleted {chart_count} charts\"}\n        self.assertEqual(response, expected_response)\n\n        for chart_id in chart_ids:\n            model = db.session.query(Slice).get(chart_id)\n            self.assertEqual(model, None)\n\n    def test_delete_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n        self.login(username=\"alpha2\", password=\"password\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.delete_assert_metric(uri, \"delete\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_delete_bulk_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test delete bulk try not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n\n        chart_count = 4\n        charts = list()\n        for chart_name_index in range(chart_count):\n            charts.append(\n                self.insert_chart(f\"title{chart_name_index}\", [user_alpha1.id], 1)\n            )\n\n        owned_chart = self.insert_chart(\"title_owned\", [user_alpha2.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n\n        # verify we can't delete not owned charts\n        arguments = [chart.id for chart in charts]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        # # nothing is deleted in bulk with a list of owned and not owned charts\n        arguments = [chart.id for chart in charts] + [owned_chart.id]\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.delete_assert_metric(uri, \"bulk_delete\")\n        self.assertEqual(rv.status_code, 403)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": \"Forbidden\"}\n        self.assertEqual(response, expected_response)\n\n        for chart in charts:\n            db.session.delete(chart)\n        db.session.delete(owned_chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_create_chart(self):\n        \"\"\"\n        Chart API: Test create chart\n        \"\"\"\n        dashboards_ids = get_dashboards_ids(db, [\"world_health\", \"births\"])\n        admin_id = self.get_user(\"admin\").id\n        chart_data = {\n            \"slice_name\": \"name1\",\n            \"description\": \"description1\",\n            \"owners\": [admin_id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"1234\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"dashboards\": dashboards_ids,\n            \"certified_by\": \"John Doe\",\n            \"certification_details\": \"Sample certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_simple_chart(self):\n        \"\"\"\n        Chart API: Test create simple chart\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 201)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        model = db.session.query(Slice).get(data.get(\"id\"))\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_create_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test create validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    def test_create_chart_validate_params(self):\n        \"\"\"\n        Chart API: Test create validate params json\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"params\": '{\"A:\"a\"}',\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.post_assert_metric(uri, chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n\n    def test_create_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test create validate datasource\n        \"\"\"\n        self.login(username=\"admin\")\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"unknown\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 0,\n            \"datasource_type\": \"table\",\n        }\n        rv = self.post_assert_metric(\"/api/v1/chart/\", chart_data, \"post\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_update_chart(self):\n        \"\"\"\n        Chart API: Test update\n        \"\"\"\n        schema = get_example_default_schema()\n        full_table_name = f\"{schema}.birth_names\" if schema else \"birth_names\"\n\n        admin = self.get_user(\"admin\")\n        gamma = self.get_user(\"gamma\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\n            \"title\", [admin.id], birth_names_table_id, admin\n        ).id\n        dash_id = db.session.query(Dashboard.id).filter_by(slug=\"births\").first()[0]\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"description\": \"description1\",\n            \"owners\": [gamma.id],\n            \"viz_type\": \"viz_type1\",\n            \"params\": \"\"\"{\"a\": 1}\"\"\",\n            \"cache_timeout\": 1000,\n            \"datasource_id\": birth_names_table_id,\n            \"datasource_type\": \"table\",\n            \"dashboards\": [dash_id],\n            \"certified_by\": \"Mario Rossi\",\n            \"certification_details\": \"Edited certification\",\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        related_dashboard = db.session.query(Dashboard).filter_by(slug=\"births\").first()\n        self.assertEqual(model.created_by, admin)\n        self.assertEqual(model.slice_name, \"title1_changed\")\n        self.assertEqual(model.description, \"description1\")\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        self.assertEqual(model.viz_type, \"viz_type1\")\n        self.assertEqual(model.params, \"\"\"{\"a\": 1}\"\"\")\n        self.assertEqual(model.cache_timeout, 1000)\n        self.assertEqual(model.datasource_id, birth_names_table_id)\n        self.assertEqual(model.datasource_type, \"table\")\n        self.assertEqual(model.datasource_name, full_table_name)\n        self.assertEqual(model.certified_by, \"Mario Rossi\")\n        self.assertEqual(model.certification_details, \"Edited certification\")\n        self.assertIn(model.id, [slice.id for slice in related_dashboard.slices])\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_disabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = False\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = False\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_activity_access_enabled(self):\n        \"\"\"\n        Chart API: Test ENABLE_BROAD_ACTIVITY_ACCESS = True\n        \"\"\"\n        access_flag = app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"]\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = True\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        self.assertEqual(model.slice_name, new_name)\n        self.assertEqual(model.changed_by_url, \"/superset/profile/admin\")\n\n        app.config[\"ENABLE_BROAD_ACTIVITY_ACCESS\"] = access_flag\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_list_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(\"api/v1/chart/\", \"get_list\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        current_chart = [d for d in res if d[\"id\"] == chart_id][0]\n        self.assertEqual(current_chart[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", current_chart[\"changed_by\"].keys())\n        self.assertNotIn(\"username\", current_chart[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_chart_get_no_username(self):\n        \"\"\"\n        Chart API: Tests that no username is returned\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        birth_names_table_id = SupersetTestCase.get_table(name=\"birth_names\").id\n        chart_id = self.insert_chart(\"title\", [admin.id], birth_names_table_id).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [admin.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n\n        response = self.get_assert_metric(uri, \"get\")\n        res = json.loads(response.data.decode(\"utf-8\"))[\"result\"]\n\n        self.assertEqual(res[\"slice_name\"], new_name)\n        self.assertNotIn(\"username\", res[\"owners\"][0].keys())\n\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_not_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner implicitly adds logged in owner\n        \"\"\"\n        gamma = self.get_user(\"gamma_no_csv\")\n        alpha = self.get_user(\"alpha\")\n        chart_id = self.insert_chart(\"title\", [gamma.id], 1).id\n        chart_data = {\n            \"slice_name\": (new_name := \"title1_changed\"),\n            \"owners\": [alpha.id],\n        }\n        self.login(username=gamma.username)\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        assert rv.status_code == 200\n        model = db.session.query(Slice).get(chart_id)\n        assert model.slice_name == new_name\n        assert alpha in model.owners\n        assert gamma in model.owners\n        db.session.delete(model)\n        db.session.commit()\n\n    def test_update_chart_new_owner_admin(self):\n        \"\"\"\n        Chart API: Test update set new owner as admin to other than current user\n        \"\"\"\n        gamma = self.get_user(\"gamma\")\n        admin = self.get_user(\"admin\")\n        chart_id = self.insert_chart(\"title\", [admin.id], 1).id\n        chart_data = {\"slice_name\": \"title1_changed\", \"owners\": [gamma.id]}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        model = db.session.query(Slice).get(chart_id)\n        self.assertNotIn(admin, model.owners)\n        self.assertIn(gamma, model.owners)\n        db.session.delete(model)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_update_chart_new_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [self.new_dashboard.id],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.new_dashboard, self.chart.dashboards)\n        self.assertNotIn(self.original_dashboard, self.chart.dashboards)\n\n    @pytest.mark.usefixtures(\"add_dashboard_to_chart\")\n    def test_not_update_chart_none_dashboards(self):\n        \"\"\"\n        Chart API: Test update set new owner to current user\n        \"\"\"\n        chart_data = {\"slice_name\": \"title1_changed_again\"}\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{self.chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n        self.assertIn(self.original_dashboard, self.chart.dashboards)\n        self.assertEqual(len(self.chart.dashboards), 1)\n\n    def test_update_chart_not_owned(self):\n        \"\"\"\n        Chart API: Test update not owned\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        self.login(username=\"alpha2\", password=\"password\")\n        chart_data = {\"slice_name\": \"title1_changed\"}\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 403)\n        db.session.delete(chart)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_linked_with_not_owned_dashboard(self):\n        \"\"\"\n        Chart API: Test update chart which is linked to not owned dashboard\n        \"\"\"\n        user_alpha1 = self.create_user(\n            \"alpha1\", \"password\", \"Alpha\", email=\"alpha1@superset.org\"\n        )\n        user_alpha2 = self.create_user(\n            \"alpha2\", \"password\", \"Alpha\", email=\"alpha2@superset.org\"\n        )\n        chart = self.insert_chart(\"title\", [user_alpha1.id], 1)\n\n        original_dashboard = Dashboard()\n        original_dashboard.dashboard_title = \"Original Dashboard\"\n        original_dashboard.slug = \"slug\"\n        original_dashboard.owners = [user_alpha1]\n        original_dashboard.slices = [chart]\n        original_dashboard.published = False\n        db.session.add(original_dashboard)\n\n        new_dashboard = Dashboard()\n        new_dashboard.dashboard_title = \"Cloned Dashboard\"\n        new_dashboard.slug = \"new_slug\"\n        new_dashboard.owners = [user_alpha2]\n        new_dashboard.slices = [chart]\n        new_dashboard.published = False\n        db.session.add(new_dashboard)\n\n        self.login(username=\"alpha1\", password=\"password\")\n        chart_data_with_invalid_dashboard = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, 0],\n        }\n        chart_data = {\n            \"slice_name\": \"title1_changed\",\n            \"dashboards\": [original_dashboard.id, new_dashboard.id],\n        }\n        uri = f\"api/v1/chart/{chart.id}\"\n\n        rv = self.put_assert_metric(uri, chart_data_with_invalid_dashboard, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"dashboards\": [\"Dashboards do not exist\"]}}\n        self.assertEqual(response, expected_response)\n\n        rv = self.put_assert_metric(uri, chart_data, \"put\")\n        self.assertEqual(rv.status_code, 200)\n\n        db.session.delete(chart)\n        db.session.delete(original_dashboard)\n        db.session.delete(new_dashboard)\n        db.session.delete(user_alpha1)\n        db.session.delete(user_alpha2)\n        db.session.commit()\n\n    def test_update_chart_validate_datasource(self):\n        \"\"\"\n        Chart API: Test update validate datasource\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", owners=[admin.id], datasource_id=1)\n        self.login(username=\"admin\")\n\n        chart_data = {\"datasource_id\": 1, \"datasource_type\": \"unknown\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 400)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response,\n            {\n                \"message\": {\n                    \"datasource_type\": [\n                        \"Must be one of: sl_table, table, dataset, query, saved_query, view.\"\n                    ]\n                }\n            },\n        )\n\n        chart_data = {\"datasource_id\": 0, \"datasource_type\": \"table\"}\n        rv = self.put_assert_metric(f\"/api/v1/chart/{chart.id}\", chart_data, \"put\")\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(\n            response, {\"message\": {\"datasource_id\": [\"Datasource does not exist\"]}}\n        )\n\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_update_chart_validate_owners(self):\n        \"\"\"\n        Chart API: Test update validate owners\n        \"\"\"\n        chart_data = {\n            \"slice_name\": \"title1\",\n            \"datasource_id\": 1,\n            \"datasource_type\": \"table\",\n            \"owners\": [1000],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.client.post(uri, json=chart_data)\n        self.assertEqual(rv.status_code, 422)\n        response = json.loads(rv.data.decode(\"utf-8\"))\n        expected_response = {\"message\": {\"owners\": [\"Owners are invalid\"]}}\n        self.assertEqual(response, expected_response)\n\n    @pytest.mark.usefixtures(\"load_world_bank_dashboard_with_slices\")\n    def test_get_chart(self):\n        \"\"\"\n        Chart API: Test get chart\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"title\", [admin.id], 1)\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart.id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 200)\n        expected_result = {\n            \"cache_timeout\": None,\n            \"certified_by\": None,\n            \"certification_details\": None,\n            \"dashboards\": [],\n            \"description\": None,\n            \"owners\": [\n                {\n                    \"id\": 1,\n                    \"first_name\": \"admin\",\n                    \"last_name\": \"user\",\n                }\n            ],\n            \"params\": None,\n            \"slice_name\": \"title\",\n            \"viz_type\": None,\n            \"query_context\": None,\n            \"is_managed_externally\": False,\n        }\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertIn(\"changed_on_delta_humanized\", data[\"result\"])\n        self.assertIn(\"id\", data[\"result\"])\n        self.assertIn(\"thumbnail_url\", data[\"result\"])\n        self.assertIn(\"url\", data[\"result\"])\n        for key, value in data[\"result\"].items():\n            # We can't assert timestamp values or id/urls\n            if key not in (\n                \"changed_on_delta_humanized\",\n                \"id\",\n                \"thumbnail_url\",\n                \"url\",\n            ):\n                self.assertEqual(value, expected_result[key])\n        db.session.delete(chart)\n        db.session.commit()\n\n    def test_get_chart_not_found(self):\n        \"\"\"\n        Chart API: Test get chart not found\n        \"\"\"\n        chart_id = 1000\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/{chart_id}\"\n        rv = self.get_assert_metric(uri, \"get\")\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\"load_birth_names_dashboard_with_slices\")\n    def test_get_chart_no_data_access(self):\n        \"\"\"\n        Chart API: Test get chart without data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        chart_no_access = (\n            db.session.query(Slice)\n            .filter_by(slice_name=\"Girl Name Cloud\")\n            .one_or_none()\n        )\n        uri = f\"api/v1/chart/{chart_no_access.id}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 404)\n\n    @pytest.mark.usefixtures(\n        \"load_energy_table_with_slice\",\n        \"load_birth_names_dashboard_with_slices\",\n        \"load_unicode_dashboard_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n    )\n    def test_get_charts(self):\n        \"\"\"\n        Chart API: Test get charts\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 34)\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboards(self):\n        \"\"\"\n        Chart API: Test get charts with related dashboards\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\"col\": \"slice_name\", \"opr\": \"eq\", \"value\": self.chart.slice_name}\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"dashboards\"] == [\n            {\n                \"id\": self.original_dashboard.id,\n                \"dashboard_title\": self.original_dashboard.dashboard_title,\n            }\n        ]\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"add_dashboard_to_chart\")\n    def test_get_charts_dashboard_filter(self):\n        \"\"\"\n        Chart API: Test get charts with dashboard filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"dashboards\",\n                    \"opr\": \"rel_m_m\",\n                    \"value\": self.original_dashboard.id,\n                }\n            ]\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        result = data[\"result\"]\n        assert len(result) == 1\n        assert result[0][\"slice_name\"] == self.chart.slice_name\n\n    def test_get_charts_changed_on(self):\n        \"\"\"\n        Dashboard API: Test get charts changed on\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        chart = self.insert_chart(\"foo_a\", [admin.id], 1, description=\"ZY_bar\")\n\n        self.login(username=\"admin\")\n\n        arguments = {\n            \"order_column\": \"changed_on_delta_humanized\",\n            \"order_direction\": \"desc\",\n        }\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert data[\"result\"][0][\"changed_on_delta_humanized\"] in (\n            \"now\",\n            \"a second ago\",\n        )\n\n        # rollback changes\n        db.session.delete(chart)\n        db.session.commit()\n\n    @pytest.mark.usefixtures(\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_filter(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        self.login(username=\"admin\")\n        arguments = {\"filters\": [{\"col\": \"slice_name\", \"opr\": \"sw\", \"value\": \"G\"}]}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 5)\n\n    @pytest.fixture()\n    def load_energy_charts(self):\n        with app.app_context():\n            admin = self.get_user(\"admin\")\n            energy_table = (\n                db.session.query(SqlaTable)\n                .filter_by(table_name=\"energy_usage\")\n                .one_or_none()\n            )\n            energy_table_id = 1\n            if energy_table:\n                energy_table_id = energy_table.id\n            chart1 = self.insert_chart(\n                \"foo_a\", [admin.id], energy_table_id, description=\"ZY_bar\"\n            )\n            chart2 = self.insert_chart(\n                \"zy_foo\", [admin.id], energy_table_id, description=\"desc1\"\n            )\n            chart3 = self.insert_chart(\n                \"foo_b\", [admin.id], energy_table_id, description=\"desc1zy_\"\n            )\n            chart4 = self.insert_chart(\n                \"foo_c\", [admin.id], energy_table_id, viz_type=\"viz_zy_\"\n            )\n            chart5 = self.insert_chart(\n                \"bar\", [admin.id], energy_table_id, description=\"foo\"\n            )\n\n            yield\n            # rollback changes\n            db.session.delete(chart1)\n            db.session.delete(chart2)\n            db.session.delete(chart3)\n            db.session.delete(chart4)\n            db.session.delete(chart5)\n            db.session.commit()\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_get_charts_custom_filter(self):\n        \"\"\"\n        Chart API: Test get charts custom filter\n        \"\"\"\n\n        arguments = {\n            \"filters\": [{\"col\": \"slice_name\", \"opr\": \"chart_all_text\", \"value\": \"zy_\"}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"viz_type\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 4)\n\n        expected_response = [\n            {\"description\": \"ZY_bar\", \"slice_name\": \"foo_a\", \"viz_type\": None},\n            {\"description\": \"desc1zy_\", \"slice_name\": \"foo_b\", \"viz_type\": None},\n            {\"description\": None, \"slice_name\": \"foo_c\", \"viz_type\": \"viz_zy_\"},\n            {\"description\": \"desc1\", \"slice_name\": \"zy_foo\", \"viz_type\": None},\n        ]\n        for index, item in enumerate(data[\"result\"]):\n            self.assertEqual(\n                item[\"description\"], expected_response[index][\"description\"]\n            )\n            self.assertEqual(item[\"slice_name\"], expected_response[index][\"slice_name\"])\n            self.assertEqual(item[\"viz_type\"], expected_response[index][\"viz_type\"])\n\n    @pytest.mark.usefixtures(\"load_energy_table_with_slice\", \"load_energy_charts\")\n    def test_admin_gets_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\", \"description\", \"table.table_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        data = rv.json\n        assert rv.status_code == 200\n        assert data[\"count\"] > 0\n        for chart in data[\"result\"]:\n            print(chart)\n            assert (\n                \"energy\"\n                in \" \".join(\n                    [\n                        chart[\"slice_name\"] or \"\",\n                        chart[\"description\"] or \"\",\n                        chart[\"table\"][\"table_name\"] or \"\",\n                    ]\n                ).lower()\n            )\n\n    @pytest.mark.usefixtures(\"create_certified_charts\")\n    def test_gets_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": True,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], CHARTS_FIXTURE_COUNT)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_gets_not_certified_charts_filter(self):\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"id\",\n                    \"opr\": \"chart_is_certified\",\n                    \"value\": False,\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 17)\n\n    @pytest.mark.usefixtures(\"load_energy_charts\")\n    def test_user_gets_none_filtered_energy_slices(self):\n        # test filtering on datasource_name\n        arguments = {\n            \"filters\": [\n                {\n                    \"col\": \"slice_name\",\n                    \"opr\": \"chart_all_text\",\n                    \"value\": \"energy\",\n                }\n            ],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_charts_favorite_filter(self):\n        \"\"\"\n        Chart API: Test get charts favorite filter\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_query = db.session.query(FavStar.obj_id).filter(\n            and_(FavStar.user_id == admin.id, FavStar.class_name == \"slice\")\n        )\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_is_favorite\", \"value\": True}],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n        # Test not favorite charts\n        expected_models = (\n            db.session.query(Slice)\n            .filter(and_(~Slice.id.in_(users_favorite_query)))\n            .order_by(Slice.slice_name.asc())\n            .all()\n        )\n        arguments[\"filters\"][0][\"value\"] = False\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n\n    @pytest.mark.usefixtures(\"create_charts_created_by_gamma\")\n    def test_get_charts_created_by_me_filter(self):\n        \"\"\"\n        Chart API: Test get charts with created by me special filter\n        \"\"\"\n        gamma_user = self.get_user(\"gamma\")\n        expected_models = (\n            db.session.query(Slice).filter(Slice.created_by_fk == gamma_user.id).all()\n        )\n        arguments = {\n            \"filters\": [\n                {\"col\": \"created_by\", \"opr\": \"chart_created_by_me\", \"value\": \"me\"}\n            ],\n            \"order_column\": \"slice_name\",\n            \"order_direction\": \"asc\",\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"gamma\")\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        assert len(expected_models) == data[\"count\"]\n        for i, expected_model in enumerate(expected_models):\n            assert expected_model.slice_name == data[\"result\"][i][\"slice_name\"]\n\n    @pytest.mark.usefixtures(\"create_charts\")\n    def test_get_current_user_favorite_status(self):\n        \"\"\"\n        Dataset API: Test get current user favorite stars\n        \"\"\"\n        admin = self.get_user(\"admin\")\n        users_favorite_ids = [\n            star.obj_id\n            for star in db.session.query(FavStar.obj_id)\n            .filter(\n                and_(\n                    FavStar.user_id == admin.id,\n                    FavStar.class_name == FavStarClassName.CHART,\n                )\n            )\n            .all()\n        ]\n\n        assert users_favorite_ids\n        arguments = [s.id for s in db.session.query(Slice.id).all()]\n        self.login(username=\"admin\")\n        uri = f\"api/v1/chart/favorite_status/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        assert rv.status_code == 200\n        for res in data[\"result\"]:\n            if res[\"id\"] in users_favorite_ids:\n                assert res[\"value\"]\n\n    def test_get_time_range(self):\n        \"\"\"\n        Chart API: Test get actually time range from human readable string\n        \"\"\"\n        self.login(username=\"admin\")\n        humanize_time_range = \"100 years ago : now\"\n        uri = f\"api/v1/time_range/?q={prison.dumps(humanize_time_range)}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(len(data[\"result\"]), 3)\n\n    def test_query_form_data(self):\n        \"\"\"\n        Chart API: Test query form data\n        \"\"\"\n        self.login(username=\"admin\")\n        slice = db.session.query(Slice).first()\n        uri = f\"api/v1/form_data/?slice_id={slice.id if slice else None}\"\n        rv = self.client.get(uri)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(rv.status_code, 200)\n        self.assertEqual(rv.content_type, \"application/json\")\n        if slice:\n            self.assertEqual(data[\"slice_id\"], slice.id)\n\n    @pytest.mark.usefixtures(\n        \"load_unicode_dashboard_with_slice\",\n        \"load_energy_table_with_slice\",\n        \"load_world_bank_dashboard_with_slices\",\n        \"load_birth_names_dashboard_with_slices\",\n    )\n    def test_get_charts_page(self):\n        \"\"\"\n        Chart API: Test get charts filter\n        \"\"\"\n        # Assuming we have 34 sample charts\n        self.login(username=\"admin\")\n        arguments = {\"page_size\": 10, \"page\": 0}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.client.get(uri)\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 10)\n\n        arguments = {\"page_size\": 10, \"page\": 3}\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(len(data[\"result\"]), 4)\n\n    def test_get_charts_no_data_access(self):\n        \"\"\"\n        Chart API: Test get charts no data access\n        \"\"\"\n        self.login(username=\"gamma\")\n        uri = \"api/v1/chart/\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 0)\n\n    def test_export_chart(self):\n        \"\"\"\n        Chart API: Test export chart\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 200\n\n        buf = BytesIO(rv.data)\n        assert is_zipfile(buf)\n\n    def test_export_chart_not_found(self):\n        \"\"\"\n        Chart API: Test export chart not found\n        \"\"\"\n        # Just one does not exist and we get 404\n        argument = [-1, 1]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n        self.login(username=\"admin\")\n        rv = self.get_assert_metric(uri, \"export\")\n\n        assert rv.status_code == 404\n\n    def test_export_chart_gamma(self):\n        \"\"\"\n        Chart API: Test export chart has gamma\n        \"\"\"\n        example_chart = db.session.query(Slice).all()[0]\n        argument = [example_chart.id]\n        uri = f\"api/v1/chart/export/?q={prison.dumps(argument)}\"\n\n        self.login(username=\"gamma\")\n        rv = self.client.get(uri)\n\n        assert rv.status_code == 404\n\n    def test_import_chart(self):\n        \"\"\"\n        Chart API: Test import chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        assert database.database_name == \"imported_database\"\n\n        assert len(database.tables) == 1\n        dataset = database.tables[0]\n        assert dataset.table_name == \"imported_dataset\"\n        assert str(dataset.uuid) == dataset_config[\"uuid\"]\n\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n        assert chart.table == dataset\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_overwrite(self):\n        \"\"\"\n        Chart API: Test import existing chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # import again without overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"charts/imported_chart.yaml\": \"Chart already exists and `overwrite=true` was not passed\",\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": \"Issue 1010 - Superset encountered an error while running a command.\",\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n        # import with overwrite flag\n        buf = self.create_chart_import()\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n            \"overwrite\": \"true\",\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 200\n        assert response == {\"message\": \"OK\"}\n\n        # clean up\n        database = (\n            db.session.query(Database).filter_by(uuid=database_config[\"uuid\"]).one()\n        )\n        dataset = database.tables[0]\n        chart = db.session.query(Slice).filter_by(uuid=chart_config[\"uuid\"]).one()\n\n        chart.owners = []\n        dataset.owners = []\n        db.session.delete(chart)\n        db.session.commit()\n        db.session.delete(dataset)\n        db.session.commit()\n        db.session.delete(database)\n        db.session.commit()\n\n    def test_import_chart_invalid(self):\n        \"\"\"\n        Chart API: Test import invalid chart\n        \"\"\"\n        self.login(username=\"admin\")\n        uri = \"api/v1/chart/import/\"\n\n        buf = BytesIO()\n        with ZipFile(buf, \"w\") as bundle:\n            with bundle.open(\"chart_export/metadata.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_metadata_config).encode())\n            with bundle.open(\n                \"chart_export/databases/imported_database.yaml\", \"w\"\n            ) as fp:\n                fp.write(yaml.safe_dump(database_config).encode())\n            with bundle.open(\"chart_export/datasets/imported_dataset.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(dataset_config).encode())\n            with bundle.open(\"chart_export/charts/imported_chart.yaml\", \"w\") as fp:\n                fp.write(yaml.safe_dump(chart_config).encode())\n        buf.seek(0)\n\n        form_data = {\n            \"formData\": (buf, \"chart_export.zip\"),\n        }\n        rv = self.client.post(uri, data=form_data, content_type=\"multipart/form-data\")\n        response = json.loads(rv.data.decode(\"utf-8\"))\n\n        assert rv.status_code == 422\n        assert response == {\n            \"errors\": [\n                {\n                    \"message\": \"Error importing chart\",\n                    \"error_type\": \"GENERIC_COMMAND_ERROR\",\n                    \"level\": \"warning\",\n                    \"extra\": {\n                        \"metadata.yaml\": {\"type\": [\"Must be equal to Slice.\"]},\n                        \"issue_codes\": [\n                            {\n                                \"code\": 1010,\n                                \"message\": (\n                                    \"Issue 1010 - Superset encountered an \"\n                                    \"error while running a command.\"\n                                ),\n                            }\n                        ],\n                    },\n                }\n            ]\n        }\n\n    def test_gets_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": True}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)\n\n    def test_gets_not_created_by_user_charts_filter(self):\n        arguments = {\n            \"filters\": [{\"col\": \"id\", \"opr\": \"chart_has_created_by\", \"value\": False}],\n            \"keys\": [\"none\"],\n            \"columns\": [\"slice_name\"],\n        }\n        self.login(username=\"admin\")\n\n        uri = f\"api/v1/chart/?q={prison.dumps(arguments)}\"\n        rv = self.get_assert_metric(uri, \"get_list\")\n        self.assertEqual(rv.status_code, 200)\n        data = json.loads(rv.data.decode(\"utf-8\"))\n        self.assertEqual(data[\"count\"], 8)", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
