{"index": 10119, "cve_id": "CVE-2022-46151", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Querybook is an open source data querying UI. In affected versions user provided data is not escaped in the error field of the auth callback url in `querybook/server/app/auth/oauth_auth.py` and `querybook/server/app/auth/okta_auth.py`. This may allow attackers to perform reflected cross site scripting (XSS) if Content Security Policy (CSP) is not enabled or `unsafe-inline` is allowed. Users are advised to upgrade to the latest, patched version of querybook (version 3.14.2 or greater). Users unable to upgrade may enable CSP and not allow unsafe-inline or manually escape query parameters in a reverse proxy.", "cvss": "6.1", "publish_date": "December 5, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "88a7f10495bf5ed1a556ade51a2f2794e403c063", "commit_message": "Merge pull request from GHSA-mrrw-9wf7-xq6w\n\nCo-authored-by: Lena <meowcodes@gmail.com>", "commit_date": "2022-11-28T22:01:09Z", "project": "pinterest/querybook", "url": "https://api.github.com/repos/pinterest/querybook/commits/88a7f10495bf5ed1a556ade51a2f2794e403c063", "html_url": "https://github.com/pinterest/querybook/commit/88a7f10495bf5ed1a556ade51a2f2794e403c063", "windows_before": [{"commit_id": "1b91cb8eef5e51ee1de7084a6e59d194c7978c07", "commit_date": "Tue Nov 22 14:29:22 2022 -0800", "commit_message": "fix: search and replace overlaps with lint status (#1088)", "files_name": ["querybook/webapp/components/QueryComposer/QueryComposer.scss"]}, {"commit_id": "a4ce07b233f7c38dad876a9a3d0075820ab9831b", "commit_date": "Fri Nov 18 15:08:09 2022 -0800", "commit_message": "feat: add helper task to auto disable unused workflows (#1082)", "files_name": ["querybook/notification_templates/schedule_disabled_notification.md", "querybook/server/tasks/disable_scheduled_docs.py"]}, {"commit_id": "9f1682f1f9983fa0fdbf7f226ce2f60d388d303b", "commit_date": "Fri Nov 18 14:40:29 2022 -0800", "commit_message": "feat: add filter support for api logging (#1084)", "files_name": ["querybook/server/lib/event_logger/__init__.py", "querybook/server/lib/event_logger/base_event_logger.py", "querybook/server/lib/event_logger/loggers/db_event_logger.py", "querybook/server/lib/event_logger/loggers/null_event_logger.py"]}, {"commit_id": "e7779a5237e3f4ea200363d555428b4b789e5a55", "commit_date": "Fri Nov 18 14:24:45 2022 -0800", "commit_message": "fix: load announcements only if the tab is active (#1085)", "files_name": ["querybook/webapp/components/Announcements/Announcements.tsx", "querybook/webapp/hooks/useInterval.ts"]}, {"commit_id": "37c9af1e067cb92bfc56ccf9d6c37197b9b40f21", "commit_date": "Tue Nov 15 12:32:22 2022 -0600", "commit_message": "fix: package.json & yarn.lock to reduce vulnerabilities (#1020)", "files_name": ["package.json", "yarn.lock"]}, {"commit_id": "920ad90615cf6831a4ba2e0cb6dc0d1cdf46fc68", "commit_date": "Tue Nov 15 12:30:46 2022 -0600", "commit_message": "fix: requirements/dev.txt to reduce vulnerabilities (#1081)", "files_name": ["requirements/dev.txt"]}, {"commit_id": "a7d8171be232b274a69cc9ab1f2d44a312aecb65", "commit_date": "Mon Nov 14 16:14:47 2022 -0800", "commit_message": "fix: relint on engine change + dont show lint when empty (#1077)", "files_name": ["querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.tsx", "querybook/webapp/components/QueryEditor/QueryEditor.tsx", "querybook/webapp/hooks/queryEditor/useLint.ts"]}, {"commit_id": "948830c5bcf75abfa5320be9bb3bf268d895f11c", "commit_date": "Mon Nov 14 12:38:29 2022 -0800", "commit_message": "fix: disable some api reqests from event logging (#1079)", "files_name": ["querybook/server/app/auth/__init__.py", "querybook/server/app/datasource.py", "querybook/server/datasources/user.py", "querybook/server/lib/event_logger/__init__.py"]}, {"commit_id": "66ba1ac2dbd39b93a81eb6fc7fda5913b2f3b440", "commit_date": "Wed Nov 9 16:33:48 2022 -0800", "commit_message": "feat: add event logging support (#1075)", "files_name": ["docs_website/docs/configurations/infra_config.md", "docs_website/docs/integrations/add_event_logger.md", "docs_website/docs/integrations/plugins.md", "docs_website/sidebars.json", "package.json", "plugins/event_logger_plugin/__init__.py", "querybook/config/querybook_default_config.yaml", "querybook/migrations/versions/2dc4b2f93081_add_event_logs.py", "querybook/server/app/datasource.py", "querybook/server/const/event_log.py", "querybook/server/env.py", "querybook/server/lib/event_logger/__init__.py", "querybook/server/lib/event_logger/all_event_loggers.py", "querybook/server/lib/event_logger/base_event_logger.py", "querybook/server/lib/event_logger/loggers/__init__.py", "querybook/server/lib/event_logger/loggers/console_event_logger.py", "querybook/server/lib/event_logger/loggers/db_event_logger.py", "querybook/server/lib/event_logger/loggers/null_event_logger.py", "querybook/server/models/__init__.py", "querybook/server/models/event_log.py", "querybook/server/tasks/db_clean_up_jobs.py"]}, {"commit_id": "0cbbb42d3949166e2ef16c5dce2a49a4bc8ec740", "commit_date": "Tue Nov 8 16:05:19 2022 -0500", "commit_message": "fix: Wrap or truncate long column types (#1070)", "files_name": ["querybook/webapp/components/DataTableViewColumn/DataTableColumnCard.scss", "querybook/webapp/components/DataTableViewMini/TablePanelView.tsx"]}, {"commit_id": "9db0e08f076e00c0179fd1058732936c828c1627", "commit_date": "Tue Nov 8 16:04:12 2022 -0500", "commit_message": "fix: Ensure DataDoc runs get tracked even if template rendering fails (#1073)", "files_name": ["querybook/server/tasks/run_datadoc.py"]}, {"commit_id": "b69217e7095112ba3181c1887c60b234f8c0279e", "commit_date": "Fri Nov 4 11:24:45 2022 -0700", "commit_message": "ui: fix notify me button (#1071)", "files_name": ["querybook/webapp/components/QueryExecutionBar/QueryExecutionNotificationButton.tsx"]}, {"commit_id": "6827e3eca6f17180523cb34a0c84a066a32af7f3", "commit_date": "Thu Nov 3 12:37:41 2022 -0400", "commit_message": "fix: Remove console.log (#1069)", "files_name": ["querybook/webapp/ui/OrderByButton/OrderByButton.tsx"]}, {"commit_id": "281cc5eb19e70a0db638f94414c13575b1b2bd7b", "commit_date": "Wed Nov 2 00:08:07 2022 -0700", "commit_message": "fix: schedule notification exception (#1067)", "files_name": ["querybook/server/lib/scheduled_datadoc/notification.py"]}, {"commit_id": "301c551df7888f88d27c6ad71a68d848043feb89", "commit_date": "Tue Nov 1 11:24:32 2022 -0700", "commit_message": "feat: add customized notification for scheduled datadoc (#1061)", "files_name": ["docs_website/docs/changelog/breaking_change.md", "package.json", "querybook/server/datasources/datadoc.py", "querybook/server/lib/notify/base_notifier.py", "querybook/server/lib/notify/notifier/email_notifier.py", "querybook/server/lib/notify/notifier/slack_notifier.py", "querybook/server/lib/notify/notifier/teams_notifier.py", "querybook/server/lib/notify/utils.py", "querybook/server/lib/scheduled_datadoc/legacy.py", "querybook/server/lib/scheduled_datadoc/notification.py", "querybook/server/lib/scheduled_datadoc/validator.py", "querybook/server/tasks/run_datadoc.py", "querybook/tests/test_lib/test_scheduled_datadoc/test_legacy.py", "querybook/webapp/components/DataDocRightSidebar/DataDocScheduleModal.tsx", "querybook/webapp/components/DataDocSchedule/DataDocScheduleForm.tsx", "querybook/webapp/components/UserSelect/MultiCreatableUserSelect.tsx", "querybook/webapp/const/schedule.ts", "querybook/webapp/lib/utils/react-select.ts", "querybook/webapp/redux/notificationService/types.ts"]}, {"commit_id": "022eaaeb8affdc167fd4e0b80b3f86d378d97b20", "commit_date": "Mon Oct 31 19:49:07 2022 +0200", "commit_message": "Feat: add schema filtering for table search (#996)", "files_name": ["querybook/server/datasources/metastore.py", "querybook/server/logic/metastore.py", "querybook/webapp/components/Search/SearchOverview.tsx", "querybook/webapp/components/Search/SearchSchemaSelect.tsx", "querybook/webapp/resource/search.ts"]}, {"commit_id": "0be51ec39a73728ba18c846f5bc10a1690be90cb", "commit_date": "Sun Oct 30 21:05:05 2022 -0700", "commit_message": "fix: Add sort_key and sort_order to table search (#1022)", "files_name": ["querybook/webapp/components/DataTableNavigator/DataTableNavigatorSearch.tsx", "querybook/webapp/components/DataTableNavigator/SchemaTableView/SchemaTableItem.tsx", "querybook/webapp/const/search.ts", "querybook/webapp/redux/dataTableSearch/action.ts", "querybook/webapp/redux/dataTableSearch/reducer.ts", "querybook/webapp/redux/dataTableSearch/types.ts", "querybook/webapp/ui/OrderByButton/OrderByButton.tsx"]}, {"commit_id": "0a0a53b378bade5d38ec6dee14e9fb72471f4145", "commit_date": "Fri Oct 28 11:42:15 2022 -0700", "commit_message": "fix: refactored useLint pipeline to be more hooks based (#1066)", "files_name": ["querybook/webapp/components/QueryEditor/QueryEditor.tsx", "querybook/webapp/hooks/queryEditor/useAutoComplete.ts", "querybook/webapp/hooks/queryEditor/useCodeAnalysis.ts", "querybook/webapp/hooks/queryEditor/useLint.ts"]}, {"commit_id": "2ba3372304c33abe7ec2ce46fc43fda543ddcb2a", "commit_date": "Wed Oct 26 18:52:42 2022 -0700", "commit_message": "fix: [dag exporter] remove use vairables (#1065)", "files_name": ["querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterListItem.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterSettings.tsx"]}, {"commit_id": "1a95889fedb16af3e9d759d30a6bf187e97dff8c", "commit_date": "Wed Oct 26 14:47:43 2022 -0700", "commit_message": "ui: update markdown code copy button (#1064)", "files_name": ["querybook/webapp/ui/Markdown/MarkdownCode.tsx"]}, {"commit_id": "27e03eaf49c3e1bcb4b162f4b8461a10d30f65b9", "commit_date": "Wed Oct 26 13:31:40 2022 -0700", "commit_message": "fix: only show supported query engines in the current env for dag exporter (#1063)", "files_name": ["querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterSettings.tsx"]}, {"commit_id": "fc521fe9ad262ec2b7f547ac47c8be17ec5f55d7", "commit_date": "Wed Oct 26 09:55:35 2022 -0700", "commit_message": "fix: SqlAutocompler setter not bind (#1062)", "files_name": ["package.json", "querybook/webapp/lib/sql-helper/sql-autocompleter.ts"]}, {"commit_id": "6d034d6a104b85bd738181dbbd9896c16f7bfa22", "commit_date": "Tue Oct 25 12:01:50 2022 -0700", "commit_message": "feat: dag exporter v2 (#1058)", "files_name": ["docs_website/docs/integrations/add_dag_exporter.md", "package.json", "querybook/server/datasources/dag_exporter.py", "querybook/server/lib/dag_exporter/all_dag_exporter.py", "querybook/server/lib/dag_exporter/base_dag_exporter.py", "querybook/server/lib/dag_exporter/export_dag.py", "querybook/server/lib/dag_exporter/exporters/demo_dag_exporter.py", "querybook/server/logic/admin.py", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporter.scss", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporter.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterButton.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterForm.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterGraph.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterListItem.tsx", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterSettings.tsx", "querybook/webapp/components/DataDocRightSidebar/DataDocRightSidebar.tsx", "querybook/webapp/const/datadoc.ts", "querybook/webapp/context/DataDocDAGExporter.ts", "querybook/webapp/hooks/dag/useExporterDAG.ts", "querybook/webapp/hooks/dag/useExporterSettings.ts", "querybook/webapp/hooks/dag/useSavedDAG.ts", "querybook/webapp/redux/dataDoc/action.ts", "querybook/webapp/redux/dataDoc/reducer.ts", "querybook/webapp/redux/dataDoc/types.ts", "querybook/webapp/resource/dataDoc.ts", "querybook/webapp/ui/FlowGraph/FlowGraph.scss", "querybook/webapp/ui/FlowGraph/FlowGraph.tsx", "querybook/webapp/ui/FlowGraph/GraphControls.tsx", "querybook/webapp/ui/FlowGraph/QueryCellNode.scss", "querybook/webapp/ui/FlowGraph/QueryCellNode.tsx", "querybook/webapp/ui/FlowGraph/helpers.ts", "querybook/webapp/ui/Modal/Modal.scss", "yarn.lock"]}, {"commit_id": "7db6d2a7a355311c21a1cb93e814ec51ea163171", "commit_date": "Tue Oct 25 11:10:28 2022 -0700", "commit_message": "refactor: Query editor linting (#1052)", "files_name": ["querybook/webapp/components/DataDoc/DataDoc.scss", "querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.scss", "querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.tsx", "querybook/webapp/components/QueryComposer/QueryComposer.tsx", "querybook/webapp/components/QueryEditor/QueryEditor.scss", "querybook/webapp/components/QueryEditor/QueryEditor.tsx", "querybook/webapp/components/QueryEngineStatusButton/QueryEngineStatusButton.scss", "querybook/webapp/components/QueryExecution/QueryError.tsx", "querybook/webapp/components/QueryRunButton/QueryRunButton.tsx", "querybook/webapp/components/QuerySnippetComposer/QuerySnippetComposer.tsx", "querybook/webapp/components/QuerySnippetInsertionModal/QuerySnippetView.tsx", "querybook/webapp/components/QueryView/QueryViewEditor.tsx", "querybook/webapp/components/TableUploader/TableUploaderConfirmForm.tsx", "querybook/webapp/hooks/queryEditor/useAutoComplete.ts", "querybook/webapp/hooks/queryEditor/useCodeAnalysis.ts", "querybook/webapp/hooks/queryEditor/useLint.ts", "querybook/webapp/stylesheets/_variables.scss", "querybook/webapp/ui/Icon/LucideIcons.ts"]}, {"commit_id": "6c4011f606af27af8aca44cbb5c1ceec14a7f1c9", "commit_date": "Mon Oct 24 16:31:28 2022 -0700", "commit_message": "fix: Update Google OAuth Version (#1057)", "files_name": [".github/workflows/pythontests.yml", "package.json", "requirements/exporter/gspread.txt", "requirements/platform/gcp.txt"]}, {"commit_id": "657f2a74fdd172a6d725ece3265d889b6cdb5ece", "commit_date": "Thu Oct 20 19:21:58 2022 -0700", "commit_message": "fix: template variable type change and big numbers (#1046)", "files_name": ["querybook/webapp/components/DataDocTemplateButton/DataDocTemplateVarForm.tsx", "querybook/webapp/components/DataDocTemplateButton/helpers.ts"]}], "windows_after": [{"commit_id": "0ab0d6d0229d56bba3e83b3e5e1f712d69a3ecd7", "commit_date": "Fri Dec 2 08:38:16 2022 +1300", "commit_message": "ui: fix execution date string (#1090)", "files_name": ["querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.scss", "querybook/webapp/components/ExecutionPicker/QueryExecutionPicker.tsx"]}, {"commit_id": "d945a68c92269a8f72a7b3331c2b186e2fcdb378", "commit_date": "Mon Dec 5 10:46:29 2022 -0800", "commit_message": "fix: remove the edge when the node is deleted in dag exporter (#1089)", "files_name": ["package.json", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporterGraph.tsx", "querybook/webapp/components/DataTableViewLineage/DataTableViewLineage.tsx", "querybook/webapp/const/datadoc.ts", "querybook/webapp/hooks/dag/useExporterDAG.ts", "querybook/webapp/hooks/dag/useSavedDAG.ts", "querybook/webapp/redux/dataDoc/action.ts", "querybook/webapp/resource/dataDoc.ts", "querybook/webapp/ui/FlowGraph/FlowGraph.tsx", "querybook/webapp/ui/FlowGraph/GraphControls.tsx", "querybook/webapp/ui/FlowGraph/LineageNode.tsx", "querybook/webapp/ui/FlowGraph/QueryCellNode.tsx", "querybook/webapp/ui/FlowGraph/RemovableEdge.tsx", "querybook/webapp/ui/FlowGraph/helpers.ts", "yarn.lock"]}, {"commit_id": "2f36f6b5ef1231017e4fddc32cef7c3125ae4610", "commit_date": "Mon Dec 5 15:33:16 2022 -0800", "commit_message": "chore: bump version to 3.14.2 for CVE (#1093)", "files_name": ["package.json"]}, {"commit_id": "676320fd21c800d46e062d7d83e443f84a512673", "commit_date": "Mon Dec 5 17:47:01 2022 -0800", "commit_message": "docs: add security advisory info (#1094)", "files_name": ["docs_website/docs/changelog/security_advisories.md", "docs_website/sidebars.json"]}, {"commit_id": "8b5b78faa35bb2f6dfe7ebef7b3807af4befc3d3", "commit_date": "Tue Dec 6 09:25:23 2022 -0800", "commit_message": "fix: notify_user need to accept user not uid (#1095)", "files_name": ["querybook/notification_templates/schedule_disabled_notification.md", "querybook/server/tasks/disable_scheduled_docs.py"]}, {"commit_id": "a18cc93b49674b0d923ee32b724942cf194ad629", "commit_date": "Wed Dec 7 15:24:42 2022 -0800", "commit_message": "fix: sidebar search should use relevance instead of alphabetical (#1096)", "files_name": [".pre-commit-config.yaml", "package.json", "querybook/webapp/components/DataTableNavigator/DataTableNavigatorSearch.tsx", "querybook/webapp/components/DataTableNavigator/SchemaTableView/SchemaTableItem.tsx", "querybook/webapp/const/metastore.ts", "querybook/webapp/redux/dataTableSearch/action.ts", "querybook/webapp/redux/dataTableSearch/const.ts", "querybook/webapp/redux/dataTableSearch/reducer.ts"]}, {"commit_id": "12520df94c9a1543d9a6e726da4c009874ea8e5f", "commit_date": "Wed Dec 7 16:50:13 2022 -0800", "commit_message": "fix: remove python-dev from dockerfile build (#1098)", "files_name": [".github/workflows/pythontests.yml", "Dockerfile", "querybook/server/app/flask_app.py"]}, {"commit_id": "d75c1d1d7089843465f6ecb0a6eb26b67b43c241", "commit_date": "Wed Dec 7 18:47:26 2022 -0800", "commit_message": "fix: boost table score for exact match when searching table (#1097)", "files_name": ["querybook/server/lib/elasticsearch/search_table.py", "querybook/webapp/redux/dataTableSearch/action.ts"]}, {"commit_id": "9d684187183e5d6097645b321c6371c1eb5382df", "commit_date": "Thu Dec 8 10:32:09 2022 -0800", "commit_message": "Tune exact match boost score of table search (#1099)", "files_name": ["querybook/server/lib/elasticsearch/search_table.py"]}, {"commit_id": "7b129608d87749525d6aa85cd715cf1a806ab9a7", "commit_date": "Wed Dec 14 10:53:51 2022 -0800", "commit_message": "fix: scheduled docs with latest_partition fail to run (#1101)", "files_name": ["querybook/server/lib/query_analysis/templating.py", "querybook/server/tasks/run_datadoc.py"]}, {"commit_id": "6435bc1c5f5d9a4c5a9f62d7d0c451292f9d5516", "commit_date": "Thu Dec 15 17:13:20 2022 -0800", "commit_message": "fix: hasOwnProperty is not a function issue from json-big (#1103)", "files_name": ["package.json", "querybook/webapp/lib/query-result/transformer.tsx"]}, {"commit_id": "b80b48c6d13fc763d723bd91c9466d1fbac170c6", "commit_date": "Fri Dec 16 13:19:53 2022 -0800", "commit_message": "feat: add support of running all cells of a data doc (#1102)", "files_name": ["package.json", "querybook/server/datasources/datadoc.py", "querybook/server/lib/notify/utils.py", "querybook/server/tasks/run_datadoc.py", "querybook/webapp/components/DataDocDAGExporter/DataDocDAGExporter.tsx", "querybook/webapp/components/DataDocRightSidebar/DataDocRightSidebar.tsx", "querybook/webapp/components/DataDocRightSidebar/DataDocRunAllButton.tsx", "querybook/webapp/hooks/dag/useExporterDAG.ts", "querybook/webapp/hooks/dataDoc/useQueryCells.ts", "querybook/webapp/redux/queryExecutions/selector.ts", "querybook/webapp/resource/dataDoc.ts"]}, {"commit_id": "1527ff3e83799bf6b95d87718e13bae75b22df9d", "commit_date": "Mon Dec 19 10:53:21 2022 -0800", "commit_message": "feat: add logout event hook (#1104)", "files_name": ["package.json", "querybook/server/app/auth/__init__.py", "querybook/server/lib/event_logger/__init__.py", "querybook/webapp/components/SessionExpirationNotice/SessionExpirationNotice.tsx"]}, {"commit_id": "03ccdb5800a5be2b83c4c7d787bdf65cfc77545f", "commit_date": "Tue Dec 20 11:46:16 2022 -0800", "commit_message": "Add 2022 change logs (#1105)", "files_name": ["docs_website/docs/changelog/2022-12-20.md", "docs_website/sidebars.json", "querybook/static/changelog/20221220/columnfiltering.png", "querybook/static/changelog/20221220/dag1.png", "querybook/static/changelog/20221220/dag2.png", "querybook/static/changelog/20221220/dag3.png", "querybook/static/changelog/20221220/eventlogging.png", "querybook/static/changelog/20221220/listv2.png", "querybook/static/changelog/20221220/metastore.png", "querybook/static/changelog/20221220/notification1.png", "querybook/static/changelog/20221220/notification2.png", "querybook/static/changelog/20221220/querylimit.png", "querybook/static/changelog/20221220/querysearch.png", "querybook/static/changelog/20221220/resultpreview1.png", "querybook/static/changelog/20221220/resultpreview2.png", "querybook/static/changelog/20221220/runall.png", "querybook/static/changelog/20221220/scheduled1.png", "querybook/static/changelog/20221220/scheduled2.png", "querybook/static/changelog/20221220/scheduled3.png", "querybook/static/changelog/20221220/syntax.png", "querybook/static/changelog/20221220/tableupload1.png", "querybook/static/changelog/20221220/tableupload2.png", "querybook/static/changelog/20221220/tableupload3.png", "querybook/static/changelog/20221220/tableupload4.png", "querybook/static/changelog/20221220/tableupload5.png", "querybook/static/changelog/20221220/tag1.png", "querybook/static/changelog/20221220/tag2.png", "querybook/static/changelog/20221220/tag3.png", "querybook/static/changelog/20221220/transpile1.png", "querybook/static/changelog/20221220/transpile2.png", "querybook/static/changelog/20221220/udf1.png", "querybook/static/changelog/20221220/udf2.png"]}, {"commit_id": "d543644af31618b301a0919556051d20a636628d", "commit_date": "Tue Dec 20 11:58:11 2022 -0800", "commit_message": "feat: Make exact table search result auto show up (#1106)", "files_name": ["querybook/webapp/components/DataDocSchemaNavigator/DataDocSchemaNavigator.scss", "querybook/webapp/components/DataDocSchemaNavigator/DataDocSchemaNavigator.tsx", "querybook/webapp/hooks/table/useExactMatchTableId.ts"]}, {"commit_id": "6bbbc8fbca44141afae2166d3af7f15accdb9887", "commit_date": "Wed Dec 21 10:48:21 2022 -0800", "commit_message": "feat: Add shortcut for toggle ToC, update datadoc short cuts (#1107)", "files_name": ["package.json", "querybook/webapp/components/DataDoc/DataDoc.tsx", "querybook/webapp/components/DataDocCell/DataDocCell.tsx", "querybook/webapp/components/DataDocChartCell/DataDocChartCell.tsx", "querybook/webapp/components/DataDocLeftSidebar/DataDocLeftSidebar.tsx", "querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.tsx", "querybook/webapp/components/DataDocTextCell/DataDocTextCell.tsx", "querybook/webapp/const/keyMap.ts", "querybook/webapp/context/DataDoc.ts", "querybook/webapp/lib/data-doc/data-doc-utils.ts"]}, {"commit_id": "d1633c0fd5e8ce5f1a9ecb66a844f46373aa007b", "commit_date": "Wed Dec 21 17:31:02 2022 -0800", "commit_message": "fix: Chart date axis bug (#1108)", "files_name": ["package.json", "querybook/webapp/const/dataDocChart.ts", "querybook/webapp/lib/chart/chart-data-processing.ts", "querybook/webapp/lib/chart/chart-meta-processing.ts", "querybook/webapp/lib/chart/chart-utils.ts"]}, {"commit_id": "d2c1f09218e62993fdc53c5e87d70e9b97eb35f4", "commit_date": "Thu Dec 22 11:06:10 2022 -0800", "commit_message": "feat: auto add quotes for table/columns (#1109)", "files_name": ["querybook/webapp/components/QueryEditor/QueryEditor.tsx", "querybook/webapp/hooks/queryEditor/useAutoComplete.ts", "querybook/webapp/lib/sql-helper/sql-autocompleter.ts", "querybook/webapp/lib/sql-helper/sql-setting.ts"]}, {"commit_id": "b6eec5a99618cd5ea20a7f66274e85509c7569c5", "commit_date": "Thu Dec 22 12:06:59 2022 -0800", "commit_message": "feat: add websocket logging (#1110)", "files_name": ["package.json", "querybook/server/const/event_log.py", "querybook/server/datasources_socketio/helper.py", "querybook/server/lib/event_logger/__init__.py", "querybook/server/lib/event_logger/base_event_logger.py"]}, {"commit_id": "3ca3686cb90ed8952ad154697dbcc5488d79338d", "commit_date": "Thu Dec 22 13:45:31 2022 -0800", "commit_message": "fix: update event_log table schema (#1111)", "files_name": ["querybook/migrations/versions/63bde0162416_update_event_type_in_event_log_table.py"]}, {"commit_id": "24652a38260f4b68c114f0aed2f22bdca67853aa", "commit_date": "Fri Dec 23 13:19:39 2022 -0800", "commit_message": "feat: add drag and drop for templated variables (#1112)", "files_name": ["package.json", "querybook/server/datasources/query_execution.py", "querybook/server/lib/dag_exporter/export_dag.py", "querybook/server/lib/data_doc/doc_types.py", "querybook/server/lib/data_doc/meta.py", "querybook/server/logic/datadoc.py", "querybook/server/models/datadoc.py", "querybook/server/tasks/run_datadoc.py", "querybook/webapp/components/DataDoc/DataDoc.tsx", "querybook/webapp/components/DataDocCell/DataDocCell.tsx", "querybook/webapp/components/DataDocQueryCell/DataDocQueryCell.tsx", "querybook/webapp/components/DataDocRightSidebar/DataDocRightSidebar.tsx", "querybook/webapp/components/DataDocTemplateButton/DataDocTemplateButton.tsx", "querybook/webapp/components/DataDocTemplateButton/DataDocTemplateCell.tsx", "querybook/webapp/components/DataDocTemplateButton/DataDocTemplateVarForm.tsx", "querybook/webapp/components/DataDocTemplateButton/helpers.ts", "querybook/webapp/components/QueryComposer/QueryComposer.tsx", "querybook/webapp/components/QueryComposer/RunQuery.tsx", "querybook/webapp/components/QuerySnippetInsertionModal/QuerySnippetInsertionModal.tsx", "querybook/webapp/components/QuerySnippetInsertionModal/QuerySnippetView.tsx", "querybook/webapp/components/TemplateQueryView/TemplatedQueryView.tsx", "querybook/webapp/const/adhocQuery.ts", "querybook/webapp/const/datadoc.ts", "querybook/webapp/lib/templated-query/index.ts", "querybook/webapp/redux/dataDoc/types.ts", "querybook/webapp/resource/queryExecution.ts", "querybook/webapp/ui/DraggableList/DraggableIcon.scss", "querybook/webapp/ui/DraggableList/DraggableIcon.tsx", "querybook/webapp/ui/Icon/LucideIcons.ts", "yarn.lock"]}, {"commit_id": "003331485824bd6b503346890049674600d22f88", "commit_date": "Fri Dec 23 16:57:35 2022 -0800", "commit_message": "feat: a bunch of small ui fixes and improvements (#1114)", "files_name": ["querybook/webapp/components/DataDoc/DataDoc.tsx", "querybook/webapp/components/DataDocNavigator/DataDocGridItem.scss", "querybook/webapp/components/DataTableViewColumn/DataTableColumnCard.tsx", "querybook/webapp/components/DataTableViewOverview/DataTableViewOverview.tsx", "querybook/webapp/components/DataTableViewQueryExample/DataTableViewQueryExamples.scss", "querybook/webapp/components/DataTableViewQueryExample/DataTableViewQueryExamples.tsx", "querybook/webapp/components/EnvironmentAppSidebar/EnvironmentAppSidebar.tsx", "querybook/webapp/const/chartColors.ts"]}], "parents": [{"commit_id_before": "1b91cb8eef5e51ee1de7084a6e59d194c7978c07", "url_before": "https://api.github.com/repos/pinterest/querybook/commits/1b91cb8eef5e51ee1de7084a6e59d194c7978c07", "html_url_before": "https://github.com/pinterest/querybook/commit/1b91cb8eef5e51ee1de7084a6e59d194c7978c07"}], "details": [{"raw_url": "https://github.com/pinterest/querybook/raw/88a7f10495bf5ed1a556ade51a2f2794e403c063/querybook%2Fserver%2Fapp%2Fauth%2Foauth_auth.py", "code": "import certifi\nimport requests\n\n\nfrom flask import Markup, request, session as flask_session, redirect\nimport flask_login\nfrom requests_oauthlib import OAuth2Session\n\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings\nfrom lib.logger import get_logger\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import (\n    AuthenticationError,\n    AuthUser,\n    abort_unauthorized,\n    QuerybookLoginManager,\n)\n\nLOG = get_logger(__file__)\n\nOAUTH_CALLBACK_PATH = \"/oauth2callback\"\n\n\nclass OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OAuthLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n\n\ndef oauth_authorization_url():\n    return login_manager._get_authn_url()\n", "code_before": "import certifi\nimport requests\n\n\nfrom flask import request, session as flask_session, redirect\nimport flask_login\nfrom requests_oauthlib import OAuth2Session\n\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings\nfrom lib.logger import get_logger\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import (\n    AuthenticationError,\n    AuthUser,\n    abort_unauthorized,\n    QuerybookLoginManager,\n)\n\nLOG = get_logger(__file__)\n\nOAUTH_CALLBACK_PATH = \"/oauth2callback\"\n\n\nclass OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OAuthLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n\n\ndef oauth_authorization_url():\n    return login_manager._get_authn_url()\n", "patch": "@@ -2,7 +2,7 @@\n import requests\n \n \n-from flask import request, session as flask_session, redirect\n+from flask import Markup, request, session as flask_session, redirect\n import flask_login\n from requests_oauthlib import OAuth2Session\n \n@@ -75,7 +75,7 @@ def oauth_callback(self):\n         LOG.debug(\"Handling Oauth callback...\")\n \n         if request.args.get(\"error\"):\n-            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n+            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n \n         code = request.args.get(\"code\")\n         try:", "file_path": "files/2022_12/1746", "file_language": "py", "file_name": "querybook/server/app/auth/oauth_auth.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.injection.raw-html-concat.raw-html-format                                \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`flask.render_template`) which will safely render HTML instead.                  \n          Details: https://sg.run/Pb7e                                                                \n           78\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\"", "       python.django.security.injection.raw-html-format.raw-html-format                               \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`django.shortcuts.render`) which will safely render HTML instead.                \n          Details: https://sg.run/oYj1                                                                \n\n           78\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\"", "       python.flask.security.audit.directly-returned-format-string.directly-returned-format-string    \n          Detected Flask route directly returning a formatted string. This is subject to cross-site   \n          scripting if user input can reach the string. Consider using the template engine instead and\n          rendering pages with 'render_template()'.                                                   \n          Details: https://sg.run/Zv6o                                                                \n\n           78\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\""]]}, "target": 1, "function_before": [{"function": "class OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user", "target": 1, "line": "@@  -75,7 +75,7  @@ def oauth_callback(self):\n         LOG.debug(\"Handling Oauth callback...\")\n \n         if request.args.get(\"error\"):\n-            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n+            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n \n         code = request.args.get(\"code\")\n         try:"}, {"function": "def init_app(app):\n    login_manager.init_app(app)", "target": 0}, {"function": "def login(request):\n    return login_manager.login(request)", "target": 0}, {"function": "def oauth_authorization_url():\n    return login_manager._get_authn_url()", "target": 0}], "function_after": [{"function": "class OAuthLoginManager(object):\n    def __init__(self):\n        self.login_manager = QuerybookLoginManager()\n        self.flask_app = None\n\n    @property\n    def oauth_session(self):\n        oauth_config = self.oauth_config\n        return OAuth2Session(\n            oauth_config[\"client_id\"],\n            scope=oauth_config[\"scope\"],\n            redirect_uri=oauth_config[\"callback_url\"],\n        )\n\n    @property\n    def oauth_config(self):\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": QuerybookSettings.OAUTH_AUTHORIZATION_URL,\n            \"token_url\": QuerybookSettings.OAUTH_TOKEN_URL,\n            \"profile_url\": QuerybookSettings.OAUTH_USER_PROFILE,\n            \"scope\": \"user\",\n        }\n\n    def init_app(self, flask_app):\n        self.flask_app = flask_app\n\n        self.login_manager.init_app(self.flask_app)\n        self.flask_app.add_url_rule(\n            OAUTH_CALLBACK_PATH, \"oauth_callback\", self.oauth_callback\n        )\n\n    def login(self, request):\n        oauth_url, _ = self._get_authn_url()\n        flask_session[\"next\"] = request.path\n        return redirect(oauth_url)\n\n    def _get_authn_url(self):\n        return self.oauth_session.authorization_url(\n            self.oauth_config[\"authorization_url\"]\n        )\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(self.login_user(username, email, session=session))\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def _parse_user_profile(self, profile_response):\n        user = profile_response.json()[\"user\"]\n        return user[\"username\"], user[\"email\"]\n\n    @with_session\n    def login_user(self, username, email, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=username, email=email, session=session\n            )\n        return user", "target": 0}, {"function": "def init_app(app):\n    login_manager.init_app(app)", "target": 0}, {"function": "def login(request):\n    return login_manager.login(request)", "target": 0}, {"function": "def oauth_authorization_url():\n    return login_manager._get_authn_url()", "target": 0}]}, {"raw_url": "https://github.com/pinterest/querybook/raw/88a7f10495bf5ed1a556ade51a2f2794e403c063/querybook%2Fserver%2Fapp%2Fauth%2Fokta_auth.py", "code": "import certifi\nimport requests\nimport flask_login\n\nfrom app.auth.oauth_auth import OAuthLoginManager, OAUTH_CALLBACK_PATH\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings, get_env_config\nfrom flask import Markup, request, session as flask_session, redirect\nfrom lib.logger import get_logger\nfrom lib.utils.decorators import in_mem_memoized\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import AuthenticationError, abort_unauthorized, AuthUser\n\nLOG = get_logger(__file__)\n\n\nclass NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r\n\n\nclass OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OktaLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n", "code_before": "import certifi\nimport requests\nimport flask_login\n\nfrom app.auth.oauth_auth import OAuthLoginManager, OAUTH_CALLBACK_PATH\nfrom app.db import with_session, DBSession\nfrom env import QuerybookSettings, get_env_config\nfrom flask import request, session as flask_session, redirect\nfrom lib.logger import get_logger\nfrom lib.utils.decorators import in_mem_memoized\nfrom logic.user import (\n    get_user_by_name,\n    create_user,\n)\nfrom .utils import AuthenticationError, abort_unauthorized, AuthUser\n\nLOG = get_logger(__file__)\n\n\nclass NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r\n\n\nclass OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user\n\n\nlogin_manager = OktaLoginManager()\n\nignore_paths = [OAUTH_CALLBACK_PATH]\n\n\ndef init_app(app):\n    login_manager.init_app(app)\n\n\ndef login(request):\n    return login_manager.login(request)\n", "patch": "@@ -5,7 +5,7 @@\n from app.auth.oauth_auth import OAuthLoginManager, OAUTH_CALLBACK_PATH\n from app.db import with_session, DBSession\n from env import QuerybookSettings, get_env_config\n-from flask import request, session as flask_session, redirect\n+from flask import Markup, request, session as flask_session, redirect\n from lib.logger import get_logger\n from lib.utils.decorators import in_mem_memoized\n from logic.user import (\n@@ -85,7 +85,7 @@ def oauth_callback(self):\n         LOG.debug(\"Handling Oauth callback...\")\n \n         if request.args.get(\"error\"):\n-            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n+            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n \n         code = request.args.get(\"code\")\n         try:", "file_path": "files/2022_12/1747", "file_language": "py", "file_name": "querybook/server/app/auth/okta_auth.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.injection.raw-html-concat.raw-html-format                                \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`flask.render_template`) which will safely render HTML instead.                  \n          Details: https://sg.run/Pb7e                                                                \n           88\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\"", "       python.django.security.injection.raw-html-format.raw-html-format                               \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`django.shortcuts.render`) which will safely render HTML instead.                \n          Details: https://sg.run/oYj1                                                                \n\n           88\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\"", "       python.flask.security.audit.directly-returned-format-string.directly-returned-format-string    \n          Detected Flask route directly returning a formatted string. This is subject to cross-site   \n          scripting if user input can reach the string. Consider using the template engine instead and\n          rendering pages with 'render_template()'.                                                   \n          Details: https://sg.run/Zv6o                                                                \n\n           88\u2506 return f\"<h1>Error: {request.args.get('error')}</h1>\""]]}, "target": 1, "function_before": [{"function": "class NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r", "target": 0}, {"function": "class OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user", "target": 1, "line": "@@  -85,7 +85,7  @@ def oauth_callback(self):\n         LOG.debug(\"Handling Oauth callback...\")\n \n         if request.args.get(\"error\"):\n-            return f\"<h1>Error: {request.args.get('error')}</h1>\"\n+            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n \n         code = request.args.get(\"code\")\n         try:"}, {"function": "def init_app(app):\n    login_manager.init_app(app)", "target": 0}, {"function": "def login(request):\n    return login_manager.login(request)", "target": 0}], "function_after": [{"function": "class NoopAuth(requests.auth.AuthBase):\n    \"\"\"\n    This auth doesn't do anything.\n    It only used to override oauthlib's behavior.\n    \"\"\"\n\n    def __call__(self, r):\n        return r", "target": 0}, {"function": "class OktaLoginManager(OAuthLoginManager):\n    def get_okta_urls(self):\n        okta_base_url = get_env_config(\"OKTA_BASE_URL\")\n        authorization_url = f\"{okta_base_url}/v1/authorize\"\n        token_url = f\"{okta_base_url}/v1/token\"\n        profile_url = f\"{okta_base_url}/v1/userinfo\"\n        return authorization_url, token_url, profile_url\n\n    @property\n    @in_mem_memoized()\n    def oauth_config(self):\n        authorization_url, token_url, profile_url = self.get_okta_urls()\n\n        return {\n            \"callback_url\": \"{}{}\".format(\n                QuerybookSettings.PUBLIC_URL, OAUTH_CALLBACK_PATH\n            ),\n            \"client_id\": QuerybookSettings.OAUTH_CLIENT_ID,\n            \"client_secret\": QuerybookSettings.OAUTH_CLIENT_SECRET,\n            \"authorization_url\": authorization_url,\n            \"token_url\": token_url,\n            \"profile_url\": profile_url,\n            \"scope\": [\"openid\", \"email\", \"profile\"],\n        }\n\n    def _fetch_access_token(self, code):\n        resp = self.oauth_session.fetch_token(\n            token_url=self.oauth_config[\"token_url\"],\n            client_id=self.oauth_config[\"client_id\"],\n            code=code,\n            client_secret=self.oauth_config[\"client_secret\"],\n            cert=certifi.where(),\n            # This Authentication is needed because Okta would throw error\n            # about passing client_secret and client_id in request.header\n            # which is the default behavior of oauthlib\n            auth=NoopAuth(),\n        )\n        if resp is None:\n            raise AuthenticationError(\"Null response, denying access.\")\n        return resp[\"access_token\"]\n\n    def _get_user_profile(self, access_token):\n        resp = requests.get(\n            self.oauth_config[\"profile_url\"],\n            headers={\"Authorization\": \"Bearer {}\".format(access_token)},\n        )\n        if not resp or resp.status_code != 200:\n            raise AuthenticationError(\n                \"Failed to fetch user profile, status ({0})\".format(\n                    resp.status if resp else \"None\"\n                )\n            )\n        return self._parse_user_profile(resp)\n\n    def oauth_callback(self):\n        LOG.debug(\"Handling Oauth callback...\")\n\n        if request.args.get(\"error\"):\n            return f\"<h1>Error: { Markup.escape(request.args.get('error')) }</h1>\"\n\n        code = request.args.get(\"code\")\n        try:\n            access_token = self._fetch_access_token(code)\n            username, email, fullname = self._get_user_profile(access_token)\n            with DBSession() as session:\n                flask_login.login_user(\n                    AuthUser(\n                        self.login_user(username, email, fullname, session=session)\n                    )\n                )\n        except AuthenticationError as e:\n            LOG.error(\"Failed authenticate oauth user\", e)\n            abort_unauthorized()\n\n        next_url = QuerybookSettings.PUBLIC_URL\n        if \"next\" in flask_session:\n            next_url = flask_session[\"next\"]\n            del flask_session[\"next\"]\n\n        return redirect(next_url)\n\n    def _parse_user_profile(self, resp):\n        user = resp.json()\n        username = user[\"email\"].split(\"@\")[0]\n        return username, user[\"email\"], user[\"name\"]\n\n    @with_session\n    def login_user(self, username, email, fullname, session=None):\n        if not username:\n            raise AuthenticationError(\"Username must not be empty!\")\n\n        user = get_user_by_name(username, session=session)\n        if not user:\n            user = create_user(\n                username=username, fullname=fullname, email=email, session=session\n            )\n        return user", "target": 0}, {"function": "def init_app(app):\n    login_manager.init_app(app)", "target": 0}, {"function": "def login(request):\n    return login_manager.login(request)", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
