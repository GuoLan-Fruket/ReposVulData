{"index": 35, "cve_id": "CVE-2011-4312", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Multiple cross-site scripting (XSS) vulnerabilities in the commenting system in Review Board before 1.5.7 and 1.6.x before 1.6.3 allow remote attackers to inject arbitrary web script or HTML via vectors involving the (1) diff viewer or (2) screenshot component.", "cvss": "3.7", "publish_date": "November 23, 2011", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "7a0a9d94555502278534dedcf2d75e9fccce8c3d", "commit_message": "Fix a comment vulnerability allowing scripts to be loaded.\n\nDue to the way that comments were loaded in, it was possible to\nterminate a script and inject a new one while loading the diff viewer.\nThis isn't believed to have been a problem in the wild, but is certainly\nan important one to fix.\n\nWe now ensure that the text is escaped at the point where it's being fed\ninto the JavaScript. It's no longer possible to inject scripts.\n\nThanks to Damian Johnson for the heads up and for the fix that this\nchange is based on.\n\nThis will be going into 1.5.7 and 1.6.3 releases.", "commit_date": "2011-11-15T10:46:40Z", "project": "reviewboard/reviewboard", "url": "https://api.github.com/repos/reviewboard/reviewboard/commits/7a0a9d94555502278534dedcf2d75e9fccce8c3d", "html_url": "https://github.com/reviewboard/reviewboard/commit/7a0a9d94555502278534dedcf2d75e9fccce8c3d", "windows_before": [{"commit_id": "238e9a42bddd0c290a00fc76a3e0b7f941207a20", "commit_date": "Sun Nov 13 14:56:21 2011 -0800", "commit_message": "Fix the location that reviewboard.db is stored in when running prepare-dev.", "files_name": ["contrib/internal/prepare-dev.py"]}, {"commit_id": "50266decdd68586637f0f74363352fd46cec8443", "commit_date": "Thu Nov 10 02:34:32 2011 -0800", "commit_message": "Update the docs database for the latest schema changes.", "files_name": ["docs/manual/docs.db"]}, {"commit_id": "0174575b187f52c769976b49618232f0c2298585", "commit_date": "Thu Nov 10 02:19:33 2011 -0800", "commit_message": "Fix a critical issue causing the Django Evolution entries to be wiped.", "files_name": ["reviewboard/admin/management/evolutions.py"]}, {"commit_id": "457a1f6b24f4a18ac7ff8e5a1e61ed13ebe955c2", "commit_date": "Thu Nov 10 01:51:16 2011 -0800", "commit_message": "Ensure creation of the ext directory for the docs media.", "files_name": ["docs/manual/data/htdocs/media/ext/.gitignore"]}, {"commit_id": "9c3c4c3055c3559e44bca90617112159535c2ae4", "commit_date": "Thu Nov 10 01:43:03 2011 -0800", "commit_message": "Add a media/ext/ directory by default.", "files_name": ["reviewboard/htdocs/media/ext/.gitignore"]}, {"commit_id": "09ad4bc480ed9dccb333b3b3017ef6645675942f", "commit_date": "Thu Nov 10 01:40:42 2011 -0800", "commit_message": "Display the actual error when importing from settings.", "files_name": ["reviewboard/manage.py"]}, {"commit_id": "aee18270ed495394709a3eb47ba0f6da47e492d9", "commit_date": "Thu Nov 10 01:40:03 2011 -0800", "commit_message": "Fix property usage on Python 2.5.", "files_name": ["reviewboard/diffviewer/models.py"]}, {"commit_id": "39d8cc35710a4f48322717753c0e3ffe7b3e2fde", "commit_date": "Thu Nov 10 01:37:55 2011 -0800", "commit_message": "Fix a syntax error on Python 2.5 with the \"with\" statement.", "files_name": ["reviewboard/diffviewer/diffutils.py"]}, {"commit_id": "8800e676356f8de9db6796cf0d9512173aafbf72", "commit_date": "Thu Nov 10 00:01:38 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["4cd62a5ac30b70aa11e0e38a83d2c18eea8d1ea7 - Wed Nov 9 23:50:51 2011 -0800 : Release Review Board 1.6.2.", "AUTHORS", "docs/releasenotes/reviewboard/1.6.2.txt", "docs/releasenotes/reviewboard/index.txt", "reviewboard/__init__.py", "setup.py"]}, {"commit_id": "728ffc280304d64f82f6d1a775d879d247957d73", "commit_date": "Wed Nov 9 23:31:57 2011 -0800", "commit_message": "Fix the filename for the \"New Updates\" favicon.", "files_name": ["reviewboard/htdocs/media/rb/images/favicon_notify.ico"]}, {"commit_id": "ba04b42fdfff87609586073792cc8722b480a693", "commit_date": "Sun Nov 6 14:06:29 2011 -0800", "commit_message": "Add a couple missing files from the diff hash change.", "files_name": ["reviewboard/diffviewer/evolutions/add_diff_hash.py", "reviewboard/diffviewer/managers.py"]}, {"commit_id": "46c0818b0c4c48d6bdf78eae1e4bd763189ac7b0", "commit_date": "Sun Nov 6 12:47:22 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["54eadf09fc51beae24aa76a18409bf8f4fbaa525 - Sun Oct 16 03:18:01 2011 -0700 : Make use of Djblets's new jquery templates.", "reviewboard/templates/admin/authentication_settings.html", "reviewboard/templates/admin/dashboard.html", "reviewboard/templates/admin/scmtools/repository/change_form.html", "reviewboard/templates/admin/storage_settings.html", "reviewboard/templates/base.html"]}, {"commit_id": "dbb92c61c7940c8d9c6880c1792c4236ca4e5497", "commit_date": "Sun Oct 16 03:11:58 2011 -0700", "commit_message": "Hard-code our jQuery and jQuery UI requirements for 1.6.", "files_name": ["reviewboard/htdocs/media/rb/js/jquery-1.3.2.min.js", "reviewboard/htdocs/media/rb/js/jquery-ui-1.6rc5.min.js", "reviewboard/templates/js/jquery-ui.html", "reviewboard/templates/js/jquery.html"]}, {"commit_id": "7b44a919c119da2221cecb54c0b31adadffdde7a", "commit_date": "Sun Nov 6 12:41:27 2011 -0800", "commit_message": "Make use of Djblets's new jquery templates.", "files_name": ["reviewboard/templates/admin/authentication_settings.html", "reviewboard/templates/admin/scmtools/repository/change_form.html", "reviewboard/templates/admin/storage_settings.html", "reviewboard/templates/base.html"]}, {"commit_id": "cf9a98e28f51647ad8d0d2c185ea734cc8b4994e", "commit_date": "Sun Nov 6 12:37:20 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["69b87451dd182f26179b6c83764bbe5f80c2010b - Sun Nov 6 12:36:58 2011 -0800 : Add Erik Johansson and Chris Tandiono to the AUTHORS list.", "AUTHORS"]}, {"commit_id": "5b45eb9736461c8a4e0ba13c864dbdeaf7ae7b98", "commit_date": "Sun Nov 6 12:20:15 2011 -0800", "commit_message": "Fix the spinner image location for the admin news widget.", "files_name": ["reviewboard/templates/admin/widgets/w-news.html"]}, {"commit_id": "90b4e9ecaa180d545b3870dbbdf86621089c6b41", "commit_date": "Fri Sep 23 13:20:08 2011 -0700", "commit_message": "Be explicit in the permissions we expect for htdocs in new configs.", "files_name": ["reviewboard/cmdline/conf/apache-fastcgi.conf.in", "reviewboard/cmdline/conf/apache-modpython.conf.in", "reviewboard/cmdline/conf/apache-wsgi.conf.in"]}, {"commit_id": "565b9f1bf5b2662181b4121a80af9a9f12353da6", "commit_date": "Sun Nov 6 12:08:00 2011 -0800", "commit_message": "Mark generated e-mails with 'auto-generated' according to RFC 3834.", "files_name": ["AUTHORS", "reviewboard/notifications/email.py"]}, {"commit_id": "3a69a29def13b3c7ac9be88552a155dc771934aa", "commit_date": "Sun Nov 6 12:06:45 2011 -0800", "commit_message": "Add Dave Druska to the AUTHORS list.", "files_name": ["AUTHORS"]}, {"commit_id": "8bfea519171d209d9d8c52c203863d07726f2817", "commit_date": "Sun Nov 6 12:05:00 2011 -0800", "commit_message": "Reduce diff storage by hashing diff uploads", "files_name": ["reviewboard/diffviewer/evolutions/__init__.py", "reviewboard/diffviewer/models.py", "reviewboard/diffviewer/tests.py", "reviewboard/reviews/fixtures/test_reviewrequests.json"]}, {"commit_id": "03f1f3ab1781ce25627d7b37810988afcb1b4315", "commit_date": "Sat Oct 22 14:05:20 2011 -0700", "commit_message": "Fix up some hooks to standardize things and reduce extension developer code.", "files_name": ["reviewboard/extensions/hooks.py", "reviewboard/extensions/templatetags/rb_extensions.py", "reviewboard/extensions/tests.py", "reviewboard/templates/extensions/action.html", "reviewboard/templates/extensions/action_dropdown.html", "reviewboard/templates/reviews/dashboard.html"]}, {"commit_id": "0d1c6e8ac80ee09648b21513fbdd8eee0886201a", "commit_date": "Fri Nov 4 13:06:50 2011 -0700", "commit_message": "Fix the broken diff link in the plain text email template.", "files_name": ["reviewboard/templates/notifications/review_request_email.txt"]}, {"commit_id": "3d7e7a5ec02b0bebc3c1600699c8986f022a2e37", "commit_date": "Thu Nov 3 22:06:09 2011 -0700", "commit_message": "Add a workaround for a failure in the comment popup in IE", "files_name": ["reviewboard/htdocs/media/rb/js/reviews.js"]}, {"commit_id": "962968b2cc013800de038f83346a9f67026c4332", "commit_date": "Thu Nov 3 21:39:38 2011 -0700", "commit_message": "Fix hard-coded media URL.", "files_name": ["reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "a3c0d92484aab3bbea109ae3fd9f4149803f7560", "commit_date": "Thu Oct 20 12:33:57 2011 -0700", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["d483cf217c5433390c4f5fa0dfdb412781b67f93 - Sat Oct 15 03:48:42 2011 -0700 : Move our stylesheets to lessCSS.", "reviewboard/htdocs/media/rb/css/admin-dashboard.css", "reviewboard/htdocs/media/rb/css/admin-dashboard.less", "reviewboard/htdocs/media/rb/css/admin.css", "reviewboard/htdocs/media/rb/css/admin.less", "reviewboard/htdocs/media/rb/css/common.less", "reviewboard/htdocs/media/rb/css/dashboard.css", "reviewboard/htdocs/media/rb/css/dashboard.less", "reviewboard/htdocs/media/rb/css/defs.less", "reviewboard/htdocs/media/rb/css/diffviewer.css", "reviewboard/htdocs/media/rb/css/diffviewer.less", "reviewboard/htdocs/media/rb/css/reviews.css", "reviewboard/htdocs/media/rb/css/reviews.less", "reviewboard/htdocs/media/rb/css/search.less", "reviewboard/htdocs/media/rb/js/admin.js", "reviewboard/settings.py", "reviewboard/templates/admin/base_site.html", "reviewboard/templates/admin/dashboard.html", "reviewboard/templates/admin/widgets/w-actions.html", "reviewboard/templates/admin/widgets/w-news.html", "reviewboard/templates/admin/widgets/w-repositories.html", "reviewboard/templates/base.html", "reviewboard/templates/compress/css.html", "reviewboard/templates/compress/css_ie.html", "reviewboard/templates/compress/js.html", "reviewboard/templates/compress/js_ie.html"]}, {"commit_id": "82545c075d4374d67133cbf5c6dc279bbec9db84", "commit_date": "Wed Oct 19 11:02:10 2011 -0700", "commit_message": "Don't crash when specifying bugs on a graphics/files-only review.", "files_name": ["reviewboard/reviews/views.py"]}, {"commit_id": "c59e9abc0261e19e91e2024f55b964198f1cbbdc", "commit_date": "Sun Oct 16 02:09:31 2011 -0700", "commit_message": "Fix our calls to parseInt to provide a radix parameter.", "files_name": ["reviewboard/htdocs/media/rb/js/common.js", "reviewboard/htdocs/media/rb/js/diffviewer.js", "reviewboard/htdocs/media/rb/js/reviews.js"]}, {"commit_id": "ccc8ee11525e1d42dc9d36dca6e6d1d0f43ad15b", "commit_date": "Thu Oct 13 03:47:27 2011 -0700", "commit_message": "Compress/combine our CSS and JavaScript files.", "files_name": [".gitignore", "reviewboard/htdocs/media/rb/css/common.css", "reviewboard/htdocs/media/rb/css/reviews.css", "reviewboard/htdocs/media/rb/js/diffviewer.js", "reviewboard/settings.py", "reviewboard/templates/admin/base_site.html", "reviewboard/templates/admin/dashboard.html", "reviewboard/templates/admin/scmtools/repository/change_form.html", "reviewboard/templates/base.html", "reviewboard/templates/compress/css.html", "reviewboard/templates/compress/css_ie.html", "reviewboard/templates/compress/js.html", "reviewboard/templates/compress/js_ie.html", "reviewboard/templates/diffviewer/view_diff.html", "reviewboard/templates/reviews/dashboard.html", "reviewboard/templates/reviews/new_review_request.html", "reviewboard/templates/reviews/review_detail.html", "reviewboard/templates/reviews/reviewable_base.html", "reviewboard/templates/reviews/screenshot_detail.html", "reviewboard/templates/reviews/search.html", "reviewboard/templates/reviews/user_page.html", "setup.py"]}, {"commit_id": "ee70027bee24b5b7ce06106c0e413ef9afe9a8a0", "commit_date": "Tue Oct 11 15:09:08 2011 -0700", "commit_message": "Formalize Admin widgets a bit more, and make them class-based.", "files_name": ["reviewboard/admin/templatetags/rbadmintags.py", "reviewboard/admin/views.py", "reviewboard/admin/widgets.py", "reviewboard/htdocs/media/rb/css/admin-dashboard.css", "reviewboard/templates/admin/admin_widget.html", "reviewboard/templates/admin/dashboard.html", "reviewboard/templates/admin/widgets/w-groups.html", "reviewboard/templates/admin/widgets/w-repositories.html", "reviewboard/templates/admin/widgets/w-request-statuses.html", "reviewboard/templates/admin/widgets/w-server-cache.html", "reviewboard/templates/admin/widgets/w-stats-large.html", "reviewboard/templates/admin/widgets/w-stats.html", "reviewboard/templates/admin/widgets/w-user-activity.html"]}, {"commit_id": "669262c92f80eea73dbbef53f66f00cfe4dfcda0", "commit_date": "Fri Oct 14 10:22:16 2011 -0700", "commit_message": "Allow adding custom Django apps in settings_local.py", "files_name": ["reviewboard/settings.py"]}, {"commit_id": "31cffdc9e93937f94afabc971fe6202cfc93a29e", "commit_date": "Tue Oct 11 03:12:49 2011 -0700", "commit_message": "Remove the fade-in of the new admin UI and improve loading overall.", "files_name": ["reviewboard/htdocs/media/rb/css/admin-dashboard.css", "reviewboard/htdocs/media/rb/js/admin.js", "reviewboard/templates/admin/widgets/w-request-statuses.html", "reviewboard/templates/admin/widgets/w-stats-large.html", "reviewboard/templates/admin/widgets/w-user-activity.html"]}, {"commit_id": "2d1c0b76e942d77211f376049e6495cf4323dcd3", "commit_date": "Thu Oct 13 03:51:31 2011 -0700", "commit_message": "Remove some media and a template we don't use.", "files_name": ["reviewboard/htdocs/media/rb/js/gears_init.js", "reviewboard/htdocs/media/rb/js/iui.js", "reviewboard/templates/docview/page.html"]}, {"commit_id": "d369fafbc0c0c39078b66986da234a015db3e3bc", "commit_date": "Tue Oct 11 15:12:03 2011 -0700", "commit_message": "Fix manage.py and extension loading.", "files_name": ["reviewboard/extensions/base.py", "reviewboard/manage.py"]}], "windows_after": [{"commit_id": "0efcd3d55e2c1a93b7b8b5a56e87288f1934fa51", "commit_date": "Tue Nov 15 02:51:51 2011 -0800", "commit_message": "Release Review Board 1.5.7.", "files_name": ["contrib/internal/release.py", "docs/releasenotes/reviewboard/1.5.7.txt", "docs/releasenotes/reviewboard/index.txt", "reviewboard/__init__.py"]}, {"commit_id": "e38144d16dcd69a82fa64ef1f0ab1dfb9b3dabfb", "commit_date": "Tue Nov 15 03:06:34 2011 -0800", "commit_message": "Merge branch 'release-1.5.x' into release-1.6.x", "files_name": ["c4d224233ed1fc9fa8b03018454361a4801a8f06 - Tue Nov 15 03:07:47 2011 -0800 : Release Review Board 1.6.3.", "docs/releasenotes/reviewboard/1.6.3.txt", "docs/releasenotes/reviewboard/index.txt"]}, {"commit_id": "0baf1b423e82e680db517a7036e43fd3da2c2bf4", "commit_date": "Tue Nov 15 03:12:56 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["e269fee1e8e66b4476776c2f17970d887fd3410b - Sat Nov 19 01:30:13 2011 -0800 : Fix unit tests with newer versions of Django.", "reviewboard/accounts/fixtures/test_users.json", "reviewboard/scmtools/fixtures/hg.json", "reviewboard/scmtools/fixtures/test_scmtools.json", "reviewboard/scmtools/tests.py"]}, {"commit_id": "bfceefce120d09cb67ac4bc17c38d7732b70d0be", "commit_date": "Sat Nov 19 01:33:34 2011 -0800", "commit_message": "Fix the import path for the fallback PIL Image.", "files_name": ["reviewboard/test.py"]}, {"commit_id": "7142282fc0345e7c7dd5292a0c2ad9f1d2193f69", "commit_date": "Sat Nov 19 01:45:07 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["cc718fdd500f4612d9c46c343ff8efe8c1208e93 - Thu Dec 1 23:27:31 2011 -0800 : Enhance the Issue Summary table.", "AUTHORS", "reviewboard/htdocs/media/rb/css/defs.less", "reviewboard/htdocs/media/rb/css/reviews.less", "reviewboard/htdocs/media/rb/js/reviews.js", "reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "648eeaa377ab819b5a193e74241f529edf26a260", "commit_date": "Thu Dec 1 23:33:19 2011 -0800", "commit_message": "Fix SPF compliance.", "files_name": ["AUTHORS", "reviewboard/notifications/email.py"]}, {"commit_id": "7b85d226658f68edc1b92ebaf2ee5156a9207b96", "commit_date": "Sun Dec 11 16:23:35 2011 -0800", "commit_message": "Add some initial release notes for 1.7 beta 1.", "files_name": ["AUTHORS", "docs/releasenotes/reviewboard/1.7-beta-1.txt", "docs/releasenotes/reviewboard/index.txt"]}, {"commit_id": "9c705216e3c48831571dc3123fd2b4b2822e30f1", "commit_date": "Sun Dec 11 17:45:59 2011 -0800", "commit_message": "Fix the parameters for DashboardHook.", "files_name": ["reviewboard/extensions/hooks.py"]}, {"commit_id": "be1dac2d3fdc44b140a0af4803dacd81b903bf55", "commit_date": "Tue Nov 15 02:41:50 2011 -0800", "commit_message": "Switch to using django-pipeline and change our versioning.", "files_name": ["MANIFEST.in", "contrib/internal/release.py", "reviewboard/settings.py", "reviewboard/templates/admin/base_site.html", "reviewboard/templates/base.html", "reviewboard/templates/js/pipeline.html", "setup.py"]}, {"commit_id": "11e1ea17977c787f956e31525baf0fbf38d31177", "commit_date": "Tue Dec 13 02:15:32 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["49121044fae58bad39511b8646041af23a78704b - Thu Dec 22 03:18:42 2011 -0800 : Raise NotImplementedError, not NotImplemented.", "reviewboard/accounts/backends.py", "reviewboard/cmdline/rbsite.py", "reviewboard/cmdline/rbssh.py", "reviewboard/scmtools/core.py", "reviewboard/scmtools/hg.py", "reviewboard/webapi/resources.py"]}, {"commit_id": "38fe86f0b1a04957e1199fa2c72c78a5b84beef5", "commit_date": "Thu Dec 22 03:19:45 2011 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["25cced98debc32eff52f9a9e35bbe20815012737 - Thu Dec 22 03:20:10 2011 -0800 : Use NotImplementedError in hooks.", "reviewboard/extensions/hooks.py"]}, {"commit_id": "a14a7b825d46c53343e4117f8a6c838e36f865ed", "commit_date": "Fri Jan 6 19:58:20 2012 -0800", "commit_message": "Merge remote-tracking branch 'origin/release-1.6.x' into release-1.6.x", "files_name": ["56b812eb823d6de5624046b390b1ec17546be8e9 - Sun Jan 8 17:02:38 2012 -0800 : Update the issue summary table when issue states are changed.", "reviewboard/htdocs/media/rb/css/reviews.less", "reviewboard/htdocs/media/rb/js/reviews.js", "reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "b5fee7841e38c6131ce607c50d5723ea7dea250b", "commit_date": "Sun Jan 8 18:03:10 2012 -0800", "commit_message": "Updated Windows installation tips and translation blocks", "files_name": ["reviewboard/templates/admin/manual-updates/data-dir.html"]}, {"commit_id": "8847d97361615b9652dff884e6069e1e6df6ccfe", "commit_date": "Tue Jan 10 23:00:45 2012 -0800", "commit_message": "Fix checking for file existence when the file is empty on Git.", "files_name": ["reviewboard/scmtools/git.py"]}, {"commit_id": "b5714bf86ad9f507866cd6596fc4fe9cc479b9c9", "commit_date": "Tue Jan 10 23:38:11 2012 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["36750aa511c66f7938fa95e84a34c2740d4a74cc - Wed Jan 11 00:09:46 2012 -0800 : Fix unit tests for the recent e-mail changes.", "reviewboard/notifications/tests.py"]}, {"commit_id": "5af211fe29972769f1b2ea16025ff51aee2f8f7f", "commit_date": "Wed Jan 11 00:10:37 2012 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["b829f4b34110163ebd9351232a3750bb83d88973 - Wed Jan 11 00:17:19 2012 -0800 : Only build media files in egg_info if there's a settings_local file.", "setup.py"]}, {"commit_id": "9dfbacda4079841a0feef149f53a2cbbae53f0f8", "commit_date": "Wed Jan 11 00:42:25 2012 -0800", "commit_message": "Fix a timing issue with the ChangeResourceTests.", "files_name": ["reviewboard/webapi/tests.py"]}, {"commit_id": "b48ff65ad5490d48c44882352e172e68150327d9", "commit_date": "Wed Jan 11 00:43:25 2012 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["c4579c537e0ff6427212f32164b1307e9d46b685 - Fri Jan 13 18:29:51 2012 -0800 : Fix potential KeyErrors when submitting the repo form without a path.", "reviewboard/scmtools/forms.py"]}, {"commit_id": "df73fccf8da260826b7095e77eb9a830e367cc55", "commit_date": "Fri Jan 20 12:23:52 2012 -0800", "commit_message": "Make \"Expand All\" icon work in review request page.", "files_name": ["reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "a4c38cd214a06a86af9dea3277ece64e42ee3d1d", "commit_date": "Fri Jan 20 18:07:15 2012 -0800", "commit_message": "Open links in description and testing done sections in new windows.", "files_name": ["reviewboard/htdocs/media/rb/js/reviews.js"]}, {"commit_id": "8069c1db754b4dfbd617688901d2b8084070217f", "commit_date": "Fri Jan 20 18:16:25 2012 -0800", "commit_message": "Fixed \"Posted\" date appears in the dashboard, but not in the review.", "files_name": ["reviewboard/templates/reviews/review_request_box.html"]}, {"commit_id": "28df4f5e5d8988fcf51a538baddb237f462bc67b", "commit_date": "Fri Jan 20 20:18:57 2012 -0800", "commit_message": "Fix DefaultReviewer.objects.for_repository for non-repo LocalSite reviewers.", "files_name": ["reviewboard/reviews/managers.py", "reviewboard/reviews/models.py", "reviewboard/reviews/tests.py"]}, {"commit_id": "08c2af64c532dec993555979a7575036002ee481", "commit_date": "Sat Jan 21 15:19:56 2012 -0800", "commit_message": "Added a \"To Me\" column to the pages with lists of Reviews.", "files_name": ["reviewboard/reviews/datagrids.py"]}, {"commit_id": "b0d02285e8e18d6e4dfbf6912bb0ab9a68da716e", "commit_date": "Sat Jan 21 16:38:16 2012 -0800", "commit_message": "Set default timezone to UTC.", "files_name": ["reviewboard/settings.py"]}, {"commit_id": "72b3a1feaaec1ed5a43a32ec5a159b79902f1354", "commit_date": "Sun Jan 22 00:18:50 2012 -0800", "commit_message": "Avoid crashing if an scmtool returns bogus text during validation.", "files_name": ["reviewboard/scmtools/forms.py"]}, {"commit_id": "1320b0bf30d52792206fbc379ccfb34694c980d1", "commit_date": "Sun Jan 22 00:43:03 2012 -0800", "commit_message": "Fix \"manage\" links in new admin to use SITE_ROOT", "files_name": ["reviewboard/templates/admin/widgets/w-actions.html"]}, {"commit_id": "512b868b5e1cea5ba79849abe676512ac03d2635", "commit_date": "Sun Jan 22 13:47:38 2012 -0800", "commit_message": "Fix documentation for git path.", "files_name": ["reviewboard/scmtools/models.py"]}, {"commit_id": "1ba234dc97310b1538d6b98828fe3656d7d26307", "commit_date": "Sun Jan 22 13:55:33 2012 -0800", "commit_message": "Update LDAP user mask hint.", "files_name": ["reviewboard/accounts/forms.py"]}, {"commit_id": "d904929237eeb61caadcd598de09d03b174e0e7b", "commit_date": "Sun Jan 22 00:50:16 2012 -0800", "commit_message": "Add validation for the cache backend setting.", "files_name": ["reviewboard/admin/forms.py"]}, {"commit_id": "731c0f619e2a0cb9900683ad5375a60e0fc4e2ea", "commit_date": "Sat Jan 21 16:27:19 2012 -0800", "commit_message": "Fix UnicodeEncodeErrors when viewing the user infobox for users with unicode names", "files_name": ["reviewboard/reviews/tests.py", "reviewboard/reviews/views.py"]}, {"commit_id": "a38f35b177484a70dd15d34589181cda0bcd12d9", "commit_date": "Mon Jan 23 23:37:04 2012 -0800", "commit_message": "Fix pyflakes warnings.", "files_name": ["reviewboard/reviews/tests.py"]}, {"commit_id": "b801d96f10e7850024e63254a5b4fe4b445df77c", "commit_date": "Thu Jan 26 20:18:04 2012 -0800", "commit_message": "Added Collapse All button", "files_name": ["reviewboard/htdocs/media/rb/js/reviews.js", "reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "7a2f1c0070468cfc4e1c01958c5691e70c8b1a6d", "commit_date": "Thu Jan 26 20:25:52 2012 -0800", "commit_message": "Include review ID in subject line of generated emails.", "files_name": ["reviewboard/notifications/email.py"]}, {"commit_id": "5fc4b76a54089129dc1f3f51ad98b28e2afb6174", "commit_date": "Tue Nov 8 18:00:09 2011 -0800", "commit_message": "Remove extra CC headers in SpiffyEmailMessage.", "files_name": ["reviewboard/notifications/email.py"]}, {"commit_id": "35bf26efda4d6a6d97391430309d8b16000a1746", "commit_date": "Sat Jan 28 15:12:11 2012 -0800", "commit_message": "Fix unit tests.", "files_name": ["reviewboard/notifications/email.py", "reviewboard/notifications/tests.py", "reviewboard/webapi/tests.py"]}, {"commit_id": "d191b9c7ac5caec15e96ab0011d1c0a4283bc20b", "commit_date": "Sun Jan 29 14:49:00 2012 -0800", "commit_message": "Fix the \"Review ID\" column to show the correct ID when using local sites.", "files_name": ["reviewboard/reviews/datagrids.py"]}, {"commit_id": "c704b31d153a57c853a2b56cdc2f5341c0270922", "commit_date": "Sun Jan 29 14:50:39 2012 -0800", "commit_message": "Merge branch 'release-1.6.x'", "files_name": ["7b425185c26c0a1bac4784246e825e05b809ce3d - Tue Jan 31 14:23:30 2012 -0800 : Added password reentry and verification in rb-site install", "reviewboard/cmdline/rbsite.py"]}, {"commit_id": "3a7431bd1beabdfd1966488825807d063c18ef56", "commit_date": "Thu Feb 2 18:06:43 2012 -0500", "commit_message": "Maximize issue summary table to browser width.", "files_name": ["reviewboard/htdocs/media/rb/css/reviews.less", "reviewboard/templates/reviews/review_detail.html"]}, {"commit_id": "5ed25c2e6b17b470040deff8a834468c71b4a175", "commit_date": "Sun Jan 29 15:32:42 2012 -0800", "commit_message": "Enable passing through encoding to perforce tool.", "files_name": ["reviewboard/scmtools/perforce.py", "reviewboard/scmtools/tests.py"]}, {"commit_id": "f17c1e92e200927c7a423e65358200d3eee1007e", "commit_date": "Tue Feb 7 01:14:53 2012 -0800", "commit_message": "Fix the alias path for favicon.ico.", "files_name": ["reviewboard/cmdline/conf/apache-wsgi.conf.in"]}, {"commit_id": "b65369c7c97b5d499d18a4c3c6dcf56f286d1079", "commit_date": "Tue Feb 7 22:10:33 2012 -0800", "commit_message": "Fix parsing for diffs with extra tab characters before the revision.", "files_name": ["reviewboard/scmtools/svn.py", "reviewboard/scmtools/tests.py"]}, {"commit_id": "22f8803a1ae34caf58d7a36b86e495798f5fdc77", "commit_date": "Tue Feb 7 22:13:17 2012 -0800", "commit_message": "Merge remote-tracking branch 'origin/master'", "files_name": ["cefd1ea0d3ea351c339e4e83d04ecfe1fc37cca8 - Thu Feb 9 17:53:55 2012 -0800 : Fix changeset_is_pending() to not throw an error if the changeset is empty.", "reviewboard/reviews/models.py", "reviewboard/scmtools/core.py", "reviewboard/scmtools/perforce.py", "reviewboard/scmtools/plastic.py"]}, {"commit_id": "7fe956a06a114e44cfdb5291a2059805d3ca01a6", "commit_date": "Sat Oct 22 14:09:58 2011 -0700", "commit_message": "Make modern versions of our old backup/load scripts.", "files_name": ["contrib/db/backup-db.py", "contrib/db/db2wiki.py", "contrib/db/load-db.py", "reviewboard/admin/management/commands/__init__.py", "reviewboard/admin/management/commands/dumpdb.py", "reviewboard/admin/management/commands/loaddb.py"]}, {"commit_id": "09b0dc762de5b358b4963cc983803e1a10e746a3", "commit_date": "Mon Dec 19 02:49:01 2011 -0800", "commit_message": "Add support for per-resource mimetypes in the API.", "files_name": ["reviewboard/webapi/decorators.py", "reviewboard/webapi/resources.py", "reviewboard/webapi/tests.py"]}, {"commit_id": "68ec6cd9f3a67de2cb7592d1b9076dacea2d5622", "commit_date": "Sat Feb 11 14:11:07 2012 -0800", "commit_message": "Expose Toggles for Opening Issues in Review Summary Dialog", "files_name": ["reviewboard/htdocs/media/rb/js/reviews.js", "reviewboard/templates/reviews/review_draft_inline_form.html"]}, {"commit_id": "57267b11a28886b6ea6c23cf31483e420dd37314", "commit_date": "Sun Feb 12 14:47:04 2012 -0800", "commit_message": "Change the text on /r/new to be a bit more generic.", "files_name": ["reviewboard/templates/reviews/new_review_request.html"]}], "parents": [{"commit_id_before": "9b789e42aa2664b0b20cad2da7788ae69081fad2", "url_before": "https://api.github.com/repos/reviewboard/reviewboard/commits/9b789e42aa2664b0b20cad2da7788ae69081fad2", "html_url_before": "https://github.com/reviewboard/reviewboard/commit/9b789e42aa2664b0b20cad2da7788ae69081fad2"}], "details": [{"raw_url": "https://github.com/reviewboard/reviewboard/raw/7a0a9d94555502278534dedcf2d75e9fccce8c3d/reviewboard%2Fhtdocs%2Fmedia%2Frb%2Fjs%2Fdiffviewer.js", "code": "// Constants\nvar BACKWARD = -1;\nvar FORWARD  = 1;\nvar INVALID  = -1;\nvar DIFF_SCROLLDOWN_AMOUNT = 100;\nvar VISIBLE_CONTEXT_SIZE = 5;\n\nvar ANCHOR_COMMENT = 1;\nvar ANCHOR_FILE = 2;\nvar ANCHOR_CHUNK = 4;\n\n\n// State\nvar gDiff;\n\n\n/*\n * A list of key bindings for the page.\n */\nvar gActions = [\n    { // Previous file\n        keys: \"aAKP<m\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Next file\n        keys: \"fFJN>\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Previous diff\n        keys: \"sSkp,,\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Next diff\n        keys: \"dDjn..\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Recenter\n        keys: unescape(\"%0D\"),\n        onPress: function() { scrollToAnchor($(gAnchors[gSelectedAnchor])); }\n    },\n\n    { // Previous comment\n        keys: \"[x\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Next comment\n        keys: \"]c\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Go to header\n        keys: \"gu;\",\n        onPress: function() {}\n    },\n\n    { // Go to footer\n        keys: \"GU:\",\n        onPress: function() {}\n    }\n];\n\n\n// State variables\nvar gSelectedAnchor = INVALID;\nvar gFileAnchorToId = {};\nvar gInterdiffFileAnchorToId = {};\nvar gAnchors = $();\nvar gCommentDlg = null;\nvar gHiddenComments = {};\nvar gDiffHighlightBorder = null;\nvar gStartAtAnchor = null;\n\n\n/*\n * Creates a comment block in the diff viewer.\n *\n * @param {jQuery} beginRow      The first table row to attach to.\n * @param {jQuery} endRow        The last table row to attach to.\n * @param {int}    beginLineNum  The line number to attach to.\n * @param {int}    endLineNum    The line number to attach to.\n * @param {array}  comments      The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction DiffCommentBlock(beginRow, endRow, beginLineNum, endLineNum,\n                          comments) {\n    var self = this;\n\n    var table = beginRow.parents(\"table:first\")\n    var fileid = table[0].id;\n\n    this.filediff = gFileAnchorToId[fileid];\n    this.interfilediff = gInterdiffFileAnchorToId[fileid];\n    this.beginLineNum = beginLineNum;\n    this.endLineNum = endLineNum;\n    this.beginRow = beginRow;\n    this.endRow = endRow;\n    this.comments = [];\n    this.draftComment = null;\n\n    this.el = $(\"<span/>\")\n        .addClass(\"commentflag\")\n        .append($(\"<span/>\").addClass(\"commentflag-shadow\"))\n        .click(function() {\n            self.showCommentDlg();\n            return false;\n        });\n\n    $(window).bind(\"resize\", function(evt) {\n        self.updateSize();\n    });\n\n    var innerFlag = $(\"<span/>\")\n        .addClass(\"commentflag-inner\")\n        .appendTo(this.el);\n\n    this.countEl = $(\"<span/>\")\n        .appendTo(innerFlag);\n\n    if ($.browser.msie && $.browser.version == 6) {\n        /*\n         * Tooltips for some reason cause comment flags to disappear in IE6.\n         * So for now, just fake them and never show them.\n         */\n        this.tooltip = $(\"<div/>\");\n    } else {\n        this.tooltip = $.tooltip(this.el, {\n            side: \"rb\"\n        }).addClass(\"comments\");\n    }\n\n    this.anchor = $(\"<a/>\")\n        .attr(\"name\",\n              \"file\" + this.filediff['id'] + \"line\" + this.beginLineNum)\n        .addClass(\"comment-anchor\")\n        .appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            // We load in encoded text, so decode it.\n            comment.text = $(\"<div/>\").html(comment.text).text();\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.updateCount();\n    this.updateTooltip();\n    this.updateSize();\n\n    /* Now that we've built everything, add this to the DOM. */\n    this.beginRow[0].cells[0].appendChild(this.el[0]);\n}\n\n$.extend(DiffCommentBlock.prototype, {\n    /*\n     * Notifies the user of some update. This notification appears by the\n     * comment flag.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .text(text)\n            .appendTo(this.el);\n\n        bubble\n            .css({\n                left: this.el.width(),\n                top:  0,\n                opacity: 0\n            })\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n            });\n    },\n\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        this.tooltip.empty();\n        var list = $(\"<ul/>\");\n\n        if (this.draftComment) {\n            $(\"<li/>\")\n                .text(this.draftComment.text.truncate())\n                .addClass(\"draft\")\n                .appendTo(list);\n        }\n\n        for (var i = 0; i < this.comments.length; i++) {\n            $(\"<li/>\")\n                .text(this.comments[i].text.truncate())\n                .appendTo(list);\n        }\n\n        list.appendTo(this.tooltip);\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment) {\n            count++;\n        }\n\n        this.count = count;\n        this.countEl.html(this.count);\n    },\n\n    /*\n     * Updates the size of the comment flag.\n     */\n    updateSize: function() {\n        /*\n         * On IE and Safari, the marginTop in getExtents will be wrong.\n         * Force a value.\n         */\n        var extents = this.el.getExtents(\"m\", \"t\") || -4;\n        this.el.css(\"height\",\n                    this.endRow.offset().top + this.endRow.outerHeight() -\n                    this.beginRow.offset().top - extents);\n    },\n\n    /*\n     * Shows the comment dialog.\n     */\n    showCommentDlg: function() {\n        var self = this;\n\n        if (gCommentDlg == null) {\n            gCommentDlg = $(\"#comment-detail\")\n                .commentDlg()\n                .css(\"z-index\", 999);\n            gCommentDlg.appendTo(\"body\");\n        }\n\n        gCommentDlg\n            .one(\"close\", function() {\n                self._createDraftComment();\n\n                gCommentDlg\n                    .setDraftComment(self.draftComment)\n                    .setCommentsList(self.comments, \"comment\")\n                    .css({\n                        left: $(document).scrollLeft() +\n                              ($(window).width() - gCommentDlg.width()) / 2,\n                        top:  self.endRow.offset().top +\n                              self.endRow.height()\n                    })\n                    .open(self.el);\n            })\n            .close();\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.DiffComment(this.filediff, this.interfilediff,\n                                         this.beginLineNum, this.endLineNum,\n                                         textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            self.notify(\"Comment Deleted\");\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            self.draftComment = null;\n\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n                self.anchor.remove();\n            } else {\n                el.removeClass(\"draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n    }\n});\n\n\n/*\n * Registers a section as being a diff file.\n *\n * This handles all mouse actions on the diff, comment range selection, and\n * populatation of comment flags.\n *\n * @param {array}  lines  The lines containing comments. See the\n *                        addCommentFlags documentation for the format.\n * @param {string} key    A unique ID identifying the file the comments\n *                        belong too (typically based on the filediff_id).\n *\n * @return {jQuery} The diff file element.\n */\n$.fn.diffFile = function(lines, key) {\n    return this.each(function() {\n        var self = $(this);\n\n        /* State */\n        var selection = {\n            begin: null,\n            beginNum: 0,\n            end: null,\n            endNum: 0,\n            lastSeenIndex: 0\n        };\n\n        var ghostCommentFlag = $(\"<span/>\")\n            .addClass(\"commentflag\")\n            .addClass(\"ghost-commentflag\")\n            .append($(\"<span class='commentflag-shadow'/>\"))\n            .append($(\"<span class='commentflag-inner'/>\"))\n            .mousedown(function(e) { self.triggerHandler(\"mousedown\", e); })\n            .mouseup(function(e)   { self.triggerHandler(\"mouseup\", e);   })\n            .mouseover(function(e) { self.triggerHandler(\"mouseover\", e); })\n            .mouseout(function(e)  { self.triggerHandler(\"mouseout\", e);  })\n            .hide()\n            .appendTo(\"body\");\n\n        var ghostCommentFlagCell = null;\n\n\n        /* Events */\n        self\n            .mousedown(function(e) {\n                /*\n                 * Handles the mouse down event, which begins selection for\n                 * comments.\n                 *\n                 * @param {event} e  The mousedown event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    beginSelection($(node.parentNode));\n                    return false;\n                }\n\n                return true;\n            })\n            .mouseup(function(e) {\n                /*\n                 * Handles the mouse up event, which finalizes selection\n                 * of a range of lines.\n                 *\n                 * This will create a new comment block and display the\n                 * comment dialog.\n                 *\n                 * @param {event} e  The mouseup event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    endSelection(getActualLineNumCell($(node)).parent());\n                } else {\n                    /*\n                     * The user clicked somewhere else. Move the anchor\n                     * point here if it's part of the diff.\n                     */\n                    var tbody = $(node).parents(\"tbody:first\");\n\n                    if (tbody.length > 0 &&\n                        (tbody.hasClass(\"delete\") || tbody.hasClass(\"insert\") ||\n                         tbody.hasClass(\"replace\"))) {\n                        gotoAnchor($(\"a:first\", tbody).attr(\"name\"), true);\n                    }\n                }\n\n                resetSelection();\n\n                return false;\n            })\n            .mouseover(function(e) {\n                /*\n                 * Handles the mouse over event. This will update the\n                 * selection, if there is one, to include this row in the\n                 * range, and set the \"selected\" class on the new row.\n                 *\n                 * @param {event} e  The mouseover event.\n                 */\n                var node = getActualLineNumCell($(e.target));\n                var row = node.parent();\n\n                if (isLineNumCell(node[0])) {\n                    addRowToSelection(row);\n                } else if (ghostCommentFlagCell != null &&\n                           node[0] != ghostCommentFlagCell[0]) {\n                    row.removeClass(\"selected\");\n                }\n            })\n            .mouseout(function(e) {\n                /*\n                 * Handles the mouse out event, removing any lines outside\n                 * the new range from the selection.\n                 *\n                 * @param {event} e  The mouseout event.\n                 */\n                var relTarget = e.relatedTarget;\n                var node = getActualLineNumCell($(e.fromElement ||\n                                                  e.originalTarget));\n\n                if (relTarget != ghostCommentFlag[0]) {\n                    ghostCommentFlag.hide();\n                    ghostCommentFlagCell = null;\n                }\n\n                if (selection.begin != null) {\n                    if (relTarget != null && isLineNumCell(relTarget)) {\n                        removeOldRowsFromSelection($(relTarget.parentNode));\n                    }\n                } else if (node != null && isLineNumCell(node[0])) {\n                    /*\n                     * Opera seems to generate lots of spurious mouse-out\n                     * events, which would cause us to get all sorts of\n                     * errors in here unless we check the target above.\n                     */\n                    node.parent().removeClass(\"selected\");\n                }\n            })\n            .bind(\"touchmove\", function(e) {\n                var firstTouch = e.originalEvent.targetTouches[0];\n                var target = document.elementFromPoint(firstTouch.pageX,\n                                                       firstTouch.pageY);\n                var node = getActualLineNumCell($(target));\n                var row = node.parent();\n\n                if (selection.lastSeenIndex == row[0].rowIndex) {\n                    return;\n                }\n\n                if (isLineNumCell(node[0])) {\n                    var row = node.parent();\n                    removeOldRowsFromSelection(row);\n                    addRowToSelection(row);\n                }\n            })\n            .bind(\"touchcancel\", function(e) {\n                resetSelection();\n            })\n            .proxyTouchEvents(\"touchstart touchend\");\n\n        addCommentFlags(self, lines, key);\n\n        /*\n         * Begins the selection of line numbers.\n         *\n         * @param {jQuery} row  The row to begin the selection on.\n         */\n        function beginSelection(row) {\n            selection.begin    = selection.end    = row;\n            selection.beginNum = selection.endNum =\n                parseInt(row.attr('line'));\n\n            selection.lastSeenIndex = row[0].rowIndex;\n            row.addClass(\"selected\");\n\n            self.disableSelection();\n        }\n\n        /*\n         * Finalizes the selection and pops up a comment dialog.\n         *\n         * @param {jquery} row  The row to end the selection on.\n         */\n        function endSelection(row) {\n            row.removeClass(\"selected\");\n\n            if (selection.beginNum == selection.endNum) {\n                /* See if we have a comment flag on the selected row. */\n                var commentFlag = row.find(\".commentflag\");\n\n                if (commentFlag.length == 1) {\n                    commentFlag.click()\n                    return;\n                }\n            }\n\n            /*\n             * Selection was finalized. Create the comment block\n             * and show the comment dialog.\n             */\n            var commentBlock = new DiffCommentBlock(\n                selection.begin,\n                selection.end,\n                selection.beginNum,\n                selection.endNum);\n            commentBlock.showCommentDlg();\n        }\n\n        /*\n         * Adds a row to the selection. This will update the selection range\n         * and mark the rows as selected.\n         *\n         * This row is assumed to be the most recently selected row, and\n         * will mark the new beginning or end of the selection.\n         *\n         * @param {jQuery} row  The row to add to the selection.\n         */\n        function addRowToSelection(row) {\n            row.css(\"cursor\", \"pointer\");\n\n            if (selection.begin != null) {\n                /* We have an active selection. */\n                var linenum = parseInt(row.attr(\"line\"));\n\n                if (linenum < selection.beginNum) {\n                    selection.beginNum = linenum;\n                    selection.begin = row;\n                } else if (linenum > selection.beginNum) {\n                    selection.end = row;\n                    selection.endNum = linenum;\n                }\n\n                var min = Math.min(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n                var max = Math.max(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n\n                for (var i = min; i <= max; i++) {\n                    $(self[0].rows[i]).addClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = row[0].rowIndex;\n            } else {\n                var lineNumCell = row[0].cells[0];\n\n                /* See if we have a comment flag in here. */\n                if ($(\".commentflag\", lineNumCell).length == 0) {\n                    ghostCommentFlag\n                        .css(\"top\", row.offset().top - 1)\n                        .show()\n                        .parent()\n                            .removeClass(\"selected\");\n                    ghostCommentFlagCell = $(row[0].cells[0]);\n                }\n\n                row.addClass(\"selected\");\n            }\n        }\n\n        /*\n         * Removes any old rows from the selection, based on the most recent\n         * row selected.\n         *\n         * @param {jQuery} row  The last row selected.\n         */\n        function removeOldRowsFromSelection(row) {\n            var destRowIndex = row[0].rowIndex;\n\n            if (destRowIndex >= selection.begin[0].rowIndex) {\n                for (var i = selection.lastSeenIndex;\n                     i > destRowIndex;\n                     i--) {\n                    $(self[0].rows[i]).removeClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = destRowIndex;\n            }\n        }\n\n        /*\n         * Resets the selection information.\n         */\n        function resetSelection() {\n            if (selection.begin != null) {\n                /* Reset the selection. */\n                var rows = self[0].rows;\n\n                for (var i = selection.begin[0].rowIndex;\n                     i <= selection.end[0].rowIndex;\n                     i++) {\n                    $(rows[i]).removeClass(\"selected\");\n                }\n\n                selection.begin    = selection.end    = null;\n                selection.beginNum = selection.endNum = 0;\n                selection.rows = [];\n            }\n\n            ghostCommentFlagCell = null;\n\n            /* Re-enable text selection on IE */\n            self.enableSelection();\n        }\n\n        /*\n         * Returns whether a particular cell is a line number cell.\n         *\n         * @param {HTMLElement} cell  The cell element.\n         *\n         * @return {bool} true if the cell is the line number cell.\n         */\n        function isLineNumCell(cell) {\n            return (cell.tagName == \"TH\" &&\n                    cell.parentNode.getAttribute('line'));\n        }\n\n\n        /*\n         * Returns the actual cell node in the table.\n         *\n         * If the node specified is the ghost flag, this will return the\n         * cell the ghost flag represents.\n         *\n         * If this is a comment flag inside a cell, this will return the\n         * comment flag's parent cell\n         *\n         * @return {jQuery} The row.\n         */\n        function getActualLineNumCell(node) {\n            if (node.hasClass(\"commentflag\")) {\n                if (node[0] == ghostCommentFlag[0]) {\n                    node = ghostCommentFlagCell;\n                } else {\n                    node = node.parent();\n                }\n            }\n\n            return node;\n        }\n    });\n};\n\n\n/*\n * Highlights a chunk of the diff.\n *\n * This will create and move four border elements around the chunk. We use\n * these border elements instead of setting a border since few browsers\n * render borders on <tbody> tags the same, and give us few options for\n * styling.\n */\n$.fn.highlightChunk = function() {\n    var firstHighlight = false;\n\n    if (!gDiffHighlightBorder) {\n        var borderEl = $(\"<div/>\")\n            .addClass(\"diff-highlight-border\")\n            .css(\"position\", \"absolute\");\n\n        gDiffHighlightBorder = {\n            top: borderEl.clone().appendTo(\"#diffs\"),\n            bottom: borderEl.clone().appendTo(\"#diffs\"),\n            left: borderEl.clone().appendTo(\"#diffs\"),\n            right: borderEl.clone().appendTo(\"#diffs\")\n        };\n\n        firstHighlight = true;\n    }\n\n    var el = this.parents(\"tbody:first, thead:first\");\n\n    var borderWidth = gDiffHighlightBorder.left.width();\n    var borderHeight = gDiffHighlightBorder.top.height();\n    var borderOffsetX = borderWidth / 2;\n    var borderOffsetY = borderHeight / 2;\n\n    if ($.browser.msie && $.browser.version <= 8) {\n        /* On IE, the black rectangle is too far to the top. */\n        borderOffsetY = -borderOffsetY;\n\n        if ($.browser.msie && $.browser.version == 8) {\n            /* And on IE8, it's also too far to the left. */\n            borderOffsetX = -borderOffsetX;\n        }\n    }\n\n    var updateQueued = false;\n    var oldLeft;\n    var oldTop;\n    var oldWidth;\n    var oldHeight;\n\n    /*\n     * Updates the position of the border elements.\n     */\n    function updatePosition(event) {\n        if (event && event.target &&\n            event.target != window &&\n            !event.target.getElementsByTagName) {\n\n            /*\n             * This is not a container. It might be a text node.\n             * Ignore it.\n             */\n            return;\n        }\n\n        var offset = el.position();\n\n        if (!offset) {\n            return;\n        }\n\n        var left = Math.round(offset.left);\n        var top = Math.round(offset.top);\n        var width = el.outerWidth();\n        var height = el.outerHeight();\n\n        if (left == oldLeft &&\n            top == oldTop &&\n            width == oldWidth &&\n            height == oldHeight) {\n\n            /* The position and size haven't actually changed. */\n            return;\n        }\n\n        var outerHeight = height + borderHeight;\n        var outerWidth  = width + borderWidth;\n        var outerLeft   = left - borderOffsetX;\n        var outerTop    = top - borderOffsetY;\n\n        gDiffHighlightBorder.left.css({\n            left: outerLeft,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.top.css({\n            left: outerLeft,\n            top: outerTop,\n            width: outerWidth\n        });\n\n        gDiffHighlightBorder.right.css({\n            left: outerLeft + width,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.bottom.css({\n            left: outerLeft,\n            top: outerTop + height,\n            width: outerWidth\n        });\n\n        oldLeft = left;\n        oldTop = top;\n        oldWidth = width;\n        oldHeight = height;\n\n        updateQueued = false;\n    }\n\n    /*\n     * Updates the position after 50ms so we don't call updatePosition too\n     * many times in response to a DOM change.\n     */\n    function queueUpdatePosition(event) {\n        if (!updateQueued) {\n            updateQueued = true;\n            setTimeout(function() { updatePosition(event); }, 50);\n        }\n    }\n\n    $(document).bind(\"DOMNodeInserted.highlightChunk\", queueUpdatePosition);\n    $(document).bind(\"DOMNodeRemoved.highlightChunk\", queueUpdatePosition);\n    $(window).bind(\"resize.highlightChunk\", updatePosition);\n\n    if (firstHighlight) {\n        /*\n         * There seems to be a bug where we often won't get this right\n         * away on page load. Race condition, perhaps.\n         */\n        queueUpdatePosition();\n    } else {\n        updatePosition();\n    }\n\n    return this;\n};\n\n\n/*\n * Sets the active anchor on the page, optionally scrolling to it.\n *\n * @param {string} name    The anchor name.\n * @param {bool}   scroll  If true, scrolls the page to the anchor.\n */\nfunction gotoAnchor(name, scroll) {\n    return scrollToAnchor($(\"a[name=\" + name + \"]\"), scroll || false);\n}\n\n\n/*\n * Finds the row in a table matching the specified line number.\n *\n * @param {HTMLElement} table     The table element.\n * @param {int}         linenum   The line number to search for.\n * @param {int}         startRow  Optional start row to search.\n * @param {int}         endRow    Optional end row to search.\n *\n * @param {HTMLElement} The resulting row, or null if not found.\n */\nfunction findLineNumRow(table, linenum, startRow, endRow) {\n    var row = null;\n    var row_offset = 1; // Get past the headers.\n\n    if (table.rows.length - row_offset > linenum) {\n        row = table.rows[row_offset + linenum];\n\n        // Account for the \"x lines hidden\" row.\n        if (row != null && parseInt(row.getAttribute('line')) == linenum) {\n            return row;\n        }\n    }\n\n    if (startRow) {\n        // startRow already includes the offset, so we need to remove it\n        startRow -= row_offset;\n    }\n\n    var low = startRow || 1;\n    var high = Math.min(endRow || table.rows.length, table.rows.length);\n\n    if (endRow != undefined && endRow < table.rows.length) {\n        /* See if we got lucky and found it in the last row. */\n        if (parseInt(table.rows[endRow].getAttribute('line')) == linenum) {\n            return table.rows[endRow];\n        }\n    } else if (row != null) {\n        /*\n         * We collapsed the rows (unless someone mucked with the DB),\n         * so the desired row is less than the row number retrieved.\n         */\n        high = Math.min(high, row_offset + linenum);\n    }\n\n    /* Binary search for this cell. */\n    for (var i = Math.round((low + high) / 2); low < high - 1;) {\n        row = table.rows[row_offset + i];\n\n        if (!row) {\n            /*\n             * should not happen, unless we miscomputed high\n             */\n            high--;\n            /*\n             * will not do much if low + high is odd\n             * but we'll catch up on the next iteration\n             */\n            i = Math.round((low + high) / 2);\n            continue;\n        }\n\n        var value = parseInt(row.getAttribute('line'))\n\n        if (!value) {\n            /*\n             * bad luck, let's look around.\n             * We'd expect to find a value on the first try\n             * but the following makes sure we explore all\n             * rows\n             */\n            var found = false;\n\n            for (var k = 1; k <= (high-low) / 2; k++) {\n                row = table.rows[row_offset + i + k];\n                if (row && parseInt(row.getAttribute('line'))) {\n                    i = i + k;\n                    found = true;\n                    break;\n                } else {\n                    row = table.rows[row_offset + i - k];\n                    if (row && parseInt(row.getAttribute('line'))) {\n                        i = i - k;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found) {\n                value = parseInt(row.getAttribute('line'));\n            } else {\n                return null;\n            }\n        }\n\n        /* See if we can use simple math to find the row quickly. */\n        var guessRowNum = linenum - value + row_offset + i;\n\n        if (guessRowNum >= 0 && guessRowNum < table.rows.length) {\n            var guessRow = table.rows[guessRowNum];\n\n            if (guessRow\n                && parseInt(guessRow.getAttribute('line')) == linenum) {\n                /* We found it using maths! */\n                return guessRow;\n            }\n        }\n\n        var oldHigh = high;\n        var oldLow = low;\n\n        if (value > linenum) {\n            high = i;\n        } else if (value < linenum) {\n            low = i;\n        } else {\n            return row;\n        }\n\n        /*\n         * Make sure we don't get stuck in an infinite loop. This can happen\n         * when a comment is placed in a line that isn't being shown.\n         */\n        if (oldHigh == high && oldLow == low) {\n            break;\n        }\n\n        i = Math.round((low + high) / 2);\n    }\n\n    // Well.. damn. Ignore this then.\n    return null;\n}\n\n\n/*\n * Adds comment flags to a table.\n *\n * lines is an array of dictionaries grouping together comments on the\n * same line. The dictionaries contain the following keys:\n *\n *    text       - The text of the comment.\n *    line       - The first line number.\n *    num_lines  - The number of lines the comment spans.\n *    user       - A dictionary containing \"username\" and \"name\" keys\n *                 for the user.\n *    url        - The URL for the comment.\n *    localdraft - true if this is the current user's draft comment.\n *\n * @param {HTMLElement} table  The table to add flags to.\n * @param {object}      lines  The comment lines to add.\n * @param {string}      key    A unique ID identifying the file the comments\n *                             belong too (typically based on the filediff_id).\n */\nfunction addCommentFlags(table, lines, key) {\n    var remaining = {};\n\n    var prevBeginRowIndex = undefined;\n\n    for (var i in lines) {\n        var line = lines[i];\n        var numLines = line.num_lines;\n\n        var beginLineNum = line.linenum;\n        var endLineNum = beginLineNum + numLines - 1;\n        var beginRow = findLineNumRow(table[0], beginLineNum,\n                                      prevBeginRowIndex);\n\n        if (beginRow != null) {\n            prevBeginRowIndex = beginRow.rowIndex;\n\n            var endRow = (endLineNum == beginLineNum\n                          ? beginRow\n                          : findLineNumRow(table[0], endLineNum,\n                                           prevBeginRowIndex,\n                                           prevBeginRowIndex + numLines - 1));\n\n\n            /*\n             * Note that endRow might be null if it exists in a collapsed\n             * region, so we can get away with just using beginRow if we\n             * need to.\n             */\n            new DiffCommentBlock($(beginRow), $(endRow || beginRow),\n                                 beginLineNum, endLineNum, line.comments);\n        } else {\n            remaining[beginLineNum] = line;\n        }\n    }\n\n    gHiddenComments[key] = remaining;\n}\n\n\n/*\n * Expands a chunk of the diff.\n *\n * @param {string} fileid              The file ID.\n * @param {string} filediff_id         The FileDiff ID.\n * @param {string} revision            The revision of the file.\n * @param {string} interdiff_revision  The interdiff revision of the file.\n * @param {int}    chunk_index         The chunk index number.\n * @param {string} tbody_id            The tbody ID to insert into.\n */\nfunction expandChunk(fileid, filediff_id, revision, interdiff_revision,\n                     chunk_index, link) {\n    gDiff.getDiffFragment(fileid, filediff_id, revision, interdiff_revision,\n                          chunk_index, function(html) {\n        var tbody = $(link).parents(\"tbody.diff-header\");\n        var table = tbody.parent();\n        var key = \"file\" + filediff_id;\n\n        tbody.replaceWith(html);\n        addCommentFlags(table, gHiddenComments[key], key);\n\n        /* The selection rectangle may not update -- bug #1353. */\n        $(gAnchors[gSelectedAnchor]).highlightChunk();\n    });\n}\n\n\n/*\n * Scrolls to the anchor at a specified location.\n *\n * @param {jQuery} anchor    The anchor jQuery instance.\n * @param {bool}   noscroll  true if the page should not be scrolled.\n *\n * @return {bool} true if the anchor was found, or false if not.\n */\nfunction scrollToAnchor(anchor, noscroll) {\n    if (anchor.length == 0) {\n        return false;\n    }\n\n    if (anchor.parent().is(\":hidden\")) {\n        return false;\n    }\n\n    if (!noscroll) {\n        $(window).scrollTop(anchor.offset().top - DIFF_SCROLLDOWN_AMOUNT);\n    }\n\n    anchor.highlightChunk();\n\n    for (var i = 0; i < gAnchors.length; i++) {\n        if (gAnchors[i] == anchor[0]) {\n            gSelectedAnchor = i;\n            break;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Returns the next navigatable anchor in the specified direction.\n *\n * @param {int} dir         The direction (BACKWARD or FORWARD)\n * @param {int} anchorType  The type of the anchor as a bitmask\n *                          (ANCHOR_COMMENT, ANCHOR_FILE, ANCHOR_CHUNK)\n *\n * @return {jQuery} The found anchor jQuery instance, or INVALID.\n */\nfunction GetNextAnchor(dir, anchorType) {\n    for (var anchor = gSelectedAnchor + dir;\n         anchor >= 0 && anchor < gAnchors.length;\n         anchor = anchor + dir) {\n\n        var anchorEl = $(gAnchors[anchor]);\n\n        if (((anchorType & ANCHOR_COMMENT) &&\n             anchorEl.hasClass(\"comment-anchor\")) ||\n            ((anchorType & ANCHOR_FILE) &&\n             anchorEl.hasClass(\"file-anchor\")) ||\n            ((anchorType & ANCHOR_CHUNK) &&\n             anchorEl.hasClass(\"chunk-anchor\"))) {\n            return anchorEl;\n        }\n    }\n\n    return $([]);\n}\n\n\n/*\n * Updates the list of known anchors based on named anchors in the specified\n * table. This is called after every part of the diff that we loaded.\n *\n * If no anchor is selected, we'll try to select the first one.\n *\n * @param {jQuery} table  The table to load anchors from.\n */\nfunction updateAnchors(table) {\n    gAnchors = gAnchors.add($(\"a[name]\", table));\n\n    /* Skip over the change index to the first item */\n    if (gSelectedAnchor == -1 && gAnchors.length > 0) {\n      gSelectedAnchor = 0;\n      $(gAnchors[gSelectedAnchor]).highlightChunk();\n    }\n}\n\n\n/*\n * Progressively load a diff.\n *\n * When the diff is loaded, it will be placed into the appropriate location\n * in the diff viewer, rebuild the anchors, and move on to the next file.\n *\n * @param {string} filediff_id               The filediff ID\n * @param {string} filediff_revision         The filediff revision\n * @param {string} interfilediff_id          The interfilediff ID (optional)\n * @param {string} interfilediff_revision    The interfilediff revision\n *                                           (optional)\n * @param {string} file_index                The file index\n * @param {dict}   comment_counts            The comments for this region\n */\nfunction loadFileDiff(filediff_id, filediff_revision,\n                      interfilediff_id, interfilediff_revision,\n                      file_index,\n                      comment_counts) {\n\n    if ($(\"#file\" + filediff_id).length == 1) {\n        /* We already have this one. This is probably a pre-loaded file. */\n        setupFileDiff();\n    } else {\n        $.funcQueue(\"diff_files\").add(function() {\n            gDiff.getDiffFile(filediff_id, filediff_revision,\n                              interfilediff_id, interfilediff_revision,\n                              file_index, onFileLoaded);\n        });\n    }\n\n    function onFileLoaded(xhr) {\n        $(\"#file_container_\" + filediff_id).replaceWith(xhr.responseText);\n\n        setupFileDiff();\n    }\n\n    function setupFileDiff() {\n        var key = \"file\" + filediff_id;\n\n        gFileAnchorToId[key] = {\n            'id': filediff_id,\n            'revision': filediff_revision\n        };\n\n        if (interfilediff_id) {\n            gInterdiffFileAnchorToId[key] = {\n                'id': interfilediff_id,\n                'revision': interfilediff_revision\n            };\n        }\n\n        var diffTable = $(\"#file\" + filediff_id);\n        diffTable.diffFile(comment_counts, key);\n\n        /* We must rebuild this every time. */\n        updateAnchors(diffTable);\n\n        if (gStartAtAnchor != null) {\n            /* See if we've loaded the anchor the user wants to start at. */\n            var anchor = $(\"a[name='\" + gStartAtAnchor + \"']\");\n\n            if (anchor.length != 0) {\n                scrollToAnchor(anchor);\n                gStartAtAnchor = null;\n            }\n        }\n\n        $.funcQueue(\"diff_files\").next();\n    }\n}\n\n\n/*\n * Toggles the display state of Whitespace chunks and lines.\n *\n * When a diff is loaded, by default, all whitespace only changes are shown.\n * This function hides the changes shown and show the hidden changes,\n * toggling the state.\n */\nfunction toggleWhitespaceChunks()\n{\n    var tables = $(\"table.sidebyside\");\n    var chunks = tables.children(\"tbody.whitespace-chunk\");\n\n    /* Dim the whole chunk */\n    chunks.toggleClass(\"replace\");\n\n    /* Dim the anchor to each chunk in the file list */\n    chunks.each(function() {\n        var target = this.id.split(\"chunk\")[1];\n        $(\"ol.index a[href=#\" + target + \"]\").toggleClass(\"dimmed\");\n    });\n\n    /* Remove chunk identifiers */\n    chunks.children(\":first-child\").toggleClass(\"first\");\n    chunks.children(\":last-child\").toggleClass(\"last\");\n\n    /* Toggle individual lines */\n    tables.find(\"tbody tr.whitespace-line\").toggleClass(\"dimmed\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ws\").toggle();\n\n    /* Toggle adjacent chunks, and show the whitespace message */\n    tables.children(\"tbody.whitespace-file\").toggle()\n                                            .siblings(\"tbody\")\n                                                .toggle();\n}\n\n\n/*\n * Read cookie to set user preferences for showing Extra Whitespace or not.\n *\n * Returns true by default, false only if a cookie is set.\n */\nfunction showExtraWhitespace()\n{\n    if (document.cookie && document.cookie != '') {\n        var cookies = document.cookie.split(\";\");\n        for (var i in cookies) {\n            var cookie = jQuery.trim(cookies[i]);\n            if (cookie == \"show_ew=false\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Write cookie to set user preferences for showing Extra Whitespace or not.\n *\n * This a session cookie.\n */\nfunction setExtraWhitespace(value)\n{\n    document.cookie=\"show_ew=\"+value+\"; path=/;\";\n}\n\n\n/*\n * Toggles the highlighting state of Extra Whitespace.\n *\n * This function turns off or on the highlighting through the ewhl class.\n */\nfunction toggleExtraWhitespace(init)\n{\n\n    /* Toggle the cookie value unless this is the first call */\n    if ( init == undefined) {\n        toggleExtraWhitespace.show_ew = !toggleExtraWhitespace.show_ew;\n        setExtraWhitespace(toggleExtraWhitespace.show_ew);\n    }\n    else {\n        /* Record initial value based on cookie setting */\n        toggleExtraWhitespace.show_ew = showExtraWhitespace();\n\n        /* Page is initially loaded with highlighting off */\n        if (!toggleExtraWhitespace.show_ew) {\n            return;\n        }\n    }\n\n    /* Toggle highlighting */\n    $(\"#diffs\").toggleClass(\"ewhl\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ew\").toggle();\n}\n\n\n$(document).ready(function() {\n    gDiff = gReviewRequest.createDiff(gRevision, gInterdiffRevision);\n\n    $(document).keypress(function(evt) {\n        if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n            return;\n        }\n\n        var keyChar = String.fromCharCode(evt.which);\n\n        for (var i = 0; i < gActions.length; i++) {\n            if (gActions[i].keys.indexOf(keyChar) != -1) {\n                gActions[i].onPress();\n                return false;\n            }\n        }\n    });\n\n    $(\"ul.controls li a.toggleWhitespaceButton\").click(function() {\n        toggleWhitespaceChunks();\n        return false;\n    });\n\n    $(\"ul.controls li a.toggleExtraWhitespaceButton\").click(function() {\n        toggleExtraWhitespace();\n        return false;\n    });\n\n    toggleExtraWhitespace('init');\n\n    /*\n     * Make sure any inputs on the page (such as the search box) don't\n     * bubble down key presses to the document.\n     */\n    $(\"input, textarea\").keypress(function(evt) {\n        evt.stopPropagation();\n    });\n\n    /* Check to see if there's an anchor we need to scroll to. */\n    var url = document.location.toString();\n\n    if (url.match(\"#\")) {\n        gStartAtAnchor = url.split(\"#\")[1];\n    }\n\n    $.funcQueue(\"diff_files\").start();\n\n    $(\"table.sidebyside tr td a.moved-to,\" +\n      \"table.sidebyside tr td a.moved-from\").click(function() {\n        var destination = $(this).attr(\"line\");\n\n        return !scrollToAnchor(\n            $(\"td a[target=\" + destination + \"]\", $(this).parents(\"table\"))\n                .parent().siblings().andSelf()\n                    .effect(\"highlight\", {}, 2000), false);\n    });\n});\n\n// vim: set et:\n", "code_before": "// Constants\nvar BACKWARD = -1;\nvar FORWARD  = 1;\nvar INVALID  = -1;\nvar DIFF_SCROLLDOWN_AMOUNT = 100;\nvar VISIBLE_CONTEXT_SIZE = 5;\n\nvar ANCHOR_COMMENT = 1;\nvar ANCHOR_FILE = 2;\nvar ANCHOR_CHUNK = 4;\n\n\n// State\nvar gDiff;\n\n\n/*\n * A list of key bindings for the page.\n */\nvar gActions = [\n    { // Previous file\n        keys: \"aAKP<m\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Next file\n        keys: \"fFJN>\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_FILE));\n        }\n    },\n\n    { // Previous diff\n        keys: \"sSkp,,\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Next diff\n        keys: \"dDjn..\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_CHUNK | ANCHOR_FILE));\n        }\n    },\n\n    { // Recenter\n        keys: unescape(\"%0D\"),\n        onPress: function() { scrollToAnchor($(gAnchors[gSelectedAnchor])); }\n    },\n\n    { // Previous comment\n        keys: \"[x\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(BACKWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Next comment\n        keys: \"]c\",\n        onPress: function() {\n            scrollToAnchor(GetNextAnchor(FORWARD, ANCHOR_COMMENT));\n        }\n    },\n\n    { // Go to header\n        keys: \"gu;\",\n        onPress: function() {}\n    },\n\n    { // Go to footer\n        keys: \"GU:\",\n        onPress: function() {}\n    }\n];\n\n\n// State variables\nvar gSelectedAnchor = INVALID;\nvar gFileAnchorToId = {};\nvar gInterdiffFileAnchorToId = {};\nvar gAnchors = $();\nvar gCommentDlg = null;\nvar gHiddenComments = {};\nvar gDiffHighlightBorder = null;\nvar gStartAtAnchor = null;\n\n\n/*\n * Creates a comment block in the diff viewer.\n *\n * @param {jQuery} beginRow      The first table row to attach to.\n * @param {jQuery} endRow        The last table row to attach to.\n * @param {int}    beginLineNum  The line number to attach to.\n * @param {int}    endLineNum    The line number to attach to.\n * @param {array}  comments      The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction DiffCommentBlock(beginRow, endRow, beginLineNum, endLineNum,\n                          comments) {\n    var self = this;\n\n    var table = beginRow.parents(\"table:first\")\n    var fileid = table[0].id;\n\n    this.filediff = gFileAnchorToId[fileid];\n    this.interfilediff = gInterdiffFileAnchorToId[fileid];\n    this.beginLineNum = beginLineNum;\n    this.endLineNum = endLineNum;\n    this.beginRow = beginRow;\n    this.endRow = endRow;\n    this.comments = [];\n    this.draftComment = null;\n\n    this.el = $(\"<span/>\")\n        .addClass(\"commentflag\")\n        .append($(\"<span/>\").addClass(\"commentflag-shadow\"))\n        .click(function() {\n            self.showCommentDlg();\n            return false;\n        });\n\n    $(window).bind(\"resize\", function(evt) {\n        self.updateSize();\n    });\n\n    var innerFlag = $(\"<span/>\")\n        .addClass(\"commentflag-inner\")\n        .appendTo(this.el);\n\n    this.countEl = $(\"<span/>\")\n        .appendTo(innerFlag);\n\n    if ($.browser.msie && $.browser.version == 6) {\n        /*\n         * Tooltips for some reason cause comment flags to disappear in IE6.\n         * So for now, just fake them and never show them.\n         */\n        this.tooltip = $(\"<div/>\");\n    } else {\n        this.tooltip = $.tooltip(this.el, {\n            side: \"rb\"\n        }).addClass(\"comments\");\n    }\n\n    this.anchor = $(\"<a/>\")\n        .attr(\"name\",\n              \"file\" + this.filediff['id'] + \"line\" + this.beginLineNum)\n        .addClass(\"comment-anchor\")\n        .appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.updateCount();\n    this.updateTooltip();\n    this.updateSize();\n\n    /* Now that we've built everything, add this to the DOM. */\n    this.beginRow[0].cells[0].appendChild(this.el[0]);\n}\n\n$.extend(DiffCommentBlock.prototype, {\n    /*\n     * Notifies the user of some update. This notification appears by the\n     * comment flag.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .text(text)\n            .appendTo(this.el);\n\n        bubble\n            .css({\n                left: this.el.width(),\n                top:  0,\n                opacity: 0\n            })\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n            });\n    },\n\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        this.tooltip.empty();\n        var list = $(\"<ul/>\");\n\n        if (this.draftComment) {\n            $(\"<li/>\")\n                .text(this.draftComment.text.truncate())\n                .addClass(\"draft\")\n                .appendTo(list);\n        }\n\n        for (var i = 0; i < this.comments.length; i++) {\n            $(\"<li/>\")\n                .text(this.comments[i].text.truncate())\n                .appendTo(list);\n        }\n\n        list.appendTo(this.tooltip);\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment) {\n            count++;\n        }\n\n        this.count = count;\n        this.countEl.html(this.count);\n    },\n\n    /*\n     * Updates the size of the comment flag.\n     */\n    updateSize: function() {\n        /*\n         * On IE and Safari, the marginTop in getExtents will be wrong.\n         * Force a value.\n         */\n        var extents = this.el.getExtents(\"m\", \"t\") || -4;\n        this.el.css(\"height\",\n                    this.endRow.offset().top + this.endRow.outerHeight() -\n                    this.beginRow.offset().top - extents);\n    },\n\n    /*\n     * Shows the comment dialog.\n     */\n    showCommentDlg: function() {\n        var self = this;\n\n        if (gCommentDlg == null) {\n            gCommentDlg = $(\"#comment-detail\")\n                .commentDlg()\n                .css(\"z-index\", 999);\n            gCommentDlg.appendTo(\"body\");\n        }\n\n        gCommentDlg\n            .one(\"close\", function() {\n                self._createDraftComment();\n\n                gCommentDlg\n                    .setDraftComment(self.draftComment)\n                    .setCommentsList(self.comments, \"comment\")\n                    .css({\n                        left: $(document).scrollLeft() +\n                              ($(window).width() - gCommentDlg.width()) / 2,\n                        top:  self.endRow.offset().top +\n                              self.endRow.height()\n                    })\n                    .open(self.el);\n            })\n            .close();\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.DiffComment(this.filediff, this.interfilediff,\n                                         this.beginLineNum, this.endLineNum,\n                                         textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            self.notify(\"Comment Deleted\");\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            self.draftComment = null;\n\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n                self.anchor.remove();\n            } else {\n                el.removeClass(\"draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n    }\n});\n\n\n/*\n * Registers a section as being a diff file.\n *\n * This handles all mouse actions on the diff, comment range selection, and\n * populatation of comment flags.\n *\n * @param {array}  lines  The lines containing comments. See the\n *                        addCommentFlags documentation for the format.\n * @param {string} key    A unique ID identifying the file the comments\n *                        belong too (typically based on the filediff_id).\n *\n * @return {jQuery} The diff file element.\n */\n$.fn.diffFile = function(lines, key) {\n    return this.each(function() {\n        var self = $(this);\n\n        /* State */\n        var selection = {\n            begin: null,\n            beginNum: 0,\n            end: null,\n            endNum: 0,\n            lastSeenIndex: 0\n        };\n\n        var ghostCommentFlag = $(\"<span/>\")\n            .addClass(\"commentflag\")\n            .addClass(\"ghost-commentflag\")\n            .append($(\"<span class='commentflag-shadow'/>\"))\n            .append($(\"<span class='commentflag-inner'/>\"))\n            .mousedown(function(e) { self.triggerHandler(\"mousedown\", e); })\n            .mouseup(function(e)   { self.triggerHandler(\"mouseup\", e);   })\n            .mouseover(function(e) { self.triggerHandler(\"mouseover\", e); })\n            .mouseout(function(e)  { self.triggerHandler(\"mouseout\", e);  })\n            .hide()\n            .appendTo(\"body\");\n\n        var ghostCommentFlagCell = null;\n\n\n        /* Events */\n        self\n            .mousedown(function(e) {\n                /*\n                 * Handles the mouse down event, which begins selection for\n                 * comments.\n                 *\n                 * @param {event} e  The mousedown event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    beginSelection($(node.parentNode));\n                    return false;\n                }\n\n                return true;\n            })\n            .mouseup(function(e) {\n                /*\n                 * Handles the mouse up event, which finalizes selection\n                 * of a range of lines.\n                 *\n                 * This will create a new comment block and display the\n                 * comment dialog.\n                 *\n                 * @param {event} e  The mouseup event.\n                 */\n                var node = e.target;\n\n                if (ghostCommentFlagCell != null) {\n                    node = ghostCommentFlagCell[0];\n                }\n\n                if (isLineNumCell(node)) {\n                    endSelection(getActualLineNumCell($(node)).parent());\n                } else {\n                    /*\n                     * The user clicked somewhere else. Move the anchor\n                     * point here if it's part of the diff.\n                     */\n                    var tbody = $(node).parents(\"tbody:first\");\n\n                    if (tbody.length > 0 &&\n                        (tbody.hasClass(\"delete\") || tbody.hasClass(\"insert\") ||\n                         tbody.hasClass(\"replace\"))) {\n                        gotoAnchor($(\"a:first\", tbody).attr(\"name\"), true);\n                    }\n                }\n\n                resetSelection();\n\n                return false;\n            })\n            .mouseover(function(e) {\n                /*\n                 * Handles the mouse over event. This will update the\n                 * selection, if there is one, to include this row in the\n                 * range, and set the \"selected\" class on the new row.\n                 *\n                 * @param {event} e  The mouseover event.\n                 */\n                var node = getActualLineNumCell($(e.target));\n                var row = node.parent();\n\n                if (isLineNumCell(node[0])) {\n                    addRowToSelection(row);\n                } else if (ghostCommentFlagCell != null &&\n                           node[0] != ghostCommentFlagCell[0]) {\n                    row.removeClass(\"selected\");\n                }\n            })\n            .mouseout(function(e) {\n                /*\n                 * Handles the mouse out event, removing any lines outside\n                 * the new range from the selection.\n                 *\n                 * @param {event} e  The mouseout event.\n                 */\n                var relTarget = e.relatedTarget;\n                var node = getActualLineNumCell($(e.fromElement ||\n                                                  e.originalTarget));\n\n                if (relTarget != ghostCommentFlag[0]) {\n                    ghostCommentFlag.hide();\n                    ghostCommentFlagCell = null;\n                }\n\n                if (selection.begin != null) {\n                    if (relTarget != null && isLineNumCell(relTarget)) {\n                        removeOldRowsFromSelection($(relTarget.parentNode));\n                    }\n                } else if (node != null && isLineNumCell(node[0])) {\n                    /*\n                     * Opera seems to generate lots of spurious mouse-out\n                     * events, which would cause us to get all sorts of\n                     * errors in here unless we check the target above.\n                     */\n                    node.parent().removeClass(\"selected\");\n                }\n            })\n            .bind(\"touchmove\", function(e) {\n                var firstTouch = e.originalEvent.targetTouches[0];\n                var target = document.elementFromPoint(firstTouch.pageX,\n                                                       firstTouch.pageY);\n                var node = getActualLineNumCell($(target));\n                var row = node.parent();\n\n                if (selection.lastSeenIndex == row[0].rowIndex) {\n                    return;\n                }\n\n                if (isLineNumCell(node[0])) {\n                    var row = node.parent();\n                    removeOldRowsFromSelection(row);\n                    addRowToSelection(row);\n                }\n            })\n            .bind(\"touchcancel\", function(e) {\n                resetSelection();\n            })\n            .proxyTouchEvents(\"touchstart touchend\");\n\n        addCommentFlags(self, lines, key);\n\n        /*\n         * Begins the selection of line numbers.\n         *\n         * @param {jQuery} row  The row to begin the selection on.\n         */\n        function beginSelection(row) {\n            selection.begin    = selection.end    = row;\n            selection.beginNum = selection.endNum =\n                parseInt(row.attr('line'));\n\n            selection.lastSeenIndex = row[0].rowIndex;\n            row.addClass(\"selected\");\n\n            self.disableSelection();\n        }\n\n        /*\n         * Finalizes the selection and pops up a comment dialog.\n         *\n         * @param {jquery} row  The row to end the selection on.\n         */\n        function endSelection(row) {\n            row.removeClass(\"selected\");\n\n            if (selection.beginNum == selection.endNum) {\n                /* See if we have a comment flag on the selected row. */\n                var commentFlag = row.find(\".commentflag\");\n\n                if (commentFlag.length == 1) {\n                    commentFlag.click()\n                    return;\n                }\n            }\n\n            /*\n             * Selection was finalized. Create the comment block\n             * and show the comment dialog.\n             */\n            var commentBlock = new DiffCommentBlock(\n                selection.begin,\n                selection.end,\n                selection.beginNum,\n                selection.endNum);\n            commentBlock.showCommentDlg();\n        }\n\n        /*\n         * Adds a row to the selection. This will update the selection range\n         * and mark the rows as selected.\n         *\n         * This row is assumed to be the most recently selected row, and\n         * will mark the new beginning or end of the selection.\n         *\n         * @param {jQuery} row  The row to add to the selection.\n         */\n        function addRowToSelection(row) {\n            row.css(\"cursor\", \"pointer\");\n\n            if (selection.begin != null) {\n                /* We have an active selection. */\n                var linenum = parseInt(row.attr(\"line\"));\n\n                if (linenum < selection.beginNum) {\n                    selection.beginNum = linenum;\n                    selection.begin = row;\n                } else if (linenum > selection.beginNum) {\n                    selection.end = row;\n                    selection.endNum = linenum;\n                }\n\n                var min = Math.min(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n                var max = Math.max(selection.lastSeenIndex,\n                                   row[0].rowIndex);\n\n                for (var i = min; i <= max; i++) {\n                    $(self[0].rows[i]).addClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = row[0].rowIndex;\n            } else {\n                var lineNumCell = row[0].cells[0];\n\n                /* See if we have a comment flag in here. */\n                if ($(\".commentflag\", lineNumCell).length == 0) {\n                    ghostCommentFlag\n                        .css(\"top\", row.offset().top - 1)\n                        .show()\n                        .parent()\n                            .removeClass(\"selected\");\n                    ghostCommentFlagCell = $(row[0].cells[0]);\n                }\n\n                row.addClass(\"selected\");\n            }\n        }\n\n        /*\n         * Removes any old rows from the selection, based on the most recent\n         * row selected.\n         *\n         * @param {jQuery} row  The last row selected.\n         */\n        function removeOldRowsFromSelection(row) {\n            var destRowIndex = row[0].rowIndex;\n\n            if (destRowIndex >= selection.begin[0].rowIndex) {\n                for (var i = selection.lastSeenIndex;\n                     i > destRowIndex;\n                     i--) {\n                    $(self[0].rows[i]).removeClass(\"selected\");\n                }\n\n                selection.lastSeenIndex = destRowIndex;\n            }\n        }\n\n        /*\n         * Resets the selection information.\n         */\n        function resetSelection() {\n            if (selection.begin != null) {\n                /* Reset the selection. */\n                var rows = self[0].rows;\n\n                for (var i = selection.begin[0].rowIndex;\n                     i <= selection.end[0].rowIndex;\n                     i++) {\n                    $(rows[i]).removeClass(\"selected\");\n                }\n\n                selection.begin    = selection.end    = null;\n                selection.beginNum = selection.endNum = 0;\n                selection.rows = [];\n            }\n\n            ghostCommentFlagCell = null;\n\n            /* Re-enable text selection on IE */\n            self.enableSelection();\n        }\n\n        /*\n         * Returns whether a particular cell is a line number cell.\n         *\n         * @param {HTMLElement} cell  The cell element.\n         *\n         * @return {bool} true if the cell is the line number cell.\n         */\n        function isLineNumCell(cell) {\n            return (cell.tagName == \"TH\" &&\n                    cell.parentNode.getAttribute('line'));\n        }\n\n\n        /*\n         * Returns the actual cell node in the table.\n         *\n         * If the node specified is the ghost flag, this will return the\n         * cell the ghost flag represents.\n         *\n         * If this is a comment flag inside a cell, this will return the\n         * comment flag's parent cell\n         *\n         * @return {jQuery} The row.\n         */\n        function getActualLineNumCell(node) {\n            if (node.hasClass(\"commentflag\")) {\n                if (node[0] == ghostCommentFlag[0]) {\n                    node = ghostCommentFlagCell;\n                } else {\n                    node = node.parent();\n                }\n            }\n\n            return node;\n        }\n    });\n};\n\n\n/*\n * Highlights a chunk of the diff.\n *\n * This will create and move four border elements around the chunk. We use\n * these border elements instead of setting a border since few browsers\n * render borders on <tbody> tags the same, and give us few options for\n * styling.\n */\n$.fn.highlightChunk = function() {\n    var firstHighlight = false;\n\n    if (!gDiffHighlightBorder) {\n        var borderEl = $(\"<div/>\")\n            .addClass(\"diff-highlight-border\")\n            .css(\"position\", \"absolute\");\n\n        gDiffHighlightBorder = {\n            top: borderEl.clone().appendTo(\"#diffs\"),\n            bottom: borderEl.clone().appendTo(\"#diffs\"),\n            left: borderEl.clone().appendTo(\"#diffs\"),\n            right: borderEl.clone().appendTo(\"#diffs\")\n        };\n\n        firstHighlight = true;\n    }\n\n    var el = this.parents(\"tbody:first, thead:first\");\n\n    var borderWidth = gDiffHighlightBorder.left.width();\n    var borderHeight = gDiffHighlightBorder.top.height();\n    var borderOffsetX = borderWidth / 2;\n    var borderOffsetY = borderHeight / 2;\n\n    if ($.browser.msie && $.browser.version <= 8) {\n        /* On IE, the black rectangle is too far to the top. */\n        borderOffsetY = -borderOffsetY;\n\n        if ($.browser.msie && $.browser.version == 8) {\n            /* And on IE8, it's also too far to the left. */\n            borderOffsetX = -borderOffsetX;\n        }\n    }\n\n    var updateQueued = false;\n    var oldLeft;\n    var oldTop;\n    var oldWidth;\n    var oldHeight;\n\n    /*\n     * Updates the position of the border elements.\n     */\n    function updatePosition(event) {\n        if (event && event.target &&\n            event.target != window &&\n            !event.target.getElementsByTagName) {\n\n            /*\n             * This is not a container. It might be a text node.\n             * Ignore it.\n             */\n            return;\n        }\n\n        var offset = el.position();\n\n        if (!offset) {\n            return;\n        }\n\n        var left = Math.round(offset.left);\n        var top = Math.round(offset.top);\n        var width = el.outerWidth();\n        var height = el.outerHeight();\n\n        if (left == oldLeft &&\n            top == oldTop &&\n            width == oldWidth &&\n            height == oldHeight) {\n\n            /* The position and size haven't actually changed. */\n            return;\n        }\n\n        var outerHeight = height + borderHeight;\n        var outerWidth  = width + borderWidth;\n        var outerLeft   = left - borderOffsetX;\n        var outerTop    = top - borderOffsetY;\n\n        gDiffHighlightBorder.left.css({\n            left: outerLeft,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.top.css({\n            left: outerLeft,\n            top: outerTop,\n            width: outerWidth\n        });\n\n        gDiffHighlightBorder.right.css({\n            left: outerLeft + width,\n            top: outerTop,\n            height: outerHeight\n        });\n\n        gDiffHighlightBorder.bottom.css({\n            left: outerLeft,\n            top: outerTop + height,\n            width: outerWidth\n        });\n\n        oldLeft = left;\n        oldTop = top;\n        oldWidth = width;\n        oldHeight = height;\n\n        updateQueued = false;\n    }\n\n    /*\n     * Updates the position after 50ms so we don't call updatePosition too\n     * many times in response to a DOM change.\n     */\n    function queueUpdatePosition(event) {\n        if (!updateQueued) {\n            updateQueued = true;\n            setTimeout(function() { updatePosition(event); }, 50);\n        }\n    }\n\n    $(document).bind(\"DOMNodeInserted.highlightChunk\", queueUpdatePosition);\n    $(document).bind(\"DOMNodeRemoved.highlightChunk\", queueUpdatePosition);\n    $(window).bind(\"resize.highlightChunk\", updatePosition);\n\n    if (firstHighlight) {\n        /*\n         * There seems to be a bug where we often won't get this right\n         * away on page load. Race condition, perhaps.\n         */\n        queueUpdatePosition();\n    } else {\n        updatePosition();\n    }\n\n    return this;\n};\n\n\n/*\n * Sets the active anchor on the page, optionally scrolling to it.\n *\n * @param {string} name    The anchor name.\n * @param {bool}   scroll  If true, scrolls the page to the anchor.\n */\nfunction gotoAnchor(name, scroll) {\n    return scrollToAnchor($(\"a[name=\" + name + \"]\"), scroll || false);\n}\n\n\n/*\n * Finds the row in a table matching the specified line number.\n *\n * @param {HTMLElement} table     The table element.\n * @param {int}         linenum   The line number to search for.\n * @param {int}         startRow  Optional start row to search.\n * @param {int}         endRow    Optional end row to search.\n *\n * @param {HTMLElement} The resulting row, or null if not found.\n */\nfunction findLineNumRow(table, linenum, startRow, endRow) {\n    var row = null;\n    var row_offset = 1; // Get past the headers.\n\n    if (table.rows.length - row_offset > linenum) {\n        row = table.rows[row_offset + linenum];\n\n        // Account for the \"x lines hidden\" row.\n        if (row != null && parseInt(row.getAttribute('line')) == linenum) {\n            return row;\n        }\n    }\n\n    if (startRow) {\n        // startRow already includes the offset, so we need to remove it\n        startRow -= row_offset;\n    }\n\n    var low = startRow || 1;\n    var high = Math.min(endRow || table.rows.length, table.rows.length);\n\n    if (endRow != undefined && endRow < table.rows.length) {\n        /* See if we got lucky and found it in the last row. */\n        if (parseInt(table.rows[endRow].getAttribute('line')) == linenum) {\n            return table.rows[endRow];\n        }\n    } else if (row != null) {\n        /*\n         * We collapsed the rows (unless someone mucked with the DB),\n         * so the desired row is less than the row number retrieved.\n         */\n        high = Math.min(high, row_offset + linenum);\n    }\n\n    /* Binary search for this cell. */\n    for (var i = Math.round((low + high) / 2); low < high - 1;) {\n        row = table.rows[row_offset + i];\n\n        if (!row) {\n            /*\n             * should not happen, unless we miscomputed high\n             */\n            high--;\n            /*\n             * will not do much if low + high is odd\n             * but we'll catch up on the next iteration\n             */\n            i = Math.round((low + high) / 2);\n            continue;\n        }\n\n        var value = parseInt(row.getAttribute('line'))\n\n        if (!value) {\n            /*\n             * bad luck, let's look around.\n             * We'd expect to find a value on the first try\n             * but the following makes sure we explore all\n             * rows\n             */\n            var found = false;\n\n            for (var k = 1; k <= (high-low) / 2; k++) {\n                row = table.rows[row_offset + i + k];\n                if (row && parseInt(row.getAttribute('line'))) {\n                    i = i + k;\n                    found = true;\n                    break;\n                } else {\n                    row = table.rows[row_offset + i - k];\n                    if (row && parseInt(row.getAttribute('line'))) {\n                        i = i - k;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found) {\n                value = parseInt(row.getAttribute('line'));\n            } else {\n                return null;\n            }\n        }\n\n        /* See if we can use simple math to find the row quickly. */\n        var guessRowNum = linenum - value + row_offset + i;\n\n        if (guessRowNum >= 0 && guessRowNum < table.rows.length) {\n            var guessRow = table.rows[guessRowNum];\n\n            if (guessRow\n                && parseInt(guessRow.getAttribute('line')) == linenum) {\n                /* We found it using maths! */\n                return guessRow;\n            }\n        }\n\n        var oldHigh = high;\n        var oldLow = low;\n\n        if (value > linenum) {\n            high = i;\n        } else if (value < linenum) {\n            low = i;\n        } else {\n            return row;\n        }\n\n        /*\n         * Make sure we don't get stuck in an infinite loop. This can happen\n         * when a comment is placed in a line that isn't being shown.\n         */\n        if (oldHigh == high && oldLow == low) {\n            break;\n        }\n\n        i = Math.round((low + high) / 2);\n    }\n\n    // Well.. damn. Ignore this then.\n    return null;\n}\n\n\n/*\n * Adds comment flags to a table.\n *\n * lines is an array of dictionaries grouping together comments on the\n * same line. The dictionaries contain the following keys:\n *\n *    text       - The text of the comment.\n *    line       - The first line number.\n *    num_lines  - The number of lines the comment spans.\n *    user       - A dictionary containing \"username\" and \"name\" keys\n *                 for the user.\n *    url        - The URL for the comment.\n *    localdraft - true if this is the current user's draft comment.\n *\n * @param {HTMLElement} table  The table to add flags to.\n * @param {object}      lines  The comment lines to add.\n * @param {string}      key    A unique ID identifying the file the comments\n *                             belong too (typically based on the filediff_id).\n */\nfunction addCommentFlags(table, lines, key) {\n    var remaining = {};\n\n    var prevBeginRowIndex = undefined;\n\n    for (var i in lines) {\n        var line = lines[i];\n        var numLines = line.num_lines;\n\n        var beginLineNum = line.linenum;\n        var endLineNum = beginLineNum + numLines - 1;\n        var beginRow = findLineNumRow(table[0], beginLineNum,\n                                      prevBeginRowIndex);\n\n        if (beginRow != null) {\n            prevBeginRowIndex = beginRow.rowIndex;\n\n            var endRow = (endLineNum == beginLineNum\n                          ? beginRow\n                          : findLineNumRow(table[0], endLineNum,\n                                           prevBeginRowIndex,\n                                           prevBeginRowIndex + numLines - 1));\n\n\n            /*\n             * Note that endRow might be null if it exists in a collapsed\n             * region, so we can get away with just using beginRow if we\n             * need to.\n             */\n            new DiffCommentBlock($(beginRow), $(endRow || beginRow),\n                                 beginLineNum, endLineNum, line.comments);\n        } else {\n            remaining[beginLineNum] = line;\n        }\n    }\n\n    gHiddenComments[key] = remaining;\n}\n\n\n/*\n * Expands a chunk of the diff.\n *\n * @param {string} fileid              The file ID.\n * @param {string} filediff_id         The FileDiff ID.\n * @param {string} revision            The revision of the file.\n * @param {string} interdiff_revision  The interdiff revision of the file.\n * @param {int}    chunk_index         The chunk index number.\n * @param {string} tbody_id            The tbody ID to insert into.\n */\nfunction expandChunk(fileid, filediff_id, revision, interdiff_revision,\n                     chunk_index, link) {\n    gDiff.getDiffFragment(fileid, filediff_id, revision, interdiff_revision,\n                          chunk_index, function(html) {\n        var tbody = $(link).parents(\"tbody.diff-header\");\n        var table = tbody.parent();\n        var key = \"file\" + filediff_id;\n\n        tbody.replaceWith(html);\n        addCommentFlags(table, gHiddenComments[key], key);\n\n        /* The selection rectangle may not update -- bug #1353. */\n        $(gAnchors[gSelectedAnchor]).highlightChunk();\n    });\n}\n\n\n/*\n * Scrolls to the anchor at a specified location.\n *\n * @param {jQuery} anchor    The anchor jQuery instance.\n * @param {bool}   noscroll  true if the page should not be scrolled.\n *\n * @return {bool} true if the anchor was found, or false if not.\n */\nfunction scrollToAnchor(anchor, noscroll) {\n    if (anchor.length == 0) {\n        return false;\n    }\n\n    if (anchor.parent().is(\":hidden\")) {\n        return false;\n    }\n\n    if (!noscroll) {\n        $(window).scrollTop(anchor.offset().top - DIFF_SCROLLDOWN_AMOUNT);\n    }\n\n    anchor.highlightChunk();\n\n    for (var i = 0; i < gAnchors.length; i++) {\n        if (gAnchors[i] == anchor[0]) {\n            gSelectedAnchor = i;\n            break;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Returns the next navigatable anchor in the specified direction.\n *\n * @param {int} dir         The direction (BACKWARD or FORWARD)\n * @param {int} anchorType  The type of the anchor as a bitmask\n *                          (ANCHOR_COMMENT, ANCHOR_FILE, ANCHOR_CHUNK)\n *\n * @return {jQuery} The found anchor jQuery instance, or INVALID.\n */\nfunction GetNextAnchor(dir, anchorType) {\n    for (var anchor = gSelectedAnchor + dir;\n         anchor >= 0 && anchor < gAnchors.length;\n         anchor = anchor + dir) {\n\n        var anchorEl = $(gAnchors[anchor]);\n\n        if (((anchorType & ANCHOR_COMMENT) &&\n             anchorEl.hasClass(\"comment-anchor\")) ||\n            ((anchorType & ANCHOR_FILE) &&\n             anchorEl.hasClass(\"file-anchor\")) ||\n            ((anchorType & ANCHOR_CHUNK) &&\n             anchorEl.hasClass(\"chunk-anchor\"))) {\n            return anchorEl;\n        }\n    }\n\n    return $([]);\n}\n\n\n/*\n * Updates the list of known anchors based on named anchors in the specified\n * table. This is called after every part of the diff that we loaded.\n *\n * If no anchor is selected, we'll try to select the first one.\n *\n * @param {jQuery} table  The table to load anchors from.\n */\nfunction updateAnchors(table) {\n    gAnchors = gAnchors.add($(\"a[name]\", table));\n\n    /* Skip over the change index to the first item */\n    if (gSelectedAnchor == -1 && gAnchors.length > 0) {\n      gSelectedAnchor = 0;\n      $(gAnchors[gSelectedAnchor]).highlightChunk();\n    }\n}\n\n\n/*\n * Progressively load a diff.\n *\n * When the diff is loaded, it will be placed into the appropriate location\n * in the diff viewer, rebuild the anchors, and move on to the next file.\n *\n * @param {string} filediff_id               The filediff ID\n * @param {string} filediff_revision         The filediff revision\n * @param {string} interfilediff_id          The interfilediff ID (optional)\n * @param {string} interfilediff_revision    The interfilediff revision\n *                                           (optional)\n * @param {string} file_index                The file index\n * @param {dict}   comment_counts            The comments for this region\n */\nfunction loadFileDiff(filediff_id, filediff_revision,\n                      interfilediff_id, interfilediff_revision,\n                      file_index,\n                      comment_counts) {\n\n    if ($(\"#file\" + filediff_id).length == 1) {\n        /* We already have this one. This is probably a pre-loaded file. */\n        setupFileDiff();\n    } else {\n        $.funcQueue(\"diff_files\").add(function() {\n            gDiff.getDiffFile(filediff_id, filediff_revision,\n                              interfilediff_id, interfilediff_revision,\n                              file_index, onFileLoaded);\n        });\n    }\n\n    function onFileLoaded(xhr) {\n        $(\"#file_container_\" + filediff_id).replaceWith(xhr.responseText);\n\n        setupFileDiff();\n    }\n\n    function setupFileDiff() {\n        var key = \"file\" + filediff_id;\n\n        gFileAnchorToId[key] = {\n            'id': filediff_id,\n            'revision': filediff_revision\n        };\n\n        if (interfilediff_id) {\n            gInterdiffFileAnchorToId[key] = {\n                'id': interfilediff_id,\n                'revision': interfilediff_revision\n            };\n        }\n\n        var diffTable = $(\"#file\" + filediff_id);\n        diffTable.diffFile(comment_counts, key);\n\n        /* We must rebuild this every time. */\n        updateAnchors(diffTable);\n\n        if (gStartAtAnchor != null) {\n            /* See if we've loaded the anchor the user wants to start at. */\n            var anchor = $(\"a[name='\" + gStartAtAnchor + \"']\");\n\n            if (anchor.length != 0) {\n                scrollToAnchor(anchor);\n                gStartAtAnchor = null;\n            }\n        }\n\n        $.funcQueue(\"diff_files\").next();\n    }\n}\n\n\n/*\n * Toggles the display state of Whitespace chunks and lines.\n *\n * When a diff is loaded, by default, all whitespace only changes are shown.\n * This function hides the changes shown and show the hidden changes,\n * toggling the state.\n */\nfunction toggleWhitespaceChunks()\n{\n    var tables = $(\"table.sidebyside\");\n    var chunks = tables.children(\"tbody.whitespace-chunk\");\n\n    /* Dim the whole chunk */\n    chunks.toggleClass(\"replace\");\n\n    /* Dim the anchor to each chunk in the file list */\n    chunks.each(function() {\n        var target = this.id.split(\"chunk\")[1];\n        $(\"ol.index a[href=#\" + target + \"]\").toggleClass(\"dimmed\");\n    });\n\n    /* Remove chunk identifiers */\n    chunks.children(\":first-child\").toggleClass(\"first\");\n    chunks.children(\":last-child\").toggleClass(\"last\");\n\n    /* Toggle individual lines */\n    tables.find(\"tbody tr.whitespace-line\").toggleClass(\"dimmed\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ws\").toggle();\n\n    /* Toggle adjacent chunks, and show the whitespace message */\n    tables.children(\"tbody.whitespace-file\").toggle()\n                                            .siblings(\"tbody\")\n                                                .toggle();\n}\n\n\n/*\n * Read cookie to set user preferences for showing Extra Whitespace or not.\n *\n * Returns true by default, false only if a cookie is set.\n */\nfunction showExtraWhitespace()\n{\n    if (document.cookie && document.cookie != '') {\n        var cookies = document.cookie.split(\";\");\n        for (var i in cookies) {\n            var cookie = jQuery.trim(cookies[i]);\n            if (cookie == \"show_ew=false\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Write cookie to set user preferences for showing Extra Whitespace or not.\n *\n * This a session cookie.\n */\nfunction setExtraWhitespace(value)\n{\n    document.cookie=\"show_ew=\"+value+\"; path=/;\";\n}\n\n\n/*\n * Toggles the highlighting state of Extra Whitespace.\n *\n * This function turns off or on the highlighting through the ewhl class.\n */\nfunction toggleExtraWhitespace(init)\n{\n\n    /* Toggle the cookie value unless this is the first call */\n    if ( init == undefined) {\n        toggleExtraWhitespace.show_ew = !toggleExtraWhitespace.show_ew;\n        setExtraWhitespace(toggleExtraWhitespace.show_ew);\n    }\n    else {\n        /* Record initial value based on cookie setting */\n        toggleExtraWhitespace.show_ew = showExtraWhitespace();\n\n        /* Page is initially loaded with highlighting off */\n        if (!toggleExtraWhitespace.show_ew) {\n            return;\n        }\n    }\n\n    /* Toggle highlighting */\n    $(\"#diffs\").toggleClass(\"ewhl\");\n\n    /* Toggle the display of the button itself */\n    $(\".review-request ul.controls li.ew\").toggle();\n}\n\n\n$(document).ready(function() {\n    gDiff = gReviewRequest.createDiff(gRevision, gInterdiffRevision);\n\n    $(document).keypress(function(evt) {\n        if (evt.altKey || evt.ctrlKey || evt.metaKey) {\n            return;\n        }\n\n        var keyChar = String.fromCharCode(evt.which);\n\n        for (var i = 0; i < gActions.length; i++) {\n            if (gActions[i].keys.indexOf(keyChar) != -1) {\n                gActions[i].onPress();\n                return false;\n            }\n        }\n    });\n\n    $(\"ul.controls li a.toggleWhitespaceButton\").click(function() {\n        toggleWhitespaceChunks();\n        return false;\n    });\n\n    $(\"ul.controls li a.toggleExtraWhitespaceButton\").click(function() {\n        toggleExtraWhitespace();\n        return false;\n    });\n\n    toggleExtraWhitespace('init');\n\n    /*\n     * Make sure any inputs on the page (such as the search box) don't\n     * bubble down key presses to the document.\n     */\n    $(\"input, textarea\").keypress(function(evt) {\n        evt.stopPropagation();\n    });\n\n    /* Check to see if there's an anchor we need to scroll to. */\n    var url = document.location.toString();\n\n    if (url.match(\"#\")) {\n        gStartAtAnchor = url.split(\"#\")[1];\n    }\n\n    $.funcQueue(\"diff_files\").start();\n\n    $(\"table.sidebyside tr td a.moved-to,\" +\n      \"table.sidebyside tr td a.moved-from\").click(function() {\n        var destination = $(this).attr(\"line\");\n\n        return !scrollToAnchor(\n            $(\"td a[target=\" + destination + \"]\", $(this).parents(\"table\"))\n                .parent().siblings().andSelf()\n                    .effect(\"highlight\", {}, 2000), false);\n    });\n});\n\n// vim: set et:\n", "patch": "@@ -160,6 +160,9 @@ function DiffCommentBlock(beginRow, endRow, beginLineNum, endLineNum,\n         for (var i in comments) {\n             var comment = comments[i];\n \n+            // We load in encoded text, so decode it.\n+            comment.text = $(\"<div/>\").html(comment.text).text();\n+\n             if (comment.localdraft) {\n                 this._createDraftComment(comment.text);\n             } else {", "file_path": "files/2011_11/3", "file_language": "js", "file_name": "reviewboard/htdocs/media/rb/js/diffviewer.js", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/reviewboard/reviewboard/raw/7a0a9d94555502278534dedcf2d75e9fccce8c3d/reviewboard%2Fhtdocs%2Fmedia%2Frb%2Fjs%2Fscreenshots.js", "code": "/*\n * Creates a comment block to the screenshot comments area.\n *\n * @param {int}    x          The X area of the block.\n * @param {int}    y          The Y area of the block.\n * @param {int}    width      The block's width.\n * @param {int}    height     The block's height.\n * @param {jQuery} container  The container for the comment block.\n * @param {array}  comments   The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction CommentBlock(x, y, width, height, container, comments) {\n    var self = this;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.hasDraft = false;\n    this.comments = [];\n    this.canDelete = false;\n    this.draftComment = null;\n\n    this.el = $('<div class=\"selection\"/>').appendTo(container);\n    this.tooltip = $.tooltip(this.el, {\n        side: \"lrbt\"\n    }).addClass(\"comments\");\n    this.flag = $('<div class=\"selection-flag\"/>').appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            // We load in encoded text, so decode it.\n            comment.text = $(\"<div/>\").html(comment.text).text();\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.el\n        .move(this.x, this.y, \"absolute\")\n        .width(this.width)\n        .height(this.height);\n\n    this.updateCount();\n    this.updateTooltip();\n\n    return this;\n}\n\njQuery.extend(CommentBlock.prototype, {\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        function addEntry(text) {\n            var item = $(\"<li>\").appendTo(list);\n            item.text(text.truncate());\n            return item;\n        }\n\n        this.tooltip.empty();\n        var list = $(\"<ul/>\").appendTo(this.tooltip);\n\n        if (this.draftComment != null) {\n            addEntry(this.draftComment.text).addClass(\"draft\");\n        }\n\n        $(this.comments).each(function(i) {\n            addEntry(this.text);\n        });\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment != null) {\n            count++;\n        }\n\n        this.count = count;\n        this.flag.html(count);\n    },\n\n    /*\n     * Notifies the user of some update. This notification appears in the\n     * comment area.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text, cb) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .appendTo(this.el)\n            .text(text);\n\n        bubble\n            .css(\"opacity\", 0)\n            .move(Math.round((this.el.width()  - bubble.width())  / 2),\n                  Math.round((this.el.height() - bubble.height()) / 2))\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n\n                if ($.isFunction(cb)) {\n                    cb();\n                }\n            });\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.ScreenshotComment(gScreenshotId,\n                                               this.x, this.y, this.width,\n                                               this.height, textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            el.queue(function() {\n                self.notify(\"Comment Deleted\", function() {\n                    el.dequeue();\n                });\n            });\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n            } else {\n                el.removeClass(\"draft\");\n                self.flag.removeClass(\"flag-draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n        this.flag.addClass(\"flag-draft\");\n    }\n});\n\n\n/*\n * Creates a box for creating and seeing all comments on a screenshot.\n *\n * @param {object} regions  The regions containing comments.\n *\n * @return {jQuery} This jQuery.\n */\njQuery.fn.screenshotCommentBox = function(regions) {\n    var self = this;\n\n    /* State */\n    var activeCommentBlock = null;\n\n    /* Page elements */\n    var image = $(\"img\", this);\n\n    var selectionArea =\n        $('<div id=\"selection-container\"/>')\n        .prependTo(this);\n\n    var activeSelection =\n        $('<div id=\"selection-interactive\"/>')\n        .prependTo(selectionArea)\n        .hide();\n\n    var commentDetail = $(\"#comment-detail\")\n        .commentDlg()\n        .bind(\"close\", function() { activeCommentBlock = null; })\n        .css(\"z-index\", 999);\n    commentDetail.appendTo(\"body\");\n\n    /*\n     * Register events on the selection area for handling new comment\n     * creation.\n     */\n    $([image[0], selectionArea[0]])\n        .mousedown(function(evt) {\n            if (evt.which == 1 && !activeCommentBlock &&\n                !$(evt.target).hasClass(\"selection-flag\")) {\n                var offset = selectionArea.offset();\n                activeSelection.beginX =\n                    evt.pageX - Math.floor(offset.left) - 1;\n                activeSelection.beginY =\n                    evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .move(activeSelection.beginX, activeSelection.beginY)\n                    .width(1)\n                    .height(1)\n                    .show();\n\n                if (activeSelection.is(\":hidden\")) {\n                    commentDetail.hide();\n                }\n\n                return false;\n            }\n        })\n        .mouseup(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                evt.stopPropagation();\n\n                var width  = activeSelection.width();\n                var height = activeSelection.height();\n                var offset = activeSelection.position();\n\n                activeSelection.hide();\n\n                /*\n                 * If we don't pass an arbitrary minimum size threshold,\n                 * don't do anything.  This helps avoid making people mad\n                 * if they accidentally click on the image.\n                 */\n                if (width > 5 && height > 5) {\n                    if (!activeCommentBlock) {\n                        showCommentDlg(addCommentBlock(offset.left,\n                                                       offset.top,\n                                                       width, height));\n                    } else {\n                        // TODO: Reposition the old block. */\n                    }\n                }\n            }\n        })\n        .mousemove(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                var offset = selectionArea.offset();\n                var x = evt.pageX - Math.floor(offset.left) - 1;\n                var y = evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .css(activeSelection.beginX <= x\n                         ? {\n                               left:  activeSelection.beginX,\n                               width: x - activeSelection.beginX\n                           }\n                         : {\n                               left:  x,\n                               width: activeSelection.beginX - x\n                           })\n                    .css(activeSelection.beginY <= y\n                         ? {\n                               top:    activeSelection.beginY,\n                               height: y - activeSelection.beginY\n                           }\n                         : {\n                               top:    y,\n                               height: activeSelection.beginY - y\n                           });\n\n                return false;\n            }\n        })\n        .proxyTouchEvents();\n\n    /*\n     * Register a hover event to hide the comments when the mouse is not\n     * over the comment area.\n     */\n    this.hover(\n        function() {\n            selectionArea.show();\n        },\n        function() {\n            if (activeSelection.is(\":hidden\") &&\n                commentDetail.is(\":hidden\")) {\n                selectionArea.hide();\n            }\n        }\n    );\n\n    /*\n     * Register a resize event to reposition the selection area on page\n     * resize, so that comments are in the right locations.\n     */\n    $(window)\n        .resize(function() {\n            var offset = image.position();\n\n            /*\n             * The margin: 0 auto means that position.left() will return\n             * the left-most part of the entire block, rather than the actual\n             * position of the image on Chrome. Every other browser returns 0\n             * for this margin, as we'd expect. So, just play it safe and\n             * offset by the margin-left. (Bug #1050)\n             */\n            offset.left += image.getExtents(\"m\", \"l\");\n\n            if ($.browser.msie && $.browser.version == 6) {\n                offset.left -= self.getExtents(\"mp\", \"l\");\n            }\n\n            selectionArea\n                .width(image.width())\n                .height(image.height())\n                .css(\"left\", offset.left);\n        })\n        .triggerHandler(\"resize\");\n\n    /* Add all existing comment regions to the page. */\n    for (region in regions) {\n        var comments = regions[region];\n        addCommentBlock(comments[0].x, comments[0].y,\n                        comments[0].w, comments[0].h,\n                        comments);\n    }\n\n    /*\n     * Adds a new comment block to the selection area. This may contain\n     * existing comments or may be a newly created comment block.\n     *\n     * @param {int}   x         The X area of the block.\n     * @param {int}   y         The Y area of the block.\n     * @param {int}   width     The block's width.\n     * @param {int}   height    The block's height.\n     * @param {array} comments  The list of comments in this block.\n     *\n     * @return {CommentBlock} The new comment block.\n     */\n    function addCommentBlock(x, y, width, height, comments) {\n        var commentBlock = new CommentBlock(x, y, width, height,\n                                            selectionArea, comments)\n        commentBlock.el.click(function() {\n            showCommentDlg(commentBlock);\n        });\n\n        return commentBlock;\n    }\n\n    /*\n     * Shows the comment details dialog for a comment block.\n     *\n     * @param {CommentBlock} commentBlock  The comment block to show.\n     */\n    function showCommentDlg(commentBlock) {\n        commentDetail\n            .one(\"close\", function() {\n                commentBlock._createDraftComment();\n                activeCommentBlock = commentBlock;\n\n                commentDetail\n                    .setDraftComment(commentBlock.draftComment)\n                    .setCommentsList(commentBlock.comments,\n                                     \"screenshot_comment\")\n                    .positionToSide(commentBlock.flag, {\n                        side: 'b',\n                        fitOnScreen: true\n                    });\n                commentDetail.open();\n            })\n            .close()\n    }\n\n    return this;\n}\n\n// vim: set et ts=4:\n", "code_before": "/*\n * Creates a comment block to the screenshot comments area.\n *\n * @param {int}    x          The X area of the block.\n * @param {int}    y          The Y area of the block.\n * @param {int}    width      The block's width.\n * @param {int}    height     The block's height.\n * @param {jQuery} container  The container for the comment block.\n * @param {array}  comments   The list of comments in this block.\n *\n * @return {object} The comment block.\n */\nfunction CommentBlock(x, y, width, height, container, comments) {\n    var self = this;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.hasDraft = false;\n    this.comments = [];\n    this.canDelete = false;\n    this.draftComment = null;\n\n    this.el = $('<div class=\"selection\"/>').appendTo(container);\n    this.tooltip = $.tooltip(this.el, {\n        side: \"lrbt\"\n    }).addClass(\"comments\");\n    this.flag = $('<div class=\"selection-flag\"/>').appendTo(this.el);\n\n    /*\n     * Find out if there's any draft comments, and filter them out of the\n     * stored list of comments.\n     */\n    if (comments && comments.length > 0) {\n        for (var i in comments) {\n            var comment = comments[i];\n\n            if (comment.localdraft) {\n                this._createDraftComment(comment.text);\n            } else {\n                this.comments.push(comment);\n            }\n        }\n    } else {\n        this._createDraftComment();\n    }\n\n    this.el\n        .move(this.x, this.y, \"absolute\")\n        .width(this.width)\n        .height(this.height);\n\n    this.updateCount();\n    this.updateTooltip();\n\n    return this;\n}\n\njQuery.extend(CommentBlock.prototype, {\n    /*\n     * Updates the tooltip contents.\n     */\n    updateTooltip: function() {\n        function addEntry(text) {\n            var item = $(\"<li>\").appendTo(list);\n            item.text(text.truncate());\n            return item;\n        }\n\n        this.tooltip.empty();\n        var list = $(\"<ul/>\").appendTo(this.tooltip);\n\n        if (this.draftComment != null) {\n            addEntry(this.draftComment.text).addClass(\"draft\");\n        }\n\n        $(this.comments).each(function(i) {\n            addEntry(this.text);\n        });\n    },\n\n    /*\n     * Updates the displayed number of comments in the comment block.\n     *\n     * If there's a draft comment, it will be added to the count. Otherwise,\n     * this depends solely on the number of published comments.\n     */\n    updateCount: function() {\n        var count = this.comments.length;\n\n        if (this.draftComment != null) {\n            count++;\n        }\n\n        this.count = count;\n        this.flag.html(count);\n    },\n\n    /*\n     * Notifies the user of some update. This notification appears in the\n     * comment area.\n     *\n     * @param {string} text  The notification text.\n     */\n    notify: function(text, cb) {\n        var offset = this.el.offset();\n\n        var bubble = $(\"<div/>\")\n            .addClass(\"bubble\")\n            .appendTo(this.el)\n            .text(text);\n\n        bubble\n            .css(\"opacity\", 0)\n            .move(Math.round((this.el.width()  - bubble.width())  / 2),\n                  Math.round((this.el.height() - bubble.height()) / 2))\n            .animate({\n                top: \"-=10px\",\n                opacity: 0.8\n            }, 350, \"swing\")\n            .delay(1200)\n            .animate({\n                top: \"+=10px\",\n                opacity: 0\n            }, 350, \"swing\", function() {\n                bubble.remove();\n\n                if ($.isFunction(cb)) {\n                    cb();\n                }\n            });\n    },\n\n    _createDraftComment: function(textOnServer) {\n        if (this.draftComment != null) {\n            return;\n        }\n\n        var self = this;\n        var el = this.el;\n        var comment = new RB.ScreenshotComment(gScreenshotId,\n                                               this.x, this.y, this.width,\n                                               this.height, textOnServer);\n\n        $.event.add(comment, \"textChanged\", function() {\n            self.updateTooltip();\n        });\n\n        $.event.add(comment, \"deleted\", function() {\n            el.queue(function() {\n                self.notify(\"Comment Deleted\", function() {\n                    el.dequeue();\n                });\n            });\n        });\n\n        $.event.add(comment, \"destroyed\", function() {\n            /* Discard the comment block if empty. */\n            if (self.comments.length == 0) {\n                el.fadeOut(350, function() { el.remove(); })\n            } else {\n                el.removeClass(\"draft\");\n                self.flag.removeClass(\"flag-draft\");\n                self.updateCount();\n                self.updateTooltip();\n            }\n        });\n\n        $.event.add(comment, \"saved\", function() {\n            self.updateCount();\n            self.updateTooltip();\n            self.notify(\"Comment Saved\");\n            showReviewBanner();\n        });\n\n        this.draftComment = comment;\n        el.addClass(\"draft\");\n        this.flag.addClass(\"flag-draft\");\n    }\n});\n\n\n/*\n * Creates a box for creating and seeing all comments on a screenshot.\n *\n * @param {object} regions  The regions containing comments.\n *\n * @return {jQuery} This jQuery.\n */\njQuery.fn.screenshotCommentBox = function(regions) {\n    var self = this;\n\n    /* State */\n    var activeCommentBlock = null;\n\n    /* Page elements */\n    var image = $(\"img\", this);\n\n    var selectionArea =\n        $('<div id=\"selection-container\"/>')\n        .prependTo(this);\n\n    var activeSelection =\n        $('<div id=\"selection-interactive\"/>')\n        .prependTo(selectionArea)\n        .hide();\n\n    var commentDetail = $(\"#comment-detail\")\n        .commentDlg()\n        .bind(\"close\", function() { activeCommentBlock = null; })\n        .css(\"z-index\", 999);\n    commentDetail.appendTo(\"body\");\n\n    /*\n     * Register events on the selection area for handling new comment\n     * creation.\n     */\n    $([image[0], selectionArea[0]])\n        .mousedown(function(evt) {\n            if (evt.which == 1 && !activeCommentBlock &&\n                !$(evt.target).hasClass(\"selection-flag\")) {\n                var offset = selectionArea.offset();\n                activeSelection.beginX =\n                    evt.pageX - Math.floor(offset.left) - 1;\n                activeSelection.beginY =\n                    evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .move(activeSelection.beginX, activeSelection.beginY)\n                    .width(1)\n                    .height(1)\n                    .show();\n\n                if (activeSelection.is(\":hidden\")) {\n                    commentDetail.hide();\n                }\n\n                return false;\n            }\n        })\n        .mouseup(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                evt.stopPropagation();\n\n                var width  = activeSelection.width();\n                var height = activeSelection.height();\n                var offset = activeSelection.position();\n\n                activeSelection.hide();\n\n                /*\n                 * If we don't pass an arbitrary minimum size threshold,\n                 * don't do anything.  This helps avoid making people mad\n                 * if they accidentally click on the image.\n                 */\n                if (width > 5 && height > 5) {\n                    if (!activeCommentBlock) {\n                        showCommentDlg(addCommentBlock(offset.left,\n                                                       offset.top,\n                                                       width, height));\n                    } else {\n                        // TODO: Reposition the old block. */\n                    }\n                }\n            }\n        })\n        .mousemove(function(evt) {\n            if (!activeCommentBlock && activeSelection.is(\":visible\")) {\n                var offset = selectionArea.offset();\n                var x = evt.pageX - Math.floor(offset.left) - 1;\n                var y = evt.pageY - Math.floor(offset.top) - 1;\n\n                activeSelection\n                    .css(activeSelection.beginX <= x\n                         ? {\n                               left:  activeSelection.beginX,\n                               width: x - activeSelection.beginX\n                           }\n                         : {\n                               left:  x,\n                               width: activeSelection.beginX - x\n                           })\n                    .css(activeSelection.beginY <= y\n                         ? {\n                               top:    activeSelection.beginY,\n                               height: y - activeSelection.beginY\n                           }\n                         : {\n                               top:    y,\n                               height: activeSelection.beginY - y\n                           });\n\n                return false;\n            }\n        })\n        .proxyTouchEvents();\n\n    /*\n     * Register a hover event to hide the comments when the mouse is not\n     * over the comment area.\n     */\n    this.hover(\n        function() {\n            selectionArea.show();\n        },\n        function() {\n            if (activeSelection.is(\":hidden\") &&\n                commentDetail.is(\":hidden\")) {\n                selectionArea.hide();\n            }\n        }\n    );\n\n    /*\n     * Register a resize event to reposition the selection area on page\n     * resize, so that comments are in the right locations.\n     */\n    $(window)\n        .resize(function() {\n            var offset = image.position();\n\n            /*\n             * The margin: 0 auto means that position.left() will return\n             * the left-most part of the entire block, rather than the actual\n             * position of the image on Chrome. Every other browser returns 0\n             * for this margin, as we'd expect. So, just play it safe and\n             * offset by the margin-left. (Bug #1050)\n             */\n            offset.left += image.getExtents(\"m\", \"l\");\n\n            if ($.browser.msie && $.browser.version == 6) {\n                offset.left -= self.getExtents(\"mp\", \"l\");\n            }\n\n            selectionArea\n                .width(image.width())\n                .height(image.height())\n                .css(\"left\", offset.left);\n        })\n        .triggerHandler(\"resize\");\n\n    /* Add all existing comment regions to the page. */\n    for (region in regions) {\n        var comments = regions[region];\n        addCommentBlock(comments[0].x, comments[0].y,\n                        comments[0].w, comments[0].h,\n                        comments);\n    }\n\n    /*\n     * Adds a new comment block to the selection area. This may contain\n     * existing comments or may be a newly created comment block.\n     *\n     * @param {int}   x         The X area of the block.\n     * @param {int}   y         The Y area of the block.\n     * @param {int}   width     The block's width.\n     * @param {int}   height    The block's height.\n     * @param {array} comments  The list of comments in this block.\n     *\n     * @return {CommentBlock} The new comment block.\n     */\n    function addCommentBlock(x, y, width, height, comments) {\n        var commentBlock = new CommentBlock(x, y, width, height,\n                                            selectionArea, comments)\n        commentBlock.el.click(function() {\n            showCommentDlg(commentBlock);\n        });\n\n        return commentBlock;\n    }\n\n    /*\n     * Shows the comment details dialog for a comment block.\n     *\n     * @param {CommentBlock} commentBlock  The comment block to show.\n     */\n    function showCommentDlg(commentBlock) {\n        commentDetail\n            .one(\"close\", function() {\n                commentBlock._createDraftComment();\n                activeCommentBlock = commentBlock;\n\n                commentDetail\n                    .setDraftComment(commentBlock.draftComment)\n                    .setCommentsList(commentBlock.comments,\n                                     \"screenshot_comment\")\n                    .positionToSide(commentBlock.flag, {\n                        side: 'b',\n                        fitOnScreen: true\n                    });\n                commentDetail.open();\n            })\n            .close()\n    }\n\n    return this;\n}\n\n// vim: set et ts=4:\n", "patch": "@@ -36,6 +36,9 @@ function CommentBlock(x, y, width, height, container, comments) {\n         for (var i in comments) {\n             var comment = comments[i];\n \n+            // We load in encoded text, so decode it.\n+            comment.text = $(\"<div/>\").html(comment.text).text();\n+\n             if (comment.localdraft) {\n                 this._createDraftComment(comment.text);\n             } else {", "file_path": "files/2011_11/4", "file_language": "js", "file_name": "reviewboard/htdocs/media/rb/js/screenshots.js", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/reviewboard/reviewboard/raw/7a0a9d94555502278534dedcf2d75e9fccce8c3d/reviewboard%2Freviews%2Ftemplatetags%2Freviewtags.py", "code": "from django import template\nfrom django.conf import settings\nfrom django.db.models import Q\nfrom django.template import NodeList, TemplateSyntaxError\nfrom django.template.loader import render_to_string\nfrom django.utils import simplejson\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext_lazy as _\nfrom djblets.util.decorators import basictag, blocktag\nfrom djblets.util.misc import get_object_or_none\nfrom djblets.util.templatetags.djblets_utils import humanize_list\n\nfrom reviewboard.accounts.models import Profile\nfrom reviewboard.diffviewer.models import DiffSet\nfrom reviewboard.reviews.models import Comment, Group, ReviewRequest, \\\n                                       ScreenshotComment\n\n\nregister = template.Library()\n\n\n@register.tag\n@blocktag\ndef forcomment(context, nodelist, filediff, review=None):\n    \"\"\"\n    Loops over a list of comments beloning to a filediff.\n\n    This will populate a special ``comment`` variable for use in the content.\n    This is of the type :model:`reviews.Comment`.\n    \"\"\"\n    new_nodelist = NodeList()\n    context.push()\n\n    if not review:\n        comments = filediff.comments.all()\n    else:\n        comments = filediff.comments.filter(review=review)\n\n    for comment in comments:\n        context['comment'] = comment\n\n        for node in nodelist:\n            new_nodelist.append(node.render(context))\n\n    context.pop()\n    return new_nodelist.render(context)\n\n\n@register.tag\n@blocktag\ndef ifneatnumber(context, nodelist, rid):\n    \"\"\"\n    Returns whether or not the specified number is a \"neat\" number.\n    This is a number with a special property, such as being a\n    palindrome or having trailing zeroes.\n\n    If the number is a neat number, the contained content is rendered,\n    and two variables, ``milestone`` and ``palindrome`` are defined.\n    \"\"\"\n    if rid == None or rid < 1000:\n        return \"\"\n\n    ridstr = str(rid)\n    interesting = False\n\n    context.push()\n    context['milestone'] = False\n    context['palindrome'] = False\n\n    if rid >= 1000:\n        trailing = ridstr[1:]\n        if trailing == \"0\" * len(trailing):\n            context['milestone'] = True\n            interesting = True\n\n    if not interesting:\n        if ridstr == ''.join(reversed(ridstr)):\n            context['palindrome'] = True\n            interesting = True\n\n    if not interesting:\n        context.pop()\n        return \"\"\n\n    s = nodelist.render(context)\n    context.pop()\n    return s\n\n\n@register.tag\n@basictag(takes_context=True)\ndef commentcounts(context, filediff, interfilediff=None):\n    \"\"\"\n    Returns a JSON array of current comments for a filediff, sorted by\n    line number.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      comment_id  The ID of the comment\n      text        The text of the comment\n      line        The first line number\n      num_lines   The number of lines this comment spans\n      user        A dictionary containing \"username\" and \"name\" keys\n                  for the user\n      url         The URL to the comment\n      localdraft  True if this is the current user's draft comment\n      =========== ==================================================\n    \"\"\"\n    comment_dict = {}\n    user = context.get('user', None)\n\n    if interfilediff:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff=interfilediff)\n    else:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff__isnull=True)\n\n    for comment in query:\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            key = (comment.first_line, comment.num_lines)\n\n            comment_dict.setdefault(key, []).append({\n                'comment_id': comment.id,\n                'text': escape(comment.text),\n                'line': comment.first_line,\n                'num_lines': comment.num_lines,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                #'timestamp': comment.timestamp,\n                'url': comment.get_review_url(),\n                'localdraft': review.user == user and \\\n                              not review.public,\n            })\n\n    comments_array = []\n\n    for key, value in comment_dict.iteritems():\n        comments_array.append({\n            'linenum': key[0],\n            'num_lines': key[1],\n            'comments': value,\n        })\n\n    comments_array.sort(cmp=lambda x, y: cmp(x['linenum'], y['linenum'] or\n                                         cmp(x['num_lines'], y['num_lines'])))\n\n    return simplejson.dumps(comments_array)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef screenshotcommentcounts(context, screenshot):\n    \"\"\"\n    Returns a JSON array of current comments for a screenshot.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      text        The text of the comment\n      localdraft  True if this is the current user's draft comment\n      x           The X location of the comment's region\n      y           The Y location of the comment's region\n      w           The width of the comment's region\n      h           The height of the comment's region\n      =========== ==================================================\n    \"\"\"\n    comments = {}\n    user = context.get('user', None)\n\n    for comment in screenshot.comments.all():\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            position = '%dx%d+%d+%d' % (comment.w, comment.h, \\\n                                        comment.x, comment.y)\n\n            comments.setdefault(position, []).append({\n                'id': comment.id,\n                'text': escape(comment.text),\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                'url': comment.get_review_url(),\n                'localdraft' : review.user == user and \\\n                               not review.public,\n                'x' : comment.x,\n                'y' : comment.y,\n                'w' : comment.w,\n                'h' : comment.h,\n            })\n\n    return simplejson.dumps(comments)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef reply_list(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a list of comments of a specified type.\n\n    This is a complex, confusing function accepts lots of inputs in order\n    to display replies to a type of object. In each case, the replies will\n    be rendered using the template :template:`reviews/review_reply.html`.\n\n    If ``context_type`` is ``\"comment\"`` or ``\"screenshot_comment\"``,\n    the generated list of replies are to ``comment``.\n\n    If ``context_type`` is ``\"body_top\"`` or ```\"body_bottom\"``,\n    the generated list of replies are to ``review``. Depending on the\n    ``context_type``, these will either be replies to the top of the\n    review body or to the bottom.\n\n    The ``context_id`` parameter has to do with the internal IDs used by\n    the JavaScript code for storing and categorizing the comments.\n    \"\"\"\n    def generate_reply_html(reply, timestamp, text):\n        return render_to_string('reviews/review_reply.html', {\n            'context_id': context_id,\n            'id': reply.id,\n            'review': review,\n            'timestamp': timestamp,\n            'text': text,\n            'reply_user': reply.user,\n            'draft': not reply.public\n        })\n\n    def process_body_replies(queryset, attrname, user):\n        if user.is_anonymous():\n            queryset = queryset.filter(public=True)\n        else:\n            queryset = queryset.filter(Q(public=True) | Q(user=user))\n\n        s = \"\"\n        for reply_comment in queryset:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, attrname))\n\n        return s\n\n    user = context.get('user', None)\n    if user.is_anonymous():\n        user = None\n\n    s = \"\"\n\n    if context_type == \"comment\" or context_type == \"screenshot_comment\":\n        for reply_comment in comment.public_replies(user):\n            s += generate_reply_html(reply_comment.review.get(),\n                                     reply_comment.timestamp,\n                                     reply_comment.text)\n    elif context_type == \"body_top\" or context_type == \"body_bottom\":\n        q = Q(public=True)\n\n        if user:\n            q = q | Q(user=user)\n\n        replies = getattr(review, \"%s_replies\" % context_type).filter(q)\n\n        for reply in replies:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, context_type))\n\n        return s\n    else:\n        raise TemplateSyntaxError, \"Invalid context type passed\"\n\n    return s\n\n\n@register.inclusion_tag('reviews/review_reply_section.html',\n                        takes_context=True)\ndef reply_section(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a template for displaying a reply.\n\n    This takes the same parameters as :tag:`reply_list`. The template\n    rendered by this function, :template:`reviews/review_reply_section.html`,\n    is responsible for invoking :tag:`reply_list` and as such passes these\n    variables through. It does not make use of them itself.\n    \"\"\"\n    if comment != \"\":\n        if type(comment) is ScreenshotComment:\n            context_id += 's'\n        context_id += str(comment.id)\n\n    return {\n        'review': review,\n        'comment': comment,\n        'context_type': context_type,\n        'context_id': context_id,\n        'user': context.get('user', None)\n    }\n\n\n@register.inclusion_tag('reviews/dashboard_entry.html', takes_context=True)\ndef dashboard_entry(context, level, text, view, group=None):\n    \"\"\"\n    Renders an entry in the dashboard sidebar.\n\n    This includes the name of the entry and the list of review requests\n    associated with it. The entry is rendered by the template\n    :template:`reviews/dashboard_entry.html`.\n    \"\"\"\n    user = context.get('user', None)\n    datagrid = context.get('datagrid', None)\n    starred = False\n    show_count = True\n    count = 0\n\n    if view == 'to-group':\n        count = datagrid.counts['groups'].get(group.name, 0)\n    elif view == 'watched-groups':\n        starred = True\n        show_count = False\n    elif view in datagrid.counts:\n        count = datagrid.counts[view]\n\n        if view == 'starred':\n            starred = True\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"Invalid view type '%s' passed to 'dashboard_entry' tag.\" % view\n\n    return {\n        'MEDIA_URL': settings.MEDIA_URL,\n        'MEDIA_SERIAL': settings.MEDIA_SERIAL,\n        'level': level,\n        'text': text,\n        'view': view,\n        'group': group,\n        'count': count,\n        'show_count': show_count,\n        'user': user,\n        'starred': starred,\n        'selected': context.get('view', None) == view and \\\n                    (not group or context.get('group', None) == group.name),\n    }\n\n\n@register.simple_tag\ndef reviewer_list(review_request):\n    \"\"\"\n    Returns a humanized list of target reviewers in a review request.\n    \"\"\"\n    return humanize_list([group.display_name or group.name \\\n                          for group in review_request.target_groups.all()] + \\\n                         [user.get_full_name() or user.username \\\n                          for user  in review_request.target_people.all()])\n\n\n@register.filter\ndef bug_url(bug_id, review_request):\n    \"\"\"\n    Returns the URL based on a bug number on the specified review request.\n\n    If the repository the review request belongs to doesn't have an\n    associated bug tracker, this returns None.\n    \"\"\"\n    if (review_request.repository and\n        review_request.repository.bug_tracker and\n        '%s' in review_request.repository.bug_tracker):\n        try:\n            return review_request.repository.bug_tracker % bug_id\n        except TypeError:\n            logging.error(\"Error creating bug URL. The bug tracker URL '%s' \"\n                          \"is likely invalid.\" %\n                          review_request.repository.bug_tracker)\n\n    return None\n\n\n@register.filter\ndef diffsets_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of diffsets in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=True)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        yield {\n            'diffset': diffset,\n            'is_current': current_pair[0] == diffset and\n                          current_pair[1] == None,\n        }\n\n\n@register.filter\ndef interdiffs_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of interdiffs in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=False)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        interdiffs = DiffSet.objects.filter(\n            files__interdiff_comments__filediff__diffset=diffset).distinct()\n\n        for interdiff in interdiffs:\n            yield {\n                'diffset': diffset,\n                'interdiff': interdiff,\n                'is_current': current_pair[0] == diffset and\n                              current_pair[1] == interdiff,\n            }\n\n\n@register.filter\ndef has_comments_in_diffsets_excluding(review, diffset_pair):\n    \"\"\"\n    Returns whether or not the specified review has any comments that\n    aren't in the specified diffset or interdiff.\n    \"\"\"\n    if not review:\n        return False\n\n    current_diffset, interdiff = diffset_pair\n\n    # See if there are any diffsets with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=True).distinct()\n\n    if not interdiff:\n        # The user is browsing a standard diffset, so filter it out.\n        q = q.exclude(pk=current_diffset.id)\n\n    if q.count() > 0:\n        return True\n\n    # See if there are any interdiffs with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=False)\n\n    if interdiff:\n        # The user is browsing an interdiff, so filter it out.\n        q = q.exclude(pk=current_diffset.id,\n                      files__comments__interfilediff__diffset=interdiff)\n\n    return q.count() > 0\n\n\n@register.tag\n@basictag(takes_context=True)\ndef star(context, obj):\n    \"\"\"\n    Renders the code for displaying a star used for starring items.\n\n    The rendered code should handle click events so that the user can\n    toggle the star. The star is rendered by the template\n    :template:`reviews/star.html`.\n\n    The passed object must be either a :model:`reviews.ReviewRequest` or\n    a :model:`reviews.Group`.\n    \"\"\"\n    return render_star(context.get('user', None), obj)\n\n\ndef render_star(user, obj):\n    \"\"\"\n    Does the actual work of rendering the star. The star tag is a wrapper\n    around this.\n    \"\"\"\n    if user.is_anonymous():\n        return \"\"\n\n    profile = None\n\n    if not hasattr(obj, 'starred'):\n        try:\n            profile = user.get_profile()\n        except Profile.DoesNotExist:\n            return \"\"\n\n    if isinstance(obj, ReviewRequest):\n        obj_info = {\n            'type': 'reviewrequests',\n            'id': obj.id\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_review_requests.filter(pk=obj.id).count() > 0\n    elif isinstance(obj, Group):\n        obj_info = {\n            'type': 'groups',\n            'id': obj.name\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_groups.filter(pk=obj.id).count() > 0\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"star tag received an incompatible object type (%s)\" % \\\n            type(obj)\n\n    if starred:\n        image_alt = _(\"Starred\")\n    else:\n        image_alt = _(\"Click to star\")\n\n    return render_to_string('reviews/star.html', {\n        'object': obj_info,\n        'starred': int(starred),\n        'alt': image_alt,\n        'user': user,\n        'MEDIA_URL': settings.MEDIA_URL,\n    })\n", "code_before": "from django import template\nfrom django.conf import settings\nfrom django.db.models import Q\nfrom django.template import NodeList, TemplateSyntaxError\nfrom django.template.loader import render_to_string\nfrom django.utils import simplejson\nfrom django.utils.translation import ugettext_lazy as _\nfrom djblets.util.decorators import basictag, blocktag\nfrom djblets.util.misc import get_object_or_none\nfrom djblets.util.templatetags.djblets_utils import humanize_list\n\nfrom reviewboard.accounts.models import Profile\nfrom reviewboard.diffviewer.models import DiffSet\nfrom reviewboard.reviews.models import Comment, Group, ReviewRequest, \\\n                                       ScreenshotComment\n\n\nregister = template.Library()\n\n\n@register.tag\n@blocktag\ndef forcomment(context, nodelist, filediff, review=None):\n    \"\"\"\n    Loops over a list of comments beloning to a filediff.\n\n    This will populate a special ``comment`` variable for use in the content.\n    This is of the type :model:`reviews.Comment`.\n    \"\"\"\n    new_nodelist = NodeList()\n    context.push()\n\n    if not review:\n        comments = filediff.comments.all()\n    else:\n        comments = filediff.comments.filter(review=review)\n\n    for comment in comments:\n        context['comment'] = comment\n\n        for node in nodelist:\n            new_nodelist.append(node.render(context))\n\n    context.pop()\n    return new_nodelist.render(context)\n\n\n@register.tag\n@blocktag\ndef ifneatnumber(context, nodelist, rid):\n    \"\"\"\n    Returns whether or not the specified number is a \"neat\" number.\n    This is a number with a special property, such as being a\n    palindrome or having trailing zeroes.\n\n    If the number is a neat number, the contained content is rendered,\n    and two variables, ``milestone`` and ``palindrome`` are defined.\n    \"\"\"\n    if rid == None or rid < 1000:\n        return \"\"\n\n    ridstr = str(rid)\n    interesting = False\n\n    context.push()\n    context['milestone'] = False\n    context['palindrome'] = False\n\n    if rid >= 1000:\n        trailing = ridstr[1:]\n        if trailing == \"0\" * len(trailing):\n            context['milestone'] = True\n            interesting = True\n\n    if not interesting:\n        if ridstr == ''.join(reversed(ridstr)):\n            context['palindrome'] = True\n            interesting = True\n\n    if not interesting:\n        context.pop()\n        return \"\"\n\n    s = nodelist.render(context)\n    context.pop()\n    return s\n\n\n@register.tag\n@basictag(takes_context=True)\ndef commentcounts(context, filediff, interfilediff=None):\n    \"\"\"\n    Returns a JSON array of current comments for a filediff, sorted by\n    line number.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      comment_id  The ID of the comment\n      text        The text of the comment\n      line        The first line number\n      num_lines   The number of lines this comment spans\n      user        A dictionary containing \"username\" and \"name\" keys\n                  for the user\n      url         The URL to the comment\n      localdraft  True if this is the current user's draft comment\n      =========== ==================================================\n    \"\"\"\n    comment_dict = {}\n    user = context.get('user', None)\n\n    if interfilediff:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff=interfilediff)\n    else:\n        query = Comment.objects.filter(filediff=filediff,\n                                       interfilediff__isnull=True)\n\n    for comment in query:\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            key = (comment.first_line, comment.num_lines)\n\n            comment_dict.setdefault(key, []).append({\n                'comment_id': comment.id,\n                'text': comment.text,\n                'line': comment.first_line,\n                'num_lines': comment.num_lines,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                #'timestamp': comment.timestamp,\n                'url': comment.get_review_url(),\n                'localdraft': review.user == user and \\\n                              not review.public,\n            })\n\n    comments_array = []\n\n    for key, value in comment_dict.iteritems():\n        comments_array.append({\n            'linenum': key[0],\n            'num_lines': key[1],\n            'comments': value,\n        })\n\n    comments_array.sort(cmp=lambda x, y: cmp(x['linenum'], y['linenum'] or\n                                         cmp(x['num_lines'], y['num_lines'])))\n\n    return simplejson.dumps(comments_array)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef screenshotcommentcounts(context, screenshot):\n    \"\"\"\n    Returns a JSON array of current comments for a screenshot.\n\n    Each entry in the array has a dictionary containing the following keys:\n\n      =========== ==================================================\n      Key         Description\n      =========== ==================================================\n      text        The text of the comment\n      localdraft  True if this is the current user's draft comment\n      x           The X location of the comment's region\n      y           The Y location of the comment's region\n      w           The width of the comment's region\n      h           The height of the comment's region\n      =========== ==================================================\n    \"\"\"\n    comments = {}\n    user = context.get('user', None)\n\n    for comment in screenshot.comments.all():\n        review = get_object_or_none(comment.review)\n\n        if review and (review.public or review.user == user):\n            position = '%dx%d+%d+%d' % (comment.w, comment.h, \\\n                                        comment.x, comment.y)\n\n            comments.setdefault(position, []).append({\n                'id': comment.id,\n                'text': comment.text,\n                'user': {\n                    'username': review.user.username,\n                    'name': review.user.get_full_name() or review.user.username,\n                },\n                'url': comment.get_review_url(),\n                'localdraft' : review.user == user and \\\n                               not review.public,\n                'x' : comment.x,\n                'y' : comment.y,\n                'w' : comment.w,\n                'h' : comment.h,\n            })\n\n    return simplejson.dumps(comments)\n\n\n@register.tag\n@basictag(takes_context=True)\ndef reply_list(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a list of comments of a specified type.\n\n    This is a complex, confusing function accepts lots of inputs in order\n    to display replies to a type of object. In each case, the replies will\n    be rendered using the template :template:`reviews/review_reply.html`.\n\n    If ``context_type`` is ``\"comment\"`` or ``\"screenshot_comment\"``,\n    the generated list of replies are to ``comment``.\n\n    If ``context_type`` is ``\"body_top\"`` or ```\"body_bottom\"``,\n    the generated list of replies are to ``review``. Depending on the\n    ``context_type``, these will either be replies to the top of the\n    review body or to the bottom.\n\n    The ``context_id`` parameter has to do with the internal IDs used by\n    the JavaScript code for storing and categorizing the comments.\n    \"\"\"\n    def generate_reply_html(reply, timestamp, text):\n        return render_to_string('reviews/review_reply.html', {\n            'context_id': context_id,\n            'id': reply.id,\n            'review': review,\n            'timestamp': timestamp,\n            'text': text,\n            'reply_user': reply.user,\n            'draft': not reply.public\n        })\n\n    def process_body_replies(queryset, attrname, user):\n        if user.is_anonymous():\n            queryset = queryset.filter(public=True)\n        else:\n            queryset = queryset.filter(Q(public=True) | Q(user=user))\n\n        s = \"\"\n        for reply_comment in queryset:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, attrname))\n\n        return s\n\n    user = context.get('user', None)\n    if user.is_anonymous():\n        user = None\n\n    s = \"\"\n\n    if context_type == \"comment\" or context_type == \"screenshot_comment\":\n        for reply_comment in comment.public_replies(user):\n            s += generate_reply_html(reply_comment.review.get(),\n                                     reply_comment.timestamp,\n                                     reply_comment.text)\n    elif context_type == \"body_top\" or context_type == \"body_bottom\":\n        q = Q(public=True)\n\n        if user:\n            q = q | Q(user=user)\n\n        replies = getattr(review, \"%s_replies\" % context_type).filter(q)\n\n        for reply in replies:\n            s += generate_reply_html(reply, reply.timestamp,\n                                     getattr(reply, context_type))\n\n        return s\n    else:\n        raise TemplateSyntaxError, \"Invalid context type passed\"\n\n    return s\n\n\n@register.inclusion_tag('reviews/review_reply_section.html',\n                        takes_context=True)\ndef reply_section(context, review, comment, context_type, context_id):\n    \"\"\"\n    Renders a template for displaying a reply.\n\n    This takes the same parameters as :tag:`reply_list`. The template\n    rendered by this function, :template:`reviews/review_reply_section.html`,\n    is responsible for invoking :tag:`reply_list` and as such passes these\n    variables through. It does not make use of them itself.\n    \"\"\"\n    if comment != \"\":\n        if type(comment) is ScreenshotComment:\n            context_id += 's'\n        context_id += str(comment.id)\n\n    return {\n        'review': review,\n        'comment': comment,\n        'context_type': context_type,\n        'context_id': context_id,\n        'user': context.get('user', None)\n    }\n\n\n@register.inclusion_tag('reviews/dashboard_entry.html', takes_context=True)\ndef dashboard_entry(context, level, text, view, group=None):\n    \"\"\"\n    Renders an entry in the dashboard sidebar.\n\n    This includes the name of the entry and the list of review requests\n    associated with it. The entry is rendered by the template\n    :template:`reviews/dashboard_entry.html`.\n    \"\"\"\n    user = context.get('user', None)\n    datagrid = context.get('datagrid', None)\n    starred = False\n    show_count = True\n    count = 0\n\n    if view == 'to-group':\n        count = datagrid.counts['groups'].get(group.name, 0)\n    elif view == 'watched-groups':\n        starred = True\n        show_count = False\n    elif view in datagrid.counts:\n        count = datagrid.counts[view]\n\n        if view == 'starred':\n            starred = True\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"Invalid view type '%s' passed to 'dashboard_entry' tag.\" % view\n\n    return {\n        'MEDIA_URL': settings.MEDIA_URL,\n        'MEDIA_SERIAL': settings.MEDIA_SERIAL,\n        'level': level,\n        'text': text,\n        'view': view,\n        'group': group,\n        'count': count,\n        'show_count': show_count,\n        'user': user,\n        'starred': starred,\n        'selected': context.get('view', None) == view and \\\n                    (not group or context.get('group', None) == group.name),\n    }\n\n\n@register.simple_tag\ndef reviewer_list(review_request):\n    \"\"\"\n    Returns a humanized list of target reviewers in a review request.\n    \"\"\"\n    return humanize_list([group.display_name or group.name \\\n                          for group in review_request.target_groups.all()] + \\\n                         [user.get_full_name() or user.username \\\n                          for user  in review_request.target_people.all()])\n\n\n@register.filter\ndef bug_url(bug_id, review_request):\n    \"\"\"\n    Returns the URL based on a bug number on the specified review request.\n\n    If the repository the review request belongs to doesn't have an\n    associated bug tracker, this returns None.\n    \"\"\"\n    if (review_request.repository and\n        review_request.repository.bug_tracker and\n        '%s' in review_request.repository.bug_tracker):\n        try:\n            return review_request.repository.bug_tracker % bug_id\n        except TypeError:\n            logging.error(\"Error creating bug URL. The bug tracker URL '%s' \"\n                          \"is likely invalid.\" %\n                          review_request.repository.bug_tracker)\n\n    return None\n\n\n@register.filter\ndef diffsets_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of diffsets in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=True)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        yield {\n            'diffset': diffset,\n            'is_current': current_pair[0] == diffset and\n                          current_pair[1] == None,\n        }\n\n\n@register.filter\ndef interdiffs_with_comments(review, current_pair):\n    \"\"\"\n    Returns a list of interdiffs in the review that contain draft comments.\n    \"\"\"\n    if not review:\n        return\n\n    diffsets = DiffSet.objects.filter(files__comments__review=review)\n    diffsets = diffsets.filter(files__comments__interfilediff__isnull=False)\n    diffsets = diffsets.distinct()\n\n    for diffset in diffsets:\n        interdiffs = DiffSet.objects.filter(\n            files__interdiff_comments__filediff__diffset=diffset).distinct()\n\n        for interdiff in interdiffs:\n            yield {\n                'diffset': diffset,\n                'interdiff': interdiff,\n                'is_current': current_pair[0] == diffset and\n                              current_pair[1] == interdiff,\n            }\n\n\n@register.filter\ndef has_comments_in_diffsets_excluding(review, diffset_pair):\n    \"\"\"\n    Returns whether or not the specified review has any comments that\n    aren't in the specified diffset or interdiff.\n    \"\"\"\n    if not review:\n        return False\n\n    current_diffset, interdiff = diffset_pair\n\n    # See if there are any diffsets with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=True).distinct()\n\n    if not interdiff:\n        # The user is browsing a standard diffset, so filter it out.\n        q = q.exclude(pk=current_diffset.id)\n\n    if q.count() > 0:\n        return True\n\n    # See if there are any interdiffs with comments on them in this review.\n    q = DiffSet.objects.filter(files__comments__review=review)\n    q = q.filter(files__comments__interfilediff__isnull=False)\n\n    if interdiff:\n        # The user is browsing an interdiff, so filter it out.\n        q = q.exclude(pk=current_diffset.id,\n                      files__comments__interfilediff__diffset=interdiff)\n\n    return q.count() > 0\n\n\n@register.tag\n@basictag(takes_context=True)\ndef star(context, obj):\n    \"\"\"\n    Renders the code for displaying a star used for starring items.\n\n    The rendered code should handle click events so that the user can\n    toggle the star. The star is rendered by the template\n    :template:`reviews/star.html`.\n\n    The passed object must be either a :model:`reviews.ReviewRequest` or\n    a :model:`reviews.Group`.\n    \"\"\"\n    return render_star(context.get('user', None), obj)\n\n\ndef render_star(user, obj):\n    \"\"\"\n    Does the actual work of rendering the star. The star tag is a wrapper\n    around this.\n    \"\"\"\n    if user.is_anonymous():\n        return \"\"\n\n    profile = None\n\n    if not hasattr(obj, 'starred'):\n        try:\n            profile = user.get_profile()\n        except Profile.DoesNotExist:\n            return \"\"\n\n    if isinstance(obj, ReviewRequest):\n        obj_info = {\n            'type': 'reviewrequests',\n            'id': obj.id\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_review_requests.filter(pk=obj.id).count() > 0\n    elif isinstance(obj, Group):\n        obj_info = {\n            'type': 'groups',\n            'id': obj.name\n        }\n\n        if hasattr(obj, 'starred'):\n            starred = obj.starred\n        else:\n            starred = \\\n                profile.starred_groups.filter(pk=obj.id).count() > 0\n    else:\n        raise template.TemplateSyntaxError, \\\n            \"star tag received an incompatible object type (%s)\" % \\\n            type(obj)\n\n    if starred:\n        image_alt = _(\"Starred\")\n    else:\n        image_alt = _(\"Click to star\")\n\n    return render_to_string('reviews/star.html', {\n        'object': obj_info,\n        'starred': int(starred),\n        'alt': image_alt,\n        'user': user,\n        'MEDIA_URL': settings.MEDIA_URL,\n    })\n", "patch": "@@ -4,6 +4,7 @@\n from django.template import NodeList, TemplateSyntaxError\n from django.template.loader import render_to_string\n from django.utils import simplejson\n+from django.utils.html import escape\n from django.utils.translation import ugettext_lazy as _\n from djblets.util.decorators import basictag, blocktag\n from djblets.util.misc import get_object_or_none\n@@ -126,7 +127,7 @@ def commentcounts(context, filediff, interfilediff=None):\n \n             comment_dict.setdefault(key, []).append({\n                 'comment_id': comment.id,\n-                'text': comment.text,\n+                'text': escape(comment.text),\n                 'line': comment.first_line,\n                 'num_lines': comment.num_lines,\n                 'user': {\n@@ -185,7 +186,7 @@ def screenshotcommentcounts(context, screenshot):\n \n             comments.setdefault(position, []).append({\n                 'id': comment.id,\n-                'text': comment.text,\n+                'text': escape(comment.text),\n                 'user': {\n                     'username': review.user.username,\n                     'name': review.user.get_full_name() or review.user.username,", "file_path": "files/2011_11/5", "file_language": "py", "file_name": "reviewboard/reviews/templatetags/reviewtags.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
