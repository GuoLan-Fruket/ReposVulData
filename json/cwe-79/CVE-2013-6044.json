{"index": 424, "cve_id": "CVE-2013-6044", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "The is_safe_url function in utils/http.py in Django 1.4.x before 1.4.6, 1.5.x before 1.5.2, and 1.6 before beta 2 treats a URL's scheme as safe even if it is not HTTP or HTTPS, which might introduce cross-site scripting (XSS) or other vulnerabilities into Django applications that use this function, as demonstrated by \"the login view in django.contrib.auth.views\" and the javascript: scheme.", "cvss": "3.7", "publish_date": "October 4, 2013", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "1a274ccd6bc1afbdac80344c9b6e5810c1162b5f", "commit_message": "Fixed is_safe_url() to reject URLs that use a scheme other than HTTP/S.\n\nThis is a security fix; disclosure to follow shortly.", "commit_date": "2013-08-13T16:03:49Z", "project": "django/django", "url": "https://api.github.com/repos/django/django/commits/1a274ccd6bc1afbdac80344c9b6e5810c1162b5f", "html_url": "https://github.com/django/django/commit/1a274ccd6bc1afbdac80344c9b6e5810c1162b5f", "windows_before": [{"commit_id": "09a5f5aabe27f63ec8d8982efa6cef9bf7b86022", "commit_date": "Tue Aug 13 15:30:02 2013 +0300", "commit_message": "Fixed test failure on MySQL", "files_name": ["tests/queries/tests.py"]}, {"commit_id": "737b53ab9a01f9e3cc59265cb017a8792f80adf5", "commit_date": "Tue Aug 13 05:11:39 2013 -0700", "commit_message": "Merge pull request #1470 from loic/admin.actionlist", "files_name": ["163a34ce4bc1086b346a52c7271f48d2c207f710 - Mon Aug 12 18:30:38 2013 +0700 : Fixed #20883 -- Made model inheritance find parent links in abstract parents", "django/db/models/base.py", "docs/releases/1.7.txt", "tests/model_inheritance_regress/models.py", "tests/model_inheritance_regress/tests.py"]}, {"commit_id": "33fc083b0db392bd35bc9d5d9a141adb25537253", "commit_date": "Tue Aug 13 17:38:29 2013 +0700", "commit_message": "Fixed overflow for the \"Recent Actions\" widget on the admin index.", "files_name": ["django/contrib/admin/static/admin/css/dashboard.css"]}, {"commit_id": "dcdc579d162b750ee3449e34efd772703592faca", "commit_date": "Tue Aug 13 14:11:52 2013 +0300", "commit_message": "Fixed #20874 -- bump_prefix() in nested subqueries", "files_name": ["django/db/models/sql/compiler.py", "django/db/models/sql/query.py", "tests/foreign_object/tests.py", "tests/queries/tests.py"]}, {"commit_id": "6c12cd15e990b0ff5a5e85328f0a092f4bfe8080", "commit_date": "Sat Oct 20 07:50:44 2012 -0500", "commit_message": "Unlocalize line numbers and ids in debug 500 view.", "files_name": ["django/views/debug.py", "tests/view_tests/tests/test_debug.py", "tests/view_tests/urls.py", "tests/view_tests/views.py"]}, {"commit_id": "44f907dd980defaab2c06b4ead2255ec3566bcd5", "commit_date": "Mon Aug 12 20:05:20 2013 +0100", "commit_message": "Start of getting Oracle to do schema stuff", "files_name": ["django/db/backends/oracle/base.py", "django/db/backends/oracle/creation.py", "django/db/backends/oracle/schema.py"]}, {"commit_id": "3f6cc33cffa5774beedf7997354fc269497a93dd", "commit_date": "Mon Aug 12 13:20:58 2013 -0400", "commit_message": "Added missing release notes for older versions of Django", "files_name": ["docs/releases/1.3.3.txt", "docs/releases/1.3.4.txt", "docs/releases/1.3.5.txt", "docs/releases/1.3.6.txt", "docs/releases/1.3.7.txt", "docs/releases/1.4.2.txt", "docs/releases/1.4.3.txt", "docs/releases/1.4.4.txt", "docs/releases/1.4.5.txt", "docs/releases/index.txt"]}, {"commit_id": "71b5617c24bb997db294480f07611233069e3359", "commit_date": "Mon Aug 12 12:41:39 2013 -0400", "commit_message": "Fixed #17778 -- Prevented class attributes on context from resolving as template variables.", "files_name": ["django/template/base.py", "tests/template_tests/test_context.py"]}, {"commit_id": "841b7af8120e854f3aa37b8918f461efcbbef3d6", "commit_date": "Mon Aug 12 16:40:41 2013 +0100", "commit_message": "Use DEFAULT_DB_ALIAS", "files_name": ["django/core/management/commands/makemigrations.py"]}, {"commit_id": "6bdb3b1135d1bd7b2dc24131b9d26ac19ebdba67", "commit_date": "Mon May 13 13:38:53 2013 +0200", "commit_message": "Fixed #13518 -- Added FILE_UPLOAD_DIRECTORY_PERMISSIONS setting", "files_name": ["django/conf/global_settings.py", "django/core/files/storage.py", "docs/ref/settings.txt", "docs/releases/1.7.txt", "docs/topics/http/file-uploads.txt", "tests/file_storage/tests.py"]}, {"commit_id": "b61b6346284fb32614aab965bd2cb09b383fc9f5", "commit_date": "Sun Aug 11 15:28:51 2013 +0100", "commit_message": "Fix weird planning issues when already fully migrated.", "files_name": ["django/db/migrations/executor.py", "tests/migrations/test_executor.py", "tests/migrations/test_migrations_2/0001_initial.py", "tests/migrations/test_migrations_2/__init__.py"]}, {"commit_id": "b4c493ecd3b8d0d55347949984561762ad2ef1dc", "commit_date": "Sun Aug 11 14:28:55 2013 +0100", "commit_message": "Remove keep_default from add_field", "files_name": ["django/db/backends/schema.py"]}, {"commit_id": "d985fd7a189cdbfa2093c1225bdeb7eefaeb6978", "commit_date": "Sun Aug 11 14:27:42 2013 +0100", "commit_message": "Fix tablespace command", "files_name": ["django/db/backends/schema.py"]}, {"commit_id": "ae19315b4d8a19eda07ea8f313c485ca0a7875d0", "commit_date": "Sun Aug 11 14:23:31 2013 +0100", "commit_message": "Support index_together during model creation", "files_name": ["django/db/backends/schema.py", "django/db/backends/sqlite3/introspection.py", "tests/schema/models.py", "tests/schema/tests.py"]}, {"commit_id": "21be9fef7b14edd75c6ee402ec2bb28bf9b6ce59", "commit_date": "Sun Aug 11 00:01:30 2013 +0100", "commit_message": "Stop being overcautious about Field.rel", "files_name": ["django/db/backends/schema.py", "django/db/migrations/autodetector.py"]}, {"commit_id": "77028194415cb03b1ff2a85a86d806a0366bccff", "commit_date": "Sat Aug 10 23:58:12 2013 +0100", "commit_message": "Update get_constraints with better comments", "files_name": ["django/db/backends/__init__.py", "django/db/backends/postgresql_psycopg2/introspection.py"]}, {"commit_id": "ab680725bfb2f0d79cff26331b30a3d583c55a80", "commit_date": "Sat Aug 10 18:08:05 2013 -0400", "commit_message": "Fixed #20890 -- Added missing import in class-based view docs.", "files_name": ["docs/topics/class-based-views/intro.txt"]}, {"commit_id": "6e70f47d02a9c5d32c0d3e88cdd6f0f93458e7ca", "commit_date": "Sat Aug 10 14:48:46 2013 -0700", "commit_message": "Merge pull request #1464 from evildmp/squashing_commits", "files_name": ["e868eaf680a3d7acfcd3c76743bb248d29ac7b60 - Sat Aug 10 22:24:24 2013 +0100 : clarified misleading wording about squashing commits", "docs/internals/contributing/writing-code/working-with-git.txt"]}, {"commit_id": "d5a7a3d6a80684caa8f5c3c7d5b454e3da1799a1", "commit_date": "Sat Aug 10 21:04:59 2013 +0100", "commit_message": "Add clarifying comment", "files_name": ["django/core/management/commands/makemigrations.py"]}, {"commit_id": "22af1394c64b6687e45747ae9f643068b340a867", "commit_date": "Sat Aug 10 16:32:07 2013 -0300", "commit_message": "Expand testing of Test LiveServerTestCase static files serving.", "files_name": ["tests/runtests.py", "tests/servers/another_app/__init__.py", "tests/servers/another_app/models.py", "tests/servers/another_app/static/another_app/another_app_static_file.txt", "tests/servers/tests.py"]}, {"commit_id": "3f1f91f155c89d0be9f920bb88a2c32f652fa79b", "commit_date": "Sat Aug 10 20:02:55 2013 +0100", "commit_message": "Print all bad apps passed to makemigrations, not just the first one.", "files_name": ["django/core/management/commands/makemigrations.py"]}, {"commit_id": "cb92e3391b0560bc3d519f066185522316b4533f", "commit_date": "Sat Aug 10 15:54:22 2013 -0300", "commit_message": "Test that django.views.static.serve() generates 404 status codes.", "files_name": ["tests/view_tests/tests/test_static.py"]}, {"commit_id": "7970d97a708f0d2f4fbd654eaf785338ab04cc1e", "commit_date": "Sat Aug 10 20:00:12 2013 +0100", "commit_message": "Docs tweaks (thanks timgraham)", "files_name": ["django/db/backends/mysql/introspection.py", "django/db/migrations/autodetector.py", "django/db/migrations/graph.py", "django/test/runner.py", "django/utils/datastructures.py", "docs/ref/django-admin.txt", "docs/ref/signals.txt", "docs/releases/1.7.txt", "docs/topics/migrations.txt"]}, {"commit_id": "3c3d308ea3e017868b6530df144dd1824471b6f2", "commit_date": "Sat Aug 10 19:48:46 2013 +0100", "commit_message": "Back SortedSet onto OrderedDict, rename it, and a few typo fixes", "files_name": ["django/utils/datastructures.py"]}, {"commit_id": "00d23a13ebaf6057d1428e798bfb6cf47bb5ef7c", "commit_date": "Wed Aug 7 21:33:31 2013 +0530", "commit_message": "Fixed #20828 -- Allowed @permission_required to take a list of permissions", "files_name": ["django/contrib/auth/decorators.py", "django/contrib/auth/tests/test_decorators.py", "docs/releases/1.7.txt", "docs/topics/auth/default.txt"]}, {"commit_id": "5737c57d95cc8c17b1aa2da4809f70ad4c212716", "commit_date": "Fri Aug 9 16:02:05 2013 -0400", "commit_message": "Fixed #20868 -- Added an email to django-announce as a security step.", "files_name": ["docs/internals/security.txt"]}, {"commit_id": "db0779dbe1da8cff96f8fc9e92ce269a5cf1c1c1", "commit_date": "Fri Aug 9 12:18:56 2013 -0700", "commit_message": "Merge pull request #1447 from evansd/patch-1", "files_name": ["f093646bfc2b459b4e37bae8fe3f2b52e4e58ff3 - Fri Aug 9 17:47:13 2013 +0100 : Remove pointless comment.", "django/db/backends/mysql/introspection.py"]}, {"commit_id": "9b4a789eefc4b0c081056f3cb97e07895b5ffc00", "commit_date": "Fri Aug 9 17:45:19 2013 +0100", "commit_message": "Add [y/n] to autodetector questions and allow for default value", "files_name": ["django/db/migrations/autodetector.py"]}, {"commit_id": "ae96ad872f0bd16c0997991c0a7109e0139f9373", "commit_date": "Fri Aug 9 17:42:56 2013 +0100", "commit_message": "Remove pointless fetch_results param", "files_name": ["django/db/backends/schema.py"]}, {"commit_id": "fb16ee5a31256c1e230a697044c3ded2dbdec3e8", "commit_date": "Fri Aug 9 17:41:39 2013 +0100", "commit_message": "Remove commented-out print", "files_name": ["django/db/backends/schema.py"]}, {"commit_id": "b3cec920a2a7d547944823c539a7ebd99b3af23a", "commit_date": "Fri Aug 9 17:39:07 2013 +0100", "commit_message": "Remove other color_style override", "files_name": ["django/core/management/commands/makemigrations.py"]}, {"commit_id": "9f736294205486443f047e93f8ca53b5b00ac1d3", "commit_date": "Fri Aug 9 17:36:16 2013 +0100", "commit_message": "utils.importlib is deprecated", "files_name": ["django/core/management/commands/flush.py", "django/core/management/commands/migrate.py", "django/db/migrations/loader.py", "django/db/migrations/writer.py"]}, {"commit_id": "679627660fef3c7a9f7be743a168930e4a0e58ae", "commit_date": "Fri Aug 9 17:34:35 2013 +0100", "commit_message": "Remove useless override of self.style", "files_name": ["django/core/management/commands/migrate.py"]}, {"commit_id": "0cac4fbf699bb6a3de5f4a48c6e047a4dc6c2df7", "commit_date": "Mon Feb 4 16:50:15 2013 +0100", "commit_message": "Fixed #18356 -- Gave the test client signals.template_rendered call a unique dispatch_uid", "files_name": ["AUTHORS", "django/test/client.py", "tests/test_client_regress/tests.py", "tests/test_client_regress/urls.py", "tests/test_client_regress/views.py"]}, {"commit_id": "453915bb1272c9a9189a741e6a9b9246edfcbd03", "commit_date": "Fri Aug 9 10:57:25 2013 -0400", "commit_message": "SQLite test fix -- refs #9057", "files_name": ["django/contrib/auth/tests/test_management.py"]}, {"commit_id": "588b523233e6cd3e7f9695b76ba639fe26fe5192", "commit_date": "Fri Aug 9 14:37:37 2013 +0100", "commit_message": "Merge remote-tracking branch 'core/master' into schema-alteration", "files_name": ["1d1cfd0bd8016358719a1e73117c811f02ca8c02 - Fri Aug 9 14:31:24 2013 +0100 : Document new field API in release notes", "docs/releases/1.7.txt"]}, {"commit_id": "ddae74b64ccb1173e3f2f06d54dd45643130f9e0", "commit_date": "Thu Aug 1 11:31:34 2013 -0400", "commit_message": "Fixed #9057 -- Added default_permissions model meta option.", "files_name": ["django/contrib/auth/management/__init__.py", "django/contrib/auth/tests/test_management.py", "django/db/models/options.py", "docs/ref/models/options.txt", "docs/releases/1.7.txt"]}, {"commit_id": "de64c4d6e97c980fb4c0ace045fc4070b3f763d9", "commit_date": "Fri Aug 9 14:17:30 2013 +0100", "commit_message": "Merge remote-tracking branch 'core/master' into schema-alteration", "files_name": ["9c711ee3a6a638add26d19dad70447c981371598 - Fri Aug 9 09:12:15 2013 -0400 : Fixed test failures on Python 3 - refs #12288", "django/conf/__init__.py", "tests/settings_tests/tests.py"]}, {"commit_id": "b575d690bbc1c4cd7f575346132c09fca8c736a7", "commit_date": "Fri Aug 9 08:34:37 2013 -0400", "commit_message": "Fixed test failures introduced by #12288", "files_name": ["tests/view_tests/tests/test_i18n.py"]}, {"commit_id": "2ac89012d8ff750ea5443b6f6f347dacb697e059", "commit_date": "Wed Aug 7 01:07:16 2013 -0700", "commit_message": "Fixed #12288 -- Added unique validation for INSTALLED_APPS", "files_name": ["django/conf/__init__.py", "tests/settings_tests/tests.py"]}, {"commit_id": "4fa2738ff3ff2704140c8bcb6671d76e9f31f776", "commit_date": "Fri Aug 9 04:06:23 2013 -0700", "commit_message": "Merge pull request #1460 from loic/ObjectMixins.get_queryset", "files_name": ["f8a6a4eba1b52dd634ab3e72637cd47412dcfa6e - Fri Aug 9 17:31:17 2013 +0700 : Improved queryset handling and docs for (Single|Multiple)ObjectMixin.", "django/views/generic/detail.py", "django/views/generic/list.py", "docs/ref/class-based-views/mixins-multiple-object.txt", "docs/ref/class-based-views/mixins-single-object.txt"]}, {"commit_id": "8442268869a691767788bcbb4df90ddb28abb8f2", "commit_date": "Thu Aug 8 14:13:39 2013 -0400", "commit_message": "Added an anchor for django.forms.Form.clean in docs", "files_name": ["docs/ref/forms/validation.txt"]}, {"commit_id": "58e4fe464cadeaab53b08511dceb5b0e2b82ebd1", "commit_date": "Thu Aug 8 07:27:08 2013 -0700", "commit_message": "Merge pull request #1457 from jaimeirurzun/master", "files_name": ["7e6af9d40ce0232deb9d4c6943beef0b62a20a08 - Thu Aug 8 13:16:48 2013 +0100 : Added more on @cached_property, refs #20870", "docs/ref/utils.txt"]}], "windows_after": [{"commit_id": "ae3535169af804352517b7fea94a42a1c9c4b762", "commit_date": "Tue Aug 13 11:06:22 2013 -0500", "commit_message": "Fixed is_safe_url() to reject URLs that use a scheme other than HTTP/S.", "files_name": ["django/contrib/auth/tests/test_views.py", "django/utils/http.py"]}, {"commit_id": "cbe6d5568f4f5053ed7228ca3c3d0cce77cf9560", "commit_date": "Tue Aug 13 11:06:41 2013 -0500", "commit_message": "Apply autoescaping to AdminURLFieldWidget.", "files_name": ["django/contrib/admin/widgets.py", "tests/admin_widgets/tests.py"]}, {"commit_id": "db682dcc9e028fa40bb4d3efb322fd3191ed1bd2", "commit_date": "Tue Aug 13 11:16:30 2013 -0500", "commit_message": "Added 1.4.6/1.5.2 release notes.", "files_name": ["docs/releases/1.4.6.txt", "docs/releases/1.5.2.txt", "docs/releases/index.txt"]}, {"commit_id": "907ef9d0d157c47c66bf265dca93a0bee8664ea3", "commit_date": "Tue Jun 4 22:41:49 2013 +0200", "commit_message": "Fixed #20555 -- Make subwidget id attribute available", "files_name": ["django/forms/forms.py", "django/forms/widgets.py", "docs/ref/forms/widgets.txt", "docs/releases/1.7.txt", "tests/forms_tests/tests/test_widgets.py"]}, {"commit_id": "157604a87fa7e1331c25fcbed558f0799aa5b8df", "commit_date": "Tue Aug 13 20:54:57 2013 +0100", "commit_message": "Oracle schema backend, passes most tests and is pretty complete.", "files_name": ["django/db/backends/oracle/base.py", "django/db/backends/oracle/introspection.py", "django/db/backends/oracle/schema.py", "django/db/backends/schema.py", "tests/schema/tests.py"]}, {"commit_id": "4e50e4065489f06d72eed8ce2d9ae98639be5a93", "commit_date": "Tue Aug 13 22:22:46 2013 +0200", "commit_message": "Removed unneeded conditional_escapes from the testsuite.", "files_name": ["tests/admin_widgets/tests.py"]}, {"commit_id": "4eeb8ec147022d3a7360d9fa78d3cd1c76accfb1", "commit_date": "Mon Aug 5 17:07:12 2013 +0200", "commit_message": "Fixed #20864 -- Made the test client use common method for performing requests.", "files_name": ["AUTHORS", "django/test/client.py"]}, {"commit_id": "71c491972eecae8783cf46e69fac7e5f9f83fc59", "commit_date": "Sat Aug 10 01:13:41 2013 -0700", "commit_message": "Fixed #11400 -- Passed kwargs from AbstractUser.email_user() to send_mail()", "files_name": ["AUTHORS", "django/contrib/auth/models.py", "django/contrib/auth/tests/test_models.py", "docs/ref/contrib/auth.txt", "docs/releases/1.7.txt"]}, {"commit_id": "ff410565bf1cf1a2905c1ef83db408d455211446", "commit_date": "Wed Aug 14 16:14:32 2013 +0200", "commit_message": "Fixed #20709 -- Allowed {% widthratio %} to accept an \"as\" parameter.", "files_name": ["AUTHORS", "django/template/defaulttags.py", "docs/ref/templates/builtins.txt", "docs/releases/1.7.txt", "tests/template_tests/tests.py"]}, {"commit_id": "b6178fa24be8a628cb002afe6a80db6391bb67d8", "commit_date": "Wed Aug 14 12:57:55 2013 -0400", "commit_message": "Added some doc links for django.contrib.messages", "files_name": ["docs/ref/contrib/messages.txt", "docs/ref/settings.txt"]}, {"commit_id": "354009d67eb56301457ec26c1c847af5fdfc083b", "commit_date": "Thu Aug 15 00:27:16 2013 +0100", "commit_message": "Updated docs following deprecation of django.views.defaults.shortcut", "files_name": ["docs/internals/deprecation.txt", "docs/ref/contrib/sites.txt"]}, {"commit_id": "29255fcb4f5f50334cda9546ada2f31e825deec3", "commit_date": "Thu Aug 15 07:14:10 2013 -0400", "commit_message": "Fixed some ReST errors regarding backticks", "files_name": ["docs/howto/custom-model-fields.txt", "docs/howto/deployment/index.txt", "docs/howto/deployment/wsgi/apache-auth.txt", "docs/howto/deployment/wsgi/modwsgi.txt", "docs/intro/tutorial01.txt", "docs/ref/contrib/admin/actions.txt", "docs/ref/contrib/admin/admindocs.txt", "docs/ref/models/querysets.txt", "docs/releases/1.7.txt", "docs/topics/auth/customizing.txt", "docs/topics/db/managers.txt", "docs/topics/http/shortcuts.txt"]}, {"commit_id": "bc5716fc9ce517c6aaa2b78f311724a335488924", "commit_date": "Tue Feb 26 13:12:27 2013 -0600", "commit_message": "Added release date to 1.5 release notes.", "files_name": ["docs/releases/1.5.txt"]}, {"commit_id": "b9ef96e73cf2f2613eb6ca96038ef8c4271ac116", "commit_date": "Thu Aug 15 20:59:58 2013 +0200", "commit_message": "Regression test and patch for ticket #20924.", "files_name": ["django/utils/functional.py", "tests/utils_tests/test_simplelazyobject.py"]}, {"commit_id": "55339a76691724109770092976e660ac62358bc5", "commit_date": "Thu Aug 15 15:24:58 2013 -0400", "commit_message": "Fixed #20891 -- Removed part of the tutorial that requires pytz", "files_name": ["docs/intro/tutorial02.txt"]}, {"commit_id": "22c6497f990fd12359b759a71abfcbf3f52b2d52", "commit_date": "Sun Aug 11 21:19:09 2013 +0100", "commit_message": "Fixed #20895 -- Made check management command warn if a BooleanField does not have a default value", "files_name": ["AUTHORS", "django/contrib/gis/tests/geoapp/models.py", "django/core/checks/compatibility/django_1_6_0.py", "tests/admin_views/models.py", "tests/aggregation_regress/models.py", "tests/check/models.py", "tests/check/tests.py", "tests/comment_tests/models.py", "tests/custom_managers/models.py", "tests/generic_relations/models.py", "tests/inspectdb/models.py", "tests/model_fields/models.py", "tests/model_fields/tests.py", "tests/model_formsets/models.py", "tests/model_inheritance/models.py", "tests/model_inheritance_regress/models.py", "tests/model_inheritance_select_related/models.py", "tests/modeladmin/models.py", "tests/one_to_one/models.py", "tests/one_to_one_regress/models.py", "tests/raw_query/models.py", "tests/reverse_single_related/models.py", "tests/serializers_regress/models.py"]}, {"commit_id": "165f44aaaa0b9008f35d8f6a3474db061559ad53", "commit_date": "Fri Aug 16 20:12:10 2013 +0200", "commit_message": "Combine consecutive with statements", "files_name": ["django/contrib/auth/tests/test_forms.py", "django/contrib/humanize/tests.py", "tests/admin_views/tests.py", "tests/admin_widgets/tests.py", "tests/defaultfilters/tests.py", "tests/forms_tests/tests/test_fields.py", "tests/i18n/tests.py", "tests/logging_tests/tests.py", "tests/one_to_one_regress/tests.py", "tests/test_utils/tests.py", "tests/transactions/tests.py", "tests/view_tests/tests/test_i18n.py"]}, {"commit_id": "240886183b022055b5a5115916c7c9766ec55c51", "commit_date": "Wed Jul 31 22:35:44 2013 +0200", "commit_message": "Fixed #20829 -- Skip postgis metadata tables with introspection", "files_name": ["django/contrib/gis/db/backends/postgis/introspection.py", "django/db/backends/postgresql_psycopg2/introspection.py"]}, {"commit_id": "c2907a6e3d96315027f7313885f3d0212dd19cbe", "commit_date": "Fri Aug 16 23:55:43 2013 -0600", "commit_message": "Remove the last FIXME from the howto-release-Django doc.", "files_name": ["docs/internals/howto-release-django.txt"]}, {"commit_id": "7a698c05b56d7d5e267241dc71c16c403efd2965", "commit_date": "Sun Aug 18 15:58:55 2013 +0200", "commit_message": "Update LazyObject method proxy declarations to simpler form.", "files_name": ["django/utils/functional.py"]}, {"commit_id": "aa01c99f5587b36c354e80c682ad52e1a3b41455", "commit_date": "Sun Aug 18 09:41:43 2013 -0700", "commit_message": "Merge pull request #1479 from nickbruun/ticket_20924", "files_name": ["40909826172374b849ddc9db8e1a8be9a8c3251b - Sun Aug 18 09:43:41 2013 -0700 : Some code simplification", "django/utils/functional.py"]}, {"commit_id": "4668c142dce77c6f29fb75532c1acfa1b2d322ff", "commit_date": "Wed Aug 7 09:51:32 2013 +0300", "commit_message": "Made Model.__eq__ consider proxy models equivalent", "files_name": ["django/db/models/base.py", "docs/ref/models/instances.txt", "docs/releases/1.7.txt", "tests/basic/tests.py", "tests/defer/tests.py", "tests/model_inheritance/tests.py", "tests/proxy_models/tests.py"]}, {"commit_id": "3844089edc43ff29aab5bac82a0eecab23d8d14a", "commit_date": "Thu Aug 15 10:32:54 2013 +0300", "commit_message": "Fixed #20777 -- Admin proxy model deletion regression", "files_name": ["django/contrib/admin/util.py", "docs/ref/models/instances.txt", "tests/proxy_models/admin.py", "tests/proxy_models/fixtures/myhorses.json", "tests/proxy_models/models.py", "tests/proxy_models/tests.py", "tests/proxy_models/urls.py"]}, {"commit_id": "630b9df42f771e90d9beb1766d4e7aa2107bd82d", "commit_date": "Mon Aug 19 14:07:51 2013 +0300", "commit_message": "Fixed #12567 -- Incorrect SQL in model inheritance case", "files_name": ["tests/model_inheritance/tests.py"]}, {"commit_id": "7d28bed13bfd07452fb7bc007544a34f7649a31f", "commit_date": "Mon Aug 19 14:16:10 2013 +0300", "commit_message": "PEP 8 cleanup", "files_name": ["tests/model_inheritance/tests.py"]}, {"commit_id": "5b522cd85a63cf5e352c500447aa91002e83845e", "commit_date": "Mon Aug 19 13:12:48 2013 +0100", "commit_message": "Minor oracle fixes", "files_name": ["django/db/backends/oracle/introspection.py"]}, {"commit_id": "52edc16086e3c28a78c31975bb4da2f9450590b4", "commit_date": "Mon Aug 19 13:50:26 2013 +0100", "commit_message": "Add more stringent M2M tests and fix the bug they exposed", "files_name": ["django/db/models/options.py", "tests/migrations/test_operations.py", "tests/schema/models.py", "tests/schema/tests.py"]}, {"commit_id": "7737305a4f5dc5006d92dac3a61523ad6c2a523a", "commit_date": "Mon Aug 19 16:00:17 2013 +0300", "commit_message": "Fixed #12886 -- aggregation over sliced queryset", "files_name": ["django/db/models/query.py", "django/db/models/sql/query.py", "tests/aggregation/tests.py"]}, {"commit_id": "7bc57a6d71dd4d00bb09cfa67be547591fd759ce", "commit_date": "Mon Aug 19 16:14:31 2013 +0300", "commit_message": "Fixed #11881 -- removed junk from aggregation subqueries", "files_name": ["django/db/models/sql/query.py", "tests/aggregation/tests.py"]}, {"commit_id": "58c6d0209d71872f0682d478921db1e00496e16c", "commit_date": "Mon Aug 19 16:24:45 2013 +0300", "commit_message": "Fixed #12807 -- EmptyResultSet ORed condition", "files_name": ["tests/queries/tests.py"]}, {"commit_id": "7b69c3e7758770dd632e1754c30714e91868e037", "commit_date": "Mon Aug 19 08:29:32 2013 -0400", "commit_message": "Removed versionadded/changed annotations for 1.5", "files_name": ["docs/ref/class-based-views/base.txt", "docs/ref/class-based-views/generic-date-based.txt", "docs/ref/class-based-views/mixins-date-based.txt", "docs/ref/class-based-views/mixins-multiple-object.txt", "docs/ref/class-based-views/mixins-simple.txt", "docs/ref/contrib/admin/index.txt", "docs/ref/contrib/auth.txt", "docs/ref/contrib/contenttypes.txt", "docs/ref/contrib/gis/geoquerysets.txt", "docs/ref/contrib/gis/geos.txt", "docs/ref/contrib/staticfiles.txt", "docs/ref/databases.txt", "docs/ref/django-admin.txt", "docs/ref/files/file.txt", "docs/ref/forms/api.txt", "docs/ref/forms/fields.txt", "docs/ref/forms/validation.txt", "docs/ref/forms/widgets.txt", "docs/ref/models/fields.txt", "docs/ref/models/instances.txt", "docs/ref/models/options.txt"]}], "parents": [{"commit_id_before": "a2286ac96445e943ffcbc624ee9a52d80d42533a", "url_before": "https://api.github.com/repos/django/django/commits/a2286ac96445e943ffcbc624ee9a52d80d42533a", "html_url_before": "https://github.com/django/django/commit/a2286ac96445e943ffcbc624ee9a52d80d42533a"}], "details": [{"raw_url": "https://github.com/django/django/raw/1a274ccd6bc1afbdac80344c9b6e5810c1162b5f/django%2Fcontrib%2Fauth%2Ftests%2Fviews.py", "code": "import os\nimport re\n\nfrom django.conf import global_settings, settings\nfrom django.contrib.sites.models import Site, RequestSite\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.core.exceptions import SuspiciousOperation\nfrom django.core.urlresolvers import reverse, NoReverseMatch\nfrom django.http import QueryDict, HttpRequest\nfrom django.utils.encoding import force_text\nfrom django.utils.html import escape\nfrom django.utils.http import urlquote\nfrom django.utils._os import upath\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.contrib.sessions.middleware import SessionMiddleware\n\nfrom django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME\nfrom django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,\n                SetPasswordForm, PasswordResetForm)\nfrom django.contrib.auth.tests.utils import skipIfCustomUser\nfrom django.contrib.auth.views import login as login_view\n\n\n@override_settings(\n    LANGUAGES=(\n        ('en', 'English'),\n    ),\n    LANGUAGE_CODE='en',\n    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,\n    TEMPLATE_DIRS=(\n        os.path.join(os.path.dirname(upath(__file__)), 'templates'),\n    ),\n    USE_TZ=False,\n    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),\n)\nclass AuthViewsTestCase(TestCase):\n    \"\"\"\n    Helper base class for all the follow test cases.\n    \"\"\"\n    fixtures = ['authtestdata.json']\n    urls = 'django.contrib.auth.tests.urls'\n\n    def login(self, password='password'):\n        response = self.client.post('/login/', {\n            'username': 'testclient',\n            'password': password,\n            })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))\n        self.assertTrue(SESSION_KEY in self.client.session)\n\n    def assertContainsEscaped(self, response, text, **kwargs):\n        return self.assertContains(response, escape(force_text(text)), **kwargs)\n\n\n@skipIfCustomUser\nclass AuthViewNamedURLTests(AuthViewsTestCase):\n    urls = 'django.contrib.auth.urls'\n\n    def test_named_urls(self):\n        \"Named URLs should be reversible\"\n        expected_named_urls = [\n            ('login', [], {}),\n            ('logout', [], {}),\n            ('password_change', [], {}),\n            ('password_change_done', [], {}),\n            ('password_reset', [], {}),\n            ('password_reset_done', [], {}),\n            ('password_reset_confirm', [], {\n                'uidb36': 'aaaaaaa',\n                'token': '1111-aaaaa',\n            }),\n            ('password_reset_complete', [], {}),\n        ]\n        for name, args, kwargs in expected_named_urls:\n            try:\n                reverse(name, args=args, kwargs=kwargs)\n            except NoReverseMatch:\n                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)\n\n\n@skipIfCustomUser\nclass PasswordResetTest(AuthViewsTestCase):\n\n    def test_email_not_found(self):\n        \"Error is raised if the provided email address isn't currently registered\"\n        response = self.client.get('/password_reset/')\n        self.assertEqual(response.status_code, 200)\n        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})\n        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_email_found(self):\n        \"Email is sent if a valid email address is provided for password reset\"\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertTrue(\"http://\" in mail.outbox[0].body)\n        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)\n\n    def test_email_found_custom_from(self):\n        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"\n        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)\n\n    @override_settings(ALLOWED_HOSTS=['adminsite.com'])\n    def test_admin_reset(self):\n        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"\n        response = self.client.post('/admin_password_reset/',\n            {'email': 'staffmember@example.com'},\n            HTTP_HOST='adminsite.com'\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)\n        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)\n\n    # Skip any 500 handler action (like sending more mail...)\n    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)\n    def test_poisoned_http_host(self):\n        \"Poisoned HTTP_HOST headers can't be used for reset emails\"\n        # This attack is based on the way browsers handle URLs. The colon\n        # should be used to separate the port, but if the URL contains an @,\n        # the colon is interpreted as part of a username for login purposes,\n        # making 'evil.com' the request domain. Since HTTP_HOST is used to\n        # produce a meaningful reset URL, we need to be certain that the\n        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()\n        # is invoked, but we check here as a practical consequence.\n        with self.assertRaises(SuspiciousOperation):\n            self.client.post('/password_reset/',\n                {'email': 'staffmember@example.com'},\n                HTTP_HOST='www.example:dr.frankenstein@evil.tld'\n            )\n        self.assertEqual(len(mail.outbox), 0)\n\n    # Skip any 500 handler action (like sending more mail...)\n    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)\n    def test_poisoned_http_host_admin_site(self):\n        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"\n        with self.assertRaises(SuspiciousOperation):\n            self.client.post('/admin_password_reset/',\n                {'email': 'staffmember@example.com'},\n                HTTP_HOST='www.example:dr.frankenstein@evil.tld'\n            )\n        self.assertEqual(len(mail.outbox), 0)\n\n    def _test_confirm_start(self):\n        # Start by creating the email\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        return self._read_signup_email(mail.outbox[0])\n\n    def _read_signup_email(self, email):\n        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)\n        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")\n        return urlmatch.group(), urlmatch.groups()[0]\n\n    def test_confirm_valid(self):\n        url, path = self._test_confirm_start()\n        response = self.client.get(path)\n        # redirect to a 'complete' page:\n        self.assertContains(response, \"Please enter your new password\")\n\n    def test_confirm_invalid(self):\n        url, path = self._test_confirm_start()\n        # Let's munge the token in the path, but keep the same length,\n        # in case the URLconf will reject a different length.\n        path = path[:-5] + (\"0\" * 4) + path[-1]\n\n        response = self.client.get(path)\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_invalid_user(self):\n        # Ensure that we get a 200 response for a non-existant user, not a 404\n        response = self.client.get('/reset/123456-1-1/')\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_overflow_user(self):\n        # Ensure that we get a 200 response for a base36 user id that overflows int\n        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_invalid_post(self):\n        # Same as test_confirm_invalid, but trying\n        # to do a POST instead.\n        url, path = self._test_confirm_start()\n        path = path[:-5] + (\"0\" * 4) + path[-1]\n\n        self.client.post(path, {\n            'new_password1': 'anewpassword',\n            'new_password2': ' anewpassword',\n        })\n        # Check the password has not been changed\n        u = User.objects.get(email='staffmember@example.com')\n        self.assertTrue(not u.check_password(\"anewpassword\"))\n\n    def test_confirm_complete(self):\n        url, path = self._test_confirm_start()\n        response = self.client.post(path, {'new_password1': 'anewpassword',\n                                           'new_password2': 'anewpassword'})\n        # It redirects us to a 'complete' page:\n        self.assertEqual(response.status_code, 302)\n        # Check the password has been changed\n        u = User.objects.get(email='staffmember@example.com')\n        self.assertTrue(u.check_password(\"anewpassword\"))\n\n        # Check we can't use the link again\n        response = self.client.get(path)\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_different_passwords(self):\n        url, path = self._test_confirm_start()\n        response = self.client.post(path, {'new_password1': 'anewpassword',\n                                           'new_password2': 'x'})\n        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])\n\n\n@override_settings(AUTH_USER_MODEL='auth.CustomUser')\nclass CustomUserPasswordResetTest(AuthViewsTestCase):\n    fixtures = ['custom_user.json']\n\n    def _test_confirm_start(self):\n        # Start by creating the email\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        return self._read_signup_email(mail.outbox[0])\n\n    def _read_signup_email(self, email):\n        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)\n        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")\n        return urlmatch.group(), urlmatch.groups()[0]\n\n    def test_confirm_valid_custom_user(self):\n        url, path = self._test_confirm_start()\n        response = self.client.get(path)\n        # redirect to a 'complete' page:\n        self.assertContains(response, \"Please enter your new password\")\n\n\n@skipIfCustomUser\nclass ChangePasswordTest(AuthViewsTestCase):\n\n    def fail_login(self, password='password'):\n        response = self.client.post('/login/', {\n            'username': 'testclient',\n            'password': password,\n        })\n        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'] % {\n                'username': User._meta.get_field('username').verbose_name\n            })\n\n    def logout(self):\n        response = self.client.get('/logout/')\n\n    def test_password_change_fails_with_invalid_old_password(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'donuts',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])\n\n    def test_password_change_fails_with_mismatched_passwords(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'donuts',\n        })\n        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])\n\n    def test_password_change_succeeds(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/password_change/done/'))\n        self.fail_login()\n        self.login(password='password1')\n\n    def test_password_change_done_succeeds(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/password_change/done/'))\n\n    def test_password_change_done_fails(self):\n        with self.settings(LOGIN_URL='/login/'):\n            response = self.client.get('/password_change/done/')\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))\n\n\n@skipIfCustomUser\nclass LoginTest(AuthViewsTestCase):\n\n    def test_current_site_in_context_after_login(self):\n        response = self.client.get(reverse('django.contrib.auth.views.login'))\n        self.assertEqual(response.status_code, 200)\n        if Site._meta.installed:\n            site = Site.objects.get_current()\n            self.assertEqual(response.context['site'], site)\n            self.assertEqual(response.context['site_name'], site.name)\n        else:\n            self.assertIsInstance(response.context['site'], RequestSite)\n        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),\n                     'Login form is not an AuthenticationForm')\n\n    def test_security_check(self, password='password'):\n        login_url = reverse('django.contrib.auth.views.login')\n\n        # Those URLs should not pass the security check\n        for bad_url in ('http://example.com',\n                        'https://example.com',\n                        'ftp://exampel.com',\n                        '//example.com',\n                        'javascript:alert(\"XSS\")'):\n\n            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                'url': login_url,\n                'next': REDIRECT_FIELD_NAME,\n                'bad_url': urlquote(bad_url),\n            }\n            response = self.client.post(nasty_url, {\n                'username': 'testclient',\n                'password': password,\n            })\n            self.assertEqual(response.status_code, 302)\n            self.assertFalse(bad_url in response['Location'],\n                             \"%s should be blocked\" % bad_url)\n\n        # These URLs *should* still pass the security check\n        for good_url in ('/view/?param=http://example.com',\n                         '/view/?param=https://example.com',\n                         '/view?param=ftp://exampel.com',\n                         'view/?param=//example.com',\n                         'https:///',\n                         'HTTPS:///',\n                         '//testserver/',\n                         '/url%20with%20spaces/'):  # see ticket #12534\n            safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n                'url': login_url,\n                'next': REDIRECT_FIELD_NAME,\n                'good_url': urlquote(good_url),\n            }\n            response = self.client.post(safe_url, {\n                    'username': 'testclient',\n                    'password': password,\n            })\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(good_url in response['Location'],\n                            \"%s should be allowed\" % good_url)\n\n    def test_login_csrf_rotate(self, password='password'):\n        \"\"\"\n        Makes sure that a login rotates the currently-used CSRF token.\n        \"\"\"\n        # Do a GET to establish a CSRF token\n        # TestClient isn't used here as we're testing middleware, essentially.\n        req = HttpRequest()\n        CsrfViewMiddleware().process_view(req, login_view, (), {})\n        req.META[\"CSRF_COOKIE_USED\"] = True\n        resp = login_view(req)\n        resp2 = CsrfViewMiddleware().process_response(req, resp)\n        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)\n        token1 = csrf_cookie.coded_value\n\n        # Prepare the POST request\n        req = HttpRequest()\n        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1\n        req.method = \"POST\"\n        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}\n        req.REQUEST = req.POST\n\n        # Use POST request to log in\n        SessionMiddleware().process_request(req)\n        CsrfViewMiddleware().process_view(req, login_view, (), {})\n        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view\n        req.META[\"SERVER_PORT\"] = 80\n        req.META[\"CSRF_COOKIE_USED\"] = True\n        resp = login_view(req)\n        resp2 = CsrfViewMiddleware().process_response(req, resp)\n        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)\n        token2 = csrf_cookie.coded_value\n\n        # Check the CSRF token switched\n        self.assertNotEqual(token1, token2)\n\n\n@skipIfCustomUser\nclass LoginURLSettings(AuthViewsTestCase):\n\n    def setUp(self):\n        super(LoginURLSettings, self).setUp()\n        self.old_LOGIN_URL = settings.LOGIN_URL\n\n    def tearDown(self):\n        super(LoginURLSettings, self).tearDown()\n        settings.LOGIN_URL = self.old_LOGIN_URL\n\n    def get_login_required_url(self, login_url):\n        settings.LOGIN_URL = login_url\n        response = self.client.get('/login_required/')\n        self.assertEqual(response.status_code, 302)\n        return response['Location']\n\n    def test_standard_login_url(self):\n        login_url = '/login/'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = '/login_required/'\n        self.assertEqual(login_required_url, 'http://testserver%s?%s' %\n                         (login_url, querystring.urlencode('/')))\n\n    def test_remote_login_url(self):\n        login_url = 'http://remote.example.com/login'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url,\n                         '%s?%s' % (login_url, querystring.urlencode('/')))\n\n    def test_https_login_url(self):\n        login_url = 'https:///login/'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url,\n                         '%s?%s' % (login_url, querystring.urlencode('/')))\n\n    def test_login_url_with_querystring(self):\n        login_url = '/login/?pretty=1'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('pretty=1', mutable=True)\n        querystring['next'] = '/login_required/'\n        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %\n                         querystring.urlencode('/'))\n\n    def test_remote_login_url_with_next_querystring(self):\n        login_url = 'http://remote.example.com/login/'\n        login_required_url = self.get_login_required_url('%s?next=/default/' %\n                                                         login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url, '%s?%s' % (login_url,\n                                                    querystring.urlencode('/')))\n\n\n@skipIfCustomUser\nclass LogoutTest(AuthViewsTestCase):\n\n    def confirm_logged_out(self):\n        self.assertTrue(SESSION_KEY not in self.client.session)\n\n    def test_logout_default(self):\n        \"Logout without next_page option renders the default template\"\n        self.login()\n        response = self.client.get('/logout/')\n        self.assertContains(response, 'Logged out')\n        self.confirm_logged_out()\n\n    def test_14377(self):\n        # Bug 14377\n        self.login()\n        response = self.client.get('/logout/')\n        self.assertTrue('site' in response.context)\n\n    def test_logout_with_overridden_redirect_url(self):\n        # Bug 11223\n        self.login()\n        response = self.client.get('/logout/next_page/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n\n        response = self.client.get('/logout/next_page/?next=/login/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/login/'))\n\n        self.confirm_logged_out()\n\n    def test_logout_with_next_page_specified(self):\n        \"Logout with next_page option given redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/next_page/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n        self.confirm_logged_out()\n\n    def test_logout_with_redirect_argument(self):\n        \"Logout with query string redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/?next=/login/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/login/'))\n        self.confirm_logged_out()\n\n    def test_logout_with_custom_redirect_argument(self):\n        \"Logout with custom query string redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/custom_query/?follow=/somewhere/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n        self.confirm_logged_out()\n\n    def test_security_check(self, password='password'):\n        logout_url = reverse('django.contrib.auth.views.logout')\n\n        # Those URLs should not pass the security check\n        for bad_url in ('http://example.com',\n                        'https://example.com',\n                        'ftp://exampel.com',\n                        '//example.com',\n                        'javascript:alert(\"XSS\")'):\n            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                'url': logout_url,\n                'next': REDIRECT_FIELD_NAME,\n                'bad_url': urlquote(bad_url),\n            }\n            self.login()\n            response = self.client.get(nasty_url)\n            self.assertEqual(response.status_code, 302)\n            self.assertFalse(bad_url in response['Location'],\n                             \"%s should be blocked\" % bad_url)\n            self.confirm_logged_out()\n\n        # These URLs *should* still pass the security check\n        for good_url in ('/view/?param=http://example.com',\n                         '/view/?param=https://example.com',\n                         '/view?param=ftp://exampel.com',\n                         'view/?param=//example.com',\n                         'https:///',\n                         'HTTPS:///',\n                         '//testserver/',\n                         '/url%20with%20spaces/'):  # see ticket #12534\n            safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n                'url': logout_url,\n                'next': REDIRECT_FIELD_NAME,\n                'good_url': urlquote(good_url),\n            }\n            self.login()\n            response = self.client.get(safe_url)\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(good_url in response['Location'],\n                            \"%s should be allowed\" % good_url)\n            self.confirm_logged_out()\n\n@skipIfCustomUser\nclass ChangelistTests(AuthViewsTestCase):\n    urls = 'django.contrib.auth.tests.urls_admin'\n\n    # #20078 - users shouldn't be allowed to guess password hashes via\n    # repeated password__startswith queries.\n    def test_changelist_disallows_password_lookups(self):\n        # Make me a superuser before loging in.\n        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)\n        self.login()\n\n        # A lookup that tries to filter on password isn't OK\n        with self.assertRaises(SuspiciousOperation):\n            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')\n", "code_before": "import os\nimport re\n\nfrom django.conf import global_settings, settings\nfrom django.contrib.sites.models import Site, RequestSite\nfrom django.contrib.auth.models import User\nfrom django.core import mail\nfrom django.core.exceptions import SuspiciousOperation\nfrom django.core.urlresolvers import reverse, NoReverseMatch\nfrom django.http import QueryDict, HttpRequest\nfrom django.utils.encoding import force_text\nfrom django.utils.html import escape\nfrom django.utils.http import urlquote\nfrom django.utils._os import upath\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.contrib.sessions.middleware import SessionMiddleware\n\nfrom django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME\nfrom django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,\n                SetPasswordForm, PasswordResetForm)\nfrom django.contrib.auth.tests.utils import skipIfCustomUser\nfrom django.contrib.auth.views import login as login_view\n\n\n@override_settings(\n    LANGUAGES=(\n        ('en', 'English'),\n    ),\n    LANGUAGE_CODE='en',\n    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,\n    TEMPLATE_DIRS=(\n        os.path.join(os.path.dirname(upath(__file__)), 'templates'),\n    ),\n    USE_TZ=False,\n    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),\n)\nclass AuthViewsTestCase(TestCase):\n    \"\"\"\n    Helper base class for all the follow test cases.\n    \"\"\"\n    fixtures = ['authtestdata.json']\n    urls = 'django.contrib.auth.tests.urls'\n\n    def login(self, password='password'):\n        response = self.client.post('/login/', {\n            'username': 'testclient',\n            'password': password,\n            })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))\n        self.assertTrue(SESSION_KEY in self.client.session)\n\n    def assertContainsEscaped(self, response, text, **kwargs):\n        return self.assertContains(response, escape(force_text(text)), **kwargs)\n\n\n@skipIfCustomUser\nclass AuthViewNamedURLTests(AuthViewsTestCase):\n    urls = 'django.contrib.auth.urls'\n\n    def test_named_urls(self):\n        \"Named URLs should be reversible\"\n        expected_named_urls = [\n            ('login', [], {}),\n            ('logout', [], {}),\n            ('password_change', [], {}),\n            ('password_change_done', [], {}),\n            ('password_reset', [], {}),\n            ('password_reset_done', [], {}),\n            ('password_reset_confirm', [], {\n                'uidb36': 'aaaaaaa',\n                'token': '1111-aaaaa',\n            }),\n            ('password_reset_complete', [], {}),\n        ]\n        for name, args, kwargs in expected_named_urls:\n            try:\n                reverse(name, args=args, kwargs=kwargs)\n            except NoReverseMatch:\n                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)\n\n\n@skipIfCustomUser\nclass PasswordResetTest(AuthViewsTestCase):\n\n    def test_email_not_found(self):\n        \"Error is raised if the provided email address isn't currently registered\"\n        response = self.client.get('/password_reset/')\n        self.assertEqual(response.status_code, 200)\n        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})\n        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_email_found(self):\n        \"Email is sent if a valid email address is provided for password reset\"\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertTrue(\"http://\" in mail.outbox[0].body)\n        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)\n\n    def test_email_found_custom_from(self):\n        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"\n        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)\n\n    @override_settings(ALLOWED_HOSTS=['adminsite.com'])\n    def test_admin_reset(self):\n        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"\n        response = self.client.post('/admin_password_reset/',\n            {'email': 'staffmember@example.com'},\n            HTTP_HOST='adminsite.com'\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)\n        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)\n\n    # Skip any 500 handler action (like sending more mail...)\n    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)\n    def test_poisoned_http_host(self):\n        \"Poisoned HTTP_HOST headers can't be used for reset emails\"\n        # This attack is based on the way browsers handle URLs. The colon\n        # should be used to separate the port, but if the URL contains an @,\n        # the colon is interpreted as part of a username for login purposes,\n        # making 'evil.com' the request domain. Since HTTP_HOST is used to\n        # produce a meaningful reset URL, we need to be certain that the\n        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()\n        # is invoked, but we check here as a practical consequence.\n        with self.assertRaises(SuspiciousOperation):\n            self.client.post('/password_reset/',\n                {'email': 'staffmember@example.com'},\n                HTTP_HOST='www.example:dr.frankenstein@evil.tld'\n            )\n        self.assertEqual(len(mail.outbox), 0)\n\n    # Skip any 500 handler action (like sending more mail...)\n    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)\n    def test_poisoned_http_host_admin_site(self):\n        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"\n        with self.assertRaises(SuspiciousOperation):\n            self.client.post('/admin_password_reset/',\n                {'email': 'staffmember@example.com'},\n                HTTP_HOST='www.example:dr.frankenstein@evil.tld'\n            )\n        self.assertEqual(len(mail.outbox), 0)\n\n    def _test_confirm_start(self):\n        # Start by creating the email\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        return self._read_signup_email(mail.outbox[0])\n\n    def _read_signup_email(self, email):\n        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)\n        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")\n        return urlmatch.group(), urlmatch.groups()[0]\n\n    def test_confirm_valid(self):\n        url, path = self._test_confirm_start()\n        response = self.client.get(path)\n        # redirect to a 'complete' page:\n        self.assertContains(response, \"Please enter your new password\")\n\n    def test_confirm_invalid(self):\n        url, path = self._test_confirm_start()\n        # Let's munge the token in the path, but keep the same length,\n        # in case the URLconf will reject a different length.\n        path = path[:-5] + (\"0\" * 4) + path[-1]\n\n        response = self.client.get(path)\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_invalid_user(self):\n        # Ensure that we get a 200 response for a non-existant user, not a 404\n        response = self.client.get('/reset/123456-1-1/')\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_overflow_user(self):\n        # Ensure that we get a 200 response for a base36 user id that overflows int\n        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_invalid_post(self):\n        # Same as test_confirm_invalid, but trying\n        # to do a POST instead.\n        url, path = self._test_confirm_start()\n        path = path[:-5] + (\"0\" * 4) + path[-1]\n\n        self.client.post(path, {\n            'new_password1': 'anewpassword',\n            'new_password2': ' anewpassword',\n        })\n        # Check the password has not been changed\n        u = User.objects.get(email='staffmember@example.com')\n        self.assertTrue(not u.check_password(\"anewpassword\"))\n\n    def test_confirm_complete(self):\n        url, path = self._test_confirm_start()\n        response = self.client.post(path, {'new_password1': 'anewpassword',\n                                           'new_password2': 'anewpassword'})\n        # It redirects us to a 'complete' page:\n        self.assertEqual(response.status_code, 302)\n        # Check the password has been changed\n        u = User.objects.get(email='staffmember@example.com')\n        self.assertTrue(u.check_password(\"anewpassword\"))\n\n        # Check we can't use the link again\n        response = self.client.get(path)\n        self.assertContains(response, \"The password reset link was invalid\")\n\n    def test_confirm_different_passwords(self):\n        url, path = self._test_confirm_start()\n        response = self.client.post(path, {'new_password1': 'anewpassword',\n                                           'new_password2': 'x'})\n        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])\n\n\n@override_settings(AUTH_USER_MODEL='auth.CustomUser')\nclass CustomUserPasswordResetTest(AuthViewsTestCase):\n    fixtures = ['custom_user.json']\n\n    def _test_confirm_start(self):\n        # Start by creating the email\n        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(len(mail.outbox), 1)\n        return self._read_signup_email(mail.outbox[0])\n\n    def _read_signup_email(self, email):\n        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)\n        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")\n        return urlmatch.group(), urlmatch.groups()[0]\n\n    def test_confirm_valid_custom_user(self):\n        url, path = self._test_confirm_start()\n        response = self.client.get(path)\n        # redirect to a 'complete' page:\n        self.assertContains(response, \"Please enter your new password\")\n\n\n@skipIfCustomUser\nclass ChangePasswordTest(AuthViewsTestCase):\n\n    def fail_login(self, password='password'):\n        response = self.client.post('/login/', {\n            'username': 'testclient',\n            'password': password,\n        })\n        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'] % {\n                'username': User._meta.get_field('username').verbose_name\n            })\n\n    def logout(self):\n        response = self.client.get('/logout/')\n\n    def test_password_change_fails_with_invalid_old_password(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'donuts',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])\n\n    def test_password_change_fails_with_mismatched_passwords(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'donuts',\n        })\n        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])\n\n    def test_password_change_succeeds(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/password_change/done/'))\n        self.fail_login()\n        self.login(password='password1')\n\n    def test_password_change_done_succeeds(self):\n        self.login()\n        response = self.client.post('/password_change/', {\n            'old_password': 'password',\n            'new_password1': 'password1',\n            'new_password2': 'password1',\n        })\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/password_change/done/'))\n\n    def test_password_change_done_fails(self):\n        with self.settings(LOGIN_URL='/login/'):\n            response = self.client.get('/password_change/done/')\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))\n\n\n@skipIfCustomUser\nclass LoginTest(AuthViewsTestCase):\n\n    def test_current_site_in_context_after_login(self):\n        response = self.client.get(reverse('django.contrib.auth.views.login'))\n        self.assertEqual(response.status_code, 200)\n        if Site._meta.installed:\n            site = Site.objects.get_current()\n            self.assertEqual(response.context['site'], site)\n            self.assertEqual(response.context['site_name'], site.name)\n        else:\n            self.assertIsInstance(response.context['site'], RequestSite)\n        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),\n                     'Login form is not an AuthenticationForm')\n\n    def test_security_check(self, password='password'):\n        login_url = reverse('django.contrib.auth.views.login')\n\n        # Those URLs should not pass the security check\n        for bad_url in ('http://example.com',\n                        'https://example.com',\n                        'ftp://exampel.com',\n                        '//example.com'):\n\n            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                'url': login_url,\n                'next': REDIRECT_FIELD_NAME,\n                'bad_url': urlquote(bad_url),\n            }\n            response = self.client.post(nasty_url, {\n                'username': 'testclient',\n                'password': password,\n            })\n            self.assertEqual(response.status_code, 302)\n            self.assertFalse(bad_url in response['Location'],\n                             \"%s should be blocked\" % bad_url)\n\n        # These URLs *should* still pass the security check\n        for good_url in ('/view/?param=http://example.com',\n                         '/view/?param=https://example.com',\n                         '/view?param=ftp://exampel.com',\n                         'view/?param=//example.com',\n                         'https:///',\n                         '//testserver/',\n                         '/url%20with%20spaces/'):  # see ticket #12534\n            safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n                'url': login_url,\n                'next': REDIRECT_FIELD_NAME,\n                'good_url': urlquote(good_url),\n            }\n            response = self.client.post(safe_url, {\n                    'username': 'testclient',\n                    'password': password,\n            })\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(good_url in response['Location'],\n                            \"%s should be allowed\" % good_url)\n\n    def test_login_csrf_rotate(self, password='password'):\n        \"\"\"\n        Makes sure that a login rotates the currently-used CSRF token.\n        \"\"\"\n        # Do a GET to establish a CSRF token\n        # TestClient isn't used here as we're testing middleware, essentially.\n        req = HttpRequest()\n        CsrfViewMiddleware().process_view(req, login_view, (), {})\n        req.META[\"CSRF_COOKIE_USED\"] = True\n        resp = login_view(req)\n        resp2 = CsrfViewMiddleware().process_response(req, resp)\n        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)\n        token1 = csrf_cookie.coded_value\n\n        # Prepare the POST request\n        req = HttpRequest()\n        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1\n        req.method = \"POST\"\n        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}\n        req.REQUEST = req.POST\n\n        # Use POST request to log in\n        SessionMiddleware().process_request(req)\n        CsrfViewMiddleware().process_view(req, login_view, (), {})\n        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view\n        req.META[\"SERVER_PORT\"] = 80\n        req.META[\"CSRF_COOKIE_USED\"] = True\n        resp = login_view(req)\n        resp2 = CsrfViewMiddleware().process_response(req, resp)\n        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)\n        token2 = csrf_cookie.coded_value\n\n        # Check the CSRF token switched\n        self.assertNotEqual(token1, token2)\n\n\n@skipIfCustomUser\nclass LoginURLSettings(AuthViewsTestCase):\n\n    def setUp(self):\n        super(LoginURLSettings, self).setUp()\n        self.old_LOGIN_URL = settings.LOGIN_URL\n\n    def tearDown(self):\n        super(LoginURLSettings, self).tearDown()\n        settings.LOGIN_URL = self.old_LOGIN_URL\n\n    def get_login_required_url(self, login_url):\n        settings.LOGIN_URL = login_url\n        response = self.client.get('/login_required/')\n        self.assertEqual(response.status_code, 302)\n        return response['Location']\n\n    def test_standard_login_url(self):\n        login_url = '/login/'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = '/login_required/'\n        self.assertEqual(login_required_url, 'http://testserver%s?%s' %\n                         (login_url, querystring.urlencode('/')))\n\n    def test_remote_login_url(self):\n        login_url = 'http://remote.example.com/login'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url,\n                         '%s?%s' % (login_url, querystring.urlencode('/')))\n\n    def test_https_login_url(self):\n        login_url = 'https:///login/'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url,\n                         '%s?%s' % (login_url, querystring.urlencode('/')))\n\n    def test_login_url_with_querystring(self):\n        login_url = '/login/?pretty=1'\n        login_required_url = self.get_login_required_url(login_url)\n        querystring = QueryDict('pretty=1', mutable=True)\n        querystring['next'] = '/login_required/'\n        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %\n                         querystring.urlencode('/'))\n\n    def test_remote_login_url_with_next_querystring(self):\n        login_url = 'http://remote.example.com/login/'\n        login_required_url = self.get_login_required_url('%s?next=/default/' %\n                                                         login_url)\n        querystring = QueryDict('', mutable=True)\n        querystring['next'] = 'http://testserver/login_required/'\n        self.assertEqual(login_required_url, '%s?%s' % (login_url,\n                                                    querystring.urlencode('/')))\n\n\n@skipIfCustomUser\nclass LogoutTest(AuthViewsTestCase):\n\n    def confirm_logged_out(self):\n        self.assertTrue(SESSION_KEY not in self.client.session)\n\n    def test_logout_default(self):\n        \"Logout without next_page option renders the default template\"\n        self.login()\n        response = self.client.get('/logout/')\n        self.assertContains(response, 'Logged out')\n        self.confirm_logged_out()\n\n    def test_14377(self):\n        # Bug 14377\n        self.login()\n        response = self.client.get('/logout/')\n        self.assertTrue('site' in response.context)\n\n    def test_logout_with_overridden_redirect_url(self):\n        # Bug 11223\n        self.login()\n        response = self.client.get('/logout/next_page/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n\n        response = self.client.get('/logout/next_page/?next=/login/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/login/'))\n\n        self.confirm_logged_out()\n\n    def test_logout_with_next_page_specified(self):\n        \"Logout with next_page option given redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/next_page/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n        self.confirm_logged_out()\n\n    def test_logout_with_redirect_argument(self):\n        \"Logout with query string redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/?next=/login/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/login/'))\n        self.confirm_logged_out()\n\n    def test_logout_with_custom_redirect_argument(self):\n        \"Logout with custom query string redirects to specified resource\"\n        self.login()\n        response = self.client.get('/logout/custom_query/?follow=/somewhere/')\n        self.assertEqual(response.status_code, 302)\n        self.assertTrue(response['Location'].endswith('/somewhere/'))\n        self.confirm_logged_out()\n\n    def test_security_check(self, password='password'):\n        logout_url = reverse('django.contrib.auth.views.logout')\n\n        # Those URLs should not pass the security check\n        for bad_url in ('http://example.com',\n                        'https://example.com',\n                        'ftp://exampel.com',\n                        '//example.com'):\n            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                'url': logout_url,\n                'next': REDIRECT_FIELD_NAME,\n                'bad_url': urlquote(bad_url),\n            }\n            self.login()\n            response = self.client.get(nasty_url)\n            self.assertEqual(response.status_code, 302)\n            self.assertFalse(bad_url in response['Location'],\n                             \"%s should be blocked\" % bad_url)\n            self.confirm_logged_out()\n\n        # These URLs *should* still pass the security check\n        for good_url in ('/view/?param=http://example.com',\n                         '/view/?param=https://example.com',\n                         '/view?param=ftp://exampel.com',\n                         'view/?param=//example.com',\n                         'https:///',\n                         '//testserver/',\n                         '/url%20with%20spaces/'):  # see ticket #12534\n            safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n                'url': logout_url,\n                'next': REDIRECT_FIELD_NAME,\n                'good_url': urlquote(good_url),\n            }\n            self.login()\n            response = self.client.get(safe_url)\n            self.assertEqual(response.status_code, 302)\n            self.assertTrue(good_url in response['Location'],\n                            \"%s should be allowed\" % good_url)\n            self.confirm_logged_out()\n\n@skipIfCustomUser\nclass ChangelistTests(AuthViewsTestCase):\n    urls = 'django.contrib.auth.tests.urls_admin'\n\n    # #20078 - users shouldn't be allowed to guess password hashes via\n    # repeated password__startswith queries.\n    def test_changelist_disallows_password_lookups(self):\n        # Make me a superuser before loging in.\n        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)\n        self.login()\n\n        # A lookup that tries to filter on password isn't OK\n        with self.assertRaises(SuspiciousOperation):\n            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')\n", "patch": "@@ -328,7 +328,8 @@ def test_security_check(self, password='password'):\n         for bad_url in ('http://example.com',\n                         'https://example.com',\n                         'ftp://exampel.com',\n-                        '//example.com'):\n+                        '//example.com',\n+                        'javascript:alert(\"XSS\")'):\n \n             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                 'url': login_url,\n@@ -349,6 +350,7 @@ def test_security_check(self, password='password'):\n                          '/view?param=ftp://exampel.com',\n                          'view/?param=//example.com',\n                          'https:///',\n+                         'HTTPS:///',\n                          '//testserver/',\n                          '/url%20with%20spaces/'):  # see ticket #12534\n             safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n@@ -522,7 +524,8 @@ def test_security_check(self, password='password'):\n         for bad_url in ('http://example.com',\n                         'https://example.com',\n                         'ftp://exampel.com',\n-                        '//example.com'):\n+                        '//example.com',\n+                        'javascript:alert(\"XSS\")'):\n             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n                 'url': logout_url,\n                 'next': REDIRECT_FIELD_NAME,\n@@ -541,6 +544,7 @@ def test_security_check(self, password='password'):\n                          '/view?param=ftp://exampel.com',\n                          'view/?param=//example.com',\n                          'https:///',\n+                         'HTTPS:///',\n                          '//testserver/',\n                          '/url%20with%20spaces/'):  # see ticket #12534\n             safe_url = '%(url)s?%(next)s=%(good_url)s' % {", "file_path": "files/2013_10/39", "file_language": "py", "file_name": "django/contrib/auth/tests/views.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.lang.security.audit.hardcoded-password-default-argument.hardcoded-password-default-argument\n          Hardcoded password is used as a default argument to 'test_security_check'. This could be       \n          dangerous if a real password is not supplied.                                                  \n          Details: https://sg.run/Lw9r                                                                   \n\n          518\u2506 def test_security_check(self, password='password'):\n          519\u2506     logout_url = reverse('django.contrib.auth.views.logout')\n          520\u2506 \n          521\u2506     # Those URLs should not pass the security check\n          522\u2506     for bad_url in ('http://example.com',\n          523\u2506                     'https://example.com',\n          524\u2506                     'ftp://exampel.com',\n          525\u2506                     '//example.com'):\n          526\u2506         nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n          527\u2506             'url': logout_url,\n          528\u2506             'next': REDIRECT_FIELD_NAME,\n          529\u2506             'bad_url': urlquote(bad_url),\n          530\u2506         }\n          531\u2506         self.login()\n          532\u2506         response = self.client.get(nasty_url)\n          533\u2506         self.assertEqual(response.status_code, 302)\n          534\u2506         self.assertFalse(bad_url in response['Location'],\n          535\u2506                          \"%s should be blocked\" % bad_url)\n          536\u2506         self.confirm_logged_out()\n          537\u2506 \n          538\u2506     # These URLs *should* still pass the security check\n          539\u2506     for good_url in ('/view/?param=http://example.com',\n          540\u2506                      '/view/?param=https://example.com',\n          541\u2506                      '/view?param=ftp://exampel.com',\n          542\u2506                      'view/?param=//example.com',\n          543\u2506                      'https:///',\n          544\u2506                      '//testserver/',\n          545\u2506                      '/url%20with%20spaces/'):  # see ticket #12534\n          546\u2506         safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n          547\u2506             'url': logout_url,\n          548\u2506             'next': REDIRECT_FIELD_NAME,\n          549\u2506             'good_url': urlquote(good_url),\n          550\u2506         }\n          551\u2506         self.login()\n          552\u2506         response = self.client.get(safe_url)\n          553\u2506         self.assertEqual(response.status_code, 302)\n          554\u2506         self.assertTrue(good_url in response['Location'],\n          555\u2506                         \"%s should be allowed\" % good_url)          556\u2506         self.confirm_logged_out()", "       python.lang.security.audit.hardcoded-password-default-argument.hardcoded-password-default-argument\n          Hardcoded password is used as a default argument to 'test_security_check'. This could be       \n          dangerous if a real password is not supplied.                                                  \n          Details: https://sg.run/Lw9r                                                                   \n\n          324\u2506 def test_security_check(self, password='password'):\n          325\u2506     login_url = reverse('django.contrib.auth.views.login')\n          326\u2506 \n          327\u2506     # Those URLs should not pass the security check\n          328\u2506     for bad_url in ('http://example.com',\n          329\u2506                     'https://example.com',\n          330\u2506                     'ftp://exampel.com',\n          331\u2506                     '//example.com'):\n          332\u2506 \n          333\u2506         nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {\n          334\u2506             'url': login_url,\n          335\u2506             'next': REDIRECT_FIELD_NAME,\n          336\u2506             'bad_url': urlquote(bad_url),\n          337\u2506         }\n          338\u2506         response = self.client.post(nasty_url, {\n          339\u2506             'username': 'testclient',\n          340\u2506             'password': password,\n          341\u2506         })\n          342\u2506         self.assertEqual(response.status_code, 302)\n          343\u2506         self.assertFalse(bad_url in response['Location'],\n          344\u2506                          \"%s should be blocked\" % bad_url)\n          345\u2506 \n          346\u2506     # These URLs *should* still pass the security check\n          347\u2506     for good_url in ('/view/?param=http://example.com',\n          348\u2506                      '/view/?param=https://example.com',\n          349\u2506                      '/view?param=ftp://exampel.com',\n          350\u2506                      'view/?param=//example.com',\n          351\u2506                      'https:///',\n          352\u2506                      '//testserver/',\n          353\u2506                      '/url%20with%20spaces/'):  # see ticket #12534\n          354\u2506         safe_url = '%(url)s?%(next)s=%(good_url)s' % {\n          355\u2506             'url': login_url,\n          356\u2506             'next': REDIRECT_FIELD_NAME,\n          357\u2506             'good_url': urlquote(good_url),\n          358\u2506         }\n          359\u2506         response = self.client.post(safe_url, {\n          360\u2506                 'username': 'testclient',\n          361\u2506                 'password': password,\n          362\u2506         })\n          363\u2506         self.assertEqual(response.status_code, 302)\n          364\u2506         self.assertTrue(good_url in response['Location'],\n          365\u2506                         \"%s should be allowed\" % good_url)"]]}, "target": 1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/django/django/raw/1a274ccd6bc1afbdac80344c9b6e5810c1162b5f/django%2Futils%2Fhttp.py", "code": "from __future__ import unicode_literals\n\nimport calendar\nimport datetime\nimport re\nimport sys\ntry:\n    from urllib import parse as urllib_parse\nexcept ImportError:     # Python 2\n    import urllib as urllib_parse\n    import urlparse\n    urllib_parse.urlparse = urlparse.urlparse\n\n\nfrom email.utils import formatdate\n\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str, force_text\nfrom django.utils.functional import allow_lazy\nfrom django.utils import six\n\nETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')\n\nMONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n__D = r'(?P<day>\\d{2})'\n__D2 = r'(?P<day>[ \\d]\\d)'\n__M = r'(?P<mon>\\w{3})'\n__Y = r'(?P<year>\\d{4})'\n__Y2 = r'(?P<year>\\d{2})'\n__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\nRFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\nRFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\nASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n\ndef urlquote(url, safe='/'):\n    \"\"\"\n    A version of Python's urllib.quote() function that can operate on unicode\n    strings. The url is first UTF-8 encoded before quoting. The returned string\n    can safely be used as part of an argument to a subsequent iri_to_uri() call\n    without double-quoting occurring.\n    \"\"\"\n    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))\nurlquote = allow_lazy(urlquote, six.text_type)\n\ndef urlquote_plus(url, safe=''):\n    \"\"\"\n    A version of Python's urllib.quote_plus() function that can operate on\n    unicode strings. The url is first UTF-8 encoded before quoting. The\n    returned string can safely be used as part of an argument to a subsequent\n    iri_to_uri() call without double-quoting occurring.\n    \"\"\"\n    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))\nurlquote_plus = allow_lazy(urlquote_plus, six.text_type)\n\ndef urlunquote(quoted_url):\n    \"\"\"\n    A wrapper for Python's urllib.unquote() function that can operate on\n    the result of django.utils.http.urlquote().\n    \"\"\"\n    return force_text(urllib_parse.unquote(force_str(quoted_url)))\nurlunquote = allow_lazy(urlunquote, six.text_type)\n\ndef urlunquote_plus(quoted_url):\n    \"\"\"\n    A wrapper for Python's urllib.unquote_plus() function that can operate on\n    the result of django.utils.http.urlquote_plus().\n    \"\"\"\n    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))\nurlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)\n\ndef urlencode(query, doseq=0):\n    \"\"\"\n    A version of Python's urllib.urlencode() function that can operate on\n    unicode strings. The parameters are first case to UTF-8 encoded strings and\n    then encoded as per normal.\n    \"\"\"\n    if isinstance(query, MultiValueDict):\n        query = query.lists()\n    elif hasattr(query, 'items'):\n        query = query.items()\n    return urllib_parse.urlencode(\n        [(force_str(k),\n         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))\n            for k, v in query],\n        doseq)\n\ndef cookie_date(epoch_seconds=None):\n    \"\"\"\n    Formats the time to ensure compatibility with Netscape's cookie standard.\n\n    Accepts a floating point number expressed in seconds since the epoch, in\n    UTC - such as that outputted by time.time(). If set to None, defaults to\n    the current time.\n\n    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.\n    \"\"\"\n    rfcdate = formatdate(epoch_seconds)\n    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])\n\ndef http_date(epoch_seconds=None):\n    \"\"\"\n    Formats the time to match the RFC1123 date format as specified by HTTP\n    RFC2616 section 3.3.1.\n\n    Accepts a floating point number expressed in seconds since the epoch, in\n    UTC - such as that outputted by time.time(). If set to None, defaults to\n    the current time.\n\n    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.\n    \"\"\"\n    rfcdate = formatdate(epoch_seconds)\n    return '%s GMT' % rfcdate[:25]\n\ndef parse_http_date(date):\n    \"\"\"\n    Parses a date format as specified by HTTP RFC2616 section 3.3.1.\n\n    The three formats allowed by the RFC are accepted, even if only the first\n    one is still in widespread use.\n\n    Returns an integer expressed in seconds since the epoch, in UTC.\n    \"\"\"\n    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately\n    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll\n    # our own RFC-compliant parsing.\n    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n        m = regex.match(date)\n        if m is not None:\n            break\n    else:\n        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n    try:\n        year = int(m.group('year'))\n        if year < 100:\n            if year < 70:\n                year += 2000\n            else:\n                year += 1900\n        month = MONTHS.index(m.group('mon').lower()) + 1\n        day = int(m.group('day'))\n        hour = int(m.group('hour'))\n        min = int(m.group('min'))\n        sec = int(m.group('sec'))\n        result = datetime.datetime(year, month, day, hour, min, sec)\n        return calendar.timegm(result.utctimetuple())\n    except Exception:\n        raise ValueError(\"%r is not a valid date\" % date)\n\ndef parse_http_date_safe(date):\n    \"\"\"\n    Same as parse_http_date, but returns None if the input is invalid.\n    \"\"\"\n    try:\n        return parse_http_date(date)\n    except Exception:\n        pass\n\n# Base 36 functions: useful for generating compact URLs\n\ndef base36_to_int(s):\n    \"\"\"\n    Converts a base 36 string to an ``int``. Raises ``ValueError` if the\n    input won't fit into an int.\n    \"\"\"\n    # To prevent overconsumption of server resources, reject any\n    # base36 string that is long than 13 base36 digits (13 digits\n    # is sufficient to base36-encode any 64-bit integer)\n    if len(s) > 13:\n        raise ValueError(\"Base36 input too large\")\n    value = int(s, 36)\n    # ... then do a final check that the value will fit into an int to avoid\n    # returning a long (#15067). The long type was removed in Python 3.\n    if not six.PY3 and value > sys.maxint:\n        raise ValueError(\"Base36 input too large\")\n    return value\n\ndef int_to_base36(i):\n    \"\"\"\n    Converts an integer to a base36 string\n    \"\"\"\n    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n    factor = 0\n    if i < 0:\n        raise ValueError(\"Negative base36 conversion input.\")\n    if not six.PY3:\n        if not isinstance(i, six.integer_types):\n            raise TypeError(\"Non-integer base36 conversion input.\")\n        if i > sys.maxint:\n            raise ValueError(\"Base36 conversion input too large.\")\n    # Find starting factor\n    while True:\n        factor += 1\n        if i < 36 ** factor:\n            factor -= 1\n            break\n    base36 = []\n    # Construct base36 representation\n    while factor >= 0:\n        j = 36 ** factor\n        base36.append(digits[i // j])\n        i = i % j\n        factor -= 1\n    return ''.join(base36)\n\ndef parse_etags(etag_str):\n    \"\"\"\n    Parses a string with one or several etags passed in If-None-Match and\n    If-Match headers by the rules in RFC 2616. Returns a list of etags\n    without surrounding double quotes (\") and unescaped from \\<CHAR>.\n    \"\"\"\n    etags = ETAG_MATCH.findall(etag_str)\n    if not etags:\n        # etag_str has wrong format, treat it as an opaque string then\n        return [etag_str]\n    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]\n    return etags\n\ndef quote_etag(etag):\n    \"\"\"\n    Wraps a string in double quotes escaping contents as necessary.\n    \"\"\"\n    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n\ndef same_origin(url1, url2):\n    \"\"\"\n    Checks if two URLs are 'same-origin'\n    \"\"\"\n    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)\n    return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)\n\ndef is_safe_url(url, host=None):\n    \"\"\"\n    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to\n    a different host and uses a safe scheme).\n\n    Always returns ``False`` on an empty url.\n    \"\"\"\n    if not url:\n        return False\n    url_info = urllib_parse.urlparse(url)\n    return (not url_info.netloc or url_info.netloc == host) and \\\n        (not url_info.scheme or url_info.scheme in ['http', 'https'])\n", "code_before": "from __future__ import unicode_literals\n\nimport calendar\nimport datetime\nimport re\nimport sys\ntry:\n    from urllib import parse as urllib_parse\nexcept ImportError:     # Python 2\n    import urllib as urllib_parse\n    import urlparse\n    urllib_parse.urlparse = urlparse.urlparse\n\n\nfrom email.utils import formatdate\n\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str, force_text\nfrom django.utils.functional import allow_lazy\nfrom django.utils import six\n\nETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')\n\nMONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n__D = r'(?P<day>\\d{2})'\n__D2 = r'(?P<day>[ \\d]\\d)'\n__M = r'(?P<mon>\\w{3})'\n__Y = r'(?P<year>\\d{4})'\n__Y2 = r'(?P<year>\\d{2})'\n__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\nRFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\nRFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\nASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n\ndef urlquote(url, safe='/'):\n    \"\"\"\n    A version of Python's urllib.quote() function that can operate on unicode\n    strings. The url is first UTF-8 encoded before quoting. The returned string\n    can safely be used as part of an argument to a subsequent iri_to_uri() call\n    without double-quoting occurring.\n    \"\"\"\n    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))\nurlquote = allow_lazy(urlquote, six.text_type)\n\ndef urlquote_plus(url, safe=''):\n    \"\"\"\n    A version of Python's urllib.quote_plus() function that can operate on\n    unicode strings. The url is first UTF-8 encoded before quoting. The\n    returned string can safely be used as part of an argument to a subsequent\n    iri_to_uri() call without double-quoting occurring.\n    \"\"\"\n    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))\nurlquote_plus = allow_lazy(urlquote_plus, six.text_type)\n\ndef urlunquote(quoted_url):\n    \"\"\"\n    A wrapper for Python's urllib.unquote() function that can operate on\n    the result of django.utils.http.urlquote().\n    \"\"\"\n    return force_text(urllib_parse.unquote(force_str(quoted_url)))\nurlunquote = allow_lazy(urlunquote, six.text_type)\n\ndef urlunquote_plus(quoted_url):\n    \"\"\"\n    A wrapper for Python's urllib.unquote_plus() function that can operate on\n    the result of django.utils.http.urlquote_plus().\n    \"\"\"\n    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))\nurlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)\n\ndef urlencode(query, doseq=0):\n    \"\"\"\n    A version of Python's urllib.urlencode() function that can operate on\n    unicode strings. The parameters are first case to UTF-8 encoded strings and\n    then encoded as per normal.\n    \"\"\"\n    if isinstance(query, MultiValueDict):\n        query = query.lists()\n    elif hasattr(query, 'items'):\n        query = query.items()\n    return urllib_parse.urlencode(\n        [(force_str(k),\n         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))\n            for k, v in query],\n        doseq)\n\ndef cookie_date(epoch_seconds=None):\n    \"\"\"\n    Formats the time to ensure compatibility with Netscape's cookie standard.\n\n    Accepts a floating point number expressed in seconds since the epoch, in\n    UTC - such as that outputted by time.time(). If set to None, defaults to\n    the current time.\n\n    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.\n    \"\"\"\n    rfcdate = formatdate(epoch_seconds)\n    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])\n\ndef http_date(epoch_seconds=None):\n    \"\"\"\n    Formats the time to match the RFC1123 date format as specified by HTTP\n    RFC2616 section 3.3.1.\n\n    Accepts a floating point number expressed in seconds since the epoch, in\n    UTC - such as that outputted by time.time(). If set to None, defaults to\n    the current time.\n\n    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.\n    \"\"\"\n    rfcdate = formatdate(epoch_seconds)\n    return '%s GMT' % rfcdate[:25]\n\ndef parse_http_date(date):\n    \"\"\"\n    Parses a date format as specified by HTTP RFC2616 section 3.3.1.\n\n    The three formats allowed by the RFC are accepted, even if only the first\n    one is still in widespread use.\n\n    Returns an integer expressed in seconds since the epoch, in UTC.\n    \"\"\"\n    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately\n    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll\n    # our own RFC-compliant parsing.\n    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n        m = regex.match(date)\n        if m is not None:\n            break\n    else:\n        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n    try:\n        year = int(m.group('year'))\n        if year < 100:\n            if year < 70:\n                year += 2000\n            else:\n                year += 1900\n        month = MONTHS.index(m.group('mon').lower()) + 1\n        day = int(m.group('day'))\n        hour = int(m.group('hour'))\n        min = int(m.group('min'))\n        sec = int(m.group('sec'))\n        result = datetime.datetime(year, month, day, hour, min, sec)\n        return calendar.timegm(result.utctimetuple())\n    except Exception:\n        raise ValueError(\"%r is not a valid date\" % date)\n\ndef parse_http_date_safe(date):\n    \"\"\"\n    Same as parse_http_date, but returns None if the input is invalid.\n    \"\"\"\n    try:\n        return parse_http_date(date)\n    except Exception:\n        pass\n\n# Base 36 functions: useful for generating compact URLs\n\ndef base36_to_int(s):\n    \"\"\"\n    Converts a base 36 string to an ``int``. Raises ``ValueError` if the\n    input won't fit into an int.\n    \"\"\"\n    # To prevent overconsumption of server resources, reject any\n    # base36 string that is long than 13 base36 digits (13 digits\n    # is sufficient to base36-encode any 64-bit integer)\n    if len(s) > 13:\n        raise ValueError(\"Base36 input too large\")\n    value = int(s, 36)\n    # ... then do a final check that the value will fit into an int to avoid\n    # returning a long (#15067). The long type was removed in Python 3.\n    if not six.PY3 and value > sys.maxint:\n        raise ValueError(\"Base36 input too large\")\n    return value\n\ndef int_to_base36(i):\n    \"\"\"\n    Converts an integer to a base36 string\n    \"\"\"\n    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n    factor = 0\n    if i < 0:\n        raise ValueError(\"Negative base36 conversion input.\")\n    if not six.PY3:\n        if not isinstance(i, six.integer_types):\n            raise TypeError(\"Non-integer base36 conversion input.\")\n        if i > sys.maxint:\n            raise ValueError(\"Base36 conversion input too large.\")\n    # Find starting factor\n    while True:\n        factor += 1\n        if i < 36 ** factor:\n            factor -= 1\n            break\n    base36 = []\n    # Construct base36 representation\n    while factor >= 0:\n        j = 36 ** factor\n        base36.append(digits[i // j])\n        i = i % j\n        factor -= 1\n    return ''.join(base36)\n\ndef parse_etags(etag_str):\n    \"\"\"\n    Parses a string with one or several etags passed in If-None-Match and\n    If-Match headers by the rules in RFC 2616. Returns a list of etags\n    without surrounding double quotes (\") and unescaped from \\<CHAR>.\n    \"\"\"\n    etags = ETAG_MATCH.findall(etag_str)\n    if not etags:\n        # etag_str has wrong format, treat it as an opaque string then\n        return [etag_str]\n    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]\n    return etags\n\ndef quote_etag(etag):\n    \"\"\"\n    Wraps a string in double quotes escaping contents as necessary.\n    \"\"\"\n    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n\ndef same_origin(url1, url2):\n    \"\"\"\n    Checks if two URLs are 'same-origin'\n    \"\"\"\n    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)\n    return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)\n\ndef is_safe_url(url, host=None):\n    \"\"\"\n    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to\n    a different host).\n\n    Always returns ``False`` on an empty url.\n    \"\"\"\n    if not url:\n        return False\n    netloc = urllib_parse.urlparse(url)[1]\n    return not netloc or netloc == host\n", "patch": "@@ -231,11 +231,12 @@ def same_origin(url1, url2):\n def is_safe_url(url, host=None):\n     \"\"\"\n     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to\n-    a different host).\n+    a different host and uses a safe scheme).\n \n     Always returns ``False`` on an empty url.\n     \"\"\"\n     if not url:\n         return False\n-    netloc = urllib_parse.urlparse(url)[1]\n-    return not netloc or netloc == host\n+    url_info = urllib_parse.urlparse(url)\n+    return (not url_info.netloc or url_info.netloc == host) and \\\n+        (not url_info.scheme or url_info.scheme in ['http', 'https'])", "file_path": "files/2013_10/40", "file_language": "py", "file_name": "django/utils/http.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 1, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
