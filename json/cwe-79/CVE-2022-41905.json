{"index": 9696, "cve_id": "CVE-2022-41905", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "WsgiDAV is a generic and extendable WebDAV server based on WSGI. Implementations using this library with directory browsing enabled may be susceptible to Cross Site Scripting (XSS) attacks. This issue has been patched, users can upgrade to version 4.1.0. As a workaround, set `dir_browser.enable = False` in the configuration.", "cvss": "6.1", "publish_date": "November 11, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "e9606ab0f42f4c1a6611bc3c52de299b0aba7726", "commit_message": "Merge pull request from GHSA-xx6g-jj35-pxjv", "commit_date": "2022-11-11T15:37:47Z", "project": "mar10/wsgidav", "url": "https://api.github.com/repos/mar10/wsgidav/commits/e9606ab0f42f4c1a6611bc3c52de299b0aba7726", "html_url": "https://github.com/mar10/wsgidav/commit/e9606ab0f42f4c1a6611bc3c52de299b0aba7726", "windows_before": [{"commit_id": "e5c757d71efbf660b5f77bde9faad99f2743238f", "commit_date": "Sun Nov 6 18:55:34 2022 +0100", "commit_message": "Fix tests", "files_name": ["tests/test_wsgidav_app.py", "wsgidav/dir_browser/_dir_browser.py"]}, {"commit_id": "73ea8f13d8b7d159c73a434beefe177f28314b3f", "commit_date": "Sun Nov 6 18:32:03 2022 +0100", "commit_message": "Silence flake8 B027", "files_name": ["wsgidav/dav_provider.py"]}, {"commit_id": "94538e1c41e1d5ed1cd15c78f191fddea86fc2c8", "commit_date": "Sun Nov 6 18:25:33 2022 +0100", "commit_message": "Improve dir browser & MOVE for reverse proxies", "files_name": [".gitignore", "CHANGELOG.md", "docs/source/reference_guide_glossary.rst", "docs/source/user_guide_configure.rst", "sample_wsgidav.yaml", "tests/fixtures/share/subfolder/subsub/test.txt", "wsgidav/dav_provider.py", "wsgidav/default_conf.py", "wsgidav/dir_browser/_dir_browser.py", "wsgidav/dir_browser/htdocs/template.html", "wsgidav/request_server.py", "wsgidav/util.py", "wsgidav/wsgidav_app.py"]}, {"commit_id": "f9b40df61ecb3be2307e03d1627e5b601f0b4f28", "commit_date": "Sat Nov 5 19:16:27 2022 +0100", "commit_message": "Create SECURITY.md", "files_name": [".github/SECURITY.md"]}, {"commit_id": "844f77233a887a5af1c652d83736b014adbb8301", "commit_date": "Sat Nov 5 11:40:14 2022 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["2d6e2213a9c1c8f38f82457bc137e3405c5b1a7b - Sat Nov 5 11:40:10 2022 +0100 : Update CHANGELOG.md", "CHANGELOG.md"]}, {"commit_id": "2d53452d1f3d95229747b1bf2a2cb03994fed062", "commit_date": "Thu Nov 3 20:48:10 2022 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["df0da7369188e17aa038a054add593ddf2b986aa - Thu Nov 3 20:47:36 2022 +0100 : Add cors docs", "docs/source/user_guide_configure.rst"]}, {"commit_id": "b96f07f3f28b2d99c9e86c9edef2cacaced24de8", "commit_date": "Fri Oct 21 17:30:47 2022 +0200", "commit_message": "Dirbrowser use relative paths to support reverse proxies", "files_name": ["CHANGELOG.md", "README.md", "\"tests/fixtures/share/subfolder/Lotosbl\\303\\274tenstengel (\\350\\223\\256\\350\\212\\261\\350\\216\\226).docx\"", "wsgidav/dir_browser/_dir_browser.py", "wsgidav/dir_browser/htdocs/template.html"]}, {"commit_id": "41b38eeace3723819c6b30271d66fc2e649c128e", "commit_date": "Fri Sep 30 19:01:32 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["b08b7fab233cf22c60d625fb30769071e67e3184 - Fri Sep 16 18:39:35 2022 +0200 : Update CHANGELOG.md", "CHANGELOG.md"]}, {"commit_id": "721d85c74b2f10f266571e85560d626d419c206f", "commit_date": "Thu Sep 15 19:33:17 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["0af3d9574f0237a6eee254c505ed169c62358728 - Thu Sep 15 19:33:15 2022 +0200 : Add  dir_browser/htdocs to setup.cfg", "CHANGELOG.md", "setup.cfg"]}, {"commit_id": "6c043393d58c1e045d1fe0ce7ea7b9fac2a63af3", "commit_date": "Wed Sep 14 21:46:17 2022 +0200", "commit_message": "Update pam_dc.py", "files_name": ["wsgidav/dc/pam_dc.py"]}, {"commit_id": "0a1c36211b79a52d2107c93f40411afe945604b4", "commit_date": "Wed Sep 14 21:19:14 2022 +0200", "commit_message": "ABC should have at least one @abstractmethod", "files_name": ["wsgidav/dav_provider.py"]}, {"commit_id": "d676a8abe008a8c21455f59e135125eb55356276", "commit_date": "Wed Sep 14 21:06:55 2022 +0200", "commit_message": "Fix PAM not threadsafe", "files_name": ["Pipfile.lock", "docs/source/requirements.txt", "requirements.txt", "wsgidav/dc/pam_dc.py"]}, {"commit_id": "c6b4fd76b02804e1c9803afc7863d77e8925c304", "commit_date": "Mon Aug 1 18:32:08 2022 +0200", "commit_message": "Update docs", "files_name": ["CHANGELOG.md", "docs/source/index.rst", "docs/source/installation.rst"]}, {"commit_id": "116b743debc11da8f1824fd3b879176d518b49e7", "commit_date": "Mon Aug 1 17:26:03 2022 +0200", "commit_message": "Bump prerelease (4.0.3-a1) [ci skip]", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "edef1295c213194cde7aff476efd68d17f0f8702", "commit_date": "Mon Aug 1 17:25:32 2022 +0200", "commit_message": "Bump version to 4.0.2", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "106d73a3c344ca32b9a7e2670f0d660984173708", "commit_date": "Mon Aug 1 17:20:51 2022 +0200", "commit_message": "Update yabs.yaml", "files_name": ["yabs.yaml"]}, {"commit_id": "e976ea61f36565eb8a9e0f22e9da3822979d5eff", "commit_date": "Mon Aug 1 17:12:59 2022 +0200", "commit_message": "Update setup.cfg", "files_name": ["setup.cfg"]}, {"commit_id": "3b9c31ad04f4673cdd6e6f2f5bd44fa4e992d110", "commit_date": "Mon Aug 1 17:01:30 2022 +0200", "commit_message": "docs", "files_name": [".github/FUNDING.yml", "README.md"]}, {"commit_id": "1722db3b9a6a887bf04f0ff084495bb39a0ddd67", "commit_date": "Mon Aug 1 17:00:47 2022 +0200", "commit_message": "Update tox.ini", "files_name": ["tox.ini"]}, {"commit_id": "9d86c27d71ce74f86c93dd59b4ee76a89688007e", "commit_date": "Mon Aug 1 17:00:19 2022 +0200", "commit_message": "Don't build prerelease MSI files (use 0.0.0.0 instead)", "files_name": ["setup_bdist_msi.py"]}, {"commit_id": "571286486806ae324dacb07f69f341b7a8ac5686", "commit_date": "Mon Aug 1 16:33:03 2022 +0200", "commit_message": "Add shelve support to MSI installer (persistent lock- and property storage)", "files_name": ["CHANGELOG.md", "setup_bdist_msi.py"]}, {"commit_id": "cb4435701b3e15cc8f4e34af3ef87eacae7b778a", "commit_date": "Mon Aug 1 08:16:26 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["f54f3a52ec3e1d7946533a7a8693ca74e0e940d5 - Sun Jul 31 20:37:14 2022 +0200 : Prepare MSI release", "Pipfile", "Pipfile.lock", "docs/source/requirements.txt", "tox.ini", "yabs.yaml"]}, {"commit_id": "fbf9e105e3a6da47c9836e2b22402a94842c3e0f", "commit_date": "Sun Jul 31 13:15:31 2022 +0200", "commit_message": "optimize travis", "files_name": [".travis.yml"]}, {"commit_id": "d5d7b00a16efe2c032570b15fad2475c89718df7", "commit_date": "Sun Jul 31 08:27:07 2022 +0200", "commit_message": "Fix package name", "files_name": ["docs/source/development.rst", "setup.cfg", "setup.py", "tox.ini"]}, {"commit_id": "7b368a6c6bc05eeec50c14d8faa73130ecb507ce", "commit_date": "Sat Jul 30 20:07:51 2022 +0200", "commit_message": "Fix travis", "files_name": [".travis.yml", "yabs.yaml"]}, {"commit_id": "eef8e22db774906917ae974f4a9d328adae6747e", "commit_date": "Sat Jul 30 19:59:40 2022 +0200", "commit_message": "Update changelog", "files_name": ["CHANGELOG.md", "requirements-dev.txt", "setup.cfg", "setup.py", "setup_bdist_msi.py", "tox.ini"]}, {"commit_id": "b51035c7c34f40d106954f673530f12a714315f2", "commit_date": "Thu Jul 21 07:30:43 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["47484088202706f66d7a1e18d0ad5da0781e8448 - Mon Jul 18 00:21:14 2022 -0500 : Use the required dry_run keyword argument when calling set_last_modified (#261)", "CHANGELOG.md", "wsgidav/dav_provider.py"]}, {"commit_id": "8ec0f8d40cbd2724ef9448a4233be5f11cb1dbbe", "commit_date": "Wed Jul 13 06:50:25 2022 +0200", "commit_message": "Case-Sensitivity issue on MOVE/COPY actions through Windows DAV", "files_name": ["CHANGELOG.md", "wsgidav/request_server.py"]}, {"commit_id": "f1a7848c10bf9f6b933e17c20a8cebbc879e77d3", "commit_date": "Sun Jul 10 16:55:38 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["73458505e945946b927bb20476222e41a4d5cf58 - Sun Jul 10 09:09:19 2022 +0200 : Fix lint error", "Pipfile.lock", "tests/davclient.py"]}, {"commit_id": "1d8e4992649058cebb6da5225cd9b1042f4d74e2", "commit_date": "Sun Jul 10 09:02:20 2022 +0200", "commit_message": "Fix travis environment configuration", "files_name": [".travis.yml", "setup.cfg"]}, {"commit_id": "97328a9a0f91289e228bf7be902bd879f952c75d", "commit_date": "Sun Jul 10 09:00:35 2022 +0200", "commit_message": "Fix ERROR: Invalid requirement: 'cheroot~=8' (from line 5 of requirements-dev.txt)", "files_name": ["requirements-dev.txt"]}, {"commit_id": "de622d0eaef96c63109af8501caf4c8c25f0f0a4", "commit_date": "Wed Jul 6 13:14:48 2022 +0200", "commit_message": "Create FUNDING.yml", "files_name": [".github/FUNDING.yml"]}, {"commit_id": "8dd957e09b1d66c1b6f431afcccb05ecc37fa2c5", "commit_date": "Mon Jul 4 12:30:20 2022 +0200", "commit_message": "Cleanup", "files_name": ["CHANGELOG.md", "setup_bdist_msi.py"]}, {"commit_id": "0d904ba0363ba9befdef0cc399d9e5ee58b81355", "commit_date": "Mon Jul 4 09:53:14 2022 +0200", "commit_message": "Move discussions from Google Groups to GitHub", "files_name": ["README.md", "docs/source/development.rst"]}, {"commit_id": "9d95686a21bba3816621d0609a7dbc555d7927c1", "commit_date": "Mon Jul 4 09:27:03 2022 +0200", "commit_message": "Add changelog link to releases", "files_name": ["yabs.yaml"]}, {"commit_id": "e0d26913839a9f45829a8d0ea34202688f3c1ee8", "commit_date": "Thu Apr 7 21:04:37 2022 +0200", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["c83c2bd91c1307e0c5115b9fa34c1241b2b52640 - Thu Apr 7 19:59:01 2022 +0200 : Add dir_browser/htdocs folder", "setup.cfg", "wsgidav/__init__.py"]}, {"commit_id": "e129cbb50392c40cc711bae76c4cebf179f55523", "commit_date": "Wed Apr 6 20:57:56 2022 +0200", "commit_message": "Update .travis.yml", "files_name": [".travis.yml"]}, {"commit_id": "a9af4398b17a8b1d05b625dc0c3ecb55dd97d32d", "commit_date": "Wed Apr 6 20:55:13 2022 +0200", "commit_message": "Update docs", "files_name": ["CHANGELOG.md", "docs/source/installation.rst"]}, {"commit_id": "7de60e27550fecfd40c062f9127f82976cda9f9c", "commit_date": "Thu Mar 24 18:12:46 2022 +0100", "commit_message": "Merge branch 'pr/251'", "files_name": ["45cd5a2cb99b894f4ebd2b5eee81a9e69e86c487 - Thu Mar 24 18:10:39 2022 +0100 : Fix removing locks in recursive mode (#251)", "CHANGELOG.md", "wsgidav/dav_provider.py", "wsgidav/lock_man/lock_manager.py"]}, {"commit_id": "724070899a47ed326382ec5131ea7df6ea7e4ee7", "commit_date": "Thu Mar 24 18:07:05 2022 +0100", "commit_message": "Merge branch 'master' into pr/251", "files_name": ["fcb883bbb047e81b0c6b55d887cd0c9e109589e3 - Thu Mar 24 18:05:50 2022 +0100 : Pin black 22.1", "Pipfile", "requirements-dev.txt", "tox.ini", "wsgidav/server/server_cli.py"]}, {"commit_id": "46840bf47c1a83dc2958e15c214fc9c055ec976c", "commit_date": "Thu Mar 24 16:32:19 2022 +0100", "commit_message": "tox -e format", "files_name": ["wsgidav/dav_provider.py"]}, {"commit_id": "682be62aaf7dd219cda85cf83151263f79b2b133", "commit_date": "Thu Mar 24 09:45:49 2022 +0100", "commit_message": "Keeps locks & properties recursion on resources to preserve compatibility with old WEBDAV clients", "files_name": ["wsgidav/fs_dav_provider.py"]}, {"commit_id": "35b6778d68fa1f009f3208c6453ee1f7db3f69fb", "commit_date": "Tue Mar 22 18:45:01 2022 +0100", "commit_message": "Fix typo in changelog", "files_name": ["CHANGELOG.md"]}, {"commit_id": "61fc73d788cf8b64cb1f57bcf3a9067c829a311b", "commit_date": "Tue Mar 22 18:42:14 2022 +0100", "commit_message": "remove explicit statement & force named args", "files_name": ["CHANGELOG.md", "wsgidav/dav_provider.py", "wsgidav/lock_man/lock_manager.py"]}, {"commit_id": "067a54caade8d1d55f52fa5d84558761d9d5f535", "commit_date": "Thu Mar 17 11:40:33 2022 +0100", "commit_message": "Fix removing locks in recursive mode", "files_name": []}], "windows_after": [{"commit_id": "6d6dfeb39ee3798fbc3bfda42b72b3ec3aa9e73a", "commit_date": "Fri Nov 11 16:41:53 2022 +0100", "commit_message": "Update CHANGELOG.md", "files_name": ["CHANGELOG.md"]}, {"commit_id": "146e657c4df4540f88a01e0c5e578017864e9c97", "commit_date": "Fri Nov 11 17:06:27 2022 +0100", "commit_message": "Fix yabs", "files_name": ["Pipfile", "Pipfile.lock", "yabs.yaml"]}, {"commit_id": "749440bd8f943c97184e45f3b07fdce4a81bfd76", "commit_date": "Fri Nov 11 17:12:03 2022 +0100", "commit_message": "Bump version to 4.1.0", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "5aed5ad06f8dc4b6920697119a2bddca2b000970", "commit_date": "Fri Nov 11 17:12:38 2022 +0100", "commit_message": "Bump prerelease (4.1.1-a1) [ci skip]", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "2e3b4b92efa3e78233b2a3c2454c521d40316321", "commit_date": "Fri Nov 11 20:23:36 2022 +0100", "commit_message": "Update CHANGELOG.md", "files_name": ["CHANGELOG.md"]}, {"commit_id": "634a2c66b8a4fcfdd11bc6d1924bda7b28d7241a", "commit_date": "Fri Nov 11 20:57:56 2022 +0100", "commit_message": "Create codeql.yml", "files_name": [".github/workflows/codeql.yml"]}, {"commit_id": "63190d5fdc7df09d6b3aa9c904b0d8562342a3fd", "commit_date": "Fri Nov 11 21:11:53 2022 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["f34d83c395de07f2c0d2239b6a9b76a4e4d6e44b - Sun Nov 13 18:01:24 2022 +0100 : Update .gitignore", ".gitignore"]}, {"commit_id": "6ae88e1efa34dc95f3de4aec357b18a75cbe2878", "commit_date": "Sun Nov 13 18:01:26 2022 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["7fe221a0850e1fe7402b250f845905deed0e6604 - Sat Jan 7 14:20:36 2023 +0100 : Fix codeql hint", "wsgidav/dir_browser/htdocs/template.html", "wsgidav/util.py"]}, {"commit_id": "53e8130ef736d926428366f1dcb8dcb8c48c4155", "commit_date": "Sat Jan 7 14:32:32 2023 +0100", "commit_message": "Fix tox errors", "files_name": ["tox.ini", "wsgidav/util.py"]}, {"commit_id": "0bf23b08b9c7ca73afaeae52d53e446776fed425", "commit_date": "Sat Jan 7 14:32:37 2023 +0100", "commit_message": "Update Pipfile.lock", "files_name": ["Pipfile.lock"]}, {"commit_id": "a7a383d0ac46ed0069971844e47d8114c50f7e97", "commit_date": "Sun Jan 8 17:02:25 2023 +0800", "commit_message": "Add quota-used-bytes and quota-available-bytes (RFC4331) (#277)", "files_name": ["CHANGELOG.md", "wsgidav/dav_provider.py", "wsgidav/fs_dav_provider.py"]}, {"commit_id": "c557b5e8db42f519356cb3f8ce7db7c73930a323", "commit_date": "Sun Jan 15 15:23:23 2023 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["c4e516334e29a7decbf2a82f3c4e71fa2ce9e93f - Sun Jan 15 15:28:37 2023 +0100 : Update codeql.yml", ".github/workflows/codeql.yml"]}, {"commit_id": "a0f2ca5903e824c7c6ba92beaa7f8d6207835c31", "commit_date": "Mon Jan 16 21:15:24 2023 +0100", "commit_message": "Official support for Python 3.11 , Update to black 22.12", "files_name": [".travis.yml", "CHANGELOG.md", "Pipfile", "Pipfile.lock", "docs/source/development.rst", "requirements-dev.txt", "setup.cfg", "tox.ini"]}, {"commit_id": "3b2478d9038125315212009425ef48474fd97775", "commit_date": "Thu Jan 19 19:47:59 2023 +0100", "commit_message": "Fix flake8", "files_name": [".travis.yml", "setup.cfg", "setup_bdist_msi.py", "tests/test_util.py", "wsgidav/dav_error.py", "wsgidav/dc/base_dc.py", "wsgidav/dc/nt_dc.py", "wsgidav/dc/pam_dc.py", "wsgidav/dc/simple_dc.py", "wsgidav/fs_dav_provider.py", "wsgidav/http_authenticator.py", "wsgidav/lock_man/lock_manager.py", "wsgidav/mw/debug_filter.py", "wsgidav/prop_man/property_manager.py", "wsgidav/request_resolver.py", "wsgidav/request_server.py", "wsgidav/server/ext_wsgiutils_server.py", "wsgidav/server/server_cli.py", "wsgidav/util.py", "wsgidav/wsgidav_app.py"]}, {"commit_id": "fe39bd86aee368ca86fbe2d964de6ebf9a42ae7b", "commit_date": "Sun Jan 22 17:05:35 2023 +0100", "commit_message": "Use Python 3.11 for CI", "files_name": ["Pipfile", "Pipfile.lock", "tox.ini"]}, {"commit_id": "f540f077825397719cdfae6b405f420ef734d172", "commit_date": "Sun Jan 22 18:56:56 2023 +0100", "commit_message": "Fix tox -e format", "files_name": ["CHANGELOG.md", "Pipfile", "requirements-dev.txt", "tox.ini"]}, {"commit_id": "d1cafc240ffb55e84c4a09bd7b1c17279ad20e57", "commit_date": "Mon Jan 23 20:20:19 2023 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["db1310f39bf474c2f7a4e67721d99129ff191a1b - Mon Jan 23 20:47:53 2023 +0100 : Update Pipfile.lock", "Pipfile.lock"]}, {"commit_id": "607c22e204f15401b6155c9d2057ed19ee2acab1", "commit_date": "Sun Feb 5 19:02:53 2023 +0100", "commit_message": "Update yabs.yaml", "files_name": ["yabs.yaml"]}, {"commit_id": "84389b95793e13b8861994ea15229f1b3397e236", "commit_date": "Sun Feb 12 17:47:50 2023 +0100", "commit_message": "Stop testing Python 3.6 (EOL 2021-12-21)", "files_name": [".travis.yml", "CHANGELOG.md", "tox.ini"]}, {"commit_id": "3cae7197d324ec91a4aa2819f39735a041c5ee04", "commit_date": "Thu Feb 16 22:05:52 2023 +0100", "commit_message": "Update .travis.yml", "files_name": [".travis.yml"]}, {"commit_id": "6748efd4f8b58da1b8f30dc5775c32c3580a08f6", "commit_date": "Sat Feb 18 16:22:45 2023 +0100", "commit_message": "Test py3.12-dev", "files_name": [".travis.yml"]}, {"commit_id": "195e6e6331d7d2deca434990dd14cd73d8987cda", "commit_date": "Sat Feb 18 16:24:26 2023 +0100", "commit_message": "Update CHANGELOG.md", "files_name": ["CHANGELOG.md"]}, {"commit_id": "bd11268a1ebf681ee218b25da94884e56267af72", "commit_date": "Sat Feb 18 16:38:22 2023 +0100", "commit_message": "2023", "files_name": ["LICENSE", "docs/source/conf.py", "setup_bdist_msi.py", "tests/benchmarks.py", "tests/test_http.py", "tests/test_litmus.py", "tests/test_lock_manager.py", "tests/test_property_manager.py", "tests/test_scripted.py", "tests/test_streaming.py", "tests/test_util.py", "tests/test_wsgidav_app.py", "tests/util.py", "wsgidav/dav_error.py", "wsgidav/dav_provider.py", "wsgidav/dc/base_dc.py", "wsgidav/dc/nt_dc.py", "wsgidav/dc/pam_dc.py", "wsgidav/dc/simple_dc.py", "wsgidav/default_conf.py", "wsgidav/dir_browser/_dir_browser.py", "wsgidav/error_printer.py", "wsgidav/fs_dav_provider.py", "wsgidav/http_authenticator.py", "wsgidav/lock_man/lock_manager.py", "wsgidav/lock_man/lock_storage.py", "wsgidav/lock_man/lock_storage_redis.py", "wsgidav/mw/cors.py", "wsgidav/mw/debug_filter.py", "wsgidav/prop_man/couch_property_manager.py", "wsgidav/prop_man/mongo_property_manager.py", "wsgidav/prop_man/property_manager.py", "wsgidav/request_resolver.py", "wsgidav/request_server.py", "wsgidav/samples/dav_provider_tools.py", "wsgidav/samples/hg_dav_provider.py", "wsgidav/samples/mongo_dav_provider.py", "wsgidav/samples/mysql_dav_provider.py", "wsgidav/samples/virtual_dav_provider.py", "wsgidav/server/ext_wsgiutils_server.py", "wsgidav/server/run_reloading_server.py", "wsgidav/server/server_sample.py", "wsgidav/stream_tools.py", "wsgidav/util.py", "wsgidav/wsgidav_app.py", "wsgidav/xml_tools.py", "yabs.yaml"]}, {"commit_id": "90b8825d8a36cd52251f81e7ac197b8453bd8bfa", "commit_date": "Sat Feb 18 16:50:49 2023 +0100", "commit_message": "Update Pipfile.lock", "files_name": ["Pipfile.lock"]}, {"commit_id": "4ba9410500bca2cd3541efc0caecd5c033839bfb", "commit_date": "Sat Feb 18 17:14:44 2023 +0100", "commit_message": "Bump version to 4.2.0", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "5226e576638dfb787fc73ba1b18ffff2b5b2b3e1", "commit_date": "Sat Feb 18 17:15:33 2023 +0100", "commit_message": "Bump prerelease (4.2.1-a1) [ci skip]", "files_name": ["wsgidav/__init__.py"]}, {"commit_id": "d68438af19477323a1fe3ea313ef2f9bbe4c4b83", "commit_date": "Sun Feb 19 08:45:24 2023 +0100", "commit_message": "Merge branch 'master' of https://github.com/mar10/wsgidav", "files_name": ["5f259c2818aa19b4845db609b1ebb510b0f82ab2 - Mon Apr 10 17:59:26 2023 +0200 : Install pam_dc dependencies using extra syntax: `pip install wsgidav[pam]`", "CHANGELOG.md", "README.md", "setup.cfg", "wsgidav/dc/pam_dc.py"]}, {"commit_id": "1fdb68fab06a899b987cc9895f936bf6eae0a74b", "commit_date": "Mon Apr 10 19:16:06 2023 +0200", "commit_message": "Snake-cased some vars", "files_name": ["wsgidav/dav_error.py", "wsgidav/request_server.py", "wsgidav/util.py"]}, {"commit_id": "aa6d4987c125943c49326afb202210253ffa11d3", "commit_date": "Tue Apr 11 22:09:58 2023 +0200", "commit_message": "Fix: Requesting range off end of file does not return 416 status code", "files_name": ["CHANGELOG.md", "wsgidav/dav_error.py", "wsgidav/error_printer.py", "wsgidav/request_server.py", "wsgidav/util.py"]}, {"commit_id": "53092f201c0c22fc70fd4702e65102a1a73a75eb", "commit_date": "Thu Apr 13 21:06:58 2023 +0200", "commit_message": "Hotfix PUT request without content-length (#282)", "files_name": ["CHANGELOG.md", "sample_wsgidav.yaml", "wsgidav/default_conf.py", "wsgidav/request_server.py"]}, {"commit_id": "c17aad4b170b9a15ea8a62bc18db8ddfa800cb03", "commit_date": "Fri May 5 16:32:51 2023 +0200", "commit_message": "Add `logging.enable` option", "files_name": ["CHANGELOG.md", "docs/source/user_guide_lib.rst", "tests/test_logging"]}], "parents": [{"commit_id_before": "e5c757d71efbf660b5f77bde9faad99f2743238f", "url_before": "https://api.github.com/repos/mar10/wsgidav/commits/e5c757d71efbf660b5f77bde9faad99f2743238f", "html_url_before": "https://github.com/mar10/wsgidav/commit/e5c757d71efbf660b5f77bde9faad99f2743238f"}], "details": [{"raw_url": "https://github.com/mar10/wsgidav/raw/e9606ab0f42f4c1a6611bc3c52de299b0aba7726/wsgidav%2Fdir_browser%2F_dir_browser.py", "code": "# -*- coding: utf-8 -*-\n# (c) 2009-2022 Martin Wendt and contributors; see WsgiDAV https://github.com/mar10/wsgidav\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license.php\n\"\"\"\nWSGI middleware that handles GET requests on collections to display directories.\n\"\"\"\nimport os\nimport sys\nfrom fnmatch import fnmatch\nfrom urllib.parse import unquote\n\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\n\nfrom wsgidav import __version__, util\nfrom wsgidav.dav_error import HTTP_MEDIATYPE_NOT_SUPPORTED, HTTP_OK, DAVError\nfrom wsgidav.mw.base_mw import BaseMiddleware\nfrom wsgidav.util import get_uri_name, safe_re_encode, send_redirect_response\n\n__docformat__ = \"reStructuredText\"\n\n_logger = util.get_module_logger(__name__)\n\nASSET_SHARE = \"/:dir_browser\"\n\nDAVMOUNT_TEMPLATE = \"\"\"\n<dm:mount xmlns:dm=\"http://purl.org/NET/webdav/mount\">\n  <dm:url>{}</dm:url>\n</dm:mount>\n\"\"\".strip()\n\nMS_OFFICE_TYPE_TO_EXT_MAP = {\n    \"excel\": (\"xls\", \"xlt\", \"xlm\", \"xlsm\", \"xlsx\", \"xltm\", \"xltx\"),\n    \"powerpoint\": (\"pps\", \"ppt\", \"pptm\", \"pptx\", \"potm\", \"potx\", \"ppsm\", \"ppsx\"),\n    \"word\": (\"doc\", \"dot\", \"docm\", \"docx\", \"dotm\", \"dotx\"),\n    \"visio\": (\"vsd\", \"vsdm\", \"vsdx\", \"vstm\", \"vstx\"),\n}\nMS_OFFICE_EXT_TO_TYPE_MAP = {}\nfor t, el in MS_OFFICE_TYPE_TO_EXT_MAP.items():\n    for e in el:\n        MS_OFFICE_EXT_TO_TYPE_MAP[e] = t\nOPEN_OFFICE_EXTENSIONS = {\"odt\", \"odp\", \"odx\"}\n\n\nclass WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader, autoescape=select_autoescape())\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context\n", "code_before": "# -*- coding: utf-8 -*-\n# (c) 2009-2022 Martin Wendt and contributors; see WsgiDAV https://github.com/mar10/wsgidav\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license.php\n\"\"\"\nWSGI middleware that handles GET requests on collections to display directories.\n\"\"\"\nimport os\nimport sys\nfrom fnmatch import fnmatch\nfrom urllib.parse import unquote\n\nfrom jinja2 import Environment, FileSystemLoader\n\nfrom wsgidav import __version__, util\nfrom wsgidav.dav_error import HTTP_MEDIATYPE_NOT_SUPPORTED, HTTP_OK, DAVError\nfrom wsgidav.mw.base_mw import BaseMiddleware\nfrom wsgidav.util import get_uri_name, safe_re_encode, send_redirect_response\n\n__docformat__ = \"reStructuredText\"\n\n_logger = util.get_module_logger(__name__)\n\nASSET_SHARE = \"/:dir_browser\"\n\nDAVMOUNT_TEMPLATE = \"\"\"\n<dm:mount xmlns:dm=\"http://purl.org/NET/webdav/mount\">\n  <dm:url>{}</dm:url>\n</dm:mount>\n\"\"\".strip()\n\nMS_OFFICE_TYPE_TO_EXT_MAP = {\n    \"excel\": (\"xls\", \"xlt\", \"xlm\", \"xlsm\", \"xlsx\", \"xltm\", \"xltx\"),\n    \"powerpoint\": (\"pps\", \"ppt\", \"pptm\", \"pptx\", \"potm\", \"potx\", \"ppsm\", \"ppsx\"),\n    \"word\": (\"doc\", \"dot\", \"docm\", \"docx\", \"dotm\", \"dotx\"),\n    \"visio\": (\"vsd\", \"vsdm\", \"vsdx\", \"vstm\", \"vstx\"),\n}\nMS_OFFICE_EXT_TO_TYPE_MAP = {}\nfor t, el in MS_OFFICE_TYPE_TO_EXT_MAP.items():\n    for e in el:\n        MS_OFFICE_EXT_TO_TYPE_MAP[e] = t\nOPEN_OFFICE_EXTENSIONS = {\"odt\", \"odp\", \"odx\"}\n\n\nclass WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader)\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context\n", "patch": "@@ -10,7 +10,7 @@\n from fnmatch import fnmatch\n from urllib.parse import unquote\n \n-from jinja2 import Environment, FileSystemLoader\n+from jinja2 import Environment, FileSystemLoader, select_autoescape\n \n from wsgidav import __version__, util\n from wsgidav.dav_error import HTTP_MEDIATYPE_NOT_SUPPORTED, HTTP_OK, DAVError\n@@ -73,7 +73,7 @@ def __init__(self, wsgidav_app, next_app, config):\n \n         # Prepare a Jinja2 template\n         templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n-        templateEnv = Environment(loader=templateLoader)\n+        templateEnv = Environment(loader=templateLoader, autoescape=select_autoescape())\n         self.template = templateEnv.get_template(\"template.html\")\n \n     def is_disabled(self):", "file_path": "files/2022_11/680", "file_language": "py", "file_name": "wsgidav/dir_browser/_dir_browser.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2                     \n          Detected direct use of jinja2. If not done properly, this may bypass HTML escaping which   \n          opens up the application to cross-site scripting (XSS) vulnerabilities. Prefer using the   \n          Flask method 'render_template()' and templates with a '.html' extension in order to prevent\n          XSS.                                                                                       \n          Details: https://sg.run/RoKe                                                               \n           76\u2506 templateEnv = Environment(loader=templateLoader)"]]}, "target": 1, "function_before": [{"function": "class WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader)\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context", "target": 1, "line": "@@  -73,7 +73,7  @@ def __init__(self, wsgidav_app, next_app, config):\n \n         # Prepare a Jinja2 template\n         templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n-        templateEnv = Environment(loader=templateLoader)\n+        templateEnv = Environment(loader=templateLoader, autoescape=select_autoescape())\n         self.template = templateEnv.get_template(\"template.html\")\n \n     def is_disabled(self):"}], "function_after": [{"function": "class WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader, autoescape=select_autoescape())\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context", "target": 0}]}, {"raw_url": "https://github.com/mar10/wsgidav/raw/e9606ab0f42f4c1a6611bc3c52de299b0aba7726/wsgidav%2Fdir_browser%2Fhtdocs%2Ftemplate.html", "code": "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"generator\" content=\"WsgiDAV/{{ version }}\">\n  <title>WsgiDAV - Index of {{ display_path }} </title>\n  <link rel=\"shortcut icon\" href=\"{{ htdocs }}/favicon.ico\">\n  <link rel=\"stylesheet\" href=\"{{ htdocs }}/style.css\" />\n  <script defer src=\"{{ htdocs }}/script.js\"></script>\n  <style type=\"text/css\"> A {behavior: url(#default#AnchorClick);} </style>\n</head>\n\n<body onload=\"onLoad()\">\n\n  <h1>\n    {%- if config.icon %}\n    <img class=\"logo\" alt=\"WsgiDAV\" title=\"WsgiDAV\" src=\"{{ htdocs }}/logo.png\">\n    {% endif -%}\n    Index of {{ display_path }}\n  </h1>\n\n  {% if config.davmount_links %}\n  <p class=\"links\">\n    <a title=\"Open this folder in a registered WebDAV client.\" href=\"{{ url }}?davmount\">Mount</a>\n  </p>\n  {% endif %}\n\n  {%- if user_name and config.show_user %}\n  <p class=\"auth-user\">\n    Authenticated user: \"{{user_name}}\", realm: \"{{realm}}\", access: {{access}}.\n    {%- if is_authenticated and config.show_logout %}\n      <a title=\"Logout current user\" href=\"{{ url }}?logout\" target=\"_blank\">Logout</a>\n    {% endif -%}\n    {%- if user_roles %}\n      , roles: {{ user_roles }}\n    {% endif -%}\n  </p>\n  {% endif -%}\n\n  <hr>\n\n  <table class=\"dir-listing\" onclick=\"return onClickTable(event)\">\n\n    <colgroup>\n      <col>\n      <col>\n      <col class=\"right\">\n      <col class=\"right\">\n    </colgroup>\n\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Type</th>\n        <th>Size</th>\n        <th>Last modified</th>\n      </tr>\n    </thead>\n\n    <tbody>\n      {%- if not is_top_dir %}\n      <tr class=\"directory\">\n          <td>\n            <a href=\"..\">..</a>\n          </td>\n        <td>Directory</td>\n        <td>-</td>\n        <td></td>\n      </tr>\n      {% endif -%}\n\n      {% for row in rows %}\n      <tr class=\"{{ row.tr_class }}\">\n        <td>\n          <a class=\"{{ row.a_class }}\" href=\"{{row.href}}\" {% if row.ofe_prefix %} data-ofe=\"{{row.ofe_prefix}}\" {% endif %} >\n              {{row.display_name}}\n          </a>\n          {%- if row.href_2 %}\n            <a class=\"{{ row.a_class_2 }}\" href=\"{{row.href_2}}\" {% if row.ofe_prefix_2%} data-ofe=\"{{row.ofe_prefix_2}}\" {% endif %} >\n                {{row.display_name_2}}\n            </a>\n          {% endif -%}\n          {%- if row.add_link_html %}\n              {{row.add_link_html | safe}}\n          {% endif -%}\n        </td>\n        <td>{{ row.display_type }}</td>\n        <td>{{ row.str_size }}</td>\n        <td>{{ row.str_modified }}</td>\n      </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n\n  <hr>\n\n  {% if trailer %}\n  <p class=\"trailer\">{{ trailer | safe }}</p>\n  {% endif %}\n\n  <object id=\"winFirefoxPlugin\" type=\"application/x-sharepoint\"\n      width=\"0\" height=\"0\" style=\"visibility: hidden;\"></object>\n\n</body>\n</html>\n", "code_before": "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"generator\" content=\"WsgiDAV/{{ version }}\">\n  <title>WsgiDAV - Index of {{ display_path }} </title>\n  <link rel=\"shortcut icon\" href=\"{{ htdocs }}/favicon.ico\">\n  <link rel=\"stylesheet\" href=\"{{ htdocs }}/style.css\" />\n  <script defer src=\"{{ htdocs }}/script.js\"></script>\n  <style type=\"text/css\"> A {behavior: url(#default#AnchorClick);} </style>\n</head>\n\n<body onload=\"onLoad()\">\n\n  <h1>\n    {%- if config.icon %}\n    <img class=\"logo\" alt=\"WsgiDAV\" title=\"WsgiDAV\" src=\"{{ htdocs }}/logo.png\">\n    {% endif -%}\n    Index of {{ display_path }}\n  </h1>\n\n  {% if config.davmount_links %}\n  <p class=\"links\">\n    <a title=\"Open this folder in a registered WebDAV client.\" href=\"{{ url }}?davmount\">Mount</a>\n  </p>\n  {% endif %}\n\n  {%- if user_name and config.show_user %}\n  <p class=\"auth-user\">\n    Authenticated user: \"{{user_name}}\", realm: \"{{realm}}\", access: {{access}}.\n    {%- if is_authenticated and config.show_logout %}\n      <a title=\"Logout current user\" href=\"{{ url }}?logout\" target=\"_blank\">Logout</a>\n    {% endif -%}\n    {%- if user_roles %}\n      , roles: {{ user_roles }}\n    {% endif -%}\n  </p>\n  {% endif -%}\n\n  <hr>\n\n  <table class=\"dir-listing\" onclick=\"return onClickTable(event)\">\n\n    <colgroup>\n      <col>\n      <col>\n      <col class=\"right\">\n      <col class=\"right\">\n    </colgroup>\n\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Type</th>\n        <th>Size</th>\n        <th>Last modified</th>\n      </tr>\n    </thead>\n\n    <tbody>\n      {%- if not is_top_dir %}\n      <tr class=\"directory\">\n          <td>\n            <a href=\"..\">..</a>\n          </td>\n        <td>Directory</td>\n        <td>-</td>\n        <td></td>\n      </tr>\n      {% endif -%}\n\n      {% for row in rows %}\n      <tr class=\"{{ row.tr_class }}\">\n        <td>\n          <a class=\"{{ row.a_class }}\" href=\"{{row.href}}\" {% if row.ofe_prefix %} data-ofe=\"{{row.ofe_prefix}}\" {% endif %} >\n              {{row.display_name}}\n          </a>\n          {%- if row.href_2 %}\n            <a class=\"{{ row.a_class_2 }}\" href=\"{{row.href_2}}\" {% if row.ofe_prefix_2%} data-ofe=\"{{row.ofe_prefix_2}}\" {% endif %} >\n                {{row.display_name_2}}\n            </a>\n          {% endif -%}\n          {%- if row.add_link_html %}\n              {{row.add_link_html}}\n          {% endif -%}\n        </td>\n        <td>{{ row.display_type }}</td>\n        <td>{{ row.str_size }}</td>\n        <td>{{ row.str_modified }}</td>\n      </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n\n  <hr>\n\n  {% if trailer %}\n  <p class=\"trailer\">{{ trailer }}</p>\n  {% endif %}\n\n  <object id=\"winFirefoxPlugin\" type=\"application/x-sharepoint\"\n      width=\"0\" height=\"0\" style=\"visibility: hidden;\"></object>\n\n</body>\n</html>\n", "patch": "@@ -81,7 +81,7 @@ <h1>\n             </a>\n           {% endif -%}\n           {%- if row.add_link_html %}\n-              {{row.add_link_html}}\n+              {{row.add_link_html | safe}}\n           {% endif -%}\n         </td>\n         <td>{{ row.display_type }}</td>\n@@ -95,7 +95,7 @@ <h1>\n   <hr>\n \n   {% if trailer %}\n-  <p class=\"trailer\">{{ trailer }}</p>\n+  <p class=\"trailer\">{{ trailer | safe }}</p>\n   {% endif %}\n \n   <object id=\"winFirefoxPlugin\" type=\"application/x-sharepoint\"", "file_path": "files/2022_11/681", "file_language": "html", "file_name": "wsgidav/dir_browser/htdocs/template.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
