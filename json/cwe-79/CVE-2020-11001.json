{"index": 4542, "cve_id": "CVE-2020-11001", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "In Wagtail before versions 2.8.1 and 2.7.2, a cross-site scripting (XSS) vulnerability exists on the page revision comparison view within the Wagtail admin interface. A user with a limited-permission editor account for the Wagtail admin could potentially craft a page revision history that, when viewed by a user with higher privileges, could perform actions with that user's credentials. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.2 (for the LTS 2.7 branch) and Wagtail 2.8.1 (for the current 2.8 branch).", "cvss": "6.8", "publish_date": "April 15, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "HIGH", "I": "NONE", "A": "NONE", "commit_id": "61045ceefea114c40ac4b680af58990dbe732389", "commit_message": "Apply proper HTML escaping on StreamField block comparisons\n\nAn individual StreamField block in the comparison view may be rendered as a plain value (for blocks that are unchanged, added or deleted) or a diff (for blocks that are changed). In both cases, the output is returned as HTML, but must not contain any unescaped editor-supplied HTML.\n\nFor CharBlock, TextBlock and RawHTMLBlock, the block value is escaped so that any HTML tags in the content are shown verbatim.\n\nFor RichTextBlock and any other block types that do not override the default comparison behaviour, we take the basic (non-templated) HTML rendering of the block and extract text-only content from it. This is then returned in HTML-escaped form for the plain view, and run through diff_text().to_html() for the diff view (which handles escaping itself).", "commit_date": "2020-04-14T01:35:20Z", "project": "wagtail/wagtail", "url": "https://api.github.com/repos/wagtail/wagtail/commits/61045ceefea114c40ac4b680af58990dbe732389", "html_url": "https://github.com/wagtail/wagtail/commit/61045ceefea114c40ac4b680af58990dbe732389", "windows_before": [{"commit_id": "72e8d861b6163bb8cd0756d1eeadfbf4035a6156", "commit_date": "Mon Feb 17 00:06:38 2020 +0000", "commit_message": "Add README badges for LGTM (#5831)", "files_name": ["README.md"]}, {"commit_id": "82cafd539ab77689ecf285b1191877fbf9faef0d", "commit_date": "Wed Apr 8 12:12:52 2020 +0100", "commit_message": "Add Jacob to core team", "files_name": ["CONTRIBUTORS.rst"]}, {"commit_id": "9d4009bebbc1d9171bde1c94e444c02b3aa2286b", "commit_date": "Wed Apr 8 11:12:57 2020 +0100", "commit_message": "Changelog/release notes", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/releases/2.9.rst"]}, {"commit_id": "5afafa151c08ebc63c0d6144d827ae8e55d91637", "commit_date": "Fri Mar 20 11:00:00 2020 +0100", "commit_message": "fix invalid focal_point attribute on image edit view", "files_name": ["wagtail/images/templates/wagtailimages/images/edit.html"]}, {"commit_id": "61af7e8d2aef60acc7e82c436e1fdc2968d808df", "commit_date": "Sat Mar 28 11:11:21 2020 -0300", "commit_message": "Allow actions translation", "files_name": ["wagtail/snippets/templates/wagtailsnippets/snippets/list.html"]}, {"commit_id": "7796a0cc4421bfbb165425a790cf02413fbd50a0", "commit_date": "Tue Mar 31 15:49:25 2020 -0300", "commit_message": "Make 'All' translatable", "files_name": ["wagtail/admin/templates/wagtailadmin/pages/search_results.html"]}, {"commit_id": "f37da8f7d88701dffc6d4beb0e63270ec9470ad1", "commit_date": "Thu Nov 1 23:26:40 2018 +0000", "commit_message": "Cache image renditions (#4883)", "files_name": ["CHANGELOG.txt", "docs/advanced_topics/performance.rst", "docs/releases/2.9.rst", "wagtail/images/models.py", "wagtail/images/tests/test_models.py"]}, {"commit_id": "23af29d35cc07b0e0923cf3ec7da01fb8f51a49b", "commit_date": "Tue Apr 7 11:56:16 2020 +0100", "commit_message": "Use AdminOnlyMenuItem in both code samples in reports docs", "files_name": ["docs/advanced_topics/adding_reports.rst"]}, {"commit_id": "2b096419dcfdeff87f7fe0596a61a56c73ebf9a3", "commit_date": "Tue Apr 7 11:10:17 2020 +0100", "commit_message": "Fix typo in import in reports documentation", "files_name": ["docs/advanced_topics/adding_reports.rst"]}, {"commit_id": "1442d7ddf2bf334c25feca31a171f9ae69c99561", "commit_date": "Sun Apr 5 16:38:44 2020 +0100", "commit_message": "Revert \"Add README badges for LGTM (#5831)\"", "files_name": ["README.md"]}, {"commit_id": "9fa2ba939debd3a85c421fbe00b777dd3cb447b7", "commit_date": "Fri Apr 3 21:59:38 2020 +0100", "commit_message": "Release notes for #5932", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst"]}, {"commit_id": "db8ab0875d364a2db22d7d429e5f33289bdc7ce0", "commit_date": "Fri Apr 3 21:46:32 2020 +0100", "commit_message": "Update BaseSetting to make it easier to utilise QuerySet.select_related() for more complex settings which reference related objects (such as pages)", "files_name": ["docs/reference/contrib/settings.rst", "wagtail/contrib/settings/models.py", "wagtail/contrib/settings/tests/test_model.py", "wagtail/tests/testapp/migrations/0048_importantpages.py", "wagtail/tests/testapp/models.py"]}, {"commit_id": "e9371f45c7d7b5e3ca1b55edaa98eb0054d00e24", "commit_date": "Fri Apr 3 21:22:22 2020 +0100", "commit_message": "Release notes for #5931", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst"]}, {"commit_id": "18118f54b61f488655e9fd33e0627920489781db", "commit_date": "Fri Apr 3 16:35:23 2020 +0100", "commit_message": "Update docs", "files_name": ["docs/reference/contrib/settings.rst"]}, {"commit_id": "a574c336cf2ed25fd820f8ab1f6df838f23934e1", "commit_date": "Fri Apr 3 12:27:31 2020 +0100", "commit_message": "Preserve more of the existing context_processor behaviour, which delays the site query until necessary", "files_name": ["wagtail/contrib/settings/context_processors.py"]}, {"commit_id": "458b514194b76d534fcc3bb71163710019d7cb6b", "commit_date": "Fri Apr 3 12:12:36 2020 +0100", "commit_message": "Add tests for new model methods, and refactor test_templates to utilise a new base class (with slightly more descriptive attribute names)", "files_name": ["wagtail/contrib/settings/tests/base.py", "wagtail/contrib/settings/tests/test_model.py", "wagtail/contrib/settings/tests/test_templates.py"]}, {"commit_id": "b023a3839045643d9a09d3250ee6f0fda6d24759", "commit_date": "Thu Apr 2 15:58:39 2020 +0100", "commit_message": "Update get_settings tag to initialise a SettingsProxy using the request (if available)", "files_name": ["wagtail/contrib/settings/context_processors.py", "wagtail/contrib/settings/templatetags/wagtailsettings_tags.py"]}, {"commit_id": "255ad1f2a187668efdfa8c43cc69b53ac91635f4", "commit_date": "Fri Feb 14 10:34:12 2020 +0000", "commit_message": "Add BaseSetting.for_request() to facilitate efficient repeat access of settings when accessed before rendering", "files_name": ["wagtail/contrib/settings/context_processors.py", "wagtail/contrib/settings/models.py"]}, {"commit_id": "3797132b4d943ba09ae104cb46923b509322c3a3", "commit_date": "Thu Apr 2 09:24:24 2020 -0400", "commit_message": "Allow ListBlocks to leverage child bulk_to_python", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/core/blocks/list_block.py", "wagtail/core/tests/test_blocks.py"]}, {"commit_id": "bb2e460c0b92fba802fc3f369730004d6b648e64", "commit_date": "Tue Mar 24 19:52:40 2020 +0300", "commit_message": "Replace deprecated ugettext, ungettext with gettext and ngettext. (#5907)", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/advanced_topics/customisation/custom_user_models.rst", "docs/reference/hooks.rst", "docs/releases/2.9.rst", "wagtail/admin/action_menu.py", "wagtail/admin/apps.py", "wagtail/admin/auth.py", "wagtail/admin/compare.py", "wagtail/admin/edit_handlers.py", "wagtail/admin/forms/auth.py", "wagtail/admin/forms/choosers.py", "wagtail/admin/forms/collections.py", "wagtail/admin/forms/pages.py", "wagtail/admin/forms/search.py", "wagtail/admin/forms/view_restrictions.py", "wagtail/admin/localization.py", "wagtail/admin/templatetags/wagtailadmin_tags.py", "wagtail/admin/tests/tests.py", "wagtail/admin/views/account.py", "wagtail/admin/views/collections.py", "wagtail/admin/views/generic.py", "wagtail/admin/views/mixins.py", "wagtail/admin/views/pages.py", "wagtail/admin/views/reports.py", "wagtail/admin/wagtail_hooks.py", "wagtail/admin/widgets.py", "wagtail/api/v2/apps.py", "wagtail/contrib/forms/apps.py", "wagtail/contrib/forms/edit_handlers.py", "wagtail/contrib/forms/forms.py", "wagtail/contrib/forms/models.py", "wagtail/contrib/forms/views.py", "wagtail/contrib/forms/wagtail_hooks.py", "wagtail/contrib/frontend_cache/apps.py", "wagtail/contrib/modeladmin/apps.py", "wagtail/contrib/modeladmin/forms.py", "wagtail/contrib/modeladmin/helpers/button.py", "wagtail/contrib/modeladmin/mixins.py", "wagtail/contrib/modeladmin/templatetags/modeladmin_tags.py", "wagtail/contrib/modeladmin/views.py", "wagtail/contrib/postgres_search/models.py", "wagtail/contrib/redirects/apps.py", "wagtail/contrib/redirects/forms.py", "wagtail/contrib/redirects/models.py", "wagtail/contrib/redirects/views.py", "wagtail/contrib/redirects/wagtail_hooks.py", "wagtail/contrib/routable_page/apps.py", "wagtail/contrib/search_promotions/apps.py", "wagtail/contrib/search_promotions/forms.py", "wagtail/contrib/search_promotions/models.py", "wagtail/contrib/search_promotions/views.py", "wagtail/contrib/search_promotions/wagtail_hooks.py", "wagtail/contrib/settings/views.py", "wagtail/contrib/sitemaps/apps.py", "wagtail/contrib/styleguide/apps.py", "wagtail/contrib/styleguide/views.py", "wagtail/contrib/styleguide/wagtail_hooks.py", "wagtail/contrib/table_block/apps.py", "wagtail/core/apps.py", "wagtail/core/blocks/static_block.py", "wagtail/core/blocks/stream_block.py", "wagtail/core/forms.py", "wagtail/core/models.py", "wagtail/core/tests/test_blocks.py", "wagtail/documents/forms.py", "wagtail/documents/models.py", "wagtail/documents/views/chooser.py", "wagtail/documents/views/documents.py", "wagtail/documents/wagtail_hooks.py", "wagtail/documents/widgets.py", "wagtail/embeds/apps.py", "wagtail/embeds/blocks.py", "wagtail/embeds/forms.py", "wagtail/embeds/models.py", "wagtail/embeds/views/chooser.py", "wagtail/embeds/wagtail_hooks.py", "wagtail/images/fields.py", "wagtail/images/formats.py", "wagtail/images/forms.py", "wagtail/images/models.py", "wagtail/images/views/chooser.py", "wagtail/images/views/images.py", "wagtail/images/wagtail_hooks.py", "wagtail/images/widgets.py", "wagtail/search/apps.py", "wagtail/search/forms.py", "wagtail/search/models.py", "wagtail/sites/apps.py", "wagtail/sites/forms.py", "wagtail/sites/views.py", "wagtail/sites/wagtail_hooks.py", "wagtail/snippets/views/chooser.py", "wagtail/snippets/views/snippets.py", "wagtail/snippets/wagtail_hooks.py", "wagtail/snippets/widgets.py", "wagtail/tests/modeladmintest/apps.py", "wagtail/tests/routablepage/apps.py", "wagtail/tests/search/apps.py", "wagtail/tests/snippets/apps.py", "wagtail/tests/testapp/apps.py", "wagtail/users/apps.py", "wagtail/users/forms.py", "wagtail/users/models.py", "wagtail/users/views/groups.py", "wagtail/users/views/users.py", "wagtail/users/wagtail_hooks.py"]}, {"commit_id": "8c1a234f139cdd77dd20cce9ee087ec309709851", "commit_date": "Wed Mar 25 14:23:48 2020 +0000", "commit_message": "Remove our outdated preferences for deployment", "files_name": ["docs/advanced_topics/deploying.rst"]}, {"commit_id": "36e777418f308fd6aa359e1c953afcf4ab041571", "commit_date": "Mon Mar 2 23:18:46 2020 -0300", "commit_message": "Fix: Hide empty 'view live' links", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/releases/2.9.rst", "wagtail/admin/templates/wagtailadmin/home/locked_pages.html", "wagtail/admin/templates/wagtailadmin/home/recent_edits.html", "wagtail/admin/templates/wagtailadmin/shared/page_status_tag.html"]}, {"commit_id": "3f86de27e0bf7e5e01031d9614e3a0a866232d03", "commit_date": "Thu Mar 19 17:57:52 2020 +0000", "commit_message": "Document AdminOnlyMenuItem in hooks documentation", "files_name": ["docs/reference/hooks.rst"]}, {"commit_id": "205249b3174249e811a37a2391e13725981a44da", "commit_date": "Thu Mar 19 17:49:33 2020 +0000", "commit_message": "Release note for #5884", "files_name": []}], "windows_after": [{"commit_id": "b5aef748019f42fe8e596434f5a6014cc3bf7283", "commit_date": "Fri Apr 3 14:10:47 2020 +0100", "commit_message": "Apply proper HTML escaping on StreamField block comparisons", "files_name": ["wagtail/admin/compare.py", "wagtail/admin/tests/test_compare.py", "wagtail/tests/testapp/migrations/0048_rawhtmlblock.py", "wagtail/tests/testapp/models.py"]}, {"commit_id": "2223d6b23258ce1d790c85b71216f17c9f28cbd6", "commit_date": "Mon Apr 6 13:24:41 2020 +0100", "commit_message": "Don't mark the translatable string 'None' as safe", "files_name": ["wagtail/admin/compare.py"]}, {"commit_id": "1d043914b435301102cefaa122f453f0498f958a", "commit_date": "Tue Apr 14 01:53:38 2020 +0100", "commit_message": "Release notes for 2.7.2", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/releases/2.7.2.rst", "docs/releases/index.rst"]}, {"commit_id": "deb1213148ff7bbeb444ed4a6246e7766933eeb1", "commit_date": "Tue Apr 14 02:04:16 2020 +0100", "commit_message": "Release notes for 2.8.1", "files_name": ["CHANGELOG.txt", "docs/releases/2.8.1.rst", "docs/releases/index.rst"]}, {"commit_id": "b7af1f48da397314113109d662ab4b43ad3c409d", "commit_date": "Tue Apr 14 10:15:56 2020 +0100", "commit_message": "Fix migration numbering in test app", "files_name": ["wagtail/tests/testapp/migrations/0049_rawhtmlblock.py"]}, {"commit_id": "7ee943a9c08813a70ae73b652ede71f9b127a697", "commit_date": "Thu Mar 12 17:30:25 2020 +0000", "commit_message": "Fix circular import", "files_name": ["wagtail/contrib/forms/models.py", "wagtail/tests/testapp/models.py"]}, {"commit_id": "a1b09f65c97a8e0dd5ccf65e1ce8e52f9bc0ad19", "commit_date": "Thu Mar 19 11:55:59 2020 +0000", "commit_message": "Rename export_heading_overrides to export_headings", "files_name": ["docs/advanced_topics/adding_reports.rst", "wagtail/admin/views/reports.py", "wagtail/contrib/forms/views.py", "wagtail/contrib/modeladmin/views.py"]}, {"commit_id": "1e4a3317662a903cd0ec1d418c7a62ee32e2b3e0", "commit_date": "Thu Mar 19 10:55:51 2020 +0000", "commit_message": "Split out base report template into an empty base and a page-specific one", "files_name": ["docs/advanced_topics/adding_reports.rst", "wagtail/admin/templates/wagtailadmin/reports/base_page_report.html", "wagtail/admin/templates/wagtailadmin/reports/base_report.html", "wagtail/admin/templates/wagtailadmin/reports/locked_pages.html"]}, {"commit_id": "abb6634d92848acbc3320ae1c0d47861d2cf3dd2", "commit_date": "Tue Apr 14 18:58:34 2020 +0100", "commit_message": "Move default export_heading_overrides / list_export config to PageReportView", "files_name": ["docs/advanced_topics/adding_reports.rst", "wagtail/admin/views/reports.py"]}, {"commit_id": "297f6638611e441b0b589c07ee5b5220290efd0f", "commit_date": "Tue Apr 14 19:00:48 2020 +0100", "commit_message": "Rename _list_report.html to _list_page_report.html", "files_name": ["docs/advanced_topics/adding_reports.rst", "wagtail/admin/templates/wagtailadmin/reports/base_page_report.html", "wagtail/admin/templates/wagtailadmin/reports/listing/_list_page_report.html", "wagtail/admin/templates/wagtailadmin/reports/listing/_list_unlock.html"]}, {"commit_id": "0017216a02b32e38b37e7dd4f18d914f423804cb", "commit_date": "Thu Mar 19 11:54:54 2020 +0000", "commit_message": "Use queryset.model to get the queryset model class", "files_name": ["wagtail/admin/views/reports.py"]}, {"commit_id": "555adccc2a6ff22db63f5d943a2ded48688936cf", "commit_date": "Tue Apr 7 10:20:23 2020 +0100", "commit_message": "Set TreeQueryset.delete.queryset_only = True (#5938)", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/core/query.py", "wagtail/core/tests/test_page_queryset.py"]}, {"commit_id": "a69559174f24165d66b68e4d61e48b0b6eb33fba", "commit_date": "Sat Apr 18 10:39:47 2020 +1000", "commit_message": "Add tutorials Q1 2020", "files_name": ["docs/advanced_topics/third_party_tutorials.rst"]}, {"commit_id": "ce815a5f0007fe9be77c20f569e0e28273046342", "commit_date": "Sun Mar 17 17:05:57 2019 +1000", "commit_message": "page.copy to use `exclude_fields_in_copy` child & parental m2m relations", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/core/models.py", "wagtail/core/tests/test_page_model.py"]}, {"commit_id": "2dbd0a49f9e73ea4d39c5c9abc1b73207a79f3c9", "commit_date": "Tue Apr 30 16:08:13 2019 +0100", "commit_message": "Fix document serve response filename when non-ascii characters used", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/documents/tests/test_views.py", "wagtail/documents/views/serve.py"]}, {"commit_id": "d0a0c804c25459bbf2161c5c53f10c37ba5b6b77", "commit_date": "Fri Jan 24 11:44:54 2020 +0000", "commit_message": "Remove inappropriate banner landmarks & adopt main element in admin  404", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/admin/templates/wagtailadmin/404.html", "wagtail/admin/templates/wagtailadmin/home.html", "wagtail/admin/templates/wagtailadmin/pages/create.html", "wagtail/admin/templates/wagtailadmin/pages/edit.html", "wagtail/admin/templates/wagtailadmin/pages/index.html", "wagtail/admin/templates/wagtailadmin/pages/move_choose_destination.html", "wagtail/admin/templates/wagtailadmin/pages/preview_error.html", "wagtail/admin/templates/wagtailadmin/shared/header.html", "wagtail/contrib/forms/templates/wagtailforms/index_submissions.html", "wagtail/contrib/modeladmin/templates/modeladmin/create.html", "wagtail/contrib/modeladmin/templates/modeladmin/index.html", "wagtail/contrib/modeladmin/templates/modeladmin/inspect.html", "wagtail/contrib/settings/templates/wagtailsettings/edit.html", "wagtail/contrib/styleguide/templates/wagtailstyleguide/base.html", "wagtail/project_template/home/templates/home/welcome_page.html", "wagtail/snippets/templates/wagtailsnippets/snippets/create.html", "wagtail/snippets/templates/wagtailsnippets/snippets/edit.html", "wagtail/snippets/templates/wagtailsnippets/snippets/type_index.html"]}, {"commit_id": "ef0c8f344684614d27d2f4e5cc8ba35794395e07", "commit_date": "Wed Apr 15 15:34:52 2020 +0100", "commit_message": "Add documentation for reporting security issues", "files_name": ["CHANGELOG.txt", "docs/contributing/index.rst", "docs/contributing/security.rst", "docs/releases/2.9.rst", "docs/support.rst"]}, {"commit_id": "4023a90d6e0b2876c560f0318c1cf6aea544e354", "commit_date": "Fri Apr 26 17:19:04 2019 +0100", "commit_message": "Allow custom image model to have fields defined as required", "files_name": ["CHANGELOG.txt", "docs/advanced_topics/images/custom_image_model.rst", "docs/releases/2.9.rst", "wagtail/images/admin_urls.py", "wagtail/images/migrations/0022_uploadedimage.py", "wagtail/images/models.py", "wagtail/images/templates/wagtailimages/multiple/edit_form.html", "wagtail/images/tests/test_admin_views.py", "wagtail/images/views/multiple.py", "wagtail/tests/testapp/migrations/0050_customimagewithauthor_customrenditionwithauthor.py", "wagtail/tests/testapp/models.py"]}, {"commit_id": "2b4103728b425ccad03a67b8239d4a5cc68761f8", "commit_date": "Wed Apr 1 17:12:31 2020 -0400", "commit_message": "Move and rename nav variables", "files_name": ["client/scss/components/_main-nav.scss", "client/scss/settings/_variables.scss"]}, {"commit_id": "7cca89f67c2da3b9518d2d2acfe54a7796b81df7", "commit_date": "Wed Apr 1 17:46:42 2020 -0400", "commit_message": "Make only the list part of the nav submenu scroll", "files_name": ["client/scss/components/_main-nav.scss", "wagtail/admin/templates/wagtailadmin/shared/menu_settings_menu_item.html", "wagtail/admin/templates/wagtailadmin/shared/menu_submenu_item.html"]}, {"commit_id": "4a0d202fc771d11ca5827539352ad357d91c9d46", "commit_date": "Mon Apr 20 11:56:09 2020 +0100", "commit_message": "Release note for #5927", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst"]}, {"commit_id": "58b11833c8f84c7ae9bd4291f9d8cd389f241371", "commit_date": "Wed Apr 15 16:21:15 2020 +0100", "commit_message": "Add placeholder docs for internationalisation", "files_name": ["CHANGELOG.txt", "docs/advanced_topics/i18n.rst", "docs/advanced_topics/index.rst", "docs/releases/2.9.rst"]}, {"commit_id": "df8e51a6e9c391d2b8294bb3db71bc5d194a5d4d", "commit_date": "Wed Mar 25 15:02:03 2020 +0000", "commit_message": "Fix user preferred language override not working with TemplateResponses by decorating TemplateResponse render method (#5910)", "files_name": ["CHANGELOG.txt", "docs/releases/2.9.rst", "wagtail/admin/auth.py"]}, {"commit_id": "1f2b6fb449781fba0bcd313cca0158812a9bb1e6", "commit_date": "Sat Dec 7 12:45:32 2019 +0000", "commit_message": "Consistently return TemplateResponse from views instead of using the render() shortcut (#5731)", "files_name": ["wagtail/admin/views/account.py", "wagtail/admin/views/chooser.py", "wagtail/admin/views/home.py", "wagtail/admin/views/pages.py", "wagtail/admin/views/userbar.py", "wagtail/contrib/forms/models.py", "wagtail/contrib/redirects/views.py", "wagtail/contrib/search_promotions/views.py", "wagtail/contrib/settings/views.py", "wagtail/contrib/styleguide/views.py", "wagtail/documents/views/chooser.py", "wagtail/documents/views/documents.py", "wagtail/documents/views/multiple.py", "wagtail/images/views/chooser.py", "wagtail/images/views/images.py", "wagtail/images/views/multiple.py", "wagtail/project_template/search/views.py", "wagtail/search/views/queries.py", "wagtail/snippets/views/chooser.py", "wagtail/snippets/views/snippets.py", "wagtail/tests/testapp/models.py", "wagtail/users/views/users.py"]}, {"commit_id": "78e3c5964dc2172c0254258809a573121c206c27", "commit_date": "Mon Apr 20 12:19:43 2020 +1000", "commit_message": "Docs & readme - remove references to now closed developers forum", "files_name": ["README.md", "docs/contributing/developing.rst"]}, {"commit_id": "f06270345f95550fbf425173dc57cc3a8718fbb5", "commit_date": "Tue Apr 21 13:56:55 2020 +0100", "commit_message": "Fix incorrect language code for Japanese in language choice dropdown", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "docs/releases/2.9.rst", "wagtail/admin/localization.py"]}, {"commit_id": "d2a9dcd42a11760e7cf70c478a0de849b1f6917a", "commit_date": "Tue Apr 21 14:21:43 2020 +0100", "commit_message": "Fetch new translations from Transifex", "files_name": ["wagtail/admin/locale/ar/LC_MESSAGES/django.mo", "wagtail/admin/locale/ar/LC_MESSAGES/django.po", "wagtail/admin/locale/be/LC_MESSAGES/django.mo", "wagtail/admin/locale/be/LC_MESSAGES/django.po", "wagtail/admin/locale/cs/LC_MESSAGES/django.mo", "wagtail/admin/locale/cs/LC_MESSAGES/django.po", "wagtail/admin/locale/es/LC_MESSAGES/django.mo", "wagtail/admin/locale/es/LC_MESSAGES/django.po", "wagtail/admin/locale/fi/LC_MESSAGES/django.mo", "wagtail/admin/locale/fi/LC_MESSAGES/django.po", "wagtail/admin/locale/hr_HR/LC_MESSAGES/django.mo", "wagtail/admin/locale/hr_HR/LC_MESSAGES/django.po", "wagtail/admin/locale/hu/LC_MESSAGES/django.mo", "wagtail/admin/locale/hu/LC_MESSAGES/django.po", "wagtail/admin/locale/it/LC_MESSAGES/django.mo", "wagtail/admin/locale/it/LC_MESSAGES/django.po", "wagtail/admin/locale/pl/LC_MESSAGES/django.mo", "wagtail/admin/locale/pl/LC_MESSAGES/django.po", "wagtail/admin/locale/pt_BR/LC_MESSAGES/django.mo", "wagtail/admin/locale/pt_BR/LC_MESSAGES/django.po", "wagtail/admin/locale/ru/LC_MESSAGES/django.mo", "wagtail/admin/locale/ru/LC_MESSAGES/django.po", "wagtail/admin/locale/sv/LC_MESSAGES/django.mo", "wagtail/admin/locale/sv/LC_MESSAGES/django.po", "wagtail/admin/locale/tr/LC_MESSAGES/django.mo", "wagtail/admin/locale/tr/LC_MESSAGES/django.po"]}], "parents": [{"commit_id_before": "081705fc7a2d9aec75da25a3593b490f3c145d2b", "url_before": "https://api.github.com/repos/wagtail/wagtail/commits/081705fc7a2d9aec75da25a3593b490f3c145d2b", "html_url_before": "https://github.com/wagtail/wagtail/commit/081705fc7a2d9aec75da25a3593b490f3c145d2b"}], "details": [{"raw_url": "https://github.com/wagtail/wagtail/raw/61045ceefea114c40ac4b680af58990dbe732389/wagtail%2Fadmin%2Fcompare.py", "code": "import difflib\n\nfrom bs4 import BeautifulSoup\nfrom django.utils.encoding import force_str\nfrom django.utils.html import escape, format_html, format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom wagtail.core import blocks\n\n\ndef text_from_html(val):\n    # Return the unescaped text content of an HTML string\n    return BeautifulSoup(force_str(val), 'html5lib').getText()\n\n\nclass FieldComparison:\n    is_field = True\n    is_child_relation = False\n\n    def __init__(self, field, obj_a, obj_b):\n        self.field = field\n        self.val_a = field.value_from_object(obj_a)\n        self.val_b = field.value_from_object(obj_b)\n\n    def field_label(self):\n        \"\"\"\n        Returns a label for this field to be displayed to the user\n        \"\"\"\n        verbose_name = getattr(self.field, 'verbose_name', None)\n\n        if verbose_name is None:\n            # Relations don't have a verbose_name\n            verbose_name = self.field.name.replace('_', ' ')\n\n        return capfirst(verbose_name)\n\n    def htmldiff(self):\n        if self.val_a != self.val_b:\n            return TextDiff([('deletion', self.val_a), ('addition', self.val_b)]).to_html()\n        else:\n            return escape(self.val_a)\n\n    def has_changed(self):\n        \"\"\"\n        Returns True if the field has changed\n        \"\"\"\n        return self.val_a != self.val_b\n\n\nclass TextFieldComparison(FieldComparison):\n    def htmldiff(self):\n        return diff_text(self.val_a, self.val_b).to_html()\n\n\nclass RichTextFieldComparison(TextFieldComparison):\n    def htmldiff(self):\n        return diff_text(\n            text_from_html(self.val_a),\n            text_from_html(self.val_b)\n        ).to_html()\n\n\ndef get_comparison_class_for_block(block):\n    if hasattr(block, 'get_comparison_class'):\n        return block.get_comparison_class()\n    elif isinstance(block, (blocks.CharBlock, blocks.TextBlock)):\n        return CharBlockComparison\n    elif isinstance(block, blocks.RawHTMLBlock):\n        # Compare raw HTML blocks as if they were plain text, so that tags are shown explicitly\n        return CharBlockComparison\n    elif isinstance(block, blocks.RichTextBlock):\n        return RichTextBlockComparison\n    elif isinstance(block, blocks.StructBlock):\n        return StructBlockComparison\n    else:\n        # As all stream field blocks have a HTML representation, fall back to diffing that.\n        return RichTextBlockComparison\n\n\nclass BlockComparison:\n    def __init__(self, block, exists_a, exists_b, val_a, val_b):\n        self.block = block\n        self.exists_a = exists_a\n        self.exists_b = exists_b\n        self.val_a = val_a\n        self.val_b = val_b\n\n    def is_new(self):\n        return self.exists_b and not self.exists_a\n\n    def is_deleted(self):\n        return self.exists_a and not self.exists_b\n\n    def has_changed(self):\n        return self.val_a != self.val_b\n\n    def htmlvalue(self, val):\n        \"\"\"\n        Return an HTML representation of this block that is safe to be included\n        in comparison views\n        \"\"\"\n        return escape(text_from_html(self.block.render_basic(val)))\n\n    def htmldiff(self):\n        html_val_a = self.block.render_basic(self.val_a)\n        html_val_b = self.block.render_basic(self.val_b)\n        return diff_text(\n            text_from_html(html_val_a),\n            text_from_html(html_val_b)\n        ).to_html()\n\n\nclass CharBlockComparison(BlockComparison):\n    def htmldiff(self):\n        return diff_text(\n            force_str(self.val_a),\n            force_str(self.val_b)\n        ).to_html()\n\n    def htmlvalue(self, val):\n        return escape(val)\n\n\nclass RichTextBlockComparison(BlockComparison):\n    pass\n\n\nclass StructBlockComparison(BlockComparison):\n    def htmlvalue(self, val):\n        htmlvalues = []\n        for name, block in self.block.child_blocks.items():\n            label = self.block.child_blocks[name].label\n            comparison_class = get_comparison_class_for_block(block)\n\n            htmlvalues.append((label, comparison_class(block, True, True, val[name], val[name]).htmlvalue(val[name])))\n\n        return format_html('<dl>\\n{}\\n</dl>', format_html_join(\n            '\\n', '    <dt>{}</dt>\\n    <dd>{}</dd>', htmlvalues))\n\n    def htmldiff(self):\n        htmldiffs = []\n        for name, block in self.block.child_blocks.items():\n            label = self.block.child_blocks[name].label\n            comparison_class = get_comparison_class_for_block(block)\n\n            htmldiffs.append((label, comparison_class(block, self.exists_a, self.exists_b, self.val_a[name], self.val_b[name]).htmldiff()))\n\n        return format_html('<dl>\\n{}\\n</dl>', format_html_join(\n            '\\n', '    <dt>{}</dt>\\n    <dd>{}</dd>', htmldiffs))\n\n\nclass StreamBlockComparison(BlockComparison):\n    def get_block_comparisons(self):\n        a_blocks = list(self.val_a) or []\n        b_blocks = list(self.val_b) or []\n\n        a_blocks_by_id = {block.id: block for block in a_blocks}\n        b_blocks_by_id = {block.id: block for block in b_blocks}\n\n        deleted_ids = a_blocks_by_id.keys() - b_blocks_by_id.keys()\n\n        comparisons = []\n        for block in b_blocks:\n            comparison_class = get_comparison_class_for_block(block.block)\n\n            if block.id in a_blocks_by_id:\n                # Changed/existing block\n                comparisons.append(comparison_class(block.block, True, True, a_blocks_by_id[block.id].value, block.value))\n            else:\n                # New block\n                comparisons.append(comparison_class(block.block, False, True, None, block.value))\n\n        # Insert deleted blocks at the index where they used to be\n        deleted_block_indices = [(block, i) for i, block in enumerate(a_blocks) if block.id in deleted_ids]\n\n        for block, index in deleted_block_indices:\n            comparison_class = get_comparison_class_for_block(block.block)\n            comparison_to_insert = comparison_class(block.block, True, False, block.value, None)\n\n            # Insert the block back in where it was before it was deleted.\n            # Note: we need to account for new blocks when finding the position.\n            current_index = 0\n            block_inserted = False\n            for i, comparison in enumerate(comparisons):\n                if comparison.is_new():\n                    continue\n\n                if current_index == index:\n                    comparisons.insert(i, comparison_to_insert)\n                    block_inserted = True\n                    break\n\n                current_index += 1\n\n            # Deleted block was from the end\n            if not block_inserted:\n                comparisons.append(comparison_to_insert)\n\n        return comparisons\n\n    def htmldiff(self):\n        comparisons_html = []\n\n        for comparison in self.get_block_comparisons():\n            classes = ['comparison__child-object']\n            if comparison.is_new():\n                classes.append('addition')\n                block_rendered = comparison.htmlvalue(comparison.val_b)\n            elif comparison.is_deleted():\n                classes.append('deletion')\n                block_rendered = comparison.htmlvalue(comparison.val_a)\n            elif comparison.has_changed():\n                block_rendered = comparison.htmldiff()\n            else:\n                block_rendered = comparison.htmlvalue(comparison.val_a)\n\n            classes = ' '.join(classes)\n            comparisons_html.append('<div class=\"{0}\">{1}</div>'.format(classes, block_rendered))\n\n        return mark_safe('\\n'.join(comparisons_html))\n\n\nclass StreamFieldComparison(FieldComparison):\n    def has_block_ids(self, val):\n        if not val:\n            return True\n\n        return bool(val[0].id)\n\n    def htmldiff(self):\n        # Our method for diffing streamfields relies on the blocks in both revisions having UUIDs.\n        # But as UUIDs were added in Wagtail 1.11 we can't compare revisions that were created before\n        # that Wagtail version.\n        if self.has_block_ids(self.val_a) and self.has_block_ids(self.val_b):\n            return StreamBlockComparison(self.field.stream_block, True, True, self.val_a, self.val_b).htmldiff()\n        else:\n            # Fall back to diffing the HTML representation\n            return diff_text(\n                text_from_html(self.val_a),\n                text_from_html(self.val_b)\n            ).to_html()\n\n\nclass ChoiceFieldComparison(FieldComparison):\n    def htmldiff(self):\n        val_a = force_str(dict(self.field.flatchoices).get(self.val_a, self.val_a), strings_only=True)\n        val_b = force_str(dict(self.field.flatchoices).get(self.val_b, self.val_b), strings_only=True)\n\n        if self.val_a != self.val_b:\n            diffs = []\n\n            if val_a:\n                diffs += [('deletion', val_a)]\n            if val_b:\n                diffs += [('addition', val_b)]\n\n            return TextDiff(diffs).to_html()\n        else:\n            return escape(val_a)\n\n\nclass M2MFieldComparison(FieldComparison):\n    def get_items(self):\n        return list(self.val_a), list(self.val_b)\n\n    def get_item_display(self, item):\n        return str(item)\n\n    def htmldiff(self):\n        # Get tags\n        items_a, items_b = self.get_items()\n\n        # Calculate changes\n        sm = difflib.SequenceMatcher(0, items_a, items_b)\n        changes = []\n        for op, i1, i2, j1, j2 in sm.get_opcodes():\n            if op == 'replace':\n                for item in items_a[i1:i2]:\n                    changes.append(('deletion', self.get_item_display(item)))\n                for item in items_b[j1:j2]:\n                    changes.append(('addition', self.get_item_display(item)))\n            elif op == 'delete':\n                for item in items_a[i1:i2]:\n                    changes.append(('deletion', self.get_item_display(item)))\n            elif op == 'insert':\n                for item in items_b[j1:j2]:\n                    changes.append(('addition', self.get_item_display(item)))\n            elif op == 'equal':\n                for item in items_a[i1:i2]:\n                    changes.append(('equal', self.get_item_display(item)))\n\n        # Convert changelist to HTML\n        return TextDiff(changes, separator=\", \").to_html()\n\n    def has_changed(self):\n        items_a, items_b = self.get_items()\n        return items_a != items_b\n\n\nclass TagsFieldComparison(M2MFieldComparison):\n    def get_item_display(self, tag):\n        return tag.slug\n\n\nclass ForeignObjectComparison(FieldComparison):\n    def get_objects(self):\n        model = self.field.related_model\n        obj_a = model.objects.filter(pk=self.val_a).first()\n        obj_b = model.objects.filter(pk=self.val_b).first()\n        return obj_a, obj_b\n\n    def htmldiff(self):\n        obj_a, obj_b = self.get_objects()\n\n        if obj_a != obj_b:\n            if obj_a and obj_b:\n                # Changed\n                return TextDiff([('deletion', force_str(obj_a)), ('addition', force_str(obj_b))]).to_html()\n            elif obj_b:\n                # Added\n                return TextDiff([('addition', force_str(obj_b))]).to_html()\n            elif obj_a:\n                # Removed\n                return TextDiff([('deletion', force_str(obj_a))]).to_html()\n        else:\n            if obj_a:\n                return escape(force_str(obj_a))\n            else:\n                return mark_safe(_(\"None\"))\n\n\nclass ChildRelationComparison:\n    is_field = False\n    is_child_relation = True\n\n    def __init__(self, field, field_comparisons, obj_a, obj_b):\n        self.field = field\n        self.field_comparisons = field_comparisons\n        self.val_a = getattr(obj_a, field.related_name)\n        self.val_b = getattr(obj_b, field.related_name)\n\n    def field_label(self):\n        \"\"\"\n        Returns a label for this field to be displayed to the user\n        \"\"\"\n        verbose_name = getattr(self.field, 'verbose_name', None)\n\n        if verbose_name is None:\n            # Relations don't have a verbose_name\n            verbose_name = self.field.name.replace('_', ' ')\n\n        return capfirst(verbose_name)\n\n    def get_mapping(self, objs_a, objs_b):\n        \"\"\"\n        This bit of code attempts to match the objects in the A revision with\n        their counterpart in the B revision.\n\n        A match is firstly attempted by PK (where a matching ID indicates they're the same).\n        We compare remaining the objects by their field data; the objects with the fewest\n        fields changed are matched until there are no more possible matches left.\n\n        This returns 4 values:\n         - map_forwards => a mapping of object indexes from the B version to the A version\n         - map_backwards => a mapping of object indexes from the A version to the B version\n         - added => a list of indices for objects that didn't exist in the B version\n         - deleted => a list of indices for objects that didn't exist in the A version\n\n        Note the indices are 0-based array indices indicating the location of the object in either\n        the objs_a or objs_b arrays.\n\n        For example:\n\n        objs_a => A, B, C, D\n        objs_b => B, C, D, E\n\n        Will return the following:\n\n        map_forwards = {\n            1: 0,  # B (objs_a: objs_b)\n            2: 1,  # C (objs_a: objs_b)\n            3: 2,  # D (objs_a: objs_b)\n        }\n        map_backwards = {\n            0: 1,  # B (objs_b: objs_a)\n            1: 2,  # C (objs_b: objs_a)\n            2: 3,  # D (objs_b: objs_a)\n        }\n        added = [4]  # D in objs_b\n        deleted = [0]  # A in objs_a\n        \"\"\"\n        map_forwards = {}\n        map_backwards = {}\n        added = []\n        deleted = []\n\n        # Match child objects on PK (ID)\n        for a_idx, a_child in enumerate(objs_a):\n            for b_idx, b_child in enumerate(objs_b):\n                if b_idx in map_backwards:\n                    continue\n\n                if a_child.pk is not None and b_child.pk is not None and a_child.pk == b_child.pk:\n                    map_forwards[a_idx] = b_idx\n                    map_backwards[b_idx] = a_idx\n\n        # Now try to match them by data\n        matches = []\n        for a_idx, a_child in enumerate(objs_a):\n            if a_idx not in map_forwards:\n                for b_idx, b_child in enumerate(objs_b):\n                    if b_idx not in map_backwards:\n                        # If they both have a PK (ID) that is different, they can't be the same child object\n                        if a_child.pk and b_child.pk and a_child.pk != b_child.pk:\n                            continue\n\n                        comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])\n                        num_differences = comparison.get_num_differences()\n\n                        matches.append((a_idx, b_idx, num_differences))\n\n        # Objects with the least differences will be matched first. So only the best possible matches are made\n        matches.sort(key=lambda match: match[2])\n        for a_idx, b_idx, num_differences in matches:\n            # Make sure both objects were not matched previously\n            if a_idx in map_forwards or b_idx in map_backwards:\n                continue\n\n            # Match!\n            map_forwards[a_idx] = b_idx\n            map_backwards[b_idx] = a_idx\n\n        # Mark unmapped objects as added/deleted\n        for a_idx, a_child in enumerate(objs_a):\n            if a_idx not in map_forwards:\n                deleted.append(a_idx)\n\n        for b_idx, b_child in enumerate(objs_b):\n            if b_idx not in map_backwards:\n                added.append(b_idx)\n\n        return map_forwards, map_backwards, added, deleted\n\n    def get_child_comparison(self, obj_a, obj_b):\n        return ChildObjectComparison(self.field.related_model, self.field_comparisons, obj_a, obj_b)\n\n    def get_child_comparisons(self):\n        \"\"\"\n        Returns a list of ChildObjectComparison objects. Representing all child\n        objects that existed in either version.\n\n        They are returned in the order they appear in the B version with deletions\n        appended at the end.\n\n        All child objects are returned, regardless of whether they were actually changed.\n        \"\"\"\n        objs_a = list(self.val_a.all())\n        objs_b = list(self.val_b.all())\n\n        map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)\n        objs_a = dict(enumerate(objs_a))\n        objs_b = dict(enumerate(objs_b))\n\n        comparisons = []\n\n        for b_idx, b_child in objs_b.items():\n            if b_idx in added:\n                comparisons.append(self.get_child_comparison(None, b_child))\n            else:\n                comparisons.append(self.get_child_comparison(objs_a[map_backwards[b_idx]], b_child))\n\n        for a_idx, a_child in objs_a.items():\n            if a_idx in deleted:\n                comparisons.append(self.get_child_comparison(a_child, None))\n\n        return comparisons\n\n    def has_changed(self):\n        \"\"\"\n        Returns true if any changes were made to any of the child objects. This includes\n        adding, deleting and reordering.\n        \"\"\"\n        objs_a = list(self.val_a.all())\n        objs_b = list(self.val_b.all())\n\n        map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)\n\n        if added or deleted:\n            return True\n\n        for a_idx, b_idx in map_forwards.items():\n            comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])\n\n            if comparison.has_changed():\n                return True\n\n        return False\n\n\nclass ChildObjectComparison:\n    def __init__(self, model, field_comparisons, obj_a, obj_b):\n        self.model = model\n        self.field_comparisons = field_comparisons\n        self.obj_a = obj_a\n        self.obj_b = obj_b\n\n    def is_addition(self):\n        \"\"\"\n        Returns True if this child object was created since obj_a\n        \"\"\"\n        return self.obj_b and not self.obj_a\n\n    def is_deletion(self):\n        \"\"\"\n        Returns True if this child object was deleted in obj_b\n        \"\"\"\n        return self.obj_a and not self.obj_b\n\n    def get_position_change(self):\n        \"\"\"\n        Returns the change in position as an integer. Positive if the object\n        was moved down, negative if it moved up.\n\n        For example: '3' indicates the object moved down three spaces. '-1'\n        indicates the object moved up one space.\n        \"\"\"\n        if not self.is_addition() and not self.is_deletion():\n            sort_a = getattr(self.obj_a, 'sort_order', 0) or 0\n            sort_b = getattr(self.obj_b, 'sort_order', 0) or 0\n            return sort_b - sort_a\n\n    def get_field_comparisons(self):\n        \"\"\"\n        Returns a list of comparisons for all the fields in this object.\n        Fields that haven't changed are included as well.\n        \"\"\"\n        comparisons = []\n\n        if self.is_addition() or self.is_deletion():\n            # Display the fields without diff as one of the versions are missing\n            obj = self.obj_a or self.obj_b\n\n            for field_comparison in self.field_comparisons:\n                comparisons.append(field_comparison(obj, obj))\n        else:\n            for field_comparison in self.field_comparisons:\n                comparisons.append(field_comparison(self.obj_a, self.obj_b))\n\n        return comparisons\n\n    def has_changed(self):\n        for comparison in self.get_field_comparisons():\n            if comparison.has_changed():\n                return True\n\n        return False\n\n    def get_num_differences(self):\n        \"\"\"\n        Returns the number of fields that differ between the two\n        objects.\n        \"\"\"\n        num_differences = 0\n\n        for comparison in self.get_field_comparisons():\n            if comparison.has_changed():\n                num_differences += 1\n\n        return num_differences\n\n\nclass TextDiff:\n    def __init__(self, changes, separator=\"\"):\n        self.changes = changes\n        self.separator = separator\n\n    def to_html(self, tag='span', addition_class='addition', deletion_class='deletion'):\n        html = []\n\n        for change_type, value in self.changes:\n            if change_type == 'equal':\n                html.append(escape(value))\n            elif change_type == 'addition':\n                html.append('<{tag} class=\"{classname}\">{value}</{tag}>'.format(\n                    tag=tag,\n                    classname=addition_class,\n                    value=escape(value)\n                ))\n            elif change_type == 'deletion':\n                html.append('<{tag} class=\"{classname}\">{value}</{tag}>'.format(\n                    tag=tag,\n                    classname=deletion_class,\n                    value=escape(value)\n                ))\n\n        return mark_safe(self.separator.join(html))\n\n\ndef diff_text(a, b):\n    \"\"\"\n    Performs a diffing algorithm on two pieces of text. Returns\n    a string of HTML containing the content of both texts with\n    <span> tags inserted indicating where the differences are.\n    \"\"\"\n    def tokenise(text):\n        \"\"\"\n        Tokenises a string by spliting it into individual characters\n        and grouping the alphanumeric ones together.\n\n        This means that punctuation, whitespace, CJK characters, etc\n        become separate tokens and words/numbers are merged together\n        to form bigger tokens.\n\n        This makes the output of the diff easier to read as words are\n        not broken up.\n        \"\"\"\n        tokens = []\n        current_token = \"\"\n\n        for c in text or \"\":\n            if c.isalnum():\n                current_token += c\n            else:\n                if current_token:\n                    tokens.append(current_token)\n                    current_token = \"\"\n\n                tokens.append(c)\n\n        if current_token:\n            tokens.append(current_token)\n\n        return tokens\n\n    a_tok = tokenise(a)\n    b_tok = tokenise(b)\n    sm = difflib.SequenceMatcher(lambda t: len(t) <= 4, a_tok, b_tok)\n\n    changes = []\n\n    for op, i1, i2, j1, j2 in sm.get_opcodes():\n        if op == 'replace':\n            for token in a_tok[i1:i2]:\n                changes.append(('deletion', token))\n            for token in b_tok[j1:j2]:\n                changes.append(('addition', token))\n        elif op == 'delete':\n            for token in a_tok[i1:i2]:\n                changes.append(('deletion', token))\n        elif op == 'insert':\n            for token in b_tok[j1:j2]:\n                changes.append(('addition', token))\n        elif op == 'equal':\n            for token in a_tok[i1:i2]:\n                changes.append(('equal', token))\n\n    # Merge ajacent changes which have the same type. This just cleans up the HTML a bit\n    merged_changes = []\n    current_value = []\n    current_change_type = None\n    for change_type, value in changes:\n        if change_type != current_change_type:\n            if current_change_type is not None:\n                merged_changes.append((current_change_type, ''.join(current_value)))\n                current_value = []\n\n            current_change_type = change_type\n\n        current_value.append(value)\n\n    if current_value:\n        merged_changes.append((current_change_type, ''.join(current_value)))\n\n    return TextDiff(merged_changes)\n", "code_before": "import difflib\n\nfrom bs4 import BeautifulSoup\nfrom django.utils.encoding import force_str\nfrom django.utils.html import escape, format_html, format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom wagtail.core import blocks\n\n\nclass FieldComparison:\n    is_field = True\n    is_child_relation = False\n\n    def __init__(self, field, obj_a, obj_b):\n        self.field = field\n        self.val_a = field.value_from_object(obj_a)\n        self.val_b = field.value_from_object(obj_b)\n\n    def field_label(self):\n        \"\"\"\n        Returns a label for this field to be displayed to the user\n        \"\"\"\n        verbose_name = getattr(self.field, 'verbose_name', None)\n\n        if verbose_name is None:\n            # Relations don't have a verbose_name\n            verbose_name = self.field.name.replace('_', ' ')\n\n        return capfirst(verbose_name)\n\n    def htmldiff(self):\n        if self.val_a != self.val_b:\n            return TextDiff([('deletion', self.val_a), ('addition', self.val_b)]).to_html()\n        else:\n            return escape(self.val_a)\n\n    def has_changed(self):\n        \"\"\"\n        Returns True if the field has changed\n        \"\"\"\n        return self.val_a != self.val_b\n\n\nclass TextFieldComparison(FieldComparison):\n    def htmldiff(self):\n        return diff_text(self.val_a, self.val_b).to_html()\n\n\nclass RichTextFieldComparison(TextFieldComparison):\n    def htmldiff(self):\n        return diff_text(\n            BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n            BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n        ).to_html()\n\n\ndef get_comparison_class_for_block(block):\n    if hasattr(block, 'get_comparison_class'):\n        return block.get_comparison_class()\n    elif isinstance(block, blocks.CharBlock):\n        return CharBlockComparison\n    elif isinstance(block, blocks.RichTextBlock):\n        return RichTextBlockComparison\n    elif isinstance(block, blocks.StructBlock):\n        return StructBlockComparison\n    else:\n        # As all stream field blocks have a HTML representation, fall back to diffing that.\n        return RichTextBlockComparison\n\n\nclass BlockComparison:\n    def __init__(self, block, exists_a, exists_b, val_a, val_b):\n        self.block = block\n        self.exists_a = exists_a\n        self.exists_b = exists_b\n        self.val_a = val_a\n        self.val_b = val_b\n\n    def is_new(self):\n        return self.exists_b and not self.exists_a\n\n    def is_deleted(self):\n        return self.exists_a and not self.exists_b\n\n    def has_changed(self):\n        return self.val_a != self.val_b\n\n    def htmlvalue(self, val):\n        return self.block.render_basic(val)\n\n\nclass CharBlockComparison(BlockComparison):\n    def htmldiff(self):\n        return diff_text(\n            force_str(self.val_a),\n            force_str(self.val_b)\n        ).to_html()\n\n\nclass RichTextBlockComparison(BlockComparison):\n    def htmldiff(self):\n        return diff_text(\n            BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n            BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n        ).to_html()\n\n\nclass StructBlockComparison(BlockComparison):\n    def htmlvalue(self, val):\n        htmlvalues = []\n        for name, block in self.block.child_blocks.items():\n            label = self.block.child_blocks[name].label\n            comparison_class = get_comparison_class_for_block(block)\n\n            htmlvalues.append((label, comparison_class(block, True, True, val[name], val[name]).htmlvalue(val[name])))\n\n        return format_html('<dl>\\n{}\\n</dl>', format_html_join(\n            '\\n', '    <dt>{}</dt>\\n    <dd>{}</dd>', htmlvalues))\n\n    def htmldiff(self):\n        htmldiffs = []\n        for name, block in self.block.child_blocks.items():\n            label = self.block.child_blocks[name].label\n            comparison_class = get_comparison_class_for_block(block)\n\n            htmldiffs.append((label, comparison_class(block, self.exists_a, self.exists_b, self.val_a[name], self.val_b[name]).htmldiff()))\n\n        return format_html('<dl>\\n{}\\n</dl>', format_html_join(\n            '\\n', '    <dt>{}</dt>\\n    <dd>{}</dd>', htmldiffs))\n\n\nclass StreamBlockComparison(BlockComparison):\n    def get_block_comparisons(self):\n        a_blocks = list(self.val_a) or []\n        b_blocks = list(self.val_b) or []\n\n        a_blocks_by_id = {block.id: block for block in a_blocks}\n        b_blocks_by_id = {block.id: block for block in b_blocks}\n\n        deleted_ids = a_blocks_by_id.keys() - b_blocks_by_id.keys()\n\n        comparisons = []\n        for block in b_blocks:\n            comparison_class = get_comparison_class_for_block(block.block)\n\n            if block.id in a_blocks_by_id:\n                # Changed/existing block\n                comparisons.append(comparison_class(block.block, True, True, a_blocks_by_id[block.id].value, block.value))\n            else:\n                # New block\n                comparisons.append(comparison_class(block.block, False, True, None, block.value))\n\n        # Insert deleted blocks at the index where they used to be\n        deleted_block_indices = [(block, i) for i, block in enumerate(a_blocks) if block.id in deleted_ids]\n\n        for block, index in deleted_block_indices:\n            comparison_class = get_comparison_class_for_block(block.block)\n            comparison_to_insert = comparison_class(block.block, True, False, block.value, None)\n\n            # Insert the block back in where it was before it was deleted.\n            # Note: we need to account for new blocks when finding the position.\n            current_index = 0\n            block_inserted = False\n            for i, comparison in enumerate(comparisons):\n                if comparison.is_new():\n                    continue\n\n                if current_index == index:\n                    comparisons.insert(i, comparison_to_insert)\n                    block_inserted = True\n                    break\n\n                current_index += 1\n\n            # Deleted block was from the end\n            if not block_inserted:\n                comparisons.append(comparison_to_insert)\n\n        return comparisons\n\n    def htmldiff(self):\n        comparisons_html = []\n\n        for comparison in self.get_block_comparisons():\n            classes = ['comparison__child-object']\n            if comparison.is_new():\n                classes.append('addition')\n                block_rendered = comparison.htmlvalue(comparison.val_b)\n            elif comparison.is_deleted():\n                classes.append('deletion')\n                block_rendered = comparison.htmlvalue(comparison.val_a)\n            elif comparison.has_changed():\n                block_rendered = comparison.htmldiff()\n            else:\n                block_rendered = comparison.htmlvalue(comparison.val_a)\n\n            classes = ' '.join(classes)\n            comparisons_html.append('<div class=\"{0}\">{1}</div>'.format(classes, block_rendered))\n\n        return mark_safe('\\n'.join(comparisons_html))\n\n\nclass StreamFieldComparison(FieldComparison):\n    def has_block_ids(self, val):\n        if not val:\n            return True\n\n        return bool(val[0].id)\n\n    def htmldiff(self):\n        # Our method for diffing streamfields relies on the blocks in both revisions having UUIDs.\n        # But as UUIDs were added in Wagtail 1.11 we can't compare revisions that were created before\n        # that Wagtail version.\n        if self.has_block_ids(self.val_a) and self.has_block_ids(self.val_b):\n            return StreamBlockComparison(self.field.stream_block, True, True, self.val_a, self.val_b).htmldiff()\n        else:\n            # Fall back to diffing the HTML representation\n            return diff_text(\n                BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n                BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n            ).to_html()\n\n\nclass ChoiceFieldComparison(FieldComparison):\n    def htmldiff(self):\n        val_a = force_str(dict(self.field.flatchoices).get(self.val_a, self.val_a), strings_only=True)\n        val_b = force_str(dict(self.field.flatchoices).get(self.val_b, self.val_b), strings_only=True)\n\n        if self.val_a != self.val_b:\n            diffs = []\n\n            if val_a:\n                diffs += [('deletion', val_a)]\n            if val_b:\n                diffs += [('addition', val_b)]\n\n            return TextDiff(diffs).to_html()\n        else:\n            return escape(val_a)\n\n\nclass M2MFieldComparison(FieldComparison):\n    def get_items(self):\n        return list(self.val_a), list(self.val_b)\n\n    def get_item_display(self, item):\n        return str(item)\n\n    def htmldiff(self):\n        # Get tags\n        items_a, items_b = self.get_items()\n\n        # Calculate changes\n        sm = difflib.SequenceMatcher(0, items_a, items_b)\n        changes = []\n        for op, i1, i2, j1, j2 in sm.get_opcodes():\n            if op == 'replace':\n                for item in items_a[i1:i2]:\n                    changes.append(('deletion', self.get_item_display(item)))\n                for item in items_b[j1:j2]:\n                    changes.append(('addition', self.get_item_display(item)))\n            elif op == 'delete':\n                for item in items_a[i1:i2]:\n                    changes.append(('deletion', self.get_item_display(item)))\n            elif op == 'insert':\n                for item in items_b[j1:j2]:\n                    changes.append(('addition', self.get_item_display(item)))\n            elif op == 'equal':\n                for item in items_a[i1:i2]:\n                    changes.append(('equal', self.get_item_display(item)))\n\n        # Convert changelist to HTML\n        return TextDiff(changes, separator=\", \").to_html()\n\n    def has_changed(self):\n        items_a, items_b = self.get_items()\n        return items_a != items_b\n\n\nclass TagsFieldComparison(M2MFieldComparison):\n    def get_item_display(self, tag):\n        return tag.slug\n\n\nclass ForeignObjectComparison(FieldComparison):\n    def get_objects(self):\n        model = self.field.related_model\n        obj_a = model.objects.filter(pk=self.val_a).first()\n        obj_b = model.objects.filter(pk=self.val_b).first()\n        return obj_a, obj_b\n\n    def htmldiff(self):\n        obj_a, obj_b = self.get_objects()\n\n        if obj_a != obj_b:\n            if obj_a and obj_b:\n                # Changed\n                return TextDiff([('deletion', force_str(obj_a)), ('addition', force_str(obj_b))]).to_html()\n            elif obj_b:\n                # Added\n                return TextDiff([('addition', force_str(obj_b))]).to_html()\n            elif obj_a:\n                # Removed\n                return TextDiff([('deletion', force_str(obj_a))]).to_html()\n        else:\n            if obj_a:\n                return escape(force_str(obj_a))\n            else:\n                return mark_safe(_(\"None\"))\n\n\nclass ChildRelationComparison:\n    is_field = False\n    is_child_relation = True\n\n    def __init__(self, field, field_comparisons, obj_a, obj_b):\n        self.field = field\n        self.field_comparisons = field_comparisons\n        self.val_a = getattr(obj_a, field.related_name)\n        self.val_b = getattr(obj_b, field.related_name)\n\n    def field_label(self):\n        \"\"\"\n        Returns a label for this field to be displayed to the user\n        \"\"\"\n        verbose_name = getattr(self.field, 'verbose_name', None)\n\n        if verbose_name is None:\n            # Relations don't have a verbose_name\n            verbose_name = self.field.name.replace('_', ' ')\n\n        return capfirst(verbose_name)\n\n    def get_mapping(self, objs_a, objs_b):\n        \"\"\"\n        This bit of code attempts to match the objects in the A revision with\n        their counterpart in the B revision.\n\n        A match is firstly attempted by PK (where a matching ID indicates they're the same).\n        We compare remaining the objects by their field data; the objects with the fewest\n        fields changed are matched until there are no more possible matches left.\n\n        This returns 4 values:\n         - map_forwards => a mapping of object indexes from the B version to the A version\n         - map_backwards => a mapping of object indexes from the A version to the B version\n         - added => a list of indices for objects that didn't exist in the B version\n         - deleted => a list of indices for objects that didn't exist in the A version\n\n        Note the indices are 0-based array indices indicating the location of the object in either\n        the objs_a or objs_b arrays.\n\n        For example:\n\n        objs_a => A, B, C, D\n        objs_b => B, C, D, E\n\n        Will return the following:\n\n        map_forwards = {\n            1: 0,  # B (objs_a: objs_b)\n            2: 1,  # C (objs_a: objs_b)\n            3: 2,  # D (objs_a: objs_b)\n        }\n        map_backwards = {\n            0: 1,  # B (objs_b: objs_a)\n            1: 2,  # C (objs_b: objs_a)\n            2: 3,  # D (objs_b: objs_a)\n        }\n        added = [4]  # D in objs_b\n        deleted = [0]  # A in objs_a\n        \"\"\"\n        map_forwards = {}\n        map_backwards = {}\n        added = []\n        deleted = []\n\n        # Match child objects on PK (ID)\n        for a_idx, a_child in enumerate(objs_a):\n            for b_idx, b_child in enumerate(objs_b):\n                if b_idx in map_backwards:\n                    continue\n\n                if a_child.pk is not None and b_child.pk is not None and a_child.pk == b_child.pk:\n                    map_forwards[a_idx] = b_idx\n                    map_backwards[b_idx] = a_idx\n\n        # Now try to match them by data\n        matches = []\n        for a_idx, a_child in enumerate(objs_a):\n            if a_idx not in map_forwards:\n                for b_idx, b_child in enumerate(objs_b):\n                    if b_idx not in map_backwards:\n                        # If they both have a PK (ID) that is different, they can't be the same child object\n                        if a_child.pk and b_child.pk and a_child.pk != b_child.pk:\n                            continue\n\n                        comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])\n                        num_differences = comparison.get_num_differences()\n\n                        matches.append((a_idx, b_idx, num_differences))\n\n        # Objects with the least differences will be matched first. So only the best possible matches are made\n        matches.sort(key=lambda match: match[2])\n        for a_idx, b_idx, num_differences in matches:\n            # Make sure both objects were not matched previously\n            if a_idx in map_forwards or b_idx in map_backwards:\n                continue\n\n            # Match!\n            map_forwards[a_idx] = b_idx\n            map_backwards[b_idx] = a_idx\n\n        # Mark unmapped objects as added/deleted\n        for a_idx, a_child in enumerate(objs_a):\n            if a_idx not in map_forwards:\n                deleted.append(a_idx)\n\n        for b_idx, b_child in enumerate(objs_b):\n            if b_idx not in map_backwards:\n                added.append(b_idx)\n\n        return map_forwards, map_backwards, added, deleted\n\n    def get_child_comparison(self, obj_a, obj_b):\n        return ChildObjectComparison(self.field.related_model, self.field_comparisons, obj_a, obj_b)\n\n    def get_child_comparisons(self):\n        \"\"\"\n        Returns a list of ChildObjectComparison objects. Representing all child\n        objects that existed in either version.\n\n        They are returned in the order they appear in the B version with deletions\n        appended at the end.\n\n        All child objects are returned, regardless of whether they were actually changed.\n        \"\"\"\n        objs_a = list(self.val_a.all())\n        objs_b = list(self.val_b.all())\n\n        map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)\n        objs_a = dict(enumerate(objs_a))\n        objs_b = dict(enumerate(objs_b))\n\n        comparisons = []\n\n        for b_idx, b_child in objs_b.items():\n            if b_idx in added:\n                comparisons.append(self.get_child_comparison(None, b_child))\n            else:\n                comparisons.append(self.get_child_comparison(objs_a[map_backwards[b_idx]], b_child))\n\n        for a_idx, a_child in objs_a.items():\n            if a_idx in deleted:\n                comparisons.append(self.get_child_comparison(a_child, None))\n\n        return comparisons\n\n    def has_changed(self):\n        \"\"\"\n        Returns true if any changes were made to any of the child objects. This includes\n        adding, deleting and reordering.\n        \"\"\"\n        objs_a = list(self.val_a.all())\n        objs_b = list(self.val_b.all())\n\n        map_forwards, map_backwards, added, deleted = self.get_mapping(objs_a, objs_b)\n\n        if added or deleted:\n            return True\n\n        for a_idx, b_idx in map_forwards.items():\n            comparison = self.get_child_comparison(objs_a[a_idx], objs_b[b_idx])\n\n            if comparison.has_changed():\n                return True\n\n        return False\n\n\nclass ChildObjectComparison:\n    def __init__(self, model, field_comparisons, obj_a, obj_b):\n        self.model = model\n        self.field_comparisons = field_comparisons\n        self.obj_a = obj_a\n        self.obj_b = obj_b\n\n    def is_addition(self):\n        \"\"\"\n        Returns True if this child object was created since obj_a\n        \"\"\"\n        return self.obj_b and not self.obj_a\n\n    def is_deletion(self):\n        \"\"\"\n        Returns True if this child object was deleted in obj_b\n        \"\"\"\n        return self.obj_a and not self.obj_b\n\n    def get_position_change(self):\n        \"\"\"\n        Returns the change in position as an integer. Positive if the object\n        was moved down, negative if it moved up.\n\n        For example: '3' indicates the object moved down three spaces. '-1'\n        indicates the object moved up one space.\n        \"\"\"\n        if not self.is_addition() and not self.is_deletion():\n            sort_a = getattr(self.obj_a, 'sort_order', 0) or 0\n            sort_b = getattr(self.obj_b, 'sort_order', 0) or 0\n            return sort_b - sort_a\n\n    def get_field_comparisons(self):\n        \"\"\"\n        Returns a list of comparisons for all the fields in this object.\n        Fields that haven't changed are included as well.\n        \"\"\"\n        comparisons = []\n\n        if self.is_addition() or self.is_deletion():\n            # Display the fields without diff as one of the versions are missing\n            obj = self.obj_a or self.obj_b\n\n            for field_comparison in self.field_comparisons:\n                comparisons.append(field_comparison(obj, obj))\n        else:\n            for field_comparison in self.field_comparisons:\n                comparisons.append(field_comparison(self.obj_a, self.obj_b))\n\n        return comparisons\n\n    def has_changed(self):\n        for comparison in self.get_field_comparisons():\n            if comparison.has_changed():\n                return True\n\n        return False\n\n    def get_num_differences(self):\n        \"\"\"\n        Returns the number of fields that differ between the two\n        objects.\n        \"\"\"\n        num_differences = 0\n\n        for comparison in self.get_field_comparisons():\n            if comparison.has_changed():\n                num_differences += 1\n\n        return num_differences\n\n\nclass TextDiff:\n    def __init__(self, changes, separator=\"\"):\n        self.changes = changes\n        self.separator = separator\n\n    def to_html(self, tag='span', addition_class='addition', deletion_class='deletion'):\n        html = []\n\n        for change_type, value in self.changes:\n            if change_type == 'equal':\n                html.append(escape(value))\n            elif change_type == 'addition':\n                html.append('<{tag} class=\"{classname}\">{value}</{tag}>'.format(\n                    tag=tag,\n                    classname=addition_class,\n                    value=escape(value)\n                ))\n            elif change_type == 'deletion':\n                html.append('<{tag} class=\"{classname}\">{value}</{tag}>'.format(\n                    tag=tag,\n                    classname=deletion_class,\n                    value=escape(value)\n                ))\n\n        return mark_safe(self.separator.join(html))\n\n\ndef diff_text(a, b):\n    \"\"\"\n    Performs a diffing algorithm on two pieces of text. Returns\n    a string of HTML containing the content of both texts with\n    <span> tags inserted indicating where the differences are.\n    \"\"\"\n    def tokenise(text):\n        \"\"\"\n        Tokenises a string by spliting it into individual characters\n        and grouping the alphanumeric ones together.\n\n        This means that punctuation, whitespace, CJK characters, etc\n        become separate tokens and words/numbers are merged together\n        to form bigger tokens.\n\n        This makes the output of the diff easier to read as words are\n        not broken up.\n        \"\"\"\n        tokens = []\n        current_token = \"\"\n\n        for c in text or \"\":\n            if c.isalnum():\n                current_token += c\n            else:\n                if current_token:\n                    tokens.append(current_token)\n                    current_token = \"\"\n\n                tokens.append(c)\n\n        if current_token:\n            tokens.append(current_token)\n\n        return tokens\n\n    a_tok = tokenise(a)\n    b_tok = tokenise(b)\n    sm = difflib.SequenceMatcher(lambda t: len(t) <= 4, a_tok, b_tok)\n\n    changes = []\n\n    for op, i1, i2, j1, j2 in sm.get_opcodes():\n        if op == 'replace':\n            for token in a_tok[i1:i2]:\n                changes.append(('deletion', token))\n            for token in b_tok[j1:j2]:\n                changes.append(('addition', token))\n        elif op == 'delete':\n            for token in a_tok[i1:i2]:\n                changes.append(('deletion', token))\n        elif op == 'insert':\n            for token in b_tok[j1:j2]:\n                changes.append(('addition', token))\n        elif op == 'equal':\n            for token in a_tok[i1:i2]:\n                changes.append(('equal', token))\n\n    # Merge ajacent changes which have the same type. This just cleans up the HTML a bit\n    merged_changes = []\n    current_value = []\n    current_change_type = None\n    for change_type, value in changes:\n        if change_type != current_change_type:\n            if current_change_type is not None:\n                merged_changes.append((current_change_type, ''.join(current_value)))\n                current_value = []\n\n            current_change_type = change_type\n\n        current_value.append(value)\n\n    if current_value:\n        merged_changes.append((current_change_type, ''.join(current_value)))\n\n    return TextDiff(merged_changes)\n", "patch": "@@ -10,6 +10,11 @@\n from wagtail.core import blocks\n \n \n+def text_from_html(val):\n+    # Return the unescaped text content of an HTML string\n+    return BeautifulSoup(force_str(val), 'html5lib').getText()\n+\n+\n class FieldComparison:\n     is_field = True\n     is_child_relation = False\n@@ -52,15 +57,18 @@ def htmldiff(self):\n class RichTextFieldComparison(TextFieldComparison):\n     def htmldiff(self):\n         return diff_text(\n-            BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n-            BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n+            text_from_html(self.val_a),\n+            text_from_html(self.val_b)\n         ).to_html()\n \n \n def get_comparison_class_for_block(block):\n     if hasattr(block, 'get_comparison_class'):\n         return block.get_comparison_class()\n-    elif isinstance(block, blocks.CharBlock):\n+    elif isinstance(block, (blocks.CharBlock, blocks.TextBlock)):\n+        return CharBlockComparison\n+    elif isinstance(block, blocks.RawHTMLBlock):\n+        # Compare raw HTML blocks as if they were plain text, so that tags are shown explicitly\n         return CharBlockComparison\n     elif isinstance(block, blocks.RichTextBlock):\n         return RichTextBlockComparison\n@@ -89,7 +97,19 @@ def has_changed(self):\n         return self.val_a != self.val_b\n \n     def htmlvalue(self, val):\n-        return self.block.render_basic(val)\n+        \"\"\"\n+        Return an HTML representation of this block that is safe to be included\n+        in comparison views\n+        \"\"\"\n+        return escape(text_from_html(self.block.render_basic(val)))\n+\n+    def htmldiff(self):\n+        html_val_a = self.block.render_basic(self.val_a)\n+        html_val_b = self.block.render_basic(self.val_b)\n+        return diff_text(\n+            text_from_html(html_val_a),\n+            text_from_html(html_val_b)\n+        ).to_html()\n \n \n class CharBlockComparison(BlockComparison):\n@@ -99,13 +119,12 @@ def htmldiff(self):\n             force_str(self.val_b)\n         ).to_html()\n \n+    def htmlvalue(self, val):\n+        return escape(val)\n+\n \n class RichTextBlockComparison(BlockComparison):\n-    def htmldiff(self):\n-        return diff_text(\n-            BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n-            BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n-        ).to_html()\n+    pass\n \n \n class StructBlockComparison(BlockComparison):\n@@ -219,8 +238,8 @@ def htmldiff(self):\n         else:\n             # Fall back to diffing the HTML representation\n             return diff_text(\n-                BeautifulSoup(force_str(self.val_a), 'html5lib').getText(),\n-                BeautifulSoup(force_str(self.val_b), 'html5lib').getText()\n+                text_from_html(self.val_a),\n+                text_from_html(self.val_b)\n             ).to_html()\n \n ", "file_path": "files/2020_4/115", "file_language": "py", "file_name": "wagtail/admin/compare.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/wagtail/wagtail/raw/61045ceefea114c40ac4b680af58990dbe732389/wagtail%2Fadmin%2Ftests%2Ftest_compare.py", "code": "from functools import partial\n\nfrom django.test import TestCase\nfrom django.utils.safestring import SafeString\n\nfrom wagtail.admin import compare\nfrom wagtail.core.blocks import StreamValue\nfrom wagtail.images import get_image_model\nfrom wagtail.images.tests.utils import get_test_image_file\nfrom wagtail.tests.testapp.models import (\n    AdvertWithCustomPrimaryKey, EventCategory, EventPage, EventPageSpeaker,\n    HeadCountRelatedModelUsingPK, SimplePage, SnippetChooserModelWithCustomPrimaryKey,\n    StreamPage, TaggedPage)\n\n\nclass TestFieldComparison(TestCase):\n    comparison_class = compare.FieldComparison\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Content\"),\n            SimplePage(content=\"Content\"),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Content\")\n        self.assertEqual(comparison.htmldiff(), 'Content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">Modified content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content='Original content'),\n            SimplePage(content='<script type=\"text/javascript\">doSomethingBad();</script>'),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestTextFieldComparison(TestFieldComparison):\n    comparison_class = compare.TextFieldComparison\n\n    # Only change from FieldComparison is the HTML diff is performed on words\n    # instead of the whole field value.\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_none_to_value_only_shows_addition(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=None),\n            SimplePage(content=\"Added content\")\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"addition\">Added content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_value_to_none_only_shows_deletion(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Removed content\"),\n            SimplePage(content=None)\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Removed content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestRichTextFieldComparison(TestFieldComparison):\n    comparison_class = compare.RichTextFieldComparison\n\n    # Only change from FieldComparison is the HTML diff is performed on words\n    # instead of the whole field value.\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    # Only change from FieldComparison is that this comparison disregards HTML tags\n    def test_has_changed_html(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"<b>Original</b> content\"),\n            SimplePage(content=\"Modified <i>content</i>\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value(self):\n        # Need to override this one as the HTML tags are stripped by RichTextFieldComparison\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content='Original content'),\n            SimplePage(content='<script type=\"text/javascript\">doSomethingBad();</script>'),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">doSomethingBad();</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestStreamFieldComparison(TestCase):\n    comparison_class = compare.StreamFieldComparison\n\n    def test_hasnt_changed(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Body\")\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Modified content\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_add_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"New Content\", '2'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object addition\">New Content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_delete_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Foo\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object deletion\">Content Foo</div>\\n<div class=\"comparison__child-object\">Content Bar</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_edit_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Foo\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Baz\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object\">Content <span class=\"deletion\">Foo</span><span class=\"addition\">Baz</span></div>\\n<div class=\"comparison__child-object\">Content Bar</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_has_changed_richtext(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"<b>Original</b> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Modified <i>content</i>\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value_on_change(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"I <b>really</b> like original<i>ish</i> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', 'I <b>really</b> like evil code <script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">I &lt;b&gt;really&lt;/b&gt; like <span class=\"deletion\">original&lt;i&gt;ish&lt;/i&gt; content</span><span class=\"addition\">evil code &lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_escapes_value_on_addition(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original <em>and unchanged</em> content\", '1'),\n                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_escapes_value_on_deletion(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original <em>and unchanged</em> content\", '1'),\n                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object deletion\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_richtext_strips_tags_on_change(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"I <b>really</b> like Wagtail &lt;3\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">I really like <span class=\"deletion\">Wagtail &lt;3</span><span class=\"addition\">evil code &gt;_&lt; doSomethingBad();</span></div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_richtext_strips_tags_on_addition(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original and unchanged content</div>\\n<div class=\"comparison__child-object addition\">I really like evil code &gt;_&lt; doSomethingBad();</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_richtext_strips_tags_on_deletion(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original and unchanged content</div>\\n<div class=\"comparison__child-object deletion\">I really like evil code &gt;_&lt; doSomethingBad();</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_raw_html_escapes_value_on_change(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', \"Original<i>ish</i> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n            ])),\n        )\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original&lt;i&gt;ish&lt;/i&gt; content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_raw_html_escapes_value_on_addition(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n        )\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_raw_html_escapes_value_on_deletion(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n            ])),\n        )\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object deletion\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_compare_structblock(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('product', {'name': 'a packet of rolos', 'price': '75p'}, '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('product', {'name': 'a packet of rolos', 'price': '85p'}, '1'),\n            ])),\n        )\n\n        expected = \"\"\"\n            <div class=\"comparison__child-object\"><dl>\n                <dt>Name</dt>\n                <dd>a packet of rolos</dd>\n                <dt>Price</dt>\n                <dd><span class=\"deletion\">75p</span><span class=\"addition\">85p</span></dd>\n            </dl></div>\n        \"\"\"\n        self.assertHTMLEqual(comparison.htmldiff(), expected)\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_compare_imagechooserblock(self):\n        image_model = get_image_model()\n        test_image_1 = image_model.objects.create(\n            title=\"Test image 1\",\n            file=get_test_image_file(),\n        )\n        test_image_2 = image_model.objects.create(\n            title=\"Test image 2\",\n            file=get_test_image_file(),\n        )\n\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('image', test_image_1, '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('image', test_image_2, '1'),\n            ])),\n        )\n\n        result = comparison.htmldiff()\n        self.assertIn('<div class=\"preview-image deletion\">', result)\n        self.assertIn('alt=\"Test image 1\"', result)\n        self.assertIn('<div class=\"preview-image addition\">', result)\n        self.assertIn('alt=\"Test image 2\"', result)\n\n        self.assertIsInstance(result, SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestChoiceFieldComparison(TestCase):\n    comparison_class = compare.ChoiceFieldComparison\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=\"public\"),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Audience\")\n        self.assertEqual(comparison.htmldiff(), 'Public')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=\"private\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Public</span><span class=\"addition\">Private</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_none_to_value_only_shows_addition(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=None),\n            EventPage(audience=\"private\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"addition\">Private</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_value_to_none_only_shows_deletion(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=None),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Public</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestTagsFieldComparison(TestCase):\n    comparison_class = compare.TagsFieldComparison\n\n    def test_hasnt_changed(self):\n        a = TaggedPage()\n        a.tags.add('wagtail')\n        a.tags.add('bird')\n\n        b = TaggedPage()\n        b.tags.add('wagtail')\n        b.tags.add('bird')\n\n        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Tags\")\n        self.assertEqual(comparison.htmldiff(), 'wagtail, bird')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        a = TaggedPage()\n        a.tags.add('wagtail')\n        a.tags.add('bird')\n\n        b = TaggedPage()\n        b.tags.add('wagtail')\n        b.tags.add('motacilla')\n\n        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)\n\n        self.assertEqual(comparison.htmldiff(), 'wagtail, <span class=\"deletion\">bird</span>, <span class=\"addition\">motacilla</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestM2MFieldComparison(TestCase):\n    fixtures = ['test.json']\n    comparison_class = compare.M2MFieldComparison\n\n    def setUp(self):\n        self.meetings_category = EventCategory.objects.create(name='Meetings')\n        self.parties_category = EventCategory.objects.create(name='Parties')\n        self.holidays_category = EventCategory.objects.create(name='Holidays')\n\n    def test_hasnt_changed(self):\n        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')\n        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')\n\n        christmas_event.categories = [self.meetings_category, self.parties_category]\n        saint_patrick_event.categories = [self.meetings_category, self.parties_category]\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Categories\")\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.htmldiff(), 'Meetings, Parties')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_has_changed(self):\n        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')\n        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')\n\n        christmas_event.categories = [self.meetings_category, self.parties_category]\n        saint_patrick_event.categories = [self.meetings_category, self.holidays_category]\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event\n        )\n\n        self.assertTrue(comparison.has_changed())\n        self.assertEqual(comparison.htmldiff(), 'Meetings, <span class=\"deletion\">Parties</span>, <span class=\"addition\">Holidays</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestForeignObjectComparison(TestCase):\n    comparison_class = compare.ForeignObjectComparison\n\n    @classmethod\n    def setUpTestData(cls):\n        image_model = get_image_model()\n        cls.test_image_1 = image_model.objects.create(\n            title=\"Test image 1\",\n            file=get_test_image_file(),\n        )\n        cls.test_image_2 = image_model.objects.create(\n            title=\"Test image 2\",\n            file=get_test_image_file(),\n        )\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('feed_image'),\n            EventPage(feed_image=self.test_image_1),\n            EventPage(feed_image=self.test_image_1),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Feed image\")\n        self.assertEqual(comparison.htmldiff(), 'Test image 1')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('feed_image'),\n            EventPage(feed_image=self.test_image_1),\n            EventPage(feed_image=self.test_image_2),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Test image 1</span><span class=\"addition\">Test image 2</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestForeignObjectComparisonWithCustomPK(TestCase):\n    \"\"\"ForeignObjectComparison works with models declaring a custom primary key field\"\"\"\n\n    comparison_class = compare.ForeignObjectComparison\n\n    @classmethod\n    def setUpTestData(cls):\n        ad1 = AdvertWithCustomPrimaryKey.objects.create(\n            advert_id='ad1',\n            text='Advert 1'\n        )\n        ad2 = AdvertWithCustomPrimaryKey.objects.create(\n            advert_id='ad2',\n            text='Advert 2'\n        )\n        cls.test_obj_1 = SnippetChooserModelWithCustomPrimaryKey.objects.create(\n            advertwithcustomprimarykey=ad1\n        )\n        cls.test_obj_2 = SnippetChooserModelWithCustomPrimaryKey.objects.create(\n            advertwithcustomprimarykey=ad2\n        )\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            SnippetChooserModelWithCustomPrimaryKey._meta.get_field('advertwithcustomprimarykey'),\n            self.test_obj_1,\n            self.test_obj_1,\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), 'Advertwithcustomprimarykey')\n        self.assertEqual(comparison.htmldiff(), 'Advert 1')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SnippetChooserModelWithCustomPrimaryKey._meta.get_field('advertwithcustomprimarykey'),\n            self.test_obj_1,\n            self.test_obj_2,\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Advert 1</span><span class=\"addition\">Advert 2</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestChildRelationComparison(TestCase):\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildRelationComparison\n\n    def test_hasnt_changed(self):\n        # Two event pages with speaker called \"Father Christmas\". Neither of\n        # the speaker objects have an ID so this tests that the code can match\n        # the two together by field content.\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertFalse(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})\n        self.assertEqual(map_backwards, {0: 0})\n        self.assertEqual(added, [])\n        self.assertEqual(deleted, [])\n\n    def test_has_changed(self):\n        # Father Christmas renamed to Santa Claus. And Father Ted added.\n        # Father Christmas should be mapped to Father Ted because they\n        # are most alike. Santa claus should be displayed as \"new\"\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=0,\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n            sort_order=0,\n        ))\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Ted\",\n            sort_order=1,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 1})  # Map Father Christmas to Father Ted\n        self.assertEqual(map_backwards, {1: 0})  # Map Father Ted ot Father Christmas\n        self.assertEqual(added, [0])  # Add Santa Claus\n        self.assertEqual(deleted, [])\n\n    def test_has_changed_with_same_id(self):\n        # Father Christmas renamed to Santa Claus, but this time the ID of the\n        # child object remained the same. It should now be detected as the same\n        # object\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=0,\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n            sort_order=0,\n        ))\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Ted\",\n            sort_order=1,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})  # Map Father Christmas to Santa Claus\n        self.assertEqual(map_backwards, {0: 0})  # Map Santa Claus to Father Christmas\n        self.assertEqual(added, [1])  # Add Father Ted\n        self.assertEqual(deleted, [])\n\n    def test_hasnt_changed_with_different_id(self):\n        # Both of the child objects have the same field content but have a\n        # different ID so they should be detected as separate objects\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            id=2,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {})\n        self.assertEqual(map_backwards, {})\n        self.assertEqual(added, [0])  # Add new Father Christmas\n        self.assertEqual(deleted, [0])  # Delete old Father Christmas\n\n\nclass TestChildObjectComparison(TestCase):\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildObjectComparison\n\n    def test_same_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_different_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertTrue(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 2)\n\n    def test_moved_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=1,\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=5,\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 4)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_addition(self):\n        obj = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            None,\n            obj,\n        )\n\n        self.assertTrue(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertIsNone(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_deletion(self):\n        obj = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj,\n            None,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertTrue(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertIsNone(comparison.get_position_change())\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n\nclass TestChildRelationComparisonUsingPK(TestCase):\n    \"\"\"Test related objects can be compred if they do not use id for primary key\"\"\"\n\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildRelationComparison\n\n    def test_has_changed_with_same_id(self):\n        # Head Count was changed but the PK of the child object remained the same.\n        # It should be detected as the same object\n\n        event_page = EventPage(title=\"Semi Finals\", slug=\"semi-finals-2018\")\n        event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=22,\n        ))\n\n        modified_event_page = EventPage(title=\"Semi Finals\", slug=\"semi-finals-2018\")\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=23,\n        ))\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            head_count=25,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('head_counts'),\n            [partial(self.field_comparison_class, HeadCountRelatedModelUsingPK._meta.get_field('head_count'))],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), 'Head counts')\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})  # map head count 22 to 23\n        self.assertEqual(map_backwards, {0: 0})  # map head count 23 to 22\n        self.assertEqual(added, [1])  # add second head count\n        self.assertEqual(deleted, [])\n\n\n    def test_hasnt_changed_with_different_id(self):\n        # Both of the child objects have the same field content but have a\n        # different PK (ID) so they should be detected as separate objects\n        event_page = EventPage(title=\"Finals\", slug=\"finals-event-abc\")\n        event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=220\n        ))\n\n        modified_event_page = EventPage(title=\"Finals\", slug=\"finals-event-abc\")\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=2,\n            head_count=220\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('head_counts'),\n            [partial(self.field_comparison_class, HeadCountRelatedModelUsingPK._meta.get_field('head_count'))],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Head counts\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {})\n        self.assertEqual(map_backwards, {})\n        self.assertEqual(added, [0])  # Add new head count\n        self.assertEqual(deleted, [0])  # Delete old head count\n", "code_before": "from functools import partial\n\nfrom django.test import TestCase\nfrom django.utils.safestring import SafeString\n\nfrom wagtail.admin import compare\nfrom wagtail.core.blocks import StreamValue\nfrom wagtail.images import get_image_model\nfrom wagtail.images.tests.utils import get_test_image_file\nfrom wagtail.tests.testapp.models import (\n    AdvertWithCustomPrimaryKey, EventCategory, EventPage, EventPageSpeaker,\n    HeadCountRelatedModelUsingPK, SimplePage, SnippetChooserModelWithCustomPrimaryKey,\n    StreamPage, TaggedPage)\n\n\nclass TestFieldComparison(TestCase):\n    comparison_class = compare.FieldComparison\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Content\"),\n            SimplePage(content=\"Content\"),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Content\")\n        self.assertEqual(comparison.htmldiff(), 'Content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">Modified content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content='Original content'),\n            SimplePage(content='<script type=\"text/javascript\">doSomethingBad();</script>'),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestTextFieldComparison(TestFieldComparison):\n    comparison_class = compare.TextFieldComparison\n\n    # Only change from FieldComparison is the HTML diff is performed on words\n    # instead of the whole field value.\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_none_to_value_only_shows_addition(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=None),\n            SimplePage(content=\"Added content\")\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"addition\">Added content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_value_to_none_only_shows_deletion(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Removed content\"),\n            SimplePage(content=None)\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Removed content</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestRichTextFieldComparison(TestFieldComparison):\n    comparison_class = compare.RichTextFieldComparison\n\n    # Only change from FieldComparison is the HTML diff is performed on words\n    # instead of the whole field value.\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"Original content\"),\n            SimplePage(content=\"Modified content\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    # Only change from FieldComparison is that this comparison disregards HTML tags\n    def test_has_changed_html(self):\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content=\"<b>Original</b> content\"),\n            SimplePage(content=\"Modified <i>content</i>\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value(self):\n        # Need to override this one as the HTML tags are stripped by RichTextFieldComparison\n        comparison = self.comparison_class(\n            SimplePage._meta.get_field('content'),\n            SimplePage(content='Original content'),\n            SimplePage(content='<script type=\"text/javascript\">doSomethingBad();</script>'),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Original content</span><span class=\"addition\">doSomethingBad();</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestStreamFieldComparison(TestCase):\n    comparison_class = compare.StreamFieldComparison\n\n    def test_hasnt_changed(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Body\")\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Modified content\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_add_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"New Content\", '2'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object addition\">New Content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_delete_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Foo\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object deletion\">Content Foo</div>\\n<div class=\"comparison__child-object\">Content Bar</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_edit_block(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Foo\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Content\", '1'),\n                ('text', \"Content Baz\", '2'),\n                ('text', \"Content Bar\", '3'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Content</div>\\n<div class=\"comparison__child-object\">Content <span class=\"deletion\">Foo</span><span class=\"addition\">Baz</span></div>\\n<div class=\"comparison__child-object\">Content Bar</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_has_changed_richtext(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"<b>Original</b> content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Modified <i>content</i>\", '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original</span><span class=\"addition\">Modified</span> content</div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_htmldiff_escapes_value(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', \"Original content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_htmldiff_escapes_value_richtext(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', \"Original content\", '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('rich_text', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n            ])),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original content</span><span class=\"addition\">doSomethingBad();</span></div>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_compare_structblock(self):\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('product', {'name': 'a packet of rolos', 'price': '75p'}, '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('product', {'name': 'a packet of rolos', 'price': '85p'}, '1'),\n            ])),\n        )\n\n        expected = \"\"\"\n            <div class=\"comparison__child-object\"><dl>\n                <dt>Name</dt>\n                <dd>a packet of rolos</dd>\n                <dt>Price</dt>\n                <dd><span class=\"deletion\">75p</span><span class=\"addition\">85p</span></dd>\n            </dl></div>\n        \"\"\"\n        self.assertHTMLEqual(comparison.htmldiff(), expected)\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_compare_imagechooserblock(self):\n        image_model = get_image_model()\n        test_image_1 = image_model.objects.create(\n            title=\"Test image 1\",\n            file=get_test_image_file(),\n        )\n        test_image_2 = image_model.objects.create(\n            title=\"Test image 2\",\n            file=get_test_image_file(),\n        )\n\n        field = StreamPage._meta.get_field('body')\n\n        comparison = self.comparison_class(\n            field,\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('image', test_image_1, '1'),\n            ])),\n            StreamPage(body=StreamValue(field.stream_block, [\n                ('image', test_image_2, '1'),\n            ])),\n        )\n\n        result = comparison.htmldiff()\n        self.assertIn('<div class=\"preview-image deletion\">', result)\n        self.assertIn('alt=\"Test image 1\"', result)\n        self.assertIn('<div class=\"preview-image addition\">', result)\n        self.assertIn('alt=\"Test image 2\"', result)\n\n        self.assertIsInstance(result, SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestChoiceFieldComparison(TestCase):\n    comparison_class = compare.ChoiceFieldComparison\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=\"public\"),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Audience\")\n        self.assertEqual(comparison.htmldiff(), 'Public')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=\"private\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Public</span><span class=\"addition\">Private</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_none_to_value_only_shows_addition(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=None),\n            EventPage(audience=\"private\"),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"addition\">Private</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n    def test_from_value_to_none_only_shows_deletion(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('audience'),\n            EventPage(audience=\"public\"),\n            EventPage(audience=None),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Public</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestTagsFieldComparison(TestCase):\n    comparison_class = compare.TagsFieldComparison\n\n    def test_hasnt_changed(self):\n        a = TaggedPage()\n        a.tags.add('wagtail')\n        a.tags.add('bird')\n\n        b = TaggedPage()\n        b.tags.add('wagtail')\n        b.tags.add('bird')\n\n        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Tags\")\n        self.assertEqual(comparison.htmldiff(), 'wagtail, bird')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        a = TaggedPage()\n        a.tags.add('wagtail')\n        a.tags.add('bird')\n\n        b = TaggedPage()\n        b.tags.add('wagtail')\n        b.tags.add('motacilla')\n\n        comparison = self.comparison_class(TaggedPage._meta.get_field('tags'), a, b)\n\n        self.assertEqual(comparison.htmldiff(), 'wagtail, <span class=\"deletion\">bird</span>, <span class=\"addition\">motacilla</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestM2MFieldComparison(TestCase):\n    fixtures = ['test.json']\n    comparison_class = compare.M2MFieldComparison\n\n    def setUp(self):\n        self.meetings_category = EventCategory.objects.create(name='Meetings')\n        self.parties_category = EventCategory.objects.create(name='Parties')\n        self.holidays_category = EventCategory.objects.create(name='Holidays')\n\n    def test_hasnt_changed(self):\n        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')\n        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')\n\n        christmas_event.categories = [self.meetings_category, self.parties_category]\n        saint_patrick_event.categories = [self.meetings_category, self.parties_category]\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Categories\")\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.htmldiff(), 'Meetings, Parties')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n    def test_has_changed(self):\n        christmas_event = EventPage.objects.get(url_path='/home/events/christmas/')\n        saint_patrick_event = EventPage.objects.get(url_path='/home/events/saint-patrick/')\n\n        christmas_event.categories = [self.meetings_category, self.parties_category]\n        saint_patrick_event.categories = [self.meetings_category, self.holidays_category]\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('categories'), christmas_event, saint_patrick_event\n        )\n\n        self.assertTrue(comparison.has_changed())\n        self.assertEqual(comparison.htmldiff(), 'Meetings, <span class=\"deletion\">Parties</span>, <span class=\"addition\">Holidays</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n\n\nclass TestForeignObjectComparison(TestCase):\n    comparison_class = compare.ForeignObjectComparison\n\n    @classmethod\n    def setUpTestData(cls):\n        image_model = get_image_model()\n        cls.test_image_1 = image_model.objects.create(\n            title=\"Test image 1\",\n            file=get_test_image_file(),\n        )\n        cls.test_image_2 = image_model.objects.create(\n            title=\"Test image 2\",\n            file=get_test_image_file(),\n        )\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('feed_image'),\n            EventPage(feed_image=self.test_image_1),\n            EventPage(feed_image=self.test_image_1),\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Feed image\")\n        self.assertEqual(comparison.htmldiff(), 'Test image 1')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('feed_image'),\n            EventPage(feed_image=self.test_image_1),\n            EventPage(feed_image=self.test_image_2),\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Test image 1</span><span class=\"addition\">Test image 2</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestForeignObjectComparisonWithCustomPK(TestCase):\n    \"\"\"ForeignObjectComparison works with models declaring a custom primary key field\"\"\"\n\n    comparison_class = compare.ForeignObjectComparison\n\n    @classmethod\n    def setUpTestData(cls):\n        ad1 = AdvertWithCustomPrimaryKey.objects.create(\n            advert_id='ad1',\n            text='Advert 1'\n        )\n        ad2 = AdvertWithCustomPrimaryKey.objects.create(\n            advert_id='ad2',\n            text='Advert 2'\n        )\n        cls.test_obj_1 = SnippetChooserModelWithCustomPrimaryKey.objects.create(\n            advertwithcustomprimarykey=ad1\n        )\n        cls.test_obj_2 = SnippetChooserModelWithCustomPrimaryKey.objects.create(\n            advertwithcustomprimarykey=ad2\n        )\n\n    def test_hasnt_changed(self):\n        comparison = self.comparison_class(\n            SnippetChooserModelWithCustomPrimaryKey._meta.get_field('advertwithcustomprimarykey'),\n            self.test_obj_1,\n            self.test_obj_1,\n        )\n\n        self.assertTrue(comparison.is_field)\n        self.assertFalse(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), 'Advertwithcustomprimarykey')\n        self.assertEqual(comparison.htmldiff(), 'Advert 1')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertFalse(comparison.has_changed())\n\n    def test_has_changed(self):\n        comparison = self.comparison_class(\n            SnippetChooserModelWithCustomPrimaryKey._meta.get_field('advertwithcustomprimarykey'),\n            self.test_obj_1,\n            self.test_obj_2,\n        )\n\n        self.assertEqual(comparison.htmldiff(), '<span class=\"deletion\">Advert 1</span><span class=\"addition\">Advert 2</span>')\n        self.assertIsInstance(comparison.htmldiff(), SafeString)\n        self.assertTrue(comparison.has_changed())\n\n\nclass TestChildRelationComparison(TestCase):\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildRelationComparison\n\n    def test_hasnt_changed(self):\n        # Two event pages with speaker called \"Father Christmas\". Neither of\n        # the speaker objects have an ID so this tests that the code can match\n        # the two together by field content.\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertFalse(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})\n        self.assertEqual(map_backwards, {0: 0})\n        self.assertEqual(added, [])\n        self.assertEqual(deleted, [])\n\n    def test_has_changed(self):\n        # Father Christmas renamed to Santa Claus. And Father Ted added.\n        # Father Christmas should be mapped to Father Ted because they\n        # are most alike. Santa claus should be displayed as \"new\"\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=0,\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n            sort_order=0,\n        ))\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Ted\",\n            sort_order=1,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 1})  # Map Father Christmas to Father Ted\n        self.assertEqual(map_backwards, {1: 0})  # Map Father Ted ot Father Christmas\n        self.assertEqual(added, [0])  # Add Santa Claus\n        self.assertEqual(deleted, [])\n\n    def test_has_changed_with_same_id(self):\n        # Father Christmas renamed to Santa Claus, but this time the ID of the\n        # child object remained the same. It should now be detected as the same\n        # object\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=0,\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n            sort_order=0,\n        ))\n        modified_event_page.speakers.add(EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Ted\",\n            sort_order=1,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})  # Map Father Christmas to Santa Claus\n        self.assertEqual(map_backwards, {0: 0})  # Map Santa Claus to Father Christmas\n        self.assertEqual(added, [1])  # Add Father Ted\n        self.assertEqual(deleted, [])\n\n    def test_hasnt_changed_with_different_id(self):\n        # Both of the child objects have the same field content but have a\n        # different ID so they should be detected as separate objects\n        event_page = EventPage(title=\"Event page\", slug=\"event\")\n        event_page.speakers.add(EventPageSpeaker(\n            id=1,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        modified_event_page = EventPage(title=\"Event page\", slug=\"event\")\n        modified_event_page.speakers.add(EventPageSpeaker(\n            id=2,\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('speaker'),\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Speaker\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {})\n        self.assertEqual(map_backwards, {})\n        self.assertEqual(added, [0])  # Add new Father Christmas\n        self.assertEqual(deleted, [0])  # Delete old Father Christmas\n\n\nclass TestChildObjectComparison(TestCase):\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildObjectComparison\n\n    def test_same_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_different_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Santa\",\n            last_name=\"Claus\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertTrue(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 2)\n\n    def test_moved_object(self):\n        obj_a = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=1,\n        )\n\n        obj_b = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n            sort_order=5,\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj_a,\n            obj_b,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertEqual(comparison.get_position_change(), 4)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_addition(self):\n        obj = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            None,\n            obj,\n        )\n\n        self.assertTrue(comparison.is_addition())\n        self.assertFalse(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertIsNone(comparison.get_position_change(), 0)\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n    def test_deletion(self):\n        obj = EventPageSpeaker(\n            first_name=\"Father\",\n            last_name=\"Christmas\",\n        )\n\n        comparison = self.comparison_class(\n            EventPageSpeaker,\n            [\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('first_name')),\n                partial(self.field_comparison_class, EventPageSpeaker._meta.get_field('last_name')),\n            ],\n            obj,\n            None,\n        )\n\n        self.assertFalse(comparison.is_addition())\n        self.assertTrue(comparison.is_deletion())\n        self.assertFalse(comparison.has_changed())\n        self.assertIsNone(comparison.get_position_change())\n        self.assertEqual(comparison.get_num_differences(), 0)\n\n\nclass TestChildRelationComparisonUsingPK(TestCase):\n    \"\"\"Test related objects can be compred if they do not use id for primary key\"\"\"\n\n    field_comparison_class = compare.FieldComparison\n    comparison_class = compare.ChildRelationComparison\n\n    def test_has_changed_with_same_id(self):\n        # Head Count was changed but the PK of the child object remained the same.\n        # It should be detected as the same object\n\n        event_page = EventPage(title=\"Semi Finals\", slug=\"semi-finals-2018\")\n        event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=22,\n        ))\n\n        modified_event_page = EventPage(title=\"Semi Finals\", slug=\"semi-finals-2018\")\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=23,\n        ))\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            head_count=25,\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('head_counts'),\n            [partial(self.field_comparison_class, HeadCountRelatedModelUsingPK._meta.get_field('head_count'))],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), 'Head counts')\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {0: 0})  # map head count 22 to 23\n        self.assertEqual(map_backwards, {0: 0})  # map head count 23 to 22\n        self.assertEqual(added, [1])  # add second head count\n        self.assertEqual(deleted, [])\n\n\n    def test_hasnt_changed_with_different_id(self):\n        # Both of the child objects have the same field content but have a\n        # different PK (ID) so they should be detected as separate objects\n        event_page = EventPage(title=\"Finals\", slug=\"finals-event-abc\")\n        event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=1,\n            head_count=220\n        ))\n\n        modified_event_page = EventPage(title=\"Finals\", slug=\"finals-event-abc\")\n        modified_event_page.head_counts.add(HeadCountRelatedModelUsingPK(\n            custom_id=2,\n            head_count=220\n        ))\n\n        comparison = self.comparison_class(\n            EventPage._meta.get_field('head_counts'),\n            [partial(self.field_comparison_class, HeadCountRelatedModelUsingPK._meta.get_field('head_count'))],\n            event_page,\n            modified_event_page,\n        )\n\n        self.assertFalse(comparison.is_field)\n        self.assertTrue(comparison.is_child_relation)\n        self.assertEqual(comparison.field_label(), \"Head counts\")\n        self.assertTrue(comparison.has_changed())\n\n        # Check mapping\n        objs_a = list(comparison.val_a.all())\n        objs_b = list(comparison.val_b.all())\n        map_forwards, map_backwards, added, deleted = comparison.get_mapping(objs_a, objs_b)\n        self.assertEqual(map_forwards, {})\n        self.assertEqual(map_backwards, {})\n        self.assertEqual(added, [0])  # Add new head count\n        self.assertEqual(deleted, [0])  # Delete old head count\n", "patch": "@@ -247,36 +247,151 @@ def test_has_changed_richtext(self):\n         self.assertIsInstance(comparison.htmldiff(), SafeString)\n         self.assertTrue(comparison.has_changed())\n \n-    def test_htmldiff_escapes_value(self):\n+    def test_htmldiff_escapes_value_on_change(self):\n         field = StreamPage._meta.get_field('body')\n \n         comparison = self.comparison_class(\n             field,\n             StreamPage(body=StreamValue(field.stream_block, [\n-                ('text', \"Original content\", '1'),\n+                ('text', \"I <b>really</b> like original<i>ish</i> content\", '1'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('text', 'I <b>really</b> like evil code <script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n+            ])),\n+        )\n+\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">I &lt;b&gt;really&lt;/b&gt; like <span class=\"deletion\">original&lt;i&gt;ish&lt;/i&gt; content</span><span class=\"addition\">evil code &lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_escapes_value_on_addition(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('text', \"Original <em>and unchanged</em> content\", '1'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('text', \"Original <em>and unchanged</em> content\", '1'),\n+                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n+            ])),\n+        )\n+\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_escapes_value_on_deletion(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('text', \"Original <em>and unchanged</em> content\", '1'),\n+                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n             ])),\n             StreamPage(body=StreamValue(field.stream_block, [\n-                ('text', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n+                ('text', \"Original <em>and unchanged</em> content\", '1'),\n             ])),\n         )\n \n-        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object deletion\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n         self.assertIsInstance(comparison.htmldiff(), SafeString)\n \n-    def test_htmldiff_escapes_value_richtext(self):\n+    def test_htmldiff_richtext_strips_tags_on_change(self):\n         field = StreamPage._meta.get_field('body')\n \n         comparison = self.comparison_class(\n             field,\n             StreamPage(body=StreamValue(field.stream_block, [\n-                ('rich_text', \"Original content\", '1'),\n+                ('rich_text', \"I <b>really</b> like Wagtail &lt;3\", '1'),\n             ])),\n             StreamPage(body=StreamValue(field.stream_block, [\n-                ('rich_text', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n+                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n             ])),\n         )\n \n-        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original content</span><span class=\"addition\">doSomethingBad();</span></div>')\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">I really like <span class=\"deletion\">Wagtail &lt;3</span><span class=\"addition\">evil code &gt;_&lt; doSomethingBad();</span></div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_richtext_strips_tags_on_addition(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n+                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n+            ])),\n+        )\n+\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original and unchanged content</div>\\n<div class=\"comparison__child-object addition\">I really like evil code &gt;_&lt; doSomethingBad();</div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_richtext_strips_tags_on_deletion(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n+                ('rich_text', 'I <b>really</b> like evil code &gt;_&lt; <script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('rich_text', \"Original <em>and unchanged</em> content\", '1'),\n+            ])),\n+        )\n+\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original and unchanged content</div>\\n<div class=\"comparison__child-object deletion\">I really like evil code &gt;_&lt; doSomethingBad();</div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_raw_html_escapes_value_on_change(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', \"Original<i>ish</i> content\", '1'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '1'),\n+            ])),\n+        )\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\"><span class=\"deletion\">Original&lt;i&gt;ish&lt;/i&gt; content</span><span class=\"addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</span></div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_raw_html_escapes_value_on_addition(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n+                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n+            ])),\n+        )\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object addition\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n+        self.assertIsInstance(comparison.htmldiff(), SafeString)\n+\n+    def test_htmldiff_raw_html_escapes_value_on_deletion(self):\n+        field = StreamPage._meta.get_field('body')\n+\n+        comparison = self.comparison_class(\n+            field,\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n+                ('raw_html', '<script type=\"text/javascript\">doSomethingBad();</script>', '2'),\n+            ])),\n+            StreamPage(body=StreamValue(field.stream_block, [\n+                ('raw_html', \"Original <em>and unchanged</em> content\", '1'),\n+            ])),\n+        )\n+        self.assertEqual(comparison.htmldiff(), '<div class=\"comparison__child-object\">Original &lt;em&gt;and unchanged&lt;/em&gt; content</div>\\n<div class=\"comparison__child-object deletion\">&lt;script type=&quot;text/javascript&quot;&gt;doSomethingBad();&lt;/script&gt;</div>')\n         self.assertIsInstance(comparison.htmldiff(), SafeString)\n \n     def test_compare_structblock(self):", "file_path": "files/2020_4/116", "file_language": "py", "file_name": "wagtail/admin/tests/test_compare.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/wagtail/wagtail/raw/61045ceefea114c40ac4b680af58990dbe732389/wagtail%2Ftests%2Ftestapp%2Fmigrations%2F0047_rawhtmlblock.py", "code": "# Generated by Django 3.0.4 on 2020-04-06 09:46\n\nfrom django.db import migrations\nimport wagtail.core.blocks\nimport wagtail.core.fields\nimport wagtail.tests.testapp.models\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('tests', '0046_personpage'),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name='streampage',\n            name='body',\n            field=wagtail.core.fields.StreamField([('text', wagtail.core.blocks.CharBlock()), ('rich_text', wagtail.core.blocks.RichTextBlock()), ('image', wagtail.tests.testapp.models.ExtendedImageChooserBlock()), ('product', wagtail.core.blocks.StructBlock([('name', wagtail.core.blocks.CharBlock()), ('price', wagtail.core.blocks.CharBlock())])), ('raw_html', wagtail.core.blocks.RawHTMLBlock())]),\n        ),\n    ]\n", "code_before": "", "patch": "@@ -0,0 +1,21 @@\n+# Generated by Django 3.0.4 on 2020-04-06 09:46\n+\n+from django.db import migrations\n+import wagtail.core.blocks\n+import wagtail.core.fields\n+import wagtail.tests.testapp.models\n+\n+\n+class Migration(migrations.Migration):\n+\n+    dependencies = [\n+        ('tests', '0046_personpage'),\n+    ]\n+\n+    operations = [\n+        migrations.AlterField(\n+            model_name='streampage',\n+            name='body',\n+            field=wagtail.core.fields.StreamField([('text', wagtail.core.blocks.CharBlock()), ('rich_text', wagtail.core.blocks.RichTextBlock()), ('image', wagtail.tests.testapp.models.ExtendedImageChooserBlock()), ('product', wagtail.core.blocks.StructBlock([('name', wagtail.core.blocks.CharBlock()), ('price', wagtail.core.blocks.CharBlock())])), ('raw_html', wagtail.core.blocks.RawHTMLBlock())]),\n+        ),\n+    ]", "file_path": "files/2020_4/117", "file_language": "py", "file_name": "wagtail/tests/testapp/migrations/0047_rawhtmlblock.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": [{"function": "class Migration(migrations.Migration):\n\n    dependencies = [\n        ('tests', '0046_personpage'),\n    ]\n\n    operations = [\n        migrations.AlterField(\n            model_name='streampage',\n            name='body',\n            field=wagtail.core.fields.StreamField([('text', wagtail.core.blocks.CharBlock()), ('rich_text', wagtail.core.blocks.RichTextBlock()), ('image', wagtail.tests.testapp.models.ExtendedImageChooserBlock()), ('product', wagtail.core.blocks.StructBlock([('name', wagtail.core.blocks.CharBlock()), ('price', wagtail.core.blocks.CharBlock())])), ('raw_html', wagtail.core.blocks.RawHTMLBlock())]),\n        ),\n    ]", "target": 0}]}, {"raw_url": "https://github.com/wagtail/wagtail/raw/61045ceefea114c40ac4b680af58990dbe732389/wagtail%2Ftests%2Ftestapp%2Fmodels.py", "code": "import hashlib\nimport json\nimport os\nimport uuid\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.core.paginator import EmptyPage, PageNotAnInteger, Paginator\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db import models\nfrom django.shortcuts import redirect, render\nfrom modelcluster.contrib.taggit import ClusterTaggableManager\nfrom modelcluster.fields import ParentalKey, ParentalManyToManyField\nfrom modelcluster.models import ClusterableModel\nfrom taggit.managers import TaggableManager\nfrom taggit.models import TaggedItemBase\n\nfrom wagtail.admin.edit_handlers import (\n    FieldPanel, InlinePanel, MultiFieldPanel, ObjectList, PageChooserPanel, StreamFieldPanel,\n    TabbedInterface)\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.admin.mail import send_mail\nfrom wagtail.contrib.forms.forms import FormBuilder\nfrom wagtail.contrib.forms.models import (\n    FORM_FIELD_CHOICES, AbstractEmailForm, AbstractFormField, AbstractFormSubmission)\nfrom wagtail.contrib.settings.models import BaseSetting, register_setting\nfrom wagtail.contrib.sitemaps import Sitemap\nfrom wagtail.contrib.table_block.blocks import TableBlock\nfrom wagtail.core.blocks import CharBlock, RawHTMLBlock, RichTextBlock, StructBlock\nfrom wagtail.core.fields import RichTextField, StreamField\nfrom wagtail.core.models import Orderable, Page, PageManager, PageQuerySet\nfrom wagtail.documents.edit_handlers import DocumentChooserPanel\nfrom wagtail.documents.models import AbstractDocument, Document\nfrom wagtail.images.blocks import ImageChooserBlock\nfrom wagtail.images.edit_handlers import ImageChooserPanel\nfrom wagtail.images.models import AbstractImage, AbstractRendition, Image\nfrom wagtail.search import index\nfrom wagtail.snippets.edit_handlers import SnippetChooserPanel\nfrom wagtail.snippets.models import register_snippet\nfrom wagtail.utils.decorators import cached_classmethod\n\nfrom .forms import FormClassAdditionalFieldPageForm, ValidatedPageForm\nfrom .views import CustomSubmissionsListView\n\nEVENT_AUDIENCE_CHOICES = (\n    ('public', \"Public\"),\n    ('private', \"Private\"),\n)\n\n\nCOMMON_PANELS = (\n    FieldPanel('slug'),\n    FieldPanel('seo_title'),\n    FieldPanel('show_in_menus'),\n    FieldPanel('search_description'),\n)\n\n\n# Link fields\n\nclass LinkFields(models.Model):\n    link_external = models.URLField(\"External link\", blank=True)\n    link_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n    link_document = models.ForeignKey(\n        'wagtaildocs.Document',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n\n    @property\n    def link(self):\n        if self.link_page:\n            return self.link_page.url\n        elif self.link_document:\n            return self.link_document.url\n        else:\n            return self.link_external\n\n    panels = [\n        FieldPanel('link_external'),\n        PageChooserPanel('link_page'),\n        DocumentChooserPanel('link_document'),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Carousel items\n\nclass CarouselItem(LinkFields):\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    embed_url = models.URLField(\"Embed URL\", blank=True)\n    caption = models.CharField(max_length=255, blank=True)\n\n    panels = [\n        ImageChooserPanel('image'),\n        FieldPanel('embed_url'),\n        FieldPanel('caption'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Related links\n\nclass RelatedLink(LinkFields):\n    title = models.CharField(max_length=255, help_text=\"Link title\")\n\n    panels = [\n        FieldPanel('title'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Simple page\nclass SimplePage(Page):\n    content = models.TextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('content'),\n    ]\n\n    def get_admin_display_title(self):\n        return \"%s (simple page)\" % super().get_admin_display_title()\n\n\n# Page with Excluded Fields when copied\nclass PageWithExcludedCopyField(Page):\n    content = models.TextField()\n\n    # Exclude this field from being copied\n    special_field = models.CharField(\n        blank=True, max_length=255, default='Very Special')\n    exclude_fields_in_copy = ['special_field']\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('special_field'),\n        FieldPanel('content'),\n    ]\n\n\nclass PageWithOldStyleRouteMethod(Page):\n    \"\"\"\n    Prior to Wagtail 0.4, the route() method on Page returned an HttpResponse\n    rather than a Page instance. As subclasses of Page may override route,\n    we need to continue accepting this convention (albeit as a deprecated API).\n    \"\"\"\n    content = models.TextField()\n    template = 'tests/simple_page.html'\n\n    def route(self, request, path_components):\n        return self.serve(request)\n\n\n# File page\nclass FilePage(Page):\n    file_field = models.FileField()\n\n\nFilePage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('file_field'),\n]\n\n\n# Event page\n\nclass EventPageCarouselItem(Orderable, CarouselItem):\n    page = ParentalKey('tests.EventPage', related_name='carousel_items', on_delete=models.CASCADE)\n\n\nclass EventPageRelatedLink(Orderable, RelatedLink):\n    page = ParentalKey('tests.EventPage', related_name='related_links', on_delete=models.CASCADE)\n\n\nclass EventPageSpeakerAward(Orderable, models.Model):\n    speaker = ParentalKey('tests.EventPageSpeaker', related_name='awards', on_delete=models.CASCADE)\n    name = models.CharField(\"Award name\", max_length=255)\n    date_awarded = models.DateField(null=True, blank=True)\n\n    panels = [\n        FieldPanel('name'),\n        FieldPanel('date_awarded'),\n    ]\n\n\nclass EventPageSpeaker(Orderable, LinkFields, ClusterableModel):\n    page = ParentalKey('tests.EventPage', related_name='speakers', related_query_name='speaker', on_delete=models.CASCADE)\n    first_name = models.CharField(\"Name\", max_length=255, blank=True)\n    last_name = models.CharField(\"Surname\", max_length=255, blank=True)\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n\n    @property\n    def name_display(self):\n        return self.first_name + \" \" + self.last_name\n\n    panels = [\n        FieldPanel('first_name'),\n        FieldPanel('last_name'),\n        ImageChooserPanel('image'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n        InlinePanel('awards', label=\"Awards\"),\n    ]\n\n\nclass EventCategory(models.Model):\n    name = models.CharField(\"Name\", max_length=255)\n\n    def __str__(self):\n        return self.name\n\n\n# Override the standard WagtailAdminPageForm to add validation on start/end dates\n# that appears as a non-field error\n\nclass EventPageForm(WagtailAdminPageForm):\n    def clean(self):\n        cleaned_data = super().clean()\n\n        # Make sure that the event starts before it ends\n        start_date = cleaned_data['date_from']\n        end_date = cleaned_data['date_to']\n        if start_date and end_date and start_date > end_date:\n            raise ValidationError('The end date must be after the start date')\n\n        return cleaned_data\n\n\nclass EventPage(Page):\n    date_from = models.DateField(\"Start date\", null=True)\n    date_to = models.DateField(\n        \"End date\",\n        null=True,\n        blank=True,\n        help_text=\"Not required if event is on a single day\"\n    )\n    time_from = models.TimeField(\"Start time\", null=True, blank=True)\n    time_to = models.TimeField(\"End time\", null=True, blank=True)\n    audience = models.CharField(max_length=255, choices=EVENT_AUDIENCE_CHOICES)\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n    cost = models.CharField(max_length=255)\n    signup_link = models.URLField(blank=True)\n    feed_image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    categories = ParentalManyToManyField(EventCategory, blank=True)\n\n    search_fields = [\n        index.SearchField('get_audience_display'),\n        index.SearchField('location'),\n        index.SearchField('body'),\n        index.FilterField('url_path'),\n    ]\n\n    password_required_template = 'tests/event_page_password_required.html'\n    base_form_class = EventPageForm\n\n\nEventPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('date_from'),\n    FieldPanel('date_to'),\n    FieldPanel('time_from'),\n    FieldPanel('time_to'),\n    FieldPanel('location'),\n    FieldPanel('audience'),\n    FieldPanel('cost'),\n    FieldPanel('signup_link'),\n    InlinePanel('carousel_items', label=\"Carousel items\"),\n    FieldPanel('body', classname=\"full\"),\n    InlinePanel('speakers', label=\"Speakers\", heading=\"Speaker lineup\"),\n    InlinePanel('related_links', label=\"Related links\"),\n    FieldPanel('categories'),\n    # InlinePanel related model uses `pk` not `id`\n    InlinePanel('head_counts', label='Head Counts'),\n]\n\nEventPage.promote_panels = [\n    MultiFieldPanel(COMMON_PANELS, \"Common page configuration\"),\n    ImageChooserPanel('feed_image'),\n]\n\n\nclass HeadCountRelatedModelUsingPK(models.Model):\n    \"\"\"Related model that uses a custom primary key (pk) not id\"\"\"\n    custom_id = models.AutoField(primary_key=True)\n    event_page = ParentalKey(\n        EventPage,\n        on_delete=models.CASCADE,\n        related_name='head_counts'\n    )\n    head_count = models.IntegerField()\n    panels = [FieldPanel('head_count')]\n\n\n# Override the standard WagtailAdminPageForm to add field that is not in model\n# so that we can test additional potential issues like comparing versions\nclass FormClassAdditionalFieldPage(Page):\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('location'),\n        FieldPanel('body'),\n        FieldPanel('code'),  # not in model, see set base_form_class\n    ]\n\n    base_form_class = FormClassAdditionalFieldPageForm\n\n\n# Just to be able to test multi table inheritance\nclass SingleEventPage(EventPage):\n    excerpt = models.TextField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=\"Short text to describe what is this action about\"\n    )\n\n    # Give this page model a custom URL routing scheme\n    def get_url_parts(self, request=None):\n        url_parts = super().get_url_parts(request=request)\n        if url_parts is None:\n            return None\n        else:\n            site_id, root_url, page_path = url_parts\n            return (site_id, root_url, page_path + 'pointless-suffix/')\n\n    def route(self, request, path_components):\n        if path_components == ['pointless-suffix']:\n            # treat this as equivalent to a request for this page\n            return super().route(request, [])\n        else:\n            # fall back to default routing rules\n            return super().route(request, path_components)\n\n    def get_admin_display_title(self):\n        return \"%s (single event)\" % super().get_admin_display_title()\n\n\nSingleEventPage.content_panels = [FieldPanel('excerpt')] + EventPage.content_panels\n\n\n# \"custom\" sitemap object\nclass EventSitemap(Sitemap):\n    pass\n\n\n# Event index (has a separate AJAX template, and a custom template context)\nclass EventIndex(Page):\n    intro = RichTextField(blank=True)\n    ajax_template = 'tests/includes/event_listing.html'\n\n    def get_events(self):\n        return self.get_children().live().type(EventPage)\n\n    def get_paginator(self):\n        return Paginator(self.get_events(), 4)\n\n    def get_context(self, request, page=1):\n        # Pagination\n        paginator = self.get_paginator()\n        try:\n            events = paginator.page(page)\n        except PageNotAnInteger:\n            events = paginator.page(1)\n        except EmptyPage:\n            events = paginator.page(paginator.num_pages)\n\n        # Update context\n        context = super().get_context(request)\n        context['events'] = events\n        return context\n\n    def route(self, request, path_components):\n        if self.live and len(path_components) == 1:\n            try:\n                return self.serve(request, page=int(path_components[0]))\n            except (TypeError, ValueError):\n                pass\n\n        return super().route(request, path_components)\n\n    def get_static_site_paths(self):\n        # Get page count\n        page_count = self.get_paginator().num_pages\n\n        # Yield a path for each page\n        for page in range(page_count):\n            yield '/%d/' % (page + 1)\n\n        # Yield from superclass\n        for path in super().get_static_site_paths():\n            yield path\n\n    def get_sitemap_urls(self, request=None):\n        # Add past events url to sitemap\n        return super().get_sitemap_urls(request=request) + [\n            {\n                'location': self.full_url + 'past/',\n                'lastmod': self.latest_revision_created_at\n            }\n        ]\n\n    def get_cached_paths(self):\n        return super().get_cached_paths() + [\n            '/past/'\n        ]\n\n\nEventIndex.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('intro', classname=\"full\"),\n]\n\n\nclass FormField(AbstractFormField):\n    page = ParentalKey('FormPage', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass FormPage(AbstractEmailForm):\n    def get_context(self, request):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n\nFormPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# FormPage with a non-HTML extension\n\nclass JadeFormField(AbstractFormField):\n    page = ParentalKey('JadeFormPage', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass JadeFormPage(AbstractEmailForm):\n    template = \"tests/form_page.jade\"\n\n\nJadeFormPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# Form page that redirects to a different page\n\nclass RedirectFormField(AbstractFormField):\n    page = ParentalKey('FormPageWithRedirect', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass FormPageWithRedirect(AbstractEmailForm):\n    thank_you_redirect_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+',\n    )\n\n    def get_context(self, request):\n        context = super(FormPageWithRedirect, self).get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def render_landing_page(self, request, form_submission=None, *args, **kwargs):\n        \"\"\"\n        Renders the landing page OR if a receipt_page_redirect is chosen redirects to this page.\n        \"\"\"\n        if self.thank_you_redirect_page:\n            return redirect(self.thank_you_redirect_page.url, permanent=False)\n\n        return super(FormPageWithRedirect, self).render_landing_page(request, form_submission, *args, **kwargs)\n\n\nFormPageWithRedirect.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    PageChooserPanel('thank_you_redirect_page'),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# FormPage with a custom FormSubmission\n\nclass FormPageWithCustomSubmission(AbstractEmailForm):\n    \"\"\"\n    This Form page:\n        * Have custom submission model\n        * Have custom related_name (see `FormFieldWithCustomSubmission.page`)\n        * Saves reference to a user\n        * Doesn't render html form, if submission for current user is present\n    \"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    def get_context(self, request, *args, **kwargs):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def get_form_fields(self):\n        return self.custom_form_fields.all()\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def process_form_submission(self, form):\n        form_submission = self.get_submission_class().objects.create(\n            form_data=json.dumps(form.cleaned_data, cls=DjangoJSONEncoder),\n            page=self, user=form.user\n        )\n\n        if self.to_address:\n            addresses = [x.strip() for x in self.to_address.split(',')]\n            content = '\\n'.join([x[1].label + ': ' + str(form.data.get(x[0])) for x in form.fields.items()])\n            send_mail(self.subject, content, addresses, self.from_address,)\n\n        # process_form_submission should now return the created form_submission\n        return form_submission\n\n    def serve(self, request, *args, **kwargs):\n        if self.get_submission_class().objects.filter(page=self, user__pk=request.user.pk).exists():\n            return render(\n                request,\n                self.template,\n                self.get_context(request)\n            )\n\n        return super().serve(request, *args, **kwargs)\n\n\nFormPageWithCustomSubmission.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('intro', classname=\"full\"),\n    InlinePanel('custom_form_fields', label=\"Form fields\"),\n    FieldPanel('thank_you_text', classname=\"full\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\nclass FormFieldWithCustomSubmission(AbstractFormField):\n    page = ParentalKey(FormPageWithCustomSubmission, on_delete=models.CASCADE, related_name='custom_form_fields')\n\n\nclass CustomFormPageSubmission(AbstractFormSubmission):\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n\n    def get_data(self):\n        form_data = super().get_data()\n        form_data.update({\n            'username': self.user.username,\n        })\n\n        return form_data\n\n\n# Custom form page with custom submission listing view and form submission\n\nclass FormFieldForCustomListViewPage(AbstractFormField):\n    page = ParentalKey(\n        'FormPageWithCustomSubmissionListView',\n        related_name='form_fields',\n        on_delete=models.CASCADE\n    )\n\n\nclass FormPageWithCustomSubmissionListView(AbstractEmailForm):\n    \"\"\"Form Page with customised submissions listing view\"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    submissions_list_view_class = CustomSubmissionsListView\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('intro', classname=\"full\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        FieldPanel('thank_you_text', classname=\"full\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]\n\n\n# FormPage with cutom FormBuilder\n\nEXTENDED_CHOICES = FORM_FIELD_CHOICES + (('ipaddress', 'IP Address'),)\n\n\nclass ExtendedFormField(AbstractFormField):\n    \"\"\"Override the field_type field with extended choices.\"\"\"\n    page = ParentalKey(\n        'FormPageWithCustomFormBuilder',\n        related_name='form_fields',\n        on_delete=models.CASCADE)\n    field_type = models.CharField(\n        verbose_name='field type', max_length=16, choices=EXTENDED_CHOICES)\n\n\nclass CustomFormBuilder(FormBuilder):\n    \"\"\"\n    A custom FormBuilder that has an 'ipaddress' field with\n    customised create_singleline_field with shorter max_length\n    \"\"\"\n\n    def create_singleline_field(self, field, options):\n        options['max_length'] = 120  # usual default is 255\n        return forms.CharField(**options)\n\n    def create_ipaddress_field(self, field, options):\n        return forms.GenericIPAddressField(**options)\n\n\nclass FormPageWithCustomFormBuilder(AbstractEmailForm):\n    \"\"\"\n    A Form page that has a custom form builder and uses a custom\n    form field model with additional field_type choices.\n    \"\"\"\n\n    form_builder = CustomFormBuilder\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]\n\n\n# Snippets\nclass AdvertPlacement(models.Model):\n    page = ParentalKey('wagtailcore.Page', related_name='advert_placements', on_delete=models.CASCADE)\n    advert = models.ForeignKey('tests.Advert', related_name='+', on_delete=models.CASCADE)\n    colour = models.CharField(max_length=255)\n\n\nclass AdvertTag(TaggedItemBase):\n    content_object = ParentalKey('Advert', related_name='tagged_items', on_delete=models.CASCADE)\n\n\nclass Advert(ClusterableModel):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    tags = TaggableManager(through=AdvertTag, blank=True)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n        FieldPanel('tags'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(Advert)\n\n\nclass AdvertWithCustomPrimaryKey(ClusterableModel):\n    advert_id = models.CharField(max_length=255, primary_key=True)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(AdvertWithCustomPrimaryKey)\n\n\nclass AdvertWithCustomUUIDPrimaryKey(ClusterableModel):\n    advert_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(AdvertWithCustomUUIDPrimaryKey)\n\n\nclass AdvertWithTabbedInterface(models.Model):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n    something_else = models.CharField(max_length=255)\n\n    advert_panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    other_panels = [\n        FieldPanel('something_else'),\n    ]\n\n    edit_handler = TabbedInterface([\n        ObjectList(advert_panels, heading='Advert'),\n        ObjectList(other_panels, heading='Other'),\n    ])\n\n    def __str__(self):\n        return self.text\n\n    class Meta:\n        ordering = ('text',)\n\n\nregister_snippet(AdvertWithTabbedInterface)\n\n\nclass StandardIndex(Page):\n    \"\"\" Index for the site \"\"\"\n    parent_page_types = [Page]\n\n\n# A custom panel setup where all Promote fields are placed in the Content tab instead;\n# we use this to test that the 'promote' tab is left out of the output when empty\nStandardIndex.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('seo_title'),\n    FieldPanel('slug'),\n    InlinePanel('advert_placements', label=\"Adverts\"),\n]\nStandardIndex.promote_panels = []\n\n\nclass StandardChild(Page):\n    pass\n\n\n# Test overriding edit_handler with a custom one\nStandardChild.edit_handler = TabbedInterface([\n    ObjectList(StandardChild.content_panels, heading='Content'),\n    ObjectList(StandardChild.promote_panels, heading='Promote'),\n    ObjectList(StandardChild.settings_panels, heading='Settings', classname='settings'),\n    ObjectList([], heading='Dinosaurs'),\n], base_form_class=WagtailAdminPageForm)\n\n\nclass BusinessIndex(Page):\n    \"\"\" Can be placed anywhere, can only have Business children \"\"\"\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessSubIndex']\n\n\nclass BusinessSubIndex(Page):\n    \"\"\" Can be placed under BusinessIndex, and have BusinessChild children \"\"\"\n\n    # BusinessNowherePage is 'incorrectly' added here as a possible child.\n    # The rules on BusinessNowherePage prevent it from being a child here though.\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessNowherePage']\n    parent_page_types = ['tests.BusinessIndex', 'tests.BusinessChild']\n\n\nclass BusinessChild(Page):\n    \"\"\" Can only be placed under Business indexes, no children allowed \"\"\"\n    subpage_types = []\n    parent_page_types = ['tests.BusinessIndex', BusinessSubIndex]\n\n\nclass BusinessNowherePage(Page):\n    \"\"\" Not allowed to be placed anywhere \"\"\"\n    parent_page_types = []\n\n\nclass TaggedPageTag(TaggedItemBase):\n    content_object = ParentalKey('tests.TaggedPage', related_name='tagged_items', on_delete=models.CASCADE)\n\n\nclass TaggedPage(Page):\n    tags = ClusterTaggableManager(through=TaggedPageTag, blank=True)\n\n\nTaggedPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('tags'),\n]\n\n\nclass SingletonPage(Page):\n    @classmethod\n    def can_create_at(cls, parent):\n        # You can only create one of these!\n        return super(SingletonPage, cls).can_create_at(parent) \\\n            and not cls.objects.exists()\n\n\nclass SingletonPageViaMaxCount(Page):\n    max_count = 1\n\n\nclass PageChooserModel(models.Model):\n    page = models.ForeignKey('wagtailcore.Page', help_text='help text', on_delete=models.CASCADE)\n\n\nclass EventPageChooserModel(models.Model):\n    page = models.ForeignKey('tests.EventPage', help_text='more help text', on_delete=models.CASCADE)\n\n\nclass SnippetChooserModel(models.Model):\n    advert = models.ForeignKey(Advert, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advert'),\n    ]\n\n\nclass SnippetChooserModelWithCustomPrimaryKey(models.Model):\n    advertwithcustomprimarykey = models.ForeignKey(AdvertWithCustomPrimaryKey, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advertwithcustomprimarykey'),\n    ]\n\n\nclass CustomImage(AbstractImage):\n    caption = models.CharField(max_length=255, blank=True)\n    fancy_caption = RichTextField(blank=True)\n    not_editable_field = models.CharField(max_length=255, blank=True)\n\n    admin_form_fields = Image.admin_form_fields + (\n        'caption',\n        'fancy_caption',\n    )\n\n\nclass CustomRendition(AbstractRendition):\n    image = models.ForeignKey(CustomImage, related_name='renditions', on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            ('image', 'filter_spec', 'focal_point_key'),\n        )\n\n\nclass CustomDocument(AbstractDocument):\n    description = models.TextField(blank=True)\n    fancy_description = RichTextField(blank=True)\n    admin_form_fields = Document.admin_form_fields + (\n        'description',\n        'fancy_description'\n    )\n\n\nclass StreamModel(models.Model):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n\n\nclass ExtendedImageChooserBlock(ImageChooserBlock):\n    \"\"\"\n    Example of Block with custom get_api_representation method.\n    If the request has an 'extended' query param, it returns a dict of id and title,\n    otherwise, it returns the default value.\n    \"\"\"\n    def get_api_representation(self, value, context=None):\n        image_id = super().get_api_representation(value, context=context)\n        if 'request' in context and context['request'].query_params.get('extended', False):\n            return {\n                'id': image_id,\n                'title': value.title\n            }\n        return image_id\n\n\nclass StreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ExtendedImageChooserBlock()),\n        ('product', StructBlock([\n            ('name', CharBlock()),\n            ('price', CharBlock()),\n        ])),\n        ('raw_html', RawHTMLBlock()),\n    ])\n\n    api_fields = ('body',)\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass DefaultStreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ], default='')\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass MTIBasePage(Page):\n    is_creatable = False\n\n    class Meta:\n        verbose_name = \"MTI Base page\"\n\n\nclass MTIChildPage(MTIBasePage):\n    # Should be creatable by default, no need to set anything\n    pass\n\n\nclass AbstractPage(Page):\n    class Meta:\n        abstract = True\n\n\n@register_setting\nclass TestSetting(BaseSetting):\n    title = models.CharField(max_length=100)\n    email = models.EmailField(max_length=50)\n\n\n@register_setting(icon=\"tag\")\nclass IconSetting(BaseSetting):\n    pass\n\n\nclass NotYetRegisteredSetting(BaseSetting):\n    pass\n\n\n@register_setting\nclass FileUploadSetting(BaseSetting):\n    file = models.FileField()\n\n\nclass BlogCategory(models.Model):\n    name = models.CharField(unique=True, max_length=80)\n\n\nclass BlogCategoryBlogPage(models.Model):\n    category = models.ForeignKey(BlogCategory, related_name=\"+\", on_delete=models.CASCADE)\n    page = ParentalKey('ManyToManyBlogPage', related_name='categories', on_delete=models.CASCADE)\n    panels = [\n        FieldPanel('category'),\n    ]\n\n\nclass ManyToManyBlogPage(Page):\n    \"\"\"\n    A page type with two different kinds of M2M relation.\n    We don't formally support these, but we don't want them to cause\n    hard breakages either.\n    \"\"\"\n    body = RichTextField(blank=True)\n    adverts = models.ManyToManyField(Advert, blank=True)\n    blog_categories = models.ManyToManyField(\n        BlogCategory, through=BlogCategoryBlogPage, blank=True)\n\n    # make first_published_at editable on this page model\n    settings_panels = Page.settings_panels + [\n        FieldPanel('first_published_at'),\n    ]\n\n\nclass OneToOnePage(Page):\n    \"\"\"\n    A Page containing a O2O relation.\n    \"\"\"\n    body = RichTextBlock(blank=True)\n    page_ptr = models.OneToOneField(Page, parent_link=True,\n                                    related_name='+', on_delete=models.CASCADE)\n\n\nclass GenericSnippetPage(Page):\n    \"\"\"\n    A page containing a reference to an arbitrary snippet (or any model for that matter)\n    linked by a GenericForeignKey\n    \"\"\"\n    snippet_content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True)\n    snippet_object_id = models.PositiveIntegerField(null=True)\n    snippet_content_object = GenericForeignKey('snippet_content_type', 'snippet_object_id')\n\n\nclass CustomImageFilePath(AbstractImage):\n    def get_upload_to(self, filename):\n        \"\"\"Create a path that's file-system friendly.\n\n        By hashing the file's contents we guarantee an equal distribution\n        of files within our root directories. This also gives us a\n        better chance of uploading images with the same filename, but\n        different contents - this isn't guaranteed as we're only using\n        the first three characters of the checksum.\n        \"\"\"\n        original_filepath = super().get_upload_to(filename)\n        folder_name, filename = original_filepath.split(os.path.sep)\n\n        # Ensure that we consume the entire file, we can't guarantee that\n        # the stream has not be partially (or entirely) consumed by\n        # another process\n        original_position = self.file.tell()\n        self.file.seek(0)\n        hash256 = hashlib.sha256()\n\n        while True:\n            data = self.file.read(256)\n            if not data:\n                break\n            hash256.update(data)\n        checksum = hash256.hexdigest()\n\n        self.file.seek(original_position)\n        return os.path.join(folder_name, checksum[:3], filename)\n\n\nclass CustomPageQuerySet(PageQuerySet):\n    def about_spam(self):\n        return self.filter(title__contains='spam')\n\n\nCustomManager = PageManager.from_queryset(CustomPageQuerySet)\n\n\nclass CustomManagerPage(Page):\n    objects = CustomManager()\n\n\nclass MyBasePage(Page):\n    \"\"\"\n    A base Page model, used to set site-wide defaults and overrides.\n    \"\"\"\n    objects = CustomManager()\n\n    class Meta:\n        abstract = True\n\n\nclass MyCustomPage(MyBasePage):\n    pass\n\n\nclass ValidatedPage(Page):\n    foo = models.CharField(max_length=255)\n\n    base_form_class = ValidatedPageForm\n    content_panels = Page.content_panels + [\n        FieldPanel('foo'),\n    ]\n\n\nclass DefaultRichTextFieldPage(Page):\n    body = RichTextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\nclass DefaultRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock()),\n    ])\n\n    content_panels = Page.content_panels + [\n        StreamFieldPanel('body')\n    ]\n\n\nclass CustomRichTextFieldPage(Page):\n    body = RichTextField(editor='custom')\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\nclass CustomRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock(editor='custom')),\n    ])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass RichTextFieldWithFeaturesPage(Page):\n    body = RichTextField(features=['quotation', 'embed', 'made-up-feature'])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\n# a page that only contains RichTextField within an InlinePanel,\n# to test that the inline child's form media gets pulled through\nclass SectionedRichTextPageSection(Orderable):\n    page = ParentalKey('tests.SectionedRichTextPage', related_name='sections', on_delete=models.CASCADE)\n    body = RichTextField()\n\n    panels = [\n        FieldPanel('body')\n    ]\n\n\nclass SectionedRichTextPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]\n\n\nclass InlineStreamPageSection(Orderable):\n    page = ParentalKey('tests.InlineStreamPage', related_name='sections', on_delete=models.CASCADE)\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n    panels = [\n        StreamFieldPanel('body')\n    ]\n\n\nclass InlineStreamPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]\n\n\nclass TableBlockStreamPage(Page):\n    table = StreamField([('table', TableBlock())])\n\n    content_panels = [StreamFieldPanel('table')]\n\n\nclass UserProfile(models.Model):\n    # Wagtail's schema must be able to coexist alongside a custom UserProfile model\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    favourite_colour = models.CharField(max_length=255)\n\n\nclass PanelSettings(TestSetting):\n    panels = [\n        FieldPanel('title')\n    ]\n\n\nclass TabbedSettings(TestSetting):\n    edit_handler = TabbedInterface([\n        ObjectList([\n            FieldPanel('title')\n        ], heading='First tab'),\n        ObjectList([\n            FieldPanel('email')\n        ], heading='Second tab'),\n    ])\n\n\nclass AlwaysShowInMenusPage(Page):\n    show_in_menus_default = True\n\n\n# test for AddField migrations on StreamFields using various default values\nclass AddedStreamFieldWithoutDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ])\n\n\nclass AddedStreamFieldWithEmptyStringDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default='')\n\n\nclass AddedStreamFieldWithEmptyListDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default=[])\n\n\n# test customising edit handler definitions on a per-request basis\nclass PerUserContentPanels(ObjectList):\n    def _replace_children_with_per_user_config(self):\n        self.children = self.instance.basic_content_panels\n        if self.request.user.is_superuser:\n            self.children = self.instance.superuser_content_panels\n        self.children = [\n            child.bind_to(model=self.model, instance=self.instance,\n                          request=self.request, form=self.form)\n            for child in self.children]\n\n    def on_instance_bound(self):\n        # replace list of children when both instance and request are available\n        if self.request:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_instance_bound()\n\n    def on_request_bound(self):\n        # replace list of children when both instance and request are available\n        if self.instance:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_request_bound()\n\n\nclass PerUserPageMixin:\n    basic_content_panels = []\n    superuser_content_panels = []\n\n    @cached_classmethod\n    def get_edit_handler(cls):\n        tabs = []\n\n        if cls.basic_content_panels and cls.superuser_content_panels:\n            tabs.append(PerUserContentPanels(heading='Content'))\n        if cls.promote_panels:\n            tabs.append(ObjectList(cls.promote_panels,\n                                   heading='Promote'))\n        if cls.settings_panels:\n            tabs.append(ObjectList(cls.settings_panels,\n                                   heading='Settings',\n                                   classname='settings'))\n\n        edit_handler = TabbedInterface(tabs,\n                                       base_form_class=cls.base_form_class)\n\n        return edit_handler.bind_to(model=cls)\n\n\nclass SecretPage(PerUserPageMixin, Page):\n    boring_data = models.TextField()\n    secret_data = models.TextField()\n\n    basic_content_panels = Page.content_panels + [\n        FieldPanel('boring_data'),\n    ]\n    superuser_content_panels = basic_content_panels + [\n        FieldPanel('secret_data'),\n    ]\n\n\nclass SimpleParentPage(Page):\n    # `BusinessIndex` has been added to bring it in line with other tests\n    subpage_types = ['tests.SimpleChildPage', BusinessIndex]\n\n\nclass SimpleChildPage(Page):\n    # `Page` has been added to bring it in line with other tests\n    parent_page_types = ['tests.SimpleParentPage', Page]\n\n    max_count_per_parent = 1\n\n\nclass PersonPage(Page):\n    first_name = models.CharField(\n        max_length=255,\n        verbose_name='First Name',\n    )\n    last_name = models.CharField(\n        max_length=255,\n        verbose_name='Last Name',\n    )\n\n    content_panels = Page.content_panels + [\n        MultiFieldPanel([\n            FieldPanel('first_name'),\n            FieldPanel('last_name'),\n        ], 'Person'),\n        InlinePanel('addresses', label='Address'),\n    ]\n\n    class Meta:\n        verbose_name = 'Person'\n        verbose_name_plural = 'Persons'\n\n\nclass Address(index.Indexed, ClusterableModel, Orderable):\n    address = models.CharField(\n        max_length=255,\n        verbose_name='Address',\n    )\n    tags = ClusterTaggableManager(\n        through='tests.AddressTag',\n        blank=True,\n    )\n    person = ParentalKey(\n        to='tests.PersonPage',\n        related_name='addresses',\n        verbose_name='Person'\n    )\n\n    panels = [\n        FieldPanel('address'),\n        FieldPanel('tags'),\n    ]\n\n    class Meta:\n        verbose_name = 'Address'\n        verbose_name_plural = 'Addresses'\n\n\nclass AddressTag(TaggedItemBase):\n    content_object = ParentalKey(\n        to='tests.Address',\n        on_delete=models.CASCADE,\n        related_name='tagged_items'\n    )\n", "code_before": "import hashlib\nimport json\nimport os\nimport uuid\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.core.paginator import EmptyPage, PageNotAnInteger, Paginator\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.db import models\nfrom django.shortcuts import redirect, render\nfrom modelcluster.contrib.taggit import ClusterTaggableManager\nfrom modelcluster.fields import ParentalKey, ParentalManyToManyField\nfrom modelcluster.models import ClusterableModel\nfrom taggit.managers import TaggableManager\nfrom taggit.models import TaggedItemBase\n\nfrom wagtail.admin.edit_handlers import (\n    FieldPanel, InlinePanel, MultiFieldPanel, ObjectList, PageChooserPanel, StreamFieldPanel,\n    TabbedInterface)\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.admin.mail import send_mail\nfrom wagtail.contrib.forms.forms import FormBuilder\nfrom wagtail.contrib.forms.models import (\n    FORM_FIELD_CHOICES, AbstractEmailForm, AbstractFormField, AbstractFormSubmission)\nfrom wagtail.contrib.settings.models import BaseSetting, register_setting\nfrom wagtail.contrib.sitemaps import Sitemap\nfrom wagtail.contrib.table_block.blocks import TableBlock\nfrom wagtail.core.blocks import CharBlock, RichTextBlock, StructBlock\nfrom wagtail.core.fields import RichTextField, StreamField\nfrom wagtail.core.models import Orderable, Page, PageManager, PageQuerySet\nfrom wagtail.documents.edit_handlers import DocumentChooserPanel\nfrom wagtail.documents.models import AbstractDocument, Document\nfrom wagtail.images.blocks import ImageChooserBlock\nfrom wagtail.images.edit_handlers import ImageChooserPanel\nfrom wagtail.images.models import AbstractImage, AbstractRendition, Image\nfrom wagtail.search import index\nfrom wagtail.snippets.edit_handlers import SnippetChooserPanel\nfrom wagtail.snippets.models import register_snippet\nfrom wagtail.utils.decorators import cached_classmethod\n\nfrom .forms import FormClassAdditionalFieldPageForm, ValidatedPageForm\nfrom .views import CustomSubmissionsListView\n\nEVENT_AUDIENCE_CHOICES = (\n    ('public', \"Public\"),\n    ('private', \"Private\"),\n)\n\n\nCOMMON_PANELS = (\n    FieldPanel('slug'),\n    FieldPanel('seo_title'),\n    FieldPanel('show_in_menus'),\n    FieldPanel('search_description'),\n)\n\n\n# Link fields\n\nclass LinkFields(models.Model):\n    link_external = models.URLField(\"External link\", blank=True)\n    link_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n    link_document = models.ForeignKey(\n        'wagtaildocs.Document',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n\n    @property\n    def link(self):\n        if self.link_page:\n            return self.link_page.url\n        elif self.link_document:\n            return self.link_document.url\n        else:\n            return self.link_external\n\n    panels = [\n        FieldPanel('link_external'),\n        PageChooserPanel('link_page'),\n        DocumentChooserPanel('link_document'),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Carousel items\n\nclass CarouselItem(LinkFields):\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    embed_url = models.URLField(\"Embed URL\", blank=True)\n    caption = models.CharField(max_length=255, blank=True)\n\n    panels = [\n        ImageChooserPanel('image'),\n        FieldPanel('embed_url'),\n        FieldPanel('caption'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Related links\n\nclass RelatedLink(LinkFields):\n    title = models.CharField(max_length=255, help_text=\"Link title\")\n\n    panels = [\n        FieldPanel('title'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True\n\n\n# Simple page\nclass SimplePage(Page):\n    content = models.TextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('content'),\n    ]\n\n    def get_admin_display_title(self):\n        return \"%s (simple page)\" % super().get_admin_display_title()\n\n\n# Page with Excluded Fields when copied\nclass PageWithExcludedCopyField(Page):\n    content = models.TextField()\n\n    # Exclude this field from being copied\n    special_field = models.CharField(\n        blank=True, max_length=255, default='Very Special')\n    exclude_fields_in_copy = ['special_field']\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('special_field'),\n        FieldPanel('content'),\n    ]\n\n\nclass PageWithOldStyleRouteMethod(Page):\n    \"\"\"\n    Prior to Wagtail 0.4, the route() method on Page returned an HttpResponse\n    rather than a Page instance. As subclasses of Page may override route,\n    we need to continue accepting this convention (albeit as a deprecated API).\n    \"\"\"\n    content = models.TextField()\n    template = 'tests/simple_page.html'\n\n    def route(self, request, path_components):\n        return self.serve(request)\n\n\n# File page\nclass FilePage(Page):\n    file_field = models.FileField()\n\n\nFilePage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('file_field'),\n]\n\n\n# Event page\n\nclass EventPageCarouselItem(Orderable, CarouselItem):\n    page = ParentalKey('tests.EventPage', related_name='carousel_items', on_delete=models.CASCADE)\n\n\nclass EventPageRelatedLink(Orderable, RelatedLink):\n    page = ParentalKey('tests.EventPage', related_name='related_links', on_delete=models.CASCADE)\n\n\nclass EventPageSpeakerAward(Orderable, models.Model):\n    speaker = ParentalKey('tests.EventPageSpeaker', related_name='awards', on_delete=models.CASCADE)\n    name = models.CharField(\"Award name\", max_length=255)\n    date_awarded = models.DateField(null=True, blank=True)\n\n    panels = [\n        FieldPanel('name'),\n        FieldPanel('date_awarded'),\n    ]\n\n\nclass EventPageSpeaker(Orderable, LinkFields, ClusterableModel):\n    page = ParentalKey('tests.EventPage', related_name='speakers', related_query_name='speaker', on_delete=models.CASCADE)\n    first_name = models.CharField(\"Name\", max_length=255, blank=True)\n    last_name = models.CharField(\"Surname\", max_length=255, blank=True)\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n\n    @property\n    def name_display(self):\n        return self.first_name + \" \" + self.last_name\n\n    panels = [\n        FieldPanel('first_name'),\n        FieldPanel('last_name'),\n        ImageChooserPanel('image'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n        InlinePanel('awards', label=\"Awards\"),\n    ]\n\n\nclass EventCategory(models.Model):\n    name = models.CharField(\"Name\", max_length=255)\n\n    def __str__(self):\n        return self.name\n\n\n# Override the standard WagtailAdminPageForm to add validation on start/end dates\n# that appears as a non-field error\n\nclass EventPageForm(WagtailAdminPageForm):\n    def clean(self):\n        cleaned_data = super().clean()\n\n        # Make sure that the event starts before it ends\n        start_date = cleaned_data['date_from']\n        end_date = cleaned_data['date_to']\n        if start_date and end_date and start_date > end_date:\n            raise ValidationError('The end date must be after the start date')\n\n        return cleaned_data\n\n\nclass EventPage(Page):\n    date_from = models.DateField(\"Start date\", null=True)\n    date_to = models.DateField(\n        \"End date\",\n        null=True,\n        blank=True,\n        help_text=\"Not required if event is on a single day\"\n    )\n    time_from = models.TimeField(\"Start time\", null=True, blank=True)\n    time_to = models.TimeField(\"End time\", null=True, blank=True)\n    audience = models.CharField(max_length=255, choices=EVENT_AUDIENCE_CHOICES)\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n    cost = models.CharField(max_length=255)\n    signup_link = models.URLField(blank=True)\n    feed_image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    categories = ParentalManyToManyField(EventCategory, blank=True)\n\n    search_fields = [\n        index.SearchField('get_audience_display'),\n        index.SearchField('location'),\n        index.SearchField('body'),\n        index.FilterField('url_path'),\n    ]\n\n    password_required_template = 'tests/event_page_password_required.html'\n    base_form_class = EventPageForm\n\n\nEventPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('date_from'),\n    FieldPanel('date_to'),\n    FieldPanel('time_from'),\n    FieldPanel('time_to'),\n    FieldPanel('location'),\n    FieldPanel('audience'),\n    FieldPanel('cost'),\n    FieldPanel('signup_link'),\n    InlinePanel('carousel_items', label=\"Carousel items\"),\n    FieldPanel('body', classname=\"full\"),\n    InlinePanel('speakers', label=\"Speakers\", heading=\"Speaker lineup\"),\n    InlinePanel('related_links', label=\"Related links\"),\n    FieldPanel('categories'),\n    # InlinePanel related model uses `pk` not `id`\n    InlinePanel('head_counts', label='Head Counts'),\n]\n\nEventPage.promote_panels = [\n    MultiFieldPanel(COMMON_PANELS, \"Common page configuration\"),\n    ImageChooserPanel('feed_image'),\n]\n\n\nclass HeadCountRelatedModelUsingPK(models.Model):\n    \"\"\"Related model that uses a custom primary key (pk) not id\"\"\"\n    custom_id = models.AutoField(primary_key=True)\n    event_page = ParentalKey(\n        EventPage,\n        on_delete=models.CASCADE,\n        related_name='head_counts'\n    )\n    head_count = models.IntegerField()\n    panels = [FieldPanel('head_count')]\n\n\n# Override the standard WagtailAdminPageForm to add field that is not in model\n# so that we can test additional potential issues like comparing versions\nclass FormClassAdditionalFieldPage(Page):\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('location'),\n        FieldPanel('body'),\n        FieldPanel('code'),  # not in model, see set base_form_class\n    ]\n\n    base_form_class = FormClassAdditionalFieldPageForm\n\n\n# Just to be able to test multi table inheritance\nclass SingleEventPage(EventPage):\n    excerpt = models.TextField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=\"Short text to describe what is this action about\"\n    )\n\n    # Give this page model a custom URL routing scheme\n    def get_url_parts(self, request=None):\n        url_parts = super().get_url_parts(request=request)\n        if url_parts is None:\n            return None\n        else:\n            site_id, root_url, page_path = url_parts\n            return (site_id, root_url, page_path + 'pointless-suffix/')\n\n    def route(self, request, path_components):\n        if path_components == ['pointless-suffix']:\n            # treat this as equivalent to a request for this page\n            return super().route(request, [])\n        else:\n            # fall back to default routing rules\n            return super().route(request, path_components)\n\n    def get_admin_display_title(self):\n        return \"%s (single event)\" % super().get_admin_display_title()\n\n\nSingleEventPage.content_panels = [FieldPanel('excerpt')] + EventPage.content_panels\n\n\n# \"custom\" sitemap object\nclass EventSitemap(Sitemap):\n    pass\n\n\n# Event index (has a separate AJAX template, and a custom template context)\nclass EventIndex(Page):\n    intro = RichTextField(blank=True)\n    ajax_template = 'tests/includes/event_listing.html'\n\n    def get_events(self):\n        return self.get_children().live().type(EventPage)\n\n    def get_paginator(self):\n        return Paginator(self.get_events(), 4)\n\n    def get_context(self, request, page=1):\n        # Pagination\n        paginator = self.get_paginator()\n        try:\n            events = paginator.page(page)\n        except PageNotAnInteger:\n            events = paginator.page(1)\n        except EmptyPage:\n            events = paginator.page(paginator.num_pages)\n\n        # Update context\n        context = super().get_context(request)\n        context['events'] = events\n        return context\n\n    def route(self, request, path_components):\n        if self.live and len(path_components) == 1:\n            try:\n                return self.serve(request, page=int(path_components[0]))\n            except (TypeError, ValueError):\n                pass\n\n        return super().route(request, path_components)\n\n    def get_static_site_paths(self):\n        # Get page count\n        page_count = self.get_paginator().num_pages\n\n        # Yield a path for each page\n        for page in range(page_count):\n            yield '/%d/' % (page + 1)\n\n        # Yield from superclass\n        for path in super().get_static_site_paths():\n            yield path\n\n    def get_sitemap_urls(self, request=None):\n        # Add past events url to sitemap\n        return super().get_sitemap_urls(request=request) + [\n            {\n                'location': self.full_url + 'past/',\n                'lastmod': self.latest_revision_created_at\n            }\n        ]\n\n    def get_cached_paths(self):\n        return super().get_cached_paths() + [\n            '/past/'\n        ]\n\n\nEventIndex.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('intro', classname=\"full\"),\n]\n\n\nclass FormField(AbstractFormField):\n    page = ParentalKey('FormPage', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass FormPage(AbstractEmailForm):\n    def get_context(self, request):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n\nFormPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# FormPage with a non-HTML extension\n\nclass JadeFormField(AbstractFormField):\n    page = ParentalKey('JadeFormPage', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass JadeFormPage(AbstractEmailForm):\n    template = \"tests/form_page.jade\"\n\n\nJadeFormPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# Form page that redirects to a different page\n\nclass RedirectFormField(AbstractFormField):\n    page = ParentalKey('FormPageWithRedirect', related_name='form_fields', on_delete=models.CASCADE)\n\n\nclass FormPageWithRedirect(AbstractEmailForm):\n    thank_you_redirect_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+',\n    )\n\n    def get_context(self, request):\n        context = super(FormPageWithRedirect, self).get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def render_landing_page(self, request, form_submission=None, *args, **kwargs):\n        \"\"\"\n        Renders the landing page OR if a receipt_page_redirect is chosen redirects to this page.\n        \"\"\"\n        if self.thank_you_redirect_page:\n            return redirect(self.thank_you_redirect_page.url, permanent=False)\n\n        return super(FormPageWithRedirect, self).render_landing_page(request, form_submission, *args, **kwargs)\n\n\nFormPageWithRedirect.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    PageChooserPanel('thank_you_redirect_page'),\n    InlinePanel('form_fields', label=\"Form fields\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\n# FormPage with a custom FormSubmission\n\nclass FormPageWithCustomSubmission(AbstractEmailForm):\n    \"\"\"\n    This Form page:\n        * Have custom submission model\n        * Have custom related_name (see `FormFieldWithCustomSubmission.page`)\n        * Saves reference to a user\n        * Doesn't render html form, if submission for current user is present\n    \"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    def get_context(self, request, *args, **kwargs):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def get_form_fields(self):\n        return self.custom_form_fields.all()\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def process_form_submission(self, form):\n        form_submission = self.get_submission_class().objects.create(\n            form_data=json.dumps(form.cleaned_data, cls=DjangoJSONEncoder),\n            page=self, user=form.user\n        )\n\n        if self.to_address:\n            addresses = [x.strip() for x in self.to_address.split(',')]\n            content = '\\n'.join([x[1].label + ': ' + str(form.data.get(x[0])) for x in form.fields.items()])\n            send_mail(self.subject, content, addresses, self.from_address,)\n\n        # process_form_submission should now return the created form_submission\n        return form_submission\n\n    def serve(self, request, *args, **kwargs):\n        if self.get_submission_class().objects.filter(page=self, user__pk=request.user.pk).exists():\n            return render(\n                request,\n                self.template,\n                self.get_context(request)\n            )\n\n        return super().serve(request, *args, **kwargs)\n\n\nFormPageWithCustomSubmission.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('intro', classname=\"full\"),\n    InlinePanel('custom_form_fields', label=\"Form fields\"),\n    FieldPanel('thank_you_text', classname=\"full\"),\n    MultiFieldPanel([\n        FieldPanel('to_address', classname=\"full\"),\n        FieldPanel('from_address', classname=\"full\"),\n        FieldPanel('subject', classname=\"full\"),\n    ], \"Email\")\n]\n\n\nclass FormFieldWithCustomSubmission(AbstractFormField):\n    page = ParentalKey(FormPageWithCustomSubmission, on_delete=models.CASCADE, related_name='custom_form_fields')\n\n\nclass CustomFormPageSubmission(AbstractFormSubmission):\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n\n    def get_data(self):\n        form_data = super().get_data()\n        form_data.update({\n            'username': self.user.username,\n        })\n\n        return form_data\n\n\n# Custom form page with custom submission listing view and form submission\n\nclass FormFieldForCustomListViewPage(AbstractFormField):\n    page = ParentalKey(\n        'FormPageWithCustomSubmissionListView',\n        related_name='form_fields',\n        on_delete=models.CASCADE\n    )\n\n\nclass FormPageWithCustomSubmissionListView(AbstractEmailForm):\n    \"\"\"Form Page with customised submissions listing view\"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    submissions_list_view_class = CustomSubmissionsListView\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('intro', classname=\"full\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        FieldPanel('thank_you_text', classname=\"full\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]\n\n\n# FormPage with cutom FormBuilder\n\nEXTENDED_CHOICES = FORM_FIELD_CHOICES + (('ipaddress', 'IP Address'),)\n\n\nclass ExtendedFormField(AbstractFormField):\n    \"\"\"Override the field_type field with extended choices.\"\"\"\n    page = ParentalKey(\n        'FormPageWithCustomFormBuilder',\n        related_name='form_fields',\n        on_delete=models.CASCADE)\n    field_type = models.CharField(\n        verbose_name='field type', max_length=16, choices=EXTENDED_CHOICES)\n\n\nclass CustomFormBuilder(FormBuilder):\n    \"\"\"\n    A custom FormBuilder that has an 'ipaddress' field with\n    customised create_singleline_field with shorter max_length\n    \"\"\"\n\n    def create_singleline_field(self, field, options):\n        options['max_length'] = 120  # usual default is 255\n        return forms.CharField(**options)\n\n    def create_ipaddress_field(self, field, options):\n        return forms.GenericIPAddressField(**options)\n\n\nclass FormPageWithCustomFormBuilder(AbstractEmailForm):\n    \"\"\"\n    A Form page that has a custom form builder and uses a custom\n    form field model with additional field_type choices.\n    \"\"\"\n\n    form_builder = CustomFormBuilder\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]\n\n\n# Snippets\nclass AdvertPlacement(models.Model):\n    page = ParentalKey('wagtailcore.Page', related_name='advert_placements', on_delete=models.CASCADE)\n    advert = models.ForeignKey('tests.Advert', related_name='+', on_delete=models.CASCADE)\n    colour = models.CharField(max_length=255)\n\n\nclass AdvertTag(TaggedItemBase):\n    content_object = ParentalKey('Advert', related_name='tagged_items', on_delete=models.CASCADE)\n\n\nclass Advert(ClusterableModel):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    tags = TaggableManager(through=AdvertTag, blank=True)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n        FieldPanel('tags'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(Advert)\n\n\nclass AdvertWithCustomPrimaryKey(ClusterableModel):\n    advert_id = models.CharField(max_length=255, primary_key=True)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(AdvertWithCustomPrimaryKey)\n\n\nclass AdvertWithCustomUUIDPrimaryKey(ClusterableModel):\n    advert_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text\n\n\nregister_snippet(AdvertWithCustomUUIDPrimaryKey)\n\n\nclass AdvertWithTabbedInterface(models.Model):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n    something_else = models.CharField(max_length=255)\n\n    advert_panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    other_panels = [\n        FieldPanel('something_else'),\n    ]\n\n    edit_handler = TabbedInterface([\n        ObjectList(advert_panels, heading='Advert'),\n        ObjectList(other_panels, heading='Other'),\n    ])\n\n    def __str__(self):\n        return self.text\n\n    class Meta:\n        ordering = ('text',)\n\n\nregister_snippet(AdvertWithTabbedInterface)\n\n\nclass StandardIndex(Page):\n    \"\"\" Index for the site \"\"\"\n    parent_page_types = [Page]\n\n\n# A custom panel setup where all Promote fields are placed in the Content tab instead;\n# we use this to test that the 'promote' tab is left out of the output when empty\nStandardIndex.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('seo_title'),\n    FieldPanel('slug'),\n    InlinePanel('advert_placements', label=\"Adverts\"),\n]\nStandardIndex.promote_panels = []\n\n\nclass StandardChild(Page):\n    pass\n\n\n# Test overriding edit_handler with a custom one\nStandardChild.edit_handler = TabbedInterface([\n    ObjectList(StandardChild.content_panels, heading='Content'),\n    ObjectList(StandardChild.promote_panels, heading='Promote'),\n    ObjectList(StandardChild.settings_panels, heading='Settings', classname='settings'),\n    ObjectList([], heading='Dinosaurs'),\n], base_form_class=WagtailAdminPageForm)\n\n\nclass BusinessIndex(Page):\n    \"\"\" Can be placed anywhere, can only have Business children \"\"\"\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessSubIndex']\n\n\nclass BusinessSubIndex(Page):\n    \"\"\" Can be placed under BusinessIndex, and have BusinessChild children \"\"\"\n\n    # BusinessNowherePage is 'incorrectly' added here as a possible child.\n    # The rules on BusinessNowherePage prevent it from being a child here though.\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessNowherePage']\n    parent_page_types = ['tests.BusinessIndex', 'tests.BusinessChild']\n\n\nclass BusinessChild(Page):\n    \"\"\" Can only be placed under Business indexes, no children allowed \"\"\"\n    subpage_types = []\n    parent_page_types = ['tests.BusinessIndex', BusinessSubIndex]\n\n\nclass BusinessNowherePage(Page):\n    \"\"\" Not allowed to be placed anywhere \"\"\"\n    parent_page_types = []\n\n\nclass TaggedPageTag(TaggedItemBase):\n    content_object = ParentalKey('tests.TaggedPage', related_name='tagged_items', on_delete=models.CASCADE)\n\n\nclass TaggedPage(Page):\n    tags = ClusterTaggableManager(through=TaggedPageTag, blank=True)\n\n\nTaggedPage.content_panels = [\n    FieldPanel('title', classname=\"full title\"),\n    FieldPanel('tags'),\n]\n\n\nclass SingletonPage(Page):\n    @classmethod\n    def can_create_at(cls, parent):\n        # You can only create one of these!\n        return super(SingletonPage, cls).can_create_at(parent) \\\n            and not cls.objects.exists()\n\n\nclass SingletonPageViaMaxCount(Page):\n    max_count = 1\n\n\nclass PageChooserModel(models.Model):\n    page = models.ForeignKey('wagtailcore.Page', help_text='help text', on_delete=models.CASCADE)\n\n\nclass EventPageChooserModel(models.Model):\n    page = models.ForeignKey('tests.EventPage', help_text='more help text', on_delete=models.CASCADE)\n\n\nclass SnippetChooserModel(models.Model):\n    advert = models.ForeignKey(Advert, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advert'),\n    ]\n\n\nclass SnippetChooserModelWithCustomPrimaryKey(models.Model):\n    advertwithcustomprimarykey = models.ForeignKey(AdvertWithCustomPrimaryKey, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advertwithcustomprimarykey'),\n    ]\n\n\nclass CustomImage(AbstractImage):\n    caption = models.CharField(max_length=255, blank=True)\n    fancy_caption = RichTextField(blank=True)\n    not_editable_field = models.CharField(max_length=255, blank=True)\n\n    admin_form_fields = Image.admin_form_fields + (\n        'caption',\n        'fancy_caption',\n    )\n\n\nclass CustomRendition(AbstractRendition):\n    image = models.ForeignKey(CustomImage, related_name='renditions', on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            ('image', 'filter_spec', 'focal_point_key'),\n        )\n\n\nclass CustomDocument(AbstractDocument):\n    description = models.TextField(blank=True)\n    fancy_description = RichTextField(blank=True)\n    admin_form_fields = Document.admin_form_fields + (\n        'description',\n        'fancy_description'\n    )\n\n\nclass StreamModel(models.Model):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n\n\nclass ExtendedImageChooserBlock(ImageChooserBlock):\n    \"\"\"\n    Example of Block with custom get_api_representation method.\n    If the request has an 'extended' query param, it returns a dict of id and title,\n    otherwise, it returns the default value.\n    \"\"\"\n    def get_api_representation(self, value, context=None):\n        image_id = super().get_api_representation(value, context=context)\n        if 'request' in context and context['request'].query_params.get('extended', False):\n            return {\n                'id': image_id,\n                'title': value.title\n            }\n        return image_id\n\n\nclass StreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ExtendedImageChooserBlock()),\n        ('product', StructBlock([\n            ('name', CharBlock()),\n            ('price', CharBlock()),\n        ])),\n    ])\n\n    api_fields = ('body',)\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass DefaultStreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ], default='')\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass MTIBasePage(Page):\n    is_creatable = False\n\n    class Meta:\n        verbose_name = \"MTI Base page\"\n\n\nclass MTIChildPage(MTIBasePage):\n    # Should be creatable by default, no need to set anything\n    pass\n\n\nclass AbstractPage(Page):\n    class Meta:\n        abstract = True\n\n\n@register_setting\nclass TestSetting(BaseSetting):\n    title = models.CharField(max_length=100)\n    email = models.EmailField(max_length=50)\n\n\n@register_setting(icon=\"tag\")\nclass IconSetting(BaseSetting):\n    pass\n\n\nclass NotYetRegisteredSetting(BaseSetting):\n    pass\n\n\n@register_setting\nclass FileUploadSetting(BaseSetting):\n    file = models.FileField()\n\n\nclass BlogCategory(models.Model):\n    name = models.CharField(unique=True, max_length=80)\n\n\nclass BlogCategoryBlogPage(models.Model):\n    category = models.ForeignKey(BlogCategory, related_name=\"+\", on_delete=models.CASCADE)\n    page = ParentalKey('ManyToManyBlogPage', related_name='categories', on_delete=models.CASCADE)\n    panels = [\n        FieldPanel('category'),\n    ]\n\n\nclass ManyToManyBlogPage(Page):\n    \"\"\"\n    A page type with two different kinds of M2M relation.\n    We don't formally support these, but we don't want them to cause\n    hard breakages either.\n    \"\"\"\n    body = RichTextField(blank=True)\n    adverts = models.ManyToManyField(Advert, blank=True)\n    blog_categories = models.ManyToManyField(\n        BlogCategory, through=BlogCategoryBlogPage, blank=True)\n\n    # make first_published_at editable on this page model\n    settings_panels = Page.settings_panels + [\n        FieldPanel('first_published_at'),\n    ]\n\n\nclass OneToOnePage(Page):\n    \"\"\"\n    A Page containing a O2O relation.\n    \"\"\"\n    body = RichTextBlock(blank=True)\n    page_ptr = models.OneToOneField(Page, parent_link=True,\n                                    related_name='+', on_delete=models.CASCADE)\n\n\nclass GenericSnippetPage(Page):\n    \"\"\"\n    A page containing a reference to an arbitrary snippet (or any model for that matter)\n    linked by a GenericForeignKey\n    \"\"\"\n    snippet_content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True)\n    snippet_object_id = models.PositiveIntegerField(null=True)\n    snippet_content_object = GenericForeignKey('snippet_content_type', 'snippet_object_id')\n\n\nclass CustomImageFilePath(AbstractImage):\n    def get_upload_to(self, filename):\n        \"\"\"Create a path that's file-system friendly.\n\n        By hashing the file's contents we guarantee an equal distribution\n        of files within our root directories. This also gives us a\n        better chance of uploading images with the same filename, but\n        different contents - this isn't guaranteed as we're only using\n        the first three characters of the checksum.\n        \"\"\"\n        original_filepath = super().get_upload_to(filename)\n        folder_name, filename = original_filepath.split(os.path.sep)\n\n        # Ensure that we consume the entire file, we can't guarantee that\n        # the stream has not be partially (or entirely) consumed by\n        # another process\n        original_position = self.file.tell()\n        self.file.seek(0)\n        hash256 = hashlib.sha256()\n\n        while True:\n            data = self.file.read(256)\n            if not data:\n                break\n            hash256.update(data)\n        checksum = hash256.hexdigest()\n\n        self.file.seek(original_position)\n        return os.path.join(folder_name, checksum[:3], filename)\n\n\nclass CustomPageQuerySet(PageQuerySet):\n    def about_spam(self):\n        return self.filter(title__contains='spam')\n\n\nCustomManager = PageManager.from_queryset(CustomPageQuerySet)\n\n\nclass CustomManagerPage(Page):\n    objects = CustomManager()\n\n\nclass MyBasePage(Page):\n    \"\"\"\n    A base Page model, used to set site-wide defaults and overrides.\n    \"\"\"\n    objects = CustomManager()\n\n    class Meta:\n        abstract = True\n\n\nclass MyCustomPage(MyBasePage):\n    pass\n\n\nclass ValidatedPage(Page):\n    foo = models.CharField(max_length=255)\n\n    base_form_class = ValidatedPageForm\n    content_panels = Page.content_panels + [\n        FieldPanel('foo'),\n    ]\n\n\nclass DefaultRichTextFieldPage(Page):\n    body = RichTextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\nclass DefaultRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock()),\n    ])\n\n    content_panels = Page.content_panels + [\n        StreamFieldPanel('body')\n    ]\n\n\nclass CustomRichTextFieldPage(Page):\n    body = RichTextField(editor='custom')\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\nclass CustomRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock(editor='custom')),\n    ])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        StreamFieldPanel('body'),\n    ]\n\n\nclass RichTextFieldWithFeaturesPage(Page):\n    body = RichTextField(features=['quotation', 'embed', 'made-up-feature'])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]\n\n\n# a page that only contains RichTextField within an InlinePanel,\n# to test that the inline child's form media gets pulled through\nclass SectionedRichTextPageSection(Orderable):\n    page = ParentalKey('tests.SectionedRichTextPage', related_name='sections', on_delete=models.CASCADE)\n    body = RichTextField()\n\n    panels = [\n        FieldPanel('body')\n    ]\n\n\nclass SectionedRichTextPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]\n\n\nclass InlineStreamPageSection(Orderable):\n    page = ParentalKey('tests.InlineStreamPage', related_name='sections', on_delete=models.CASCADE)\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n    panels = [\n        StreamFieldPanel('body')\n    ]\n\n\nclass InlineStreamPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]\n\n\nclass TableBlockStreamPage(Page):\n    table = StreamField([('table', TableBlock())])\n\n    content_panels = [StreamFieldPanel('table')]\n\n\nclass UserProfile(models.Model):\n    # Wagtail's schema must be able to coexist alongside a custom UserProfile model\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    favourite_colour = models.CharField(max_length=255)\n\n\nclass PanelSettings(TestSetting):\n    panels = [\n        FieldPanel('title')\n    ]\n\n\nclass TabbedSettings(TestSetting):\n    edit_handler = TabbedInterface([\n        ObjectList([\n            FieldPanel('title')\n        ], heading='First tab'),\n        ObjectList([\n            FieldPanel('email')\n        ], heading='Second tab'),\n    ])\n\n\nclass AlwaysShowInMenusPage(Page):\n    show_in_menus_default = True\n\n\n# test for AddField migrations on StreamFields using various default values\nclass AddedStreamFieldWithoutDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ])\n\n\nclass AddedStreamFieldWithEmptyStringDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default='')\n\n\nclass AddedStreamFieldWithEmptyListDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default=[])\n\n\n# test customising edit handler definitions on a per-request basis\nclass PerUserContentPanels(ObjectList):\n    def _replace_children_with_per_user_config(self):\n        self.children = self.instance.basic_content_panels\n        if self.request.user.is_superuser:\n            self.children = self.instance.superuser_content_panels\n        self.children = [\n            child.bind_to(model=self.model, instance=self.instance,\n                          request=self.request, form=self.form)\n            for child in self.children]\n\n    def on_instance_bound(self):\n        # replace list of children when both instance and request are available\n        if self.request:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_instance_bound()\n\n    def on_request_bound(self):\n        # replace list of children when both instance and request are available\n        if self.instance:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_request_bound()\n\n\nclass PerUserPageMixin:\n    basic_content_panels = []\n    superuser_content_panels = []\n\n    @cached_classmethod\n    def get_edit_handler(cls):\n        tabs = []\n\n        if cls.basic_content_panels and cls.superuser_content_panels:\n            tabs.append(PerUserContentPanels(heading='Content'))\n        if cls.promote_panels:\n            tabs.append(ObjectList(cls.promote_panels,\n                                   heading='Promote'))\n        if cls.settings_panels:\n            tabs.append(ObjectList(cls.settings_panels,\n                                   heading='Settings',\n                                   classname='settings'))\n\n        edit_handler = TabbedInterface(tabs,\n                                       base_form_class=cls.base_form_class)\n\n        return edit_handler.bind_to(model=cls)\n\n\nclass SecretPage(PerUserPageMixin, Page):\n    boring_data = models.TextField()\n    secret_data = models.TextField()\n\n    basic_content_panels = Page.content_panels + [\n        FieldPanel('boring_data'),\n    ]\n    superuser_content_panels = basic_content_panels + [\n        FieldPanel('secret_data'),\n    ]\n\n\nclass SimpleParentPage(Page):\n    # `BusinessIndex` has been added to bring it in line with other tests\n    subpage_types = ['tests.SimpleChildPage', BusinessIndex]\n\n\nclass SimpleChildPage(Page):\n    # `Page` has been added to bring it in line with other tests\n    parent_page_types = ['tests.SimpleParentPage', Page]\n\n    max_count_per_parent = 1\n\n\nclass PersonPage(Page):\n    first_name = models.CharField(\n        max_length=255,\n        verbose_name='First Name',\n    )\n    last_name = models.CharField(\n        max_length=255,\n        verbose_name='Last Name',\n    )\n\n    content_panels = Page.content_panels + [\n        MultiFieldPanel([\n            FieldPanel('first_name'),\n            FieldPanel('last_name'),\n        ], 'Person'),\n        InlinePanel('addresses', label='Address'),\n    ]\n\n    class Meta:\n        verbose_name = 'Person'\n        verbose_name_plural = 'Persons'\n\n\nclass Address(index.Indexed, ClusterableModel, Orderable):\n    address = models.CharField(\n        max_length=255,\n        verbose_name='Address',\n    )\n    tags = ClusterTaggableManager(\n        through='tests.AddressTag',\n        blank=True,\n    )\n    person = ParentalKey(\n        to='tests.PersonPage',\n        related_name='addresses',\n        verbose_name='Person'\n    )\n\n    panels = [\n        FieldPanel('address'),\n        FieldPanel('tags'),\n    ]\n\n    class Meta:\n        verbose_name = 'Address'\n        verbose_name_plural = 'Addresses'\n\n\nclass AddressTag(TaggedItemBase):\n    content_object = ParentalKey(\n        to='tests.Address',\n        on_delete=models.CASCADE,\n        related_name='tagged_items'\n    )\n", "patch": "@@ -29,7 +29,7 @@\n from wagtail.contrib.settings.models import BaseSetting, register_setting\n from wagtail.contrib.sitemaps import Sitemap\n from wagtail.contrib.table_block.blocks import TableBlock\n-from wagtail.core.blocks import CharBlock, RichTextBlock, StructBlock\n+from wagtail.core.blocks import CharBlock, RawHTMLBlock, RichTextBlock, StructBlock\n from wagtail.core.fields import RichTextField, StreamField\n from wagtail.core.models import Orderable, Page, PageManager, PageQuerySet\n from wagtail.documents.edit_handlers import DocumentChooserPanel\n@@ -972,6 +972,7 @@ class StreamPage(Page):\n             ('name', CharBlock()),\n             ('price', CharBlock()),\n         ])),\n+        ('raw_html', RawHTMLBlock()),\n     ])\n \n     api_fields = ('body',)", "file_path": "files/2020_4/118", "file_language": "py", "file_name": "wagtail/tests/testapp/models.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class LinkFields(models.Model):\n    link_external = models.URLField(\"External link\", blank=True)\n    link_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n    link_document = models.ForeignKey(\n        'wagtaildocs.Document',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n\n    @property\n    def link(self):\n        if self.link_page:\n            return self.link_page.url\n        elif self.link_document:\n            return self.link_document.url\n        else:\n            return self.link_external\n\n    panels = [\n        FieldPanel('link_external'),\n        PageChooserPanel('link_page'),\n        DocumentChooserPanel('link_document'),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class CarouselItem(LinkFields):\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    embed_url = models.URLField(\"Embed URL\", blank=True)\n    caption = models.CharField(max_length=255, blank=True)\n\n    panels = [\n        ImageChooserPanel('image'),\n        FieldPanel('embed_url'),\n        FieldPanel('caption'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class RelatedLink(LinkFields):\n    title = models.CharField(max_length=255, help_text=\"Link title\")\n\n    panels = [\n        FieldPanel('title'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class SimplePage(Page):\n    content = models.TextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('content'),\n    ]\n\n    def get_admin_display_title(self):\n        return \"%s (simple page)\" % super().get_admin_display_title()", "target": 0}, {"function": "class PageWithExcludedCopyField(Page):\n    content = models.TextField()\n\n    # Exclude this field from being copied\n    special_field = models.CharField(\n        blank=True, max_length=255, default='Very Special')\n    exclude_fields_in_copy = ['special_field']\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('special_field'),\n        FieldPanel('content'),\n    ]", "target": 0}, {"function": "class PageWithOldStyleRouteMethod(Page):\n    \"\"\"\n    Prior to Wagtail 0.4, the route() method on Page returned an HttpResponse\n    rather than a Page instance. As subclasses of Page may override route,\n    we need to continue accepting this convention (albeit as a deprecated API).\n    \"\"\"\n    content = models.TextField()\n    template = 'tests/simple_page.html'\n\n    def route(self, request, path_components):\n        return self.serve(request)", "target": 0}, {"function": "class FilePage(Page):\n    file_field = models.FileField()", "target": 0}, {"function": "class EventPageCarouselItem(Orderable, CarouselItem):\n    page = ParentalKey('tests.EventPage', related_name='carousel_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageRelatedLink(Orderable, RelatedLink):\n    page = ParentalKey('tests.EventPage', related_name='related_links', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageSpeakerAward(Orderable, models.Model):\n    speaker = ParentalKey('tests.EventPageSpeaker', related_name='awards', on_delete=models.CASCADE)\n    name = models.CharField(\"Award name\", max_length=255)\n    date_awarded = models.DateField(null=True, blank=True)\n\n    panels = [\n        FieldPanel('name'),\n        FieldPanel('date_awarded'),\n    ]", "target": 0}, {"function": "class EventPageSpeaker(Orderable, LinkFields, ClusterableModel):\n    page = ParentalKey('tests.EventPage', related_name='speakers', related_query_name='speaker', on_delete=models.CASCADE)\n    first_name = models.CharField(\"Name\", max_length=255, blank=True)\n    last_name = models.CharField(\"Surname\", max_length=255, blank=True)\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n\n    @property\n    def name_display(self):\n        return self.first_name + \" \" + self.last_name\n\n    panels = [\n        FieldPanel('first_name'),\n        FieldPanel('last_name'),\n        ImageChooserPanel('image'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n        InlinePanel('awards', label=\"Awards\"),\n    ]", "target": 0}, {"function": "class EventCategory(models.Model):\n    name = models.CharField(\"Name\", max_length=255)\n\n    def __str__(self):\n        return self.name", "target": 0}, {"function": "class EventPageForm(WagtailAdminPageForm):\n    def clean(self):\n        cleaned_data = super().clean()\n\n        # Make sure that the event starts before it ends\n        start_date = cleaned_data['date_from']\n        end_date = cleaned_data['date_to']\n        if start_date and end_date and start_date > end_date:\n            raise ValidationError('The end date must be after the start date')\n\n        return cleaned_data", "target": 0}, {"function": "class EventPage(Page):\n    date_from = models.DateField(\"Start date\", null=True)\n    date_to = models.DateField(\n        \"End date\",\n        null=True,\n        blank=True,\n        help_text=\"Not required if event is on a single day\"\n    )\n    time_from = models.TimeField(\"Start time\", null=True, blank=True)\n    time_to = models.TimeField(\"End time\", null=True, blank=True)\n    audience = models.CharField(max_length=255, choices=EVENT_AUDIENCE_CHOICES)\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n    cost = models.CharField(max_length=255)\n    signup_link = models.URLField(blank=True)\n    feed_image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    categories = ParentalManyToManyField(EventCategory, blank=True)\n\n    search_fields = [\n        index.SearchField('get_audience_display'),\n        index.SearchField('location'),\n        index.SearchField('body'),\n        index.FilterField('url_path'),\n    ]\n\n    password_required_template = 'tests/event_page_password_required.html'\n    base_form_class = EventPageForm", "target": 0}, {"function": "class HeadCountRelatedModelUsingPK(models.Model):\n    \"\"\"Related model that uses a custom primary key (pk) not id\"\"\"\n    custom_id = models.AutoField(primary_key=True)\n    event_page = ParentalKey(\n        EventPage,\n        on_delete=models.CASCADE,\n        related_name='head_counts'\n    )\n    head_count = models.IntegerField()\n    panels = [FieldPanel('head_count')]", "target": 0}, {"function": "class FormClassAdditionalFieldPage(Page):\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('location'),\n        FieldPanel('body'),\n        FieldPanel('code'),  # not in model, see set base_form_class\n    ]\n\n    base_form_class = FormClassAdditionalFieldPageForm", "target": 0}, {"function": "class SingleEventPage(EventPage):\n    excerpt = models.TextField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=\"Short text to describe what is this action about\"\n    )\n\n    # Give this page model a custom URL routing scheme\n    def get_url_parts(self, request=None):\n        url_parts = super().get_url_parts(request=request)\n        if url_parts is None:\n            return None\n        else:\n            site_id, root_url, page_path = url_parts\n            return (site_id, root_url, page_path + 'pointless-suffix/')\n\n    def route(self, request, path_components):\n        if path_components == ['pointless-suffix']:\n            # treat this as equivalent to a request for this page\n            return super().route(request, [])\n        else:\n            # fall back to default routing rules\n            return super().route(request, path_components)\n\n    def get_admin_display_title(self):\n        return \"%s (single event)\" % super().get_admin_display_title()", "target": 0}, {"function": "class EventSitemap(Sitemap):\n    pass", "target": 0}, {"function": "class EventIndex(Page):\n    intro = RichTextField(blank=True)\n    ajax_template = 'tests/includes/event_listing.html'\n\n    def get_events(self):\n        return self.get_children().live().type(EventPage)\n\n    def get_paginator(self):\n        return Paginator(self.get_events(), 4)\n\n    def get_context(self, request, page=1):\n        # Pagination\n        paginator = self.get_paginator()\n        try:\n            events = paginator.page(page)\n        except PageNotAnInteger:\n            events = paginator.page(1)\n        except EmptyPage:\n            events = paginator.page(paginator.num_pages)\n\n        # Update context\n        context = super().get_context(request)\n        context['events'] = events\n        return context\n\n    def route(self, request, path_components):\n        if self.live and len(path_components) == 1:\n            try:\n                return self.serve(request, page=int(path_components[0]))\n            except (TypeError, ValueError):\n                pass\n\n        return super().route(request, path_components)\n\n    def get_static_site_paths(self):\n        # Get page count\n        page_count = self.get_paginator().num_pages\n\n        # Yield a path for each page\n        for page in range(page_count):\n            yield '/%d/' % (page + 1)\n\n        # Yield from superclass\n        for path in super().get_static_site_paths():\n            yield path\n\n    def get_sitemap_urls(self, request=None):\n        # Add past events url to sitemap\n        return super().get_sitemap_urls(request=request) + [\n            {\n                'location': self.full_url + 'past/',\n                'lastmod': self.latest_revision_created_at\n            }\n        ]\n\n    def get_cached_paths(self):\n        return super().get_cached_paths() + [\n            '/past/'\n        ]", "target": 0}, {"function": "class FormField(AbstractFormField):\n    page = ParentalKey('FormPage', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class FormPage(AbstractEmailForm):\n    def get_context(self, request):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context", "target": 0}, {"function": "class JadeFormField(AbstractFormField):\n    page = ParentalKey('JadeFormPage', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class JadeFormPage(AbstractEmailForm):\n    template = \"tests/form_page.jade\"", "target": 0}, {"function": "class RedirectFormField(AbstractFormField):\n    page = ParentalKey('FormPageWithRedirect', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class FormPageWithRedirect(AbstractEmailForm):\n    thank_you_redirect_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+',\n    )\n\n    def get_context(self, request):\n        context = super(FormPageWithRedirect, self).get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def render_landing_page(self, request, form_submission=None, *args, **kwargs):\n        \"\"\"\n        Renders the landing page OR if a receipt_page_redirect is chosen redirects to this page.\n        \"\"\"\n        if self.thank_you_redirect_page:\n            return redirect(self.thank_you_redirect_page.url, permanent=False)\n\n        return super(FormPageWithRedirect, self).render_landing_page(request, form_submission, *args, **kwargs)", "target": 0}, {"function": "class FormPageWithCustomSubmission(AbstractEmailForm):\n    \"\"\"\n    This Form page:\n        * Have custom submission model\n        * Have custom related_name (see `FormFieldWithCustomSubmission.page`)\n        * Saves reference to a user\n        * Doesn't render html form, if submission for current user is present\n    \"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    def get_context(self, request, *args, **kwargs):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def get_form_fields(self):\n        return self.custom_form_fields.all()\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def process_form_submission(self, form):\n        form_submission = self.get_submission_class().objects.create(\n            form_data=json.dumps(form.cleaned_data, cls=DjangoJSONEncoder),\n            page=self, user=form.user\n        )\n\n        if self.to_address:\n            addresses = [x.strip() for x in self.to_address.split(',')]\n            content = '\\n'.join([x[1].label + ': ' + str(form.data.get(x[0])) for x in form.fields.items()])\n            send_mail(self.subject, content, addresses, self.from_address,)\n\n        # process_form_submission should now return the created form_submission\n        return form_submission\n\n    def serve(self, request, *args, **kwargs):\n        if self.get_submission_class().objects.filter(page=self, user__pk=request.user.pk).exists():\n            return render(\n                request,\n                self.template,\n                self.get_context(request)\n            )\n\n        return super().serve(request, *args, **kwargs)", "target": 0}, {"function": "class FormFieldWithCustomSubmission(AbstractFormField):\n    page = ParentalKey(FormPageWithCustomSubmission, on_delete=models.CASCADE, related_name='custom_form_fields')", "target": 0}, {"function": "class CustomFormPageSubmission(AbstractFormSubmission):\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n\n    def get_data(self):\n        form_data = super().get_data()\n        form_data.update({\n            'username': self.user.username,\n        })\n\n        return form_data", "target": 0}, {"function": "class FormFieldForCustomListViewPage(AbstractFormField):\n    page = ParentalKey(\n        'FormPageWithCustomSubmissionListView',\n        related_name='form_fields',\n        on_delete=models.CASCADE\n    )", "target": 0}, {"function": "class FormPageWithCustomSubmissionListView(AbstractEmailForm):\n    \"\"\"Form Page with customised submissions listing view\"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    submissions_list_view_class = CustomSubmissionsListView\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('intro', classname=\"full\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        FieldPanel('thank_you_text', classname=\"full\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]", "target": 0}, {"function": "class ExtendedFormField(AbstractFormField):\n    \"\"\"Override the field_type field with extended choices.\"\"\"\n    page = ParentalKey(\n        'FormPageWithCustomFormBuilder',\n        related_name='form_fields',\n        on_delete=models.CASCADE)\n    field_type = models.CharField(\n        verbose_name='field type', max_length=16, choices=EXTENDED_CHOICES)", "target": 0}, {"function": "class CustomFormBuilder(FormBuilder):\n    \"\"\"\n    A custom FormBuilder that has an 'ipaddress' field with\n    customised create_singleline_field with shorter max_length\n    \"\"\"\n\n    def create_singleline_field(self, field, options):\n        options['max_length'] = 120  # usual default is 255\n        return forms.CharField(**options)\n\n    def create_ipaddress_field(self, field, options):\n        return forms.GenericIPAddressField(**options)", "target": 0}, {"function": "class FormPageWithCustomFormBuilder(AbstractEmailForm):\n    \"\"\"\n    A Form page that has a custom form builder and uses a custom\n    form field model with additional field_type choices.\n    \"\"\"\n\n    form_builder = CustomFormBuilder\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]", "target": 0}, {"function": "class AdvertPlacement(models.Model):\n    page = ParentalKey('wagtailcore.Page', related_name='advert_placements', on_delete=models.CASCADE)\n    advert = models.ForeignKey('tests.Advert', related_name='+', on_delete=models.CASCADE)\n    colour = models.CharField(max_length=255)", "target": 0}, {"function": "class AdvertTag(TaggedItemBase):\n    content_object = ParentalKey('Advert', related_name='tagged_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class Advert(ClusterableModel):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    tags = TaggableManager(through=AdvertTag, blank=True)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n        FieldPanel('tags'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithCustomPrimaryKey(ClusterableModel):\n    advert_id = models.CharField(max_length=255, primary_key=True)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithCustomUUIDPrimaryKey(ClusterableModel):\n    advert_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithTabbedInterface(models.Model):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n    something_else = models.CharField(max_length=255)\n\n    advert_panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    other_panels = [\n        FieldPanel('something_else'),\n    ]\n\n    edit_handler = TabbedInterface([\n        ObjectList(advert_panels, heading='Advert'),\n        ObjectList(other_panels, heading='Other'),\n    ])\n\n    def __str__(self):\n        return self.text\n\n    class Meta:\n        ordering = ('text',)", "target": 0}, {"function": "class StandardIndex(Page):\n    \"\"\" Index for the site \"\"\"\n    parent_page_types = [Page]", "target": 0}, {"function": "class StandardChild(Page):\n    pass", "target": 0}, {"function": "class BusinessIndex(Page):\n    \"\"\" Can be placed anywhere, can only have Business children \"\"\"\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessSubIndex']", "target": 0}, {"function": "class BusinessSubIndex(Page):\n    \"\"\" Can be placed under BusinessIndex, and have BusinessChild children \"\"\"\n\n    # BusinessNowherePage is 'incorrectly' added here as a possible child.\n    # The rules on BusinessNowherePage prevent it from being a child here though.\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessNowherePage']\n    parent_page_types = ['tests.BusinessIndex', 'tests.BusinessChild']", "target": 0}, {"function": "class BusinessChild(Page):\n    \"\"\" Can only be placed under Business indexes, no children allowed \"\"\"\n    subpage_types = []\n    parent_page_types = ['tests.BusinessIndex', BusinessSubIndex]", "target": 0}, {"function": "class BusinessNowherePage(Page):\n    \"\"\" Not allowed to be placed anywhere \"\"\"\n    parent_page_types = []", "target": 0}, {"function": "class TaggedPageTag(TaggedItemBase):\n    content_object = ParentalKey('tests.TaggedPage', related_name='tagged_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class TaggedPage(Page):\n    tags = ClusterTaggableManager(through=TaggedPageTag, blank=True)", "target": 0}, {"function": "class SingletonPage(Page):\n    @classmethod\n    def can_create_at(cls, parent):\n        # You can only create one of these!\n        return super(SingletonPage, cls).can_create_at(parent) \\\n            and not cls.objects.exists()", "target": 0}, {"function": "class SingletonPageViaMaxCount(Page):\n    max_count = 1", "target": 0}, {"function": "class PageChooserModel(models.Model):\n    page = models.ForeignKey('wagtailcore.Page', help_text='help text', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageChooserModel(models.Model):\n    page = models.ForeignKey('tests.EventPage', help_text='more help text', on_delete=models.CASCADE)", "target": 0}, {"function": "class SnippetChooserModel(models.Model):\n    advert = models.ForeignKey(Advert, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advert'),\n    ]", "target": 0}, {"function": "class SnippetChooserModelWithCustomPrimaryKey(models.Model):\n    advertwithcustomprimarykey = models.ForeignKey(AdvertWithCustomPrimaryKey, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advertwithcustomprimarykey'),\n    ]", "target": 0}, {"function": "class CustomImage(AbstractImage):\n    caption = models.CharField(max_length=255, blank=True)\n    fancy_caption = RichTextField(blank=True)\n    not_editable_field = models.CharField(max_length=255, blank=True)\n\n    admin_form_fields = Image.admin_form_fields + (\n        'caption',\n        'fancy_caption',\n    )", "target": 0}, {"function": "class CustomRendition(AbstractRendition):\n    image = models.ForeignKey(CustomImage, related_name='renditions', on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            ('image', 'filter_spec', 'focal_point_key'),\n        )", "target": 0}, {"function": "class CustomDocument(AbstractDocument):\n    description = models.TextField(blank=True)\n    fancy_description = RichTextField(blank=True)\n    admin_form_fields = Document.admin_form_fields + (\n        'description',\n        'fancy_description'\n    )", "target": 0}, {"function": "class StreamModel(models.Model):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])", "target": 0}, {"function": "class ExtendedImageChooserBlock(ImageChooserBlock):\n    \"\"\"\n    Example of Block with custom get_api_representation method.\n    If the request has an 'extended' query param, it returns a dict of id and title,\n    otherwise, it returns the default value.\n    \"\"\"\n    def get_api_representation(self, value, context=None):\n        image_id = super().get_api_representation(value, context=context)\n        if 'request' in context and context['request'].query_params.get('extended', False):\n            return {\n                'id': image_id,\n                'title': value.title\n            }\n        return image_id", "target": 0}, {"function": "class StreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ExtendedImageChooserBlock()),\n        ('product', StructBlock([\n            ('name', CharBlock()),\n            ('price', CharBlock()),\n        ])),\n    ])\n\n    api_fields = ('body',)\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class DefaultStreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ], default='')\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class MTIBasePage(Page):\n    is_creatable = False\n\n    class Meta:\n        verbose_name = \"MTI Base page\"", "target": 0}, {"function": "class MTIChildPage(MTIBasePage):\n    # Should be creatable by default, no need to set anything\n    pass", "target": 0}, {"function": "class AbstractPage(Page):\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class NotYetRegisteredSetting(BaseSetting):\n    pass", "target": 0}, {"function": "class BlogCategory(models.Model):\n    name = models.CharField(unique=True, max_length=80)", "target": 0}, {"function": "class BlogCategoryBlogPage(models.Model):\n    category = models.ForeignKey(BlogCategory, related_name=\"+\", on_delete=models.CASCADE)\n    page = ParentalKey('ManyToManyBlogPage', related_name='categories', on_delete=models.CASCADE)\n    panels = [\n        FieldPanel('category'),\n    ]", "target": 0}, {"function": "class ManyToManyBlogPage(Page):\n    \"\"\"\n    A page type with two different kinds of M2M relation.\n    We don't formally support these, but we don't want them to cause\n    hard breakages either.\n    \"\"\"\n    body = RichTextField(blank=True)\n    adverts = models.ManyToManyField(Advert, blank=True)\n    blog_categories = models.ManyToManyField(\n        BlogCategory, through=BlogCategoryBlogPage, blank=True)\n\n    # make first_published_at editable on this page model\n    settings_panels = Page.settings_panels + [\n        FieldPanel('first_published_at'),\n    ]", "target": 0}, {"function": "class OneToOnePage(Page):\n    \"\"\"\n    A Page containing a O2O relation.\n    \"\"\"\n    body = RichTextBlock(blank=True)\n    page_ptr = models.OneToOneField(Page, parent_link=True,\n                                    related_name='+', on_delete=models.CASCADE)", "target": 0}, {"function": "class GenericSnippetPage(Page):\n    \"\"\"\n    A page containing a reference to an arbitrary snippet (or any model for that matter)\n    linked by a GenericForeignKey\n    \"\"\"\n    snippet_content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True)\n    snippet_object_id = models.PositiveIntegerField(null=True)\n    snippet_content_object = GenericForeignKey('snippet_content_type', 'snippet_object_id')", "target": 0}, {"function": "class CustomImageFilePath(AbstractImage):\n    def get_upload_to(self, filename):\n        \"\"\"Create a path that's file-system friendly.\n\n        By hashing the file's contents we guarantee an equal distribution\n        of files within our root directories. This also gives us a\n        better chance of uploading images with the same filename, but\n        different contents - this isn't guaranteed as we're only using\n        the first three characters of the checksum.\n        \"\"\"\n        original_filepath = super().get_upload_to(filename)\n        folder_name, filename = original_filepath.split(os.path.sep)\n\n        # Ensure that we consume the entire file, we can't guarantee that\n        # the stream has not be partially (or entirely) consumed by\n        # another process\n        original_position = self.file.tell()\n        self.file.seek(0)\n        hash256 = hashlib.sha256()\n\n        while True:\n            data = self.file.read(256)\n            if not data:\n                break\n            hash256.update(data)\n        checksum = hash256.hexdigest()\n\n        self.file.seek(original_position)\n        return os.path.join(folder_name, checksum[:3], filename)", "target": 0}, {"function": "class CustomPageQuerySet(PageQuerySet):\n    def about_spam(self):\n        return self.filter(title__contains='spam')", "target": 0}, {"function": "class CustomManagerPage(Page):\n    objects = CustomManager()", "target": 0}, {"function": "class MyBasePage(Page):\n    \"\"\"\n    A base Page model, used to set site-wide defaults and overrides.\n    \"\"\"\n    objects = CustomManager()\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class MyCustomPage(MyBasePage):\n    pass", "target": 0}, {"function": "class ValidatedPage(Page):\n    foo = models.CharField(max_length=255)\n\n    base_form_class = ValidatedPageForm\n    content_panels = Page.content_panels + [\n        FieldPanel('foo'),\n    ]", "target": 0}, {"function": "class DefaultRichTextFieldPage(Page):\n    body = RichTextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class DefaultRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock()),\n    ])\n\n    content_panels = Page.content_panels + [\n        StreamFieldPanel('body')\n    ]", "target": 0}, {"function": "class CustomRichTextFieldPage(Page):\n    body = RichTextField(editor='custom')\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class CustomRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock(editor='custom')),\n    ])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class RichTextFieldWithFeaturesPage(Page):\n    body = RichTextField(features=['quotation', 'embed', 'made-up-feature'])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class SectionedRichTextPageSection(Orderable):\n    page = ParentalKey('tests.SectionedRichTextPage', related_name='sections', on_delete=models.CASCADE)\n    body = RichTextField()\n\n    panels = [\n        FieldPanel('body')\n    ]", "target": 0}, {"function": "class SectionedRichTextPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]", "target": 0}, {"function": "class InlineStreamPageSection(Orderable):\n    page = ParentalKey('tests.InlineStreamPage', related_name='sections', on_delete=models.CASCADE)\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n    panels = [\n        StreamFieldPanel('body')\n    ]", "target": 0}, {"function": "class InlineStreamPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]", "target": 0}, {"function": "class TableBlockStreamPage(Page):\n    table = StreamField([('table', TableBlock())])\n\n    content_panels = [StreamFieldPanel('table')]", "target": 0}, {"function": "class UserProfile(models.Model):\n    # Wagtail's schema must be able to coexist alongside a custom UserProfile model\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    favourite_colour = models.CharField(max_length=255)", "target": 0}, {"function": "class PanelSettings(TestSetting):\n    panels = [\n        FieldPanel('title')\n    ]", "target": 0}, {"function": "class TabbedSettings(TestSetting):\n    edit_handler = TabbedInterface([\n        ObjectList([\n            FieldPanel('title')\n        ], heading='First tab'),\n        ObjectList([\n            FieldPanel('email')\n        ], heading='Second tab'),\n    ])", "target": 0}, {"function": "class AlwaysShowInMenusPage(Page):\n    show_in_menus_default = True", "target": 0}, {"function": "class AddedStreamFieldWithoutDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ])", "target": 0}, {"function": "class AddedStreamFieldWithEmptyStringDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default='')", "target": 0}, {"function": "class AddedStreamFieldWithEmptyListDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default=[])", "target": 0}, {"function": "class PerUserContentPanels(ObjectList):\n    def _replace_children_with_per_user_config(self):\n        self.children = self.instance.basic_content_panels\n        if self.request.user.is_superuser:\n            self.children = self.instance.superuser_content_panels\n        self.children = [\n            child.bind_to(model=self.model, instance=self.instance,\n                          request=self.request, form=self.form)\n            for child in self.children]\n\n    def on_instance_bound(self):\n        # replace list of children when both instance and request are available\n        if self.request:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_instance_bound()\n\n    def on_request_bound(self):\n        # replace list of children when both instance and request are available\n        if self.instance:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_request_bound()", "target": 0}, {"function": "class PerUserPageMixin:\n    basic_content_panels = []\n    superuser_content_panels = []\n\n    @cached_classmethod\n    def get_edit_handler(cls):\n        tabs = []\n\n        if cls.basic_content_panels and cls.superuser_content_panels:\n            tabs.append(PerUserContentPanels(heading='Content'))\n        if cls.promote_panels:\n            tabs.append(ObjectList(cls.promote_panels,\n                                   heading='Promote'))\n        if cls.settings_panels:\n            tabs.append(ObjectList(cls.settings_panels,\n                                   heading='Settings',\n                                   classname='settings'))\n\n        edit_handler = TabbedInterface(tabs,\n                                       base_form_class=cls.base_form_class)\n\n        return edit_handler.bind_to(model=cls)", "target": 0}, {"function": "class SecretPage(PerUserPageMixin, Page):\n    boring_data = models.TextField()\n    secret_data = models.TextField()\n\n    basic_content_panels = Page.content_panels + [\n        FieldPanel('boring_data'),\n    ]\n    superuser_content_panels = basic_content_panels + [\n        FieldPanel('secret_data'),\n    ]", "target": 0}, {"function": "class SimpleParentPage(Page):\n    # `BusinessIndex` has been added to bring it in line with other tests\n    subpage_types = ['tests.SimpleChildPage', BusinessIndex]", "target": 0}, {"function": "class SimpleChildPage(Page):\n    # `Page` has been added to bring it in line with other tests\n    parent_page_types = ['tests.SimpleParentPage', Page]\n\n    max_count_per_parent = 1", "target": 0}, {"function": "class PersonPage(Page):\n    first_name = models.CharField(\n        max_length=255,\n        verbose_name='First Name',\n    )\n    last_name = models.CharField(\n        max_length=255,\n        verbose_name='Last Name',\n    )\n\n    content_panels = Page.content_panels + [\n        MultiFieldPanel([\n            FieldPanel('first_name'),\n            FieldPanel('last_name'),\n        ], 'Person'),\n        InlinePanel('addresses', label='Address'),\n    ]\n\n    class Meta:\n        verbose_name = 'Person'\n        verbose_name_plural = 'Persons'", "target": 0}, {"function": "class Address(index.Indexed, ClusterableModel, Orderable):\n    address = models.CharField(\n        max_length=255,\n        verbose_name='Address',\n    )\n    tags = ClusterTaggableManager(\n        through='tests.AddressTag',\n        blank=True,\n    )\n    person = ParentalKey(\n        to='tests.PersonPage',\n        related_name='addresses',\n        verbose_name='Person'\n    )\n\n    panels = [\n        FieldPanel('address'),\n        FieldPanel('tags'),\n    ]\n\n    class Meta:\n        verbose_name = 'Address'\n        verbose_name_plural = 'Addresses'", "target": 0}, {"function": "class AddressTag(TaggedItemBase):\n    content_object = ParentalKey(\n        to='tests.Address',\n        on_delete=models.CASCADE,\n        related_name='tagged_items'\n    )", "target": 0}], "function_after": [{"function": "class LinkFields(models.Model):\n    link_external = models.URLField(\"External link\", blank=True)\n    link_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n    link_document = models.ForeignKey(\n        'wagtaildocs.Document',\n        null=True,\n        blank=True,\n        related_name='+',\n        on_delete=models.CASCADE\n    )\n\n    @property\n    def link(self):\n        if self.link_page:\n            return self.link_page.url\n        elif self.link_document:\n            return self.link_document.url\n        else:\n            return self.link_external\n\n    panels = [\n        FieldPanel('link_external'),\n        PageChooserPanel('link_page'),\n        DocumentChooserPanel('link_document'),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class CarouselItem(LinkFields):\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    embed_url = models.URLField(\"Embed URL\", blank=True)\n    caption = models.CharField(max_length=255, blank=True)\n\n    panels = [\n        ImageChooserPanel('image'),\n        FieldPanel('embed_url'),\n        FieldPanel('caption'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class RelatedLink(LinkFields):\n    title = models.CharField(max_length=255, help_text=\"Link title\")\n\n    panels = [\n        FieldPanel('title'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n    ]\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class SimplePage(Page):\n    content = models.TextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('content'),\n    ]\n\n    def get_admin_display_title(self):\n        return \"%s (simple page)\" % super().get_admin_display_title()", "target": 0}, {"function": "class PageWithExcludedCopyField(Page):\n    content = models.TextField()\n\n    # Exclude this field from being copied\n    special_field = models.CharField(\n        blank=True, max_length=255, default='Very Special')\n    exclude_fields_in_copy = ['special_field']\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('special_field'),\n        FieldPanel('content'),\n    ]", "target": 0}, {"function": "class PageWithOldStyleRouteMethod(Page):\n    \"\"\"\n    Prior to Wagtail 0.4, the route() method on Page returned an HttpResponse\n    rather than a Page instance. As subclasses of Page may override route,\n    we need to continue accepting this convention (albeit as a deprecated API).\n    \"\"\"\n    content = models.TextField()\n    template = 'tests/simple_page.html'\n\n    def route(self, request, path_components):\n        return self.serve(request)", "target": 0}, {"function": "class FilePage(Page):\n    file_field = models.FileField()", "target": 0}, {"function": "class EventPageCarouselItem(Orderable, CarouselItem):\n    page = ParentalKey('tests.EventPage', related_name='carousel_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageRelatedLink(Orderable, RelatedLink):\n    page = ParentalKey('tests.EventPage', related_name='related_links', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageSpeakerAward(Orderable, models.Model):\n    speaker = ParentalKey('tests.EventPageSpeaker', related_name='awards', on_delete=models.CASCADE)\n    name = models.CharField(\"Award name\", max_length=255)\n    date_awarded = models.DateField(null=True, blank=True)\n\n    panels = [\n        FieldPanel('name'),\n        FieldPanel('date_awarded'),\n    ]", "target": 0}, {"function": "class EventPageSpeaker(Orderable, LinkFields, ClusterableModel):\n    page = ParentalKey('tests.EventPage', related_name='speakers', related_query_name='speaker', on_delete=models.CASCADE)\n    first_name = models.CharField(\"Name\", max_length=255, blank=True)\n    last_name = models.CharField(\"Surname\", max_length=255, blank=True)\n    image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n\n    @property\n    def name_display(self):\n        return self.first_name + \" \" + self.last_name\n\n    panels = [\n        FieldPanel('first_name'),\n        FieldPanel('last_name'),\n        ImageChooserPanel('image'),\n        MultiFieldPanel(LinkFields.panels, \"Link\"),\n        InlinePanel('awards', label=\"Awards\"),\n    ]", "target": 0}, {"function": "class EventCategory(models.Model):\n    name = models.CharField(\"Name\", max_length=255)\n\n    def __str__(self):\n        return self.name", "target": 0}, {"function": "class EventPageForm(WagtailAdminPageForm):\n    def clean(self):\n        cleaned_data = super().clean()\n\n        # Make sure that the event starts before it ends\n        start_date = cleaned_data['date_from']\n        end_date = cleaned_data['date_to']\n        if start_date and end_date and start_date > end_date:\n            raise ValidationError('The end date must be after the start date')\n\n        return cleaned_data", "target": 0}, {"function": "class EventPage(Page):\n    date_from = models.DateField(\"Start date\", null=True)\n    date_to = models.DateField(\n        \"End date\",\n        null=True,\n        blank=True,\n        help_text=\"Not required if event is on a single day\"\n    )\n    time_from = models.TimeField(\"Start time\", null=True, blank=True)\n    time_to = models.TimeField(\"End time\", null=True, blank=True)\n    audience = models.CharField(max_length=255, choices=EVENT_AUDIENCE_CHOICES)\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n    cost = models.CharField(max_length=255)\n    signup_link = models.URLField(blank=True)\n    feed_image = models.ForeignKey(\n        'wagtailimages.Image',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+'\n    )\n    categories = ParentalManyToManyField(EventCategory, blank=True)\n\n    search_fields = [\n        index.SearchField('get_audience_display'),\n        index.SearchField('location'),\n        index.SearchField('body'),\n        index.FilterField('url_path'),\n    ]\n\n    password_required_template = 'tests/event_page_password_required.html'\n    base_form_class = EventPageForm", "target": 0}, {"function": "class HeadCountRelatedModelUsingPK(models.Model):\n    \"\"\"Related model that uses a custom primary key (pk) not id\"\"\"\n    custom_id = models.AutoField(primary_key=True)\n    event_page = ParentalKey(\n        EventPage,\n        on_delete=models.CASCADE,\n        related_name='head_counts'\n    )\n    head_count = models.IntegerField()\n    panels = [FieldPanel('head_count')]", "target": 0}, {"function": "class FormClassAdditionalFieldPage(Page):\n    location = models.CharField(max_length=255)\n    body = RichTextField(blank=True)\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('location'),\n        FieldPanel('body'),\n        FieldPanel('code'),  # not in model, see set base_form_class\n    ]\n\n    base_form_class = FormClassAdditionalFieldPageForm", "target": 0}, {"function": "class SingleEventPage(EventPage):\n    excerpt = models.TextField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=\"Short text to describe what is this action about\"\n    )\n\n    # Give this page model a custom URL routing scheme\n    def get_url_parts(self, request=None):\n        url_parts = super().get_url_parts(request=request)\n        if url_parts is None:\n            return None\n        else:\n            site_id, root_url, page_path = url_parts\n            return (site_id, root_url, page_path + 'pointless-suffix/')\n\n    def route(self, request, path_components):\n        if path_components == ['pointless-suffix']:\n            # treat this as equivalent to a request for this page\n            return super().route(request, [])\n        else:\n            # fall back to default routing rules\n            return super().route(request, path_components)\n\n    def get_admin_display_title(self):\n        return \"%s (single event)\" % super().get_admin_display_title()", "target": 0}, {"function": "class EventSitemap(Sitemap):\n    pass", "target": 0}, {"function": "class EventIndex(Page):\n    intro = RichTextField(blank=True)\n    ajax_template = 'tests/includes/event_listing.html'\n\n    def get_events(self):\n        return self.get_children().live().type(EventPage)\n\n    def get_paginator(self):\n        return Paginator(self.get_events(), 4)\n\n    def get_context(self, request, page=1):\n        # Pagination\n        paginator = self.get_paginator()\n        try:\n            events = paginator.page(page)\n        except PageNotAnInteger:\n            events = paginator.page(1)\n        except EmptyPage:\n            events = paginator.page(paginator.num_pages)\n\n        # Update context\n        context = super().get_context(request)\n        context['events'] = events\n        return context\n\n    def route(self, request, path_components):\n        if self.live and len(path_components) == 1:\n            try:\n                return self.serve(request, page=int(path_components[0]))\n            except (TypeError, ValueError):\n                pass\n\n        return super().route(request, path_components)\n\n    def get_static_site_paths(self):\n        # Get page count\n        page_count = self.get_paginator().num_pages\n\n        # Yield a path for each page\n        for page in range(page_count):\n            yield '/%d/' % (page + 1)\n\n        # Yield from superclass\n        for path in super().get_static_site_paths():\n            yield path\n\n    def get_sitemap_urls(self, request=None):\n        # Add past events url to sitemap\n        return super().get_sitemap_urls(request=request) + [\n            {\n                'location': self.full_url + 'past/',\n                'lastmod': self.latest_revision_created_at\n            }\n        ]\n\n    def get_cached_paths(self):\n        return super().get_cached_paths() + [\n            '/past/'\n        ]", "target": 0}, {"function": "class FormField(AbstractFormField):\n    page = ParentalKey('FormPage', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class FormPage(AbstractEmailForm):\n    def get_context(self, request):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context", "target": 0}, {"function": "class JadeFormField(AbstractFormField):\n    page = ParentalKey('JadeFormPage', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class JadeFormPage(AbstractEmailForm):\n    template = \"tests/form_page.jade\"", "target": 0}, {"function": "class RedirectFormField(AbstractFormField):\n    page = ParentalKey('FormPageWithRedirect', related_name='form_fields', on_delete=models.CASCADE)", "target": 0}, {"function": "class FormPageWithRedirect(AbstractEmailForm):\n    thank_you_redirect_page = models.ForeignKey(\n        'wagtailcore.Page',\n        null=True,\n        blank=True,\n        on_delete=models.SET_NULL,\n        related_name='+',\n    )\n\n    def get_context(self, request):\n        context = super(FormPageWithRedirect, self).get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def render_landing_page(self, request, form_submission=None, *args, **kwargs):\n        \"\"\"\n        Renders the landing page OR if a receipt_page_redirect is chosen redirects to this page.\n        \"\"\"\n        if self.thank_you_redirect_page:\n            return redirect(self.thank_you_redirect_page.url, permanent=False)\n\n        return super(FormPageWithRedirect, self).render_landing_page(request, form_submission, *args, **kwargs)", "target": 0}, {"function": "class FormPageWithCustomSubmission(AbstractEmailForm):\n    \"\"\"\n    This Form page:\n        * Have custom submission model\n        * Have custom related_name (see `FormFieldWithCustomSubmission.page`)\n        * Saves reference to a user\n        * Doesn't render html form, if submission for current user is present\n    \"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    def get_context(self, request, *args, **kwargs):\n        context = super().get_context(request)\n        context['greeting'] = \"hello world\"\n        return context\n\n    def get_form_fields(self):\n        return self.custom_form_fields.all()\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def process_form_submission(self, form):\n        form_submission = self.get_submission_class().objects.create(\n            form_data=json.dumps(form.cleaned_data, cls=DjangoJSONEncoder),\n            page=self, user=form.user\n        )\n\n        if self.to_address:\n            addresses = [x.strip() for x in self.to_address.split(',')]\n            content = '\\n'.join([x[1].label + ': ' + str(form.data.get(x[0])) for x in form.fields.items()])\n            send_mail(self.subject, content, addresses, self.from_address,)\n\n        # process_form_submission should now return the created form_submission\n        return form_submission\n\n    def serve(self, request, *args, **kwargs):\n        if self.get_submission_class().objects.filter(page=self, user__pk=request.user.pk).exists():\n            return render(\n                request,\n                self.template,\n                self.get_context(request)\n            )\n\n        return super().serve(request, *args, **kwargs)", "target": 0}, {"function": "class FormFieldWithCustomSubmission(AbstractFormField):\n    page = ParentalKey(FormPageWithCustomSubmission, on_delete=models.CASCADE, related_name='custom_form_fields')", "target": 0}, {"function": "class CustomFormPageSubmission(AbstractFormSubmission):\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n\n    def get_data(self):\n        form_data = super().get_data()\n        form_data.update({\n            'username': self.user.username,\n        })\n\n        return form_data", "target": 0}, {"function": "class FormFieldForCustomListViewPage(AbstractFormField):\n    page = ParentalKey(\n        'FormPageWithCustomSubmissionListView',\n        related_name='form_fields',\n        on_delete=models.CASCADE\n    )", "target": 0}, {"function": "class FormPageWithCustomSubmissionListView(AbstractEmailForm):\n    \"\"\"Form Page with customised submissions listing view\"\"\"\n\n    intro = RichTextField(blank=True)\n    thank_you_text = RichTextField(blank=True)\n\n    submissions_list_view_class = CustomSubmissionsListView\n\n    def get_submission_class(self):\n        return CustomFormPageSubmission\n\n    def get_data_fields(self):\n        data_fields = [\n            ('username', 'Username'),\n        ]\n        data_fields += super().get_data_fields()\n\n        return data_fields\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('intro', classname=\"full\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        FieldPanel('thank_you_text', classname=\"full\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]", "target": 0}, {"function": "class ExtendedFormField(AbstractFormField):\n    \"\"\"Override the field_type field with extended choices.\"\"\"\n    page = ParentalKey(\n        'FormPageWithCustomFormBuilder',\n        related_name='form_fields',\n        on_delete=models.CASCADE)\n    field_type = models.CharField(\n        verbose_name='field type', max_length=16, choices=EXTENDED_CHOICES)", "target": 0}, {"function": "class CustomFormBuilder(FormBuilder):\n    \"\"\"\n    A custom FormBuilder that has an 'ipaddress' field with\n    customised create_singleline_field with shorter max_length\n    \"\"\"\n\n    def create_singleline_field(self, field, options):\n        options['max_length'] = 120  # usual default is 255\n        return forms.CharField(**options)\n\n    def create_ipaddress_field(self, field, options):\n        return forms.GenericIPAddressField(**options)", "target": 0}, {"function": "class FormPageWithCustomFormBuilder(AbstractEmailForm):\n    \"\"\"\n    A Form page that has a custom form builder and uses a custom\n    form field model with additional field_type choices.\n    \"\"\"\n\n    form_builder = CustomFormBuilder\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('form_fields', label=\"Form fields\"),\n        MultiFieldPanel([\n            FieldPanel('to_address', classname=\"full\"),\n            FieldPanel('from_address', classname=\"full\"),\n            FieldPanel('subject', classname=\"full\"),\n        ], \"Email\")\n    ]", "target": 0}, {"function": "class AdvertPlacement(models.Model):\n    page = ParentalKey('wagtailcore.Page', related_name='advert_placements', on_delete=models.CASCADE)\n    advert = models.ForeignKey('tests.Advert', related_name='+', on_delete=models.CASCADE)\n    colour = models.CharField(max_length=255)", "target": 0}, {"function": "class AdvertTag(TaggedItemBase):\n    content_object = ParentalKey('Advert', related_name='tagged_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class Advert(ClusterableModel):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    tags = TaggableManager(through=AdvertTag, blank=True)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n        FieldPanel('tags'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithCustomPrimaryKey(ClusterableModel):\n    advert_id = models.CharField(max_length=255, primary_key=True)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithCustomUUIDPrimaryKey(ClusterableModel):\n    advert_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n\n    panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    def __str__(self):\n        return self.text", "target": 0}, {"function": "class AdvertWithTabbedInterface(models.Model):\n    url = models.URLField(null=True, blank=True)\n    text = models.CharField(max_length=255)\n    something_else = models.CharField(max_length=255)\n\n    advert_panels = [\n        FieldPanel('url'),\n        FieldPanel('text'),\n    ]\n\n    other_panels = [\n        FieldPanel('something_else'),\n    ]\n\n    edit_handler = TabbedInterface([\n        ObjectList(advert_panels, heading='Advert'),\n        ObjectList(other_panels, heading='Other'),\n    ])\n\n    def __str__(self):\n        return self.text\n\n    class Meta:\n        ordering = ('text',)", "target": 0}, {"function": "class StandardIndex(Page):\n    \"\"\" Index for the site \"\"\"\n    parent_page_types = [Page]", "target": 0}, {"function": "class StandardChild(Page):\n    pass", "target": 0}, {"function": "class BusinessIndex(Page):\n    \"\"\" Can be placed anywhere, can only have Business children \"\"\"\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessSubIndex']", "target": 0}, {"function": "class BusinessSubIndex(Page):\n    \"\"\" Can be placed under BusinessIndex, and have BusinessChild children \"\"\"\n\n    # BusinessNowherePage is 'incorrectly' added here as a possible child.\n    # The rules on BusinessNowherePage prevent it from being a child here though.\n    subpage_types = ['tests.BusinessChild', 'tests.BusinessNowherePage']\n    parent_page_types = ['tests.BusinessIndex', 'tests.BusinessChild']", "target": 0}, {"function": "class BusinessChild(Page):\n    \"\"\" Can only be placed under Business indexes, no children allowed \"\"\"\n    subpage_types = []\n    parent_page_types = ['tests.BusinessIndex', BusinessSubIndex]", "target": 0}, {"function": "class BusinessNowherePage(Page):\n    \"\"\" Not allowed to be placed anywhere \"\"\"\n    parent_page_types = []", "target": 0}, {"function": "class TaggedPageTag(TaggedItemBase):\n    content_object = ParentalKey('tests.TaggedPage', related_name='tagged_items', on_delete=models.CASCADE)", "target": 0}, {"function": "class TaggedPage(Page):\n    tags = ClusterTaggableManager(through=TaggedPageTag, blank=True)", "target": 0}, {"function": "class SingletonPage(Page):\n    @classmethod\n    def can_create_at(cls, parent):\n        # You can only create one of these!\n        return super(SingletonPage, cls).can_create_at(parent) \\\n            and not cls.objects.exists()", "target": 0}, {"function": "class SingletonPageViaMaxCount(Page):\n    max_count = 1", "target": 0}, {"function": "class PageChooserModel(models.Model):\n    page = models.ForeignKey('wagtailcore.Page', help_text='help text', on_delete=models.CASCADE)", "target": 0}, {"function": "class EventPageChooserModel(models.Model):\n    page = models.ForeignKey('tests.EventPage', help_text='more help text', on_delete=models.CASCADE)", "target": 0}, {"function": "class SnippetChooserModel(models.Model):\n    advert = models.ForeignKey(Advert, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advert'),\n    ]", "target": 0}, {"function": "class SnippetChooserModelWithCustomPrimaryKey(models.Model):\n    advertwithcustomprimarykey = models.ForeignKey(AdvertWithCustomPrimaryKey, help_text='help text', on_delete=models.CASCADE)\n\n    panels = [\n        SnippetChooserPanel('advertwithcustomprimarykey'),\n    ]", "target": 0}, {"function": "class CustomImage(AbstractImage):\n    caption = models.CharField(max_length=255, blank=True)\n    fancy_caption = RichTextField(blank=True)\n    not_editable_field = models.CharField(max_length=255, blank=True)\n\n    admin_form_fields = Image.admin_form_fields + (\n        'caption',\n        'fancy_caption',\n    )", "target": 0}, {"function": "class CustomRendition(AbstractRendition):\n    image = models.ForeignKey(CustomImage, related_name='renditions', on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            ('image', 'filter_spec', 'focal_point_key'),\n        )", "target": 0}, {"function": "class CustomDocument(AbstractDocument):\n    description = models.TextField(blank=True)\n    fancy_description = RichTextField(blank=True)\n    admin_form_fields = Document.admin_form_fields + (\n        'description',\n        'fancy_description'\n    )", "target": 0}, {"function": "class StreamModel(models.Model):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])", "target": 0}, {"function": "class ExtendedImageChooserBlock(ImageChooserBlock):\n    \"\"\"\n    Example of Block with custom get_api_representation method.\n    If the request has an 'extended' query param, it returns a dict of id and title,\n    otherwise, it returns the default value.\n    \"\"\"\n    def get_api_representation(self, value, context=None):\n        image_id = super().get_api_representation(value, context=context)\n        if 'request' in context and context['request'].query_params.get('extended', False):\n            return {\n                'id': image_id,\n                'title': value.title\n            }\n        return image_id", "target": 0}, {"function": "class StreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ExtendedImageChooserBlock()),\n        ('product', StructBlock([\n            ('name', CharBlock()),\n            ('price', CharBlock()),\n        ])),\n        ('raw_html', RawHTMLBlock()),\n    ])\n\n    api_fields = ('body',)\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class DefaultStreamPage(Page):\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ], default='')\n\n    content_panels = [\n        FieldPanel('title'),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class MTIBasePage(Page):\n    is_creatable = False\n\n    class Meta:\n        verbose_name = \"MTI Base page\"", "target": 0}, {"function": "class MTIChildPage(MTIBasePage):\n    # Should be creatable by default, no need to set anything\n    pass", "target": 0}, {"function": "class AbstractPage(Page):\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class NotYetRegisteredSetting(BaseSetting):\n    pass", "target": 0}, {"function": "class BlogCategory(models.Model):\n    name = models.CharField(unique=True, max_length=80)", "target": 0}, {"function": "class BlogCategoryBlogPage(models.Model):\n    category = models.ForeignKey(BlogCategory, related_name=\"+\", on_delete=models.CASCADE)\n    page = ParentalKey('ManyToManyBlogPage', related_name='categories', on_delete=models.CASCADE)\n    panels = [\n        FieldPanel('category'),\n    ]", "target": 0}, {"function": "class ManyToManyBlogPage(Page):\n    \"\"\"\n    A page type with two different kinds of M2M relation.\n    We don't formally support these, but we don't want them to cause\n    hard breakages either.\n    \"\"\"\n    body = RichTextField(blank=True)\n    adverts = models.ManyToManyField(Advert, blank=True)\n    blog_categories = models.ManyToManyField(\n        BlogCategory, through=BlogCategoryBlogPage, blank=True)\n\n    # make first_published_at editable on this page model\n    settings_panels = Page.settings_panels + [\n        FieldPanel('first_published_at'),\n    ]", "target": 0}, {"function": "class OneToOnePage(Page):\n    \"\"\"\n    A Page containing a O2O relation.\n    \"\"\"\n    body = RichTextBlock(blank=True)\n    page_ptr = models.OneToOneField(Page, parent_link=True,\n                                    related_name='+', on_delete=models.CASCADE)", "target": 0}, {"function": "class GenericSnippetPage(Page):\n    \"\"\"\n    A page containing a reference to an arbitrary snippet (or any model for that matter)\n    linked by a GenericForeignKey\n    \"\"\"\n    snippet_content_type = models.ForeignKey(ContentType, on_delete=models.SET_NULL, null=True)\n    snippet_object_id = models.PositiveIntegerField(null=True)\n    snippet_content_object = GenericForeignKey('snippet_content_type', 'snippet_object_id')", "target": 0}, {"function": "class CustomImageFilePath(AbstractImage):\n    def get_upload_to(self, filename):\n        \"\"\"Create a path that's file-system friendly.\n\n        By hashing the file's contents we guarantee an equal distribution\n        of files within our root directories. This also gives us a\n        better chance of uploading images with the same filename, but\n        different contents - this isn't guaranteed as we're only using\n        the first three characters of the checksum.\n        \"\"\"\n        original_filepath = super().get_upload_to(filename)\n        folder_name, filename = original_filepath.split(os.path.sep)\n\n        # Ensure that we consume the entire file, we can't guarantee that\n        # the stream has not be partially (or entirely) consumed by\n        # another process\n        original_position = self.file.tell()\n        self.file.seek(0)\n        hash256 = hashlib.sha256()\n\n        while True:\n            data = self.file.read(256)\n            if not data:\n                break\n            hash256.update(data)\n        checksum = hash256.hexdigest()\n\n        self.file.seek(original_position)\n        return os.path.join(folder_name, checksum[:3], filename)", "target": 0}, {"function": "class CustomPageQuerySet(PageQuerySet):\n    def about_spam(self):\n        return self.filter(title__contains='spam')", "target": 0}, {"function": "class CustomManagerPage(Page):\n    objects = CustomManager()", "target": 0}, {"function": "class MyBasePage(Page):\n    \"\"\"\n    A base Page model, used to set site-wide defaults and overrides.\n    \"\"\"\n    objects = CustomManager()\n\n    class Meta:\n        abstract = True", "target": 0}, {"function": "class MyCustomPage(MyBasePage):\n    pass", "target": 0}, {"function": "class ValidatedPage(Page):\n    foo = models.CharField(max_length=255)\n\n    base_form_class = ValidatedPageForm\n    content_panels = Page.content_panels + [\n        FieldPanel('foo'),\n    ]", "target": 0}, {"function": "class DefaultRichTextFieldPage(Page):\n    body = RichTextField()\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class DefaultRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock()),\n    ])\n\n    content_panels = Page.content_panels + [\n        StreamFieldPanel('body')\n    ]", "target": 0}, {"function": "class CustomRichTextFieldPage(Page):\n    body = RichTextField(editor='custom')\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class CustomRichBlockFieldPage(Page):\n    body = StreamField([\n        ('rich_text', RichTextBlock(editor='custom')),\n    ])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        StreamFieldPanel('body'),\n    ]", "target": 0}, {"function": "class RichTextFieldWithFeaturesPage(Page):\n    body = RichTextField(features=['quotation', 'embed', 'made-up-feature'])\n\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        FieldPanel('body'),\n    ]", "target": 0}, {"function": "class SectionedRichTextPageSection(Orderable):\n    page = ParentalKey('tests.SectionedRichTextPage', related_name='sections', on_delete=models.CASCADE)\n    body = RichTextField()\n\n    panels = [\n        FieldPanel('body')\n    ]", "target": 0}, {"function": "class SectionedRichTextPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]", "target": 0}, {"function": "class InlineStreamPageSection(Orderable):\n    page = ParentalKey('tests.InlineStreamPage', related_name='sections', on_delete=models.CASCADE)\n    body = StreamField([\n        ('text', CharBlock()),\n        ('rich_text', RichTextBlock()),\n        ('image', ImageChooserBlock()),\n    ])\n    panels = [\n        StreamFieldPanel('body')\n    ]", "target": 0}, {"function": "class InlineStreamPage(Page):\n    content_panels = [\n        FieldPanel('title', classname=\"full title\"),\n        InlinePanel('sections')\n    ]", "target": 0}, {"function": "class TableBlockStreamPage(Page):\n    table = StreamField([('table', TableBlock())])\n\n    content_panels = [StreamFieldPanel('table')]", "target": 0}, {"function": "class UserProfile(models.Model):\n    # Wagtail's schema must be able to coexist alongside a custom UserProfile model\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    favourite_colour = models.CharField(max_length=255)", "target": 0}, {"function": "class PanelSettings(TestSetting):\n    panels = [\n        FieldPanel('title')\n    ]", "target": 0}, {"function": "class TabbedSettings(TestSetting):\n    edit_handler = TabbedInterface([\n        ObjectList([\n            FieldPanel('title')\n        ], heading='First tab'),\n        ObjectList([\n            FieldPanel('email')\n        ], heading='Second tab'),\n    ])", "target": 0}, {"function": "class AlwaysShowInMenusPage(Page):\n    show_in_menus_default = True", "target": 0}, {"function": "class AddedStreamFieldWithoutDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ])", "target": 0}, {"function": "class AddedStreamFieldWithEmptyStringDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default='')", "target": 0}, {"function": "class AddedStreamFieldWithEmptyListDefaultPage(Page):\n    body = StreamField([\n        ('title', CharBlock())\n    ], default=[])", "target": 0}, {"function": "class PerUserContentPanels(ObjectList):\n    def _replace_children_with_per_user_config(self):\n        self.children = self.instance.basic_content_panels\n        if self.request.user.is_superuser:\n            self.children = self.instance.superuser_content_panels\n        self.children = [\n            child.bind_to(model=self.model, instance=self.instance,\n                          request=self.request, form=self.form)\n            for child in self.children]\n\n    def on_instance_bound(self):\n        # replace list of children when both instance and request are available\n        if self.request:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_instance_bound()\n\n    def on_request_bound(self):\n        # replace list of children when both instance and request are available\n        if self.instance:\n            self._replace_children_with_per_user_config()\n        else:\n            super().on_request_bound()", "target": 0}, {"function": "class PerUserPageMixin:\n    basic_content_panels = []\n    superuser_content_panels = []\n\n    @cached_classmethod\n    def get_edit_handler(cls):\n        tabs = []\n\n        if cls.basic_content_panels and cls.superuser_content_panels:\n            tabs.append(PerUserContentPanels(heading='Content'))\n        if cls.promote_panels:\n            tabs.append(ObjectList(cls.promote_panels,\n                                   heading='Promote'))\n        if cls.settings_panels:\n            tabs.append(ObjectList(cls.settings_panels,\n                                   heading='Settings',\n                                   classname='settings'))\n\n        edit_handler = TabbedInterface(tabs,\n                                       base_form_class=cls.base_form_class)\n\n        return edit_handler.bind_to(model=cls)", "target": 0}, {"function": "class SecretPage(PerUserPageMixin, Page):\n    boring_data = models.TextField()\n    secret_data = models.TextField()\n\n    basic_content_panels = Page.content_panels + [\n        FieldPanel('boring_data'),\n    ]\n    superuser_content_panels = basic_content_panels + [\n        FieldPanel('secret_data'),\n    ]", "target": 0}, {"function": "class SimpleParentPage(Page):\n    # `BusinessIndex` has been added to bring it in line with other tests\n    subpage_types = ['tests.SimpleChildPage', BusinessIndex]", "target": 0}, {"function": "class SimpleChildPage(Page):\n    # `Page` has been added to bring it in line with other tests\n    parent_page_types = ['tests.SimpleParentPage', Page]\n\n    max_count_per_parent = 1", "target": 0}, {"function": "class PersonPage(Page):\n    first_name = models.CharField(\n        max_length=255,\n        verbose_name='First Name',\n    )\n    last_name = models.CharField(\n        max_length=255,\n        verbose_name='Last Name',\n    )\n\n    content_panels = Page.content_panels + [\n        MultiFieldPanel([\n            FieldPanel('first_name'),\n            FieldPanel('last_name'),\n        ], 'Person'),\n        InlinePanel('addresses', label='Address'),\n    ]\n\n    class Meta:\n        verbose_name = 'Person'\n        verbose_name_plural = 'Persons'", "target": 0}, {"function": "class Address(index.Indexed, ClusterableModel, Orderable):\n    address = models.CharField(\n        max_length=255,\n        verbose_name='Address',\n    )\n    tags = ClusterTaggableManager(\n        through='tests.AddressTag',\n        blank=True,\n    )\n    person = ParentalKey(\n        to='tests.PersonPage',\n        related_name='addresses',\n        verbose_name='Person'\n    )\n\n    panels = [\n        FieldPanel('address'),\n        FieldPanel('tags'),\n    ]\n\n    class Meta:\n        verbose_name = 'Address'\n        verbose_name_plural = 'Addresses'", "target": 0}, {"function": "class AddressTag(TaggedItemBase):\n    content_object = ParentalKey(\n        to='tests.Address',\n        on_delete=models.CASCADE,\n        related_name='tagged_items'\n    )", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
