{"index": 10534, "cve_id": "CVE-2015-10010", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "A vulnerability was found in OpenDNS OpenResolve. It has been rated as problematic. Affected by this issue is the function get of the file resolverapi/endpoints.py of the component API. The manipulation leads to cross site scripting. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The name of the patch is c680170d5583cd9342fe1af43001fe8b2b8004dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217196.", "cvss": "6.1", "publish_date": "January 2, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "c680170d5583cd9342fe1af43001fe8b2b8004dd", "commit_message": "Prevent Reflected XSS\n\nThe API takes user input and validates them before making DNS calls but\nif invalid, a response containing the user input is reflected back to\nthe user as it is without any sanitization. This makes OpenResolve\nvulnerable to a reflected XSS attack.", "commit_date": "2015-08-03T23:27:18Z", "project": "opendns/openresolve", "url": "https://api.github.com/repos/opendns/OpenResolve/commits/c680170d5583cd9342fe1af43001fe8b2b8004dd", "html_url": "https://github.com/opendns/OpenResolve/commit/c680170d5583cd9342fe1af43001fe8b2b8004dd", "windows_before": [{"commit_id": "9eba6ba5abd89d0e36a008921eb307fcef8c5311", "commit_date": "Mon Aug 3 16:19:02 2015 -0700", "commit_message": "Log Injection Attack Vulnerability", "files_name": ["resolverapi/endpoints.py"]}, {"commit_id": "e0f7933ae04c7a99b7b4d7fd3da02a61cc949469", "commit_date": "Thu Dec 4 12:45:55 2014 -0800", "commit_message": "do not link to a specific coveralls branch", "files_name": ["README.md"]}, {"commit_id": "8345acfc642ad338de827d11c20aaf5d9f3603f8", "commit_date": "Thu Dec 4 12:40:38 2014 -0800", "commit_message": "Add coveralls icon to README", "files_name": ["README.md"]}, {"commit_id": "ee43d2a980db0c78186a3c0c71f6d30bc341aaea", "commit_date": "Thu Dec 4 12:35:32 2014 -0800", "commit_message": "Add coveralls testing", "files_name": [".travis.yml"]}, {"commit_id": "41d0a0bef10624f9ba6e3473c1e7e30d6bc2e5fb", "commit_date": "Wed Dec 3 23:20:44 2014 -0800", "commit_message": "Not python3.4 - and add travis image", "files_name": [".travis.yml", "README.md"]}, {"commit_id": "aa835378d2976d89c86dba9e50bfb40dda906767", "commit_date": "Wed Dec 3 23:15:43 2014 -0800", "commit_message": "Add travisci integration", "files_name": [".travis.yml"]}, {"commit_id": "86e6cb5e32b9698fad734da9ce4c2be8dea586e0", "commit_date": "Wed Dec 3 18:22:57 2014 -0800", "commit_message": "Create root page for api.openresolve.com", "files_name": ["resolverapi/__init__.py"]}, {"commit_id": "e820623e710aaf4d3196180f1f9b26447e86dd7d", "commit_date": "Wed Dec 3 18:14:49 2014 -0800", "commit_message": "remove pyc files, restore .gitignore and .pylintrc", "files_name": [".gitignore", ".pylintrc", "resolverapi/__init__.pyc", "resolverapi/config.pyc", "resolverapi/endpoints.pyc", "resolverapi/helpers.pyc", "resolverapi/util/__init__.pyc", "resolverapi/util/dns_query.pyc", "tests/__init__.pyc", "tests/test_endpoints.pyc", "tests/test_util.pyc"]}, {"commit_id": "6d50680388baf266b4666c82eff9b670d1590347", "commit_date": "Wed Dec 3 18:08:49 2014 -0800", "commit_message": "Merge pull request #1 from OpenResolve/cors", "files_name": ["4684f37bc6d329b36cb5ce294dd70f35a88c478d - Wed Dec 3 17:56:43 2014 -0800 : cors support", "Dockerfile", "README.md", "requirements.txt", "resolverapi/__init__.py"]}, {"commit_id": "dc29bd3d6d10f84f6b1c73c9f3e2d4acd18eebb3", "commit_date": "Wed Dec 3 16:44:40 2014 -0800", "commit_message": "Update README.md", "files_name": ["README.md"]}, {"commit_id": "533ff18c61f0d23d46483479da09ae924807a04e", "commit_date": "Wed Dec 3 16:40:12 2014 -0800", "commit_message": "Initial commit 2/2", "files_name": ["resolverapi/__init__.py", "resolverapi/__init__.pyc", "resolverapi/config.py", "resolverapi/config.pyc", "resolverapi/endpoints.py", "resolverapi/endpoints.pyc", "resolverapi/helpers.pyc", "resolverapi/util/__init__.py", "resolverapi/util/__init__.pyc", "resolverapi/util/dns_query.py", "resolverapi/util/dns_query.pyc"]}, {"commit_id": "6aa7795d50a25556c769b148c65951f68538e95f", "commit_date": "Wed Dec 3 16:27:09 2014 -0800", "commit_message": "Initial commit 1/2", "files_name": ["Dockerfile", "LICENSE", "README.md", "conf/nginx-app.conf", "conf/supervisor-app.conf", "conf/uwsgi_params", "requirements-dev.txt", "requirements.txt", "run.py", "setup.py", "tests/__init__.py", "tests/__init__.pyc", "tests/test_endpoints.py", "tests/test_endpoints.pyc", "tests/test_util.py", "tests/test_util.pyc", "uwsgi.ini"]}], "windows_after": [{"commit_id": "95110785cf2b8cf03f69ed8adb1731c8e115a63c", "commit_date": "Mon Aug 3 16:30:44 2015 -0700", "commit_message": "Merge pull request #2 from OpenResolve/security-improvements", "files_name": ["10c0cee909a2700572073ea60be28d7d878cf120 - Mon Aug 3 16:52:42 2015 -0700 : Fix Tests after Reflected XSS", "resolverapi/endpoints.py", "tests/test_endpoints.py"]}, {"commit_id": "a3ca24569624639029d3eabb78bf53f711a7e024", "commit_date": "Mon Aug 3 16:57:47 2015 -0700", "commit_message": "README updates", "files_name": ["README.md"]}], "parents": [{"commit_id_before": "9eba6ba5abd89d0e36a008921eb307fcef8c5311", "url_before": "https://api.github.com/repos/opendns/OpenResolve/commits/9eba6ba5abd89d0e36a008921eb307fcef8c5311", "html_url_before": "https://github.com/opendns/OpenResolve/commit/9eba6ba5abd89d0e36a008921eb307fcef8c5311"}], "details": [{"raw_url": "https://github.com/opendns/OpenResolve/raw/c680170d5583cd9342fe1af43001fe8b2b8004dd/resolverapi%2Fendpoints.py", "code": "from flask import current_app, request\nfrom flask_restful import Resource, abort\nfrom dns import reversename, rdatatype\nfrom dns.resolver import NXDOMAIN, NoNameservers\n\nfrom resolverapi.util import is_valid_hostname, is_valid_rdtype, is_valid_ip\nfrom resolverapi.util.dns_query import parse_query\nfrom resolverapi import dns_resolver\n\nimport time\nfrom dns.exception import Timeout\n\n\nclass LookupRecordType(Resource):\n\n    def get(self, rdtype, domain):\n        t1 = time.time()\n\n        rdtype = rdtype.upper()\n        current_app.logger.info(\n            'Request from %s - %s', request.remote_addr, rdtype)\n        self.valid_args(rdtype, domain)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                answer = dns_resolver.query(\n                    domain, rdtype, raise_on_no_answer=False)\n                # Successful query\n                break\n            except (NoNameservers, NXDOMAIN):\n                # TODO: this should still follow the RFC\n                return {'message': \"No nameservers for %s\" % domain}, 404\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, rdtype, domain):\n        if not is_valid_rdtype(rdtype):\n            abort(400, message=\"The provided record type is not supported\")\n        if not is_valid_hostname(domain):\n            abort(400, message=\"The provided domain name is invalid\")\n\n\nclass ReverseLookup(Resource):\n\n    def get(self, ip):\n        t1 = time.time()\n        self.valid_args(ip)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                # http://stackoverflow.com/a/19867936/1707152\n                answer = dns_resolver.query(\n                    reversename.from_address(ip), rdatatype.PTR,\n                    raise_on_no_answer=False)\n                # Successful query\n                break\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except NXDOMAIN:\n                return {'message': 'No nameserver found for the provided IP'}, 404\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        if answer is None:\n            return {'message': 'An unexpected error occured.'}, 500\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, ip):\n        if not is_valid_ip(ip):\n            abort(400, message=\"The provided ip address is invalid\")\n", "code_before": "from flask import current_app, request\nfrom flask_restful import Resource, abort\nfrom dns import reversename, rdatatype\nfrom dns.resolver import NXDOMAIN, NoNameservers\n\nfrom resolverapi.util import is_valid_hostname, is_valid_rdtype, is_valid_ip\nfrom resolverapi.util.dns_query import parse_query\nfrom resolverapi import dns_resolver\n\nimport time\nfrom dns.exception import Timeout\n\n\nclass LookupRecordType(Resource):\n\n    def get(self, rdtype, domain):\n        t1 = time.time()\n\n        rdtype = rdtype.upper()\n        current_app.logger.info(\n            'Request from %s - %s', request.remote_addr, rdtype)\n        self.valid_args(rdtype, domain)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                answer = dns_resolver.query(\n                    domain, rdtype, raise_on_no_answer=False)\n                # Successful query\n                break\n            except (NoNameservers, NXDOMAIN):\n                # TODO: this should still follow the RFC\n                return {'message': \"No nameservers for %s\" % domain}, 404\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, rdtype, domain):\n        if not is_valid_rdtype(rdtype):\n            abort(400, message=\"%s type is not supported\" % rdtype)\n        if not is_valid_hostname(domain):\n            abort(400, message=\"%s is not a valid domain name\" % domain)\n\n\nclass ReverseLookup(Resource):\n\n    def get(self, ip):\n        t1 = time.time()\n        self.valid_args(ip)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                # http://stackoverflow.com/a/19867936/1707152\n                answer = dns_resolver.query(\n                    reversename.from_address(ip), rdatatype.PTR,\n                    raise_on_no_answer=False)\n                # Successful query\n                break\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except NXDOMAIN:\n                return {'message': 'No nameserver found for %s' % ip}, 404\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        if answer is None:\n            return {'message': 'An unexpected error occured.'}, 500\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, ip):\n        if not is_valid_ip(ip):\n            abort(400, message=\"%s is not a valid ip address\" % ip)\n", "patch": "@@ -50,9 +50,9 @@ def get(self, rdtype, domain):\n \n     def valid_args(self, rdtype, domain):\n         if not is_valid_rdtype(rdtype):\n-            abort(400, message=\"%s type is not supported\" % rdtype)\n+            abort(400, message=\"The provided record type is not supported\")\n         if not is_valid_hostname(domain):\n-            abort(400, message=\"%s is not a valid domain name\" % domain)\n+            abort(400, message=\"The provided domain name is invalid\")\n \n \n class ReverseLookup(Resource):\n@@ -79,7 +79,7 @@ def get(self, ip):\n                     return {'message': 'All nameservers timed out.'}, 503\n                 continue\n             except NXDOMAIN:\n-                return {'message': 'No nameserver found for %s' % ip}, 404\n+                return {'message': 'No nameserver found for the provided IP'}, 404\n             except Exception as e:\n                 current_app.logger.error(e)\n                 return {'message': 'An unexpected error occured.'}, 500\n@@ -93,4 +93,4 @@ def get(self, ip):\n \n     def valid_args(self, ip):\n         if not is_valid_ip(ip):\n-            abort(400, message=\"%s is not a valid ip address\" % ip)\n+            abort(400, message=\"The provided ip address is invalid\")", "file_path": "files/2023_1/2222", "file_language": "py", "file_name": "resolverapi/endpoints.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 1, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class LookupRecordType(Resource):\n\n    def get(self, rdtype, domain):\n        t1 = time.time()\n\n        rdtype = rdtype.upper()\n        current_app.logger.info(\n            'Request from %s - %s', request.remote_addr, rdtype)\n        self.valid_args(rdtype, domain)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                answer = dns_resolver.query(\n                    domain, rdtype, raise_on_no_answer=False)\n                # Successful query\n                break\n            except (NoNameservers, NXDOMAIN):\n                # TODO: this should still follow the RFC\n                return {'message': \"No nameservers for %s\" % domain}, 404\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, rdtype, domain):\n        if not is_valid_rdtype(rdtype):\n            abort(400, message=\"%s type is not supported\" % rdtype)\n        if not is_valid_hostname(domain):\n            abort(400, message=\"%s is not a valid domain name\" % domain)", "target": 0}, {"function": "class ReverseLookup(Resource):\n\n    def get(self, ip):\n        t1 = time.time()\n        self.valid_args(ip)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                # http://stackoverflow.com/a/19867936/1707152\n                answer = dns_resolver.query(\n                    reversename.from_address(ip), rdatatype.PTR,\n                    raise_on_no_answer=False)\n                # Successful query\n                break\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except NXDOMAIN:\n                return {'message': 'No nameserver found for %s' % ip}, 404\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        if answer is None:\n            return {'message': 'An unexpected error occured.'}, 500\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, ip):\n        if not is_valid_ip(ip):\n            abort(400, message=\"%s is not a valid ip address\" % ip)", "target": 0}], "function_after": [{"function": "class LookupRecordType(Resource):\n\n    def get(self, rdtype, domain):\n        t1 = time.time()\n\n        rdtype = rdtype.upper()\n        current_app.logger.info(\n            'Request from %s - %s', request.remote_addr, rdtype)\n        self.valid_args(rdtype, domain)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                answer = dns_resolver.query(\n                    domain, rdtype, raise_on_no_answer=False)\n                # Successful query\n                break\n            except (NoNameservers, NXDOMAIN):\n                # TODO: this should still follow the RFC\n                return {'message': \"No nameservers for %s\" % domain}, 404\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, rdtype, domain):\n        if not is_valid_rdtype(rdtype):\n            abort(400, message=\"The provided record type is not supported\")\n        if not is_valid_hostname(domain):\n            abort(400, message=\"The provided domain name is invalid\")", "target": 0}, {"function": "class ReverseLookup(Resource):\n\n    def get(self, ip):\n        t1 = time.time()\n        self.valid_args(ip)\n\n        # Iterate through nameservers so that we can tell which one gets used.\n        nameservers = current_app.config['RESOLVERS']\n        for nameserver in nameservers:\n            dns_resolver.nameservers = [nameserver]\n            try:\n                # http://stackoverflow.com/a/19867936/1707152\n                answer = dns_resolver.query(\n                    reversename.from_address(ip), rdatatype.PTR,\n                    raise_on_no_answer=False)\n                # Successful query\n                break\n            except Timeout as e:\n                # Communication fail or timeout - try next nameserver\n                if nameserver is nameservers[-1]:\n                    current_app.logger.info(e)\n                    return {'message': 'All nameservers timed out.'}, 503\n                continue\n            except NXDOMAIN:\n                return {'message': 'No nameserver found for the provided IP'}, 404\n            except Exception as e:\n                current_app.logger.error(e)\n                return {'message': 'An unexpected error occured.'}, 500\n\n        t2 = time.time()\n        duration = t2 - t1\n\n        if answer is None:\n            return {'message': 'An unexpected error occured.'}, 500\n        return parse_query(answer, nameserver, duration)\n\n    def valid_args(self, ip):\n        if not is_valid_ip(ip):\n            abort(400, message=\"The provided ip address is invalid\")", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
