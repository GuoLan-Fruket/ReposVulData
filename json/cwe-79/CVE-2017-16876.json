{"index": 2578, "cve_id": "CVE-2017-16876", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Cross-site scripting (XSS) vulnerability in the _keyify function in mistune.py in Mistune before 0.8.1 allows remote attackers to inject arbitrary web script or HTML by leveraging failure to escape the \"key\" argument.", "cvss": "6.1", "publish_date": "December 29, 2017", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "5f06d724bc05580e7f203db2d4a4905fc1127f98", "commit_message": "Fix CVE-2017-16876", "commit_date": "2017-11-20T15:15:09Z", "project": "lepture/mistune", "url": "https://api.github.com/repos/lepture/mistune/commits/5f06d724bc05580e7f203db2d4a4905fc1127f98", "html_url": "https://github.com/lepture/mistune/commit/5f06d724bc05580e7f203db2d4a4905fc1127f98", "windows_before": [{"commit_id": "7f7f106a717e6cf58012304e56b41d6fb2b98e5f", "commit_date": "Thu Oct 26 10:00:30 2017 -0700", "commit_message": "Version bump 0.8", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "f8ac83ff6d49c0e850436b8d9e57b71c3b2c4d57", "commit_date": "Thu Oct 26 09:56:30 2017 -0700", "commit_message": "Cleanup appveyor CI", "files_name": ["appveyor.yml"]}, {"commit_id": "dda2ace2c74b534c82ba3a9571ee8e0bddba9e0e", "commit_date": "Thu Oct 26 09:55:33 2017 -0700", "commit_message": "Fix CI testing", "files_name": [".travis.yml", "appveyor.yml", "tox.ini"]}, {"commit_id": "ab8f7de8bc78c2a88f9e01522b8a3a0aa8cd9416", "commit_date": "Thu Oct 26 09:49:10 2017 -0700", "commit_message": "Merge pull request #140 from junorouse/master", "files_name": ["d6f0b6402299bf5a380e7b4e77bd80e8736630fe - Thu Oct 19 01:13:52 2017 +0900 : Fix bypassing XSS vulnerability.", "mistune.py", "tests/__init__.py", "tests/test_extra.py"]}, {"commit_id": "5b8c3f7db4321bada0b955a9fb833a3faba4a67f", "commit_date": "Fri Jun 2 15:12:50 2017 +0900", "commit_message": "Change donate link", "files_name": ["README.rst"]}, {"commit_id": "4c117151ab536004599b0d5a8079ccda84cc5472", "commit_date": "Thu May 18 14:38:50 2017 +0100", "commit_message": "Add missing regex import to Lexers example (#129)", "files_name": ["README.rst"]}, {"commit_id": "e9e2066fee8ea4970cec17f1e480031db96906b9", "commit_date": "Mon May 8 18:19:12 2017 +0900", "commit_message": "Update benchmark for misaka", "files_name": ["tests/bench.py"]}, {"commit_id": "56f6f4b9d4cd237ac088077530e1d549d22d8b5d", "commit_date": "Mon May 8 18:15:42 2017 +0900", "commit_message": "Remove rev and rel attribute for footnotes.", "files_name": ["mistune.py", "tests/fixtures/extra/footnotes.html"]}, {"commit_id": "1a50827a8de4849aeb865934d1f73b8fb5b2252d", "commit_date": "Thu Mar 16 17:48:50 2017 +0900", "commit_message": "Remove non breaking spaces preprocessing #125", "files_name": ["mistune.py"]}, {"commit_id": "714e60a20a7efe0923bc39991d989b3ef3324690", "commit_date": "Tue Mar 14 15:57:45 2017 +0900", "commit_message": "Version bump 0.7.4", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "556dcb6aa2e10051602649a92aecf43deebcd746", "commit_date": "Fri Jan 20 23:46:22 2017 -0800", "commit_message": "Use kleene star to allow empty alt text attrs (#123)", "files_name": ["mistune.py"]}, {"commit_id": "f7b5239ab73d576f55041bc87b40c46dcc4707fb", "commit_date": "Sat Jan 14 10:49:16 2017 +0900", "commit_message": "Fix HTML attribute regex", "files_name": ["mistune.py", "tests/test_extra.py"]}, {"commit_id": "1e551e1213ad7d722922f6448711a365702cdff0", "commit_date": "Sun Dec 18 10:50:31 2016 +0900", "commit_message": "Remove useless code line_started in InlineLexer", "files_name": ["mistune.py"]}, {"commit_id": "406e043bc6117e18e353d3819ed4ca729219802f", "commit_date": "Wed Nov 2 16:43:03 2016 +0900", "commit_message": "No escape text for parse_block_html", "files_name": ["mistune.py"]}, {"commit_id": "dd6957036ab269c484cfa3d04c919cea66188e44", "commit_date": "Mon Oct 24 15:55:46 2016 +0900", "commit_message": "Prepare for next release", "files_name": ["CHANGES.rst", "README.rst", "mistune.py"]}, {"commit_id": "e3417cb593191067d66747a413eada47d3f6e028", "commit_date": "Thu Oct 20 11:19:24 2016 +0900", "commit_message": "Fix escape option for text renderer", "files_name": ["mistune.py"]}, {"commit_id": "d45c262aa1fe61d040b993cedd102d76a02a9c8b", "commit_date": "Fri Jul 29 11:44:28 2016 +0900", "commit_message": "Fix test cases", "files_name": ["tests/test_extra.py"]}, {"commit_id": "f1a3d8a8793cc50e7b3990050fc5c594ba53da0e", "commit_date": "Fri Jul 29 11:38:50 2016 +0900", "commit_message": "Use expandtabs.", "files_name": ["mistune.py"]}, {"commit_id": "ac77ee2072d93b7df7e40022b25a70d06314a317", "commit_date": "Mon Jul 25 23:06:51 2016 +0900", "commit_message": "HTML attribute allows numbers without quote", "files_name": ["mistune.py"]}, {"commit_id": "32f50703c5e1980ea0165ec528b7ff16d6af01c3", "commit_date": "Mon Jul 25 23:02:06 2016 +0900", "commit_message": "Remove text/html data uri from blacklist.", "files_name": ["mistune.py"]}, {"commit_id": "c337b97f2cb47bd54c3ce836b09b04d6182e5a91", "commit_date": "Mon Jul 25 10:01:04 2016 -0400", "commit_message": "Handle block HTML with no content (#111)", "files_name": ["mistune.py", "tests/fixtures/normal/inline_html_simple.html", "tests/fixtures/normal/inline_html_simple.text"]}, {"commit_id": "c7c29c5c1abb43ead502b53debe0b71f00d86ed3", "commit_date": "Mon Jul 18 10:37:06 2016 +0800", "commit_message": "Refactor escape_link, no more parameters", "files_name": ["mistune.py"]}, {"commit_id": "3968048569ef62b3d2004ab6efd175672e3974cf", "commit_date": "Mon Jul 18 10:26:52 2016 +0800", "commit_message": "Revert \"Only escape link when in escape option.\"", "files_name": ["mistune.py"]}, {"commit_id": "24029cd8c9f1c273055f272d8d05b7c360cf56ff", "commit_date": "Sun Jul 17 10:05:04 2016 +0800", "commit_message": "Only escape link when in escape option.", "files_name": ["mistune.py"]}, {"commit_id": "8a31fac515a8883aa524f87cc5b60300d2dfb125", "commit_date": "Wed Jul 13 08:20:56 2016 -0500", "commit_message": "Allows trailing whitespace before closing > in inline/block html (#105)", "files_name": ["mistune.py", "tests/test_extra.py"]}, {"commit_id": "6a070d550d0573a5165e75c9d4cff94483a45e4c", "commit_date": "Wed Jul 13 08:20:37 2016 -0500", "commit_message": "Fixes `escape_link` for `\\x1a` prefixed url schemes (#106)", "files_name": ["mistune.py"]}, {"commit_id": "715046fe4b5f3642b24edc7fdd62ba8915228498", "commit_date": "Wed Jul 6 10:29:27 2016 +0900", "commit_message": "Don't eat all data protocol. Only ignore data:text/html", "files_name": ["mistune.py"]}, {"commit_id": "b93f3f17f8ec21f99cdc2e39215aebf1a900f20a", "commit_date": "Tue Jun 28 16:59:37 2016 +0900", "commit_message": "Version bump 0.7.3", "files_name": ["CHANGES.rst", "README.rst", "mistune.py"]}, {"commit_id": "eb26053d960e7dc68e2dce0aaddbed998add2fd7", "commit_date": "Tue Jun 7 11:31:35 2016 +0200", "commit_message": "Escape sequences should be treated as text by the renderer. (#97)", "files_name": ["mistune.py", "tests/fixtures/extra/escaped_angles.html", "tests/fixtures/normal/backslash_escapes.html"]}, {"commit_id": "63b85a943b13209f770cd4deb1df014d4d3f8eec", "commit_date": "Mon May 23 00:52:51 2016 +0900", "commit_message": "Fix close tag regex patterns", "files_name": ["mistune.py"]}, {"commit_id": "2a33458a589659d2743961d762aff8b8eb7e1890", "commit_date": "Mon May 23 00:38:06 2016 +0900", "commit_message": "Fix html attribute regex. Close #99", "files_name": ["mistune.py"]}, {"commit_id": "1076727360eb06c267716bfc43641565d9afca53", "commit_date": "Wed Apr 6 22:39:29 2016 +0100", "commit_message": "Fixed #95: Corrected strikethrough pattern and added to test fixture.", "files_name": ["mistune.py", "tests/fixtures/extra/gfm_del.html", "tests/fixtures/extra/gfm_del.text"]}, {"commit_id": "9c15c0f8d76e9d0fca8b2f41de214e43ee16c732", "commit_date": "Mon Apr 4 13:28:05 2016 +0900", "commit_message": "Fix strikthrough regular expression", "files_name": ["mistune.py"]}, {"commit_id": "28f31d3b4f612d592d2e04d67705306d479c54c2", "commit_date": "Fri Feb 26 10:42:04 2016 +0900", "commit_message": "Version bump v0.7.2", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "7720190f6fa86e1af71da2593b4843254295dff2", "commit_date": "Fri Feb 26 00:37:09 2016 +0100", "commit_message": "Fix bypass", "files_name": ["mistune.py", "tests/test_extra.py"]}, {"commit_id": "6a9d23d2fa5d9c5a530b2658d634d663f05171cb", "commit_date": "Fri Feb 26 00:31:34 2016 +0100", "commit_message": "Fix #80 and #87", "files_name": ["mistune.py", "tests/fixtures/normal/amps_and_angles_encoding.html", "tests/test_extra.py"]}, {"commit_id": "0ad832fcc14edc8e609f47c5ae33a0030831d775", "commit_date": "Fri Feb 12 10:52:19 2016 +0900", "commit_message": "Fix appveyor", "files_name": ["appveyor.yml"]}, {"commit_id": "3e9b93f2f91b63a4da9224736476ceb447267d5a", "commit_date": "Thu Feb 11 14:41:23 2016 -0500", "commit_message": "Fix emphasis regex", "files_name": ["mistune.py"]}, {"commit_id": "ae552c386b80bcddb4940d31b53ab0049e1b0d79", "commit_date": "Thu Feb 11 10:25:56 2016 -0500", "commit_message": "Fix emphasis regex in the _ case.", "files_name": ["mistune.py"]}, {"commit_id": "95777bacf7c583058bd6747764ba141ab0851234", "commit_date": "Sun Nov 8 16:32:23 2015 +0800", "commit_message": "Prepare for next release 0.7.2", "files_name": ["CHANGES.rst"]}, {"commit_id": "86919082e44f7256557646f4a764e2af92e53951", "commit_date": "Sat Nov 7 22:55:20 2015 +0800", "commit_message": "fix module import", "files_name": ["README.rst"]}, {"commit_id": "920f88d4634cc6c70376eecbce12772571d136da", "commit_date": "Mon Nov 2 22:58:38 2015 +0800", "commit_message": "Fix test cases, add hard_wrap option test case.", "files_name": ["tests/test_cases.py", "tests/test_extra.py"]}, {"commit_id": "8c8fc2f487abf2c5fbf76d4bcd8fd4c927700537", "commit_date": "Mon Nov 2 22:57:32 2015 +0800", "commit_message": "Use config on renderer", "files_name": ["mistune.py"]}, {"commit_id": "1b654d176d98958e7014b514a213fe10e013b285", "commit_date": "Thu Oct 22 17:20:36 2015 +0200", "commit_message": "Fix typo in comment, doc string etc.", "files_name": ["mistune.py"]}, {"commit_id": "878f92bdb224a8b7830e8c33952bd2f368e5d711", "commit_date": "Sat Aug 22 23:29:14 2015 +0800", "commit_message": "Version bump 0.7.1", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "8ca5d5bbd59306c5ef731a0cccee3b9576e2effe", "commit_date": "Tue Aug 11 15:56:41 2015 +0800", "commit_message": "Docs on hard_wrap with suggestion #68", "files_name": ["README.rst"]}, {"commit_id": "857862bc961f4c3a3daa024a5e824a45b035a3da", "commit_date": "Wed Aug 5 23:38:57 2015 +0800", "commit_message": "Add test case for #67", "files_name": ["tests/test_extra.py"]}, {"commit_id": "b596dc1af5e41148aaa6abf2923b1693b40adabe", "commit_date": "Wed Aug 5 23:36:25 2015 +0800", "commit_message": "Fix inline_html when there is no content. #67", "files_name": ["mistune.py"]}, {"commit_id": "b909b647638a8fd8761191bb35218bfd6dd43722", "commit_date": "Tue Aug 4 17:55:55 2015 +0800", "commit_message": "Pre-compile block quote and block code leading regex for speeding", "files_name": ["mistune.py"]}, {"commit_id": "bba78f3dd802e37b514a60c3ff0d768b33c39fb2", "commit_date": "Thu Jul 30 11:58:06 2015 +0800", "commit_message": "Change appveyor badge style. More tests for coverage 100%", "files_name": ["README.rst", "tests/test_extra.py"]}, {"commit_id": "8e060f31c7cb94a2d5f727e5519dbf19be14b992", "commit_date": "Sat Jul 18 20:41:50 2015 +0800", "commit_message": "Version bump 0.7", "files_name": ["CHANGES.rst", "README.rst", "mistune.py"]}, {"commit_id": "4273635bb2e0f623f72b927b3d4da890cf7c568b", "commit_date": "Mon Jul 13 15:41:42 2015 +0800", "commit_message": "Remove parse_html option", "files_name": ["CHANGES.rst", "README.rst", "mistune.py", "tests/test_extra.py"]}, {"commit_id": "29ad717cf45945fc92359c1b6919b2934080cac3", "commit_date": "Mon Jul 13 15:39:31 2015 +0800", "commit_message": "Fix render inline html with escape off", "files_name": ["mistune.py"]}, {"commit_id": "bcede6405e812ab879a7414fbf368e4954c0ebf3", "commit_date": "Mon Jul 13 15:33:59 2015 +0800", "commit_message": "Make close/open html separated", "files_name": ["mistune.py"]}, {"commit_id": "a775e9007bbf0eb5255f2b6451df451c91ceb896", "commit_date": "Sun Jul 12 16:09:52 2015 +0800", "commit_message": "Fix test case to inspect wrong escape", "files_name": ["tests/test_extra.py"]}], "windows_after": [{"commit_id": "cef69acaa506567595e95ab6ecea25a806de622e", "commit_date": "Tue Nov 21 00:17:28 2017 +0900", "commit_message": "Add change log for v0.8.1", "files_name": ["CHANGES.rst"]}, {"commit_id": "3fabfe4e96dcfd8c25d186058a1a84bce1b3fd42", "commit_date": "Tue Nov 28 16:49:42 2017 -0800", "commit_message": "Fix #137 nested html issue", "files_name": ["mistune.py"]}, {"commit_id": "54b299153d6f4c7bb0366856617fdb230f99ce67", "commit_date": "Wed Nov 29 09:45:59 2017 -0800", "commit_message": "Add test case for PR #143", "files_name": ["tests/test_extra.py"]}, {"commit_id": "e90cf3dd63797ec8994f8cb78aea1590dec26f07", "commit_date": "Thu Nov 30 14:23:03 2017 +0900", "commit_message": "Merge pull request #143 from frostming/patch-1", "files_name": ["b8da37ec3d0e6f63273e37a7c47a0f00bd477db0 - Mon Dec 4 13:57:27 2017 +0900 : Version bump 0.8.2", "CHANGES.rst", "appveyor.yml", "mistune.py"]}, {"commit_id": "787c34ea75142ced3b742558d9d390089508ca2b", "commit_date": "Mon Dec 4 13:59:07 2017 +0900", "commit_message": "Merge branch 'master' of github.com:lepture/mistune", "files_name": ["92b7f32664bad1a4b3740ee81eda47e5246e780f - Mon Dec 4 14:01:44 2017 +0900 : Version bump 0.8.3", "CHANGES.rst", "mistune.py"]}, {"commit_id": "1c74f10137ecbde7a3a26dd0164b93d9cfef2af8", "commit_date": "Wed Jan 31 15:10:07 2018 +0100", "commit_message": "Support an escaped pipe char in a table cell", "files_name": ["mistune.py", "tests/fixtures/extra/gfm_tables.html", "tests/fixtures/extra/gfm_tables.text"]}, {"commit_id": "0b22d1a7d8812f05fce0307a6f524896cd64846f", "commit_date": "Thu Feb 1 18:39:05 2018 +0900", "commit_message": "Merge pull request #150 from lazyfrosch/pipe-char-in-table", "files_name": ["01ad70419691d1b4fa22d068c5fb46bff24d632e - Mon Feb 5 12:55:03 2018 +0800 : Fix parsing error #151 on heterogeneous list", "mistune.py", "tests/fixtures/extra/hetero_list.html", "tests/fixtures/extra/hetero_list.text"]}, {"commit_id": "fbdd84835e312bb0dd25a127b3b475bbfc696cdf", "commit_date": "Tue Feb 6 12:41:35 2018 +0800", "commit_message": "hetero list test case", "files_name": ["mistune.py", "tests/fixtures/extra/hetero_list.html", "tests/fixtures/extra/hetero_list.text"]}, {"commit_id": "2a3f96fc893635d7d2b3fe17bd505edaa1920c80", "commit_date": "Tue Feb 6 14:05:02 2018 +0800", "commit_message": "newlines at EOF", "files_name": ["tests/fixtures/extra/hetero_list.html", "tests/fixtures/extra/hetero_list.text"]}, {"commit_id": "01370dcedad2410f62aa4109f70656ad94232a05", "commit_date": "Tue Feb 6 18:42:16 2018 +0900", "commit_message": "Merge pull request #152 from frostming/hetero-list", "files_name": ["1e7a75bd5ed4f2cde180fab5427d763a4dc987e4 - Sun Mar 4 23:09:01 2018 +0200 : Update Python versions", "README.rst"]}, {"commit_id": "fe666068186cba14d1c82a08f6e17b39921c1247", "commit_date": "Sun Mar 4 23:12:17 2018 +0200", "commit_message": "Update Python versions", "files_name": ["setup.py"]}, {"commit_id": "2804685f04c302db51ae96d4292b94e38bd475d6", "commit_date": "Sun Mar 4 23:14:30 2018 +0200", "commit_message": "Remove redundant version check", "files_name": ["setup.py"]}, {"commit_id": "c365503e1319f28e77ec68dc5a2e152587d406be", "commit_date": "Wed May 2 20:36:10 2018 +0900", "commit_message": "Merge pull request #153 from hugovk/patch-1", "files_name": ["4ac88f5e1c6658e16eb17165f75e9fea9d37fdaa - Fri Sep 7 21:33:52 2018 +0900 : Fix minors in tests (#175)", "tests/test_extra.py", "tests/test_subclassing.py"]}, {"commit_id": "4ad66e28ebdf509b25fbc6cc33d3997aa0dabffd", "commit_date": "Sat Sep 15 11:27:53 2018 +0900", "commit_message": "Fix spaces between = in HTML tags", "files_name": ["mistune.py", "tests/test_extra.py"]}, {"commit_id": "bd36ac34348e96bbd88ef19bdbfa48b04e654422", "commit_date": "Sat Sep 15 11:59:59 2018 +0900", "commit_message": "Add changelog for v0.8.4", "files_name": ["CHANGES.rst", "README.rst"]}, {"commit_id": "b95d42035fc8d3ad7e84635930a2a40b4a552b5e", "commit_date": "Sat Sep 15 12:00:43 2018 +0900", "commit_message": "Add max_recursive_depth for list and blockquote.", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "583d358296bb10c0f66ba643e9ee574e8af96db0", "commit_date": "Sat Sep 15 12:05:32 2018 +0900", "commit_message": "Fix fences code block.", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "e586d8e0d126bdfe3df8e031a8206c826dc0eaf2", "commit_date": "Thu Oct 11 15:48:05 2018 +0900", "commit_message": "Add test cases for nested blockquote and list", "files_name": ["mistune.py", "tests/fixtures/extra/nested_blockquotes.html", "tests/fixtures/extra/nested_blockquotes.text", "tests/fixtures/extra/nested_list.html", "tests/fixtures/extra/nested_list.text"]}, {"commit_id": "eeb8a9791e2aa14a4d29de15db67694a2604f828", "commit_date": "Thu Oct 11 15:57:53 2018 +0900", "commit_message": "Build without cython", "files_name": ["setup.py"]}, {"commit_id": "6470c42b2087a4649ad0437227cf7b5c570c3a91", "commit_date": "Thu Oct 11 15:58:49 2018 +0900", "commit_message": "Version bump 0.8.4", "files_name": ["CHANGES.rst", "mistune.py"]}, {"commit_id": "b534644c1602bd5d43096bc45c23f7bc7048b74a", "commit_date": "Fri Nov 2 21:13:29 2018 +0900", "commit_message": "Update donate badge", "files_name": ["README.rst"]}, {"commit_id": "e972e41f3f7101409d8eb1dde2df54b80242e2cb", "commit_date": "Tue Dec 11 22:27:56 2018 +0900", "commit_message": "Init with inline token parser", "files_name": ["src/mistune/inlines.py", "src/mistune/renderer.py", "src/mistune/scanner.py"]}, {"commit_id": "2e9f818f76a68db9a44efac9abffc86c29c8b53d", "commit_date": "Wed Dec 12 21:52:31 2018 +0900", "commit_message": "Add tests for inline parser", "files_name": ["src/mistune/__init__.py", "src/mistune/inlines.py", "src/mistune/renderers.py", "src/mistune/scanner.py", "src/tests/__init__.py", "src/tests/fixtures/__init__.py", "src/tests/fixtures/inlines.txt", "src/tests/test_inlines.py"]}, {"commit_id": "e89ec96deee97f2e0aeff687533af63987e201bd", "commit_date": "Wed Dec 12 22:31:18 2018 +0900", "commit_message": "Share ScannerParser", "files_name": ["src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/scanner.py"]}, {"commit_id": "c815e1f774c36f50c82c1fc380a1e2143af9c2bc", "commit_date": "Sat Dec 15 10:37:20 2018 +0900", "commit_message": "block parsing flow works", "files_name": ["src/mistune/__init__.py", "src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/markdown.py", "src/mistune/renderers.py", "src/mistune/scanner.py", "src/tests/test_inlines.py"]}, {"commit_id": "701461292153d8b47a8294d1629352c65c3aa35b", "commit_date": "Sat Dec 15 11:39:56 2018 +0900", "commit_message": "Add blockquote", "files_name": ["src/mistune/blocks.py", "src/mistune/renderers.py"]}, {"commit_id": "e1eb0a2b3ce7c7b73e5520931ae17578c30f071e", "commit_date": "Sat Dec 15 17:20:15 2018 +0900", "commit_message": "Add table plugin", "files_name": ["src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/markdown.py", "src/mistune/plugins/__init__.py", "src/mistune/plugins/table.py", "src/mistune/renderers.py"]}, {"commit_id": "d6f973e92b46d155994f214a1298c43e74248d92", "commit_date": "Sat Dec 15 22:00:59 2018 +0900", "commit_message": "block html works now.", "files_name": ["src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/renderers.py", "src/mistune/scanner.py"]}, {"commit_id": "fc52808a1a959c5312da5d4caa28ae94f273ba6a", "commit_date": "Sun Dec 16 10:14:09 2018 +0900", "commit_message": "Add render html toc", "files_name": ["src/mistune/plugins/toc.py"]}, {"commit_id": "09db2d70a857d03a30a0ba1d9eeabc43cc85dd4f", "commit_date": "Sun Dec 16 14:36:49 2018 +0900", "commit_message": "Add admonition plugin. Fix toc plugin.", "files_name": ["src/mistune/blocks.py", "src/mistune/markdown.py", "src/mistune/plugins/admonition.py", "src/mistune/plugins/table.py", "src/mistune/plugins/toc.py", "src/mistune/renderers.py"]}, {"commit_id": "38ee6d3c23ed395dc5d063eef9edca105307b591", "commit_date": "Sun Dec 16 14:49:07 2018 +0900", "commit_message": "Rename admonition to directive", "files_name": ["src/mistune/plugins/directive.py"]}, {"commit_id": "6c7e26dca73677d970d13828c933e761e5a5bd18", "commit_date": "Sun Dec 16 15:05:54 2018 +0900", "commit_message": "Prevent harmful links", "files_name": ["src/mistune/renderers.py"]}, {"commit_id": "52188bea948bc9ab17939d8db5a7af06673964bf", "commit_date": "Sun Dec 16 15:26:24 2018 +0900", "commit_message": "Prepare to parse list", "files_name": ["src/mistune/blocks.py"]}, {"commit_id": "bb24ad8103a71d908c1b8a73266a532ca1de96db", "commit_date": "Sun Dec 16 15:44:47 2018 +0900", "commit_message": "process input text, ensure there is newline at eof", "files_name": ["src/mistune/blocks.py", "src/mistune/markdown.py", "src/mistune/plugins/directive.py"]}, {"commit_id": "e130222c463ebaeb999b9f7f902834ed8263103e", "commit_date": "Sun Dec 16 17:48:37 2018 +0900", "commit_message": "Parsing list", "files_name": ["src/mistune/blocks.py", "src/tests/test_inlines.py"]}, {"commit_id": "d2c393d8813d25abd4fb8172a7a2afb700b21267", "commit_date": "Sun Dec 16 18:03:22 2018 +0900", "commit_message": "Add renderer for list", "files_name": ["src/mistune/blocks.py", "src/mistune/renderers.py"]}, {"commit_id": "ccb83493b72e1353727edefa0a2ee509d1c1e334", "commit_date": "Sun Dec 16 18:24:28 2018 +0900", "commit_message": "Deal with tabs", "files_name": ["src/mistune/blocks.py"]}, {"commit_id": "940cb6111cd8f1b56f9246872777433e5539afba", "commit_date": "Sun Dec 16 19:11:08 2018 +0900", "commit_message": "footenotes works", "files_name": ["src/mistune/blocks.py", "src/mistune/markdown.py", "src/mistune/renderers.py"]}, {"commit_id": "67b1b985525fbc4fa66505ceffe7bb5675791c85", "commit_date": "Sun Dec 16 23:13:53 2018 +0900", "commit_message": "Fix some bugs", "files_name": ["src/mistune/__init__.py", "src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/renderers.py"]}, {"commit_id": "aecbddc160eebd9c3d41b74c228d49d7df59ed9d", "commit_date": "Sun Dec 16 23:42:43 2018 +0900", "commit_message": "Fix some errors", "files_name": ["src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/scanner.py"]}, {"commit_id": "b2ad0f89ff378c1f03efe1c89cb2ac865b8da045", "commit_date": "Mon Dec 17 20:05:40 2018 +0900", "commit_message": "Fix for paragraph and indent code", "files_name": ["src/mistune/__init__.py", "src/mistune/blocks.py", "src/mistune/inlines.py", "src/mistune/renderers.py", "src/mistune/scanner.py"]}, {"commit_id": "53b59de62bcb54dc45ec0e68e43bbcf5a5c6315d", "commit_date": "Mon Dec 17 21:00:25 2018 +0900", "commit_message": "Fix links and block code.", "files_name": ["src/mistune/blocks.py", "src/mistune/inlines.py"]}], "parents": [{"commit_id_before": "7f7f106a717e6cf58012304e56b41d6fb2b98e5f", "url_before": "https://api.github.com/repos/lepture/mistune/commits/7f7f106a717e6cf58012304e56b41d6fb2b98e5f", "html_url_before": "https://github.com/lepture/mistune/commit/7f7f106a717e6cf58012304e56b41d6fb2b98e5f"}], "details": [{"raw_url": "https://github.com/lepture/mistune/raw/5f06d724bc05580e7f203db2d4a4905fc1127f98/mistune.py", "code": "# coding: utf-8\n\"\"\"\n    mistune\n    ~~~~~~~\n\n    The fastest markdown parser in pure Python with renderer feature.\n\n    :copyright: (c) 2014 - 2017 by Hsiaoming Yang.\n\"\"\"\n\nimport re\nimport inspect\n\n__version__ = '0.8.1'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n\n\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\=(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\n\n\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\n\n\ndef _keyify(key):\n    key = escape(key.lower(), quote=True)\n    return _key_pattern.sub(' ', key)\n\n\ndef escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:\n        text = text.replace('&', '&amp;')\n    text = text.replace('<', '&lt;')\n    text = text.replace('>', '&gt;')\n    if quote:\n        text = text.replace('\"', '&quot;')\n        text = text.replace(\"'\", '&#39;')\n    return text\n\n\ndef escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\n\n\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\n\n\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:\n        r'(?: {1,}[^\\n]*(?:\\n+|$))*'\n        r')'\n    )\n\n    newline = re.compile(r'^\\n+')\n    block_code = re.compile(r'^( {4}[^\\n]+\\n*)+')\n    fences = re.compile(\n        r'^ *(`{3,}|~{3,}) *(\\S+)? *\\n'  # ```lang\n        r'([\\s\\S]+?)\\s*'\n        r'\\1 *(?:\\n+|$)'  # ```\n    )\n    hrule = re.compile(r'^ {0,3}[-*_](?: *[-*_]){2,} *(?:\\n+|$)')\n    heading = re.compile(r'^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)')\n    lheading = re.compile(r'^([^\\n]+)\\n *(=|-)+ *(?:\\n+|$)')\n    block_quote = re.compile(r'^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+')\n    list_block = re.compile(\n        r'^( *)([*+-]|\\d+\\.) [\\s\\S]+?'\n        r'(?:'\n        r'\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))'  # hrule\n        r'|\\n+(?=%s)'  # def links\n        r'|\\n+(?=%s)'  # def footnotes\n        r'|\\n{2,}'\n        r'(?! )'\n        r'(?!\\1(?:[*+-]|\\d+\\.) )\\n*'\n        r'|'\n        r'\\s*$)' % (\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n        )\n    )\n    list_item = re.compile(\n        r'^(( *)(?:[*+-]|\\d+\\.) [^\\n]*'\n        r'(?:\\n(?!\\2(?:[*+-]|\\d+\\.) )[^\\n]*)*)',\n        flags=re.M\n    )\n    list_bullet = re.compile(r'^ *(?:[*+-]|\\d+\\.) +')\n    paragraph = re.compile(\n        r'^((?:[^\\n]+\\n?(?!'\n        r'%s|%s|%s|%s|%s|%s|%s|%s|%s'\n        r'))+)\\n*' % (\n            _pure_pattern(fences).replace(r'\\1', r'\\2'),\n            _pure_pattern(list_block).replace(r'\\1', r'\\3'),\n            _pure_pattern(hrule),\n            _pure_pattern(heading),\n            _pure_pattern(lheading),\n            _pure_pattern(block_quote),\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n            '<' + _block_tag,\n        )\n    )\n    block_html = re.compile(\n        r'^ *(?:%s|%s|%s) *(?:\\n{2,}|\\s*$)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(%s)((?:%s)*?)>([\\s\\S]*?)<\\/\\1>' % (_block_tag, _valid_attr),\n            r'<%s(?:%s)*?\\s*\\/?>' % (_block_tag, _valid_attr),\n        )\n    )\n    table = re.compile(\n        r'^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*'\n    )\n    nptable = re.compile(\n        r'^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*'\n    )\n    text = re.compile(r'^[^\\n]+')\n\n\nclass BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n\n    list_rules = (\n        'newline', 'block_code', 'fences', 'lheading', 'hrule',\n        'block_quote', 'list_block', 'block_html', 'text',\n    )\n\n    footnote_rules = (\n        'newline', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'hrule', 'block_quote',\n        'list_block', 'block_html', 'table', 'paragraph', 'text'\n    )\n\n    def __init__(self, rules=None, **kwargs):\n        self.tokens = []\n        self.def_links = {}\n        self.def_footnotes = {}\n\n        if not rules:\n            rules = self.grammar_class()\n\n        self.rules = rules\n\n    def __call__(self, text, rules=None):\n        return self.parse(text, rules)\n\n    def parse(self, text, rules=None):\n        text = text.rstrip('\\n')\n\n        if not rules:\n            rules = self.default_rules\n\n        def manipulate(text):\n            for key in rules:\n                rule = getattr(self.rules, key)\n                m = rule.match(text)\n                if not m:\n                    continue\n                getattr(self, 'parse_%s' % key)(m)\n                return m\n            return False  # pragma: no cover\n\n        while text:\n            m = manipulate(text)\n            if m is not False:\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n        return self.tokens\n\n    def parse_newline(self, m):\n        length = len(m.group(0))\n        if length > 1:\n            self.tokens.append({'type': 'newline'})\n\n    def parse_block_code(self, m):\n        # clean leading whitespace\n        code = _block_code_leading_pattern.sub('', m.group(0))\n        self.tokens.append({\n            'type': 'code',\n            'lang': None,\n            'text': code,\n        })\n\n    def parse_fences(self, m):\n        self.tokens.append({\n            'type': 'code',\n            'lang': m.group(2),\n            'text': m.group(3),\n        })\n\n    def parse_heading(self, m):\n        self.tokens.append({\n            'type': 'heading',\n            'level': len(m.group(1)),\n            'text': m.group(2),\n        })\n\n    def parse_lheading(self, m):\n        \"\"\"Parse setext heading.\"\"\"\n        self.tokens.append({\n            'type': 'heading',\n            'level': 1 if m.group(2) == '=' else 2,\n            'text': m.group(1),\n        })\n\n    def parse_hrule(self, m):\n        self.tokens.append({'type': 'hrule'})\n\n    def parse_list_block(self, m):\n        bull = m.group(2)\n        self.tokens.append({\n            'type': 'list_start',\n            'ordered': '.' in bull,\n        })\n        cap = m.group(0)\n        self._process_list_item(cap, bull)\n        self.tokens.append({'type': 'list_end'})\n\n    def _process_list_item(self, cap, bull):\n        cap = self.rules.list_item.findall(cap)\n\n        _next = False\n        length = len(cap)\n\n        for i in range(length):\n            item = cap[i][0]\n\n            # remove the bullet\n            space = len(item)\n            item = self.rules.list_bullet.sub('', item)\n\n            # outdent\n            if '\\n ' in item:\n                space = space - len(item)\n                pattern = re.compile(r'^ {1,%d}' % space, flags=re.M)\n                item = pattern.sub('', item)\n\n            # determine whether item is loose or not\n            loose = _next\n            if not loose and re.search(r'\\n\\n(?!\\s*$)', item):\n                loose = True\n\n            rest = len(item)\n            if i != length - 1 and rest:\n                _next = item[rest-1] == '\\n'\n                if not loose:\n                    loose = _next\n\n            if loose:\n                t = 'loose_item_start'\n            else:\n                t = 'list_item_start'\n\n            self.tokens.append({'type': t})\n            # recurse\n            self.parse(item, self.list_rules)\n            self.tokens.append({'type': 'list_item_end'})\n\n    def parse_block_quote(self, m):\n        self.tokens.append({'type': 'block_quote_start'})\n        # clean leading >\n        cap = _block_quote_leading_pattern.sub('', m.group(0))\n        self.parse(cap)\n        self.tokens.append({'type': 'block_quote_end'})\n\n    def parse_def_links(self, m):\n        key = _keyify(m.group(1))\n        self.def_links[key] = {\n            'link': m.group(2),\n            'title': m.group(3),\n        }\n\n    def parse_def_footnotes(self, m):\n        key = _keyify(m.group(1))\n        if key in self.def_footnotes:\n            # footnote is already defined\n            return\n\n        self.def_footnotes[key] = 0\n\n        self.tokens.append({\n            'type': 'footnote_start',\n            'key': key,\n        })\n\n        text = m.group(2)\n\n        if '\\n' in text:\n            lines = text.split('\\n')\n            whitespace = None\n            for line in lines[1:]:\n                space = len(line) - len(line.lstrip())\n                if space and (not whitespace or space < whitespace):\n                    whitespace = space\n            newlines = [lines[0]]\n            for line in lines[1:]:\n                newlines.append(line[whitespace:])\n            text = '\\n'.join(newlines)\n\n        self.parse(text, self.footnote_rules)\n\n        self.tokens.append({\n            'type': 'footnote_end',\n            'key': key,\n        })\n\n    def parse_table(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'(?: *\\| *)?\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            v = re.sub(r'^ *\\| *| *\\| *$', '', v)\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def parse_nptable(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def _process_table(self, m):\n        header = re.sub(r'^ *| *\\| *$', '', m.group(1))\n        header = re.split(r' *\\| *', header)\n        align = re.sub(r' *|\\| *$', '', m.group(2))\n        align = re.split(r' *\\| *', align)\n\n        for i, v in enumerate(align):\n            if re.search(r'^ *-+: *$', v):\n                align[i] = 'right'\n            elif re.search(r'^ *:-+: *$', v):\n                align[i] = 'center'\n            elif re.search(r'^ *:-+ *$', v):\n                align[i] = 'left'\n            else:\n                align[i] = None\n\n        item = {\n            'type': 'table',\n            'header': header,\n            'align': align,\n        }\n        return item\n\n    def parse_block_html(self, m):\n        tag = m.group(1)\n        if not tag:\n            text = m.group(0)\n            self.tokens.append({\n                'type': 'close_html',\n                'text': text\n            })\n        else:\n            attr = m.group(2)\n            text = m.group(3)\n            self.tokens.append({\n                'type': 'open_html',\n                'tag': tag,\n                'extra': attr,\n                'text': text\n            })\n\n    def parse_paragraph(self, m):\n        text = m.group(1).rstrip('\\n')\n        self.tokens.append({'type': 'paragraph', 'text': text})\n\n    def parse_text(self, m):\n        text = m.group(0)\n        self.tokens.append({'type': 'text', 'text': text})\n\n\nclass InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (\n                _valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )\n    )\n    autolink = re.compile(r'^<([^ >]+(@|:)[^ >]+)>')\n    link = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\('\n        r'''\\s*(<)?([\\s\\S]*?)(?(2)>)(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*'''\n        r'\\)'\n    )\n    reflink = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\s*\\[([^^\\]]*)\\]'\n    )\n    nolink = re.compile(r'^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]')\n    url = re.compile(r'''^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])''')\n    double_emphasis = re.compile(\n        r'^_{2}([\\s\\S]+?)_{2}(?!_)'  # __word__\n        r'|'\n        r'^\\*{2}([\\s\\S]+?)\\*{2}(?!\\*)'  # **word**\n    )\n    emphasis = re.compile(\n        r'^\\b_((?:__|[^_])+?)_\\b'  # _word_\n        r'|'\n        r'^\\*((?:\\*\\*|[^\\*])+?)\\*(?!\\*)'  # *word*\n    )\n    code = re.compile(r'^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)')  # `code`\n    linebreak = re.compile(r'^ {2,}\\n(?!\\s*$)')\n    strikethrough = re.compile(r'^~~(?=\\S)([\\s\\S]*?\\S)~~')  # ~~word~~\n    footnote = re.compile(r'^\\[\\^([^\\]]+)\\]')\n    text = re.compile(r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| {2,}\\n|$)')\n\n    def hard_wrap(self):\n        \"\"\"Grammar for hard wrap linebreak. You don't need to add two\n        spaces at the end of a line.\n        \"\"\"\n        self.linebreak = re.compile(r'^ *\\n(?!\\s*$)')\n        self.text = re.compile(\n            r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| *\\n|$)'\n        )\n\n\nclass InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [\n        'escape', 'autolink', 'url', 'link', 'reflink',\n        'nolink', 'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n\n    def __init__(self, renderer, rules=None, **kwargs):\n        self.renderer = renderer\n        self.links = {}\n        self.footnotes = {}\n        self.footnote_index = 0\n\n        if not rules:\n            rules = self.grammar_class()\n\n        kwargs.update(self.renderer.options)\n        if kwargs.get('hard_wrap'):\n            rules.hard_wrap()\n\n        self.rules = rules\n\n        self._in_link = False\n        self._in_footnote = False\n        self._parse_inline_html = kwargs.get('parse_inline_html')\n\n    def __call__(self, text, rules=None):\n        return self.output(text, rules)\n\n    def setup(self, links, footnotes):\n        self.footnote_index = 0\n        self.links = links or {}\n        self.footnotes = footnotes or {}\n\n    def output(self, text, rules=None):\n        text = text.rstrip('\\n')\n        if not rules:\n            rules = list(self.default_rules)\n\n        if self._in_footnote and 'footnote' in rules:\n            rules.remove('footnote')\n\n        output = self.renderer.placeholder()\n\n        def manipulate(text):\n            for key in rules:\n                pattern = getattr(self.rules, key)\n                m = pattern.match(text)\n                if not m:\n                    continue\n                self.line_match = m\n                out = getattr(self, 'output_%s' % key)(m)\n                if out is not None:\n                    return m, out\n            return False  # pragma: no cover\n\n        while text:\n            ret = manipulate(text)\n            if ret is not False:\n                m, out = ret\n                output += out\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n\n        return output\n\n    def output_escape(self, m):\n        text = m.group(1)\n        return self.renderer.escape(text)\n\n    def output_autolink(self, m):\n        link = m.group(1)\n        if m.group(2) == '@':\n            is_email = True\n        else:\n            is_email = False\n        return self.renderer.autolink(link, is_email)\n\n    def output_url(self, m):\n        link = m.group(1)\n        if self._in_link:\n            return self.renderer.text(link)\n        return self.renderer.autolink(link, False)\n\n    def output_inline_html(self, m):\n        tag = m.group(1)\n        if self._parse_inline_html and tag in _inline_tags:\n            text = m.group(3)\n            if tag == 'a':\n                self._in_link = True\n                text = self.output(text, rules=self.inline_html_rules)\n                self._in_link = False\n            else:\n                text = self.output(text, rules=self.inline_html_rules)\n            extra = m.group(2) or ''\n            html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        else:\n            html = m.group(0)\n        return self.renderer.inline_html(html)\n\n    def output_footnote(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.footnotes:\n            return None\n        if self.footnotes[key]:\n            return None\n        self.footnote_index += 1\n        self.footnotes[key] = self.footnote_index\n        return self.renderer.footnote_ref(key, self.footnote_index)\n\n    def output_link(self, m):\n        return self._process_link(m, m.group(3), m.group(4))\n\n    def output_reflink(self, m):\n        key = _keyify(m.group(2) or m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def output_nolink(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def _process_link(self, m, link, title=None):\n        line = m.group(0)\n        text = m.group(1)\n        if line[0] == '!':\n            return self.renderer.image(link, title, text)\n\n        self._in_link = True\n        text = self.output(text)\n        self._in_link = False\n        return self.renderer.link(link, title, text)\n\n    def output_double_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.double_emphasis(text)\n\n    def output_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.emphasis(text)\n\n    def output_code(self, m):\n        text = m.group(2)\n        return self.renderer.codespan(text)\n\n    def output_linebreak(self, m):\n        return self.renderer.linebreak()\n\n    def output_strikethrough(self, m):\n        text = self.output(m.group(1))\n        return self.renderer.strikethrough(text)\n\n    def output_text(self, m):\n        text = m.group(0)\n        return self.renderer.text(text)\n\n\nclass Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.options = kwargs\n\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.\n\n        Can be overridden by Renderer subclasses to be types like an empty\n        list, allowing the renderer to create a tree-like structure to\n        represent the document (which can then be reprocessed later into a\n        separate format like docx or pdf).\n        \"\"\"\n        return ''\n\n    def block_code(self, code, lang=None):\n        \"\"\"Rendering block level code. ``pre > code``.\n\n        :param code: text content of the code block.\n        :param lang: language of the given code.\n        \"\"\"\n        code = code.rstrip('\\n')\n        if not lang:\n            code = escape(code, smart_amp=False)\n            return '<pre><code>%s\\n</code></pre>\\n' % code\n        code = escape(code, quote=True, smart_amp=False)\n        return '<pre><code class=\"lang-%s\">%s\\n</code></pre>\\n' % (lang, code)\n\n    def block_quote(self, text):\n        \"\"\"Rendering <blockquote> with the given text.\n\n        :param text: text content of the blockquote.\n        \"\"\"\n        return '<blockquote>%s\\n</blockquote>\\n' % text.rstrip('\\n')\n\n    def block_html(self, html):\n        \"\"\"Rendering block level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('skip_style') and \\\n           html.lower().startswith('<style'):\n            return ''\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def header(self, text, level, raw=None):\n        \"\"\"Rendering header/heading tags like ``<h1>`` ``<h2>``.\n\n        :param text: rendered text content for the header.\n        :param level: a number for the header level, for example: 1.\n        :param raw: raw text content of the header.\n        \"\"\"\n        return '<h%d>%s</h%d>\\n' % (level, text, level)\n\n    def hrule(self):\n        \"\"\"Rendering method for ``<hr>`` tag.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<hr />\\n'\n        return '<hr>\\n'\n\n    def list(self, body, ordered=True):\n        \"\"\"Rendering list tags like ``<ul>`` and ``<ol>``.\n\n        :param body: body contents of the list.\n        :param ordered: whether this list is ordered or not.\n        \"\"\"\n        tag = 'ul'\n        if ordered:\n            tag = 'ol'\n        return '<%s>\\n%s</%s>\\n' % (tag, body, tag)\n\n    def list_item(self, text):\n        \"\"\"Rendering list item snippet. Like ``<li>``.\"\"\"\n        return '<li>%s</li>\\n' % text\n\n    def paragraph(self, text):\n        \"\"\"Rendering paragraph tags. Like ``<p>``.\"\"\"\n        return '<p>%s</p>\\n' % text.strip(' ')\n\n    def table(self, header, body):\n        \"\"\"Rendering table element. Wrap header and body in it.\n\n        :param header: header part of the table.\n        :param body: body part of the table.\n        \"\"\"\n        return (\n            '<table>\\n<thead>%s</thead>\\n'\n            '<tbody>\\n%s</tbody>\\n</table>\\n'\n        ) % (header, body)\n\n    def table_row(self, content):\n        \"\"\"Rendering a table row. Like ``<tr>``.\n\n        :param content: content of current table row.\n        \"\"\"\n        return '<tr>\\n%s</tr>\\n' % content\n\n    def table_cell(self, content, **flags):\n        \"\"\"Rendering a table cell. Like ``<th>`` ``<td>``.\n\n        :param content: content of current table cell.\n        :param header: whether this is header or not.\n        :param align: align of current table cell.\n        \"\"\"\n        if flags['header']:\n            tag = 'th'\n        else:\n            tag = 'td'\n        align = flags['align']\n        if not align:\n            return '<%s>%s</%s>\\n' % (tag, content, tag)\n        return '<%s style=\"text-align:%s\">%s</%s>\\n' % (\n            tag, align, content, tag\n        )\n\n    def double_emphasis(self, text):\n        \"\"\"Rendering **strong** text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<strong>%s</strong>' % text\n\n    def emphasis(self, text):\n        \"\"\"Rendering *emphasis* text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<em>%s</em>' % text\n\n    def codespan(self, text):\n        \"\"\"Rendering inline `code` text.\n\n        :param text: text content for inline code.\n        \"\"\"\n        text = escape(text.rstrip(), smart_amp=False)\n        return '<code>%s</code>' % text\n\n    def linebreak(self):\n        \"\"\"Rendering line break like ``<br>``.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<br />\\n'\n        return '<br>\\n'\n\n    def strikethrough(self, text):\n        \"\"\"Rendering ~~strikethrough~~ text.\n\n        :param text: text content for strikethrough.\n        \"\"\"\n        return '<del>%s</del>' % text\n\n    def text(self, text):\n        \"\"\"Rendering unformatted text.\n\n        :param text: text content.\n        \"\"\"\n        if self.options.get('parse_block_html'):\n            return text\n        return escape(text)\n\n    def escape(self, text):\n        \"\"\"Rendering escape sequence.\n\n        :param text: text content.\n        \"\"\"\n        return escape(text)\n\n    def autolink(self, link, is_email=False):\n        \"\"\"Rendering a given link or email address.\n\n        :param link: link content or email address.\n        :param is_email: whether this is an email or not.\n        \"\"\"\n        text = link = escape_link(link)\n        if is_email:\n            link = 'mailto:%s' % link\n        return '<a href=\"%s\">%s</a>' % (link, text)\n\n    def link(self, link, title, text):\n        \"\"\"Rendering a given link with content and title.\n\n        :param link: href link for ``<a>`` tag.\n        :param title: title content for `title` attribute.\n        :param text: text content for description.\n        \"\"\"\n        link = escape_link(link)\n        if not title:\n            return '<a href=\"%s\">%s</a>' % (link, text)\n        title = escape(title, quote=True)\n        return '<a href=\"%s\" title=\"%s\">%s</a>' % (link, title, text)\n\n    def image(self, src, title, text):\n        \"\"\"Rendering a image with title and text.\n\n        :param src: source link of the image.\n        :param title: title text of the image.\n        :param text: alt text of the image.\n        \"\"\"\n        src = escape_link(src)\n        text = escape(text, quote=True)\n        if title:\n            title = escape(title, quote=True)\n            html = '<img src=\"%s\" alt=\"%s\" title=\"%s\"' % (src, text, title)\n        else:\n            html = '<img src=\"%s\" alt=\"%s\"' % (src, text)\n        if self.options.get('use_xhtml'):\n            return '%s />' % html\n        return '%s>' % html\n\n    def inline_html(self, html):\n        \"\"\"Rendering span level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def newline(self):\n        \"\"\"Rendering newline element.\"\"\"\n        return ''\n\n    def footnote_ref(self, key, index):\n        \"\"\"Rendering the ref anchor of a footnote.\n\n        :param key: identity key for the footnote.\n        :param index: the index count of current footnote.\n        \"\"\"\n        html = (\n            '<sup class=\"footnote-ref\" id=\"fnref-%s\">'\n            '<a href=\"#fn-%s\">%d</a></sup>'\n        ) % (escape(key), escape(key), index)\n        return html\n\n    def footnote_item(self, key, text):\n        \"\"\"Rendering a footnote item.\n\n        :param key: identity key for the footnote.\n        :param text: text content of the footnote.\n        \"\"\"\n        back = (\n            '<a href=\"#fnref-%s\" class=\"footnote\">&#8617;</a>'\n        ) % escape(key)\n        text = text.rstrip()\n        if text.endswith('</p>'):\n            text = re.sub(r'<\\/p>$', r'%s</p>' % back, text)\n        else:\n            text = '%s<p>%s</p>' % (text, back)\n        html = '<li id=\"fn-%s\">%s</li>\\n' % (escape(key), text)\n        return html\n\n    def footnotes(self, text):\n        \"\"\"Wrapper for all footnotes.\n\n        :param text: contents of all footnotes.\n        \"\"\"\n        html = '<div class=\"footnotes\">\\n%s<ol>%s</ol>\\n</div>\\n'\n        return html % (self.hrule(), text)\n\n\nclass Markdown(object):\n    \"\"\"The Markdown parser.\n\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:\n            kwargs.update(renderer.options)\n\n        self.renderer = renderer\n\n        if inline and inspect.isclass(inline):\n            inline = inline(renderer, **kwargs)\n        if block and inspect.isclass(block):\n            block = block(**kwargs)\n\n        if inline:\n            self.inline = inline\n        else:\n            self.inline = InlineLexer(renderer, **kwargs)\n\n        self.block = block or BlockLexer(BlockGrammar())\n        self.footnotes = []\n        self.tokens = []\n\n        # detect if it should parse text in block html\n        self._parse_block_html = kwargs.get('parse_block_html')\n\n    def __call__(self, text):\n        return self.parse(text)\n\n    def render(self, text):\n        \"\"\"Render the Markdown text.\n\n        :param text: markdown formatted text content.\n        \"\"\"\n        return self.parse(text)\n\n    def parse(self, text):\n        out = self.output(preprocessing(text))\n\n        keys = self.block.def_footnotes\n\n        # reset block\n        self.block.def_links = {}\n        self.block.def_footnotes = {}\n\n        # reset inline\n        self.inline.links = {}\n        self.inline.footnotes = {}\n\n        if not self.footnotes:\n            return out\n\n        footnotes = filter(lambda o: keys.get(o['key']), self.footnotes)\n        self.footnotes = sorted(\n            footnotes, key=lambda o: keys.get(o['key']), reverse=True\n        )\n\n        body = self.renderer.placeholder()\n        while self.footnotes:\n            note = self.footnotes.pop()\n            body += self.renderer.footnote_item(\n                note['key'], note['text']\n            )\n\n        out += self.renderer.footnotes(body)\n        return out\n\n    def pop(self):\n        if not self.tokens:\n            return None\n        self.token = self.tokens.pop()\n        return self.token\n\n    def peek(self):\n        if self.tokens:\n            return self.tokens[-1]\n        return None  # pragma: no cover\n\n    def output(self, text, rules=None):\n        self.tokens = self.block(text, rules)\n        self.tokens.reverse()\n\n        self.inline.setup(self.block.def_links, self.block.def_footnotes)\n\n        out = self.renderer.placeholder()\n        while self.pop():\n            out += self.tok()\n        return out\n\n    def tok(self):\n        t = self.token['type']\n\n        # sepcial cases\n        if t.endswith('_start'):\n            t = t[:-6]\n\n        return getattr(self, 'output_%s' % t)()\n\n    def tok_text(self):\n        text = self.token['text']\n        while self.peek()['type'] == 'text':\n            text += '\\n' + self.pop()['text']\n        return self.inline(text)\n\n    def output_newline(self):\n        return self.renderer.newline()\n\n    def output_hrule(self):\n        return self.renderer.hrule()\n\n    def output_heading(self):\n        return self.renderer.header(\n            self.inline(self.token['text']),\n            self.token['level'],\n            self.token['text'],\n        )\n\n    def output_code(self):\n        return self.renderer.block_code(\n            self.token['text'], self.token['lang']\n        )\n\n    def output_table(self):\n        aligns = self.token['align']\n        aligns_length = len(aligns)\n        cell = self.renderer.placeholder()\n\n        # header part\n        header = self.renderer.placeholder()\n        for i, value in enumerate(self.token['header']):\n            align = aligns[i] if i < aligns_length else None\n            flags = {'header': True, 'align': align}\n            cell += self.renderer.table_cell(self.inline(value), **flags)\n\n        header += self.renderer.table_row(cell)\n\n        # body part\n        body = self.renderer.placeholder()\n        for i, row in enumerate(self.token['cells']):\n            cell = self.renderer.placeholder()\n            for j, value in enumerate(row):\n                align = aligns[j] if j < aligns_length else None\n                flags = {'header': False, 'align': align}\n                cell += self.renderer.table_cell(self.inline(value), **flags)\n            body += self.renderer.table_row(cell)\n\n        return self.renderer.table(header, body)\n\n    def output_block_quote(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'block_quote_end':\n            body += self.tok()\n        return self.renderer.block_quote(body)\n\n    def output_list(self):\n        ordered = self.token['ordered']\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_end':\n            body += self.tok()\n        return self.renderer.list(body, ordered)\n\n    def output_list_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            if self.token['type'] == 'text':\n                body += self.tok_text()\n            else:\n                body += self.tok()\n\n        return self.renderer.list_item(body)\n\n    def output_loose_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            body += self.tok()\n        return self.renderer.list_item(body)\n\n    def output_footnote(self):\n        self.inline._in_footnote = True\n        body = self.renderer.placeholder()\n        key = self.token['key']\n        while self.pop()['type'] != 'footnote_end':\n            body += self.tok()\n        self.footnotes.append({'key': key, 'text': body})\n        self.inline._in_footnote = False\n        return self.renderer.placeholder()\n\n    def output_close_html(self):\n        text = self.token['text']\n        return self.renderer.block_html(text)\n\n    def output_open_html(self):\n        text = self.token['text']\n        tag = self.token['tag']\n        if self._parse_block_html and tag not in _pre_tags:\n            text = self.inline(text, rules=self.inline.inline_html_rules)\n        extra = self.token.get('extra') or ''\n        html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        return self.renderer.block_html(html)\n\n    def output_paragraph(self):\n        return self.renderer.paragraph(self.inline(self.token['text']))\n\n    def output_text(self):\n        return self.renderer.paragraph(self.tok_text())\n\n\ndef markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)\n", "code_before": "# coding: utf-8\n\"\"\"\n    mistune\n    ~~~~~~~\n\n    The fastest markdown parser in pure Python with renderer feature.\n\n    :copyright: (c) 2014 - 2017 by Hsiaoming Yang.\n\"\"\"\n\nimport re\nimport inspect\n\n__version__ = '0.8'\n__author__ = 'Hsiaoming Yang <me@lepture.com>'\n__all__ = [\n    'BlockGrammar', 'BlockLexer',\n    'InlineGrammar', 'InlineLexer',\n    'Renderer', 'Markdown',\n    'markdown', 'escape',\n]\n\n\n_key_pattern = re.compile(r'\\s+')\n_nonalpha_pattern = re.compile(r'\\W')\n_escape_pattern = re.compile(r'&(?!#?\\w+;)')\n_newline_pattern = re.compile(r'\\r\\n|\\r')\n_block_quote_leading_pattern = re.compile(r'^ *> ?', flags=re.M)\n_block_code_leading_pattern = re.compile(r'^ {4}', re.M)\n_inline_tags = [\n    'a', 'em', 'strong', 'small', 's', 'cite', 'q', 'dfn', 'abbr', 'data',\n    'time', 'code', 'var', 'samp', 'kbd', 'sub', 'sup', 'i', 'b', 'u', 'mark',\n    'ruby', 'rt', 'rp', 'bdi', 'bdo', 'span', 'br', 'wbr', 'ins', 'del',\n    'img', 'font',\n]\n_pre_tags = ['pre', 'script', 'style']\n_valid_end = r'(?!:/|[^\\w\\s@]*@)\\b'\n_valid_attr = r'''\\s*[a-zA-Z\\-](?:\\=(?:\"[^\"]*\"|'[^']*'|[^\\s'\">]+))?'''\n_block_tag = r'(?!(?:%s)\\b)\\w+%s' % ('|'.join(_inline_tags), _valid_end)\n_scheme_blacklist = ('javascript:', 'vbscript:')\n\n\ndef _pure_pattern(regex):\n    pattern = regex.pattern\n    if pattern.startswith('^'):\n        pattern = pattern[1:]\n    return pattern\n\n\ndef _keyify(key):\n    return _key_pattern.sub(' ', key.lower())\n\n\ndef escape(text, quote=False, smart_amp=True):\n    \"\"\"Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n\n    The original cgi.escape will always escape \"&\", but you can control\n    this one for a smart escape amp.\n\n    :param quote: if set to True, \" and ' will be escaped.\n    :param smart_amp: if set to False, & will always be escaped.\n    \"\"\"\n    if smart_amp:\n        text = _escape_pattern.sub('&amp;', text)\n    else:\n        text = text.replace('&', '&amp;')\n    text = text.replace('<', '&lt;')\n    text = text.replace('>', '&gt;')\n    if quote:\n        text = text.replace('\"', '&quot;')\n        text = text.replace(\"'\", '&#39;')\n    return text\n\n\ndef escape_link(url):\n    \"\"\"Remove dangerous URL schemes like javascript: and escape afterwards.\"\"\"\n    lower_url = url.lower().strip('\\x00\\x1a \\n\\r\\t')\n\n    for scheme in _scheme_blacklist:\n        if re.sub(r'[^A-Za-z0-9\\/:]+', '', lower_url).startswith(scheme):\n            return ''\n    return escape(url, quote=True, smart_amp=False)\n\n\ndef preprocessing(text, tab=4):\n    text = _newline_pattern.sub('\\n', text)\n    text = text.expandtabs(tab)\n    text = text.replace('\\u2424', '\\n')\n    pattern = re.compile(r'^ +$', re.M)\n    return pattern.sub('', text)\n\n\nclass BlockGrammar(object):\n    \"\"\"Grammars for block level tokens.\"\"\"\n\n    def_links = re.compile(\n        r'^ *\\[([^^\\]]+)\\]: *'  # [key]:\n        r'<?([^\\s>]+)>?'  # <link> or link\n        r'(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)'\n    )\n    def_footnotes = re.compile(\n        r'^\\[\\^([^\\]]+)\\]: *('\n        r'[^\\n]*(?:\\n+|$)'  # [^key]:\n        r'(?: {1,}[^\\n]*(?:\\n+|$))*'\n        r')'\n    )\n\n    newline = re.compile(r'^\\n+')\n    block_code = re.compile(r'^( {4}[^\\n]+\\n*)+')\n    fences = re.compile(\n        r'^ *(`{3,}|~{3,}) *(\\S+)? *\\n'  # ```lang\n        r'([\\s\\S]+?)\\s*'\n        r'\\1 *(?:\\n+|$)'  # ```\n    )\n    hrule = re.compile(r'^ {0,3}[-*_](?: *[-*_]){2,} *(?:\\n+|$)')\n    heading = re.compile(r'^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)')\n    lheading = re.compile(r'^([^\\n]+)\\n *(=|-)+ *(?:\\n+|$)')\n    block_quote = re.compile(r'^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+')\n    list_block = re.compile(\n        r'^( *)([*+-]|\\d+\\.) [\\s\\S]+?'\n        r'(?:'\n        r'\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))'  # hrule\n        r'|\\n+(?=%s)'  # def links\n        r'|\\n+(?=%s)'  # def footnotes\n        r'|\\n{2,}'\n        r'(?! )'\n        r'(?!\\1(?:[*+-]|\\d+\\.) )\\n*'\n        r'|'\n        r'\\s*$)' % (\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n        )\n    )\n    list_item = re.compile(\n        r'^(( *)(?:[*+-]|\\d+\\.) [^\\n]*'\n        r'(?:\\n(?!\\2(?:[*+-]|\\d+\\.) )[^\\n]*)*)',\n        flags=re.M\n    )\n    list_bullet = re.compile(r'^ *(?:[*+-]|\\d+\\.) +')\n    paragraph = re.compile(\n        r'^((?:[^\\n]+\\n?(?!'\n        r'%s|%s|%s|%s|%s|%s|%s|%s|%s'\n        r'))+)\\n*' % (\n            _pure_pattern(fences).replace(r'\\1', r'\\2'),\n            _pure_pattern(list_block).replace(r'\\1', r'\\3'),\n            _pure_pattern(hrule),\n            _pure_pattern(heading),\n            _pure_pattern(lheading),\n            _pure_pattern(block_quote),\n            _pure_pattern(def_links),\n            _pure_pattern(def_footnotes),\n            '<' + _block_tag,\n        )\n    )\n    block_html = re.compile(\n        r'^ *(?:%s|%s|%s) *(?:\\n{2,}|\\s*$)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(%s)((?:%s)*?)>([\\s\\S]*?)<\\/\\1>' % (_block_tag, _valid_attr),\n            r'<%s(?:%s)*?\\s*\\/?>' % (_block_tag, _valid_attr),\n        )\n    )\n    table = re.compile(\n        r'^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*'\n    )\n    nptable = re.compile(\n        r'^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*'\n    )\n    text = re.compile(r'^[^\\n]+')\n\n\nclass BlockLexer(object):\n    \"\"\"Block level lexer for block grammars.\"\"\"\n    grammar_class = BlockGrammar\n\n    default_rules = [\n        'newline', 'hrule', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'block_quote',\n        'list_block', 'block_html', 'def_links',\n        'def_footnotes', 'table', 'paragraph', 'text'\n    ]\n\n    list_rules = (\n        'newline', 'block_code', 'fences', 'lheading', 'hrule',\n        'block_quote', 'list_block', 'block_html', 'text',\n    )\n\n    footnote_rules = (\n        'newline', 'block_code', 'fences', 'heading',\n        'nptable', 'lheading', 'hrule', 'block_quote',\n        'list_block', 'block_html', 'table', 'paragraph', 'text'\n    )\n\n    def __init__(self, rules=None, **kwargs):\n        self.tokens = []\n        self.def_links = {}\n        self.def_footnotes = {}\n\n        if not rules:\n            rules = self.grammar_class()\n\n        self.rules = rules\n\n    def __call__(self, text, rules=None):\n        return self.parse(text, rules)\n\n    def parse(self, text, rules=None):\n        text = text.rstrip('\\n')\n\n        if not rules:\n            rules = self.default_rules\n\n        def manipulate(text):\n            for key in rules:\n                rule = getattr(self.rules, key)\n                m = rule.match(text)\n                if not m:\n                    continue\n                getattr(self, 'parse_%s' % key)(m)\n                return m\n            return False  # pragma: no cover\n\n        while text:\n            m = manipulate(text)\n            if m is not False:\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n        return self.tokens\n\n    def parse_newline(self, m):\n        length = len(m.group(0))\n        if length > 1:\n            self.tokens.append({'type': 'newline'})\n\n    def parse_block_code(self, m):\n        # clean leading whitespace\n        code = _block_code_leading_pattern.sub('', m.group(0))\n        self.tokens.append({\n            'type': 'code',\n            'lang': None,\n            'text': code,\n        })\n\n    def parse_fences(self, m):\n        self.tokens.append({\n            'type': 'code',\n            'lang': m.group(2),\n            'text': m.group(3),\n        })\n\n    def parse_heading(self, m):\n        self.tokens.append({\n            'type': 'heading',\n            'level': len(m.group(1)),\n            'text': m.group(2),\n        })\n\n    def parse_lheading(self, m):\n        \"\"\"Parse setext heading.\"\"\"\n        self.tokens.append({\n            'type': 'heading',\n            'level': 1 if m.group(2) == '=' else 2,\n            'text': m.group(1),\n        })\n\n    def parse_hrule(self, m):\n        self.tokens.append({'type': 'hrule'})\n\n    def parse_list_block(self, m):\n        bull = m.group(2)\n        self.tokens.append({\n            'type': 'list_start',\n            'ordered': '.' in bull,\n        })\n        cap = m.group(0)\n        self._process_list_item(cap, bull)\n        self.tokens.append({'type': 'list_end'})\n\n    def _process_list_item(self, cap, bull):\n        cap = self.rules.list_item.findall(cap)\n\n        _next = False\n        length = len(cap)\n\n        for i in range(length):\n            item = cap[i][0]\n\n            # remove the bullet\n            space = len(item)\n            item = self.rules.list_bullet.sub('', item)\n\n            # outdent\n            if '\\n ' in item:\n                space = space - len(item)\n                pattern = re.compile(r'^ {1,%d}' % space, flags=re.M)\n                item = pattern.sub('', item)\n\n            # determine whether item is loose or not\n            loose = _next\n            if not loose and re.search(r'\\n\\n(?!\\s*$)', item):\n                loose = True\n\n            rest = len(item)\n            if i != length - 1 and rest:\n                _next = item[rest-1] == '\\n'\n                if not loose:\n                    loose = _next\n\n            if loose:\n                t = 'loose_item_start'\n            else:\n                t = 'list_item_start'\n\n            self.tokens.append({'type': t})\n            # recurse\n            self.parse(item, self.list_rules)\n            self.tokens.append({'type': 'list_item_end'})\n\n    def parse_block_quote(self, m):\n        self.tokens.append({'type': 'block_quote_start'})\n        # clean leading >\n        cap = _block_quote_leading_pattern.sub('', m.group(0))\n        self.parse(cap)\n        self.tokens.append({'type': 'block_quote_end'})\n\n    def parse_def_links(self, m):\n        key = _keyify(m.group(1))\n        self.def_links[key] = {\n            'link': m.group(2),\n            'title': m.group(3),\n        }\n\n    def parse_def_footnotes(self, m):\n        key = _keyify(m.group(1))\n        if key in self.def_footnotes:\n            # footnote is already defined\n            return\n\n        self.def_footnotes[key] = 0\n\n        self.tokens.append({\n            'type': 'footnote_start',\n            'key': key,\n        })\n\n        text = m.group(2)\n\n        if '\\n' in text:\n            lines = text.split('\\n')\n            whitespace = None\n            for line in lines[1:]:\n                space = len(line) - len(line.lstrip())\n                if space and (not whitespace or space < whitespace):\n                    whitespace = space\n            newlines = [lines[0]]\n            for line in lines[1:]:\n                newlines.append(line[whitespace:])\n            text = '\\n'.join(newlines)\n\n        self.parse(text, self.footnote_rules)\n\n        self.tokens.append({\n            'type': 'footnote_end',\n            'key': key,\n        })\n\n    def parse_table(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'(?: *\\| *)?\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            v = re.sub(r'^ *\\| *| *\\| *$', '', v)\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def parse_nptable(self, m):\n        item = self._process_table(m)\n\n        cells = re.sub(r'\\n$', '', m.group(3))\n        cells = cells.split('\\n')\n        for i, v in enumerate(cells):\n            cells[i] = re.split(r' *\\| *', v)\n\n        item['cells'] = cells\n        self.tokens.append(item)\n\n    def _process_table(self, m):\n        header = re.sub(r'^ *| *\\| *$', '', m.group(1))\n        header = re.split(r' *\\| *', header)\n        align = re.sub(r' *|\\| *$', '', m.group(2))\n        align = re.split(r' *\\| *', align)\n\n        for i, v in enumerate(align):\n            if re.search(r'^ *-+: *$', v):\n                align[i] = 'right'\n            elif re.search(r'^ *:-+: *$', v):\n                align[i] = 'center'\n            elif re.search(r'^ *:-+ *$', v):\n                align[i] = 'left'\n            else:\n                align[i] = None\n\n        item = {\n            'type': 'table',\n            'header': header,\n            'align': align,\n        }\n        return item\n\n    def parse_block_html(self, m):\n        tag = m.group(1)\n        if not tag:\n            text = m.group(0)\n            self.tokens.append({\n                'type': 'close_html',\n                'text': text\n            })\n        else:\n            attr = m.group(2)\n            text = m.group(3)\n            self.tokens.append({\n                'type': 'open_html',\n                'tag': tag,\n                'extra': attr,\n                'text': text\n            })\n\n    def parse_paragraph(self, m):\n        text = m.group(1).rstrip('\\n')\n        self.tokens.append({'type': 'paragraph', 'text': text})\n\n    def parse_text(self, m):\n        text = m.group(0)\n        self.tokens.append({'type': 'text', 'text': text})\n\n\nclass InlineGrammar(object):\n    \"\"\"Grammars for inline level tokens.\"\"\"\n\n    escape = re.compile(r'^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>~|])')  # \\* \\+ \\! ....\n    inline_html = re.compile(\n        r'^(?:%s|%s|%s)' % (\n            r'<!--[\\s\\S]*?-->',\n            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (_valid_end, _valid_attr),\n            r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n        )\n    )\n    autolink = re.compile(r'^<([^ >]+(@|:)[^ >]+)>')\n    link = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\('\n        r'''\\s*(<)?([\\s\\S]*?)(?(2)>)(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*'''\n        r'\\)'\n    )\n    reflink = re.compile(\n        r'^!?\\[('\n        r'(?:\\[[^^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*'\n        r')\\]\\s*\\[([^^\\]]*)\\]'\n    )\n    nolink = re.compile(r'^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]')\n    url = re.compile(r'''^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])''')\n    double_emphasis = re.compile(\n        r'^_{2}([\\s\\S]+?)_{2}(?!_)'  # __word__\n        r'|'\n        r'^\\*{2}([\\s\\S]+?)\\*{2}(?!\\*)'  # **word**\n    )\n    emphasis = re.compile(\n        r'^\\b_((?:__|[^_])+?)_\\b'  # _word_\n        r'|'\n        r'^\\*((?:\\*\\*|[^\\*])+?)\\*(?!\\*)'  # *word*\n    )\n    code = re.compile(r'^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)')  # `code`\n    linebreak = re.compile(r'^ {2,}\\n(?!\\s*$)')\n    strikethrough = re.compile(r'^~~(?=\\S)([\\s\\S]*?\\S)~~')  # ~~word~~\n    footnote = re.compile(r'^\\[\\^([^\\]]+)\\]')\n    text = re.compile(r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| {2,}\\n|$)')\n\n    def hard_wrap(self):\n        \"\"\"Grammar for hard wrap linebreak. You don't need to add two\n        spaces at the end of a line.\n        \"\"\"\n        self.linebreak = re.compile(r'^ *\\n(?!\\s*$)')\n        self.text = re.compile(\n            r'^[\\s\\S]+?(?=[\\\\<!\\[_*`~]|https?://| *\\n|$)'\n        )\n\n\nclass InlineLexer(object):\n    \"\"\"Inline level lexer for inline grammars.\"\"\"\n    grammar_class = InlineGrammar\n\n    default_rules = [\n        'escape', 'inline_html', 'autolink', 'url',\n        'footnote', 'link', 'reflink', 'nolink',\n        'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n    inline_html_rules = [\n        'escape', 'autolink', 'url', 'link', 'reflink',\n        'nolink', 'double_emphasis', 'emphasis', 'code',\n        'linebreak', 'strikethrough', 'text',\n    ]\n\n    def __init__(self, renderer, rules=None, **kwargs):\n        self.renderer = renderer\n        self.links = {}\n        self.footnotes = {}\n        self.footnote_index = 0\n\n        if not rules:\n            rules = self.grammar_class()\n\n        kwargs.update(self.renderer.options)\n        if kwargs.get('hard_wrap'):\n            rules.hard_wrap()\n\n        self.rules = rules\n\n        self._in_link = False\n        self._in_footnote = False\n        self._parse_inline_html = kwargs.get('parse_inline_html')\n\n    def __call__(self, text, rules=None):\n        return self.output(text, rules)\n\n    def setup(self, links, footnotes):\n        self.footnote_index = 0\n        self.links = links or {}\n        self.footnotes = footnotes or {}\n\n    def output(self, text, rules=None):\n        text = text.rstrip('\\n')\n        if not rules:\n            rules = list(self.default_rules)\n\n        if self._in_footnote and 'footnote' in rules:\n            rules.remove('footnote')\n\n        output = self.renderer.placeholder()\n\n        def manipulate(text):\n            for key in rules:\n                pattern = getattr(self.rules, key)\n                m = pattern.match(text)\n                if not m:\n                    continue\n                self.line_match = m\n                out = getattr(self, 'output_%s' % key)(m)\n                if out is not None:\n                    return m, out\n            return False  # pragma: no cover\n\n        while text:\n            ret = manipulate(text)\n            if ret is not False:\n                m, out = ret\n                output += out\n                text = text[len(m.group(0)):]\n                continue\n            if text:  # pragma: no cover\n                raise RuntimeError('Infinite loop at: %s' % text)\n\n        return output\n\n    def output_escape(self, m):\n        text = m.group(1)\n        return self.renderer.escape(text)\n\n    def output_autolink(self, m):\n        link = m.group(1)\n        if m.group(2) == '@':\n            is_email = True\n        else:\n            is_email = False\n        return self.renderer.autolink(link, is_email)\n\n    def output_url(self, m):\n        link = m.group(1)\n        if self._in_link:\n            return self.renderer.text(link)\n        return self.renderer.autolink(link, False)\n\n    def output_inline_html(self, m):\n        tag = m.group(1)\n        if self._parse_inline_html and tag in _inline_tags:\n            text = m.group(3)\n            if tag == 'a':\n                self._in_link = True\n                text = self.output(text, rules=self.inline_html_rules)\n                self._in_link = False\n            else:\n                text = self.output(text, rules=self.inline_html_rules)\n            extra = m.group(2) or ''\n            html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        else:\n            html = m.group(0)\n        return self.renderer.inline_html(html)\n\n    def output_footnote(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.footnotes:\n            return None\n        if self.footnotes[key]:\n            return None\n        self.footnote_index += 1\n        self.footnotes[key] = self.footnote_index\n        return self.renderer.footnote_ref(key, self.footnote_index)\n\n    def output_link(self, m):\n        return self._process_link(m, m.group(3), m.group(4))\n\n    def output_reflink(self, m):\n        key = _keyify(m.group(2) or m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def output_nolink(self, m):\n        key = _keyify(m.group(1))\n        if key not in self.links:\n            return None\n        ret = self.links[key]\n        return self._process_link(m, ret['link'], ret['title'])\n\n    def _process_link(self, m, link, title=None):\n        line = m.group(0)\n        text = m.group(1)\n        if line[0] == '!':\n            return self.renderer.image(link, title, text)\n\n        self._in_link = True\n        text = self.output(text)\n        self._in_link = False\n        return self.renderer.link(link, title, text)\n\n    def output_double_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.double_emphasis(text)\n\n    def output_emphasis(self, m):\n        text = m.group(2) or m.group(1)\n        text = self.output(text)\n        return self.renderer.emphasis(text)\n\n    def output_code(self, m):\n        text = m.group(2)\n        return self.renderer.codespan(text)\n\n    def output_linebreak(self, m):\n        return self.renderer.linebreak()\n\n    def output_strikethrough(self, m):\n        text = self.output(m.group(1))\n        return self.renderer.strikethrough(text)\n\n    def output_text(self, m):\n        text = m.group(0)\n        return self.renderer.text(text)\n\n\nclass Renderer(object):\n    \"\"\"The default HTML renderer for rendering Markdown.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.options = kwargs\n\n    def placeholder(self):\n        \"\"\"Returns the default, empty output value for the renderer.\n\n        All renderer methods use the '+=' operator to append to this value.\n        Default is a string so rendering HTML can build up a result string with\n        the rendered Markdown.\n\n        Can be overridden by Renderer subclasses to be types like an empty\n        list, allowing the renderer to create a tree-like structure to\n        represent the document (which can then be reprocessed later into a\n        separate format like docx or pdf).\n        \"\"\"\n        return ''\n\n    def block_code(self, code, lang=None):\n        \"\"\"Rendering block level code. ``pre > code``.\n\n        :param code: text content of the code block.\n        :param lang: language of the given code.\n        \"\"\"\n        code = code.rstrip('\\n')\n        if not lang:\n            code = escape(code, smart_amp=False)\n            return '<pre><code>%s\\n</code></pre>\\n' % code\n        code = escape(code, quote=True, smart_amp=False)\n        return '<pre><code class=\"lang-%s\">%s\\n</code></pre>\\n' % (lang, code)\n\n    def block_quote(self, text):\n        \"\"\"Rendering <blockquote> with the given text.\n\n        :param text: text content of the blockquote.\n        \"\"\"\n        return '<blockquote>%s\\n</blockquote>\\n' % text.rstrip('\\n')\n\n    def block_html(self, html):\n        \"\"\"Rendering block level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('skip_style') and \\\n           html.lower().startswith('<style'):\n            return ''\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def header(self, text, level, raw=None):\n        \"\"\"Rendering header/heading tags like ``<h1>`` ``<h2>``.\n\n        :param text: rendered text content for the header.\n        :param level: a number for the header level, for example: 1.\n        :param raw: raw text content of the header.\n        \"\"\"\n        return '<h%d>%s</h%d>\\n' % (level, text, level)\n\n    def hrule(self):\n        \"\"\"Rendering method for ``<hr>`` tag.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<hr />\\n'\n        return '<hr>\\n'\n\n    def list(self, body, ordered=True):\n        \"\"\"Rendering list tags like ``<ul>`` and ``<ol>``.\n\n        :param body: body contents of the list.\n        :param ordered: whether this list is ordered or not.\n        \"\"\"\n        tag = 'ul'\n        if ordered:\n            tag = 'ol'\n        return '<%s>\\n%s</%s>\\n' % (tag, body, tag)\n\n    def list_item(self, text):\n        \"\"\"Rendering list item snippet. Like ``<li>``.\"\"\"\n        return '<li>%s</li>\\n' % text\n\n    def paragraph(self, text):\n        \"\"\"Rendering paragraph tags. Like ``<p>``.\"\"\"\n        return '<p>%s</p>\\n' % text.strip(' ')\n\n    def table(self, header, body):\n        \"\"\"Rendering table element. Wrap header and body in it.\n\n        :param header: header part of the table.\n        :param body: body part of the table.\n        \"\"\"\n        return (\n            '<table>\\n<thead>%s</thead>\\n'\n            '<tbody>\\n%s</tbody>\\n</table>\\n'\n        ) % (header, body)\n\n    def table_row(self, content):\n        \"\"\"Rendering a table row. Like ``<tr>``.\n\n        :param content: content of current table row.\n        \"\"\"\n        return '<tr>\\n%s</tr>\\n' % content\n\n    def table_cell(self, content, **flags):\n        \"\"\"Rendering a table cell. Like ``<th>`` ``<td>``.\n\n        :param content: content of current table cell.\n        :param header: whether this is header or not.\n        :param align: align of current table cell.\n        \"\"\"\n        if flags['header']:\n            tag = 'th'\n        else:\n            tag = 'td'\n        align = flags['align']\n        if not align:\n            return '<%s>%s</%s>\\n' % (tag, content, tag)\n        return '<%s style=\"text-align:%s\">%s</%s>\\n' % (\n            tag, align, content, tag\n        )\n\n    def double_emphasis(self, text):\n        \"\"\"Rendering **strong** text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<strong>%s</strong>' % text\n\n    def emphasis(self, text):\n        \"\"\"Rendering *emphasis* text.\n\n        :param text: text content for emphasis.\n        \"\"\"\n        return '<em>%s</em>' % text\n\n    def codespan(self, text):\n        \"\"\"Rendering inline `code` text.\n\n        :param text: text content for inline code.\n        \"\"\"\n        text = escape(text.rstrip(), smart_amp=False)\n        return '<code>%s</code>' % text\n\n    def linebreak(self):\n        \"\"\"Rendering line break like ``<br>``.\"\"\"\n        if self.options.get('use_xhtml'):\n            return '<br />\\n'\n        return '<br>\\n'\n\n    def strikethrough(self, text):\n        \"\"\"Rendering ~~strikethrough~~ text.\n\n        :param text: text content for strikethrough.\n        \"\"\"\n        return '<del>%s</del>' % text\n\n    def text(self, text):\n        \"\"\"Rendering unformatted text.\n\n        :param text: text content.\n        \"\"\"\n        if self.options.get('parse_block_html'):\n            return text\n        return escape(text)\n\n    def escape(self, text):\n        \"\"\"Rendering escape sequence.\n\n        :param text: text content.\n        \"\"\"\n        return escape(text)\n\n    def autolink(self, link, is_email=False):\n        \"\"\"Rendering a given link or email address.\n\n        :param link: link content or email address.\n        :param is_email: whether this is an email or not.\n        \"\"\"\n        text = link = escape_link(link)\n        if is_email:\n            link = 'mailto:%s' % link\n        return '<a href=\"%s\">%s</a>' % (link, text)\n\n    def link(self, link, title, text):\n        \"\"\"Rendering a given link with content and title.\n\n        :param link: href link for ``<a>`` tag.\n        :param title: title content for `title` attribute.\n        :param text: text content for description.\n        \"\"\"\n        link = escape_link(link)\n        if not title:\n            return '<a href=\"%s\">%s</a>' % (link, text)\n        title = escape(title, quote=True)\n        return '<a href=\"%s\" title=\"%s\">%s</a>' % (link, title, text)\n\n    def image(self, src, title, text):\n        \"\"\"Rendering a image with title and text.\n\n        :param src: source link of the image.\n        :param title: title text of the image.\n        :param text: alt text of the image.\n        \"\"\"\n        src = escape_link(src)\n        text = escape(text, quote=True)\n        if title:\n            title = escape(title, quote=True)\n            html = '<img src=\"%s\" alt=\"%s\" title=\"%s\"' % (src, text, title)\n        else:\n            html = '<img src=\"%s\" alt=\"%s\"' % (src, text)\n        if self.options.get('use_xhtml'):\n            return '%s />' % html\n        return '%s>' % html\n\n    def inline_html(self, html):\n        \"\"\"Rendering span level pure html content.\n\n        :param html: text content of the html snippet.\n        \"\"\"\n        if self.options.get('escape'):\n            return escape(html)\n        return html\n\n    def newline(self):\n        \"\"\"Rendering newline element.\"\"\"\n        return ''\n\n    def footnote_ref(self, key, index):\n        \"\"\"Rendering the ref anchor of a footnote.\n\n        :param key: identity key for the footnote.\n        :param index: the index count of current footnote.\n        \"\"\"\n        html = (\n            '<sup class=\"footnote-ref\" id=\"fnref-%s\">'\n            '<a href=\"#fn-%s\">%d</a></sup>'\n        ) % (escape(key), escape(key), index)\n        return html\n\n    def footnote_item(self, key, text):\n        \"\"\"Rendering a footnote item.\n\n        :param key: identity key for the footnote.\n        :param text: text content of the footnote.\n        \"\"\"\n        back = (\n            '<a href=\"#fnref-%s\" class=\"footnote\">&#8617;</a>'\n        ) % escape(key)\n        text = text.rstrip()\n        if text.endswith('</p>'):\n            text = re.sub(r'<\\/p>$', r'%s</p>' % back, text)\n        else:\n            text = '%s<p>%s</p>' % (text, back)\n        html = '<li id=\"fn-%s\">%s</li>\\n' % (escape(key), text)\n        return html\n\n    def footnotes(self, text):\n        \"\"\"Wrapper for all footnotes.\n\n        :param text: contents of all footnotes.\n        \"\"\"\n        html = '<div class=\"footnotes\">\\n%s<ol>%s</ol>\\n</div>\\n'\n        return html % (self.hrule(), text)\n\n\nclass Markdown(object):\n    \"\"\"The Markdown parser.\n\n    :param renderer: An instance of ``Renderer``.\n    :param inline: An inline lexer class or instance.\n    :param block: A block lexer class or instance.\n    \"\"\"\n    def __init__(self, renderer=None, inline=None, block=None, **kwargs):\n        if not renderer:\n            renderer = Renderer(**kwargs)\n        else:\n            kwargs.update(renderer.options)\n\n        self.renderer = renderer\n\n        if inline and inspect.isclass(inline):\n            inline = inline(renderer, **kwargs)\n        if block and inspect.isclass(block):\n            block = block(**kwargs)\n\n        if inline:\n            self.inline = inline\n        else:\n            self.inline = InlineLexer(renderer, **kwargs)\n\n        self.block = block or BlockLexer(BlockGrammar())\n        self.footnotes = []\n        self.tokens = []\n\n        # detect if it should parse text in block html\n        self._parse_block_html = kwargs.get('parse_block_html')\n\n    def __call__(self, text):\n        return self.parse(text)\n\n    def render(self, text):\n        \"\"\"Render the Markdown text.\n\n        :param text: markdown formatted text content.\n        \"\"\"\n        return self.parse(text)\n\n    def parse(self, text):\n        out = self.output(preprocessing(text))\n\n        keys = self.block.def_footnotes\n\n        # reset block\n        self.block.def_links = {}\n        self.block.def_footnotes = {}\n\n        # reset inline\n        self.inline.links = {}\n        self.inline.footnotes = {}\n\n        if not self.footnotes:\n            return out\n\n        footnotes = filter(lambda o: keys.get(o['key']), self.footnotes)\n        self.footnotes = sorted(\n            footnotes, key=lambda o: keys.get(o['key']), reverse=True\n        )\n\n        body = self.renderer.placeholder()\n        while self.footnotes:\n            note = self.footnotes.pop()\n            body += self.renderer.footnote_item(\n                note['key'], note['text']\n            )\n\n        out += self.renderer.footnotes(body)\n        return out\n\n    def pop(self):\n        if not self.tokens:\n            return None\n        self.token = self.tokens.pop()\n        return self.token\n\n    def peek(self):\n        if self.tokens:\n            return self.tokens[-1]\n        return None  # pragma: no cover\n\n    def output(self, text, rules=None):\n        self.tokens = self.block(text, rules)\n        self.tokens.reverse()\n\n        self.inline.setup(self.block.def_links, self.block.def_footnotes)\n\n        out = self.renderer.placeholder()\n        while self.pop():\n            out += self.tok()\n        return out\n\n    def tok(self):\n        t = self.token['type']\n\n        # sepcial cases\n        if t.endswith('_start'):\n            t = t[:-6]\n\n        return getattr(self, 'output_%s' % t)()\n\n    def tok_text(self):\n        text = self.token['text']\n        while self.peek()['type'] == 'text':\n            text += '\\n' + self.pop()['text']\n        return self.inline(text)\n\n    def output_newline(self):\n        return self.renderer.newline()\n\n    def output_hrule(self):\n        return self.renderer.hrule()\n\n    def output_heading(self):\n        return self.renderer.header(\n            self.inline(self.token['text']),\n            self.token['level'],\n            self.token['text'],\n        )\n\n    def output_code(self):\n        return self.renderer.block_code(\n            self.token['text'], self.token['lang']\n        )\n\n    def output_table(self):\n        aligns = self.token['align']\n        aligns_length = len(aligns)\n        cell = self.renderer.placeholder()\n\n        # header part\n        header = self.renderer.placeholder()\n        for i, value in enumerate(self.token['header']):\n            align = aligns[i] if i < aligns_length else None\n            flags = {'header': True, 'align': align}\n            cell += self.renderer.table_cell(self.inline(value), **flags)\n\n        header += self.renderer.table_row(cell)\n\n        # body part\n        body = self.renderer.placeholder()\n        for i, row in enumerate(self.token['cells']):\n            cell = self.renderer.placeholder()\n            for j, value in enumerate(row):\n                align = aligns[j] if j < aligns_length else None\n                flags = {'header': False, 'align': align}\n                cell += self.renderer.table_cell(self.inline(value), **flags)\n            body += self.renderer.table_row(cell)\n\n        return self.renderer.table(header, body)\n\n    def output_block_quote(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'block_quote_end':\n            body += self.tok()\n        return self.renderer.block_quote(body)\n\n    def output_list(self):\n        ordered = self.token['ordered']\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_end':\n            body += self.tok()\n        return self.renderer.list(body, ordered)\n\n    def output_list_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            if self.token['type'] == 'text':\n                body += self.tok_text()\n            else:\n                body += self.tok()\n\n        return self.renderer.list_item(body)\n\n    def output_loose_item(self):\n        body = self.renderer.placeholder()\n        while self.pop()['type'] != 'list_item_end':\n            body += self.tok()\n        return self.renderer.list_item(body)\n\n    def output_footnote(self):\n        self.inline._in_footnote = True\n        body = self.renderer.placeholder()\n        key = self.token['key']\n        while self.pop()['type'] != 'footnote_end':\n            body += self.tok()\n        self.footnotes.append({'key': key, 'text': body})\n        self.inline._in_footnote = False\n        return self.renderer.placeholder()\n\n    def output_close_html(self):\n        text = self.token['text']\n        return self.renderer.block_html(text)\n\n    def output_open_html(self):\n        text = self.token['text']\n        tag = self.token['tag']\n        if self._parse_block_html and tag not in _pre_tags:\n            text = self.inline(text, rules=self.inline.inline_html_rules)\n        extra = self.token.get('extra') or ''\n        html = '<%s%s>%s</%s>' % (tag, extra, text, tag)\n        return self.renderer.block_html(html)\n\n    def output_paragraph(self):\n        return self.renderer.paragraph(self.inline(self.token['text']))\n\n    def output_text(self):\n        return self.renderer.paragraph(self.tok_text())\n\n\ndef markdown(text, escape=True, **kwargs):\n    \"\"\"Render markdown formatted text to html.\n\n    :param text: markdown formatted text content.\n    :param escape: if set to False, all html tags will not be escaped.\n    :param use_xhtml: output with xhtml tags.\n    :param hard_wrap: if set to True, it will use the GFM line breaks feature.\n    :param parse_block_html: parse text only in block level html.\n    :param parse_inline_html: parse text only in inline level html.\n    \"\"\"\n    return Markdown(escape=escape, **kwargs)(text)\n", "patch": "@@ -11,7 +11,7 @@\n import re\n import inspect\n \n-__version__ = '0.8'\n+__version__ = '0.8.1'\n __author__ = 'Hsiaoming Yang <me@lepture.com>'\n __all__ = [\n     'BlockGrammar', 'BlockLexer',\n@@ -48,7 +48,8 @@ def _pure_pattern(regex):\n \n \n def _keyify(key):\n-    return _key_pattern.sub(' ', key.lower())\n+    key = escape(key.lower(), quote=True)\n+    return _key_pattern.sub(' ', key)\n \n \n def escape(text, quote=False, smart_amp=True):\n@@ -445,7 +446,8 @@ class InlineGrammar(object):\n     inline_html = re.compile(\n         r'^(?:%s|%s|%s)' % (\n             r'<!--[\\s\\S]*?-->',\n-            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (_valid_end, _valid_attr),\n+            r'<(\\w+%s)((?:%s)*?)\\s*>([\\s\\S]*?)<\\/\\1>' % (\n+                _valid_end, _valid_attr),\n             r'<\\w+%s(?:%s)*?\\s*\\/?>' % (_valid_end, _valid_attr),\n         )\n     )", "file_path": "files/2017_12/16", "file_language": "py", "file_name": "mistune.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [true, ["/data/rdhu/other/Static/tmp/2017_12_16.py:445: High: compile\n    inline_html = re.compile(\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous."]], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
