{"index": 6826, "cve_id": "CVE-2021-41134", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "nbdime provides tools for diffing and merging of Jupyter Notebooks. In affected versions a stored cross-site scripting (XSS) issue exists within the Jupyter-owned nbdime project. It appears that when reading the file name and path from disk, the extension does not sanitize the string it constructs before returning it to be displayed. The diffNotebookCheckpoint function within nbdime causes this issue. When attempting to display the name of the local notebook (diffNotebookCheckpoint), nbdime appears to simply append .ipynb to the name of the input file. The NbdimeWidget is then created, and the base string is passed through to the request API function. From there, the frontend simply renders the HTML tag and anything along with it. Users are advised to patch to the most recent version of the affected product.", "cvss": "5.4", "publish_date": "November 3, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "e44a5cc7677f24b45ebafc756db49058c2f750ea", "commit_message": "Merge pull request from GHSA-p6rw-44q7-3fw4\n\nSafer handling of user strings", "commit_date": "2021-10-25T22:51:55Z", "project": "jupyter/nbdime", "url": "https://api.github.com/repos/jupyter/nbdime/commits/e44a5cc7677f24b45ebafc756db49058c2f750ea", "html_url": "https://github.com/jupyter/nbdime/commit/e44a5cc7677f24b45ebafc756db49058c2f750ea", "windows_before": [{"commit_id": "e77ed97592612d2ac9eb2ad266c544ab53879d08", "commit_date": "Mon Oct 25 18:48:33 2021 +0100", "commit_message": "Run CI on 3.10", "files_name": [".github/workflows/tests.yml"]}, {"commit_id": "f91e5c32e7b83418048c1d8039f829ae6603231d", "commit_date": "Sun Oct 24 15:04:11 2021 -0400", "commit_message": "Support python 3.10", "files_name": ["setup.py", "setupbase.py"]}, {"commit_id": "492bc23347f4b81ed8f240890e70a5bc035e1c5e", "commit_date": "Thu Sep 30 08:50:06 2021 -0700", "commit_message": "Format note and code on installation page", "files_name": ["docs/source/installing.rst"]}, {"commit_id": "19fded3bb9ac3405d1efa4d34b9b45d3e261dcc0", "commit_date": "Thu Sep 30 12:22:20 2021 +0100", "commit_message": "Fix buildSelect + tests", "files_name": ["packages/nbdime/src/common/util.ts", "packages/nbdime/test/src/common/util.spec.ts"]}, {"commit_id": "8f931cbf36ce6d356b771a74fcd2fd2e48d599d7", "commit_date": "Wed Sep 29 11:02:04 2021 +0100", "commit_message": "Replace innerHTML with innerText", "files_name": ["packages/labextension/src/widget.ts", "packages/nbdime/src/common/util.ts", "packages/webapp/src/app/diff.ts", "packages/webapp/src/app/merge.ts"]}, {"commit_id": "5f053299bc59d410130b3cb104f66f8fa5c6c29d", "commit_date": "Thu Sep 30 12:08:11 2021 +0100", "commit_message": "Merge pull request #604 from vidartf/fix-build", "files_name": ["36ecef6f80d2c998dbffc80fa16ca274fe340957 - Thu Sep 30 11:38:01 2021 +0100 : Also upload codecov on JS tests", ".github/workflows/tests.yml"]}, {"commit_id": "6967723ca3754e94b8ac3393323cbda2de0c9ce0", "commit_date": "Thu Sep 30 11:28:15 2021 +0100", "commit_message": "Fixes for GHA CI", "files_name": [".github/workflows/tests.yml", ".travis.yml"]}, {"commit_id": "559d7853ea08c7ebb358a9644c4ef6d5d6960eda", "commit_date": "Thu Sep 30 11:19:16 2021 +0100", "commit_message": "Merge pull request #603 from vidartf/fix-build", "files_name": ["b283d494201ae9955be11257a173f95845a9c3f1 - Wed Sep 29 13:50:29 2021 +0100 : Attempt to set up GHA", ".github/workflows/tests.yml"]}, {"commit_id": "8b48709927e43ae3c5b8c6c7966c146ea69f08ae", "commit_date": "Wed Sep 29 12:59:22 2021 +0100", "commit_message": "Update jest.config.js", "files_name": ["packages/nbdime/jest.config.js"]}, {"commit_id": "a9887180c19fc64b75ba42b23fc563fc467578d9", "commit_date": "Wed Sep 29 12:05:13 2021 +0100", "commit_message": "Fix the build", "files_name": ["package.json", "packages/webapp/package.json", "packages/webapp/src/index.ts"]}, {"commit_id": "a74b538386d05e3e9c26753ad21faf9ff4d269d7", "commit_date": "Thu Jun 24 14:15:03 2021 +0100", "commit_message": "Update changelog.md", "files_name": ["docs/source/changelog.md"]}, {"commit_id": "4036fae9ede339cdf0cd0c49ead1e2283cb1d626", "commit_date": "Fri Jun 18 14:21:11 2021 +0800", "commit_message": "fix", "files_name": ["nbdime/webapp/nb_server_extension.py"]}, {"commit_id": "7a6d456208d8b8a7d8a351e02d6d830a8055c308", "commit_date": "Thu Jun 17 23:24:02 2021 +0800", "commit_message": "Compatible with asynchronous contentsmanager", "files_name": ["nbdime/webapp/nb_server_extension.py"]}, {"commit_id": "4dbaabe7a310fca0f0293e7e97a5e9199023b819", "commit_date": "Tue May 25 17:16:24 2021 +0100", "commit_message": "back to dev", "files_name": ["nbdime/_version.py"]}, {"commit_id": "f376fa3608c9a166ac7893c3b26d71854735ea59", "commit_date": "Tue May 25 17:14:45 2021 +0100", "commit_message": "3.1.0", "files_name": ["nbdime/_version.py"]}, {"commit_id": "761f106624e0b0481ec9f864e5a3614f2baaf152", "commit_date": "Tue May 25 17:10:26 2021 +0100", "commit_message": "nbdime@6.1.1", "files_name": ["packages/nbdime/package.json"]}, {"commit_id": "9df6aea72e657ce311a1e91037705eac8782e9d8", "commit_date": "Tue May 25 15:15:43 2021 +0100", "commit_message": "Merge pull request #593 from vidartf/fix-added-long-output", "files_name": ["8201cd5533b15f06e83aa5009678ad2e6d96d6c2 - Wed May 19 19:26:25 2021 +0100 : Fix missed update from copy/paste", "packages/nbdime/src/diff/model/renderable.ts"]}, {"commit_id": "c01cbb816fce56268a7d6d62887857ebd161d253", "commit_date": "Wed May 5 18:16:53 2021 +0200", "commit_message": "Doc: precise configuration option", "files_name": ["docs/source/config.rst"]}, {"commit_id": "524aac24e1b1a4367f3673627161e5bcf62d8f90", "commit_date": "Tue Apr 20 12:27:09 2021 +0100", "commit_message": "Merge pull request #586 from fcollonval/fcollonval/issue583", "files_name": ["e4e696c640f60afe8586732cc7591d9b9064b876 - Sat Apr 17 17:09:06 2021 +0200 : Remove Python 2.7 dedicated code Fixes #583", "docs/source/installing.rst", "docs/source/nodevenv.rst", "nbdime/__init__.py", "nbdime/__main__.py", "nbdime/config.py", "nbdime/diff_format.py", "nbdime/diff_utils.py", "nbdime/diffing/__init__.py", "nbdime/diffing/generic.py", "nbdime/diffing/lcs.py", "nbdime/diffing/notebooks.py", "nbdime/diffing/seq_bruteforce.py", "nbdime/diffing/seq_difflib.py", "nbdime/diffing/seq_myers.py", "nbdime/diffing/sequences.py", "nbdime/diffing/snakes.py", "nbdime/gitfiles.py", "nbdime/ignorables.py", "nbdime/log.py", "nbdime/merging/__init__.py", "nbdime/merging/autoresolve.py", "nbdime/merging/chunks.py", "nbdime/merging/decisions.py", "nbdime/merging/generic.py", "nbdime/merging/notebooks.py", "nbdime/merging/strategies.py", "nbdime/nbdiffapp.py", "nbdime/nbmergeapp.py", "nbdime/nbpatchapp.py", "nbdime/nbshowapp.py", "nbdime/patching.py", "nbdime/prettyprint.py", "nbdime/tests/__init__.py", "nbdime/tests/conftest.py", "nbdime/tests/test_apply_merge.py", "nbdime/tests/test_args.py", "nbdime/tests/test_autoresolve.py", "nbdime/tests/test_cli_apps.py", "nbdime/tests/test_decision_tools.py", "nbdime/tests/test_diff.py", "nbdime/tests/test_diff_gitrefs.py", "nbdime/tests/test_diff_sequence.py", "nbdime/tests/test_diff_sequence_bruteforce.py", "nbdime/tests/test_diff_sequence_difflib.py", "nbdime/tests/test_git_diffdriver.py", "nbdime/tests/test_git_filter_integration.py", "nbdime/tests/test_hg_differ.py", "nbdime/tests/test_merge.py", "nbdime/tests/test_merge_notebooks.py", "nbdime/tests/test_myers.py", "nbdime/tests/test_notebook_diff.py", "nbdime/tests/test_patch.py", "nbdime/tests/test_prettyprint.py", "nbdime/tests/utils.py", "nbdime/utils.py", "nbdime/vcs/git/diffdriver.py", "nbdime/vcs/git/filter_integration.py", "nbdime/vcs/git/mergedriver.py", "nbdime/vcs/hg/diff.py", "nbdime/vcs/hg/diffweb.py", "nbdime/vcs/hg/merge.py", "nbdime/vcs/hg/mergeweb.py", "nbdime/webapp/nb_server_extension.py", "nbdime/webapp/nbdifftool.py", "nbdime/webapp/nbdiffweb.py", "nbdime/webapp/nbdimeserver.py", "nbdime/webapp/nbmergetool.py", "nbdime/webapp/nbmergeweb.py", "nbdime/webapp/webutil.py", "setup.py"]}, {"commit_id": "2994fb4fad38beb698e65c6570b521fd275e6f48", "commit_date": "Wed Apr 14 18:37:44 2021 +0100", "commit_message": "back to dev", "files_name": ["nbdime/_version.py"]}, {"commit_id": "a5936d1a8a265aa7d272ba2d06e29bda963c2b81", "commit_date": "Wed Apr 14 18:28:47 2021 +0100", "commit_message": "3.0.0", "files_name": ["docs/source/changelog.md", "nbdime/_version.py", "packages/labextension/package.json", "packages/nbdime/package.json", "packages/webapp/package.json"]}, {"commit_id": "ab8e60d48e9f0a59f2c9b4120dcdd65ab92b942d", "commit_date": "Wed Apr 14 18:01:22 2021 +0100", "commit_message": "Merge pull request #581 from vidartf/clenaup", "files_name": ["23e0cc9f305b6a8bea7c591b5fa67399b5537e98 - Wed Apr 14 17:35:44 2021 +0100 : cleanup labext dist", "nbdime/__init__.py", "packages/labextension/package.json", "setup.py"]}, {"commit_id": "f1e18ff929acb455bc7fbd51d3e8715751b8b2f7", "commit_date": "Wed Apr 14 17:27:12 2021 +0100", "commit_message": "Merge pull request #572 from fcollonval/ft/federated-package", "files_name": ["6c1ce97e1f86885be6c7ac2ba9d8218e2cab2a5e - Wed Apr 14 09:16:42 2021 +0200 : Package lab assets in python pkg", ".gitignore", "MANIFEST.in", "nbdime/__init__.py", "packages/labextension/package.json", "setup.py"]}, {"commit_id": "52f7990abcc22781863881859c276882667ecfb4", "commit_date": "Tue Apr 13 19:03:43 2021 +0100", "commit_message": "Merge pull request #580 from fcollonval/fix/follow-up-576", "files_name": ["8391e4c92f65cfde1517f53d21ee7b17f9095f6e - Mon Apr 12 15:56:32 2021 +0200 : Fix job killed by max log length", ".travis.yml"]}, {"commit_id": "f03d0fa0cd5c2b66721473e5d1dfd9122d0635c2", "commit_date": "Mon Apr 12 15:50:02 2021 +0200", "commit_message": "Fix typo", "files_name": ["setup.py"]}, {"commit_id": "289dbdf512c8317f335905ab31f2ec0fbad66c09", "commit_date": "Mon Apr 12 15:45:29 2021 +0200", "commit_message": "Fix import of setupbase for PEP 517/518", "files_name": ["setup.py"]}, {"commit_id": "99ace3abf64bbee2766eb15b14619d1a1c6e84c5", "commit_date": "Mon Apr 12 15:42:06 2021 +0200", "commit_message": "Need jupyterlab to build the sdist", "files_name": ["appveyor.yml"]}, {"commit_id": "328d0fe7c6fd62965c9d1b84fc1c5db923e68cae", "commit_date": "Mon Apr 12 15:36:23 2021 +0200", "commit_message": "jupyter-packaging is not used", "files_name": ["pyproject.toml"]}, {"commit_id": "2577450534af484603fa7a67c57fc717211b31d2", "commit_date": "Mon Apr 12 15:35:00 2021 +0200", "commit_message": "Create pyproject.toml", "files_name": ["pyproject.toml"]}, {"commit_id": "25252f664731ff89c381c12393a7f99e44795c4b", "commit_date": "Mon Apr 12 09:23:40 2021 +0200", "commit_message": "Remove unnecessary dev dependency", "files_name": ["packages/nbdime/package.json"]}, {"commit_id": "7ce9586809cf3b908a6e5878abf2c0aface72eca", "commit_date": "Mon Apr 12 09:23:22 2021 +0200", "commit_message": "Add comments on mocked objects", "files_name": ["packages/nbdime/test/src/common/mergeview.spec.ts", "packages/nbdime/test/src/merge/widget.spec.ts"]}, {"commit_id": "7458c8854f6cec25c07fbefae6bfbc3d83f43e1a", "commit_date": "Sat Mar 13 18:28:56 2021 +0100", "commit_message": "Package labextension as federated extension", "files_name": ["packages/labextension/package.json", "packages/nbdime/package.json", "setup.py"]}, {"commit_id": "8ce708cc541b3a104b67bed75c180dcaaedc4dc2", "commit_date": "Mon Apr 12 01:40:45 2021 +0100", "commit_message": "Merge pull request #566 from krassowski/fix-cell-id-tests", "files_name": ["dea43d6015132de896742027a9498d1a29e563de - Sun Apr 11 21:28:48 2021 +0100 : ignore some more cell ids"]}], "windows_after": [{"commit_id": "1b3f2b43d51e0dab536c352135077cf386de8ade", "commit_date": "Tue Oct 26 00:31:53 2021 +0100", "commit_message": "back to dev", "files_name": ["nbdime/_version.py"]}, {"commit_id": "17d103c5102f98fb83417fc54a99237795110b3a", "commit_date": "Wed Nov 3 11:51:16 2021 +0000", "commit_message": "Merge pull request #605 from joelostblom/patch-1", "files_name": ["480a421d9a7bb6cddb1b6a0903b70cf9f638cc84 - Fri Feb 4 10:29:40 2022 +0000 : Make INFO text more readable in black terminal", "nbdime/prettyprint.py"]}, {"commit_id": "fc31fbbe2e6a25a8221f011af08ca4e1fdbf9690", "commit_date": "Mon Feb 28 10:52:19 2022 +0000", "commit_message": "Merge pull request #589 from brunetton/patch-2", "files_name": ["dd4be20beb71b62505162f7e0efcdb5fca6cedf1 - Wed Mar 2 22:11:24 2022 +0200 : add GitHub URL for PyPi", "setup.py"]}, {"commit_id": "49c853ef7cf2f21d6e2358a4ab0bddcb0713c082", "commit_date": "Sat Mar 12 06:04:12 2022 -0600", "commit_message": "Remove usage of ipython_genutils", "files_name": ["nbdime/config.py"]}, {"commit_id": "bbf621e38a11767dc58edabaad37a3f0414ef14a", "commit_date": "Sat Apr 9 05:33:57 2022 -0500", "commit_message": "Merge pull request #618 from jupyter/blink1073-patch-1", "files_name": ["fa4e2a3890c5a022cfdd0a8d67d25ab98a21d6b8 - Mon Apr 18 10:42:26 2022 +0200 : Merge pull request #617 from andriyor/patch-1", "2db0b44d24352f37b655bddda4fcb2f0e7e31bf9 - Sun Jun 19 10:46:51 2022 +0100 : Merge pull request #615 from tallamjr/issues/240/prettyprint-black-terminal", "ecded88425ceaaebdf9d1c7b5507cf04f5633dd4 - Sun Jun 19 10:48:02 2022 +0100 : Merge pull request #596 from icankeep/fix-checkpoint-async", "9c190e05f9b1ae7304bbaea82627dffff33c2eea - Wed Jun 29 15:30:54 2022 +0200 : fixed the grant number display, added missing space", "docs/source/index.rst"]}, {"commit_id": "4bc7ae23fbe8c2fce2ac084a091118db5a9d7eb5", "commit_date": "Tue Jul 5 17:29:00 2022 +0100", "commit_message": "Merge pull request #623 from Daniel-Mietchen/patch-1", "files_name": ["f67a809262b45ed0eaedc840b0e5d979eaa6965d - Tue Nov 22 23:43:59 2022 -0500 : Move global flags to start of regex", "setupbase.py"]}, {"commit_id": "f50376344db8ba01f1aff0b65f39ead7a3ed2405", "commit_date": "Thu Nov 24 14:42:18 2022 +0000", "commit_message": "Merge pull request #640 from singingwolfboy/patch-1", "files_name": ["3079951ae746505c29a81ba1c9e2a50c03aec093 - Sun Dec 4 20:36:15 2022 -0600 : support Python 3.11", ".github/workflows/tests.yml", "setup.py"]}, {"commit_id": "39bbff782cbc05d2b0f942f24a382a327cc8cbfc", "commit_date": "Fri Dec 16 18:18:01 2022 -0500", "commit_message": "Update cell marker format to use bold correctly", "files_name": ["nbdime/merging/strategies.py"]}, {"commit_id": "fe11ad568472526f4c8cc17104559d0c28acc8f5", "commit_date": "Sat Jan 14 16:10:48 2023 +0000", "commit_message": "Merge pull request #644 from singingwolfboy/py311", "files_name": ["a02615e68d7c64b02eba601f1050fffb02d1f212 - Sun Jan 15 07:39:41 2023 -0500 : Update typescript (#641)", ".github/workflows/tests.yml", "nbdime/tests/conftest.py", "nbdime/tests/test_cli_apps.py", "nbdime/tests/test_web.py", "nbdime/webapp/nb_server_extension.py", "nbdime/webapp/nbdimeserver.py", "packages/labextension/package.json", "packages/labextension/src/actions.ts", "packages/labextension/src/plugin.ts", "packages/labextension/src/widget.ts", "packages/nbdime/package.json", "packages/nbdime/src/chunking/diffchunking.ts", "packages/nbdime/src/common/dragpanel.ts", "packages/nbdime/src/common/editor.ts", "packages/nbdime/src/common/mergeview.ts", "packages/nbdime/src/diff/diffentries.ts", "packages/nbdime/src/diff/model/cell.ts", "packages/nbdime/src/diff/model/immutable.ts", "packages/nbdime/src/diff/model/notebook.ts", "packages/nbdime/src/diff/model/output.ts", "packages/nbdime/src/diff/model/renderable.ts", "packages/nbdime/src/diff/model/string.ts", "packages/nbdime/src/diff/range.ts", "packages/nbdime/src/diff/widget/cell.ts", "packages/nbdime/src/diff/widget/metadata.ts", "packages/nbdime/src/diff/widget/notebook.ts", "packages/nbdime/src/diff/widget/output.ts", "packages/nbdime/src/diff/widget/renderable.ts", "packages/nbdime/src/merge/model/cell.ts", "packages/nbdime/src/merge/model/common.ts", "packages/nbdime/src/merge/model/metadata.ts", "packages/nbdime/src/merge/model/notebook.ts", "packages/nbdime/src/merge/widget/cell.ts", "packages/nbdime/src/merge/widget/dragdrop.ts", "packages/nbdime/src/merge/widget/metadata.ts", "packages/nbdime/src/merge/widget/notebook.ts", "packages/nbdime/src/merge/widget/output.ts", "packages/nbdime/src/patch/common.ts", "packages/nbdime/src/patch/stringified.ts", "packages/nbdime/src/request/index.ts", "packages/nbdime/src/upstreaming/flexpanel.ts", "packages/nbdime/test/src/common/flexpanel.spec.ts", "packages/nbdime/test/src/diff/model.spec.ts", "packages/nbdime/test/src/diff/widget/output.spec.ts", "packages/nbdime/test/src/merge/model.spec.ts", "packages/nbdime/test/src/merge/widget.spec.ts", "packages/nbdime/test/src/patch/patching.spec.ts", "packages/webapp/package.json", "packages/webapp/src/app/common.ts", "packages/webapp/src/app/diff.ts", "packages/webapp/src/app/merge.ts", "packages/webapp/src/app/save.ts", "tsconfig_base.json"]}, {"commit_id": "c6b14b1f040242281e56e1992c56d33c3fe0488d", "commit_date": "Sun Jan 15 14:16:01 2023 +0000", "commit_message": "Add identity_provider setting w/jupyter_server 2", "files_name": ["nbdime/webapp/nbdimeserver.py"]}, {"commit_id": "535e62b6b744d8a8162b2d3ce339ff6fb078fd16", "commit_date": "Sun Jan 15 14:18:40 2023 +0000", "commit_message": "XSRF for sendBeacon calls (closetool API)", "files_name": ["nbdime/tests/test_cli_apps.py", "nbdime/webapp/nbdimeserver.py", "packages/webapp/src/app/common.ts"]}, {"commit_id": "498ae07567ac0f40e3c3c459311a5855e530ae3f", "commit_date": "Sun Jan 15 15:24:08 2023 +0000", "commit_message": "formatting tests", "files_name": ["nbdime/tests/test_server_extension.py"]}, {"commit_id": "0d57918d898c5128a298af0d3390502d2a5b094c", "commit_date": "Sun Jan 15 17:09:23 2023 +0000", "commit_message": "Merge pull request #648 from mlucool/patch-1", "files_name": ["2da614b603b694e13fc8d597eef1cc09ff07cb10 - Sun Jan 15 17:22:37 2023 +0000 : Merge pull request #649 from vidartf/jps2", "510364e08ca41dd474ede7ca349506a6e949e50d - Sun Jan 29 16:49:29 2023 +0800 : Replace mock with unittest.mock", "nbdime/tests/test_git_diffdriver.py", "nbdime/tests/test_hg_differ.py", "setup.py"]}, {"commit_id": "742e38f344e1d1fe6a303a7a5870b3d9c1faef93", "commit_date": "Mon Feb 20 14:35:47 2023 +0800", "commit_message": "Fix building", "files_name": [".github/workflows/tests.yml"]}, {"commit_id": "d5a3a4860603eae0a3a53bf27183bc611cd5a7e1", "commit_date": "Fri Mar 24 08:54:17 2023 -0700", "commit_message": "Fix typo", "files_name": ["nbdime/nbmergeapp.py"]}, {"commit_id": "50c9347e24007e31fee3dcb4b7ada66a3285bdb6", "commit_date": "Fri Mar 24 22:50:11 2023 +0000", "commit_message": "Merge pull request #651 from yan12125/unittest-mock", "files_name": ["9fbfd4656d9ce66c44b62154097808da5df9bf48 - Fri Mar 24 23:20:15 2023 +0000 : Merge pull request #657 from saiwing-yeung/master", "254f0eeae0f3740f0250ce67e67f5243914d73b7 - Fri Mar 24 11:10:01 2023 +0000 : Add back support for nb6", "nbdime/__init__.py", "nbdime/tests/conftest.py", "nbdime/webapp/nb_server_extension.py"]}, {"commit_id": "d78fdeba7e5935537c30596330f5b72cb65b0a45", "commit_date": "Fri Mar 24 11:32:05 2023 +0000", "commit_message": "Test with both jupyter_server 2 and 1", "files_name": [".github/workflows/tests.yml"]}, {"commit_id": "e9b2156eda49cd1daa23454bb48a9e37ae2d3fab", "commit_date": "Wed Apr 12 01:58:28 2023 +0100", "commit_message": "Update dev tooling", "files_name": [".github/workflows/tests.yml", "appveyor.yml", "package.json", "packages/labextension/package.json", "packages/nbdime/jest.config.js", "packages/nbdime/package.json", "packages/nbdime/test/jest-setup-files.js", "packages/webapp/package.json", "packages/webapp/webpack.config.js"]}, {"commit_id": "df0353a14db9110feb5809745912a102c70b6751", "commit_date": "Wed Apr 12 17:59:47 2023 +0100", "commit_message": "Update CI", "files_name": [".github/workflows/tests.yml", "appveyor.yml"]}, {"commit_id": "691b9c8b20470e8ad08d50aace8e69719a19b2f8", "commit_date": "Sat Apr 22 11:28:32 2023 +0100", "commit_message": "Merge pull request #656 from vidartf/nb6", "files_name": ["2c7197e76f5c7e3aadac8ade4ee25a13b5e46722 - Sat Apr 22 13:41:21 2023 +0100 : Start including package-lock file", ".gitignore", "package-lock.json"]}, {"commit_id": "47fdc17c5c5a845b7e4f2c7a40eba877c12bcffa", "commit_date": "Sat Apr 22 13:46:35 2023 +0100", "commit_message": "Tweak publish command", "files_name": ["package.json"]}, {"commit_id": "2f4785009bf9956f5c22d091d79de3025daf4e01", "commit_date": "Sat Apr 22 13:47:04 2023 +0100", "commit_message": "Publish", "files_name": ["packages/labextension/package.json", "packages/nbdime/package.json"]}, {"commit_id": "c86ab97a53d4d1332e06c78a164661595d6dc1a7", "commit_date": "Sat Apr 22 14:34:58 2023 +0100", "commit_message": "Not needed after all", "files_name": ["package.json"]}, {"commit_id": "0993aaea25f190627277f7969089cb82e0b6b321", "commit_date": "Sat Apr 22 14:50:20 2023 +0100", "commit_message": "tweak jest setup", "files_name": ["packages/nbdime/test/jest-setup-files.js"]}, {"commit_id": "e85f3aa57f2b7d4579ccade1eb2fb24311011c96", "commit_date": "Sat Apr 22 14:58:17 2023 +0100", "commit_message": "Dependabot shouldn't care about dev deps", "files_name": [".github/dependabot.yml"]}, {"commit_id": "98cb5fd9296a05aa30a9450734c1bd5605a40a0f", "commit_date": "Sat Apr 22 15:32:04 2023 +0100", "commit_message": "Crypto pathc vs latest node (18.16.0)", "files_name": ["packages/nbdime/test/jest-setup-files.js"]}, {"commit_id": "90d0787bdd16f6403d508ab4f7c76b4473ba0326", "commit_date": "Sat Apr 22 15:49:04 2023 +0100", "commit_message": "Release 3.2.0", "files_name": ["nbdime/_version.py"]}, {"commit_id": "e7a828dd409d5cc98a38db3b5e33cc32c51a0f1f", "commit_date": "Sun Apr 23 00:58:03 2023 +0100", "commit_message": "back to dev", "files_name": ["nbdime/_version.py"]}, {"commit_id": "53e1a9ffa420038aee19bc7b76d3f907da6f5c9e", "commit_date": "Sun Apr 30 15:13:11 2023 +0100", "commit_message": "Correctly send exit code 0", "files_name": ["packages/webapp/src/app/common.ts"]}, {"commit_id": "b1804b19ab526b432f034af3ba8523e43195d575", "commit_date": "Sun Apr 30 16:20:56 2023 +0100", "commit_message": "Merge pull request #666 from vidartf/fix-exit-code", "files_name": ["d618ced5e4e5280f1d8df9f178e45ee32e8ec702 - Sun Apr 30 16:34:25 2023 +0100 : Patch version updates for deps", "package-lock.json"]}, {"commit_id": "5377e9a3fb89b50f8fa21a553b4e8aece39ddb26", "commit_date": "Sun Apr 30 16:34:56 2023 +0100", "commit_message": "Release 3.2.1", "files_name": ["docs/source/changelog.md", "nbdime/_version.py"]}, {"commit_id": "1b368a884405914e9b1861a445c20927f7c88a5b", "commit_date": "Sun Apr 30 16:45:30 2023 +0100", "commit_message": "back to dev", "files_name": ["nbdime/_version.py"]}, {"commit_id": "e21a723db57075cf16620e9c705a77f1e4c26e26", "commit_date": "Fri May 5 22:12:16 2023 +0200", "commit_message": "Add .prettierrc and .prettierignore files and add prettier scripts in package.json file.", "files_name": [".prettierignore", ".prettierrc", "package.json"]}, {"commit_id": "9eeb4671dd2ce61c0a54f4be196ff2b986573aba", "commit_date": "Fri May 12 00:36:17 2023 +0200", "commit_message": "Update the .ts, .js, .json, .css and .md files with prettier formatting.", "files_name": ["LICENSE.md", "lerna.json", "nbdime/diff_format.schema.json", "nbdime/merge_format.schema.json", "nbdime/notebook_ext/index.js"]}], "parents": [{"commit_id_before": "f16d4488a72707ce2d6738526d8b06622cf7617f", "url_before": "https://api.github.com/repos/jupyter/nbdime/commits/f16d4488a72707ce2d6738526d8b06622cf7617f", "html_url_before": "https://github.com/jupyter/nbdime/commit/f16d4488a72707ce2d6738526d8b06622cf7617f"}, {"commit_id_before": "19fded3bb9ac3405d1efa4d34b9b45d3e261dcc0", "url_before": "https://api.github.com/repos/jupyter/nbdime/commits/19fded3bb9ac3405d1efa4d34b9b45d3e261dcc0", "html_url_before": "https://github.com/jupyter/nbdime/commit/19fded3bb9ac3405d1efa4d34b9b45d3e261dcc0"}], "details": [{"raw_url": "https://github.com/jupyter/nbdime/raw/e44a5cc7677f24b45ebafc756db49058c2f750ea/packages%2Flabextension%2Fsrc%2Fwidget.ts", "code": "\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  IRenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  ServerConnection\n} from '@jupyterlab/services';\n\nimport {\n  JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget, Panel\n} from '@lumino/widgets';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget, CELLDIFF_CLASS\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  UNCHANGED_DIFF_CLASS, CHUNK_PANEL_CLASS\n} from 'nbdime/lib/diff/widget/common';\n\nimport {\n  requestApiJson\n} from 'nbdime/lib/request';\n\n\n\n/**\n * Class of the outermost widget, the draggable tab\n */\nconst NBDIME_CLASS = 'nbdime-Widget'\n\n/**\n * Class of the root of the actual diff, the scroller element\n */\nconst ROOT_CLASS = 'nbdime-root'\n\n/**\n * DOM class for whether or not to hide unchanged cells\n */\nconst HIDE_UNCHANGED_CLASS = 'jp-mod-hideUnchanged';\n\n\nexport\nclass NbdimeWidget extends Panel {\n  /**\n   *\n   */\n  constructor(options: NbdimeWidget.IOptions) {\n    super();\n\n    this.addClass(NBDIME_CLASS);\n\n    this.base = options.base;\n    this.remote = options.remote;\n    this.rendermime = options.rendermime;\n\n    let header = Private.diffHeader(options);\n    this.addWidget(header);\n\n    this.scroller = new Panel();\n    this.scroller.addClass(ROOT_CLASS);\n    this.scroller.node.tabIndex = -1;\n    this.addWidget(this.scroller);\n\n    let hideUnchangedChk = header.node.getElementsByClassName('nbdime-hide-unchanged')[0] as HTMLInputElement;\n    hideUnchangedChk.checked = options.hideUnchanged === undefined\n      ? true : options.hideUnchanged;\n    hideUnchangedChk.onchange = () => {\n      Private.toggleShowUnchanged(this.scroller, !hideUnchangedChk.checked);\n    };\n    if (options.hideUnchanged) {\n      Private.toggleShowUnchanged(this.scroller, false);\n    }\n\n    let args: JSONObject;\n    if (this.remote) {\n      args = {base: this.base, remote: this.remote};\n    } else if (options.baseLabel === 'Checkpoint') {\n      args = {base: `checkpoint:${this.base}`}\n    } else {\n      args = {base: `git:${this.base}`}\n    }\n\n    requestApiJson(\n      ServerConnection.makeSettings().baseUrl,\n      'nbdime/api/diff',\n      args,\n      this.onData.bind(this),\n      this.onError.bind(this));\n    this.id = `nbdime-${JSON.stringify(args)}`;\n    this.title.closable = true;\n    return this;\n  }\n\n  dispose(): void {\n    super.dispose();\n    this.rendermime = null!;\n    this.header = null!;\n    this.scroller = null!;\n  }\n\n  /**\n   * Handle `'activate-request'` messages.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.scroller.node.focus();\n  }\n\n\n  protected onData(data: JSONObject) {\n    if (this.isDisposed) {\n      return;\n    }\n    let base = data['base'] as nbformat.INotebookContent;\n    let diff = data['diff'] as any as IDiffEntry[];\n    let nbdModel = new NotebookDiffModel(base, diff);\n    let nbdWidget = new NotebookDiffWidget(nbdModel, this.rendermime);\n\n    this.scroller.addWidget(nbdWidget);\n    let work = nbdWidget.init();\n    work.then(() => {\n      Private.markUnchangedRanges(this.scroller.node);\n    })\n    return work;\n  }\n\n  protected onError(error: ServerConnection.NetworkError | ServerConnection.ResponseError): void {\n    if (this.isDisposed) {\n      return;\n    }\n    let widget = new Widget();\n    widget.node.innerHTML = `Failed to fetch diff: ${error.message}`;\n    this.scroller.addWidget(widget);\n  }\n\n  readonly base: string;\n  readonly remote: string | undefined;\n\n  protected rendermime: IRenderMimeRegistry;\n\n  protected header: Widget;\n  protected scroller: Panel;\n}\n\n\nexport\nnamespace NbdimeWidget {\n\n  export\n  interface IOptions {\n    /**\n     * The base notebook path.\n     */\n    base: string,\n\n    /**\n     * The remote notebook path. If undefined, base will be diffed against git HEAD.\n     */\n    remote?: string,\n\n    /**\n     * A rendermime instance to use to render markdown/outputs.\n     */\n    rendermime: IRenderMimeRegistry,\n\n    /**\n     * If specified this will be use to represent the base file in the view.\n     *\n     * Defaults to the value of `base`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    baseLabel?: string,\n\n    /**\n     * If specified this will be use to represent the remote file in the view.\n     *\n     * Defaults to the value of `remote`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    remoteLabel?: string,\n\n    /**\n     * Whether to hide unchanged cells by default.\n     */\n    hideUnchanged?: boolean,\n  }\n}\n\n\nnamespace Private {\n\n  /**\n   * Create a header widget for the diff view.\n   */\n  export\n  function diffHeader(options: NbdimeWidget.IOptions): Widget {\n    let {base, remote, baseLabel, remoteLabel} = options;\n    if (remote) {\n      if (baseLabel === undefined) {\n        baseLabel = base;\n      }\n      if (remoteLabel === undefined) {\n        remoteLabel = remote;\n      }\n    } else {\n      if (!baseLabel) {\n        baseLabel = 'git HEAD';\n      }\n      remoteLabel = base;\n    }\n\n    let node = document.createElement('div');\n    node.className = 'nbdime-Diff';\n    node.innerHTML = `\n      <div class=\"nbdime-header-buttonrow\">\n        <label><input class=\"nbdime-hide-unchanged\" type=\"checkbox\">Hide unchanged cells</label>\n        <button class=\"nbdime-export\" style=\"display: none\">Export diff</button>\n      </div>\n      <div class=nbdime-header-banner>\n        <span class=\"nbdime-header-base\"></span>\n        <span class=\"nbdime-header-remote\"></span>\n      </div>`;\n    (node.getElementsByClassName(\"nbdime-header-base\")[0] as HTMLSpanElement).innerText = baseLabel;\n    (node.getElementsByClassName(\"nbdime-header-remote\")[0] as HTMLSpanElement).innerText = remoteLabel;\n\n    return new Widget({node});\n  }\n\n  /**\n   * Toggle whether to show or hide unchanged cells.\n   *\n   * This simply marks with a class, real work is done by CSS.\n   */\n  export\n  function toggleShowUnchanged(root: Widget, show?: boolean) {\n    let hiding = root.hasClass(HIDE_UNCHANGED_CLASS);\n    if (show === undefined) {\n      show = hiding;\n    } else if (hiding !== show) {\n      // Nothing to do\n      return;\n    }\n    if (show) {\n      root.removeClass(HIDE_UNCHANGED_CLASS);\n    } else {\n      markUnchangedRanges(root.node);\n      root.addClass(HIDE_UNCHANGED_CLASS);\n    }\n    root.update();\n  }\n\n\n  /**\n   * Gets the chunk element of an added/removed cell, or the cell element for others\n   * @param cellElement\n   */\n  function getChunkElement(cellElement: Element): Element {\n    if (!cellElement.parentElement || !cellElement.parentElement.parentElement) {\n      return cellElement;\n    }\n    let chunkCandidate = cellElement.parentElement.parentElement;\n    if (chunkCandidate.classList.contains(CHUNK_PANEL_CLASS)) {\n      return chunkCandidate;\n    }\n    return cellElement;\n  }\n\n\n  /**\n   * Marks certain cells with\n   */\n  export\n  function markUnchangedRanges(root: HTMLElement) {\n    let children = root.querySelectorAll(`.${CELLDIFF_CLASS}`);\n    let rangeStart = -1;\n    for (let i=0; i < children.length; ++i) {\n      let child = children[i];\n      if (!child.classList.contains(UNCHANGED_DIFF_CLASS)) {\n        // Visible\n        if (rangeStart !== -1) {\n          // Previous was hidden\n          let N = i - rangeStart;\n          getChunkElement(child).setAttribute('data-nbdime-NCellsHiddenBefore', N.toString());\n          rangeStart = -1;\n        }\n      } else if (rangeStart === -1) {\n        rangeStart = i;\n      }\n    }\n    if (rangeStart !== -1) {\n      // Last element was part of a hidden range, need to mark\n      // the last cell that will be visible.\n      let N = children.length - rangeStart;\n      if (rangeStart === 0) {\n        // All elements were hidden, nothing to mark\n        // Add info on root instead\n        let tag = root.querySelector('.jp-Notebook-diff') || root;\n        tag.setAttribute('data-nbdime-AllCellsHidden', N.toString());\n        return;\n      }\n      let lastVisible = children[rangeStart - 1];\n      getChunkElement(lastVisible).setAttribute('data-nbdime-NCellsHiddenAfter', N.toString());\n    }\n  }\n}\n", "code_before": "\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  IRenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  ServerConnection\n} from '@jupyterlab/services';\n\nimport {\n  JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget, Panel\n} from '@lumino/widgets';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget, CELLDIFF_CLASS\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  UNCHANGED_DIFF_CLASS, CHUNK_PANEL_CLASS\n} from 'nbdime/lib/diff/widget/common';\n\nimport {\n  requestApiJson\n} from 'nbdime/lib/request';\n\n\n\n/**\n * Class of the outermost widget, the draggable tab\n */\nconst NBDIME_CLASS = 'nbdime-Widget'\n\n/**\n * Class of the root of the actual diff, the scroller element\n */\nconst ROOT_CLASS = 'nbdime-root'\n\n/**\n * DOM class for whether or not to hide unchanged cells\n */\nconst HIDE_UNCHANGED_CLASS = 'jp-mod-hideUnchanged';\n\n\nexport\nclass NbdimeWidget extends Panel {\n  /**\n   *\n   */\n  constructor(options: NbdimeWidget.IOptions) {\n    super();\n\n    this.addClass(NBDIME_CLASS);\n\n    this.base = options.base;\n    this.remote = options.remote;\n    this.rendermime = options.rendermime;\n\n    let header = Private.diffHeader(options);\n    this.addWidget(header);\n\n    this.scroller = new Panel();\n    this.scroller.addClass(ROOT_CLASS);\n    this.scroller.node.tabIndex = -1;\n    this.addWidget(this.scroller);\n\n    let hideUnchangedChk = header.node.getElementsByClassName('nbdime-hide-unchanged')[0] as HTMLInputElement;\n    hideUnchangedChk.checked = options.hideUnchanged === undefined\n      ? true : options.hideUnchanged;\n    hideUnchangedChk.onchange = () => {\n      Private.toggleShowUnchanged(this.scroller, !hideUnchangedChk.checked);\n    };\n    if (options.hideUnchanged) {\n      Private.toggleShowUnchanged(this.scroller, false);\n    }\n\n    let args: JSONObject;\n    if (this.remote) {\n      args = {base: this.base, remote: this.remote};\n    } else if (options.baseLabel === 'Checkpoint') {\n      args = {base: `checkpoint:${this.base}`}\n    } else {\n      args = {base: `git:${this.base}`}\n    }\n\n    requestApiJson(\n      ServerConnection.makeSettings().baseUrl,\n      'nbdime/api/diff',\n      args,\n      this.onData.bind(this),\n      this.onError.bind(this));\n    this.id = `nbdime-${JSON.stringify(args)}`;\n    this.title.closable = true;\n    return this;\n  }\n\n  dispose(): void {\n    super.dispose();\n    this.rendermime = null!;\n    this.header = null!;\n    this.scroller = null!;\n  }\n\n  /**\n   * Handle `'activate-request'` messages.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.scroller.node.focus();\n  }\n\n\n  protected onData(data: JSONObject) {\n    if (this.isDisposed) {\n      return;\n    }\n    let base = data['base'] as nbformat.INotebookContent;\n    let diff = data['diff'] as any as IDiffEntry[];\n    let nbdModel = new NotebookDiffModel(base, diff);\n    let nbdWidget = new NotebookDiffWidget(nbdModel, this.rendermime);\n\n    this.scroller.addWidget(nbdWidget);\n    let work = nbdWidget.init();\n    work.then(() => {\n      Private.markUnchangedRanges(this.scroller.node);\n    })\n    return work;\n  }\n\n  protected onError(error: ServerConnection.NetworkError | ServerConnection.ResponseError): void {\n    if (this.isDisposed) {\n      return;\n    }\n    let widget = new Widget();\n    widget.node.innerHTML = `Failed to fetch diff: ${error.message}`;\n    this.scroller.addWidget(widget);\n  }\n\n  readonly base: string;\n  readonly remote: string | undefined;\n\n  protected rendermime: IRenderMimeRegistry;\n\n  protected header: Widget;\n  protected scroller: Panel;\n}\n\n\nexport\nnamespace NbdimeWidget {\n\n  export\n  interface IOptions {\n    /**\n     * The base notebook path.\n     */\n    base: string,\n\n    /**\n     * The remote notebook path. If undefined, base will be diffed against git HEAD.\n     */\n    remote?: string,\n\n    /**\n     * A rendermime instance to use to render markdown/outputs.\n     */\n    rendermime: IRenderMimeRegistry,\n\n    /**\n     * If specified this will be use to represent the base file in the view.\n     *\n     * Defaults to the value of `base`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    baseLabel?: string,\n\n    /**\n     * If specified this will be use to represent the remote file in the view.\n     *\n     * Defaults to the value of `remote`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    remoteLabel?: string,\n\n    /**\n     * Whether to hide unchanged cells by default.\n     */\n    hideUnchanged?: boolean,\n  }\n}\n\n\nnamespace Private {\n\n  /**\n   * Create a header widget for the diff view.\n   */\n  export\n  function diffHeader(options: NbdimeWidget.IOptions): Widget {\n    let {base, remote, baseLabel, remoteLabel} = options;\n    if (remote) {\n      if (baseLabel === undefined) {\n        baseLabel = base;\n      }\n      if (remoteLabel === undefined) {\n        remoteLabel = remote;\n      }\n    } else {\n      if (!baseLabel) {\n        baseLabel = 'git HEAD';\n      }\n      remoteLabel = base;\n    }\n\n    let node = document.createElement('div');\n    node.className = 'nbdime-Diff';\n    node.innerHTML = `\n      <div class=\"nbdime-header-buttonrow\">\n        <label><input class=\"nbdime-hide-unchanged\" type=\"checkbox\">Hide unchanged cells</label>\n        <button class=\"nbdime-export\" style=\"display: none\">Export diff</button>\n      </div>\n      <div class=nbdime-header-banner>\n        <span class=\"nbdime-header-base\"></span>\n        <span class=\"nbdime-header-remote\"></span>\n      </div>`;\n    (node.getElementsByClassName(\"nbdime-header-base\")[0] as HTMLSpanElement).innerText = baseLabel;\n    (node.getElementsByClassName(\"nbdime-header-remote\")[0] as HTMLSpanElement).innerText = remoteLabel;\n\n    return new Widget({node});\n  }\n\n  /**\n   * Toggle whether to show or hide unchanged cells.\n   *\n   * This simply marks with a class, real work is done by CSS.\n   */\n  export\n  function toggleShowUnchanged(root: Widget, show?: boolean) {\n    let hiding = root.hasClass(HIDE_UNCHANGED_CLASS);\n    if (show === undefined) {\n      show = hiding;\n    } else if (hiding !== show) {\n      // Nothing to do\n      return;\n    }\n    if (show) {\n      root.removeClass(HIDE_UNCHANGED_CLASS);\n    } else {\n      markUnchangedRanges(root.node);\n      root.addClass(HIDE_UNCHANGED_CLASS);\n    }\n    root.update();\n  }\n\n\n  /**\n   * Gets the chunk element of an added/removed cell, or the cell element for others\n   * @param cellElement\n   */\n  function getChunkElement(cellElement: Element): Element {\n    if (!cellElement.parentElement || !cellElement.parentElement.parentElement) {\n      return cellElement;\n    }\n    let chunkCandidate = cellElement.parentElement.parentElement;\n    if (chunkCandidate.classList.contains(CHUNK_PANEL_CLASS)) {\n      return chunkCandidate;\n    }\n    return cellElement;\n  }\n\n\n  /**\n   * Marks certain cells with\n   */\n  export\n  function markUnchangedRanges(root: HTMLElement) {\n    let children = root.querySelectorAll(`.${CELLDIFF_CLASS}`);\n    let rangeStart = -1;\n    for (let i=0; i < children.length; ++i) {\n      let child = children[i];\n      if (!child.classList.contains(UNCHANGED_DIFF_CLASS)) {\n        // Visible\n        if (rangeStart !== -1) {\n          // Previous was hidden\n          let N = i - rangeStart;\n          getChunkElement(child).setAttribute('data-nbdime-NCellsHiddenBefore', N.toString());\n          rangeStart = -1;\n        }\n      } else if (rangeStart === -1) {\n        rangeStart = i;\n      }\n    }\n    if (rangeStart !== -1) {\n      // Last element was part of a hidden range, need to mark\n      // the last cell that will be visible.\n      let N = children.length - rangeStart;\n      if (rangeStart === 0) {\n        // All elements were hidden, nothing to mark\n        // Add info on root instead\n        let tag = root.querySelector('.jp-Notebook-diff') || root;\n        tag.setAttribute('data-nbdime-AllCellsHidden', N.toString());\n        return;\n      }\n      let lastVisible = children[rangeStart - 1];\n      getChunkElement(lastVisible).setAttribute('data-nbdime-NCellsHiddenAfter', N.toString());\n    }\n  }\n}\n", "patch": "@@ -239,9 +239,11 @@ namespace Private {\n         <button class=\"nbdime-export\" style=\"display: none\">Export diff</button>\n       </div>\n       <div class=nbdime-header-banner>\n-        <span class=\"nbdime-header-base\">${baseLabel}</span>\n-        <span class=\"nbdime-header-remote\">${remoteLabel}</span>\n+        <span class=\"nbdime-header-base\"></span>\n+        <span class=\"nbdime-header-remote\"></span>\n       </div>`;\n+    (node.getElementsByClassName(\"nbdime-header-base\")[0] as HTMLSpanElement).innerText = baseLabel;\n+    (node.getElementsByClassName(\"nbdime-header-remote\")[0] as HTMLSpanElement).innerText = remoteLabel;\n \n     return new Widget({node});\n   }", "file_path": "files/2021_11/569", "file_language": "ts", "file_name": "packages/labextension/src/widget.ts", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/jupyter/nbdime/raw/e44a5cc7677f24b45ebafc756db49058c2f750ea/packages%2Fnbdime%2Fsrc%2Fcommon%2Futil.ts", "code": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\nexport\ninterface DeepCopyableObject {\n  [key: string]: any | undefined;\n  prototype?: DeepCopyableObject;\n}\n\nexport\ntype DeepCopyableValue = DeepCopyableObject | DeepCopyableObject[] | string | number | boolean | null;\n\n/**\n * Check whether a value is in an array.\n */\nexport\nfunction valueIn(value: any, array: Array<any>) {\n  return array.indexOf(value) >= 0;\n}\n\n\n/**\n * Check whether array is null or empty, and type guards agains null\n */\nexport\nfunction hasEntries<T>(array: T[] | null): array is T[] {\n  return array !== null && array.length !== 0;\n}\n\n\n/**\n * Splits a multinline string into an array of lines\n *\n * @export\n * @param {string} multiline\n * @returns {string[]}\n */\nexport\nfunction splitLines(multiline: string): string[] {\n  // Split lines (retaining newlines)\n  // We use !postfix, as we also match empty string,\n  // so we are guaranteed to get at elast one match\n  return multiline.match(/^.*(\\r\\n|\\r|\\n|$)/gm)!;\n}\n\n/**\n * Deepcopy routine for JSON-able data types\n */\nexport function deepCopy(obj: null): null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T): T;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null {\n  if (typeof obj !== 'object') {\n    if (valueIn(typeof obj, ['string', 'number', 'boolean'])) {\n      return obj;\n    }\n    throw new TypeError('Cannot deepcopy non-object');\n  }\n  if (obj === null) {\n    return null;\n  } else if (Array.isArray(obj)) {\n    let l = obj.length;\n    let o = new Array(l);\n    for (let i = 0; i < l; i++) {\n      o[i] = deepCopy(obj[i]);\n    }\n    return o as T;\n  } else {\n    let a = obj as DeepCopyableObject;\n    let r: DeepCopyableObject = {};\n    if (a.prototype !== undefined) {\n      r.prototype = a.prototype;\n    }\n    for (let k in obj) {\n      r[k] = deepCopy(a[k]);\n    }\n    return r as T;\n  }\n}\n\n/**\n * Shallow copy routine for objects\n */\nexport\nfunction shallowCopy< T extends { [key: string]: any } >(original: T): T {\n  // First create an empty object with\n  // same prototype of our original source\n  let clone = Object.create(Object.getPrototypeOf(original));\n\n  for (let k in original) {\n    // Don't copy function\n    let ok = original[k];\n    if (ok !== null && ok !== undefined &&\n        ok.hasOwnProperty('constructor') &&\n        ok.constructor === Function) {\n      continue;\n    }\n    let pDesc = Object.getOwnPropertyDescriptor(original, k);\n    // Don't copy properties with getter\n    if (!pDesc || pDesc.get) {\n      continue;\n    }\n    // copy each property into the clone\n    Object.defineProperty(clone, k, pDesc);\n  }\n  return clone;\n}\n\n/**\n * Do a shallow, element-wise equality comparison on two arrays.\n */\nexport\nfunction arraysEqual(a: any[] | null, b: any[] | null) {\n  if (a === b) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Find the shared common starting sequence in two arrays\n */\nexport\nfunction findSharedPrefix(a: any[] | null, b: any[] | null): any[] | null {\n  if (a === null || b === null) {\n    return null;\n  }\n  if (a === b) {  // Only checking for instance equality\n    return a.slice();\n  }\n  let i = 0;\n  for (; i < Math.min(a.length, b.length); ++i) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n  return a.slice(0, i);\n}\n\n/**\n * Check whether `parent` is contained within the start of `child`\n *\n * Note on terminology: Parent is here the shortest array, as it will\n * be the parent in a tree-view of values, e.g. a path. In other words, parent\n * is a subsequence of child.\n */\nexport\nfunction isPrefixArray(parent: any[] | null, child: any[] | null): boolean {\n  if (parent === child) {\n    return true;\n  }\n  if (parent === null || parent.length === 0) {\n    return true;\n  }\n  if (child === null || parent.length > child.length) {\n    return false;\n  }\n  for (let i = 0; i < parent.length; ++i) {\n    if (parent[i] !== child[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort array by attribute `key` (i.e. compare by array[0][key] < array[1][key]). Stable.\n */\nexport\nfunction sortByKey<T extends {[key: string]: any}>(array: T[], key: string): T[] {\n    return stableSort(array, function(a, b) {\n        let x = a[key]; let y = b[key];\n        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n    });\n}\n\n\n/**\n * Utility function to repeat a string\n */\nexport\nfunction repeatString(str: string, count: number): string {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  let pattern = str.valueOf();\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1, pattern += pattern;\n  }\n  return result + pattern;\n}\n\n/**\n * Calculate the cumulative sum of string lengths for an array of strings\n *\n * Example:\n *   For the arary ['ab', '123', 'y', '\\t\\nfoo'], the output would be\n *   [2, 5, 6, 11]\n */\nexport\nfunction accumulateLengths(arr: string[]) {\n  let ret: number[] = [];\n  arr.reduce<number>(function(a: number, b: string, i: number): number {\n    return ret[i] = a + b.length;\n  }, 0);\n  return ret;\n}\n\n/**\n * Filter for Array.filter to only have unique values\n */\nexport\nfunction unique<T>(value: T, index: number, self: T[]): boolean {\n  return self.indexOf(value) === index;\n}\n\n/**\n * Return the intersection of two arrays (with no duplicates)\n */\nexport\nfunction intersection<T>(a: T[], b: T[]): T[] {\n  let ret: T[] = [];\n  // Loop over longest, so that indexOf works on shortest\n  [a, b] = a.length > b.length ? [a, b] : [b, a];\n  for (let ia of a) {\n    if (b.indexOf(ia) !== -1) {\n      ret.push(ia);\n    }\n  }\n  return ret;\n}\n\n\n/**\n * Similar to Array.sort, but guaranteed to keep order stable\n * when compare function returns 0\n */\nexport\nfunction stableSort<T>(arr: T[], compare: (a: T, b: T) => number): T[] {\n  let sorters: {index: number, key: T}[] = [];\n  for (let i=0; i < arr.length; ++i) {\n    sorters.push({index: i, key: arr[i]});\n  }\n  sorters = sorters.sort((a: {index: number, key: T}, b: {index: number, key: T}): number => {\n    return compare(a.key, b.key) || a.index - b.index;\n  });\n  let out: T[] = new Array<T>(arr.length);\n  for (let i=0; i < arr.length; ++i) {\n    out[i] = arr[sorters[i].index];\n  }\n  return out;\n}\n\n\n/**\n * Copy an object, possibly extending it in the process\n */\nexport function copyObj<T extends {[key: string]: any}>(obj: T): T;\nexport function copyObj<T extends {[key: string]: any}, U extends {[key: string]: any}>\n(obj: T, target?: U): T & U;\nexport function copyObj(obj: {[key: string]: any}, target?: {[key: string]: any}): any {\n  if (!target) {\n    target = {};\n  }\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      target[prop] = obj[prop];\n    }\n  }\n  return target;\n}\n\n\n/**\n * Create or populate a select element with string options\n */\nexport\nfunction buildSelect(options: string[], select?: HTMLSelectElement): HTMLSelectElement {\n  if (select === undefined) {\n    select = document.createElement('select');\n  }\n  for (let option of options) {\n    let opt = document.createElement('option');\n    opt.text = option;\n    select.appendChild(opt);\n  }\n  return select;\n}\n", "code_before": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\nexport\ninterface DeepCopyableObject {\n  [key: string]: any | undefined;\n  prototype?: DeepCopyableObject;\n}\n\nexport\ntype DeepCopyableValue = DeepCopyableObject | DeepCopyableObject[] | string | number | boolean | null;\n\n/**\n * Check whether a value is in an array.\n */\nexport\nfunction valueIn(value: any, array: Array<any>) {\n  return array.indexOf(value) >= 0;\n}\n\n\n/**\n * Check whether array is null or empty, and type guards agains null\n */\nexport\nfunction hasEntries<T>(array: T[] | null): array is T[] {\n  return array !== null && array.length !== 0;\n}\n\n\n/**\n * Splits a multinline string into an array of lines\n *\n * @export\n * @param {string} multiline\n * @returns {string[]}\n */\nexport\nfunction splitLines(multiline: string): string[] {\n  // Split lines (retaining newlines)\n  // We use !postfix, as we also match empty string,\n  // so we are guaranteed to get at elast one match\n  return multiline.match(/^.*(\\r\\n|\\r|\\n|$)/gm)!;\n}\n\n/**\n * Deepcopy routine for JSON-able data types\n */\nexport function deepCopy(obj: null): null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T): T;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null {\n  if (typeof obj !== 'object') {\n    if (valueIn(typeof obj, ['string', 'number', 'boolean'])) {\n      return obj;\n    }\n    throw new TypeError('Cannot deepcopy non-object');\n  }\n  if (obj === null) {\n    return null;\n  } else if (Array.isArray(obj)) {\n    let l = obj.length;\n    let o = new Array(l);\n    for (let i = 0; i < l; i++) {\n      o[i] = deepCopy(obj[i]);\n    }\n    return o as T;\n  } else {\n    let a = obj as DeepCopyableObject;\n    let r: DeepCopyableObject = {};\n    if (a.prototype !== undefined) {\n      r.prototype = a.prototype;\n    }\n    for (let k in obj) {\n      r[k] = deepCopy(a[k]);\n    }\n    return r as T;\n  }\n}\n\n/**\n * Shallow copy routine for objects\n */\nexport\nfunction shallowCopy< T extends { [key: string]: any } >(original: T): T {\n  // First create an empty object with\n  // same prototype of our original source\n  let clone = Object.create(Object.getPrototypeOf(original));\n\n  for (let k in original) {\n    // Don't copy function\n    let ok = original[k];\n    if (ok !== null && ok !== undefined &&\n        ok.hasOwnProperty('constructor') &&\n        ok.constructor === Function) {\n      continue;\n    }\n    let pDesc = Object.getOwnPropertyDescriptor(original, k);\n    // Don't copy properties with getter\n    if (!pDesc || pDesc.get) {\n      continue;\n    }\n    // copy each property into the clone\n    Object.defineProperty(clone, k, pDesc);\n  }\n  return clone;\n}\n\n/**\n * Do a shallow, element-wise equality comparison on two arrays.\n */\nexport\nfunction arraysEqual(a: any[] | null, b: any[] | null) {\n  if (a === b) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Find the shared common starting sequence in two arrays\n */\nexport\nfunction findSharedPrefix(a: any[] | null, b: any[] | null): any[] | null {\n  if (a === null || b === null) {\n    return null;\n  }\n  if (a === b) {  // Only checking for instance equality\n    return a.slice();\n  }\n  let i = 0;\n  for (; i < Math.min(a.length, b.length); ++i) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n  return a.slice(0, i);\n}\n\n/**\n * Check whether `parent` is contained within the start of `child`\n *\n * Note on terminology: Parent is here the shortest array, as it will\n * be the parent in a tree-view of values, e.g. a path. In other words, parent\n * is a subsequence of child.\n */\nexport\nfunction isPrefixArray(parent: any[] | null, child: any[] | null): boolean {\n  if (parent === child) {\n    return true;\n  }\n  if (parent === null || parent.length === 0) {\n    return true;\n  }\n  if (child === null || parent.length > child.length) {\n    return false;\n  }\n  for (let i = 0; i < parent.length; ++i) {\n    if (parent[i] !== child[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort array by attribute `key` (i.e. compare by array[0][key] < array[1][key]). Stable.\n */\nexport\nfunction sortByKey<T extends {[key: string]: any}>(array: T[], key: string): T[] {\n    return stableSort(array, function(a, b) {\n        let x = a[key]; let y = b[key];\n        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n    });\n}\n\n\n/**\n * Utility function to repeat a string\n */\nexport\nfunction repeatString(str: string, count: number): string {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  let pattern = str.valueOf();\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1, pattern += pattern;\n  }\n  return result + pattern;\n}\n\n/**\n * Calculate the cumulative sum of string lengths for an array of strings\n *\n * Example:\n *   For the arary ['ab', '123', 'y', '\\t\\nfoo'], the output would be\n *   [2, 5, 6, 11]\n */\nexport\nfunction accumulateLengths(arr: string[]) {\n  let ret: number[] = [];\n  arr.reduce<number>(function(a: number, b: string, i: number): number {\n    return ret[i] = a + b.length;\n  }, 0);\n  return ret;\n}\n\n/**\n * Filter for Array.filter to only have unique values\n */\nexport\nfunction unique<T>(value: T, index: number, self: T[]): boolean {\n  return self.indexOf(value) === index;\n}\n\n/**\n * Return the intersection of two arrays (with no duplicates)\n */\nexport\nfunction intersection<T>(a: T[], b: T[]): T[] {\n  let ret: T[] = [];\n  // Loop over longest, so that indexOf works on shortest\n  [a, b] = a.length > b.length ? [a, b] : [b, a];\n  for (let ia of a) {\n    if (b.indexOf(ia) !== -1) {\n      ret.push(ia);\n    }\n  }\n  return ret;\n}\n\n\n/**\n * Similar to Array.sort, but guaranteed to keep order stable\n * when compare function returns 0\n */\nexport\nfunction stableSort<T>(arr: T[], compare: (a: T, b: T) => number): T[] {\n  let sorters: {index: number, key: T}[] = [];\n  for (let i=0; i < arr.length; ++i) {\n    sorters.push({index: i, key: arr[i]});\n  }\n  sorters = sorters.sort((a: {index: number, key: T}, b: {index: number, key: T}): number => {\n    return compare(a.key, b.key) || a.index - b.index;\n  });\n  let out: T[] = new Array<T>(arr.length);\n  for (let i=0; i < arr.length; ++i) {\n    out[i] = arr[sorters[i].index];\n  }\n  return out;\n}\n\n\n/**\n * Copy an object, possibly extending it in the process\n */\nexport function copyObj<T extends {[key: string]: any}>(obj: T): T;\nexport function copyObj<T extends {[key: string]: any}, U extends {[key: string]: any}>\n(obj: T, target?: U): T & U;\nexport function copyObj(obj: {[key: string]: any}, target?: {[key: string]: any}): any {\n  if (!target) {\n    target = {};\n  }\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      target[prop] = obj[prop];\n    }\n  }\n  return target;\n}\n\n\n/**\n * Create or populate a select element with string options\n */\nexport\nfunction buildSelect(options: string[], select?: HTMLSelectElement): HTMLSelectElement {\n  if (select === undefined) {\n    select = document.createElement('select');\n  }\n  for (let option of options) {\n    let opt = document.createElement('option');\n    opt.text = option;\n    select.appendChild(opt);\n  }\n  return select;\n}\n", "patch": "@@ -298,7 +298,7 @@ function buildSelect(options: string[], select?: HTMLSelectElement): HTMLSelectE\n   }\n   for (let option of options) {\n     let opt = document.createElement('option');\n-    opt.value = opt.innerHTML = option;\n+    opt.text = option;\n     select.appendChild(opt);\n   }\n   return select;", "file_path": "files/2021_11/570", "file_language": "ts", "file_name": "packages/nbdime/src/common/util.ts", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/jupyter/nbdime/raw/e44a5cc7677f24b45ebafc756db49058c2f750ea/packages%2Fnbdime%2Ftest%2Fsrc%2Fcommon%2Futil.spec.ts", "code": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport * as util from '../../../src/common/util';\n\ndescribe('common', () => {\n\n  describe('util', () => {\n\n    describe('arraysEqual', () => {\n\n      it('should return true for instance equality', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for shallow equality', () => {\n        let arrays = [[1, 2, 3],\n                      ['a', 'b', 'c'],\n                      [123, 'text', true]];\n        for (let a of arrays) {\n          let value = util.arraysEqual(a, a.slice());\n          expect(value).toBe(true);\n        }\n      });\n\n      it('should return true for both null', () => {\n        let value = util.arraysEqual(null, null);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for one null input', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(null, a);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual(a, null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for different length arrays', () => {\n        let value = util.arraysEqual([1, 2, 3], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual([1, 2], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for deep comparison', () => {\n        let value = util.arraysEqual([{a: 1, b: 2}], [{a: 1, b: 2}]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('findSharedPrefix', () => {\n\n      it('should return a copy on identical input', () => {\n        let a = [1, 2, 3];\n        let value = util.findSharedPrefix(a, a);\n        expect(value).toEqual(a);\n        expect(value).not.toBe(a);  // Checking for instance equality\n      });\n\n      it('should return null for null inputs', () => {\n        let value = util.findSharedPrefix(null, null);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix(null, [1, 2]);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix([1, 2], null);\n        expect(value).toBe(null);\n      });\n\n      it('should return empty array for one or more empy inputs', () => {\n        let value = util.findSharedPrefix([], []);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([], [1, 2]);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([1, 2], []);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for disjoint inputs', () => {\n        let value = util.findSharedPrefix([1, 2, 3], ['a', 'b', 'c']);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for inputs that overlap after start', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4], [5, 2, 3, 4]);\n        expect(value).toEqual([]);\n      });\n\n      it('should find prefix of single element arrays', () => {\n        let value = util.findSharedPrefix([1], [1]);\n        expect(value).toEqual([1]);\n\n        value = util.findSharedPrefix(['text'], ['text']);\n        expect(value).toEqual(['text']);\n      });\n\n      it('should find prefix of muliple element arrays that are equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3], [1, 2, 3]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc'], ['text', 'abc']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n      it('should find prefix of muliple element arrays that are not equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4, 5], [1, 2, 3, 6, 7]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc', 'foo'], ['text', 'abc', 'bar']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n    });\n\n    describe('isPrefixArray', () => {\n\n      it('should return true for object equality', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let value = util.isPrefixArray(null, null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(null, [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for empty parent', () => {\n        let value = util.isPrefixArray([], null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], []);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for null child, with non null/empty parent', () => {\n        let value = util.isPrefixArray([1], null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false if child is shorter than parent', () => {\n        let value = util.isPrefixArray([1], []);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true if child is equal to parent', () => {\n        let value = util.isPrefixArray([1], [1]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def', 0], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true if entire parent matches start of child', () => {\n        let value = util.isPrefixArray([1], [1, 2]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def'], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false if entire parent matches non-start of child', () => {\n        let value = util.isPrefixArray([2], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray(['def'], ['abc', 'def', 0]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('accumulateLengths', () => {\n\n      it('should handle an empty array', () => {\n        let value = util.accumulateLengths([]);\n        expect(value).toEqual([]);\n      });\n\n      it('should handle an single item array', () => {\n        let value = util.accumulateLengths(['abc']);\n        expect(value).toEqual([3]);\n      });\n\n      it('should handle multiple strings', () => {\n        let value = util.accumulateLengths(['abc', 'foo', '0xdead']);\n        expect(value).toEqual([3, 6, 12]);\n      });\n\n      it('should handle multiple strings with newlines at end', () => {\n        let value = util.accumulateLengths(['abc\\n', 'foo\\n', '0xdead\\n']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n      it('should handle multiple strings with newlines randomly placed', () => {\n        let value = util.accumulateLengths(['\\nabc', 'foo\\n', '0xde\\nad']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n    });\n\n    describe('hasEntries', () => {\n\n      it('should return false for null', () => {\n        let value = util.hasEntries(null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for empty array', () => {\n        let value = util.hasEntries([]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true for array with falsy entry', () => {\n        let value = util.hasEntries([0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for array with truthy entry', () => {\n        let value = util.hasEntries([4]);\n        expect(value).toBe(true);\n      });\n\n    });\n\n    describe('buildSelect', () => {\n\n      it('should create an empty select', () => {\n        let value = util.buildSelect([]);\n        expect(value.outerHTML).toEqual(\"<select></select>\");\n      });\n\n      it('should reuse a given select', () => {\n        const select = document.createElement('select');\n        let value = util.buildSelect([], select);\n        expect(value).toBe(select);\n      });\n\n      it('should create a select with options', () => {\n        let value = util.buildSelect([\n          'foo',\n          'bar',\n          '<div>boo</div>'\n        ]);\n        expect(value.outerHTML).toEqual(\n          '<select>' +\n            '<option>foo</option>' +\n            '<option>bar</option>' +\n            '<option>&lt;div&gt;boo&lt;/div&gt;</option>' +\n          '</select>'\n        );\n      });\n\n    });\n\n  });\n\n});\n", "code_before": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport * as util from '../../../src/common/util';\n\ndescribe('common', () => {\n\n  describe('util', () => {\n\n    describe('arraysEqual', () => {\n\n      it('should return true for instance equality', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for shallow equality', () => {\n        let arrays = [[1, 2, 3],\n                      ['a', 'b', 'c'],\n                      [123, 'text', true]];\n        for (let a of arrays) {\n          let value = util.arraysEqual(a, a.slice());\n          expect(value).toBe(true);\n        }\n      });\n\n      it('should return true for both null', () => {\n        let value = util.arraysEqual(null, null);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for one null input', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(null, a);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual(a, null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for different length arrays', () => {\n        let value = util.arraysEqual([1, 2, 3], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual([1, 2], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for deep comparison', () => {\n        let value = util.arraysEqual([{a: 1, b: 2}], [{a: 1, b: 2}]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('findSharedPrefix', () => {\n\n      it('should return a copy on identical input', () => {\n        let a = [1, 2, 3];\n        let value = util.findSharedPrefix(a, a);\n        expect(value).toEqual(a);\n        expect(value).not.toBe(a);  // Checking for instance equality\n      });\n\n      it('should return null for null inputs', () => {\n        let value = util.findSharedPrefix(null, null);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix(null, [1, 2]);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix([1, 2], null);\n        expect(value).toBe(null);\n      });\n\n      it('should return empty array for one or more empy inputs', () => {\n        let value = util.findSharedPrefix([], []);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([], [1, 2]);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([1, 2], []);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for disjoint inputs', () => {\n        let value = util.findSharedPrefix([1, 2, 3], ['a', 'b', 'c']);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for inputs that overlap after start', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4], [5, 2, 3, 4]);\n        expect(value).toEqual([]);\n      });\n\n      it('should find prefix of single element arrays', () => {\n        let value = util.findSharedPrefix([1], [1]);\n        expect(value).toEqual([1]);\n\n        value = util.findSharedPrefix(['text'], ['text']);\n        expect(value).toEqual(['text']);\n      });\n\n      it('should find prefix of muliple element arrays that are equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3], [1, 2, 3]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc'], ['text', 'abc']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n      it('should find prefix of muliple element arrays that are not equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4, 5], [1, 2, 3, 6, 7]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc', 'foo'], ['text', 'abc', 'bar']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n    });\n\n    describe('isPrefixArray', () => {\n\n      it('should return true for object equality', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let value = util.isPrefixArray(null, null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(null, [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for empty parent', () => {\n        let value = util.isPrefixArray([], null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], []);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for null child, with non null/empty parent', () => {\n        let value = util.isPrefixArray([1], null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false if child is shorter than parent', () => {\n        let value = util.isPrefixArray([1], []);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true if child is equal to parent', () => {\n        let value = util.isPrefixArray([1], [1]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def', 0], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true if entire parent matches start of child', () => {\n        let value = util.isPrefixArray([1], [1, 2]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def'], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false if entire parent matches non-start of child', () => {\n        let value = util.isPrefixArray([2], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray(['def'], ['abc', 'def', 0]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('accumulateLengths', () => {\n\n      it('should handle an empty array', () => {\n        let value = util.accumulateLengths([]);\n        expect(value).toEqual([]);\n      });\n\n      it('should handle an single item array', () => {\n        let value = util.accumulateLengths(['abc']);\n        expect(value).toEqual([3]);\n      });\n\n      it('should handle multiple strings', () => {\n        let value = util.accumulateLengths(['abc', 'foo', '0xdead']);\n        expect(value).toEqual([3, 6, 12]);\n      });\n\n      it('should handle multiple strings with newlines at end', () => {\n        let value = util.accumulateLengths(['abc\\n', 'foo\\n', '0xdead\\n']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n      it('should handle multiple strings with newlines randomly placed', () => {\n        let value = util.accumulateLengths(['\\nabc', 'foo\\n', '0xde\\nad']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n    });\n\n    describe('hasEntries', () => {\n\n      it('should return false for null', () => {\n        let value = util.hasEntries(null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for empty array', () => {\n        let value = util.hasEntries([]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true for array with falsy entry', () => {\n        let value = util.hasEntries([0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for array with truthy entry', () => {\n        let value = util.hasEntries([4]);\n        expect(value).toBe(true);\n      });\n\n    });\n\n    describe('buildSelect', () => {\n\n      it('should create an empty select', () => {\n        let value = util.buildSelect([]);\n        expect(value.outerHTML).toEqual(\"<select></select>\");\n      });\n\n      it('should reuse a given select', () => {\n        const select = document.createElement('select');\n        let value = util.buildSelect([], select);\n        expect(value).toBe(select);\n      });\n\n      it('should create a select with options', () => {\n        let value = util.buildSelect([\n          'foo',\n          'bar',\n          '<div>boo</div>'\n        ]);\n        expect(value.outerHTML).toEqual(\n          '<select>' +\n            '<option>foo</option>' +\n            '<option>bar</option>' +\n            '<option>&lt;div&gt;boo&lt;/div&gt;</option>' +\n          '</select>'\n        );\n      });\n\n    });\n\n  });\n\n});\n", "patch": "@@ -255,6 +255,36 @@ describe('common', () => {\n \n     });\n \n+    describe('buildSelect', () => {\n+\n+      it('should create an empty select', () => {\n+        let value = util.buildSelect([]);\n+        expect(value.outerHTML).toEqual(\"<select></select>\");\n+      });\n+\n+      it('should reuse a given select', () => {\n+        const select = document.createElement('select');\n+        let value = util.buildSelect([], select);\n+        expect(value).toBe(select);\n+      });\n+\n+      it('should create a select with options', () => {\n+        let value = util.buildSelect([\n+          'foo',\n+          'bar',\n+          '<div>boo</div>'\n+        ]);\n+        expect(value.outerHTML).toEqual(\n+          '<select>' +\n+            '<option>foo</option>' +\n+            '<option>bar</option>' +\n+            '<option>&lt;div&gt;boo&lt;/div&gt;</option>' +\n+          '</select>'\n+        );\n+      });\n+\n+    });\n+\n   });\n \n });", "file_path": "files/2021_11/571", "file_language": "ts", "file_name": "packages/nbdime/test/src/common/util.spec.ts", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/jupyter/nbdime/raw/e44a5cc7677f24b45ebafc756db49058c2f750ea/packages%2Fwebapp%2Fsrc%2Fapp%2Fdiff.ts", "code": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  PageConfig\n} from '@jupyterlab/coreutils';\n\nimport {\n  MathJaxTypesetter\n} from '@jupyterlab/mathjax2';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  requestDiff\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, toggleSpinner, toggleShowUnchanged,\n  markUnchangedRanges\n} from './common';\n\nimport {\n  exportDiff\n} from './staticdiff';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nlet diffWidget: NotebookDiffWidget | null = null;\n\nconst prefixes = ['git:', 'checkpoint:'];\n\nfunction hasPrefix(candidate: string): boolean {\n  for (let p of prefixes) {\n    if (candidate.slice(0, p.length) === p) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction stripPrefix(s: string): string {\n  for (let p of prefixes) {\n    if (s.slice(0, p.length) === p) {\n      return s.slice(p.length);\n    }\n  }\n  return s;\n}\n\n\n/**\n * Show the diff as represented by the base notebook and a list of diff entries\n */\nfunction showDiff(data: {base: nbformat.INotebookContent, diff: IDiffEntry[]}): Promise<void> {\n\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n    latexTypesetter: new MathJaxTypesetter({\n      url: getConfigOption('mathjaxUrl'),\n      config: getConfigOption('mathjaxConfig'),\n    }),\n  });\n\n  let nbdModel = new NotebookDiffModel(data.base, data.diff);\n  let nbdWidget = new NotebookDiffWidget(nbdModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbdWidget);\n  let work = nbdWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  diffWidget = nbdWidget;\n  return work;\n}\n\n/**\n * Diff form submission callback. Sends a request for a diff to the server based\n * on the content of the form.\n */\nfunction onDiff(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('diff-base') as HTMLInputElement).value;\n  let r = (document.getElementById('diff-remote') as HTMLInputElement).value;\n  compare(b, r, true);\n  return false;\n};\n\n\nfunction compare(base: string, remote: string | undefined, pushHistory: boolean | 'replace') {\n  toggleSpinner(true);\n  getDiff(base, remote);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    base = stripPrefix(base);\n    uri = '?base=' + encodeURIComponent(base);\n    if (remote) {\n      uri += '&remote=' + encodeURIComponent(remote);\n    }\n    editHistory(pushHistory, {base, remote},\n      'Diff: \"' + base + '\" vs \"' + remote + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n\n/**\n * Calls `requestDiff` with our response handlers\n */\nexport\nfunction getDiff(base: string, remote: string | undefined) {\n  let baseUrl = getBaseUrl();\n  requestDiff(base, remote, baseUrl, onDiffRequestCompleted, onDiffRequestFailed);\n}\n\n/**\n * Callback for a successfull diff request\n */\nfunction onDiffRequestCompleted(data: any) {\n  let layoutWork = showDiff(data);\n\n  layoutWork.then(() => {\n    let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n    exportBtn.style.display = 'initial';\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed diff request\n */\nfunction onDiffRequestFailed(response: string) {\n  console.log('Diff request failed.');\n  const root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  diffWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('diff-base') as HTMLInputElement);\n    let er = (document.getElementById('diff-remote') as HTMLInputElement);\n    eb.value = e.state.base;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.remote, false);\n  }\n}\n\n/**\n * Trust all outputs in diff\n */\nfunction trustOutputs() {\n  let trust = true;\n  if (!diffWidget) {\n    return;\n  }\n  let model = diffWidget.model;\n  for (let cell of model.cells) {\n    if (!cell.outputs) {\n      continue;\n    }\n    for (let output of cell.outputs) {\n      output.trusted = trust;\n    }\n  }\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-diff-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onDiff;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n\n/**\n *\n */\nexport\nfunction initializeDiff() {\n  attachToForm();\n  // If arguments supplied in config, run diff directly:\n  let base = getConfigOption('base');\n  let remote = getConfigOption('remote');\n  if (base && (remote || hasPrefix(base))) {\n    compare(base, remote, 'replace');\n  }\n\n  let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n  exportBtn.onclick = exportDiff;\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, diffWidget);\n  };\n\n  let trustBtn = document.getElementById('nbdime-trust') as HTMLButtonElement;\n  trustBtn.onclick = trustOutputs;\n  trustBtn.style.display = 'initial';\n}\n", "code_before": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  PageConfig\n} from '@jupyterlab/coreutils';\n\nimport {\n  MathJaxTypesetter\n} from '@jupyterlab/mathjax2';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  requestDiff\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, toggleSpinner, toggleShowUnchanged,\n  markUnchangedRanges\n} from './common';\n\nimport {\n  exportDiff\n} from './staticdiff';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nlet diffWidget: NotebookDiffWidget | null = null;\n\nconst prefixes = ['git:', 'checkpoint:'];\n\nfunction hasPrefix(candidate: string): boolean {\n  for (let p of prefixes) {\n    if (candidate.slice(0, p.length) === p) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction stripPrefix(s: string): string {\n  for (let p of prefixes) {\n    if (s.slice(0, p.length) === p) {\n      return s.slice(p.length);\n    }\n  }\n  return s;\n}\n\n\n/**\n * Show the diff as represented by the base notebook and a list of diff entries\n */\nfunction showDiff(data: {base: nbformat.INotebookContent, diff: IDiffEntry[]}): Promise<void> {\n\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n    latexTypesetter: new MathJaxTypesetter({\n      url: getConfigOption('mathjaxUrl'),\n      config: getConfigOption('mathjaxConfig'),\n    }),\n  });\n\n  let nbdModel = new NotebookDiffModel(data.base, data.diff);\n  let nbdWidget = new NotebookDiffWidget(nbdModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbdWidget);\n  let work = nbdWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  diffWidget = nbdWidget;\n  return work;\n}\n\n/**\n * Diff form submission callback. Sends a request for a diff to the server based\n * on the content of the form.\n */\nfunction onDiff(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('diff-base') as HTMLInputElement).value;\n  let r = (document.getElementById('diff-remote') as HTMLInputElement).value;\n  compare(b, r, true);\n  return false;\n};\n\n\nfunction compare(base: string, remote: string | undefined, pushHistory: boolean | 'replace') {\n  toggleSpinner(true);\n  getDiff(base, remote);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    base = stripPrefix(base);\n    uri = '?base=' + encodeURIComponent(base);\n    if (remote) {\n      uri += '&remote=' + encodeURIComponent(remote);\n    }\n    editHistory(pushHistory, {base, remote},\n      'Diff: \"' + base + '\" vs \"' + remote + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n\n/**\n * Calls `requestDiff` with our response handlers\n */\nexport\nfunction getDiff(base: string, remote: string | undefined) {\n  let baseUrl = getBaseUrl();\n  requestDiff(base, remote, baseUrl, onDiffRequestCompleted, onDiffRequestFailed);\n}\n\n/**\n * Callback for a successfull diff request\n */\nfunction onDiffRequestCompleted(data: any) {\n  let layoutWork = showDiff(data);\n\n  layoutWork.then(() => {\n    let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n    exportBtn.style.display = 'initial';\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed diff request\n */\nfunction onDiffRequestFailed(response: string) {\n  console.log('Diff request failed.');\n  const root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  diffWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('diff-base') as HTMLInputElement);\n    let er = (document.getElementById('diff-remote') as HTMLInputElement);\n    eb.value = e.state.base;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.remote, false);\n  }\n}\n\n/**\n * Trust all outputs in diff\n */\nfunction trustOutputs() {\n  let trust = true;\n  if (!diffWidget) {\n    return;\n  }\n  let model = diffWidget.model;\n  for (let cell of model.cells) {\n    if (!cell.outputs) {\n      continue;\n    }\n    for (let output of cell.outputs) {\n      output.trusted = trust;\n    }\n  }\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-diff-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onDiff;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n\n/**\n *\n */\nexport\nfunction initializeDiff() {\n  attachToForm();\n  // If arguments supplied in config, run diff directly:\n  let base = getConfigOption('base');\n  let remote = getConfigOption('remote');\n  if (base && (remote || hasPrefix(base))) {\n    compare(base, remote, 'replace');\n  }\n\n  let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n  exportBtn.onclick = exportDiff;\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, diffWidget);\n  };\n\n  let trustBtn = document.getElementById('nbdime-trust') as HTMLButtonElement;\n  trustBtn.onclick = trustOutputs;\n  trustBtn.style.display = 'initial';\n}\n", "patch": "@@ -180,11 +180,14 @@ function onDiffRequestCompleted(data: any) {\n  */\n function onDiffRequestFailed(response: string) {\n   console.log('Diff request failed.');\n-  let root = document.getElementById('nbdime-root');\n+  const root = document.getElementById('nbdime-root');\n   if (!root) {\n     throw new Error('Missing root element \"nbidme-root\"');\n   }\n-  root.innerHTML = '<pre>' + response + '</pre>';\n+  const pre = document.createElement('pre');\n+  pre.innerText = response;\n+  root.innerHTML = '';\n+  root.appendChild(pre);\n   diffWidget = null;\n   toggleSpinner(false);\n }", "file_path": "files/2021_11/572", "file_language": "ts", "file_name": "packages/webapp/src/app/diff.ts", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/jupyter/nbdime/raw/e44a5cc7677f24b45ebafc756db49058c2f750ea/packages%2Fwebapp%2Fsrc%2Fapp%2Fmerge.ts", "code": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as alertify from 'alertify.js';\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  JSONExt, JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  NotebookMergeModel\n} from 'nbdime/lib/merge/model';\n\nimport {\n  IMergeDecision\n} from 'nbdime/lib/merge/decisions';\n\nimport {\n  NotebookMergeWidget\n} from 'nbdime/lib/merge/widget';\n\nimport {\n  stringify\n} from 'nbdime/lib/patch';\n\nimport {\n  requestMerge, requestApi\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, closeTool, toggleSpinner,\n  toggleShowUnchanged, markUnchangedRanges\n} from './common';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nimport {\n  extractMergedNotebook\n} from './save';\n\n\nlet mergeWidget: NotebookMergeWidget | null = null;\n\n/**\n * Show the merge as represented by the base notebook and a\n * list of merge decisions\n */\nfunction showMerge(data: {\n    base: nbformat.INotebookContent,\n    merge_decisions: IMergeDecision[]\n    }): Promise<void> {\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n  });\n\n  let nbmModel = new NotebookMergeModel(data.base,\n      data.merge_decisions);\n  let nbmWidget = new NotebookMergeWidget(nbmModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbmWidget);\n  let work = nbmWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  mergeWidget = nbmWidget;\n  return work;\n}\n\n/**\n * Calls `requestMerge` with our response handlers\n */\nexport\nfunction getMerge(base: string, local: string, remote: string) {\n  let baseUrl = getBaseUrl();\n  requestMerge(base, local, remote, baseUrl, onMergeRequestCompleted, onMergeRequestFailed);\n}\n\n/**\n * Merge form submission callback. Sends a request for a merge to the server\n * based on the content of the form.\n *\n * Also pushes state to history for navigation history wo/reload\n */\nfunction onMerge(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('merge-base') as HTMLInputElement).value;\n  let c = (document.getElementById('merge-local') as HTMLInputElement).value;\n  let r = (document.getElementById('merge-remote') as HTMLInputElement).value;\n  compare(b, c, r, true);\n  return false;\n};\n\nfunction compare(b: string, c: string, r: string, pushHistory: boolean | 'replace') {\n  // All values present, do merge\n  toggleSpinner(true);\n  getMerge(b, c, r);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    uri += '?base=' + encodeURIComponent(b) +\n      '&local=' + encodeURIComponent(c) +\n      '&remote=' + encodeURIComponent(r);\n    editHistory(pushHistory, {base: b, local: c, remote: r},\n      'Merge: \"' + c + '\" - \"' + b + '\" - \"' + r + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('merge-base') as HTMLInputElement);\n    let el = (document.getElementById('merge-local') as HTMLInputElement);\n    let er = (document.getElementById('merge-remote') as HTMLInputElement);\n\n    eb.value = e.state.base;\n    el.value = e.state.local;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.local, e.state.remote, false);\n  }\n}\n\n/**\n * Callback for a successfull merge request\n */\nfunction onMergeRequestCompleted(data: any) {\n  let layoutWork = showMerge(data);\n  layoutWork.then(() => {\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed merge request\n */\nfunction onMergeRequestFailed(response: string) {\n  console.log('Merge request failed.');\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  mergeWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Extract the merged notebook from the model, as well as any remaining\n * conflicts, and send them to the server for storage / further processing.\n */\nexport\nfunction saveMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  let nb = extractMergedNotebook(mergeWidget);\n  let conflicts: IMergeDecision[] = [];\n  for (let md of mergeWidget.model.conflicts) {\n    conflicts.push(md.serialize());\n  }\n  submitMerge(nb, conflicts);\n}\n\n\nfunction downloadNotebook(notebook: nbformat.INotebookContent, filename: string) {\n  let element = document.createElement('a');\n  const nbCopy = JSONExt.deepCopy(notebook) as JSONObject;\n  element.setAttribute(\n    'href', 'data:text/plain;charset=utf-8,' +\n    encodeURIComponent(stringify(nbCopy)));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n  try {\n    element.click();\n  } finally {\n    document.body.removeChild(element);\n  }\n}\n\n\nfunction getMergeFilename() {\n  // If present use 'outputfilename'\n  let filename = getConfigOption('outputfilename');\n  // Otherwise use base name as suggestion\n  if (!filename) {\n    filename = getConfigOption('base');\n  }\n  // Fallback:\n  if (!filename) {\n    filename = 'merged.ipynb';\n  }\n  return filename;\n}\n\n/**\n *\n */\nexport\nfunction downloadMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  function download() {\n    let filename = getMergeFilename();\n    let nb = extractMergedNotebook(mergeWidget!);\n    downloadNotebook(nb, filename);\n  }\n  let conflicted = mergeWidget.model.conflicts.length > 0;\n  if (conflicted) {\n    alertify.confirm('There are conflicts remaining. ' +\n      'Do you still want to download the merge output?', () => {\n        download();\n      });\n  } else {\n    download();\n  }\n}\n\n/**\n * Submit a merged notebook\n */\nfunction submitMerge(mergedNotebook: nbformat.INotebookContent,\n                     conflicts: IMergeDecision[]) {\n  requestApi(\n    getBaseUrl(),\n    '/api/store',\n    {\n      merged: mergedNotebook,\n      conflicts: conflicts\n    },\n    onSubmissionCompleted,\n    onSubmissionFailed);\n}\n\n/**\n * Callback for a successful store of the submitted merged notebook\n */\nfunction onSubmissionCompleted() {\n  alertify.success('Merged notebook saved successfully');\n  mergeWidget!.model.unsavedChanges = false;\n}\n\n/**\n * Callback for a failed store of the submitted merged notebook\n */\nfunction onSubmissionFailed(response: string) {\n  alertify.error('Was not able to save the notebook! See console and/or server log for details.');\n}\n\n\n/**\n * Called when the merge tool is closing, but it can be prevented.\n */\nexport\nfunction closeMerge(ev: Event, unloading=false): string | void | null {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  let savable = getConfigOption('savable');\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      if (mergeWidget.model.unsavedChanges && savable) {\n        let prompt = 'There are remaining conflicts, and you have unsaved changes. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      } else {\n        let prompt = 'There are remaining conflicts. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      }\n    }\n  }\n  if (mergeWidget.model.unsavedChanges && savable) {\n    let prompt = 'There are unsaved changes. Do you want to close anyway?';\n    if (unloading) {\n      ev.returnValue = true;\n      return prompt;\n    }\n    alertify.confirm(prompt,\n      () => {\n        window.onbeforeunload = null!;\n        closeTool(0);\n      },\n      () => {\n        ev.preventDefault();\n      });\n    return null;\n  }\n  closeTool(0);\n  return null;\n}\n\n\n/**\n * Called when merge tool is closing, and it shouldn't be prevented.\n *\n * Will only try to set the correct exit code for the tool.\n */\nexport\nfunction forceCloseMerge(): void {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      closeTool(1);\n    }\n  }\n  closeTool(0);\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-merge-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onMerge;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n/** */\nexport\nfunction initializeMerge() {\n  attachToForm();\n  // If arguments supplied in config, run merge directly:\n  let base = getConfigOption('base');\n  let local = getConfigOption('local');  // Only available for merge\n  let remote = getConfigOption('remote');\n  if (base && local && remote) {\n    compare(base, local, remote, 'replace');\n  }\n\n  let savable = getConfigOption('savable');\n  let saveBtn = document.getElementById('nbdime-save') as HTMLButtonElement;\n  if (savable) {\n    saveBtn.onclick = saveMerged;\n    saveBtn.style.display = 'initial';\n  }\n  let downloadBtn = document.getElementById('nbdime-download') as HTMLButtonElement;\n  downloadBtn.onclick = downloadMerged;\n  downloadBtn.style.display = 'initial';\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, mergeWidget);\n  };\n}\n", "code_before": "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as alertify from 'alertify.js';\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  JSONExt, JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  NotebookMergeModel\n} from 'nbdime/lib/merge/model';\n\nimport {\n  IMergeDecision\n} from 'nbdime/lib/merge/decisions';\n\nimport {\n  NotebookMergeWidget\n} from 'nbdime/lib/merge/widget';\n\nimport {\n  stringify\n} from 'nbdime/lib/patch';\n\nimport {\n  requestMerge, requestApi\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, closeTool, toggleSpinner,\n  toggleShowUnchanged, markUnchangedRanges\n} from './common';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nimport {\n  extractMergedNotebook\n} from './save';\n\n\nlet mergeWidget: NotebookMergeWidget | null = null;\n\n/**\n * Show the merge as represented by the base notebook and a\n * list of merge decisions\n */\nfunction showMerge(data: {\n    base: nbformat.INotebookContent,\n    merge_decisions: IMergeDecision[]\n    }): Promise<void> {\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n  });\n\n  let nbmModel = new NotebookMergeModel(data.base,\n      data.merge_decisions);\n  let nbmWidget = new NotebookMergeWidget(nbmModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbmWidget);\n  let work = nbmWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  mergeWidget = nbmWidget;\n  return work;\n}\n\n/**\n * Calls `requestMerge` with our response handlers\n */\nexport\nfunction getMerge(base: string, local: string, remote: string) {\n  let baseUrl = getBaseUrl();\n  requestMerge(base, local, remote, baseUrl, onMergeRequestCompleted, onMergeRequestFailed);\n}\n\n/**\n * Merge form submission callback. Sends a request for a merge to the server\n * based on the content of the form.\n *\n * Also pushes state to history for navigation history wo/reload\n */\nfunction onMerge(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('merge-base') as HTMLInputElement).value;\n  let c = (document.getElementById('merge-local') as HTMLInputElement).value;\n  let r = (document.getElementById('merge-remote') as HTMLInputElement).value;\n  compare(b, c, r, true);\n  return false;\n};\n\nfunction compare(b: string, c: string, r: string, pushHistory: boolean | 'replace') {\n  // All values present, do merge\n  toggleSpinner(true);\n  getMerge(b, c, r);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    uri += '?base=' + encodeURIComponent(b) +\n      '&local=' + encodeURIComponent(c) +\n      '&remote=' + encodeURIComponent(r);\n    editHistory(pushHistory, {base: b, local: c, remote: r},\n      'Merge: \"' + c + '\" - \"' + b + '\" - \"' + r + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('merge-base') as HTMLInputElement);\n    let el = (document.getElementById('merge-local') as HTMLInputElement);\n    let er = (document.getElementById('merge-remote') as HTMLInputElement);\n\n    eb.value = e.state.base;\n    el.value = e.state.local;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.local, e.state.remote, false);\n  }\n}\n\n/**\n * Callback for a successfull merge request\n */\nfunction onMergeRequestCompleted(data: any) {\n  let layoutWork = showMerge(data);\n  layoutWork.then(() => {\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed merge request\n */\nfunction onMergeRequestFailed(response: string) {\n  console.log('Merge request failed.');\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  mergeWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Extract the merged notebook from the model, as well as any remaining\n * conflicts, and send them to the server for storage / further processing.\n */\nexport\nfunction saveMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  let nb = extractMergedNotebook(mergeWidget);\n  let conflicts: IMergeDecision[] = [];\n  for (let md of mergeWidget.model.conflicts) {\n    conflicts.push(md.serialize());\n  }\n  submitMerge(nb, conflicts);\n}\n\n\nfunction downloadNotebook(notebook: nbformat.INotebookContent, filename: string) {\n  let element = document.createElement('a');\n  const nbCopy = JSONExt.deepCopy(notebook) as JSONObject;\n  element.setAttribute(\n    'href', 'data:text/plain;charset=utf-8,' +\n    encodeURIComponent(stringify(nbCopy)));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n  try {\n    element.click();\n  } finally {\n    document.body.removeChild(element);\n  }\n}\n\n\nfunction getMergeFilename() {\n  // If present use 'outputfilename'\n  let filename = getConfigOption('outputfilename');\n  // Otherwise use base name as suggestion\n  if (!filename) {\n    filename = getConfigOption('base');\n  }\n  // Fallback:\n  if (!filename) {\n    filename = 'merged.ipynb';\n  }\n  return filename;\n}\n\n/**\n *\n */\nexport\nfunction downloadMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  function download() {\n    let filename = getMergeFilename();\n    let nb = extractMergedNotebook(mergeWidget!);\n    downloadNotebook(nb, filename);\n  }\n  let conflicted = mergeWidget.model.conflicts.length > 0;\n  if (conflicted) {\n    alertify.confirm('There are conflicts remaining. ' +\n      'Do you still want to download the merge output?', () => {\n        download();\n      });\n  } else {\n    download();\n  }\n}\n\n/**\n * Submit a merged notebook\n */\nfunction submitMerge(mergedNotebook: nbformat.INotebookContent,\n                     conflicts: IMergeDecision[]) {\n  requestApi(\n    getBaseUrl(),\n    '/api/store',\n    {\n      merged: mergedNotebook,\n      conflicts: conflicts\n    },\n    onSubmissionCompleted,\n    onSubmissionFailed);\n}\n\n/**\n * Callback for a successful store of the submitted merged notebook\n */\nfunction onSubmissionCompleted() {\n  alertify.success('Merged notebook saved successfully');\n  mergeWidget!.model.unsavedChanges = false;\n}\n\n/**\n * Callback for a failed store of the submitted merged notebook\n */\nfunction onSubmissionFailed(response: string) {\n  alertify.error('Was not able to save the notebook! See console and/or server log for details.');\n}\n\n\n/**\n * Called when the merge tool is closing, but it can be prevented.\n */\nexport\nfunction closeMerge(ev: Event, unloading=false): string | void | null {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  let savable = getConfigOption('savable');\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      if (mergeWidget.model.unsavedChanges && savable) {\n        let prompt = 'There are remaining conflicts, and you have unsaved changes. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      } else {\n        let prompt = 'There are remaining conflicts. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      }\n    }\n  }\n  if (mergeWidget.model.unsavedChanges && savable) {\n    let prompt = 'There are unsaved changes. Do you want to close anyway?';\n    if (unloading) {\n      ev.returnValue = true;\n      return prompt;\n    }\n    alertify.confirm(prompt,\n      () => {\n        window.onbeforeunload = null!;\n        closeTool(0);\n      },\n      () => {\n        ev.preventDefault();\n      });\n    return null;\n  }\n  closeTool(0);\n  return null;\n}\n\n\n/**\n * Called when merge tool is closing, and it shouldn't be prevented.\n *\n * Will only try to set the correct exit code for the tool.\n */\nexport\nfunction forceCloseMerge(): void {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      closeTool(1);\n    }\n  }\n  closeTool(0);\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-merge-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onMerge;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n/** */\nexport\nfunction initializeMerge() {\n  attachToForm();\n  // If arguments supplied in config, run merge directly:\n  let base = getConfigOption('base');\n  let local = getConfigOption('local');  // Only available for merge\n  let remote = getConfigOption('remote');\n  if (base && local && remote) {\n    compare(base, local, remote, 'replace');\n  }\n\n  let savable = getConfigOption('savable');\n  let saveBtn = document.getElementById('nbdime-save') as HTMLButtonElement;\n  if (savable) {\n    saveBtn.onclick = saveMerged;\n    saveBtn.style.display = 'initial';\n  }\n  let downloadBtn = document.getElementById('nbdime-download') as HTMLButtonElement;\n  downloadBtn.onclick = downloadMerged;\n  downloadBtn.style.display = 'initial';\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, mergeWidget);\n  };\n}\n", "patch": "@@ -179,7 +179,10 @@ function onMergeRequestFailed(response: string) {\n   if (!root) {\n     throw new Error('Missing root element \"nbidme-root\"');\n   }\n-  root.innerHTML = '<pre>' + response + '</pre>';\n+  const pre = document.createElement('pre');\n+  pre.innerText = response;\n+  root.innerHTML = '';\n+  root.appendChild(pre);\n   mergeWidget = null;\n   toggleSpinner(false);\n }", "file_path": "files/2021_11/573", "file_language": "ts", "file_name": "packages/webapp/src/app/merge.ts", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
