{"index": 11366, "cve_id": "CVE-2023-28836", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Wagtail is an open source content management system built on Django. Starting in version 1.5 and prior to versions 4.1.4 and 4.2.2, a stored cross-site scripting (XSS) vulnerability exists on ModelAdmin views within the Wagtail admin interface. A user with a limited-permission editor account for the Wagtail admin could potentially craft pages and documents that, when viewed by a user with higher privileges, could perform actions with that user's credentials. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin, and only affects sites with ModelAdmin enabled. For page, the vulnerability is in the \"Choose a parent page\" ModelAdmin view (`ChooseParentView`), available when managing pages via ModelAdmin. For documents, the vulnerability is in the ModelAdmin Inspect view (`InspectView`) when displaying document fields. Patched versions have been released as Wagtail 4.1.4 and Wagtail 4.2.2. Site owners who are unable to upgrade to the new versions can disable or override the corresponding functionality.", "cvss": "5.4", "publish_date": "April 3, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "ff806ab173a504395fdfb3139eb0a29444ab4b91", "commit_message": "Change ModelAdmin InspectView to escape any HTML from document titles", "commit_date": "2023-04-03T11:11:46Z", "project": "wagtail/wagtail", "url": "https://api.github.com/repos/wagtail/wagtail/commits/ff806ab173a504395fdfb3139eb0a29444ab4b91", "html_url": "https://github.com/wagtail/wagtail/commit/ff806ab173a504395fdfb3139eb0a29444ab4b91", "windows_before": [{"commit_id": "e219968e60723815746ca2c6983b8a4152e13a7e", "commit_date": "Mon Apr 3 12:34:43 2023 +0200", "commit_message": "Fill in release date for 4.1.4", "files_name": ["CHANGELOG.txt", "docs/releases/4.1.4.md"]}, {"commit_id": "879295913a68d2b13b2519ea6b8ed62bfe3844b6", "commit_date": "Mon Apr 3 12:34:12 2023 +0200", "commit_message": "Fill in release date for 4.2.2", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "d4022310cbe497993459c3136311467c7ac6329a", "commit_date": "Mon Apr 3 12:01:43 2023 +0200", "commit_message": "Release note for CVE-2023-28837 in 4.1.4", "files_name": ["CHANGELOG.txt", "docs/releases/4.1.4.md"]}, {"commit_id": "c9d2fcd650a88d76ae122646142245e5927a9165", "commit_date": "Mon Apr 3 12:00:49 2023 +0200", "commit_message": "Release note for CVE-2023-28837 in 4.2.2", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "cfa11bbe00dbe7ce8cd4c0bbfe2a898a690df2bf", "commit_date": "Fri Mar 10 12:00:46 2023 +0000", "commit_message": "Don't load temporary uploaded files into memory", "files_name": ["wagtail/images/fields.py", "wagtail/images/tests/test_admin_views.py"]}, {"commit_id": "3c0c64642b9e5b8d28b111263c7f4bddad6c3880", "commit_date": "Fri Mar 10 11:16:56 2023 +0000", "commit_message": "Don't load images / documents into memory when calculating their hash", "files_name": ["wagtail/documents/models.py", "wagtail/documents/tests/test_models.py", "wagtail/images/models.py", "wagtail/images/tests/test_models.py", "wagtail/tests/test_utils.py", "wagtail/utils/file.py"]}, {"commit_id": "eefc3381d37b476791610e5d30594fae443f33af", "commit_date": "Mon Apr 3 11:19:56 2023 +0200", "commit_message": "Release note for CVE-2023-28836 in 4.1.4", "files_name": ["CHANGELOG.txt", "docs/releases/4.1.4.md"]}, {"commit_id": "bc84bf9815610cfbf8db3b6050c7ddcbaa4b9713", "commit_date": "Mon Apr 3 11:18:58 2023 +0200", "commit_message": "Release note for CVE-2023-28836 in 4.2.2", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "158acef60615bbeeae07713b2888dad07b0ee1ff", "commit_date": "Mon Mar 27 13:03:46 2023 +0100", "commit_message": "Change ModelAdmin InspectView to escape any HTML from document titles", "files_name": ["wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py", "wagtail/contrib/modeladmin/views.py"]}, {"commit_id": "f033c9c490097ce1384419bed69d5f4100801d1c", "commit_date": "Mon Mar 27 13:03:16 2023 +0100", "commit_message": "Add new document field to Book model to test ModelAdmin features", "files_name": ["wagtail/test/modeladmintest/migrations/0013_book_extract_document.py", "wagtail/test/modeladmintest/models.py"]}, {"commit_id": "714147964a532d9797d33284f5db93d231204978", "commit_date": "Mon Mar 27 12:48:02 2023 +0100", "commit_message": "Change ChooseParentView to use plain text breadcrumbs for page titles, avoiding stored XSS vector", "files_name": ["wagtail/contrib/modeladmin/forms.py", "wagtail/contrib/modeladmin/tests/test_page_modeladmin.py"]}, {"commit_id": "a3498b260f8d2ed26ebd3df865e32fd84669d2dd", "commit_date": "Mon Apr 3 10:20:22 2023 +0200", "commit_message": "Release note for #10256", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md"]}, {"commit_id": "bcbaafd116e080c1939551a016204acfa72ce9d6", "commit_date": "Mon Mar 20 17:00:26 2023 +0000", "commit_message": "Add docs and tests for snippets listing filters via list_filter", "files_name": ["docs/reference/viewsets.md", "docs/topics/snippets.md", "wagtail/snippets/tests/test_viewset.py", "wagtail/test/testapp/models.py", "wagtail/test/testapp/wagtail_hooks.py"]}, {"commit_id": "b33eff76a131de7a3c9dd897f368e2e12e0b3885", "commit_date": "Wed Mar 22 16:34:53 2023 +0000", "commit_message": "Fix is_filtering detection in generic IndexView for filters with lookups", "files_name": ["wagtail/admin/views/generic/models.py"]}, {"commit_id": "82cac4ae2edea4fa9f17777d133c0117052c5db5", "commit_date": "Tue Mar 21 17:28:58 2023 +0000", "commit_message": "Move custom snippets listing view tests to test_viewset and merge FilterableSnippet with FullFeaturedSnippet", "files_name": ["wagtail/snippets/tests/test_snippets.py", "wagtail/snippets/tests/test_viewset.py", "wagtail/test/snippets/migrations/0010_delete_filterablesnippet.py", "wagtail/test/snippets/models.py", "wagtail/test/snippets/views.py", "wagtail/test/testapp/migrations/0024_fullfeaturedsnippet_country_code_and_more.py", "wagtail/test/testapp/models.py", "wagtail/test/testapp/wagtail_hooks.py"]}, {"commit_id": "c1a4528b8a91ebdb5018837c37ffd54ef34f0aba", "commit_date": "Tue Mar 21 17:28:04 2023 +0000", "commit_message": "Prevent a circular import when registering snippets bulk actions", "files_name": ["wagtail/admin/views/bulk_action/base_bulk_action.py", "wagtail/admin/views/bulk_action/registry.py", "wagtail/snippets/bulk_actions/snippet_bulk_action.py"]}, {"commit_id": "6e3d75f0ab5bae710e0dcd1286b7e13a6572ece5", "commit_date": "Mon Mar 20 17:00:00 2023 +0000", "commit_message": "Allow IndexView.list_filter to be set via SnippetViewSet.list_filter", "files_name": ["wagtail/snippets/views/snippets.py"]}, {"commit_id": "78c890eaebde61c6319d368f5a41dc8f05d16208", "commit_date": "Mon Mar 20 16:58:21 2023 +0000", "commit_message": "Automatically generate a default filterset_class via IndexView.list_filter", "files_name": ["wagtail/admin/views/generic/models.py"]}, {"commit_id": "def7e44a380d9098541d4f266b9c211202d94150", "commit_date": "Sat Apr 1 01:23:08 2023 +0100", "commit_message": "Release note for #10266 in 4.2.2", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "d82ae50ca9d2d7145ce5d03614b9c4bce26f416a", "commit_date": "Sat Apr 1 01:21:42 2023 +0100", "commit_message": "Release note for #10266 in 4.1.4", "files_name": ["CHANGELOG.txt", "docs/releases/4.1.4.md"]}, {"commit_id": "1532eedf209074eaea5eef8d7bc5303128760bbd", "commit_date": "Sat Mar 25 21:14:52 2023 +1000", "commit_message": "Ensure datetimepicker widget overlay shows over modals", "files_name": ["client/scss/overrides/_vendor.datetimepicker.scss"]}, {"commit_id": "4498956f051fe7fdfba493d803f318945e9337d2", "commit_date": "Sat Apr 1 00:57:51 2023 +0100", "commit_message": "Release note for #10284 in 4.2.2", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "2cd4730e63044e904da7caf859dc1639c933ad88", "commit_date": "Sat Apr 1 00:56:29 2023 +0100", "commit_message": "Release note for #10284 in 4.1.4", "files_name": ["CHANGELOG.txt", "docs/releases/4.1.4.md"]}, {"commit_id": "ab92331f99bebe4cd6ec41530e7badd9eaae3c99", "commit_date": "Fri Mar 10 15:04:44 2023 +0000", "commit_message": "Render large image files to disk", "files_name": ["wagtail/images/models.py"]}, {"commit_id": "f82ff1e22c6bdad4fe7363080523b52753df1e78", "commit_date": "Fri Mar 31 17:05:20 2023 +0100", "commit_message": "Move help text above all form fields (#10302)", "files_name": ["CHANGELOG.txt", "client/scss/components/_panel.scss", "client/scss/components/forms/_field.scss", "client/scss/components/forms/_help.scss", "client/scss/components/forms/_title.scss", "client/src/components/StreamField/blocks/FieldBlock.js", "client/src/components/StreamField/blocks/__snapshots__/FieldBlock.test.js.snap", "client/src/components/StreamField/blocks/__snapshots__/ListBlock.test.js.snap", "client/src/components/StreamField/blocks/__snapshots__/StreamBlock.test.js.snap", "client/src/components/StreamField/blocks/__snapshots__/StructBlock.test.js.snap", "client/src/entrypoints/contrib/table_block/__snapshots__/table.test.js.snap", "client/src/entrypoints/contrib/table_block/table.js", "client/src/entrypoints/contrib/typed_table_block/__snapshots__/typed_table_block.test.js.snap", "docs/releases/5.0.md", "wagtail/admin/templates/wagtailadmin/shared/field.html"]}, {"commit_id": "84fdbf37838e9023a59a57147db69bd5395a0edc", "commit_date": "Fri Mar 31 14:36:29 2023 +0100", "commit_message": "Make /admin/jsi18n/ view accessible to unauthenticated users", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md", "wagtail/admin/tests/test_views.py", "wagtail/admin/urls/__init__.py"]}, {"commit_id": "7a6d2bc689b849ae5897555342f3bc518b6d5976", "commit_date": "Thu Mar 30 21:20:13 2023 +1000", "commit_message": "5.0 release notes clean up", "files_name": ["docs/releases/5.0.md"]}, {"commit_id": "e6282572c30989f6f45b6962846d0e72e8ecf798", "commit_date": "Thu Mar 30 16:11:56 2023 +0100", "commit_message": "Release note for #10298", "files_name": ["CHANGELOG.txt", "docs/releases/4.2.2.md"]}, {"commit_id": "9e4226dd61145cc413cb83d46d45b81a0ecdf8b1", "commit_date": "Thu Mar 30 14:54:41 2023 +0100", "commit_message": "Release note for #10297", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md"]}, {"commit_id": "859a4d1e8daf9cb676c6dd2dfbc43672b71e4792", "commit_date": "Thu Mar 30 13:48:55 2023 +0100", "commit_message": "Remove fallback code for old Wagtail versions from wagtail_factories", "files_name": ["wagtail/test/utils/wagtail_factories/__init__.py", "wagtail/test/utils/wagtail_factories/blocks.py", "wagtail/test/utils/wagtail_factories/builder.py", "wagtail/test/utils/wagtail_factories/factories.py"]}, {"commit_id": "8fbf010b1676be7ceeb5bc37d155f1a685543fdd", "commit_date": "Thu Mar 30 13:43:18 2023 +0100", "commit_message": "Include wagtail-factories inside wagtail.test.utils", "files_name": ["setup.py", "wagtail/test/streamfield_migrations/factories.py", "wagtail/test/utils/wagtail_factories/__init__.py", "wagtail/test/utils/wagtail_factories/blocks.py", "wagtail/test/utils/wagtail_factories/builder.py", "wagtail/test/utils/wagtail_factories/factories.py", "wagtail/test/utils/wagtail_factories/options.py"]}, {"commit_id": "fd88ec3eb774826becc249bb74d4dc00dfaa2b03", "commit_date": "Thu Mar 30 10:45:09 2023 +0100", "commit_message": "Release note for #9842", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md"]}, {"commit_id": "c3383f20a42c27b34369144f451159d98f9904a5", "commit_date": "Thu Mar 30 00:21:21 2023 +0100", "commit_message": "Use functools.lru_cache instead of cache on ImageNode.get_filter", "files_name": ["wagtail/images/templatetags/wagtailimages_tags.py", "wagtail/images/utils.py"]}, {"commit_id": "926ae2418f18a2de2a3df7ec83462772f70f9c38", "commit_date": "Wed Mar 29 20:24:15 2023 +0100", "commit_message": "Bump Willow to 1.5 for SVG support", "files_name": ["setup.py"]}, {"commit_id": "2424df3d685849657c24aedc1d8d436c0704632a", "commit_date": "Fri Feb 10 15:46:37 2023 +0000", "commit_message": "Remove WAGTAILIMAGES_ALLOW_SVG setting for WAGTAILIMAGES_EXTENSIONS", "files_name": ["docs/reference/settings.md", "docs/topics/images.md", "wagtail/images/fields.py", "wagtail/images/tests/test_admin_views.py", "wagtail/images/views/multiple.py", "wagtail/test/settings.py"]}, {"commit_id": "657afde30a1217dc28eed9c61252084f9c9ebeea", "commit_date": "Fri Feb 10 14:53:21 2023 +0000", "commit_message": "Add more detail to SVG security notes, update settings reference", "files_name": ["docs/reference/settings.md", "docs/topics/images.md"]}, {"commit_id": "ef12245351b243a705fa4ce4213904cd7c5f4883", "commit_date": "Tue Jan 3 17:31:23 2023 +0000", "commit_message": "Add more SVG tests", "files_name": ["wagtail/images/tests/test_admin_views.py", "wagtail/images/tests/test_image_operations.py", "wagtail/images/tests/test_templatetags.py", "wagtail/test/settings.py"]}, {"commit_id": "196ed4162d355a6136ceb007ca0427b2aac4c279", "commit_date": "Tue Jan 3 15:58:46 2023 +0000", "commit_message": "Add SVG docs", "files_name": ["docs/advanced_topics/api/v2/configuration.md", "docs/topics/images.md"]}, {"commit_id": "b30bfa993fcb9d8bc0a76b637b677925227c70b9", "commit_date": "Tue Jan 3 10:52:50 2023 +0000", "commit_message": "Add preserve_svg option to api ImageRenditionField", "files_name": ["wagtail/images/api/fields.py"]}, {"commit_id": "34691bdd3a211786422fc2db1d73ac50c5b367cf", "commit_date": "Thu Dec 22 16:52:32 2022 +0000", "commit_message": "Add preserve-svg option to image template tag", "files_name": ["wagtail/images/models.py", "wagtail/images/templatetags/wagtailimages_tags.py", "wagtail/images/tests/test_templatetags.py", "wagtail/images/tests/utils.py", "wagtail/images/utils.py"]}, {"commit_id": "0634ad2e9c70defcdf5d0a49b00f2ab841b9bcd5", "commit_date": "Wed Dec 21 14:37:02 2022 +0000", "commit_message": "Allow processing of SVGs with floating point dimensions", "files_name": ["wagtail/images/image_operations.py", "wagtail/images/models.py"]}], "windows_after": [{"commit_id": "e41035e298caec4f37dc8b7994a92a90ef73d179", "commit_date": "Mon Apr 3 14:30:24 2023 +0200", "commit_message": "Update latest.txt for 4.2.2 / 4.1.4", "files_name": ["scripts/latest.txt"]}, {"commit_id": "18e57574cbba60c6b26cc2523f38eb481dd9c15a", "commit_date": "Mon Apr 3 16:09:22 2023 +0200", "commit_message": "Formalise support for Django 4.2", "files_name": [".github/workflows/test.yml", "CHANGELOG.txt", "README.md", "docs/getting_started/integrating_into_django.md", "docs/releases/5.0.md", "docs/releases/upgrading.md", "setup.py", "tox.ini", "wagtail/project_template/requirements.txt"]}, {"commit_id": "b3ecfabf640d58a214890b9ce4f0b3ff2be1f41d", "commit_date": "Fri Mar 24 15:05:17 2023 +0000", "commit_message": "Earmark icon font setup scheduled for deletion in Wagtail 6.0", "files_name": ["client/scss/components/_icons.scss", "client/scss/settings/_variables.icons.scss"]}, {"commit_id": "5ffb48a015818eef3cfd80b10dbdcad70fff9fea", "commit_date": "Fri Mar 24 15:00:59 2023 +0000", "commit_message": "Convert workflow and page listing icons to SVG", "files_name": ["client/scss/components/_icons.scss", "client/scss/components/_listing.scss", "wagtail/admin/templates/wagtailadmin/chooser/tables/page_navigate_to_children_cell.html", "wagtail/admin/templates/wagtailadmin/pages/listing/_list.html", "wagtail/admin/templates/wagtailadmin/pages/listing/_navigation_explore.html", "wagtail/admin/templates/wagtailadmin/pages/listing/_page_title_explore.html", "wagtail/admin/templates/wagtailadmin/workflows/includes/workflow_pages_formset.html", "wagtail/admin/templates/wagtailadmin/workflows/index.html", "wagtail/admin/templates/wagtailadmin/workflows/select_task_type.html", "wagtail/admin/templates/wagtailadmin/workflows/task_chooser/includes/select_task_type.html", "wagtail/admin/templates/wagtailadmin/workflows/task_index.html", "wagtail/admin/tests/pages/test_explorer_view.py"]}, {"commit_id": "2ebf0de3fc708026d251895390259428ab7609bf", "commit_date": "Fri Mar 24 15:00:28 2023 +0000", "commit_message": "Convert ModelAdmin icons to SVG", "files_name": ["wagtail/contrib/modeladmin/helpers/button.py", "wagtail/contrib/modeladmin/templates/modeladmin/includes/button.html"]}, {"commit_id": "c2c37ab1432ffeb6ca207584193e88e12bc04962", "commit_date": "Fri Apr 7 09:25:02 2023 +0100", "commit_message": "Update documentation referring to icon class names", "files_name": ["docs/extending/adding_reports.md", "docs/reference/hooks.md"]}, {"commit_id": "574cc05d1998f104c240ebe9abeadbdce5dbedc0", "commit_date": "Wed Apr 12 11:50:14 2023 +0100", "commit_message": "Release notes for #10278", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md"]}, {"commit_id": "8cbff95a9ca4788ff463ed687706b00743bdfadf", "commit_date": "Wed Mar 8 12:18:14 2023 +0000", "commit_message": "Rewrite test_search_searchable_fields to not hack search_fields on the fly", "files_name": ["wagtail/admin/tests/pages/test_page_search.py"]}, {"commit_id": "8d80c858d2cba02dcf326bda38bd1c42676f2e18", "commit_date": "Wed Mar 8 12:20:12 2023 +0000", "commit_message": "add a repr to MatchExpression to help with debugging", "files_name": ["wagtail/search/backends/database/sqlite/query.py"]}, {"commit_id": "f83ba30c4213d9659dffacde0d7d56f473b63158", "commit_date": "Wed Mar 8 12:22:07 2023 +0000", "commit_message": "Change the \"missing core fields in search_fields\" test to check against TaggedPage instead of EventPage", "files_name": ["wagtail/search/tests/test_indexed_class.py", "wagtail/test/testapp/models.py"]}, {"commit_id": "7f6d6c34775d8fa2cf7a31be7d9e294e6d6db130", "commit_date": "Wed Mar 8 13:30:21 2023 +0000", "commit_message": "Perform indexing before running API page search tests", "files_name": ["wagtail/api/v2/tests/test_pages.py"]}, {"commit_id": "12e277a95c4eb9151ef45b2b2328b176f7faa10a", "commit_date": "Wed Mar 8 17:31:39 2023 +0000", "commit_message": "Update page chooser search tests to not rely on partial matching", "files_name": ["wagtail/admin/tests/test_page_chooser.py"]}, {"commit_id": "ca6732f5691f757acb57d823c37a5c0ef52f97a8", "commit_date": "Wed Mar 8 17:48:01 2023 +0000", "commit_message": "When capturing deletion signals, don't assume objects have an id field", "files_name": ["wagtail/admin/tests/pages/test_bulk_actions/test_bulk_delete.py", "wagtail/admin/tests/pages/test_delete_page.py"]}, {"commit_id": "2f41de277d8828e01311352bbca5b62f6164b3e9", "commit_date": "Thu Mar 9 12:57:26 2023 +0000", "commit_message": "Switch to real database backend for tests", "files_name": ["wagtail/test/settings.py"]}, {"commit_id": "cee79201d3e97f42b74360cd92c476f258a5f401", "commit_date": "Thu Mar 9 15:24:22 2023 +0000", "commit_message": "Fix test for root appearing in search results", "files_name": ["wagtail/admin/tests/pages/test_page_search.py"]}, {"commit_id": "99b3813d6ed2df94d3b69eab3e922b9500af8abe", "commit_date": "Thu Mar 9 16:41:59 2023 +0000", "commit_message": "Use the correct context variable for snippet chooser tests", "files_name": ["wagtail/snippets/tests/test_snippets.py"]}, {"commit_id": "09d61cedcdeeb7477618fc71b993390c9c249111", "commit_date": "Thu Mar 9 18:21:16 2023 +0000", "commit_message": "Use more distinctive keywords in API search tests", "files_name": ["wagtail/api/v2/tests/test_pages.py", "wagtail/test/demosite/fixtures/demosite.json"]}, {"commit_id": "dc08bca09409a7df46d74274a8e5bc74b44958e4", "commit_date": "Thu Mar 9 18:28:44 2023 +0000", "commit_message": "search for 'lord' instead of 'of' to avoid stopword removal", "files_name": ["wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py", "wagtail/test/modeladmintest/fixtures/modeladmintest_test.json"]}, {"commit_id": "d871cd463547bec4ed044afe563591005c3de215", "commit_date": "Fri Mar 10 18:46:46 2023 +0000", "commit_message": "Disable order_by_relevance when testing custom ordering on search queries", "files_name": ["wagtail/documents/tests/test_models.py", "wagtail/images/tests/test_models.py"]}, {"commit_id": "c281c4605b4f8645245e053bd26a7d81a564ab76", "commit_date": "Fri Mar 10 18:53:20 2023 +0000", "commit_message": "Fix snippet search tests to avoid searching on a stopword", "files_name": ["wagtail/snippets/tests/test_viewset.py"]}, {"commit_id": "ae89cd6b115bdddfb77250cdf73d6616da5dec5b", "commit_date": "Fri Mar 10 19:01:11 2023 +0000", "commit_message": "Fix annotate_score tests to test a real search, and run indexer", "files_name": ["wagtail/tests/test_page_queryset.py"]}, {"commit_id": "7d754d0fcee6b4a830f037a207931ced31e081fc", "commit_date": "Mon Mar 27 00:48:39 2023 +0100", "commit_message": "Use TransactionTestCase for API search tests", "files_name": ["wagtail/admin/tests/api/test_documents.py", "wagtail/admin/tests/api/test_images.py", "wagtail/admin/tests/api/test_pages.py", "wagtail/admin/tests/api/utils.py", "wagtail/api/v2/tests/test_documents.py", "wagtail/api/v2/tests/test_images.py", "wagtail/api/v2/tests/test_pages.py", "wagtail/test/demosite/fixtures/demosite.json"]}, {"commit_id": "da171df2cee23ebb4109471059e4fe0a4816737f", "commit_date": "Mon Mar 27 01:30:13 2023 +0100", "commit_message": "Use TransactionTestCase for page search tests", "files_name": ["wagtail/admin/tests/pages/test_page_search.py", "wagtail/test/testapp/fixtures/test_empty.json"]}, {"commit_id": "f86666f5efb31e54181da713ad09bdc35446a295", "commit_date": "Mon Mar 27 01:42:53 2023 +0100", "commit_message": "Use TransactionTestCase for document admin search tests", "files_name": ["wagtail/documents/tests/test_admin_views.py"]}, {"commit_id": "34876237c256b2c77a40ef0c98291e4a5fcb0aa4", "commit_date": "Mon Mar 27 02:28:41 2023 +0100", "commit_message": "Use TransactionTestCase for page queryset search tests", "files_name": ["wagtail/test/testapp/fixtures/test.json", "wagtail/test/testapp/fixtures/test_specific.json", "wagtail/tests/test_page_queryset.py"]}, {"commit_id": "706113c1e14c397d5f9984df067c1798058b4aca", "commit_date": "Fri Mar 31 17:08:17 2023 +0100", "commit_message": "Use TransactionTestCase for TestChooserSearch in test_page_chooser", "files_name": ["wagtail/admin/tests/test_page_chooser.py"]}, {"commit_id": "18e445c5f45c1197c9f2177d1528cd7dbcc0b1df", "commit_date": "Fri Mar 31 17:13:12 2023 +0100", "commit_message": "Use TransactionTestCase for simple modeladmin search test", "files_name": ["wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py", "wagtail/test/modeladmintest/fixtures/modeladmintest_test.json"]}, {"commit_id": "d3503bfd5a214e40c193e8f2acbc5fee7bf992b6", "commit_date": "Fri Mar 31 17:35:41 2023 +0100", "commit_message": "Use TransactionTestCase for document model search tests", "files_name": ["wagtail/documents/tests/test_models.py"]}, {"commit_id": "daf56028fea0d26a7f52cc30754e328588cd263b", "commit_date": "Fri Mar 31 17:45:12 2023 +0100", "commit_message": "Use TransactionTestCase for image admin view search tests", "files_name": ["wagtail/images/tests/test_admin_views.py"]}, {"commit_id": "e1f4876ac697903535632dfeda50230e8ba6531b", "commit_date": "Fri Mar 31 17:48:00 2023 +0100", "commit_message": "Use TransactionTestCase for image model search tests", "files_name": ["wagtail/images/tests/test_models.py"]}, {"commit_id": "601c59eef0b3c103380745286d9d712c9001ec27", "commit_date": "Fri Mar 31 17:57:47 2023 +0100", "commit_message": "Use TransactionTestCase for snippet search tests", "files_name": ["wagtail/snippets/tests/test_snippets.py", "wagtail/snippets/tests/test_viewset.py"]}, {"commit_id": "b3b8af2cf601fa700336fd2d7b6e3a33d75eaae4", "commit_date": "Fri Mar 31 18:20:09 2023 +0100", "commit_message": "Revert \"Switch to real database backend for tests\"", "files_name": ["wagtail/test/settings.py"]}, {"commit_id": "f88796b3ddcd30b4ae49ae60254d69f23cc51002", "commit_date": "Wed Apr 12 16:26:05 2023 +0100", "commit_message": "Release note for #10208", "files_name": ["CHANGELOG.txt", "docs/releases/5.0.md"]}, {"commit_id": "70a6230a650f8ce299d6f883483c37bacfc325d6", "commit_date": "Thu Mar 30 09:46:43 2023 +0530", "commit_message": "Migrate submit translation bulk toggle to Stimulus Controller (w-bulk)", "files_name": ["CHANGELOG.txt", "CONTRIBUTORS.rst", "client/src/controllers/BulkController.test.js", "client/src/controllers/BulkController.ts", "client/src/controllers/index.ts", "docs/releases/5.0.md", "wagtail/contrib/simple_translation/forms.py", "wagtail/contrib/simple_translation/templates/simple_translation/admin/submit_translation.html"]}, {"commit_id": "1992c72791035e26a296daf5f673a0d700b9ee12", "commit_date": "Mon Mar 27 11:06:57 2023 +0100", "commit_message": "Add missing docs for chooser_viewset_class", "files_name": ["docs/reference/viewsets.md", "wagtail/snippets/views/snippets.py"]}, {"commit_id": "b3a9c79f403d40071b5bfc64d0e7d308c174f2ff", "commit_date": "Mon Mar 27 11:24:07 2023 +0100", "commit_message": "Rename Snippets type_index.html and results.html templates to index.html and index_results.html", "files_name": ["wagtail/snippets/templates/wagtailsnippets/snippets/index.html", "wagtail/snippets/templates/wagtailsnippets/snippets/index_results.html", "wagtail/snippets/tests/test_snippets.py", "wagtail/snippets/views/snippets.py"]}, {"commit_id": "2bb0088f21e68a0b2e7cc0f035c5665f80cf53bb", "commit_date": "Mon Mar 27 11:41:29 2023 +0100", "commit_message": "Pass viewset instance to all Snippets views", "files_name": ["wagtail/snippets/views/snippets.py"]}, {"commit_id": "25ae75ab2f5da90bc562b64f158d95081da6d1a5", "commit_date": "Mon Mar 27 12:12:21 2023 +0100", "commit_message": "Allow template overrides from SnippetViewSet", "files_name": ["wagtail/snippets/templates/wagtailsnippets/snippets/delete.html", "wagtail/snippets/views/snippets.py"]}, {"commit_id": "0ded23402e6e783ea8dbf76132afc3a6f3d765a1", "commit_date": "Mon Mar 27 12:52:41 2023 +0100", "commit_message": "Allow template overrides for Snippets views that use generic templates", "files_name": ["wagtail/snippets/views/snippets.py"]}, {"commit_id": "1638695d122bc3787bdf90b3e5f152abb9addf5e", "commit_date": "Mon Apr 3 10:39:56 2023 +0100", "commit_message": "Look for model_index.html before using the generic template for snippets ModelIndexView", "files_name": ["wagtail/snippets/views/snippets.py"]}, {"commit_id": "f2ab3ae7745a39d74e90701868b5d4bfe43a094d", "commit_date": "Mon Mar 27 14:52:04 2023 +0100", "commit_message": "Add docs and tests for Snippets template overrides", "files_name": ["docs/reference/viewsets.md", "docs/releases/5.0.md", "docs/topics/snippets.md", "wagtail/snippets/tests/test_viewset.py", "wagtail/snippets/views/snippets.py", "wagtail/test/testapp/templates/tests/fullfeaturedsnippet_index.html", "wagtail/test/testapp/templates/tests/snippet_history.html", "wagtail/test/testapp/templates/wagtailsnippets/snippets/delete.html", "wagtail/test/testapp/templates/wagtailsnippets/snippets/tests/edit.html", "wagtail/test/testapp/templates/wagtailsnippets/snippets/tests/fullfeaturedsnippet/create.html", "wagtail/test/testapp/templates/wagtailsnippets/snippets/tests/fullfeaturedsnippet/unpublish.html", "wagtail/test/testapp/wagtail_hooks.py"]}, {"commit_id": "b0177333f8b02e45438a756270a26ca4a01dc385", "commit_date": "Tue Apr 4 10:57:25 2023 +0100", "commit_message": "Override get_template_names() to allow WagtailAdminTemplateMixin.template_name to be a list", "files_name": ["wagtail/admin/views/generic/base.py"]}, {"commit_id": "f0857770a770dc567ef6366a1b86a6fdd373412f", "commit_date": "Tue Apr 4 11:24:29 2023 +0100", "commit_message": "Do not pass SnippetViewSet into the views and pass template_name instead", "files_name": ["wagtail/snippets/views/snippets.py"]}, {"commit_id": "dc6c0b09497f5fbfbd4e1a96ccf0cf9687853ffb", "commit_date": "Tue Apr 4 11:43:29 2023 +0100", "commit_message": "Allow overriding SnippetViewSet template prefix", "files_name": ["docs/reference/viewsets.md", "docs/topics/snippets.md", "wagtail/snippets/views/snippets.py"]}, {"commit_id": "93732690a347938df0564c2cf785128321a2488e", "commit_date": "Thu Mar 30 10:57:21 2023 +0100", "commit_message": "Update icon visuals to FontAwesome 6, with deprecation warnings for removed icons", "files_name": ["client/scss/components/forms/_radio-checkbox.scss"]}], "parents": [{"commit_id_before": "f6eae49db5f5e63a15552853ea480e901b97b3eb", "url_before": "https://api.github.com/repos/wagtail/wagtail/commits/f6eae49db5f5e63a15552853ea480e901b97b3eb", "html_url_before": "https://github.com/wagtail/wagtail/commit/f6eae49db5f5e63a15552853ea480e901b97b3eb"}], "details": [{"raw_url": "https://github.com/wagtail/wagtail/raw/ff806ab173a504395fdfb3139eb0a29444ab4b91/wagtail%2Fcontrib%2Fmodeladmin%2Ftests%2Ftest_simple_modeladmin.py", "code": "import datetime\nfrom io import BytesIO\nfrom unittest import mock\n\nfrom django.contrib.auth.models import Group, Permission\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core import checks\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.utils.timezone import make_aware\nfrom openpyxl import load_workbook\n\nfrom wagtail.admin.admin_url_finder import AdminURLFinder\nfrom wagtail.admin.panels import FieldPanel, TabbedInterface\nfrom wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler\nfrom wagtail.documents.models import Document\nfrom wagtail.documents.tests.utils import get_test_document_file\nfrom wagtail.images.models import Image\nfrom wagtail.images.tests.utils import get_test_image_file\nfrom wagtail.models import Locale, ModelLogEntry, Page\nfrom wagtail.test.modeladmintest.models import (\n    Author,\n    Book,\n    Publisher,\n    RelatedLink,\n    Token,\n    TranslatableBook,\n)\nfrom wagtail.test.modeladmintest.wagtail_hooks import BookModelAdmin, EventsAdminGroup\nfrom wagtail.test.utils import WagtailTestUtils\n\n\nclass TestBookIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n        img = Image.objects.create(\n            title=\"LOTR cover\",\n            file=get_test_image_file(),\n        )\n        book = Book.objects.get(title=\"The Lord of the Rings\")\n        book.cover_image = img\n        book.save()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/book/\", params)\n\n    def test_thumbnail_image_col_header_text(self):\n        response = self.get()\n\n        # check thumb_col_header_text is correctly used\n        self.assertContains(\n            response,\n            '<th scope=\"col\" class=\"column-admin_thumb\">The cover</th>',\n            html=True,\n        )\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">4 out of 4</span>', html=True\n        )\n\n        # User has add permission\n        self.assertIs(response.context[\"user_can_create\"], True)\n\n    def test_csv_export(self):\n        # Export the whole queryset\n        response = self.get(export=\"csv\")\n\n        self.assertEqual(response.status_code, 200)\n        # Check attachment is present and named correctly using the modeladmin export_filename\n        self.assertEqual(\n            response.get(\"content-disposition\"),\n            'attachment; filename=\"books-export.csv\"',\n        )\n\n        # Check response - all books should be in it\n        data_lines = response.getvalue().decode().split(\"\\n\")\n        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")\n        self.assertEqual(\n            data_lines[1], \"Charlie and the Chocolate Factory,Roald Dahl,1916-09-13\\r\"\n        )\n        self.assertEqual(\n            data_lines[2], \"The Chronicles of Narnia,Roald Dahl,1898-11-29\\r\"\n        )\n        self.assertEqual(data_lines[3], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")\n        self.assertEqual(\n            data_lines[4], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"\n        )\n\n    def test_xlsx_export(self):\n        # Export the whole queryset\n        response = self.get(export=\"xlsx\")\n\n        self.assertEqual(response.status_code, 200)\n        # Check attachment is present and named correctly using the modeladmin export_filename\n        self.assertEqual(\n            response.get(\"content-disposition\"),\n            'attachment; filename=\"books-export.xlsx\"',\n        )\n\n        # Check response - all books should be in it\n        workbook_data = response.getvalue()\n        worksheet = load_workbook(filename=BytesIO(workbook_data))[\"Sheet1\"]\n        cell_array = [[cell.value for cell in row] for row in worksheet.rows]\n        self.assertEqual(cell_array[0], [\"Title\", \"Author\", \"Author Date Of Birth\"])\n        self.assertEqual(\n            cell_array[1],\n            [\"Charlie and the Chocolate Factory\", \"Roald Dahl\", \"1916-09-13\"],\n        )\n        self.assertEqual(\n            cell_array[2], [\"The Chronicles of Narnia\", \"Roald Dahl\", \"1898-11-29\"]\n        )\n        self.assertEqual(\n            cell_array[3], [\"The Hobbit\", \"J. R. R. Tolkien\", \"1892-01-03\"]\n        )\n        self.assertEqual(\n            cell_array[4], [\"The Lord of the Rings\", \"J. R. R. Tolkien\", \"1892-01-03\"]\n        )\n        self.assertEqual(len(cell_array), 5)\n\n    def test_tr_attributes(self):\n        response = self.get()\n\n        # Charlie & The Chocolate factory should be in the list with the\n        # `data-author_yob` and `data-object_pk` attributes added\n        self.assertContains(response, 'data-author-yob=\"1916\"')\n        self.assertContains(response, 'data-object-pk=\"3\"')\n\n        # There should be two odd rows and two even ones, and 'book' should be\n        # added to the `class` attribute for every one.\n        self.assertContains(response, 'class=\"book odd\"', count=2)\n        self.assertContains(response, 'class=\"book even\"', count=2)\n\n    def test_filter(self):\n        # Filter by author 1 (JRR Tolkien)\n        response = self.get(author__id__exact=1)\n\n        self.assertEqual(response.status_code, 200)\n\n        # JRR Tolkien has two books in the test data\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 4</span>', html=True\n        )\n\n        # The search form should retain the filter\n        self.assertContains(\n            response,\n            '<input type=\"hidden\" name=\"author__id__exact\" value=\"1\">',\n            html=True,\n        )\n\n        for book in response.context[\"object_list\"]:\n            self.assertEqual(book.author_id, 1)\n\n    def test_filtered_csv_export(self):\n        # Filter by author 1 (JRR Tolkien) and export the current selection\n        response = self.get(author__id__exact=1, export=\"csv\")\n\n        # Check response - only books by JRR Tolkien should be in it\n        self.assertEqual(response.status_code, 200)\n        data_lines = response.getvalue().decode().split(\"\\n\")\n        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")\n        self.assertEqual(data_lines[1], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")\n        self.assertEqual(\n            data_lines[2], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"\n        )\n        self.assertEqual(data_lines[3], \"\")\n\n    def test_search_indexed(self):\n        response = self.get(q=\"of\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are two books where the title contains 'of'\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 4</span>', html=True\n        )\n\n    def test_search_form_present(self):\n        # Test the backend search handler allows the search form to render\n        response = self.get()\n\n        self.assertContains(response, '<input id=\"id_q\"')\n\n    def test_search_form_absent(self):\n        # DjangoORMSearchHandler + no search_fields, search form should be absent\n        with mock.patch.object(\n            BookModelAdmin, \"search_handler_class\", DjangoORMSearchHandler\n        ):\n            response = self.get()\n\n            self.assertNotContains(response, '<input id=\"id_q\"')\n\n    def test_ordering(self):\n        response = self.get(o=\"0.1\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n    def test_paging(self):\n        # should be corrected to just the first page, as there aren't enough\n        # objects to make up more than one page\n        response = self.get(p=9)\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n        # Should raise a ValueError that gets caught during initialisation\n        response = self.get(p=\"notaninteger\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n\nclass TestAuthorIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/author/\", params)\n\n    def test_search(self):\n        response = self.get(q=\"Roald Dahl\")\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 5</span>', html=True\n        )\n\n    def test_col_extra_class_names(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <td class=\"field-first_book for-author-1 title\">The Lord of the Rings</td>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    def test_col_extra_attributes(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <td class=\"field-last_book title\" data-for_author=\"1\">The Hobbit</td>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    def test_title_column_links_to_edit_view_by_default(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/edit/1/\" title=\"Edit this author\">J. R. R. Tolkien</a></div>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",\n        return_value=False,\n    )\n    def test_title_column_links_to_inspect_view_when_user_cannot_edit(self, *mocks):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/inspect/1/\" title=\"Inspect this author\">J. R. R. Tolkien</a></div>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_inspect_obj\",\n        return_value=False,\n    )\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",\n        return_value=False,\n    )\n    def test_title_column_is_not_linked_when_user_cannot_edit_or_inspect(self, *mocks):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<td class=\"field-name title\">J. R. R. Tolkien')\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableBookIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/translatablebook/\", params)\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are two books in the test data\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # Check the locale filter is there\n        expected = \"\"\"\n        <ul>\n            <li class=\"selected\">\n            <a href=\"?\">All</a></li>\n            <li>\n            <a href=\"?locale__id__exact=1\">English</a></li>\n            <li>\n            <a href=\"?locale__id__exact=2\">French</a></li>\n        </ul>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n    @override_settings(WAGTAIL_I18N_ENABLED=False)\n    def test_locale_selector_not_present_when_i18n_disabled(self):\n        response = self.get()\n\n        self.assertNotContains(\n            response, '<a href=\"?locale__id__exact=2\">French</a>', html=True\n        )\n\n    def test_filter(self):\n        # Filter by locale 2 (fr)\n        response = self.get(locale__id__exact=2)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Locale fr has one book in the test data\n        self.assertEqual(response.context[\"result_count\"], 1)\n\n        for book in response.context[\"object_list\"]:\n            self.assertEqual(book.locale_id, 2)\n\n        self.assertContains(response, \"Le Seigneur des anneaux\", html=True)\n\n\nclass TestCreateView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self):\n        return self.client.get(\"/admin/modeladmintest/book/create/\")\n\n    def post(self, post_data):\n        return self.client.post(\"/admin/modeladmintest/book/create/\", post_data)\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_create(self):\n        response = self.post(\n            {\n                \"title\": \"George's Marvellous Medicine\",\n                \"author\": 2,\n            }\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Check that the book was created\n        self.assertEqual(\n            Book.objects.filter(title=\"George's Marvellous Medicine\").count(), 1\n        )\n\n        response = self.client.get(\"/admin/modeladmintest/publisher/create/\")\n        self.assertIn(\"name\", response.content.decode(\"UTF-8\"))\n        self.assertNotIn(\"headquartered_in\", response.content.decode(\"UTF-8\"))\n        self.assertEqual(list(response.context[\"form\"].fields), [\"name\"])\n        self.client.post(\n            \"/admin/modeladmintest/publisher/create/\", {\"name\": \"Sharper Collins\"}\n        )\n        publisher = Publisher.objects.get(name=\"Sharper Collins\")\n        self.assertIsNone(publisher.headquartered_in)\n\n    def test_post_invalid(self):\n        initial_book_count = Book.objects.count()\n\n        response = self.post(\n            {\n                \"title\": \"\",\n                \"author\": 2,\n            }\n        )\n        final_book_count = Book.objects.count()\n\n        self.assertEqual(response.status_code, 200)\n        # Check that the book was not created\n        self.assertEqual(initial_book_count, final_book_count)\n\n        # Check that a form error was raised\n        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")\n        self.assertContains(response, \"error-message\", count=1)\n\n    def test_exclude_passed_to_extract_panel_definitions(self):\n        path_to_form_fields_exclude_property = (\n            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"\n        )\n        with mock.patch(\n            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"\n        ) as m:\n            with mock.patch(\n                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock\n            ) as mock_form_fields_exclude:\n                mock_form_fields_exclude.return_value = [\"123\"]\n\n                self.get()\n                self.assertTrue(mock_form_fields_exclude.called)\n                m.assert_called_with(\n                    Book, exclude=mock_form_fields_exclude.return_value\n                )\n\n    def test_clean_form_once(self):\n        with mock.patch(\n            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"\n        ) as mock_form_clean:\n            response = self.client.post(\n                \"/admin/modeladmintest/publisher/create/\", {\"name\": \"\"}\n            )\n            self.assertEqual(response.status_code, 200)\n\n            mock_form_clean.assert_called_once()\n\n    def test_create_view_with_multifieldpanel(self):\n        # https://github.com/wagtail/wagtail/issues/6413\n        response = self.client.get(\"/admin/modeladmintest/relatedlink/create/\")\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(\n            \"/admin/modeladmintest/relatedlink/create/\",\n            {\n                \"title\": \"Homepage\",\n                \"link\": Page.objects.filter(depth=2).first().id,\n            },\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")\n\n        # Check that the link was created\n        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage\").count(), 1)\n\n    def test_prepopulated_field_data_in_context(self):\n        response = self.get()\n        self.assertIn(\n            'data-prepopulated-fields=\"[{&quot;id&quot;: &quot;#id_title&quot;, &quot;name&quot;: &quot;title&quot;, &quot;dependency_ids&quot;: [&quot;#id_author&quot;], &quot;dependency_list&quot;: [&quot;author&quot;], &quot;maxLength&quot;: 255, &quot;allowUnicode&quot;: false}]\"',\n            response.content.decode(\"UTF-8\"),\n        )\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableCreateView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/translatablebook/create/\", params)\n\n    def test_simple(self):\n        response = self.get(locale=\"fr\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that the locale select exists and is set correctly\n        expected = '<a href=\"javascript:void(0)\" aria-label=\"French\" class=\"c-dropdown__button u-btn-current w-no-underline\">'\n        self.assertContains(response, expected)\n\n        # Check that the other locale link is right\n        expected = \"\"\"\n        <a href=\"/admin/modeladmintest/translatablebook/create/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">\n            English\n        </a>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestRevisableCreateView(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.login()\n\n    def post(self, post_data):\n        return self.client.post(\"/admin/modeladmintest/publisher/create/\", post_data)\n\n    def test_create_with_revision(self):\n        data = {\"name\": \"foo\"}\n        response = self.post(data)\n        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")\n\n        instances = Publisher.objects.filter(name=\"foo\")\n        instance = instances.first()\n        self.assertEqual(instances.count(), 1)\n\n        # The revision should be created\n        revisions = instance.revisions\n        revision = revisions.first()\n        self.assertEqual(revisions.count(), 1)\n        self.assertEqual(revision.content[\"name\"], \"foo\")\n\n        # The log entry should have the revision attached\n        log_entries = ModelLogEntry.objects.for_instance(instance).filter(\n            action=\"wagtail.create\"\n        )\n        self.assertEqual(log_entries.count(), 1)\n        self.assertEqual(log_entries.first().revision, revision)\n\n\nclass TestInspectView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n        img = Image.objects.create(\n            title=\"LOTR cover\",\n            file=get_test_image_file(),\n        )\n        book = Book.objects.get(title=\"The Lord of the Rings\")\n        book.cover_image = img\n        book.save()\n\n    def get_for_author(self, author_id):\n        return self.client.get(\"/admin/modeladmintest/author/inspect/%d/\" % author_id)\n\n    def get_for_book(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/inspect/%d/\" % book_id)\n\n    def test_author_simple(self):\n        response = self.get_for_author(1)\n        self.assertEqual(response.status_code, 200)\n\n    def test_author_name_present(self):\n        \"\"\"\n        The author name should appear twice. Once in the header, and once\n        more in the field listing\n        \"\"\"\n        response = self.get_for_author(1)\n        self.assertContains(response, \"J. R. R. Tolkien\", 2)\n\n    def test_author_dob_not_present(self):\n        \"\"\"\n        The date of birth shouldn't appear, because the field wasn't included\n        in the `inspect_view_fields` list\n        \"\"\"\n        response = self.get_for_author(1)\n        self.assertNotContains(response, \"1892\")\n\n    def test_book_simple(self):\n        response = self.get_for_book(1)\n        self.assertEqual(response.status_code, 200)\n\n    def test_book_title_present(self):\n        \"\"\"\n        The book title should appear once only, in the header, as 'title'\n        was added to the `inspect_view_fields_ignore` list\n        \"\"\"\n        response = self.get_for_book(1)\n        self.assertContains(response, \"The Lord of the Rings\", 1)\n\n    def test_book_author_present(self):\n        \"\"\"\n        The author name should appear, because 'author' is not in\n        `inspect_view_fields_ignore` and should be returned by the\n        `get_inspect_view_fields` method.\n        \"\"\"\n        response = self.get_for_book(1)\n        self.assertContains(response, \"J. R. R. Tolkien\", 1)\n\n    def test_book_extract_document_html_escaping(self):\n        doc = Document.objects.create(\n            title=\"Title with <script>alert('XSS')</script>\",\n            file=get_test_document_file(),\n        )\n        book = Book.objects.get(title=\"The Lord of the Rings\")\n        book.extract_document = doc\n        book.save()\n        response = self.get_for_book(1)\n        self.assertNotContains(response, \"Title with <script>alert('XSS')</script>\")\n        self.assertContains(\n            response, \"Title with &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;\"\n        )\n\n    def test_non_existent(self):\n        response = self.get_for_book(100)\n        self.assertEqual(response.status_code, 404)\n\n    def test_back_to_listing(self):\n        response = self.client.get(\"/admin/modeladmintest/author/inspect/1/\")\n        # check that back to listing link exists\n        expected = \"\"\"\n            <p class=\"back\">\n                    <a href=\"/admin/modeladmintest/author/\">\n                        <svg class=\"icon icon-arrow-left default\" aria-hidden=\"true\">\n                            <use href=\"#icon-arrow-left\"></use>\n                        </svg>\n                        Back to author list\n                    </a>\n            </p>\n        \"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestEditView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.user = self.login()\n        ModelLogEntry.objects.create(\n            content_type=ContentType.objects.get_for_model(Book),\n            label=\"The Lord of the Rings\",\n            action=\"wagtail.create\",\n            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),\n            object_id=\"1\",\n        )\n\n    def get(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/edit/%d/\" % book_id)\n\n    def post(self, book_id, post_data):\n        return self.client.post(\n            \"/admin/modeladmintest/book/edit/%d/\" % book_id, post_data\n        )\n\n    def test_simple(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"The Lord of the Rings\")\n\n        # \"Last updated\" timestamp should be present\n        self.assertContains(\n            response, 'data-wagtail-tooltip=\"Sept. 30, 2021, 10:01 a.m.\"'\n        )\n        # History link should be present\n        self.assertContains(response, 'href=\"/admin/modeladmintest/book/history/1/\"')\n\n        url_finder = AdminURLFinder(self.user)\n        expected_url = \"/admin/modeladmintest/book/edit/1/\"\n        self.assertEqual(url_finder.get_edit_url(Book.objects.get(id=1)), expected_url)\n\n    def test_non_existent(self):\n        response = self.get(100)\n\n        self.assertEqual(response.status_code, 404)\n\n    def test_edit(self):\n        response = self.post(\n            1,\n            {\n                \"title\": \"The Lady of the Rings\",\n                \"author\": 1,\n            },\n        )\n\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Check that the book was updated\n        self.assertEqual(Book.objects.get(id=1).title, \"The Lady of the Rings\")\n\n    def test_post_invalid(self):\n        response = self.post(\n            1,\n            {\n                \"title\": \"\",\n                \"author\": 1,\n            },\n        )\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that the title was not updated\n        self.assertEqual(Book.objects.get(id=1).title, \"The Lord of the Rings\")\n\n        # Check that a form error was raised\n        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")\n        self.assertContains(response, \"error-message\", count=1)\n\n    def test_exclude_passed_to_extract_panel_definitions(self):\n        path_to_form_fields_exclude_property = (\n            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"\n        )\n        with mock.patch(\n            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"\n        ) as m:\n            with mock.patch(\n                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock\n            ) as mock_form_fields_exclude:\n                mock_form_fields_exclude.return_value = [\"123\"]\n\n                self.get(1)\n                self.assertTrue(mock_form_fields_exclude.called)\n                m.assert_called_with(\n                    Book, exclude=mock_form_fields_exclude.return_value\n                )\n\n    def test_clean_form_once(self):\n        with mock.patch(\n            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"\n        ) as mock_form_clean:\n            publisher = Publisher.objects.create(name=\"Sharper Collins\")\n\n            response = self.client.post(\n                \"/admin/modeladmintest/publisher/edit/%d/\" % publisher.pk, {\"name\": \"\"}\n            )\n            self.assertEqual(response.status_code, 200)\n\n            mock_form_clean.assert_called_once()\n\n    def test_edit_view_with_multifieldpanel(self):\n        # https://github.com/wagtail/wagtail/issues/6413\n        link = RelatedLink.objects.create(\n            title=\"Homepage\", link=Page.objects.filter(depth=2).first()\n        )\n        response = self.client.get(\n            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id\n        )\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(\n            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id,\n            {\n                \"title\": \"Homepage edited\",\n                \"link\": Page.objects.filter(depth=2).first().id,\n            },\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")\n\n        # Check that the link was updated\n        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage edited\").count(), 1)\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableBookEditView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, book_id, **params):\n        return self.client.get(\n            \"/admin/modeladmintest/translatablebook/edit/%d/\" % book_id, params\n        )\n\n    def test_simple(self):\n        book = TranslatableBook.objects.first()\n        response = self.get(book.id)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the locale switcher isn't there\n        self.assertNotContains(response, \"English\", html=True)\n\n        tbook = book.copy_for_translation(locale=Locale.objects.get(language_code=\"fr\"))\n        tbook.save()\n\n        response = self.get(tbook.id)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the locale switcher is there\n        expected = \"\"\"\n        <a href=\"/admin/modeladmintest/translatablebook/edit/1/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">\n            English\n        </a>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestRevisableEditView(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.login()\n        self.instance = Publisher.objects.create(name=\"foo\")\n\n    def post(self, post_data):\n        return self.client.post(\n            \"/admin/modeladmintest/publisher/edit/%s/\" % self.instance.pk, post_data\n        )\n\n    def test_edit_with_revision(self):\n        data = {\"name\": \"bar\"}\n        response = self.post(data)\n        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")\n\n        instances = Publisher.objects.filter(name=\"bar\")\n        instance = instances.first()\n        self.assertEqual(instances.count(), 1)\n\n        # The revision should be created\n        revisions = instance.revisions\n        revision = revisions.first()\n        self.assertEqual(revisions.count(), 1)\n        self.assertEqual(revision.content[\"name\"], \"bar\")\n\n        # The log entry should have the revision attached\n        log_entries = ModelLogEntry.objects.for_instance(instance).filter(\n            action=\"wagtail.edit\"\n        )\n        self.assertEqual(log_entries.count(), 1)\n        self.assertEqual(log_entries.first().revision, revision)\n\n\nclass TestPageSpecificViews(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n    expected_status_code = 404\n\n    def setUp(self):\n        self.login()\n\n    def test_choose_parent(self):\n        response = self.client.get(\"/admin/modeladmintest/book/choose_parent/\")\n        self.assertEqual(response.status_code, self.expected_status_code)\n\n\nclass TestConfirmDeleteView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/delete/%d/\" % book_id)\n\n    def post(self, book_id):\n        return self.client.post(\"/admin/modeladmintest/book/delete/%d/\" % book_id)\n\n    def test_simple(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_non_existent(self):\n        response = self.get(100)\n\n        self.assertEqual(response.status_code, 404)\n\n    def test_post(self):\n        response = self.post(1)\n\n        # User redirected to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Book deleted\n        self.assertFalse(Book.objects.filter(id=1).exists())\n\n\nclass TestDeleteViewWithProtectedRelation(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, author_id):\n        return self.client.get(\"/admin/modeladmintest/author/delete/%d/\" % author_id)\n\n    def post(self, author_id):\n        return self.client.post(\"/admin/modeladmintest/author/delete/%d/\" % author_id)\n\n    def test_get_with_dependent_object(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_get_without_dependent_object(self):\n        response = self.get(4)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_post_with_dependent_object(self):\n        response = self.post(1)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response, \"'J. R. R. Tolkien' is currently referenced by other objects\"\n        )\n        self.assertContains(response, \"<li><b>Book:</b> The Lord of the Rings</li>\")\n\n        # Author not deleted\n        self.assertTrue(Author.objects.filter(id=1).exists())\n\n    def test_post_without_dependent_object(self):\n        response = self.post(4)\n\n        # User redirected to index\n        self.assertRedirects(response, \"/admin/modeladmintest/author/\")\n\n        # Author deleted\n        self.assertFalse(Author.objects.filter(id=4).exists())\n\n    def test_post_with_1to1_dependent_object(self):\n        response = self.post(5)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response, \"'Harper Lee' is currently referenced by other objects\"\n        )\n        self.assertContains(\n            response, \"<li><b>Solo Book:</b> To Kill a Mockingbird</li>\"\n        )\n\n        # Author not deleted\n        self.assertTrue(Author.objects.filter(id=5).exists())\n\n\nclass TestDeleteViewModelReprPrimary(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def test_delete(self):\n        response = self.client.post(\"/admin/modeladmintest/token/delete/boom/\")\n        self.assertEqual(response.status_code, 302)\n\n\nclass TestEditorAccess(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        # Create a user\n        self.user = self.create_user(username=\"test2\", password=\"password\")\n        self.group = Group.objects.get(name=\"Editors\")\n        self.user.groups.add(self.group)\n        self.book_content_type = ContentType.objects.get_for_model(Book)\n\n        # Login\n        self.login(username=\"test2\", password=\"password\")\n\n    def test_index_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_inspect_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_create_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/create/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/create/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_edit_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"change_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_admin_url_finder_without_permission(self):\n        url_finder = AdminURLFinder(self.user)\n        self.assertIsNone(url_finder.get_edit_url(Book.objects.get(id=2)))\n\n    def test_admin_url_finder_with_permission(self):\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"change_book\", content_type=self.book_content_type\n            )\n        )\n        url_finder = AdminURLFinder(self.user)\n        self.assertEqual(\n            url_finder.get_edit_url(Book.objects.get(id=2)),\n            \"/admin/modeladmintest/book/edit/2/\",\n        )\n\n    def test_delete_get_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"delete_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_delete_post_permitted(self):\n        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"delete_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n\nclass TestHistoryView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n        ModelLogEntry.objects.create(\n            content_type=ContentType.objects.get_for_model(Book),\n            label=\"The Lord of the Rings\",\n            action=\"wagtail.create\",\n            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),\n            object_id=\"1\",\n        )\n\n    def test_simple(self):\n        response = self.client.get(\"/admin/modeladmintest/book/history/1/\")\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"<td>Created</td>\", html=True)\n        self.assertContains(\n            response,\n            'data-tippy-content=\"Sept. 30, 2021, 10:01 a.m.\"',\n        )\n\n\nclass TestQuoting(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n    expected_status_code = 200\n\n    def setUp(self):\n        self.login()\n        self.tok_reg = Token.objects.create(key=\"RegularName\")\n        self.tok_irr = Token.objects.create(key=\"Irregular_Name\")\n\n    def test_action_links(self):\n        response = self.client.get(\"/admin/modeladmintest/token/\")\n\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/edit/RegularName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/delete/RegularName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/edit/Irregular_5FName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/delete/Irregular_5FName/\"'\n        )\n\n        response = self.client.get(\"/admin/modeladmintest/token/edit/Irregular_5FName/\")\n        self.assertEqual(response.status_code, 200)\n        response = self.client.get(\n            \"/admin/modeladmintest/token/delete/Irregular_5FName/\"\n        )\n        self.assertEqual(response.status_code, 200)\n\n\nclass TestPanelConfigurationChecks(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.warning_id = \"wagtailadmin.W002\"\n\n        def get_checks_result():\n            # run checks only with the 'panels' tag\n            checks_result = checks.run_checks(tags=[\"panels\"])\n            return [\n                warning for warning in checks_result if warning.id == self.warning_id\n            ]\n\n        self.get_checks_result = get_checks_result\n\n    def test_model_with_single_tabbed_panel_only(self):\n        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]\n\n        warning = checks.Warning(\n            \"Publisher.content_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `content_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Content tab for the content_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        checks_results = self.get_checks_result()\n\n        self.assertIn(warning, checks_results)\n\n        # clean up for future checks\n        delattr(Publisher, \"content_panels\")\n\n    def test_model_with_two_tabbed_panels_only(self):\n        Publisher.settings_panels = [FieldPanel(\"name\")]\n        Publisher.promote_panels = [FieldPanel(\"headquartered_in\")]\n\n        warning_1 = checks.Warning(\n            \"Publisher.promote_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `promote_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Promote tab for the promote_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        warning_2 = checks.Warning(\n            \"Publisher.settings_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `settings_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Settings tab for the settings_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        checks_results = self.get_checks_result()\n\n        self.assertIn(warning_1, checks_results)\n        self.assertIn(warning_2, checks_results)\n\n        # clean up for future checks\n        delattr(Publisher, \"settings_panels\")\n        delattr(Publisher, \"promote_panels\")\n\n    def test_model_with_single_tabbed_panel_and_edit_handler(self):\n        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]\n        Publisher.edit_handler = TabbedInterface(Publisher.content_panels)\n\n        # no errors should occur\n        self.assertEqual(self.get_checks_result(), [])\n\n        # clean up for future checks\n        delattr(Publisher, \"content_panels\")\n        delattr(Publisher, \"edit_handler\")\n\n\nclass TestMenuSetting(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def test_default_menu_setting_model_admin(self):\n        modeladmin = BookModelAdmin()\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Books\")\n        self.assertEqual(menu_item.name, \"books\")\n\n    def test_custom_menu_setting_model_admin(self):\n        modeladmin = BookModelAdmin()\n        modeladmin.menu_label = \"Book Model Label\"\n        modeladmin.menu_item_name = \"bookitem\"\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Book Model Label\")\n        self.assertEqual(menu_item.name, \"bookitem\")\n\n    def test_default_menu_setting_model_admin_group(self):\n        modeladmin = EventsAdminGroup()\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Events\")\n        self.assertEqual(menu_item.name, \"events\")\n\n    def test_custom_menu_setting_model_admin_group(self):\n        modeladmin = EventsAdminGroup()\n        modeladmin.menu_label = \"Event Model Label\"\n        modeladmin.menu_item_name = \"eventitem\"\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Event Model Label\")\n        self.assertEqual(menu_item.name, \"eventitem\")\n", "code_before": "import datetime\nfrom io import BytesIO\nfrom unittest import mock\n\nfrom django.contrib.auth.models import Group, Permission\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core import checks\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.utils.timezone import make_aware\nfrom openpyxl import load_workbook\n\nfrom wagtail.admin.admin_url_finder import AdminURLFinder\nfrom wagtail.admin.panels import FieldPanel, TabbedInterface\nfrom wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler\nfrom wagtail.images.models import Image\nfrom wagtail.images.tests.utils import get_test_image_file\nfrom wagtail.models import Locale, ModelLogEntry, Page\nfrom wagtail.test.modeladmintest.models import (\n    Author,\n    Book,\n    Publisher,\n    RelatedLink,\n    Token,\n    TranslatableBook,\n)\nfrom wagtail.test.modeladmintest.wagtail_hooks import BookModelAdmin, EventsAdminGroup\nfrom wagtail.test.utils import WagtailTestUtils\n\n\nclass TestBookIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n        img = Image.objects.create(\n            title=\"LOTR cover\",\n            file=get_test_image_file(),\n        )\n        book = Book.objects.get(title=\"The Lord of the Rings\")\n        book.cover_image = img\n        book.save()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/book/\", params)\n\n    def test_thumbnail_image_col_header_text(self):\n        response = self.get()\n\n        # check thumb_col_header_text is correctly used\n        self.assertContains(\n            response,\n            '<th scope=\"col\" class=\"column-admin_thumb\">The cover</th>',\n            html=True,\n        )\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">4 out of 4</span>', html=True\n        )\n\n        # User has add permission\n        self.assertIs(response.context[\"user_can_create\"], True)\n\n    def test_csv_export(self):\n        # Export the whole queryset\n        response = self.get(export=\"csv\")\n\n        self.assertEqual(response.status_code, 200)\n        # Check attachment is present and named correctly using the modeladmin export_filename\n        self.assertEqual(\n            response.get(\"content-disposition\"),\n            'attachment; filename=\"books-export.csv\"',\n        )\n\n        # Check response - all books should be in it\n        data_lines = response.getvalue().decode().split(\"\\n\")\n        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")\n        self.assertEqual(\n            data_lines[1], \"Charlie and the Chocolate Factory,Roald Dahl,1916-09-13\\r\"\n        )\n        self.assertEqual(\n            data_lines[2], \"The Chronicles of Narnia,Roald Dahl,1898-11-29\\r\"\n        )\n        self.assertEqual(data_lines[3], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")\n        self.assertEqual(\n            data_lines[4], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"\n        )\n\n    def test_xlsx_export(self):\n        # Export the whole queryset\n        response = self.get(export=\"xlsx\")\n\n        self.assertEqual(response.status_code, 200)\n        # Check attachment is present and named correctly using the modeladmin export_filename\n        self.assertEqual(\n            response.get(\"content-disposition\"),\n            'attachment; filename=\"books-export.xlsx\"',\n        )\n\n        # Check response - all books should be in it\n        workbook_data = response.getvalue()\n        worksheet = load_workbook(filename=BytesIO(workbook_data))[\"Sheet1\"]\n        cell_array = [[cell.value for cell in row] for row in worksheet.rows]\n        self.assertEqual(cell_array[0], [\"Title\", \"Author\", \"Author Date Of Birth\"])\n        self.assertEqual(\n            cell_array[1],\n            [\"Charlie and the Chocolate Factory\", \"Roald Dahl\", \"1916-09-13\"],\n        )\n        self.assertEqual(\n            cell_array[2], [\"The Chronicles of Narnia\", \"Roald Dahl\", \"1898-11-29\"]\n        )\n        self.assertEqual(\n            cell_array[3], [\"The Hobbit\", \"J. R. R. Tolkien\", \"1892-01-03\"]\n        )\n        self.assertEqual(\n            cell_array[4], [\"The Lord of the Rings\", \"J. R. R. Tolkien\", \"1892-01-03\"]\n        )\n        self.assertEqual(len(cell_array), 5)\n\n    def test_tr_attributes(self):\n        response = self.get()\n\n        # Charlie & The Chocolate factory should be in the list with the\n        # `data-author_yob` and `data-object_pk` attributes added\n        self.assertContains(response, 'data-author-yob=\"1916\"')\n        self.assertContains(response, 'data-object-pk=\"3\"')\n\n        # There should be two odd rows and two even ones, and 'book' should be\n        # added to the `class` attribute for every one.\n        self.assertContains(response, 'class=\"book odd\"', count=2)\n        self.assertContains(response, 'class=\"book even\"', count=2)\n\n    def test_filter(self):\n        # Filter by author 1 (JRR Tolkien)\n        response = self.get(author__id__exact=1)\n\n        self.assertEqual(response.status_code, 200)\n\n        # JRR Tolkien has two books in the test data\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 4</span>', html=True\n        )\n\n        # The search form should retain the filter\n        self.assertContains(\n            response,\n            '<input type=\"hidden\" name=\"author__id__exact\" value=\"1\">',\n            html=True,\n        )\n\n        for book in response.context[\"object_list\"]:\n            self.assertEqual(book.author_id, 1)\n\n    def test_filtered_csv_export(self):\n        # Filter by author 1 (JRR Tolkien) and export the current selection\n        response = self.get(author__id__exact=1, export=\"csv\")\n\n        # Check response - only books by JRR Tolkien should be in it\n        self.assertEqual(response.status_code, 200)\n        data_lines = response.getvalue().decode().split(\"\\n\")\n        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")\n        self.assertEqual(data_lines[1], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")\n        self.assertEqual(\n            data_lines[2], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"\n        )\n        self.assertEqual(data_lines[3], \"\")\n\n    def test_search_indexed(self):\n        response = self.get(q=\"of\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are two books where the title contains 'of'\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 4</span>', html=True\n        )\n\n    def test_search_form_present(self):\n        # Test the backend search handler allows the search form to render\n        response = self.get()\n\n        self.assertContains(response, '<input id=\"id_q\"')\n\n    def test_search_form_absent(self):\n        # DjangoORMSearchHandler + no search_fields, search form should be absent\n        with mock.patch.object(\n            BookModelAdmin, \"search_handler_class\", DjangoORMSearchHandler\n        ):\n            response = self.get()\n\n            self.assertNotContains(response, '<input id=\"id_q\"')\n\n    def test_ordering(self):\n        response = self.get(o=\"0.1\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n    def test_paging(self):\n        # should be corrected to just the first page, as there aren't enough\n        # objects to make up more than one page\n        response = self.get(p=9)\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n        # Should raise a ValueError that gets caught during initialisation\n        response = self.get(p=\"notaninteger\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are four books in the test data\n        self.assertEqual(response.context[\"result_count\"], 4)\n\n\nclass TestAuthorIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/author/\", params)\n\n    def test_search(self):\n        response = self.get(q=\"Roald Dahl\")\n\n        self.assertEqual(response.status_code, 200)\n\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # The result count content is shown in the header\n        self.assertContains(\n            response, '<span class=\"result-count\">2 out of 5</span>', html=True\n        )\n\n    def test_col_extra_class_names(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <td class=\"field-first_book for-author-1 title\">The Lord of the Rings</td>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    def test_col_extra_attributes(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <td class=\"field-last_book title\" data-for_author=\"1\">The Hobbit</td>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    def test_title_column_links_to_edit_view_by_default(self):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/edit/1/\" title=\"Edit this author\">J. R. R. Tolkien</a></div>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",\n        return_value=False,\n    )\n    def test_title_column_links_to_inspect_view_when_user_cannot_edit(self, *mocks):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        test_html = \"\"\"\n            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/inspect/1/\" title=\"Inspect this author\">J. R. R. Tolkien</a></div>\n        \"\"\"\n        self.assertContains(response, test_html, html=True)\n\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_inspect_obj\",\n        return_value=False,\n    )\n    @mock.patch(\n        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",\n        return_value=False,\n    )\n    def test_title_column_is_not_linked_when_user_cannot_edit_or_inspect(self, *mocks):\n        response = self.get()\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<td class=\"field-name title\">J. R. R. Tolkien')\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableBookIndexView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/translatablebook/\", params)\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n        # There are two books in the test data\n        self.assertEqual(response.context[\"result_count\"], 2)\n\n        # Check the locale filter is there\n        expected = \"\"\"\n        <ul>\n            <li class=\"selected\">\n            <a href=\"?\">All</a></li>\n            <li>\n            <a href=\"?locale__id__exact=1\">English</a></li>\n            <li>\n            <a href=\"?locale__id__exact=2\">French</a></li>\n        </ul>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n    @override_settings(WAGTAIL_I18N_ENABLED=False)\n    def test_locale_selector_not_present_when_i18n_disabled(self):\n        response = self.get()\n\n        self.assertNotContains(\n            response, '<a href=\"?locale__id__exact=2\">French</a>', html=True\n        )\n\n    def test_filter(self):\n        # Filter by locale 2 (fr)\n        response = self.get(locale__id__exact=2)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Locale fr has one book in the test data\n        self.assertEqual(response.context[\"result_count\"], 1)\n\n        for book in response.context[\"object_list\"]:\n            self.assertEqual(book.locale_id, 2)\n\n        self.assertContains(response, \"Le Seigneur des anneaux\", html=True)\n\n\nclass TestCreateView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self):\n        return self.client.get(\"/admin/modeladmintest/book/create/\")\n\n    def post(self, post_data):\n        return self.client.post(\"/admin/modeladmintest/book/create/\", post_data)\n\n    def test_simple(self):\n        response = self.get()\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_create(self):\n        response = self.post(\n            {\n                \"title\": \"George's Marvellous Medicine\",\n                \"author\": 2,\n            }\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Check that the book was created\n        self.assertEqual(\n            Book.objects.filter(title=\"George's Marvellous Medicine\").count(), 1\n        )\n\n        response = self.client.get(\"/admin/modeladmintest/publisher/create/\")\n        self.assertIn(\"name\", response.content.decode(\"UTF-8\"))\n        self.assertNotIn(\"headquartered_in\", response.content.decode(\"UTF-8\"))\n        self.assertEqual(list(response.context[\"form\"].fields), [\"name\"])\n        self.client.post(\n            \"/admin/modeladmintest/publisher/create/\", {\"name\": \"Sharper Collins\"}\n        )\n        publisher = Publisher.objects.get(name=\"Sharper Collins\")\n        self.assertIsNone(publisher.headquartered_in)\n\n    def test_post_invalid(self):\n        initial_book_count = Book.objects.count()\n\n        response = self.post(\n            {\n                \"title\": \"\",\n                \"author\": 2,\n            }\n        )\n        final_book_count = Book.objects.count()\n\n        self.assertEqual(response.status_code, 200)\n        # Check that the book was not created\n        self.assertEqual(initial_book_count, final_book_count)\n\n        # Check that a form error was raised\n        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")\n        self.assertContains(response, \"error-message\", count=1)\n\n    def test_exclude_passed_to_extract_panel_definitions(self):\n        path_to_form_fields_exclude_property = (\n            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"\n        )\n        with mock.patch(\n            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"\n        ) as m:\n            with mock.patch(\n                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock\n            ) as mock_form_fields_exclude:\n                mock_form_fields_exclude.return_value = [\"123\"]\n\n                self.get()\n                self.assertTrue(mock_form_fields_exclude.called)\n                m.assert_called_with(\n                    Book, exclude=mock_form_fields_exclude.return_value\n                )\n\n    def test_clean_form_once(self):\n        with mock.patch(\n            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"\n        ) as mock_form_clean:\n            response = self.client.post(\n                \"/admin/modeladmintest/publisher/create/\", {\"name\": \"\"}\n            )\n            self.assertEqual(response.status_code, 200)\n\n            mock_form_clean.assert_called_once()\n\n    def test_create_view_with_multifieldpanel(self):\n        # https://github.com/wagtail/wagtail/issues/6413\n        response = self.client.get(\"/admin/modeladmintest/relatedlink/create/\")\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(\n            \"/admin/modeladmintest/relatedlink/create/\",\n            {\n                \"title\": \"Homepage\",\n                \"link\": Page.objects.filter(depth=2).first().id,\n            },\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")\n\n        # Check that the link was created\n        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage\").count(), 1)\n\n    def test_prepopulated_field_data_in_context(self):\n        response = self.get()\n        self.assertIn(\n            'data-prepopulated-fields=\"[{&quot;id&quot;: &quot;#id_title&quot;, &quot;name&quot;: &quot;title&quot;, &quot;dependency_ids&quot;: [&quot;#id_author&quot;], &quot;dependency_list&quot;: [&quot;author&quot;], &quot;maxLength&quot;: 255, &quot;allowUnicode&quot;: false}]\"',\n            response.content.decode(\"UTF-8\"),\n        )\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableCreateView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, **params):\n        return self.client.get(\"/admin/modeladmintest/translatablebook/create/\", params)\n\n    def test_simple(self):\n        response = self.get(locale=\"fr\")\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that the locale select exists and is set correctly\n        expected = '<a href=\"javascript:void(0)\" aria-label=\"French\" class=\"c-dropdown__button u-btn-current w-no-underline\">'\n        self.assertContains(response, expected)\n\n        # Check that the other locale link is right\n        expected = \"\"\"\n        <a href=\"/admin/modeladmintest/translatablebook/create/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">\n            English\n        </a>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestRevisableCreateView(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.login()\n\n    def post(self, post_data):\n        return self.client.post(\"/admin/modeladmintest/publisher/create/\", post_data)\n\n    def test_create_with_revision(self):\n        data = {\"name\": \"foo\"}\n        response = self.post(data)\n        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")\n\n        instances = Publisher.objects.filter(name=\"foo\")\n        instance = instances.first()\n        self.assertEqual(instances.count(), 1)\n\n        # The revision should be created\n        revisions = instance.revisions\n        revision = revisions.first()\n        self.assertEqual(revisions.count(), 1)\n        self.assertEqual(revision.content[\"name\"], \"foo\")\n\n        # The log entry should have the revision attached\n        log_entries = ModelLogEntry.objects.for_instance(instance).filter(\n            action=\"wagtail.create\"\n        )\n        self.assertEqual(log_entries.count(), 1)\n        self.assertEqual(log_entries.first().revision, revision)\n\n\nclass TestInspectView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n        img = Image.objects.create(\n            title=\"LOTR cover\",\n            file=get_test_image_file(),\n        )\n        book = Book.objects.get(title=\"The Lord of the Rings\")\n        book.cover_image = img\n        book.save()\n\n    def get_for_author(self, author_id):\n        return self.client.get(\"/admin/modeladmintest/author/inspect/%d/\" % author_id)\n\n    def get_for_book(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/inspect/%d/\" % book_id)\n\n    def test_author_simple(self):\n        response = self.get_for_author(1)\n        self.assertEqual(response.status_code, 200)\n\n    def test_author_name_present(self):\n        \"\"\"\n        The author name should appear twice. Once in the header, and once\n        more in the field listing\n        \"\"\"\n        response = self.get_for_author(1)\n        self.assertContains(response, \"J. R. R. Tolkien\", 2)\n\n    def test_author_dob_not_present(self):\n        \"\"\"\n        The date of birth shouldn't appear, because the field wasn't included\n        in the `inspect_view_fields` list\n        \"\"\"\n        response = self.get_for_author(1)\n        self.assertNotContains(response, \"1892\")\n\n    def test_book_simple(self):\n        response = self.get_for_book(1)\n        self.assertEqual(response.status_code, 200)\n\n    def test_book_title_present(self):\n        \"\"\"\n        The book title should appear once only, in the header, as 'title'\n        was added to the `inspect_view_fields_ignore` list\n        \"\"\"\n        response = self.get_for_book(1)\n        self.assertContains(response, \"The Lord of the Rings\", 1)\n\n    def test_book_author_present(self):\n        \"\"\"\n        The author name should appear, because 'author' is not in\n        `inspect_view_fields_ignore` and should be returned by the\n        `get_inspect_view_fields` method.\n        \"\"\"\n        response = self.get_for_book(1)\n        self.assertContains(response, \"J. R. R. Tolkien\", 1)\n\n    def test_non_existent(self):\n        response = self.get_for_book(100)\n        self.assertEqual(response.status_code, 404)\n\n    def test_back_to_listing(self):\n        response = self.client.get(\"/admin/modeladmintest/author/inspect/1/\")\n        # check that back to listing link exists\n        expected = \"\"\"\n            <p class=\"back\">\n                    <a href=\"/admin/modeladmintest/author/\">\n                        <svg class=\"icon icon-arrow-left default\" aria-hidden=\"true\">\n                            <use href=\"#icon-arrow-left\"></use>\n                        </svg>\n                        Back to author list\n                    </a>\n            </p>\n        \"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestEditView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.user = self.login()\n        ModelLogEntry.objects.create(\n            content_type=ContentType.objects.get_for_model(Book),\n            label=\"The Lord of the Rings\",\n            action=\"wagtail.create\",\n            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),\n            object_id=\"1\",\n        )\n\n    def get(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/edit/%d/\" % book_id)\n\n    def post(self, book_id, post_data):\n        return self.client.post(\n            \"/admin/modeladmintest/book/edit/%d/\" % book_id, post_data\n        )\n\n    def test_simple(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"The Lord of the Rings\")\n\n        # \"Last updated\" timestamp should be present\n        self.assertContains(\n            response, 'data-wagtail-tooltip=\"Sept. 30, 2021, 10:01 a.m.\"'\n        )\n        # History link should be present\n        self.assertContains(response, 'href=\"/admin/modeladmintest/book/history/1/\"')\n\n        url_finder = AdminURLFinder(self.user)\n        expected_url = \"/admin/modeladmintest/book/edit/1/\"\n        self.assertEqual(url_finder.get_edit_url(Book.objects.get(id=1)), expected_url)\n\n    def test_non_existent(self):\n        response = self.get(100)\n\n        self.assertEqual(response.status_code, 404)\n\n    def test_edit(self):\n        response = self.post(\n            1,\n            {\n                \"title\": \"The Lady of the Rings\",\n                \"author\": 1,\n            },\n        )\n\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Check that the book was updated\n        self.assertEqual(Book.objects.get(id=1).title, \"The Lady of the Rings\")\n\n    def test_post_invalid(self):\n        response = self.post(\n            1,\n            {\n                \"title\": \"\",\n                \"author\": 1,\n            },\n        )\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that the title was not updated\n        self.assertEqual(Book.objects.get(id=1).title, \"The Lord of the Rings\")\n\n        # Check that a form error was raised\n        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")\n        self.assertContains(response, \"error-message\", count=1)\n\n    def test_exclude_passed_to_extract_panel_definitions(self):\n        path_to_form_fields_exclude_property = (\n            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"\n        )\n        with mock.patch(\n            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"\n        ) as m:\n            with mock.patch(\n                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock\n            ) as mock_form_fields_exclude:\n                mock_form_fields_exclude.return_value = [\"123\"]\n\n                self.get(1)\n                self.assertTrue(mock_form_fields_exclude.called)\n                m.assert_called_with(\n                    Book, exclude=mock_form_fields_exclude.return_value\n                )\n\n    def test_clean_form_once(self):\n        with mock.patch(\n            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"\n        ) as mock_form_clean:\n            publisher = Publisher.objects.create(name=\"Sharper Collins\")\n\n            response = self.client.post(\n                \"/admin/modeladmintest/publisher/edit/%d/\" % publisher.pk, {\"name\": \"\"}\n            )\n            self.assertEqual(response.status_code, 200)\n\n            mock_form_clean.assert_called_once()\n\n    def test_edit_view_with_multifieldpanel(self):\n        # https://github.com/wagtail/wagtail/issues/6413\n        link = RelatedLink.objects.create(\n            title=\"Homepage\", link=Page.objects.filter(depth=2).first()\n        )\n        response = self.client.get(\n            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id\n        )\n        self.assertEqual(response.status_code, 200)\n\n        response = self.client.post(\n            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id,\n            {\n                \"title\": \"Homepage edited\",\n                \"link\": Page.objects.filter(depth=2).first().id,\n            },\n        )\n        # Should redirect back to index\n        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")\n\n        # Check that the link was updated\n        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage edited\").count(), 1)\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestTranslatableBookEditView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, book_id, **params):\n        return self.client.get(\n            \"/admin/modeladmintest/translatablebook/edit/%d/\" % book_id, params\n        )\n\n    def test_simple(self):\n        book = TranslatableBook.objects.first()\n        response = self.get(book.id)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the locale switcher isn't there\n        self.assertNotContains(response, \"English\", html=True)\n\n        tbook = book.copy_for_translation(locale=Locale.objects.get(language_code=\"fr\"))\n        tbook.save()\n\n        response = self.get(tbook.id)\n        self.assertEqual(response.status_code, 200)\n\n        # Check the locale switcher is there\n        expected = \"\"\"\n        <a href=\"/admin/modeladmintest/translatablebook/edit/1/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">\n            English\n        </a>\"\"\"\n        self.assertContains(response, expected, html=True)\n\n\nclass TestRevisableEditView(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.login()\n        self.instance = Publisher.objects.create(name=\"foo\")\n\n    def post(self, post_data):\n        return self.client.post(\n            \"/admin/modeladmintest/publisher/edit/%s/\" % self.instance.pk, post_data\n        )\n\n    def test_edit_with_revision(self):\n        data = {\"name\": \"bar\"}\n        response = self.post(data)\n        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")\n\n        instances = Publisher.objects.filter(name=\"bar\")\n        instance = instances.first()\n        self.assertEqual(instances.count(), 1)\n\n        # The revision should be created\n        revisions = instance.revisions\n        revision = revisions.first()\n        self.assertEqual(revisions.count(), 1)\n        self.assertEqual(revision.content[\"name\"], \"bar\")\n\n        # The log entry should have the revision attached\n        log_entries = ModelLogEntry.objects.for_instance(instance).filter(\n            action=\"wagtail.edit\"\n        )\n        self.assertEqual(log_entries.count(), 1)\n        self.assertEqual(log_entries.first().revision, revision)\n\n\nclass TestPageSpecificViews(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n    expected_status_code = 404\n\n    def setUp(self):\n        self.login()\n\n    def test_choose_parent(self):\n        response = self.client.get(\"/admin/modeladmintest/book/choose_parent/\")\n        self.assertEqual(response.status_code, self.expected_status_code)\n\n\nclass TestConfirmDeleteView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, book_id):\n        return self.client.get(\"/admin/modeladmintest/book/delete/%d/\" % book_id)\n\n    def post(self, book_id):\n        return self.client.post(\"/admin/modeladmintest/book/delete/%d/\" % book_id)\n\n    def test_simple(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_non_existent(self):\n        response = self.get(100)\n\n        self.assertEqual(response.status_code, 404)\n\n    def test_post(self):\n        response = self.post(1)\n\n        # User redirected to index\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n        # Book deleted\n        self.assertFalse(Book.objects.filter(id=1).exists())\n\n\nclass TestDeleteViewWithProtectedRelation(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def get(self, author_id):\n        return self.client.get(\"/admin/modeladmintest/author/delete/%d/\" % author_id)\n\n    def post(self, author_id):\n        return self.client.post(\"/admin/modeladmintest/author/delete/%d/\" % author_id)\n\n    def test_get_with_dependent_object(self):\n        response = self.get(1)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_get_without_dependent_object(self):\n        response = self.get(4)\n\n        self.assertEqual(response.status_code, 200)\n\n    def test_post_with_dependent_object(self):\n        response = self.post(1)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response, \"'J. R. R. Tolkien' is currently referenced by other objects\"\n        )\n        self.assertContains(response, \"<li><b>Book:</b> The Lord of the Rings</li>\")\n\n        # Author not deleted\n        self.assertTrue(Author.objects.filter(id=1).exists())\n\n    def test_post_without_dependent_object(self):\n        response = self.post(4)\n\n        # User redirected to index\n        self.assertRedirects(response, \"/admin/modeladmintest/author/\")\n\n        # Author deleted\n        self.assertFalse(Author.objects.filter(id=4).exists())\n\n    def test_post_with_1to1_dependent_object(self):\n        response = self.post(5)\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response, \"'Harper Lee' is currently referenced by other objects\"\n        )\n        self.assertContains(\n            response, \"<li><b>Solo Book:</b> To Kill a Mockingbird</li>\"\n        )\n\n        # Author not deleted\n        self.assertTrue(Author.objects.filter(id=5).exists())\n\n\nclass TestDeleteViewModelReprPrimary(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def test_delete(self):\n        response = self.client.post(\"/admin/modeladmintest/token/delete/boom/\")\n        self.assertEqual(response.status_code, 302)\n\n\nclass TestEditorAccess(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        # Create a user\n        self.user = self.create_user(username=\"test2\", password=\"password\")\n        self.group = Group.objects.get(name=\"Editors\")\n        self.user.groups.add(self.group)\n        self.book_content_type = ContentType.objects.get_for_model(Book)\n\n        # Login\n        self.login(username=\"test2\", password=\"password\")\n\n    def test_index_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_inspect_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_create_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/create/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"add_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/create/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_edit_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"change_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_admin_url_finder_without_permission(self):\n        url_finder = AdminURLFinder(self.user)\n        self.assertIsNone(url_finder.get_edit_url(Book.objects.get(id=2)))\n\n    def test_admin_url_finder_with_permission(self):\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"change_book\", content_type=self.book_content_type\n            )\n        )\n        url_finder = AdminURLFinder(self.user)\n        self.assertEqual(\n            url_finder.get_edit_url(Book.objects.get(id=2)),\n            \"/admin/modeladmintest/book/edit/2/\",\n        )\n\n    def test_delete_get_permitted(self):\n        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"delete_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertEqual(response.status_code, 200)\n\n    def test_delete_post_permitted(self):\n        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/\")\n\n        self.group.permissions.add(\n            Permission.objects.get(\n                codename=\"delete_book\", content_type=self.book_content_type\n            )\n        )\n        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")\n        self.assertRedirects(response, \"/admin/modeladmintest/book/\")\n\n\nclass TestHistoryView(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n        ModelLogEntry.objects.create(\n            content_type=ContentType.objects.get_for_model(Book),\n            label=\"The Lord of the Rings\",\n            action=\"wagtail.create\",\n            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),\n            object_id=\"1\",\n        )\n\n    def test_simple(self):\n        response = self.client.get(\"/admin/modeladmintest/book/history/1/\")\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"<td>Created</td>\", html=True)\n        self.assertContains(\n            response,\n            'data-tippy-content=\"Sept. 30, 2021, 10:01 a.m.\"',\n        )\n\n\nclass TestQuoting(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n    expected_status_code = 200\n\n    def setUp(self):\n        self.login()\n        self.tok_reg = Token.objects.create(key=\"RegularName\")\n        self.tok_irr = Token.objects.create(key=\"Irregular_Name\")\n\n    def test_action_links(self):\n        response = self.client.get(\"/admin/modeladmintest/token/\")\n\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/edit/RegularName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/delete/RegularName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/edit/Irregular_5FName/\"'\n        )\n        self.assertContains(\n            response, 'href=\"/admin/modeladmintest/token/delete/Irregular_5FName/\"'\n        )\n\n        response = self.client.get(\"/admin/modeladmintest/token/edit/Irregular_5FName/\")\n        self.assertEqual(response.status_code, 200)\n        response = self.client.get(\n            \"/admin/modeladmintest/token/delete/Irregular_5FName/\"\n        )\n        self.assertEqual(response.status_code, 200)\n\n\nclass TestPanelConfigurationChecks(TestCase, WagtailTestUtils):\n    def setUp(self):\n        self.warning_id = \"wagtailadmin.W002\"\n\n        def get_checks_result():\n            # run checks only with the 'panels' tag\n            checks_result = checks.run_checks(tags=[\"panels\"])\n            return [\n                warning for warning in checks_result if warning.id == self.warning_id\n            ]\n\n        self.get_checks_result = get_checks_result\n\n    def test_model_with_single_tabbed_panel_only(self):\n        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]\n\n        warning = checks.Warning(\n            \"Publisher.content_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `content_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Content tab for the content_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        checks_results = self.get_checks_result()\n\n        self.assertIn(warning, checks_results)\n\n        # clean up for future checks\n        delattr(Publisher, \"content_panels\")\n\n    def test_model_with_two_tabbed_panels_only(self):\n        Publisher.settings_panels = [FieldPanel(\"name\")]\n        Publisher.promote_panels = [FieldPanel(\"headquartered_in\")]\n\n        warning_1 = checks.Warning(\n            \"Publisher.promote_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `promote_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Promote tab for the promote_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        warning_2 = checks.Warning(\n            \"Publisher.settings_panels will have no effect on modeladmin editing\",\n            hint=\"\"\"Ensure that Publisher uses `panels` instead of `settings_panels`\\\nor set up an `edit_handler` if you want a tabbed editing interface.\nThere are no default tabs on non-Page models so there will be no\\\n Settings tab for the settings_panels to render in.\"\"\",\n            obj=Publisher,\n            id=\"wagtailadmin.W002\",\n        )\n\n        checks_results = self.get_checks_result()\n\n        self.assertIn(warning_1, checks_results)\n        self.assertIn(warning_2, checks_results)\n\n        # clean up for future checks\n        delattr(Publisher, \"settings_panels\")\n        delattr(Publisher, \"promote_panels\")\n\n    def test_model_with_single_tabbed_panel_and_edit_handler(self):\n        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]\n        Publisher.edit_handler = TabbedInterface(Publisher.content_panels)\n\n        # no errors should occur\n        self.assertEqual(self.get_checks_result(), [])\n\n        # clean up for future checks\n        delattr(Publisher, \"content_panels\")\n        delattr(Publisher, \"edit_handler\")\n\n\nclass TestMenuSetting(TestCase, WagtailTestUtils):\n    fixtures = [\"modeladmintest_test.json\"]\n\n    def setUp(self):\n        self.login()\n\n    def test_default_menu_setting_model_admin(self):\n        modeladmin = BookModelAdmin()\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Books\")\n        self.assertEqual(menu_item.name, \"books\")\n\n    def test_custom_menu_setting_model_admin(self):\n        modeladmin = BookModelAdmin()\n        modeladmin.menu_label = \"Book Model Label\"\n        modeladmin.menu_item_name = \"bookitem\"\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Book Model Label\")\n        self.assertEqual(menu_item.name, \"bookitem\")\n\n    def test_default_menu_setting_model_admin_group(self):\n        modeladmin = EventsAdminGroup()\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Events\")\n        self.assertEqual(menu_item.name, \"events\")\n\n    def test_custom_menu_setting_model_admin_group(self):\n        modeladmin = EventsAdminGroup()\n        modeladmin.menu_label = \"Event Model Label\"\n        modeladmin.menu_item_name = \"eventitem\"\n\n        menu_item = modeladmin.get_menu_item()\n        self.assertEqual(menu_item.label, \"Event Model Label\")\n        self.assertEqual(menu_item.name, \"eventitem\")\n", "patch": "@@ -13,6 +13,8 @@\n from wagtail.admin.admin_url_finder import AdminURLFinder\n from wagtail.admin.panels import FieldPanel, TabbedInterface\n from wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler\n+from wagtail.documents.models import Document\n+from wagtail.documents.tests.utils import get_test_document_file\n from wagtail.images.models import Image\n from wagtail.images.tests.utils import get_test_image_file\n from wagtail.models import Locale, ModelLogEntry, Page\n@@ -591,6 +593,20 @@ def test_book_author_present(self):\n         response = self.get_for_book(1)\n         self.assertContains(response, \"J. R. R. Tolkien\", 1)\n \n+    def test_book_extract_document_html_escaping(self):\n+        doc = Document.objects.create(\n+            title=\"Title with <script>alert('XSS')</script>\",\n+            file=get_test_document_file(),\n+        )\n+        book = Book.objects.get(title=\"The Lord of the Rings\")\n+        book.extract_document = doc\n+        book.save()\n+        response = self.get_for_book(1)\n+        self.assertNotContains(response, \"Title with <script>alert('XSS')</script>\")\n+        self.assertContains(\n+            response, \"Title with &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;\"\n+        )\n+\n     def test_non_existent(self):\n         response = self.get_for_book(100)\n         self.assertEqual(response.status_code, 404)", "file_path": "files/2023_4/1008", "file_language": "py", "file_name": "wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/wagtail/wagtail/raw/ff806ab173a504395fdfb3139eb0a29444ab4b91/wagtail%2Fcontrib%2Fmodeladmin%2Fviews.py", "code": "import warnings\nfrom collections import OrderedDict\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.admin import FieldListFilter\nfrom django.contrib.admin.options import IncorrectLookupParameters\nfrom django.contrib.admin.utils import (\n    get_fields_from_path,\n    label_for_field,\n    lookup_field,\n    prepare_lookup_value,\n    quote,\n    unquote,\n)\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.exceptions import (\n    FieldDoesNotExist,\n    ImproperlyConfigured,\n    ObjectDoesNotExist,\n    PermissionDenied,\n    SuspiciousOperation,\n)\nfrom django.core.paginator import InvalidPage, Paginator\nfrom django.db import models, transaction\nfrom django.db.models.fields.related import ManyToManyField, OneToOneRel\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.template.defaultfilters import filesizeformat\nfrom django.utils.decorators import method_decorator\nfrom django.utils.encoding import force_str\nfrom django.utils.functional import cached_property\nfrom django.utils.html import format_html\nfrom django.utils.http import urlencode\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.views.generic import TemplateView\nfrom django.views.generic.edit import FormView\nfrom django.views.generic.list import MultipleObjectMixin\n\nfrom wagtail.admin import messages\nfrom wagtail.admin.ui.tables import Column, DateColumn, Table, UserColumn\nfrom wagtail.admin.views.generic.base import WagtailAdminTemplateMixin\nfrom wagtail.admin.views.mixins import SpreadsheetExportMixin\nfrom wagtail.log_actions import log\nfrom wagtail.log_actions import registry as log_registry\nfrom wagtail.models import Locale, RevisionMixin, TranslatableMixin\nfrom wagtail.utils.deprecation import RemovedInWagtail50Warning\n\nfrom .forms import ParentChooserForm\n\ntry:\n    from django.contrib.admin.utils import lookup_spawns_duplicates\nexcept ImportError:\n    # fallback for Django <4.0\n    from django.contrib.admin.utils import (\n        lookup_needs_distinct as lookup_spawns_duplicates,\n    )\n\n\nQUERY_TERMS = {\n    \"contains\",\n    \"day\",\n    \"endswith\",\n    \"exact\",\n    \"gt\",\n    \"gte\",\n    \"hour\",\n    \"icontains\",\n    \"iendswith\",\n    \"iexact\",\n    \"in\",\n    \"iregex\",\n    \"isnull\",\n    \"istartswith\",\n    \"lt\",\n    \"lte\",\n    \"minute\",\n    \"month\",\n    \"range\",\n    \"regex\",\n    \"search\",\n    \"second\",\n    \"startswith\",\n    \"week_day\",\n    \"year\",\n}\n\n\nclass WMABaseView(TemplateView):\n    \"\"\"\n    Groups together common functionality for all app views.\n    \"\"\"\n\n    model_admin = None\n    meta_title = \"\"\n    page_title = \"\"\n    page_subtitle = \"\"\n\n    def __init__(self, model_admin):\n        self.model_admin = model_admin\n        self.model = model_admin.model\n        self.opts = self.model._meta\n        self.app_label = force_str(self.opts.app_label)\n        self.model_name = force_str(self.opts.model_name)\n        self.verbose_name = force_str(self.opts.verbose_name)\n        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)\n        self.pk_attname = self.opts.pk.attname\n        self.is_pagemodel = model_admin.is_pagemodel\n        self.permission_helper = model_admin.permission_helper\n        self.url_helper = model_admin.url_helper\n\n    def check_action_permitted(self, user):\n        return True\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        button_helper_class = self.model_admin.get_button_helper_class()\n        self.button_helper = button_helper_class(self, request)\n        return super().dispatch(request, *args, **kwargs)\n\n    @cached_property\n    def menu_icon(self):\n        return self.model_admin.get_menu_icon()\n\n    @cached_property\n    def header_icon(self):\n        return self.menu_icon\n\n    def get_page_title(self):\n        return self.page_title or capfirst(self.opts.verbose_name_plural)\n\n    def get_meta_title(self):\n        return self.meta_title or self.get_page_title()\n\n    @cached_property\n    def index_url(self):\n        return self.url_helper.index_url\n\n    @cached_property\n    def create_url(self):\n        return self.url_helper.create_url\n\n    def get_base_queryset(self, request=None):\n        return self.model_admin.get_queryset(request or self.request)\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"view\": self,\n            \"model_admin\": self.model_admin,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n\nclass ModelFormView(WMABaseView, FormView):\n    def setup(self, request, *args, **kwargs):\n        super().setup(request, *args, **kwargs)\n        self.edit_handler = self.get_edit_handler()\n\n    def get_form(self):\n        form = super().get_form()\n        return form\n\n    def get_edit_handler(self):\n        try:\n            edit_handler = self.model_admin.get_edit_handler()\n        except TypeError:\n            edit_handler = self.model_admin.get_edit_handler(\n                instance=None, request=None\n            )\n            warnings.warn(\n                \"%s.get_edit_handler should not accept instance or request arguments\"\n                % type(self.model_admin).__name__,\n                category=RemovedInWagtail50Warning,\n            )\n\n        return edit_handler.bind_to_model(self.model_admin.model)\n\n    def get_form_class(self):\n        return self.edit_handler.get_form_class()\n\n    def get_success_url(self):\n        return self.index_url\n\n    def get_instance(self):\n        return getattr(self, \"instance\", None) or self.model()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})\n        return kwargs\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_form_view_extra_css()},\n            js=self.model_admin.get_form_view_extra_js(),\n        )\n\n    def get_context_data(self, form=None, **kwargs):\n        if form is None:\n            form = self.get_form()\n\n        bound_panel = self.edit_handler.get_bound_panel(\n            form=form, instance=form.instance, request=self.request\n        )\n\n        prepopulated_fields = self.get_prepopulated_fields(form)\n        context = {\n            \"is_multipart\": form.is_multipart(),\n            \"edit_handler\": bound_panel,\n            \"form\": form,\n            \"prepopulated_fields\": prepopulated_fields,\n            \"media\": self.media + bound_panel.media + form.media,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_prepopulated_fields(self, form):\n        fields = []\n        for field_name, dependencies in self.model_admin.get_prepopulated_fields(\n            self.request\n        ).items():\n            missing_dependencies = [\n                f\"'{f}'\" for f in dependencies if f not in form.fields\n            ]\n            if len(missing_dependencies) != 0:\n                missing_deps_string = \", \".join(missing_dependencies)\n                dependency_string = (\n                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"\n                )\n                warnings.warn(\n                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",\n                    category=RuntimeWarning,\n                )\n            elif field_name in form.fields:\n                fields.append(\n                    {\n                        \"field\": form[field_name],\n                        \"dependencies\": [form[f] for f in dependencies],\n                    }\n                )\n        return fields\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' created.\") % {\n            \"model_name\": capfirst(self.opts.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_success_message_buttons(self, instance):\n        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))\n        return [messages.button(button_url, _(\"Edit\"))]\n\n    def get_error_message(self):\n        model_name = self.verbose_name\n        return _(\"The %(object)s could not be created due to errors.\") % {\n            \"object\": model_name\n        }\n\n    def form_valid(self, form):\n        self.instance = form.save()\n        messages.success(\n            self.request,\n            self.get_success_message(self.instance),\n            buttons=self.get_success_message_buttons(self.instance),\n        )\n        return redirect(self.get_success_url())\n\n    def form_invalid(self, form):\n        messages.validation_error(self.request, self.get_error_message(), form)\n        return self.render_to_response(self.get_context_data(form=form))\n\n\nclass InstanceSpecificView(WMABaseView):\n\n    instance_pk = None\n    pk_quoted = None\n    instance = None\n    locale = None\n\n    def __init__(self, model_admin, instance_pk):\n        super().__init__(model_admin)\n        self.instance_pk = unquote(instance_pk)\n        self.pk_quoted = quote(self.instance_pk)\n        filter_kwargs = {}\n        filter_kwargs[self.pk_attname] = self.instance_pk\n        object_qs = model_admin.model._default_manager.get_queryset().filter(\n            **filter_kwargs\n        )\n        self.instance = get_object_or_404(object_qs)\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            model_admin.model, TranslatableMixin\n        ):\n            self.locale = self.instance.locale\n\n    def get_page_subtitle(self):\n        return self.instance\n\n    @cached_property\n    def edit_url(self):\n        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)\n\n    @cached_property\n    def delete_url(self):\n        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)\n\n    def get_context_data(self, **kwargs):\n        context = {\"instance\": self.instance}\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n\nclass IndexView(SpreadsheetExportMixin, WMABaseView):\n\n    ORDER_VAR = \"o\"\n    ORDER_TYPE_VAR = \"ot\"\n    PAGE_VAR = \"p\"\n    SEARCH_VAR = \"q\"\n    ERROR_FLAG = \"e\"\n    EXPORT_VAR = \"export\"\n    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)\n\n    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers\n    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by\n    sortable_by = None\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        # Only continue if logged in user has list permission\n        if not self.permission_helper.user_can_list(request.user):\n            raise PermissionDenied\n\n        self.list_export = self.model_admin.get_list_export(request)\n        self.list_display = self.model_admin.get_list_display(request)\n        self.list_filter = self.model_admin.get_list_filter(request)\n        self.search_fields = self.model_admin.get_search_fields(request)\n        self.items_per_page = self.model_admin.list_per_page\n        self.select_related = self.model_admin.list_select_related\n        self.search_handler = self.model_admin.get_search_handler(\n            request, self.search_fields\n        )\n        self.export = request.GET.get(self.EXPORT_VAR)\n\n        # Get search parameters from the query string.\n        try:\n            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))\n        except ValueError:\n            self.page_num = 0\n\n        self.params = dict(request.GET.items())\n        if self.PAGE_VAR in self.params:\n            del self.params[self.PAGE_VAR]\n        if self.ERROR_FLAG in self.params:\n            del self.params[self.ERROR_FLAG]\n        if self.EXPORT_VAR in self.params:\n            del self.params[self.EXPORT_VAR]\n\n        self.query = request.GET.get(self.SEARCH_VAR, \"\")\n\n        self.queryset = self.get_queryset(request)\n\n        if self.export in self.FORMATS:\n            return self.as_spreadsheet(self.queryset, self.export)\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_filename(self):\n        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"\n        return getattr(self.model_admin, \"export_filename\", super().get_filename())\n\n    def get_heading(self, queryset, field):\n        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"\n        heading_override = self.export_headings.get(field)\n        if heading_override:\n            return force_str(heading_override)\n        return force_str(\n            label_for_field(\n                field, model=self.model, model_admin=self.model_admin\n            ).title()\n        )\n\n    def to_row_dict(self, item):\n        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"\n        row_dict = OrderedDict()\n        for field in self.list_export:\n            f, attr, value = lookup_field(field, item, self.model_admin)\n            if not value:\n                value = getattr(\n                    attr,\n                    \"empty_value_display\",\n                    self.model_admin.get_empty_value_display(field),\n                )\n            row_dict[field] = value\n\n        return row_dict\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_index_view_extra_css()},\n            js=self.model_admin.get_index_view_extra_js(),\n        )\n\n    def get_buttons_for_obj(self, obj):\n        return self.button_helper.get_buttons_for_obj(\n            obj, classnames_add=[\"button-small\"]\n        )\n\n    def get_search_results(self, request, queryset, search_term):\n        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)\n        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET\n        return self.search_handler.search_queryset(queryset, search_term, **kwargs)\n\n    def get_filters_params(self, params=None):\n        \"\"\"\n        Returns all params except IGNORED_PARAMS\n        \"\"\"\n        if not params:\n            params = self.params\n        lookup_params = params.copy()  # a dictionary of the query string\n        # Remove all the parameters that are globally and systematically\n        # ignored.\n        for ignored in self.IGNORED_PARAMS:\n            if ignored in lookup_params:\n                del lookup_params[ignored]\n        return lookup_params\n\n    def get_filters(self, request):\n        lookup_params = self.get_filters_params()\n        use_distinct = False\n\n        filter_specs = []\n        if self.list_filter:\n            for list_filter in self.list_filter:\n                if callable(list_filter):\n                    # This is simply a custom list filter class.\n                    spec = list_filter(\n                        request, lookup_params, self.model, self.model_admin\n                    )\n                else:\n                    field_path = None\n                    if isinstance(list_filter, (tuple, list)):\n                        # This is a custom FieldListFilter class for a given\n                        # field.\n                        field, field_list_filter_class = list_filter\n                    else:\n                        # This is simply a field name, so use the default\n                        # FieldListFilter class that has been registered for\n                        # the type of the given field.\n                        field = list_filter\n                        field_list_filter_class = FieldListFilter.create\n                    if not isinstance(field, models.Field):\n                        field_path = field\n                        field = get_fields_from_path(self.model, field_path)[-1]\n                    spec = field_list_filter_class(\n                        field,\n                        request,\n                        lookup_params,\n                        self.model,\n                        self.model_admin,\n                        field_path=field_path,\n                    )\n\n                    # Check if we need to use distinct()\n                    use_distinct = use_distinct or lookup_spawns_duplicates(\n                        self.opts, field_path\n                    )\n                if spec and spec.has_output():\n                    filter_specs.append(spec)\n\n        # At this point, all the parameters used by the various ListFilters\n        # have been removed from lookup_params, which now only contains other\n        # parameters passed via the query string. We now loop through the\n        # remaining parameters both to ensure that all the parameters are valid\n        # fields and to determine if at least one of them needs distinct(). If\n        # the lookup parameters aren't real fields, then bail out.\n        try:\n            for key, value in lookup_params.items():\n                lookup_params[key] = prepare_lookup_value(key, value)\n                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)\n            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)\n        except FieldDoesNotExist as e:\n            raise IncorrectLookupParameters from e\n\n    def get_query_string(self, new_params=None, remove=None):\n        if new_params is None:\n            new_params = {}\n        if remove is None:\n            remove = []\n        p = self.params.copy()\n        for r in remove:\n            for k in list(p):\n                if k.startswith(r):\n                    del p[k]\n        for k, v in new_params.items():\n            if v is None:\n                if k in p:\n                    del p[k]\n            else:\n                p[k] = v\n        return \"?%s\" % urlencode(sorted(p.items()))\n\n    def _get_default_ordering(self):\n        ordering = []\n        if self.model_admin.ordering:\n            ordering = self.model_admin.ordering\n        elif self.opts.ordering:\n            ordering = self.opts.ordering\n        return ordering\n\n    def get_default_ordering(self, request):\n        if self.model_admin.get_ordering(request):\n            return self.model_admin.get_ordering(request)\n        if self.opts.ordering:\n            return self.opts.ordering\n        return ()\n\n    def get_ordering_field(self, field_name):\n        \"\"\"\n        Returns the proper model field name corresponding to the given\n        field_name to use for ordering. field_name may either be the name of a\n        proper model field or the name of a method (on the admin or model) or a\n        callable with the 'admin_order_field' attribute. Returns None if no\n        proper model field name can be matched.\n        \"\"\"\n        try:\n            field = self.opts.get_field(field_name)\n            return field.name\n        except FieldDoesNotExist:\n            # See whether field_name is a name of a non-field\n            # that allows sorting.\n            if callable(field_name):\n                attr = field_name\n            elif hasattr(self.model_admin, field_name):\n                attr = getattr(self.model_admin, field_name)\n            else:\n                attr = getattr(self.model, field_name)\n            return getattr(attr, \"admin_order_field\", None)\n\n    def get_ordering(self, request, queryset):\n        \"\"\"\n        Returns the list of ordering fields for the change list.\n        First we check the get_ordering() method in model admin, then we check\n        the object's default ordering. Then, any manually-specified ordering\n        from the query string overrides anything. Finally, a deterministic\n        order is guaranteed by ensuring the primary key is used as the last\n        ordering field.\n        \"\"\"\n        params = self.params\n        ordering = list(self.get_default_ordering(request))\n        if self.ORDER_VAR in params:\n            # Clear ordering and used params\n            ordering = []\n            order_params = params[self.ORDER_VAR].split(\".\")\n            for p in order_params:\n                try:\n                    none, pfx, idx = p.rpartition(\"-\")\n                    field_name = self.list_display[int(idx)]\n                    order_field = self.get_ordering_field(field_name)\n                    if not order_field:\n                        continue  # No 'admin_order_field', skip it\n                    # reverse order if order_field has already \"-\" as prefix\n                    if order_field.startswith(\"-\") and pfx == \"-\":\n                        ordering.append(order_field[1:])\n                    else:\n                        ordering.append(pfx + order_field)\n                except (IndexError, ValueError):\n                    continue  # Invalid ordering specified, skip it.\n\n        # Add the given query's ordering fields, if any.\n        ordering.extend(queryset.query.order_by)\n\n        # Ensure that the primary key is systematically present in the list of\n        # ordering fields so we can guarantee a deterministic order across all\n        # database backends.\n        pk_name = self.opts.pk.name\n\n        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):\n            # ordering isn't already being applied to pk\n            ordering.append(\"-\" + pk_name)\n\n        return ordering\n\n    def get_ordering_field_columns(self):\n        \"\"\"\n        Returns an OrderedDict of ordering field column numbers and asc/desc\n        \"\"\"\n\n        # We must cope with more than one column having the same underlying\n        # sort field, so we base things on column numbers.\n        ordering = self._get_default_ordering()\n        ordering_fields = OrderedDict()\n        if self.ORDER_VAR not in self.params:\n            # for ordering specified on model_admin or model Meta, we don't\n            # know the right column numbers absolutely, because there might be\n            # morr than one column associated with that ordering, so we guess.\n            for field in ordering:\n                if field.startswith(\"-\"):\n                    field = field[1:]\n                    order_type = \"desc\"\n                else:\n                    order_type = \"asc\"\n                for index, attr in enumerate(self.list_display):\n                    if self.get_ordering_field(attr) == field:\n                        ordering_fields[index] = order_type\n                        break\n        else:\n            for p in self.params[self.ORDER_VAR].split(\".\"):\n                none, pfx, idx = p.rpartition(\"-\")\n                try:\n                    idx = int(idx)\n                except ValueError:\n                    continue  # skip it\n                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"\n        return ordering_fields\n\n    def get_queryset(self, request=None):\n        request = request or self.request\n\n        # First, we collect all the declared list filters.\n        (\n            self.filter_specs,\n            self.has_filters,\n            remaining_lookup_params,\n            filters_use_distinct,\n        ) = self.get_filters(request)\n\n        # Then, we let every list filter modify the queryset to its liking.\n        qs = self.get_base_queryset(request)\n        for filter_spec in self.filter_specs:\n            new_qs = filter_spec.queryset(request, qs)\n            if new_qs is not None:\n                qs = new_qs\n\n        try:\n            # Finally, we apply the remaining lookup parameters from the query\n            # string (i.e. those that haven't already been processed by the\n            # filters).\n            qs = qs.filter(**remaining_lookup_params)\n        except (SuspiciousOperation, ImproperlyConfigured):\n            # Allow certain types of errors to be re-raised as-is so that the\n            # caller can treat them in a special way.\n            raise\n        except Exception as e:\n            # Every other error is caught with a naked except, because we don't\n            # have any other way of validating lookup parameters. They might be\n            # invalid if the keyword arguments are incorrect, or if the values\n            # are not in the correct type, so we might get FieldError,\n            # ValueError, ValidationError, or ?.\n            raise IncorrectLookupParameters(e)\n\n        if not qs.query.select_related:\n            qs = self.apply_select_related(qs)\n\n        # Set ordering.\n        ordering = self.get_ordering(request, qs)\n        qs = qs.order_by(*ordering)\n\n        # Remove duplicates from results, if necessary\n        if filters_use_distinct:\n            qs = qs.distinct()\n\n        # Apply search results\n        return self.get_search_results(request, qs, self.query)\n\n    def apply_select_related(self, qs):\n        if self.select_related is True:\n            return qs.select_related()\n\n        if self.select_related is False:\n            if self.has_related_field_in_list_display():\n                return qs.select_related()\n\n        if self.select_related:\n            return qs.select_related(*self.select_related)\n        return qs\n\n    def has_related_field_in_list_display(self):\n        for field_name in self.list_display:\n            try:\n                field = self.opts.get_field(field_name)\n            except FieldDoesNotExist:\n                pass\n            else:\n                if isinstance(field, models.ManyToOneRel):\n                    return True\n        return False\n\n    def get_context_data(self, **kwargs):\n        user = self.request.user\n        all_count = self.get_base_queryset().count()\n        queryset = self.get_queryset()\n        result_count = queryset.count()\n        paginator = Paginator(queryset, self.items_per_page)\n\n        try:\n            page_obj = paginator.page(self.page_num + 1)\n        except InvalidPage:\n            page_obj = paginator.page(1)\n\n        context = {\n            \"view\": self,\n            \"all_count\": all_count,\n            \"result_count\": result_count,\n            \"paginator\": paginator,\n            \"page_obj\": page_obj,\n            \"object_list\": page_obj.object_list,\n            \"user_can_create\": self.permission_helper.user_can_create(user),\n            \"show_search\": self.search_handler.show_search_form,\n        }\n\n        if self.is_pagemodel:\n            models = self.model.allowed_parent_page_models()\n            allowed_parent_types = [m._meta.verbose_name for m in models]\n            valid_parents = self.permission_helper.get_valid_parent_pages(user)\n            valid_parent_count = valid_parents.count()\n            context.update(\n                {\n                    \"no_valid_parents\": not valid_parent_count,\n                    \"required_parent_types\": allowed_parent_types,\n                }\n            )\n\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_index_template()\n\n\nclass CreateView(ModelFormView):\n    page_title = gettext_lazy(\"New\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_create(user)\n\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            user = request.user\n            parents = self.permission_helper.get_valid_parent_pages(user)\n            parent_count = parents.count()\n\n            # There's only one available parent for this page type for this\n            # user, so we send them along with that as the chosen parent page\n            if parent_count == 1:\n                parent = parents.get()\n                parent_pk = quote(parent.pk)\n                return redirect(\n                    self.url_helper.get_action_url(\n                        \"add\", self.app_label, self.model_name, parent_pk\n                    )\n                )\n\n            # The page can be added in multiple places, so redirect to the\n            # choose_parent view so that the parent can be specified\n            return redirect(self.url_helper.get_action_url(\"choose_parent\"))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                locale = get_object_or_404(Locale, language_code=selected_locale)\n            else:\n                locale = Locale.get_default()\n\n            kwargs.update(\n                {\n                    \"locale\": locale,\n                    \"translations\": [\n                        {\n                            \"locale\": locale,\n                            \"url\": self.create_url + \"?locale=\" + locale.language_code,\n                        }\n                        for locale in Locale.objects.all().exclude(id=locale.id)\n                    ],\n                }\n            )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(user=self.request.user)\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.create\",\n            revision=revision,\n            content_changed=True,\n        )\n        return response\n\n    def get_meta_title(self):\n        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_page_subtitle(self):\n        return capfirst(self.verbose_name)\n\n    def get_template_names(self):\n        return self.model_admin.get_create_template()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                kwargs[\"instance\"].locale = get_object_or_404(\n                    Locale, language_code=selected_locale\n                )\n\n        return kwargs\n\n\nclass EditView(ModelFormView, InstanceSpecificView):\n    page_title = gettext_lazy(\"Editing\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_edit_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"edit\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' updated.\") % {\n            \"model_name\": capfirst(self.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"user_can_delete\": self.permission_helper.user_can_delete_obj(\n                self.request.user, self.instance\n            )\n        }\n        context.update(kwargs)\n        if self.model_admin.history_view_enabled:\n            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(\n                self.instance\n            ).first()\n            context[\"history_url\"] = self.url_helper.get_action_url(\n                \"history\", quote(self.instance.pk)\n            )\n        else:\n            context[\"latest_log_entry\"] = None\n            context[\"history_url\"] = None\n\n        return super().get_context_data(**context)\n\n    def get_error_message(self):\n        name = self.verbose_name\n        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}\n\n    def get_template_names(self):\n        return self.model_admin.get_edit_template()\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        self.has_content_changes = form.has_changed()\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(\n                user=self.request.user,\n                changed=self.has_content_changes,\n            )\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.edit\",\n            revision=revision,\n            content_changed=self.has_content_changes,\n        )\n        return response\n\n\nclass ChooseParentView(WMABaseView):\n    def dispatch(self, request, *args, **kwargs):\n        if not self.permission_helper.user_can_create(request.user):\n            raise PermissionDenied\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_page_title(self):\n        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_form(self, request):\n        parents = self.permission_helper.get_valid_parent_pages(request.user)\n        return ParentChooserForm(parents, request.POST or None)\n\n    def get(self, request, *args, **kwargs):\n        form = self.get_form(request)\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def post(self, request, *args, **kargs):\n        form = self.get_form(request)\n        if form.is_valid():\n            return self.form_valid(form)\n        return self.form_invalid(form)\n\n    def form_valid(self, form):\n        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)\n        return redirect(\n            self.url_helper.get_action_url(\n                \"add\", self.app_label, self.model_name, parent_pk\n            )\n        )\n\n    def form_invalid(self, form):\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_choose_parent_template()\n\n\nclass DeleteView(InstanceSpecificView):\n    page_title = gettext_lazy(\"Delete\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_delete_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}\n\n    def confirmation_message(self):\n        return _(\n            \"Are you sure you want to delete this %(object)s? If other things in your \"\n            \"site are related to it, they may also be affected.\"\n        ) % {\"object\": self.verbose_name}\n\n    def delete_instance(self):\n        self.instance.delete()\n\n    def post(self, request, *args, **kwargs):\n        try:\n            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {\n                \"model_name\": self.verbose_name,\n                \"object\": self.instance,\n            }\n            with transaction.atomic():\n                log(instance=self.instance, action=\"wagtail.delete\")\n                self.delete_instance()\n            messages.success(request, msg)\n            return redirect(self.index_url)\n        except models.ProtectedError:\n            linked_objects = []\n            fields = self.model._meta.fields_map.values()\n            fields = (\n                obj for obj in fields if not isinstance(obj.field, ManyToManyField)\n            )\n            for rel in fields:\n                if rel.on_delete == models.PROTECT:\n                    if isinstance(rel, OneToOneRel):\n                        try:\n                            obj = getattr(self.instance, rel.get_accessor_name())\n                        except ObjectDoesNotExist:\n                            pass\n                        else:\n                            linked_objects.append(obj)\n                    else:\n                        qs = getattr(self.instance, rel.get_accessor_name())\n                        for obj in qs.all():\n                            linked_objects.append(obj)\n            context = self.get_context_data(\n                protected_error=True, linked_objects=linked_objects\n            )\n            return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_delete_template()\n\n\nclass InspectView(InstanceSpecificView):\n\n    page_title = gettext_lazy(\"Inspecting\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_inspect_obj(user, self.instance)\n\n    def dispatch(self, request, *args, **kwargs):\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model_admin.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"inspect\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_inspect_view_extra_css()},\n            js=self.model_admin.get_inspect_view_extra_js(),\n        )\n\n    def get_meta_title(self):\n        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_field_label(self, field_name, field=None):\n        \"\"\"Return a label to display for a field\"\"\"\n        return label_for_field(field_name, model=self.model)\n\n    def get_field_display_value(self, field_name, field=None):\n        \"\"\"Return a display value for a field/attribute\"\"\"\n\n        # First we check for a 'get_fieldname_display' property/method on\n        # the model, and return the value of that, if present.\n        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)\n        if val_funct is not None:\n            if callable(val_funct):\n                return val_funct()\n            return val_funct\n\n        # Now let's get the attribute value from the instance itself and see if\n        # we can render something useful. raises AttributeError appropriately.\n        val = getattr(self.instance, field_name)\n\n        if isinstance(val, models.Manager):\n            val = val.all()\n\n        if isinstance(val, models.QuerySet):\n            if val.exists():\n                return \", \".join([\"%s\" % obj for obj in val])\n            return self.model_admin.get_empty_value_display(field_name)\n\n        # wagtail.images might not be installed\n        try:\n            from wagtail.images.models import AbstractImage\n\n            if isinstance(val, AbstractImage):\n                # Render a rendition of the image\n                return self.get_image_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # wagtail.wagtaildocuments might not be installed\n        try:\n            from wagtail.documents.models import AbstractDocument\n\n            if isinstance(val, AbstractDocument):\n                # Render a link to the document\n                return self.get_document_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # Resort to returning the real value or 'empty value'\n        if val or val is False:\n            return val\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_image_field_display(self, field_name, field):\n        \"\"\"Render an image\"\"\"\n        from wagtail.images.shortcuts import get_rendition_or_not_found\n\n        image = getattr(self.instance, field_name)\n        if image:\n            return get_rendition_or_not_found(image, \"max-400x400\").img_tag\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_document_field_display(self, field_name, field):\n        \"\"\"Render a link to a document\"\"\"\n        document = getattr(self.instance, field_name)\n        if document:\n            return format_html(\n                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',\n                document.url,\n                document.title,\n                document.file_extension.upper(),\n                filesizeformat(document.file.size),\n            )\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_dict_for_field(self, field_name):\n        \"\"\"\n        Return a dictionary containing `label` and `value` values to display\n        for a field.\n        \"\"\"\n        try:\n            field = self.model._meta.get_field(field_name)\n        except FieldDoesNotExist:\n            field = None\n        return {\n            \"label\": self.get_field_label(field_name, field),\n            \"value\": self.get_field_display_value(field_name, field),\n        }\n\n    def get_fields_dict(self):\n        \"\"\"\n        Return a list of `label`/`value` dictionaries to represent the\n        fields named by the model_admin class's `get_inspect_view_fields` method\n        \"\"\"\n        fields = []\n        for field_name in self.model_admin.get_inspect_view_fields():\n            fields.append(self.get_dict_for_field(field_name))\n        return fields\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"fields\": self.get_fields_dict(),\n            \"buttons\": self.button_helper.get_buttons_for_obj(\n                self.instance, exclude=[\"inspect\"]\n            ),\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_inspect_template()\n\n\nclass HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):\n    page_title = gettext_lazy(\"History\")\n    paginate_by = 50\n    columns = [\n        Column(\"message\", label=gettext_lazy(\"Action\")),\n        UserColumn(\"user\", blank_display_name=\"system\"),\n        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),\n    ]\n\n    def get_page_subtitle(self):\n        return str(self.instance)\n\n    def get_template_names(self):\n        return self.model_admin.get_history_template()\n\n    def get_queryset(self):\n        return log_registry.get_logs_for_instance(self.instance).prefetch_related(\n            \"user__wagtail_userprofile\"\n        )\n\n    def get_context_data(self, **kwargs):\n        self.object_list = self.get_queryset()\n        context = super().get_context_data(**kwargs)\n        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))\n        table = Table(\n            self.columns,\n            context[\"object_list\"],\n            base_url=index_url,\n            ordering=self.get_ordering(),\n        )\n\n        context[\"table\"] = table\n        context[\"media\"] = table.media\n        context[\"index_url\"] = index_url\n        context[\"is_paginated\"] = True\n        return context\n", "code_before": "import warnings\nfrom collections import OrderedDict\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.admin import FieldListFilter\nfrom django.contrib.admin.options import IncorrectLookupParameters\nfrom django.contrib.admin.utils import (\n    get_fields_from_path,\n    label_for_field,\n    lookup_field,\n    prepare_lookup_value,\n    quote,\n    unquote,\n)\nfrom django.contrib.auth.decorators import login_required\nfrom django.core.exceptions import (\n    FieldDoesNotExist,\n    ImproperlyConfigured,\n    ObjectDoesNotExist,\n    PermissionDenied,\n    SuspiciousOperation,\n)\nfrom django.core.paginator import InvalidPage, Paginator\nfrom django.db import models, transaction\nfrom django.db.models.fields.related import ManyToManyField, OneToOneRel\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.template.defaultfilters import filesizeformat\nfrom django.utils.decorators import method_decorator\nfrom django.utils.encoding import force_str\nfrom django.utils.functional import cached_property\nfrom django.utils.http import urlencode\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import capfirst\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.views.generic import TemplateView\nfrom django.views.generic.edit import FormView\nfrom django.views.generic.list import MultipleObjectMixin\n\nfrom wagtail.admin import messages\nfrom wagtail.admin.ui.tables import Column, DateColumn, Table, UserColumn\nfrom wagtail.admin.views.generic.base import WagtailAdminTemplateMixin\nfrom wagtail.admin.views.mixins import SpreadsheetExportMixin\nfrom wagtail.log_actions import log\nfrom wagtail.log_actions import registry as log_registry\nfrom wagtail.models import Locale, RevisionMixin, TranslatableMixin\nfrom wagtail.utils.deprecation import RemovedInWagtail50Warning\n\nfrom .forms import ParentChooserForm\n\ntry:\n    from django.contrib.admin.utils import lookup_spawns_duplicates\nexcept ImportError:\n    # fallback for Django <4.0\n    from django.contrib.admin.utils import (\n        lookup_needs_distinct as lookup_spawns_duplicates,\n    )\n\n\nQUERY_TERMS = {\n    \"contains\",\n    \"day\",\n    \"endswith\",\n    \"exact\",\n    \"gt\",\n    \"gte\",\n    \"hour\",\n    \"icontains\",\n    \"iendswith\",\n    \"iexact\",\n    \"in\",\n    \"iregex\",\n    \"isnull\",\n    \"istartswith\",\n    \"lt\",\n    \"lte\",\n    \"minute\",\n    \"month\",\n    \"range\",\n    \"regex\",\n    \"search\",\n    \"second\",\n    \"startswith\",\n    \"week_day\",\n    \"year\",\n}\n\n\nclass WMABaseView(TemplateView):\n    \"\"\"\n    Groups together common functionality for all app views.\n    \"\"\"\n\n    model_admin = None\n    meta_title = \"\"\n    page_title = \"\"\n    page_subtitle = \"\"\n\n    def __init__(self, model_admin):\n        self.model_admin = model_admin\n        self.model = model_admin.model\n        self.opts = self.model._meta\n        self.app_label = force_str(self.opts.app_label)\n        self.model_name = force_str(self.opts.model_name)\n        self.verbose_name = force_str(self.opts.verbose_name)\n        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)\n        self.pk_attname = self.opts.pk.attname\n        self.is_pagemodel = model_admin.is_pagemodel\n        self.permission_helper = model_admin.permission_helper\n        self.url_helper = model_admin.url_helper\n\n    def check_action_permitted(self, user):\n        return True\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        button_helper_class = self.model_admin.get_button_helper_class()\n        self.button_helper = button_helper_class(self, request)\n        return super().dispatch(request, *args, **kwargs)\n\n    @cached_property\n    def menu_icon(self):\n        return self.model_admin.get_menu_icon()\n\n    @cached_property\n    def header_icon(self):\n        return self.menu_icon\n\n    def get_page_title(self):\n        return self.page_title or capfirst(self.opts.verbose_name_plural)\n\n    def get_meta_title(self):\n        return self.meta_title or self.get_page_title()\n\n    @cached_property\n    def index_url(self):\n        return self.url_helper.index_url\n\n    @cached_property\n    def create_url(self):\n        return self.url_helper.create_url\n\n    def get_base_queryset(self, request=None):\n        return self.model_admin.get_queryset(request or self.request)\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"view\": self,\n            \"model_admin\": self.model_admin,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n\nclass ModelFormView(WMABaseView, FormView):\n    def setup(self, request, *args, **kwargs):\n        super().setup(request, *args, **kwargs)\n        self.edit_handler = self.get_edit_handler()\n\n    def get_form(self):\n        form = super().get_form()\n        return form\n\n    def get_edit_handler(self):\n        try:\n            edit_handler = self.model_admin.get_edit_handler()\n        except TypeError:\n            edit_handler = self.model_admin.get_edit_handler(\n                instance=None, request=None\n            )\n            warnings.warn(\n                \"%s.get_edit_handler should not accept instance or request arguments\"\n                % type(self.model_admin).__name__,\n                category=RemovedInWagtail50Warning,\n            )\n\n        return edit_handler.bind_to_model(self.model_admin.model)\n\n    def get_form_class(self):\n        return self.edit_handler.get_form_class()\n\n    def get_success_url(self):\n        return self.index_url\n\n    def get_instance(self):\n        return getattr(self, \"instance\", None) or self.model()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})\n        return kwargs\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_form_view_extra_css()},\n            js=self.model_admin.get_form_view_extra_js(),\n        )\n\n    def get_context_data(self, form=None, **kwargs):\n        if form is None:\n            form = self.get_form()\n\n        bound_panel = self.edit_handler.get_bound_panel(\n            form=form, instance=form.instance, request=self.request\n        )\n\n        prepopulated_fields = self.get_prepopulated_fields(form)\n        context = {\n            \"is_multipart\": form.is_multipart(),\n            \"edit_handler\": bound_panel,\n            \"form\": form,\n            \"prepopulated_fields\": prepopulated_fields,\n            \"media\": self.media + bound_panel.media + form.media,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_prepopulated_fields(self, form):\n        fields = []\n        for field_name, dependencies in self.model_admin.get_prepopulated_fields(\n            self.request\n        ).items():\n            missing_dependencies = [\n                f\"'{f}'\" for f in dependencies if f not in form.fields\n            ]\n            if len(missing_dependencies) != 0:\n                missing_deps_string = \", \".join(missing_dependencies)\n                dependency_string = (\n                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"\n                )\n                warnings.warn(\n                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",\n                    category=RuntimeWarning,\n                )\n            elif field_name in form.fields:\n                fields.append(\n                    {\n                        \"field\": form[field_name],\n                        \"dependencies\": [form[f] for f in dependencies],\n                    }\n                )\n        return fields\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' created.\") % {\n            \"model_name\": capfirst(self.opts.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_success_message_buttons(self, instance):\n        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))\n        return [messages.button(button_url, _(\"Edit\"))]\n\n    def get_error_message(self):\n        model_name = self.verbose_name\n        return _(\"The %(object)s could not be created due to errors.\") % {\n            \"object\": model_name\n        }\n\n    def form_valid(self, form):\n        self.instance = form.save()\n        messages.success(\n            self.request,\n            self.get_success_message(self.instance),\n            buttons=self.get_success_message_buttons(self.instance),\n        )\n        return redirect(self.get_success_url())\n\n    def form_invalid(self, form):\n        messages.validation_error(self.request, self.get_error_message(), form)\n        return self.render_to_response(self.get_context_data(form=form))\n\n\nclass InstanceSpecificView(WMABaseView):\n\n    instance_pk = None\n    pk_quoted = None\n    instance = None\n    locale = None\n\n    def __init__(self, model_admin, instance_pk):\n        super().__init__(model_admin)\n        self.instance_pk = unquote(instance_pk)\n        self.pk_quoted = quote(self.instance_pk)\n        filter_kwargs = {}\n        filter_kwargs[self.pk_attname] = self.instance_pk\n        object_qs = model_admin.model._default_manager.get_queryset().filter(\n            **filter_kwargs\n        )\n        self.instance = get_object_or_404(object_qs)\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            model_admin.model, TranslatableMixin\n        ):\n            self.locale = self.instance.locale\n\n    def get_page_subtitle(self):\n        return self.instance\n\n    @cached_property\n    def edit_url(self):\n        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)\n\n    @cached_property\n    def delete_url(self):\n        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)\n\n    def get_context_data(self, **kwargs):\n        context = {\"instance\": self.instance}\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n\nclass IndexView(SpreadsheetExportMixin, WMABaseView):\n\n    ORDER_VAR = \"o\"\n    ORDER_TYPE_VAR = \"ot\"\n    PAGE_VAR = \"p\"\n    SEARCH_VAR = \"q\"\n    ERROR_FLAG = \"e\"\n    EXPORT_VAR = \"export\"\n    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)\n\n    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers\n    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by\n    sortable_by = None\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        # Only continue if logged in user has list permission\n        if not self.permission_helper.user_can_list(request.user):\n            raise PermissionDenied\n\n        self.list_export = self.model_admin.get_list_export(request)\n        self.list_display = self.model_admin.get_list_display(request)\n        self.list_filter = self.model_admin.get_list_filter(request)\n        self.search_fields = self.model_admin.get_search_fields(request)\n        self.items_per_page = self.model_admin.list_per_page\n        self.select_related = self.model_admin.list_select_related\n        self.search_handler = self.model_admin.get_search_handler(\n            request, self.search_fields\n        )\n        self.export = request.GET.get(self.EXPORT_VAR)\n\n        # Get search parameters from the query string.\n        try:\n            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))\n        except ValueError:\n            self.page_num = 0\n\n        self.params = dict(request.GET.items())\n        if self.PAGE_VAR in self.params:\n            del self.params[self.PAGE_VAR]\n        if self.ERROR_FLAG in self.params:\n            del self.params[self.ERROR_FLAG]\n        if self.EXPORT_VAR in self.params:\n            del self.params[self.EXPORT_VAR]\n\n        self.query = request.GET.get(self.SEARCH_VAR, \"\")\n\n        self.queryset = self.get_queryset(request)\n\n        if self.export in self.FORMATS:\n            return self.as_spreadsheet(self.queryset, self.export)\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_filename(self):\n        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"\n        return getattr(self.model_admin, \"export_filename\", super().get_filename())\n\n    def get_heading(self, queryset, field):\n        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"\n        heading_override = self.export_headings.get(field)\n        if heading_override:\n            return force_str(heading_override)\n        return force_str(\n            label_for_field(\n                field, model=self.model, model_admin=self.model_admin\n            ).title()\n        )\n\n    def to_row_dict(self, item):\n        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"\n        row_dict = OrderedDict()\n        for field in self.list_export:\n            f, attr, value = lookup_field(field, item, self.model_admin)\n            if not value:\n                value = getattr(\n                    attr,\n                    \"empty_value_display\",\n                    self.model_admin.get_empty_value_display(field),\n                )\n            row_dict[field] = value\n\n        return row_dict\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_index_view_extra_css()},\n            js=self.model_admin.get_index_view_extra_js(),\n        )\n\n    def get_buttons_for_obj(self, obj):\n        return self.button_helper.get_buttons_for_obj(\n            obj, classnames_add=[\"button-small\"]\n        )\n\n    def get_search_results(self, request, queryset, search_term):\n        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)\n        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET\n        return self.search_handler.search_queryset(queryset, search_term, **kwargs)\n\n    def get_filters_params(self, params=None):\n        \"\"\"\n        Returns all params except IGNORED_PARAMS\n        \"\"\"\n        if not params:\n            params = self.params\n        lookup_params = params.copy()  # a dictionary of the query string\n        # Remove all the parameters that are globally and systematically\n        # ignored.\n        for ignored in self.IGNORED_PARAMS:\n            if ignored in lookup_params:\n                del lookup_params[ignored]\n        return lookup_params\n\n    def get_filters(self, request):\n        lookup_params = self.get_filters_params()\n        use_distinct = False\n\n        filter_specs = []\n        if self.list_filter:\n            for list_filter in self.list_filter:\n                if callable(list_filter):\n                    # This is simply a custom list filter class.\n                    spec = list_filter(\n                        request, lookup_params, self.model, self.model_admin\n                    )\n                else:\n                    field_path = None\n                    if isinstance(list_filter, (tuple, list)):\n                        # This is a custom FieldListFilter class for a given\n                        # field.\n                        field, field_list_filter_class = list_filter\n                    else:\n                        # This is simply a field name, so use the default\n                        # FieldListFilter class that has been registered for\n                        # the type of the given field.\n                        field = list_filter\n                        field_list_filter_class = FieldListFilter.create\n                    if not isinstance(field, models.Field):\n                        field_path = field\n                        field = get_fields_from_path(self.model, field_path)[-1]\n                    spec = field_list_filter_class(\n                        field,\n                        request,\n                        lookup_params,\n                        self.model,\n                        self.model_admin,\n                        field_path=field_path,\n                    )\n\n                    # Check if we need to use distinct()\n                    use_distinct = use_distinct or lookup_spawns_duplicates(\n                        self.opts, field_path\n                    )\n                if spec and spec.has_output():\n                    filter_specs.append(spec)\n\n        # At this point, all the parameters used by the various ListFilters\n        # have been removed from lookup_params, which now only contains other\n        # parameters passed via the query string. We now loop through the\n        # remaining parameters both to ensure that all the parameters are valid\n        # fields and to determine if at least one of them needs distinct(). If\n        # the lookup parameters aren't real fields, then bail out.\n        try:\n            for key, value in lookup_params.items():\n                lookup_params[key] = prepare_lookup_value(key, value)\n                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)\n            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)\n        except FieldDoesNotExist as e:\n            raise IncorrectLookupParameters from e\n\n    def get_query_string(self, new_params=None, remove=None):\n        if new_params is None:\n            new_params = {}\n        if remove is None:\n            remove = []\n        p = self.params.copy()\n        for r in remove:\n            for k in list(p):\n                if k.startswith(r):\n                    del p[k]\n        for k, v in new_params.items():\n            if v is None:\n                if k in p:\n                    del p[k]\n            else:\n                p[k] = v\n        return \"?%s\" % urlencode(sorted(p.items()))\n\n    def _get_default_ordering(self):\n        ordering = []\n        if self.model_admin.ordering:\n            ordering = self.model_admin.ordering\n        elif self.opts.ordering:\n            ordering = self.opts.ordering\n        return ordering\n\n    def get_default_ordering(self, request):\n        if self.model_admin.get_ordering(request):\n            return self.model_admin.get_ordering(request)\n        if self.opts.ordering:\n            return self.opts.ordering\n        return ()\n\n    def get_ordering_field(self, field_name):\n        \"\"\"\n        Returns the proper model field name corresponding to the given\n        field_name to use for ordering. field_name may either be the name of a\n        proper model field or the name of a method (on the admin or model) or a\n        callable with the 'admin_order_field' attribute. Returns None if no\n        proper model field name can be matched.\n        \"\"\"\n        try:\n            field = self.opts.get_field(field_name)\n            return field.name\n        except FieldDoesNotExist:\n            # See whether field_name is a name of a non-field\n            # that allows sorting.\n            if callable(field_name):\n                attr = field_name\n            elif hasattr(self.model_admin, field_name):\n                attr = getattr(self.model_admin, field_name)\n            else:\n                attr = getattr(self.model, field_name)\n            return getattr(attr, \"admin_order_field\", None)\n\n    def get_ordering(self, request, queryset):\n        \"\"\"\n        Returns the list of ordering fields for the change list.\n        First we check the get_ordering() method in model admin, then we check\n        the object's default ordering. Then, any manually-specified ordering\n        from the query string overrides anything. Finally, a deterministic\n        order is guaranteed by ensuring the primary key is used as the last\n        ordering field.\n        \"\"\"\n        params = self.params\n        ordering = list(self.get_default_ordering(request))\n        if self.ORDER_VAR in params:\n            # Clear ordering and used params\n            ordering = []\n            order_params = params[self.ORDER_VAR].split(\".\")\n            for p in order_params:\n                try:\n                    none, pfx, idx = p.rpartition(\"-\")\n                    field_name = self.list_display[int(idx)]\n                    order_field = self.get_ordering_field(field_name)\n                    if not order_field:\n                        continue  # No 'admin_order_field', skip it\n                    # reverse order if order_field has already \"-\" as prefix\n                    if order_field.startswith(\"-\") and pfx == \"-\":\n                        ordering.append(order_field[1:])\n                    else:\n                        ordering.append(pfx + order_field)\n                except (IndexError, ValueError):\n                    continue  # Invalid ordering specified, skip it.\n\n        # Add the given query's ordering fields, if any.\n        ordering.extend(queryset.query.order_by)\n\n        # Ensure that the primary key is systematically present in the list of\n        # ordering fields so we can guarantee a deterministic order across all\n        # database backends.\n        pk_name = self.opts.pk.name\n\n        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):\n            # ordering isn't already being applied to pk\n            ordering.append(\"-\" + pk_name)\n\n        return ordering\n\n    def get_ordering_field_columns(self):\n        \"\"\"\n        Returns an OrderedDict of ordering field column numbers and asc/desc\n        \"\"\"\n\n        # We must cope with more than one column having the same underlying\n        # sort field, so we base things on column numbers.\n        ordering = self._get_default_ordering()\n        ordering_fields = OrderedDict()\n        if self.ORDER_VAR not in self.params:\n            # for ordering specified on model_admin or model Meta, we don't\n            # know the right column numbers absolutely, because there might be\n            # morr than one column associated with that ordering, so we guess.\n            for field in ordering:\n                if field.startswith(\"-\"):\n                    field = field[1:]\n                    order_type = \"desc\"\n                else:\n                    order_type = \"asc\"\n                for index, attr in enumerate(self.list_display):\n                    if self.get_ordering_field(attr) == field:\n                        ordering_fields[index] = order_type\n                        break\n        else:\n            for p in self.params[self.ORDER_VAR].split(\".\"):\n                none, pfx, idx = p.rpartition(\"-\")\n                try:\n                    idx = int(idx)\n                except ValueError:\n                    continue  # skip it\n                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"\n        return ordering_fields\n\n    def get_queryset(self, request=None):\n        request = request or self.request\n\n        # First, we collect all the declared list filters.\n        (\n            self.filter_specs,\n            self.has_filters,\n            remaining_lookup_params,\n            filters_use_distinct,\n        ) = self.get_filters(request)\n\n        # Then, we let every list filter modify the queryset to its liking.\n        qs = self.get_base_queryset(request)\n        for filter_spec in self.filter_specs:\n            new_qs = filter_spec.queryset(request, qs)\n            if new_qs is not None:\n                qs = new_qs\n\n        try:\n            # Finally, we apply the remaining lookup parameters from the query\n            # string (i.e. those that haven't already been processed by the\n            # filters).\n            qs = qs.filter(**remaining_lookup_params)\n        except (SuspiciousOperation, ImproperlyConfigured):\n            # Allow certain types of errors to be re-raised as-is so that the\n            # caller can treat them in a special way.\n            raise\n        except Exception as e:\n            # Every other error is caught with a naked except, because we don't\n            # have any other way of validating lookup parameters. They might be\n            # invalid if the keyword arguments are incorrect, or if the values\n            # are not in the correct type, so we might get FieldError,\n            # ValueError, ValidationError, or ?.\n            raise IncorrectLookupParameters(e)\n\n        if not qs.query.select_related:\n            qs = self.apply_select_related(qs)\n\n        # Set ordering.\n        ordering = self.get_ordering(request, qs)\n        qs = qs.order_by(*ordering)\n\n        # Remove duplicates from results, if necessary\n        if filters_use_distinct:\n            qs = qs.distinct()\n\n        # Apply search results\n        return self.get_search_results(request, qs, self.query)\n\n    def apply_select_related(self, qs):\n        if self.select_related is True:\n            return qs.select_related()\n\n        if self.select_related is False:\n            if self.has_related_field_in_list_display():\n                return qs.select_related()\n\n        if self.select_related:\n            return qs.select_related(*self.select_related)\n        return qs\n\n    def has_related_field_in_list_display(self):\n        for field_name in self.list_display:\n            try:\n                field = self.opts.get_field(field_name)\n            except FieldDoesNotExist:\n                pass\n            else:\n                if isinstance(field, models.ManyToOneRel):\n                    return True\n        return False\n\n    def get_context_data(self, **kwargs):\n        user = self.request.user\n        all_count = self.get_base_queryset().count()\n        queryset = self.get_queryset()\n        result_count = queryset.count()\n        paginator = Paginator(queryset, self.items_per_page)\n\n        try:\n            page_obj = paginator.page(self.page_num + 1)\n        except InvalidPage:\n            page_obj = paginator.page(1)\n\n        context = {\n            \"view\": self,\n            \"all_count\": all_count,\n            \"result_count\": result_count,\n            \"paginator\": paginator,\n            \"page_obj\": page_obj,\n            \"object_list\": page_obj.object_list,\n            \"user_can_create\": self.permission_helper.user_can_create(user),\n            \"show_search\": self.search_handler.show_search_form,\n        }\n\n        if self.is_pagemodel:\n            models = self.model.allowed_parent_page_models()\n            allowed_parent_types = [m._meta.verbose_name for m in models]\n            valid_parents = self.permission_helper.get_valid_parent_pages(user)\n            valid_parent_count = valid_parents.count()\n            context.update(\n                {\n                    \"no_valid_parents\": not valid_parent_count,\n                    \"required_parent_types\": allowed_parent_types,\n                }\n            )\n\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_index_template()\n\n\nclass CreateView(ModelFormView):\n    page_title = gettext_lazy(\"New\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_create(user)\n\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            user = request.user\n            parents = self.permission_helper.get_valid_parent_pages(user)\n            parent_count = parents.count()\n\n            # There's only one available parent for this page type for this\n            # user, so we send them along with that as the chosen parent page\n            if parent_count == 1:\n                parent = parents.get()\n                parent_pk = quote(parent.pk)\n                return redirect(\n                    self.url_helper.get_action_url(\n                        \"add\", self.app_label, self.model_name, parent_pk\n                    )\n                )\n\n            # The page can be added in multiple places, so redirect to the\n            # choose_parent view so that the parent can be specified\n            return redirect(self.url_helper.get_action_url(\"choose_parent\"))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                locale = get_object_or_404(Locale, language_code=selected_locale)\n            else:\n                locale = Locale.get_default()\n\n            kwargs.update(\n                {\n                    \"locale\": locale,\n                    \"translations\": [\n                        {\n                            \"locale\": locale,\n                            \"url\": self.create_url + \"?locale=\" + locale.language_code,\n                        }\n                        for locale in Locale.objects.all().exclude(id=locale.id)\n                    ],\n                }\n            )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(user=self.request.user)\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.create\",\n            revision=revision,\n            content_changed=True,\n        )\n        return response\n\n    def get_meta_title(self):\n        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_page_subtitle(self):\n        return capfirst(self.verbose_name)\n\n    def get_template_names(self):\n        return self.model_admin.get_create_template()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                kwargs[\"instance\"].locale = get_object_or_404(\n                    Locale, language_code=selected_locale\n                )\n\n        return kwargs\n\n\nclass EditView(ModelFormView, InstanceSpecificView):\n    page_title = gettext_lazy(\"Editing\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_edit_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"edit\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' updated.\") % {\n            \"model_name\": capfirst(self.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"user_can_delete\": self.permission_helper.user_can_delete_obj(\n                self.request.user, self.instance\n            )\n        }\n        context.update(kwargs)\n        if self.model_admin.history_view_enabled:\n            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(\n                self.instance\n            ).first()\n            context[\"history_url\"] = self.url_helper.get_action_url(\n                \"history\", quote(self.instance.pk)\n            )\n        else:\n            context[\"latest_log_entry\"] = None\n            context[\"history_url\"] = None\n\n        return super().get_context_data(**context)\n\n    def get_error_message(self):\n        name = self.verbose_name\n        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}\n\n    def get_template_names(self):\n        return self.model_admin.get_edit_template()\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        self.has_content_changes = form.has_changed()\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(\n                user=self.request.user,\n                changed=self.has_content_changes,\n            )\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.edit\",\n            revision=revision,\n            content_changed=self.has_content_changes,\n        )\n        return response\n\n\nclass ChooseParentView(WMABaseView):\n    def dispatch(self, request, *args, **kwargs):\n        if not self.permission_helper.user_can_create(request.user):\n            raise PermissionDenied\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_page_title(self):\n        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_form(self, request):\n        parents = self.permission_helper.get_valid_parent_pages(request.user)\n        return ParentChooserForm(parents, request.POST or None)\n\n    def get(self, request, *args, **kwargs):\n        form = self.get_form(request)\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def post(self, request, *args, **kargs):\n        form = self.get_form(request)\n        if form.is_valid():\n            return self.form_valid(form)\n        return self.form_invalid(form)\n\n    def form_valid(self, form):\n        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)\n        return redirect(\n            self.url_helper.get_action_url(\n                \"add\", self.app_label, self.model_name, parent_pk\n            )\n        )\n\n    def form_invalid(self, form):\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_choose_parent_template()\n\n\nclass DeleteView(InstanceSpecificView):\n    page_title = gettext_lazy(\"Delete\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_delete_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}\n\n    def confirmation_message(self):\n        return _(\n            \"Are you sure you want to delete this %(object)s? If other things in your \"\n            \"site are related to it, they may also be affected.\"\n        ) % {\"object\": self.verbose_name}\n\n    def delete_instance(self):\n        self.instance.delete()\n\n    def post(self, request, *args, **kwargs):\n        try:\n            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {\n                \"model_name\": self.verbose_name,\n                \"object\": self.instance,\n            }\n            with transaction.atomic():\n                log(instance=self.instance, action=\"wagtail.delete\")\n                self.delete_instance()\n            messages.success(request, msg)\n            return redirect(self.index_url)\n        except models.ProtectedError:\n            linked_objects = []\n            fields = self.model._meta.fields_map.values()\n            fields = (\n                obj for obj in fields if not isinstance(obj.field, ManyToManyField)\n            )\n            for rel in fields:\n                if rel.on_delete == models.PROTECT:\n                    if isinstance(rel, OneToOneRel):\n                        try:\n                            obj = getattr(self.instance, rel.get_accessor_name())\n                        except ObjectDoesNotExist:\n                            pass\n                        else:\n                            linked_objects.append(obj)\n                    else:\n                        qs = getattr(self.instance, rel.get_accessor_name())\n                        for obj in qs.all():\n                            linked_objects.append(obj)\n            context = self.get_context_data(\n                protected_error=True, linked_objects=linked_objects\n            )\n            return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_delete_template()\n\n\nclass InspectView(InstanceSpecificView):\n\n    page_title = gettext_lazy(\"Inspecting\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_inspect_obj(user, self.instance)\n\n    def dispatch(self, request, *args, **kwargs):\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model_admin.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"inspect\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_inspect_view_extra_css()},\n            js=self.model_admin.get_inspect_view_extra_js(),\n        )\n\n    def get_meta_title(self):\n        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_field_label(self, field_name, field=None):\n        \"\"\"Return a label to display for a field\"\"\"\n        return label_for_field(field_name, model=self.model)\n\n    def get_field_display_value(self, field_name, field=None):\n        \"\"\"Return a display value for a field/attribute\"\"\"\n\n        # First we check for a 'get_fieldname_display' property/method on\n        # the model, and return the value of that, if present.\n        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)\n        if val_funct is not None:\n            if callable(val_funct):\n                return val_funct()\n            return val_funct\n\n        # Now let's get the attribute value from the instance itself and see if\n        # we can render something useful. raises AttributeError appropriately.\n        val = getattr(self.instance, field_name)\n\n        if isinstance(val, models.Manager):\n            val = val.all()\n\n        if isinstance(val, models.QuerySet):\n            if val.exists():\n                return \", \".join([\"%s\" % obj for obj in val])\n            return self.model_admin.get_empty_value_display(field_name)\n\n        # wagtail.images might not be installed\n        try:\n            from wagtail.images.models import AbstractImage\n\n            if isinstance(val, AbstractImage):\n                # Render a rendition of the image\n                return self.get_image_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # wagtail.wagtaildocuments might not be installed\n        try:\n            from wagtail.documents.models import AbstractDocument\n\n            if isinstance(val, AbstractDocument):\n                # Render a link to the document\n                return self.get_document_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # Resort to returning the real value or 'empty value'\n        if val or val is False:\n            return val\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_image_field_display(self, field_name, field):\n        \"\"\"Render an image\"\"\"\n        from wagtail.images.shortcuts import get_rendition_or_not_found\n\n        image = getattr(self.instance, field_name)\n        if image:\n            return get_rendition_or_not_found(image, \"max-400x400\").img_tag\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_document_field_display(self, field_name, field):\n        \"\"\"Render a link to a document\"\"\"\n        document = getattr(self.instance, field_name)\n        if document:\n            return mark_safe(\n                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'\n                % (\n                    document.url,\n                    document.title,\n                    document.file_extension.upper(),\n                    filesizeformat(document.file.size),\n                )\n            )\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_dict_for_field(self, field_name):\n        \"\"\"\n        Return a dictionary containing `label` and `value` values to display\n        for a field.\n        \"\"\"\n        try:\n            field = self.model._meta.get_field(field_name)\n        except FieldDoesNotExist:\n            field = None\n        return {\n            \"label\": self.get_field_label(field_name, field),\n            \"value\": self.get_field_display_value(field_name, field),\n        }\n\n    def get_fields_dict(self):\n        \"\"\"\n        Return a list of `label`/`value` dictionaries to represent the\n        fields named by the model_admin class's `get_inspect_view_fields` method\n        \"\"\"\n        fields = []\n        for field_name in self.model_admin.get_inspect_view_fields():\n            fields.append(self.get_dict_for_field(field_name))\n        return fields\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"fields\": self.get_fields_dict(),\n            \"buttons\": self.button_helper.get_buttons_for_obj(\n                self.instance, exclude=[\"inspect\"]\n            ),\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_inspect_template()\n\n\nclass HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):\n    page_title = gettext_lazy(\"History\")\n    paginate_by = 50\n    columns = [\n        Column(\"message\", label=gettext_lazy(\"Action\")),\n        UserColumn(\"user\", blank_display_name=\"system\"),\n        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),\n    ]\n\n    def get_page_subtitle(self):\n        return str(self.instance)\n\n    def get_template_names(self):\n        return self.model_admin.get_history_template()\n\n    def get_queryset(self):\n        return log_registry.get_logs_for_instance(self.instance).prefetch_related(\n            \"user__wagtail_userprofile\"\n        )\n\n    def get_context_data(self, **kwargs):\n        self.object_list = self.get_queryset()\n        context = super().get_context_data(**kwargs)\n        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))\n        table = Table(\n            self.columns,\n            context[\"object_list\"],\n            base_url=index_url,\n            ordering=self.get_ordering(),\n        )\n\n        context[\"table\"] = table\n        context[\"media\"] = table.media\n        context[\"index_url\"] = index_url\n        context[\"is_paginated\"] = True\n        return context\n", "patch": "@@ -29,8 +29,8 @@\n from django.utils.decorators import method_decorator\n from django.utils.encoding import force_str\n from django.utils.functional import cached_property\n+from django.utils.html import format_html\n from django.utils.http import urlencode\n-from django.utils.safestring import mark_safe\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n from django.utils.translation import gettext_lazy\n@@ -1131,14 +1131,12 @@ def get_document_field_display(self, field_name, field):\n         \"\"\"Render a link to a document\"\"\"\n         document = getattr(self.instance, field_name)\n         if document:\n-            return mark_safe(\n-                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'\n-                % (\n-                    document.url,\n-                    document.title,\n-                    document.file_extension.upper(),\n-                    filesizeformat(document.file.size),\n-                )\n+            return format_html(\n+                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',\n+                document.url,\n+                document.title,\n+                document.file_extension.upper(),\n+                filesizeformat(document.file.size),\n             )\n         return self.model_admin.get_empty_value_display(field_name)\n ", "file_path": "files/2023_4/1009", "file_language": "py", "file_name": "wagtail/contrib/modeladmin/views.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.django.security.audit.avoid-mark-safe.avoid-mark-safe                                   \n          'mark_safe()' is used to mark a string as \"safe\" for HTML output. This disables escaping and\n          could therefore subject the content to XSS attacks. Use 'django.utils.html.format_html()' to\n          build HTML for rendering instead.                                                           \n          Details: https://sg.run/yd0P                                                                \n\n         1134\u2506 return mark_safe(\n         1135\u2506     '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'\n         1136\u2506     % (\n         1137\u2506         document.url,\n         1138\u2506         document.title,\n         1139\u2506         document.file_extension.upper(),\n         1140\u2506         filesizeformat(document.file.size),\n         1141\u2506     )         1142\u2506 )"]]}, "target": 1, "function_before": [{"function": "class WMABaseView(TemplateView):\n    \"\"\"\n    Groups together common functionality for all app views.\n    \"\"\"\n\n    model_admin = None\n    meta_title = \"\"\n    page_title = \"\"\n    page_subtitle = \"\"\n\n    def __init__(self, model_admin):\n        self.model_admin = model_admin\n        self.model = model_admin.model\n        self.opts = self.model._meta\n        self.app_label = force_str(self.opts.app_label)\n        self.model_name = force_str(self.opts.model_name)\n        self.verbose_name = force_str(self.opts.verbose_name)\n        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)\n        self.pk_attname = self.opts.pk.attname\n        self.is_pagemodel = model_admin.is_pagemodel\n        self.permission_helper = model_admin.permission_helper\n        self.url_helper = model_admin.url_helper\n\n    def check_action_permitted(self, user):\n        return True\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        button_helper_class = self.model_admin.get_button_helper_class()\n        self.button_helper = button_helper_class(self, request)\n        return super().dispatch(request, *args, **kwargs)\n\n    @cached_property\n    def menu_icon(self):\n        return self.model_admin.get_menu_icon()\n\n    @cached_property\n    def header_icon(self):\n        return self.menu_icon\n\n    def get_page_title(self):\n        return self.page_title or capfirst(self.opts.verbose_name_plural)\n\n    def get_meta_title(self):\n        return self.meta_title or self.get_page_title()\n\n    @cached_property\n    def index_url(self):\n        return self.url_helper.index_url\n\n    @cached_property\n    def create_url(self):\n        return self.url_helper.create_url\n\n    def get_base_queryset(self, request=None):\n        return self.model_admin.get_queryset(request or self.request)\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"view\": self,\n            \"model_admin\": self.model_admin,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)", "target": 0}, {"function": "class ModelFormView(WMABaseView, FormView):\n    def setup(self, request, *args, **kwargs):\n        super().setup(request, *args, **kwargs)\n        self.edit_handler = self.get_edit_handler()\n\n    def get_form(self):\n        form = super().get_form()\n        return form\n\n    def get_edit_handler(self):\n        try:\n            edit_handler = self.model_admin.get_edit_handler()\n        except TypeError:\n            edit_handler = self.model_admin.get_edit_handler(\n                instance=None, request=None\n            )\n            warnings.warn(\n                \"%s.get_edit_handler should not accept instance or request arguments\"\n                % type(self.model_admin).__name__,\n                category=RemovedInWagtail50Warning,\n            )\n\n        return edit_handler.bind_to_model(self.model_admin.model)\n\n    def get_form_class(self):\n        return self.edit_handler.get_form_class()\n\n    def get_success_url(self):\n        return self.index_url\n\n    def get_instance(self):\n        return getattr(self, \"instance\", None) or self.model()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})\n        return kwargs\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_form_view_extra_css()},\n            js=self.model_admin.get_form_view_extra_js(),\n        )\n\n    def get_context_data(self, form=None, **kwargs):\n        if form is None:\n            form = self.get_form()\n\n        bound_panel = self.edit_handler.get_bound_panel(\n            form=form, instance=form.instance, request=self.request\n        )\n\n        prepopulated_fields = self.get_prepopulated_fields(form)\n        context = {\n            \"is_multipart\": form.is_multipart(),\n            \"edit_handler\": bound_panel,\n            \"form\": form,\n            \"prepopulated_fields\": prepopulated_fields,\n            \"media\": self.media + bound_panel.media + form.media,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_prepopulated_fields(self, form):\n        fields = []\n        for field_name, dependencies in self.model_admin.get_prepopulated_fields(\n            self.request\n        ).items():\n            missing_dependencies = [\n                f\"'{f}'\" for f in dependencies if f not in form.fields\n            ]\n            if len(missing_dependencies) != 0:\n                missing_deps_string = \", \".join(missing_dependencies)\n                dependency_string = (\n                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"\n                )\n                warnings.warn(\n                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",\n                    category=RuntimeWarning,\n                )\n            elif field_name in form.fields:\n                fields.append(\n                    {\n                        \"field\": form[field_name],\n                        \"dependencies\": [form[f] for f in dependencies],\n                    }\n                )\n        return fields\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' created.\") % {\n            \"model_name\": capfirst(self.opts.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_success_message_buttons(self, instance):\n        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))\n        return [messages.button(button_url, _(\"Edit\"))]\n\n    def get_error_message(self):\n        model_name = self.verbose_name\n        return _(\"The %(object)s could not be created due to errors.\") % {\n            \"object\": model_name\n        }\n\n    def form_valid(self, form):\n        self.instance = form.save()\n        messages.success(\n            self.request,\n            self.get_success_message(self.instance),\n            buttons=self.get_success_message_buttons(self.instance),\n        )\n        return redirect(self.get_success_url())\n\n    def form_invalid(self, form):\n        messages.validation_error(self.request, self.get_error_message(), form)\n        return self.render_to_response(self.get_context_data(form=form))", "target": 0}, {"function": "class InstanceSpecificView(WMABaseView):\n\n    instance_pk = None\n    pk_quoted = None\n    instance = None\n    locale = None\n\n    def __init__(self, model_admin, instance_pk):\n        super().__init__(model_admin)\n        self.instance_pk = unquote(instance_pk)\n        self.pk_quoted = quote(self.instance_pk)\n        filter_kwargs = {}\n        filter_kwargs[self.pk_attname] = self.instance_pk\n        object_qs = model_admin.model._default_manager.get_queryset().filter(\n            **filter_kwargs\n        )\n        self.instance = get_object_or_404(object_qs)\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            model_admin.model, TranslatableMixin\n        ):\n            self.locale = self.instance.locale\n\n    def get_page_subtitle(self):\n        return self.instance\n\n    @cached_property\n    def edit_url(self):\n        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)\n\n    @cached_property\n    def delete_url(self):\n        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)\n\n    def get_context_data(self, **kwargs):\n        context = {\"instance\": self.instance}\n        context.update(kwargs)\n        return super().get_context_data(**context)", "target": 0}, {"function": "class IndexView(SpreadsheetExportMixin, WMABaseView):\n\n    ORDER_VAR = \"o\"\n    ORDER_TYPE_VAR = \"ot\"\n    PAGE_VAR = \"p\"\n    SEARCH_VAR = \"q\"\n    ERROR_FLAG = \"e\"\n    EXPORT_VAR = \"export\"\n    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)\n\n    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers\n    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by\n    sortable_by = None\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        # Only continue if logged in user has list permission\n        if not self.permission_helper.user_can_list(request.user):\n            raise PermissionDenied\n\n        self.list_export = self.model_admin.get_list_export(request)\n        self.list_display = self.model_admin.get_list_display(request)\n        self.list_filter = self.model_admin.get_list_filter(request)\n        self.search_fields = self.model_admin.get_search_fields(request)\n        self.items_per_page = self.model_admin.list_per_page\n        self.select_related = self.model_admin.list_select_related\n        self.search_handler = self.model_admin.get_search_handler(\n            request, self.search_fields\n        )\n        self.export = request.GET.get(self.EXPORT_VAR)\n\n        # Get search parameters from the query string.\n        try:\n            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))\n        except ValueError:\n            self.page_num = 0\n\n        self.params = dict(request.GET.items())\n        if self.PAGE_VAR in self.params:\n            del self.params[self.PAGE_VAR]\n        if self.ERROR_FLAG in self.params:\n            del self.params[self.ERROR_FLAG]\n        if self.EXPORT_VAR in self.params:\n            del self.params[self.EXPORT_VAR]\n\n        self.query = request.GET.get(self.SEARCH_VAR, \"\")\n\n        self.queryset = self.get_queryset(request)\n\n        if self.export in self.FORMATS:\n            return self.as_spreadsheet(self.queryset, self.export)\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_filename(self):\n        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"\n        return getattr(self.model_admin, \"export_filename\", super().get_filename())\n\n    def get_heading(self, queryset, field):\n        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"\n        heading_override = self.export_headings.get(field)\n        if heading_override:\n            return force_str(heading_override)\n        return force_str(\n            label_for_field(\n                field, model=self.model, model_admin=self.model_admin\n            ).title()\n        )\n\n    def to_row_dict(self, item):\n        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"\n        row_dict = OrderedDict()\n        for field in self.list_export:\n            f, attr, value = lookup_field(field, item, self.model_admin)\n            if not value:\n                value = getattr(\n                    attr,\n                    \"empty_value_display\",\n                    self.model_admin.get_empty_value_display(field),\n                )\n            row_dict[field] = value\n\n        return row_dict\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_index_view_extra_css()},\n            js=self.model_admin.get_index_view_extra_js(),\n        )\n\n    def get_buttons_for_obj(self, obj):\n        return self.button_helper.get_buttons_for_obj(\n            obj, classnames_add=[\"button-small\"]\n        )\n\n    def get_search_results(self, request, queryset, search_term):\n        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)\n        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET\n        return self.search_handler.search_queryset(queryset, search_term, **kwargs)\n\n    def get_filters_params(self, params=None):\n        \"\"\"\n        Returns all params except IGNORED_PARAMS\n        \"\"\"\n        if not params:\n            params = self.params\n        lookup_params = params.copy()  # a dictionary of the query string\n        # Remove all the parameters that are globally and systematically\n        # ignored.\n        for ignored in self.IGNORED_PARAMS:\n            if ignored in lookup_params:\n                del lookup_params[ignored]\n        return lookup_params\n\n    def get_filters(self, request):\n        lookup_params = self.get_filters_params()\n        use_distinct = False\n\n        filter_specs = []\n        if self.list_filter:\n            for list_filter in self.list_filter:\n                if callable(list_filter):\n                    # This is simply a custom list filter class.\n                    spec = list_filter(\n                        request, lookup_params, self.model, self.model_admin\n                    )\n                else:\n                    field_path = None\n                    if isinstance(list_filter, (tuple, list)):\n                        # This is a custom FieldListFilter class for a given\n                        # field.\n                        field, field_list_filter_class = list_filter\n                    else:\n                        # This is simply a field name, so use the default\n                        # FieldListFilter class that has been registered for\n                        # the type of the given field.\n                        field = list_filter\n                        field_list_filter_class = FieldListFilter.create\n                    if not isinstance(field, models.Field):\n                        field_path = field\n                        field = get_fields_from_path(self.model, field_path)[-1]\n                    spec = field_list_filter_class(\n                        field,\n                        request,\n                        lookup_params,\n                        self.model,\n                        self.model_admin,\n                        field_path=field_path,\n                    )\n\n                    # Check if we need to use distinct()\n                    use_distinct = use_distinct or lookup_spawns_duplicates(\n                        self.opts, field_path\n                    )\n                if spec and spec.has_output():\n                    filter_specs.append(spec)\n\n        # At this point, all the parameters used by the various ListFilters\n        # have been removed from lookup_params, which now only contains other\n        # parameters passed via the query string. We now loop through the\n        # remaining parameters both to ensure that all the parameters are valid\n        # fields and to determine if at least one of them needs distinct(). If\n        # the lookup parameters aren't real fields, then bail out.\n        try:\n            for key, value in lookup_params.items():\n                lookup_params[key] = prepare_lookup_value(key, value)\n                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)\n            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)\n        except FieldDoesNotExist as e:\n            raise IncorrectLookupParameters from e\n\n    def get_query_string(self, new_params=None, remove=None):\n        if new_params is None:\n            new_params = {}\n        if remove is None:\n            remove = []\n        p = self.params.copy()\n        for r in remove:\n            for k in list(p):\n                if k.startswith(r):\n                    del p[k]\n        for k, v in new_params.items():\n            if v is None:\n                if k in p:\n                    del p[k]\n            else:\n                p[k] = v\n        return \"?%s\" % urlencode(sorted(p.items()))\n\n    def _get_default_ordering(self):\n        ordering = []\n        if self.model_admin.ordering:\n            ordering = self.model_admin.ordering\n        elif self.opts.ordering:\n            ordering = self.opts.ordering\n        return ordering\n\n    def get_default_ordering(self, request):\n        if self.model_admin.get_ordering(request):\n            return self.model_admin.get_ordering(request)\n        if self.opts.ordering:\n            return self.opts.ordering\n        return ()\n\n    def get_ordering_field(self, field_name):\n        \"\"\"\n        Returns the proper model field name corresponding to the given\n        field_name to use for ordering. field_name may either be the name of a\n        proper model field or the name of a method (on the admin or model) or a\n        callable with the 'admin_order_field' attribute. Returns None if no\n        proper model field name can be matched.\n        \"\"\"\n        try:\n            field = self.opts.get_field(field_name)\n            return field.name\n        except FieldDoesNotExist:\n            # See whether field_name is a name of a non-field\n            # that allows sorting.\n            if callable(field_name):\n                attr = field_name\n            elif hasattr(self.model_admin, field_name):\n                attr = getattr(self.model_admin, field_name)\n            else:\n                attr = getattr(self.model, field_name)\n            return getattr(attr, \"admin_order_field\", None)\n\n    def get_ordering(self, request, queryset):\n        \"\"\"\n        Returns the list of ordering fields for the change list.\n        First we check the get_ordering() method in model admin, then we check\n        the object's default ordering. Then, any manually-specified ordering\n        from the query string overrides anything. Finally, a deterministic\n        order is guaranteed by ensuring the primary key is used as the last\n        ordering field.\n        \"\"\"\n        params = self.params\n        ordering = list(self.get_default_ordering(request))\n        if self.ORDER_VAR in params:\n            # Clear ordering and used params\n            ordering = []\n            order_params = params[self.ORDER_VAR].split(\".\")\n            for p in order_params:\n                try:\n                    none, pfx, idx = p.rpartition(\"-\")\n                    field_name = self.list_display[int(idx)]\n                    order_field = self.get_ordering_field(field_name)\n                    if not order_field:\n                        continue  # No 'admin_order_field', skip it\n                    # reverse order if order_field has already \"-\" as prefix\n                    if order_field.startswith(\"-\") and pfx == \"-\":\n                        ordering.append(order_field[1:])\n                    else:\n                        ordering.append(pfx + order_field)\n                except (IndexError, ValueError):\n                    continue  # Invalid ordering specified, skip it.\n\n        # Add the given query's ordering fields, if any.\n        ordering.extend(queryset.query.order_by)\n\n        # Ensure that the primary key is systematically present in the list of\n        # ordering fields so we can guarantee a deterministic order across all\n        # database backends.\n        pk_name = self.opts.pk.name\n\n        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):\n            # ordering isn't already being applied to pk\n            ordering.append(\"-\" + pk_name)\n\n        return ordering\n\n    def get_ordering_field_columns(self):\n        \"\"\"\n        Returns an OrderedDict of ordering field column numbers and asc/desc\n        \"\"\"\n\n        # We must cope with more than one column having the same underlying\n        # sort field, so we base things on column numbers.\n        ordering = self._get_default_ordering()\n        ordering_fields = OrderedDict()\n        if self.ORDER_VAR not in self.params:\n            # for ordering specified on model_admin or model Meta, we don't\n            # know the right column numbers absolutely, because there might be\n            # morr than one column associated with that ordering, so we guess.\n            for field in ordering:\n                if field.startswith(\"-\"):\n                    field = field[1:]\n                    order_type = \"desc\"\n                else:\n                    order_type = \"asc\"\n                for index, attr in enumerate(self.list_display):\n                    if self.get_ordering_field(attr) == field:\n                        ordering_fields[index] = order_type\n                        break\n        else:\n            for p in self.params[self.ORDER_VAR].split(\".\"):\n                none, pfx, idx = p.rpartition(\"-\")\n                try:\n                    idx = int(idx)\n                except ValueError:\n                    continue  # skip it\n                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"\n        return ordering_fields\n\n    def get_queryset(self, request=None):\n        request = request or self.request\n\n        # First, we collect all the declared list filters.\n        (\n            self.filter_specs,\n            self.has_filters,\n            remaining_lookup_params,\n            filters_use_distinct,\n        ) = self.get_filters(request)\n\n        # Then, we let every list filter modify the queryset to its liking.\n        qs = self.get_base_queryset(request)\n        for filter_spec in self.filter_specs:\n            new_qs = filter_spec.queryset(request, qs)\n            if new_qs is not None:\n                qs = new_qs\n\n        try:\n            # Finally, we apply the remaining lookup parameters from the query\n            # string (i.e. those that haven't already been processed by the\n            # filters).\n            qs = qs.filter(**remaining_lookup_params)\n        except (SuspiciousOperation, ImproperlyConfigured):\n            # Allow certain types of errors to be re-raised as-is so that the\n            # caller can treat them in a special way.\n            raise\n        except Exception as e:\n            # Every other error is caught with a naked except, because we don't\n            # have any other way of validating lookup parameters. They might be\n            # invalid if the keyword arguments are incorrect, or if the values\n            # are not in the correct type, so we might get FieldError,\n            # ValueError, ValidationError, or ?.\n            raise IncorrectLookupParameters(e)\n\n        if not qs.query.select_related:\n            qs = self.apply_select_related(qs)\n\n        # Set ordering.\n        ordering = self.get_ordering(request, qs)\n        qs = qs.order_by(*ordering)\n\n        # Remove duplicates from results, if necessary\n        if filters_use_distinct:\n            qs = qs.distinct()\n\n        # Apply search results\n        return self.get_search_results(request, qs, self.query)\n\n    def apply_select_related(self, qs):\n        if self.select_related is True:\n            return qs.select_related()\n\n        if self.select_related is False:\n            if self.has_related_field_in_list_display():\n                return qs.select_related()\n\n        if self.select_related:\n            return qs.select_related(*self.select_related)\n        return qs\n\n    def has_related_field_in_list_display(self):\n        for field_name in self.list_display:\n            try:\n                field = self.opts.get_field(field_name)\n            except FieldDoesNotExist:\n                pass\n            else:\n                if isinstance(field, models.ManyToOneRel):\n                    return True\n        return False\n\n    def get_context_data(self, **kwargs):\n        user = self.request.user\n        all_count = self.get_base_queryset().count()\n        queryset = self.get_queryset()\n        result_count = queryset.count()\n        paginator = Paginator(queryset, self.items_per_page)\n\n        try:\n            page_obj = paginator.page(self.page_num + 1)\n        except InvalidPage:\n            page_obj = paginator.page(1)\n\n        context = {\n            \"view\": self,\n            \"all_count\": all_count,\n            \"result_count\": result_count,\n            \"paginator\": paginator,\n            \"page_obj\": page_obj,\n            \"object_list\": page_obj.object_list,\n            \"user_can_create\": self.permission_helper.user_can_create(user),\n            \"show_search\": self.search_handler.show_search_form,\n        }\n\n        if self.is_pagemodel:\n            models = self.model.allowed_parent_page_models()\n            allowed_parent_types = [m._meta.verbose_name for m in models]\n            valid_parents = self.permission_helper.get_valid_parent_pages(user)\n            valid_parent_count = valid_parents.count()\n            context.update(\n                {\n                    \"no_valid_parents\": not valid_parent_count,\n                    \"required_parent_types\": allowed_parent_types,\n                }\n            )\n\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_index_template()", "target": 0}, {"function": "class CreateView(ModelFormView):\n    page_title = gettext_lazy(\"New\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_create(user)\n\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            user = request.user\n            parents = self.permission_helper.get_valid_parent_pages(user)\n            parent_count = parents.count()\n\n            # There's only one available parent for this page type for this\n            # user, so we send them along with that as the chosen parent page\n            if parent_count == 1:\n                parent = parents.get()\n                parent_pk = quote(parent.pk)\n                return redirect(\n                    self.url_helper.get_action_url(\n                        \"add\", self.app_label, self.model_name, parent_pk\n                    )\n                )\n\n            # The page can be added in multiple places, so redirect to the\n            # choose_parent view so that the parent can be specified\n            return redirect(self.url_helper.get_action_url(\"choose_parent\"))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                locale = get_object_or_404(Locale, language_code=selected_locale)\n            else:\n                locale = Locale.get_default()\n\n            kwargs.update(\n                {\n                    \"locale\": locale,\n                    \"translations\": [\n                        {\n                            \"locale\": locale,\n                            \"url\": self.create_url + \"?locale=\" + locale.language_code,\n                        }\n                        for locale in Locale.objects.all().exclude(id=locale.id)\n                    ],\n                }\n            )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(user=self.request.user)\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.create\",\n            revision=revision,\n            content_changed=True,\n        )\n        return response\n\n    def get_meta_title(self):\n        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_page_subtitle(self):\n        return capfirst(self.verbose_name)\n\n    def get_template_names(self):\n        return self.model_admin.get_create_template()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                kwargs[\"instance\"].locale = get_object_or_404(\n                    Locale, language_code=selected_locale\n                )\n\n        return kwargs", "target": 0}, {"function": "class EditView(ModelFormView, InstanceSpecificView):\n    page_title = gettext_lazy(\"Editing\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_edit_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"edit\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' updated.\") % {\n            \"model_name\": capfirst(self.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"user_can_delete\": self.permission_helper.user_can_delete_obj(\n                self.request.user, self.instance\n            )\n        }\n        context.update(kwargs)\n        if self.model_admin.history_view_enabled:\n            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(\n                self.instance\n            ).first()\n            context[\"history_url\"] = self.url_helper.get_action_url(\n                \"history\", quote(self.instance.pk)\n            )\n        else:\n            context[\"latest_log_entry\"] = None\n            context[\"history_url\"] = None\n\n        return super().get_context_data(**context)\n\n    def get_error_message(self):\n        name = self.verbose_name\n        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}\n\n    def get_template_names(self):\n        return self.model_admin.get_edit_template()\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        self.has_content_changes = form.has_changed()\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(\n                user=self.request.user,\n                changed=self.has_content_changes,\n            )\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.edit\",\n            revision=revision,\n            content_changed=self.has_content_changes,\n        )\n        return response", "target": 0}, {"function": "class ChooseParentView(WMABaseView):\n    def dispatch(self, request, *args, **kwargs):\n        if not self.permission_helper.user_can_create(request.user):\n            raise PermissionDenied\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_page_title(self):\n        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_form(self, request):\n        parents = self.permission_helper.get_valid_parent_pages(request.user)\n        return ParentChooserForm(parents, request.POST or None)\n\n    def get(self, request, *args, **kwargs):\n        form = self.get_form(request)\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def post(self, request, *args, **kargs):\n        form = self.get_form(request)\n        if form.is_valid():\n            return self.form_valid(form)\n        return self.form_invalid(form)\n\n    def form_valid(self, form):\n        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)\n        return redirect(\n            self.url_helper.get_action_url(\n                \"add\", self.app_label, self.model_name, parent_pk\n            )\n        )\n\n    def form_invalid(self, form):\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_choose_parent_template()", "target": 0}, {"function": "class DeleteView(InstanceSpecificView):\n    page_title = gettext_lazy(\"Delete\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_delete_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}\n\n    def confirmation_message(self):\n        return _(\n            \"Are you sure you want to delete this %(object)s? If other things in your \"\n            \"site are related to it, they may also be affected.\"\n        ) % {\"object\": self.verbose_name}\n\n    def delete_instance(self):\n        self.instance.delete()\n\n    def post(self, request, *args, **kwargs):\n        try:\n            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {\n                \"model_name\": self.verbose_name,\n                \"object\": self.instance,\n            }\n            with transaction.atomic():\n                log(instance=self.instance, action=\"wagtail.delete\")\n                self.delete_instance()\n            messages.success(request, msg)\n            return redirect(self.index_url)\n        except models.ProtectedError:\n            linked_objects = []\n            fields = self.model._meta.fields_map.values()\n            fields = (\n                obj for obj in fields if not isinstance(obj.field, ManyToManyField)\n            )\n            for rel in fields:\n                if rel.on_delete == models.PROTECT:\n                    if isinstance(rel, OneToOneRel):\n                        try:\n                            obj = getattr(self.instance, rel.get_accessor_name())\n                        except ObjectDoesNotExist:\n                            pass\n                        else:\n                            linked_objects.append(obj)\n                    else:\n                        qs = getattr(self.instance, rel.get_accessor_name())\n                        for obj in qs.all():\n                            linked_objects.append(obj)\n            context = self.get_context_data(\n                protected_error=True, linked_objects=linked_objects\n            )\n            return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_delete_template()", "target": 0}, {"function": "class InspectView(InstanceSpecificView):\n\n    page_title = gettext_lazy(\"Inspecting\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_inspect_obj(user, self.instance)\n\n    def dispatch(self, request, *args, **kwargs):\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model_admin.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"inspect\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_inspect_view_extra_css()},\n            js=self.model_admin.get_inspect_view_extra_js(),\n        )\n\n    def get_meta_title(self):\n        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_field_label(self, field_name, field=None):\n        \"\"\"Return a label to display for a field\"\"\"\n        return label_for_field(field_name, model=self.model)\n\n    def get_field_display_value(self, field_name, field=None):\n        \"\"\"Return a display value for a field/attribute\"\"\"\n\n        # First we check for a 'get_fieldname_display' property/method on\n        # the model, and return the value of that, if present.\n        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)\n        if val_funct is not None:\n            if callable(val_funct):\n                return val_funct()\n            return val_funct\n\n        # Now let's get the attribute value from the instance itself and see if\n        # we can render something useful. raises AttributeError appropriately.\n        val = getattr(self.instance, field_name)\n\n        if isinstance(val, models.Manager):\n            val = val.all()\n\n        if isinstance(val, models.QuerySet):\n            if val.exists():\n                return \", \".join([\"%s\" % obj for obj in val])\n            return self.model_admin.get_empty_value_display(field_name)\n\n        # wagtail.images might not be installed\n        try:\n            from wagtail.images.models import AbstractImage\n\n            if isinstance(val, AbstractImage):\n                # Render a rendition of the image\n                return self.get_image_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # wagtail.wagtaildocuments might not be installed\n        try:\n            from wagtail.documents.models import AbstractDocument\n\n            if isinstance(val, AbstractDocument):\n                # Render a link to the document\n                return self.get_document_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # Resort to returning the real value or 'empty value'\n        if val or val is False:\n            return val\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_image_field_display(self, field_name, field):\n        \"\"\"Render an image\"\"\"\n        from wagtail.images.shortcuts import get_rendition_or_not_found\n\n        image = getattr(self.instance, field_name)\n        if image:\n            return get_rendition_or_not_found(image, \"max-400x400\").img_tag\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_document_field_display(self, field_name, field):\n        \"\"\"Render a link to a document\"\"\"\n        document = getattr(self.instance, field_name)\n        if document:\n            return mark_safe(\n                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'\n                % (\n                    document.url,\n                    document.title,\n                    document.file_extension.upper(),\n                    filesizeformat(document.file.size),\n                )\n            )\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_dict_for_field(self, field_name):\n        \"\"\"\n        Return a dictionary containing `label` and `value` values to display\n        for a field.\n        \"\"\"\n        try:\n            field = self.model._meta.get_field(field_name)\n        except FieldDoesNotExist:\n            field = None\n        return {\n            \"label\": self.get_field_label(field_name, field),\n            \"value\": self.get_field_display_value(field_name, field),\n        }\n\n    def get_fields_dict(self):\n        \"\"\"\n        Return a list of `label`/`value` dictionaries to represent the\n        fields named by the model_admin class's `get_inspect_view_fields` method\n        \"\"\"\n        fields = []\n        for field_name in self.model_admin.get_inspect_view_fields():\n            fields.append(self.get_dict_for_field(field_name))\n        return fields\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"fields\": self.get_fields_dict(),\n            \"buttons\": self.button_helper.get_buttons_for_obj(\n                self.instance, exclude=[\"inspect\"]\n            ),\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_inspect_template()", "target": 1, "line": "@@  -1131,14 +1131,12  @@ def get_document_field_display(self, field_name, field):\n         \"\"\"Render a link to a document\"\"\"\n         document = getattr(self.instance, field_name)\n         if document:\n-            return mark_safe(\n-                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'\n-                % (\n-                    document.url,\n-                    document.title,\n-                    document.file_extension.upper(),\n-                    filesizeformat(document.file.size),\n-                )\n+            return format_html(\n+                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',\n+                document.url,\n+                document.title,\n+                document.file_extension.upper(),\n+                filesizeformat(document.file.size),\n             )\n         return self.model_admin.get_empty_value_display(field_name)\n "}, {"function": "class HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):\n    page_title = gettext_lazy(\"History\")\n    paginate_by = 50\n    columns = [\n        Column(\"message\", label=gettext_lazy(\"Action\")),\n        UserColumn(\"user\", blank_display_name=\"system\"),\n        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),\n    ]\n\n    def get_page_subtitle(self):\n        return str(self.instance)\n\n    def get_template_names(self):\n        return self.model_admin.get_history_template()\n\n    def get_queryset(self):\n        return log_registry.get_logs_for_instance(self.instance).prefetch_related(\n            \"user__wagtail_userprofile\"\n        )\n\n    def get_context_data(self, **kwargs):\n        self.object_list = self.get_queryset()\n        context = super().get_context_data(**kwargs)\n        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))\n        table = Table(\n            self.columns,\n            context[\"object_list\"],\n            base_url=index_url,\n            ordering=self.get_ordering(),\n        )\n\n        context[\"table\"] = table\n        context[\"media\"] = table.media\n        context[\"index_url\"] = index_url\n        context[\"is_paginated\"] = True\n        return context", "target": 0}], "function_after": [{"function": "class WMABaseView(TemplateView):\n    \"\"\"\n    Groups together common functionality for all app views.\n    \"\"\"\n\n    model_admin = None\n    meta_title = \"\"\n    page_title = \"\"\n    page_subtitle = \"\"\n\n    def __init__(self, model_admin):\n        self.model_admin = model_admin\n        self.model = model_admin.model\n        self.opts = self.model._meta\n        self.app_label = force_str(self.opts.app_label)\n        self.model_name = force_str(self.opts.model_name)\n        self.verbose_name = force_str(self.opts.verbose_name)\n        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)\n        self.pk_attname = self.opts.pk.attname\n        self.is_pagemodel = model_admin.is_pagemodel\n        self.permission_helper = model_admin.permission_helper\n        self.url_helper = model_admin.url_helper\n\n    def check_action_permitted(self, user):\n        return True\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        button_helper_class = self.model_admin.get_button_helper_class()\n        self.button_helper = button_helper_class(self, request)\n        return super().dispatch(request, *args, **kwargs)\n\n    @cached_property\n    def menu_icon(self):\n        return self.model_admin.get_menu_icon()\n\n    @cached_property\n    def header_icon(self):\n        return self.menu_icon\n\n    def get_page_title(self):\n        return self.page_title or capfirst(self.opts.verbose_name_plural)\n\n    def get_meta_title(self):\n        return self.meta_title or self.get_page_title()\n\n    @cached_property\n    def index_url(self):\n        return self.url_helper.index_url\n\n    @cached_property\n    def create_url(self):\n        return self.url_helper.create_url\n\n    def get_base_queryset(self, request=None):\n        return self.model_admin.get_queryset(request or self.request)\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"view\": self,\n            \"model_admin\": self.model_admin,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)", "target": 0}, {"function": "class ModelFormView(WMABaseView, FormView):\n    def setup(self, request, *args, **kwargs):\n        super().setup(request, *args, **kwargs)\n        self.edit_handler = self.get_edit_handler()\n\n    def get_form(self):\n        form = super().get_form()\n        return form\n\n    def get_edit_handler(self):\n        try:\n            edit_handler = self.model_admin.get_edit_handler()\n        except TypeError:\n            edit_handler = self.model_admin.get_edit_handler(\n                instance=None, request=None\n            )\n            warnings.warn(\n                \"%s.get_edit_handler should not accept instance or request arguments\"\n                % type(self.model_admin).__name__,\n                category=RemovedInWagtail50Warning,\n            )\n\n        return edit_handler.bind_to_model(self.model_admin.model)\n\n    def get_form_class(self):\n        return self.edit_handler.get_form_class()\n\n    def get_success_url(self):\n        return self.index_url\n\n    def get_instance(self):\n        return getattr(self, \"instance\", None) or self.model()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})\n        return kwargs\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_form_view_extra_css()},\n            js=self.model_admin.get_form_view_extra_js(),\n        )\n\n    def get_context_data(self, form=None, **kwargs):\n        if form is None:\n            form = self.get_form()\n\n        bound_panel = self.edit_handler.get_bound_panel(\n            form=form, instance=form.instance, request=self.request\n        )\n\n        prepopulated_fields = self.get_prepopulated_fields(form)\n        context = {\n            \"is_multipart\": form.is_multipart(),\n            \"edit_handler\": bound_panel,\n            \"form\": form,\n            \"prepopulated_fields\": prepopulated_fields,\n            \"media\": self.media + bound_panel.media + form.media,\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_prepopulated_fields(self, form):\n        fields = []\n        for field_name, dependencies in self.model_admin.get_prepopulated_fields(\n            self.request\n        ).items():\n            missing_dependencies = [\n                f\"'{f}'\" for f in dependencies if f not in form.fields\n            ]\n            if len(missing_dependencies) != 0:\n                missing_deps_string = \", \".join(missing_dependencies)\n                dependency_string = (\n                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"\n                )\n                warnings.warn(\n                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",\n                    category=RuntimeWarning,\n                )\n            elif field_name in form.fields:\n                fields.append(\n                    {\n                        \"field\": form[field_name],\n                        \"dependencies\": [form[f] for f in dependencies],\n                    }\n                )\n        return fields\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' created.\") % {\n            \"model_name\": capfirst(self.opts.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_success_message_buttons(self, instance):\n        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))\n        return [messages.button(button_url, _(\"Edit\"))]\n\n    def get_error_message(self):\n        model_name = self.verbose_name\n        return _(\"The %(object)s could not be created due to errors.\") % {\n            \"object\": model_name\n        }\n\n    def form_valid(self, form):\n        self.instance = form.save()\n        messages.success(\n            self.request,\n            self.get_success_message(self.instance),\n            buttons=self.get_success_message_buttons(self.instance),\n        )\n        return redirect(self.get_success_url())\n\n    def form_invalid(self, form):\n        messages.validation_error(self.request, self.get_error_message(), form)\n        return self.render_to_response(self.get_context_data(form=form))", "target": 0}, {"function": "class InstanceSpecificView(WMABaseView):\n\n    instance_pk = None\n    pk_quoted = None\n    instance = None\n    locale = None\n\n    def __init__(self, model_admin, instance_pk):\n        super().__init__(model_admin)\n        self.instance_pk = unquote(instance_pk)\n        self.pk_quoted = quote(self.instance_pk)\n        filter_kwargs = {}\n        filter_kwargs[self.pk_attname] = self.instance_pk\n        object_qs = model_admin.model._default_manager.get_queryset().filter(\n            **filter_kwargs\n        )\n        self.instance = get_object_or_404(object_qs)\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            model_admin.model, TranslatableMixin\n        ):\n            self.locale = self.instance.locale\n\n    def get_page_subtitle(self):\n        return self.instance\n\n    @cached_property\n    def edit_url(self):\n        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)\n\n    @cached_property\n    def delete_url(self):\n        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)\n\n    def get_context_data(self, **kwargs):\n        context = {\"instance\": self.instance}\n        context.update(kwargs)\n        return super().get_context_data(**context)", "target": 0}, {"function": "class IndexView(SpreadsheetExportMixin, WMABaseView):\n\n    ORDER_VAR = \"o\"\n    ORDER_TYPE_VAR = \"ot\"\n    PAGE_VAR = \"p\"\n    SEARCH_VAR = \"q\"\n    ERROR_FLAG = \"e\"\n    EXPORT_VAR = \"export\"\n    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)\n\n    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers\n    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by\n    sortable_by = None\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        # Only continue if logged in user has list permission\n        if not self.permission_helper.user_can_list(request.user):\n            raise PermissionDenied\n\n        self.list_export = self.model_admin.get_list_export(request)\n        self.list_display = self.model_admin.get_list_display(request)\n        self.list_filter = self.model_admin.get_list_filter(request)\n        self.search_fields = self.model_admin.get_search_fields(request)\n        self.items_per_page = self.model_admin.list_per_page\n        self.select_related = self.model_admin.list_select_related\n        self.search_handler = self.model_admin.get_search_handler(\n            request, self.search_fields\n        )\n        self.export = request.GET.get(self.EXPORT_VAR)\n\n        # Get search parameters from the query string.\n        try:\n            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))\n        except ValueError:\n            self.page_num = 0\n\n        self.params = dict(request.GET.items())\n        if self.PAGE_VAR in self.params:\n            del self.params[self.PAGE_VAR]\n        if self.ERROR_FLAG in self.params:\n            del self.params[self.ERROR_FLAG]\n        if self.EXPORT_VAR in self.params:\n            del self.params[self.EXPORT_VAR]\n\n        self.query = request.GET.get(self.SEARCH_VAR, \"\")\n\n        self.queryset = self.get_queryset(request)\n\n        if self.export in self.FORMATS:\n            return self.as_spreadsheet(self.queryset, self.export)\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_filename(self):\n        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"\n        return getattr(self.model_admin, \"export_filename\", super().get_filename())\n\n    def get_heading(self, queryset, field):\n        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"\n        heading_override = self.export_headings.get(field)\n        if heading_override:\n            return force_str(heading_override)\n        return force_str(\n            label_for_field(\n                field, model=self.model, model_admin=self.model_admin\n            ).title()\n        )\n\n    def to_row_dict(self, item):\n        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"\n        row_dict = OrderedDict()\n        for field in self.list_export:\n            f, attr, value = lookup_field(field, item, self.model_admin)\n            if not value:\n                value = getattr(\n                    attr,\n                    \"empty_value_display\",\n                    self.model_admin.get_empty_value_display(field),\n                )\n            row_dict[field] = value\n\n        return row_dict\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_index_view_extra_css()},\n            js=self.model_admin.get_index_view_extra_js(),\n        )\n\n    def get_buttons_for_obj(self, obj):\n        return self.button_helper.get_buttons_for_obj(\n            obj, classnames_add=[\"button-small\"]\n        )\n\n    def get_search_results(self, request, queryset, search_term):\n        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)\n        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET\n        return self.search_handler.search_queryset(queryset, search_term, **kwargs)\n\n    def get_filters_params(self, params=None):\n        \"\"\"\n        Returns all params except IGNORED_PARAMS\n        \"\"\"\n        if not params:\n            params = self.params\n        lookup_params = params.copy()  # a dictionary of the query string\n        # Remove all the parameters that are globally and systematically\n        # ignored.\n        for ignored in self.IGNORED_PARAMS:\n            if ignored in lookup_params:\n                del lookup_params[ignored]\n        return lookup_params\n\n    def get_filters(self, request):\n        lookup_params = self.get_filters_params()\n        use_distinct = False\n\n        filter_specs = []\n        if self.list_filter:\n            for list_filter in self.list_filter:\n                if callable(list_filter):\n                    # This is simply a custom list filter class.\n                    spec = list_filter(\n                        request, lookup_params, self.model, self.model_admin\n                    )\n                else:\n                    field_path = None\n                    if isinstance(list_filter, (tuple, list)):\n                        # This is a custom FieldListFilter class for a given\n                        # field.\n                        field, field_list_filter_class = list_filter\n                    else:\n                        # This is simply a field name, so use the default\n                        # FieldListFilter class that has been registered for\n                        # the type of the given field.\n                        field = list_filter\n                        field_list_filter_class = FieldListFilter.create\n                    if not isinstance(field, models.Field):\n                        field_path = field\n                        field = get_fields_from_path(self.model, field_path)[-1]\n                    spec = field_list_filter_class(\n                        field,\n                        request,\n                        lookup_params,\n                        self.model,\n                        self.model_admin,\n                        field_path=field_path,\n                    )\n\n                    # Check if we need to use distinct()\n                    use_distinct = use_distinct or lookup_spawns_duplicates(\n                        self.opts, field_path\n                    )\n                if spec and spec.has_output():\n                    filter_specs.append(spec)\n\n        # At this point, all the parameters used by the various ListFilters\n        # have been removed from lookup_params, which now only contains other\n        # parameters passed via the query string. We now loop through the\n        # remaining parameters both to ensure that all the parameters are valid\n        # fields and to determine if at least one of them needs distinct(). If\n        # the lookup parameters aren't real fields, then bail out.\n        try:\n            for key, value in lookup_params.items():\n                lookup_params[key] = prepare_lookup_value(key, value)\n                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)\n            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)\n        except FieldDoesNotExist as e:\n            raise IncorrectLookupParameters from e\n\n    def get_query_string(self, new_params=None, remove=None):\n        if new_params is None:\n            new_params = {}\n        if remove is None:\n            remove = []\n        p = self.params.copy()\n        for r in remove:\n            for k in list(p):\n                if k.startswith(r):\n                    del p[k]\n        for k, v in new_params.items():\n            if v is None:\n                if k in p:\n                    del p[k]\n            else:\n                p[k] = v\n        return \"?%s\" % urlencode(sorted(p.items()))\n\n    def _get_default_ordering(self):\n        ordering = []\n        if self.model_admin.ordering:\n            ordering = self.model_admin.ordering\n        elif self.opts.ordering:\n            ordering = self.opts.ordering\n        return ordering\n\n    def get_default_ordering(self, request):\n        if self.model_admin.get_ordering(request):\n            return self.model_admin.get_ordering(request)\n        if self.opts.ordering:\n            return self.opts.ordering\n        return ()\n\n    def get_ordering_field(self, field_name):\n        \"\"\"\n        Returns the proper model field name corresponding to the given\n        field_name to use for ordering. field_name may either be the name of a\n        proper model field or the name of a method (on the admin or model) or a\n        callable with the 'admin_order_field' attribute. Returns None if no\n        proper model field name can be matched.\n        \"\"\"\n        try:\n            field = self.opts.get_field(field_name)\n            return field.name\n        except FieldDoesNotExist:\n            # See whether field_name is a name of a non-field\n            # that allows sorting.\n            if callable(field_name):\n                attr = field_name\n            elif hasattr(self.model_admin, field_name):\n                attr = getattr(self.model_admin, field_name)\n            else:\n                attr = getattr(self.model, field_name)\n            return getattr(attr, \"admin_order_field\", None)\n\n    def get_ordering(self, request, queryset):\n        \"\"\"\n        Returns the list of ordering fields for the change list.\n        First we check the get_ordering() method in model admin, then we check\n        the object's default ordering. Then, any manually-specified ordering\n        from the query string overrides anything. Finally, a deterministic\n        order is guaranteed by ensuring the primary key is used as the last\n        ordering field.\n        \"\"\"\n        params = self.params\n        ordering = list(self.get_default_ordering(request))\n        if self.ORDER_VAR in params:\n            # Clear ordering and used params\n            ordering = []\n            order_params = params[self.ORDER_VAR].split(\".\")\n            for p in order_params:\n                try:\n                    none, pfx, idx = p.rpartition(\"-\")\n                    field_name = self.list_display[int(idx)]\n                    order_field = self.get_ordering_field(field_name)\n                    if not order_field:\n                        continue  # No 'admin_order_field', skip it\n                    # reverse order if order_field has already \"-\" as prefix\n                    if order_field.startswith(\"-\") and pfx == \"-\":\n                        ordering.append(order_field[1:])\n                    else:\n                        ordering.append(pfx + order_field)\n                except (IndexError, ValueError):\n                    continue  # Invalid ordering specified, skip it.\n\n        # Add the given query's ordering fields, if any.\n        ordering.extend(queryset.query.order_by)\n\n        # Ensure that the primary key is systematically present in the list of\n        # ordering fields so we can guarantee a deterministic order across all\n        # database backends.\n        pk_name = self.opts.pk.name\n\n        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):\n            # ordering isn't already being applied to pk\n            ordering.append(\"-\" + pk_name)\n\n        return ordering\n\n    def get_ordering_field_columns(self):\n        \"\"\"\n        Returns an OrderedDict of ordering field column numbers and asc/desc\n        \"\"\"\n\n        # We must cope with more than one column having the same underlying\n        # sort field, so we base things on column numbers.\n        ordering = self._get_default_ordering()\n        ordering_fields = OrderedDict()\n        if self.ORDER_VAR not in self.params:\n            # for ordering specified on model_admin or model Meta, we don't\n            # know the right column numbers absolutely, because there might be\n            # morr than one column associated with that ordering, so we guess.\n            for field in ordering:\n                if field.startswith(\"-\"):\n                    field = field[1:]\n                    order_type = \"desc\"\n                else:\n                    order_type = \"asc\"\n                for index, attr in enumerate(self.list_display):\n                    if self.get_ordering_field(attr) == field:\n                        ordering_fields[index] = order_type\n                        break\n        else:\n            for p in self.params[self.ORDER_VAR].split(\".\"):\n                none, pfx, idx = p.rpartition(\"-\")\n                try:\n                    idx = int(idx)\n                except ValueError:\n                    continue  # skip it\n                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"\n        return ordering_fields\n\n    def get_queryset(self, request=None):\n        request = request or self.request\n\n        # First, we collect all the declared list filters.\n        (\n            self.filter_specs,\n            self.has_filters,\n            remaining_lookup_params,\n            filters_use_distinct,\n        ) = self.get_filters(request)\n\n        # Then, we let every list filter modify the queryset to its liking.\n        qs = self.get_base_queryset(request)\n        for filter_spec in self.filter_specs:\n            new_qs = filter_spec.queryset(request, qs)\n            if new_qs is not None:\n                qs = new_qs\n\n        try:\n            # Finally, we apply the remaining lookup parameters from the query\n            # string (i.e. those that haven't already been processed by the\n            # filters).\n            qs = qs.filter(**remaining_lookup_params)\n        except (SuspiciousOperation, ImproperlyConfigured):\n            # Allow certain types of errors to be re-raised as-is so that the\n            # caller can treat them in a special way.\n            raise\n        except Exception as e:\n            # Every other error is caught with a naked except, because we don't\n            # have any other way of validating lookup parameters. They might be\n            # invalid if the keyword arguments are incorrect, or if the values\n            # are not in the correct type, so we might get FieldError,\n            # ValueError, ValidationError, or ?.\n            raise IncorrectLookupParameters(e)\n\n        if not qs.query.select_related:\n            qs = self.apply_select_related(qs)\n\n        # Set ordering.\n        ordering = self.get_ordering(request, qs)\n        qs = qs.order_by(*ordering)\n\n        # Remove duplicates from results, if necessary\n        if filters_use_distinct:\n            qs = qs.distinct()\n\n        # Apply search results\n        return self.get_search_results(request, qs, self.query)\n\n    def apply_select_related(self, qs):\n        if self.select_related is True:\n            return qs.select_related()\n\n        if self.select_related is False:\n            if self.has_related_field_in_list_display():\n                return qs.select_related()\n\n        if self.select_related:\n            return qs.select_related(*self.select_related)\n        return qs\n\n    def has_related_field_in_list_display(self):\n        for field_name in self.list_display:\n            try:\n                field = self.opts.get_field(field_name)\n            except FieldDoesNotExist:\n                pass\n            else:\n                if isinstance(field, models.ManyToOneRel):\n                    return True\n        return False\n\n    def get_context_data(self, **kwargs):\n        user = self.request.user\n        all_count = self.get_base_queryset().count()\n        queryset = self.get_queryset()\n        result_count = queryset.count()\n        paginator = Paginator(queryset, self.items_per_page)\n\n        try:\n            page_obj = paginator.page(self.page_num + 1)\n        except InvalidPage:\n            page_obj = paginator.page(1)\n\n        context = {\n            \"view\": self,\n            \"all_count\": all_count,\n            \"result_count\": result_count,\n            \"paginator\": paginator,\n            \"page_obj\": page_obj,\n            \"object_list\": page_obj.object_list,\n            \"user_can_create\": self.permission_helper.user_can_create(user),\n            \"show_search\": self.search_handler.show_search_form,\n        }\n\n        if self.is_pagemodel:\n            models = self.model.allowed_parent_page_models()\n            allowed_parent_types = [m._meta.verbose_name for m in models]\n            valid_parents = self.permission_helper.get_valid_parent_pages(user)\n            valid_parent_count = valid_parents.count()\n            context.update(\n                {\n                    \"no_valid_parents\": not valid_parent_count,\n                    \"required_parent_types\": allowed_parent_types,\n                }\n            )\n\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_index_template()", "target": 0}, {"function": "class CreateView(ModelFormView):\n    page_title = gettext_lazy(\"New\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_create(user)\n\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            user = request.user\n            parents = self.permission_helper.get_valid_parent_pages(user)\n            parent_count = parents.count()\n\n            # There's only one available parent for this page type for this\n            # user, so we send them along with that as the chosen parent page\n            if parent_count == 1:\n                parent = parents.get()\n                parent_pk = quote(parent.pk)\n                return redirect(\n                    self.url_helper.get_action_url(\n                        \"add\", self.app_label, self.model_name, parent_pk\n                    )\n                )\n\n            # The page can be added in multiple places, so redirect to the\n            # choose_parent view so that the parent can be specified\n            return redirect(self.url_helper.get_action_url(\"choose_parent\"))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                locale = get_object_or_404(Locale, language_code=selected_locale)\n            else:\n                locale = Locale.get_default()\n\n            kwargs.update(\n                {\n                    \"locale\": locale,\n                    \"translations\": [\n                        {\n                            \"locale\": locale,\n                            \"url\": self.create_url + \"?locale=\" + locale.language_code,\n                        }\n                        for locale in Locale.objects.all().exclude(id=locale.id)\n                    ],\n                }\n            )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(user=self.request.user)\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.create\",\n            revision=revision,\n            content_changed=True,\n        )\n        return response\n\n    def get_meta_title(self):\n        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_page_subtitle(self):\n        return capfirst(self.verbose_name)\n\n    def get_template_names(self):\n        return self.model_admin.get_create_template()\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            selected_locale = self.request.GET.get(\"locale\")\n            if selected_locale:\n                kwargs[\"instance\"].locale = get_object_or_404(\n                    Locale, language_code=selected_locale\n                )\n\n        return kwargs", "target": 0}, {"function": "class EditView(ModelFormView, InstanceSpecificView):\n    page_title = gettext_lazy(\"Editing\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_edit_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))\n\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"edit\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_success_message(self, instance):\n        return _(\"%(model_name)s '%(object)s' updated.\") % {\n            \"model_name\": capfirst(self.verbose_name),\n            \"object\": instance,\n        }\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"user_can_delete\": self.permission_helper.user_can_delete_obj(\n                self.request.user, self.instance\n            )\n        }\n        context.update(kwargs)\n        if self.model_admin.history_view_enabled:\n            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(\n                self.instance\n            ).first()\n            context[\"history_url\"] = self.url_helper.get_action_url(\n                \"history\", quote(self.instance.pk)\n            )\n        else:\n            context[\"latest_log_entry\"] = None\n            context[\"history_url\"] = None\n\n        return super().get_context_data(**context)\n\n    def get_error_message(self):\n        name = self.verbose_name\n        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}\n\n    def get_template_names(self):\n        return self.model_admin.get_edit_template()\n\n    def form_valid(self, form):\n        response = super().form_valid(form)\n        revision = None\n\n        self.has_content_changes = form.has_changed()\n\n        # Save revision if the model inherits from RevisionMixin\n        if isinstance(self.instance, RevisionMixin):\n            revision = self.instance.save_revision(\n                user=self.request.user,\n                changed=self.has_content_changes,\n            )\n\n        log(\n            instance=self.instance,\n            action=\"wagtail.edit\",\n            revision=revision,\n            content_changed=self.has_content_changes,\n        )\n        return response", "target": 0}, {"function": "class ChooseParentView(WMABaseView):\n    def dispatch(self, request, *args, **kwargs):\n        if not self.permission_helper.user_can_create(request.user):\n            raise PermissionDenied\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_page_title(self):\n        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_form(self, request):\n        parents = self.permission_helper.get_valid_parent_pages(request.user)\n        return ParentChooserForm(parents, request.POST or None)\n\n    def get(self, request, *args, **kwargs):\n        form = self.get_form(request)\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def post(self, request, *args, **kargs):\n        form = self.get_form(request)\n        if form.is_valid():\n            return self.form_valid(form)\n        return self.form_invalid(form)\n\n    def form_valid(self, form):\n        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)\n        return redirect(\n            self.url_helper.get_action_url(\n                \"add\", self.app_label, self.model_name, parent_pk\n            )\n        )\n\n    def form_invalid(self, form):\n        context = self.get_context_data(form=form)\n        return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_choose_parent_template()", "target": 0}, {"function": "class DeleteView(InstanceSpecificView):\n    page_title = gettext_lazy(\"Delete\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_delete_obj(user, self.instance)\n\n    @method_decorator(login_required)\n    def dispatch(self, request, *args, **kwargs):\n        if not self.check_action_permitted(request.user):\n            raise PermissionDenied\n        if self.is_pagemodel:\n            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))\n        return super().dispatch(request, *args, **kwargs)\n\n    def get_meta_title(self):\n        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}\n\n    def confirmation_message(self):\n        return _(\n            \"Are you sure you want to delete this %(object)s? If other things in your \"\n            \"site are related to it, they may also be affected.\"\n        ) % {\"object\": self.verbose_name}\n\n    def delete_instance(self):\n        self.instance.delete()\n\n    def post(self, request, *args, **kwargs):\n        try:\n            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {\n                \"model_name\": self.verbose_name,\n                \"object\": self.instance,\n            }\n            with transaction.atomic():\n                log(instance=self.instance, action=\"wagtail.delete\")\n                self.delete_instance()\n            messages.success(request, msg)\n            return redirect(self.index_url)\n        except models.ProtectedError:\n            linked_objects = []\n            fields = self.model._meta.fields_map.values()\n            fields = (\n                obj for obj in fields if not isinstance(obj.field, ManyToManyField)\n            )\n            for rel in fields:\n                if rel.on_delete == models.PROTECT:\n                    if isinstance(rel, OneToOneRel):\n                        try:\n                            obj = getattr(self.instance, rel.get_accessor_name())\n                        except ObjectDoesNotExist:\n                            pass\n                        else:\n                            linked_objects.append(obj)\n                    else:\n                        qs = getattr(self.instance, rel.get_accessor_name())\n                        for obj in qs.all():\n                            linked_objects.append(obj)\n            context = self.get_context_data(\n                protected_error=True, linked_objects=linked_objects\n            )\n            return self.render_to_response(context)\n\n    def get_template_names(self):\n        return self.model_admin.get_delete_template()", "target": 0}, {"function": "class InspectView(InstanceSpecificView):\n\n    page_title = gettext_lazy(\"Inspecting\")\n\n    def check_action_permitted(self, user):\n        return self.permission_helper.user_can_inspect_obj(user, self.instance)\n\n    def dispatch(self, request, *args, **kwargs):\n        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(\n            self.model_admin.model, TranslatableMixin\n        ):\n            translations = []\n            for translation in self.instance.get_translations().select_related(\n                \"locale\"\n            ):\n                locale = translation.locale\n                url = (\n                    self.url_helper.get_action_url(\"inspect\", translation.pk)\n                    + \"?locale=\"\n                    + locale.language_code\n                )\n                translations.append({\"locale\": locale, \"url\": url})\n\n            if translations:\n                kwargs.update(\n                    {\n                        \"locale\": self.locale,\n                        \"translations\": translations,\n                    }\n                )\n\n        return super().dispatch(request, *args, **kwargs)\n\n    @property\n    def media(self):\n        return forms.Media(\n            css={\"all\": self.model_admin.get_inspect_view_extra_css()},\n            js=self.model_admin.get_inspect_view_extra_js(),\n        )\n\n    def get_meta_title(self):\n        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}\n\n    def get_field_label(self, field_name, field=None):\n        \"\"\"Return a label to display for a field\"\"\"\n        return label_for_field(field_name, model=self.model)\n\n    def get_field_display_value(self, field_name, field=None):\n        \"\"\"Return a display value for a field/attribute\"\"\"\n\n        # First we check for a 'get_fieldname_display' property/method on\n        # the model, and return the value of that, if present.\n        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)\n        if val_funct is not None:\n            if callable(val_funct):\n                return val_funct()\n            return val_funct\n\n        # Now let's get the attribute value from the instance itself and see if\n        # we can render something useful. raises AttributeError appropriately.\n        val = getattr(self.instance, field_name)\n\n        if isinstance(val, models.Manager):\n            val = val.all()\n\n        if isinstance(val, models.QuerySet):\n            if val.exists():\n                return \", \".join([\"%s\" % obj for obj in val])\n            return self.model_admin.get_empty_value_display(field_name)\n\n        # wagtail.images might not be installed\n        try:\n            from wagtail.images.models import AbstractImage\n\n            if isinstance(val, AbstractImage):\n                # Render a rendition of the image\n                return self.get_image_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # wagtail.wagtaildocuments might not be installed\n        try:\n            from wagtail.documents.models import AbstractDocument\n\n            if isinstance(val, AbstractDocument):\n                # Render a link to the document\n                return self.get_document_field_display(field_name, field)\n        except RuntimeError:\n            pass\n\n        # Resort to returning the real value or 'empty value'\n        if val or val is False:\n            return val\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_image_field_display(self, field_name, field):\n        \"\"\"Render an image\"\"\"\n        from wagtail.images.shortcuts import get_rendition_or_not_found\n\n        image = getattr(self.instance, field_name)\n        if image:\n            return get_rendition_or_not_found(image, \"max-400x400\").img_tag\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_document_field_display(self, field_name, field):\n        \"\"\"Render a link to a document\"\"\"\n        document = getattr(self.instance, field_name)\n        if document:\n            return format_html(\n                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',\n                document.url,\n                document.title,\n                document.file_extension.upper(),\n                filesizeformat(document.file.size),\n            )\n        return self.model_admin.get_empty_value_display(field_name)\n\n    def get_dict_for_field(self, field_name):\n        \"\"\"\n        Return a dictionary containing `label` and `value` values to display\n        for a field.\n        \"\"\"\n        try:\n            field = self.model._meta.get_field(field_name)\n        except FieldDoesNotExist:\n            field = None\n        return {\n            \"label\": self.get_field_label(field_name, field),\n            \"value\": self.get_field_display_value(field_name, field),\n        }\n\n    def get_fields_dict(self):\n        \"\"\"\n        Return a list of `label`/`value` dictionaries to represent the\n        fields named by the model_admin class's `get_inspect_view_fields` method\n        \"\"\"\n        fields = []\n        for field_name in self.model_admin.get_inspect_view_fields():\n            fields.append(self.get_dict_for_field(field_name))\n        return fields\n\n    def get_context_data(self, **kwargs):\n        context = {\n            \"fields\": self.get_fields_dict(),\n            \"buttons\": self.button_helper.get_buttons_for_obj(\n                self.instance, exclude=[\"inspect\"]\n            ),\n        }\n        context.update(kwargs)\n        return super().get_context_data(**context)\n\n    def get_template_names(self):\n        return self.model_admin.get_inspect_template()", "target": 0}, {"function": "class HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):\n    page_title = gettext_lazy(\"History\")\n    paginate_by = 50\n    columns = [\n        Column(\"message\", label=gettext_lazy(\"Action\")),\n        UserColumn(\"user\", blank_display_name=\"system\"),\n        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),\n    ]\n\n    def get_page_subtitle(self):\n        return str(self.instance)\n\n    def get_template_names(self):\n        return self.model_admin.get_history_template()\n\n    def get_queryset(self):\n        return log_registry.get_logs_for_instance(self.instance).prefetch_related(\n            \"user__wagtail_userprofile\"\n        )\n\n    def get_context_data(self, **kwargs):\n        self.object_list = self.get_queryset()\n        context = super().get_context_data(**kwargs)\n        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))\n        table = Table(\n            self.columns,\n            context[\"object_list\"],\n            base_url=index_url,\n            ordering=self.get_ordering(),\n        )\n\n        context[\"table\"] = table\n        context[\"media\"] = table.media\n        context[\"index_url\"] = index_url\n        context[\"is_paginated\"] = True\n        return context", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
