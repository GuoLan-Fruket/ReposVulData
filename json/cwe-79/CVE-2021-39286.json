{"index": 6285, "cve_id": "CVE-2021-39286", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Webrecorder pywb before 2.6.0 allows XSS because it does not ensure that Jinja2 templates are autoescaped.", "cvss": "6.1", "publish_date": "August 18, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "f7bd84cdacdd665ff73ae8d09a202f60be2ebae9", "commit_message": "Localization / doc fixes (#650)\n\n* localization / doc fixes:\r\n- add missing header.html\r\n- docs: support 'i18n' extra, mention in docs\r\n- use 'default_locale' for html lang tag\r\n- access control docs: fix documentation for adding user with acl command\r\n\r\n* localization: add compile_catalog after extract as well to simplify updates for identity (en) locale\r\n\r\n* ui: \r\n- include locale in home page collection listing\r\n- keep locale on error page home link\r\n\r\n* autoescape:\r\n- ensure jinja2 templates are autoescaped to prevent xss issues (thanks @sebastian-nagel for suggested fix)\r\n- ensure banner inserts are not double-escaped\r\n- update tests for template autoescaping\r\n\r\n* update CHANGES.rst\r\n\r\n* bump version to 2.6.0b1", "commit_date": "2021-06-15T00:09:00Z", "project": "webrecorder/pywb", "url": "https://api.github.com/repos/webrecorder/pywb/commits/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9", "html_url": "https://github.com/webrecorder/pywb/commit/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9", "windows_before": [{"commit_id": "958795485675aa9e6e44f2e3f73f5afa1c023290", "commit_date": "Sat Jun 12 00:50:35 2021 -0500", "commit_message": "Fix typos in localization and access-control docs (#649)", "files_name": ["docs/manual/access-control.rst", "docs/manual/localization.rst"]}, {"commit_id": "12fcc87962a23516550b7239a1096e81811f88a5", "commit_date": "Wed Jun 9 13:12:53 2021 -0700", "commit_message": "Localization Support (#647)", "files_name": ["CHANGES.rst", "babel.ini", "config.yaml", "docs/index.rst", "docs/manual/localization.rst", "extra_requirements.txt", "pywb/apps/rewriterapp.py", "pywb/manager/locmanager.py", "pywb/manager/manager.py", "pywb/rewrite/templateview.py", "pywb/static/default_banner.js", "pywb/templates/base.html", "pywb/templates/error.html", "pywb/templates/index.html", "pywb/templates/not_found.html", "pywb/templates/search.html"]}, {"commit_id": "0eedd1502f7716fa5c54a0e9d6bf9d16d99b6c5b", "commit_date": "Wed Jun 9 12:41:08 2021 -0700", "commit_message": "remove fakeredis from tests_require, fixes #644", "files_name": ["setup.py"]}, {"commit_id": "d95b79a8abb1609a60789d82b2e8d4471c94a022", "commit_date": "Wed Jun 9 12:18:45 2021 -0700", "commit_message": "CHANGES: update changelist for 2.6.0b0 bump version to 2.6.0b0", "files_name": ["CHANGES.rst"]}, {"commit_id": "f07d35709ad96cc08b536fcd4ff6410ab4a885d9", "commit_date": "Tue May 18 20:09:18 2021 -0700", "commit_message": "Access Control Improvements: Embargo + ACL User Support (#642)", "files_name": ["docs/manual/access-control.rst", "docs/manual/cdxserver_api.rst", "docs/manual/usage.rst", "pywb/apps/rewriterapp.py", "pywb/manager/aclmanager.py", "pywb/rewrite/rewriteinputreq.py", "pywb/version.py", "pywb/warcserver/access_checker.py", "pywb/warcserver/handlers.py", "pywb/warcserver/warcserver.py", "requirements.txt", "sample-deploy/pywb-apache.conf", "sample-deploy/pywb-nginx.conf", "sample_archive/access/pywb.aclj", "tests/config_test_access.yaml", "tests/test_acl.py", "tests/test_acl_manager.py", "tests/test_embargo.py"]}, {"commit_id": "818b5187656272092b48b35f3a54917743c769e8", "commit_date": "Mon May 17 23:00:57 2021 -0700", "commit_message": "update to latest wombat (3.1.6), includes more consist post-to-get handling on client-side to match server side handling fuzzymatcher: ensure fuzzy match enabled for non-get requests", "files_name": ["pywb/static/wombat.js", "pywb/warcserver/index/fuzzymatcher.py", "wombat"]}, {"commit_id": "551b8fe0267e6ff6e535524f16e789a3eb527e06", "commit_date": "Thu May 13 10:33:58 2021 +0900", "commit_message": "xmlquery: remove space after the \"limit:\" query field name (#640)", "files_name": ["pywb/warcserver/index/indexsource.py", "pywb/warcserver/index/test/test_xmlquery_indexsource.py"]}, {"commit_id": "abb76911f5a50bf3b6c4612a4b3752c9de1caa09", "commit_date": "Wed Apr 28 16:10:39 2021 -0700", "commit_message": "Recorder Pending count (#637)", "files_name": ["pywb/apps/frontendapp.py", "pywb/recorder/recorderapp.py", "pywb/recorder/redisindexer.py", "tests/test_record_dedup.py"]}, {"commit_id": "626da99899865e7f9bf9bfdd775218b36d6a2567", "commit_date": "Tue Apr 27 20:52:24 2021 -0700", "commit_message": "POST request handling and indexing improvements (#636)", "files_name": ["appveyor.disabled.yml", "pywb/indexer/archiveindexer.py", "pywb/indexer/test/test_indexing.py", "pywb/rules.yaml", "pywb/static/wombat.js", "pywb/warcserver/inputrequest.py", "pywb/warcserver/test/test_inputreq.py", "sample_archive/cdx/post-test.cdx", "sample_archive/cdxj/post-test.cdxj", "tests/test_integration.py", "tests/test_record_replay.py", "tox.ini"]}, {"commit_id": "106a9e9200a1ddc3de302c6c7a1a6fbe025ad142", "commit_date": "Tue Apr 27 21:47:13 2021 +0200", "commit_message": "IndexHandler: report BadRequestException as error while loading index (#625)", "files_name": ["pywb/warcserver/handlers.py", "tests/test_cdx_server_app.py"]}, {"commit_id": "5d34018b9f0ae6b0e9a2101958ac21806de946f5", "commit_date": "Mon Apr 26 21:10:30 2021 -0700", "commit_message": "yt rules: more general yt rules (#635)", "files_name": ["pywb/rules.yaml"]}, {"commit_id": "ad9b431eaf9163c79ff62b72f2957c733e87652b", "commit_date": "Tue Apr 27 05:00:18 2021 +0100", "commit_message": "Update the classifiers to match the Python factors in tox.ini (#634)", "files_name": ["setup.py"]}, {"commit_id": "c5c4a54e7d4caded36dd939a75194cd89a49fdc6", "commit_date": "Tue Apr 27 12:59:37 2021 +0900", "commit_message": "xmlquery: use compressed length when available (#633)", "files_name": ["pywb/warcserver/index/indexsource.py", "pywb/warcserver/index/test/test_xmlquery_indexsource.py"]}, {"commit_id": "73d6735bed96958c7472b50d3867d462a3e0cb33", "commit_date": "Tue Apr 27 05:55:06 2021 +0200", "commit_message": "Zipnum index: do fail if counting pages with filter params (#631)", "files_name": ["pywb/warcserver/index/aggregator.py", "pywb/warcserver/index/test/test_zipnum.py"]}, {"commit_id": "cdb17c40001ae7b2e13e0f64c3c08921eb500e26", "commit_date": "Tue Apr 27 05:52:58 2021 +0200", "commit_message": "Fix dedup_index_url configuration option (#617)", "files_name": ["pywb/warcserver/warcserver.py"]}, {"commit_id": "7ce4573c70ca332566fc4efd917b5fc1eafbbc76", "commit_date": "Tue Apr 27 05:52:21 2021 +0200", "commit_message": "WarcServer CDXJ API: fail with CDXException (Bad Request) if params (#630)", "files_name": ["pywb/warcserver/index/query.py", "pywb/warcserver/index/test/test_zipnum.py", "pywb/warcserver/index/zipnum.py"]}, {"commit_id": "212691bd3808e7adfd8f8acb43fb43640adbf2fc", "commit_date": "Tue Apr 27 05:51:33 2021 +0200", "commit_message": "Handle CDXException and respond with HTTP 400 Bad Request (#626)", "files_name": ["pywb/warcserver/handlers.py", "tests/test_zipnum_auto_dir.py"]}, {"commit_id": "13ea5baee5d490a703b0ebf6efd37719b397875c", "commit_date": "Tue Apr 27 05:35:28 2021 +0200", "commit_message": "FrontendApp: forward HTTP status of CDX backend (#624)", "files_name": ["pywb/apps/frontendapp.py", "pywb/warcserver/basewarcserver.py"]}, {"commit_id": "c62b1bc9873a0bd86f2a385a8c3eb9eeb15b1315", "commit_date": "Tue Apr 27 05:33:37 2021 +0200", "commit_message": "Warcserver / CDXJ API: properly handle unsupported output formats (#623)", "files_name": ["pywb/warcserver/handlers.py", "tests/test_cdx_server_app.py"]}, {"commit_id": "4224cdd7e50c9b5e1f2299fd6420b20e5cf13ae7", "commit_date": "Tue Apr 27 05:09:18 2021 +0200", "commit_message": "IndexHandler: backward-compatibility for `fl` (fields) param (#621)", "files_name": ["pywb/warcserver/handlers.py"]}, {"commit_id": "ca14bdd8b2d9d52dbe8156abe9ba401982d6f681", "commit_date": "Tue Apr 27 05:07:19 2021 +0200", "commit_message": "AccessChecker: exact-match rules not found in single-line ACLJ file, fixes #628 (#629)", "files_name": ["pywb/warcserver/access_checker.py", "pywb/warcserver/test/test_access.py", "sample_archive/access/pywb.aclj", "sample_archive/access/single-line.aclj"]}, {"commit_id": "084be82550c33d63ed43254868990918de058530", "commit_date": "Mon Apr 26 20:04:26 2021 -0700", "commit_message": "bump version to 2.6.0.dev0", "files_name": ["pywb/version.py"]}, {"commit_id": "662fc747bf4d5e011fb3c200c0adae8b9e3bf1c6", "commit_date": "Tue Apr 27 04:58:56 2021 +0200", "commit_message": "Fix ACL loading for auto collections (#620)", "files_name": ["docs/manual/access-control.rst", "pywb/warcserver/access_checker.py", "pywb/warcserver/warcserver.py"]}, {"commit_id": "b475d85c4f1af8190c9f30ad2ce3511d49a3dc6c", "commit_date": "Mon Apr 26 18:22:43 2021 -0700", "commit_message": "tests: fix failing test? update to latest wombat (3.1.4)", "files_name": ["tests/test_force_https.py", "wombat"]}, {"commit_id": "78a9888b4673b33cfa263b5ced684a9c855331d5", "commit_date": "Tue Jan 26 22:39:52 2021 -0800", "commit_message": "Dedup Policy Tests (#613)", "files_name": ["pywb/warcserver/warcserver.py", "tests/config_test_record_dedup.yaml", "tests/test_record_dedup.py"]}, {"commit_id": "aee458b7f5bb80a3aee5e48acf3e13c036078a51", "commit_date": "Tue Jan 26 19:09:36 2021 -0800", "commit_message": "README: update for 2.5, update badge to github actions", "files_name": ["README.rst"]}, {"commit_id": "94f6273a918c5c78132e40d435d266cdeaaddf26", "commit_date": "Tue Jan 26 19:01:44 2021 -0800", "commit_message": "Update CHANGES.rst  for 2.5.0! (#612)", "files_name": ["CHANGES.rst"]}, {"commit_id": "087ef2f261b5020ba8156214fbae0ffc4eda0ba3", "commit_date": "Tue Jan 26 18:58:13 2021 -0800", "commit_message": "wombat: update to latest wombat (3.0.3)", "files_name": ["pywb/static/wombat.js", "wombat"]}, {"commit_id": "69654fd013b40d9862d15b045d6b54f4b872323a", "commit_date": "Tue Jan 26 18:54:37 2021 -0800", "commit_message": "update CHANGES for 2.5.0!", "files_name": ["CHANGES.rst"]}, {"commit_id": "e1cad621b9d49484c8cc31435b2d70e77e742a8d", "commit_date": "Tue Jan 26 18:53:54 2021 -0800", "commit_message": "Dedup Improvments (#611)", "files_name": ["docs/manual/configuring.rst", "pywb/apps/cli.py", "pywb/apps/frontendapp.py", "pywb/apps/rewriterapp.py", "pywb/recorder/multifilewarcwriter.py", "pywb/recorder/redisindexer.py", "pywb/recorder/test/test_recorder.py", "pywb/warcserver/warcserver.py"]}, {"commit_id": "ddf3207e40b36f6fb8d432f6801be1221e1904d4", "commit_date": "Wed Jan 27 02:06:18 2021 +0100", "commit_message": "Add configuration options for dedup  (#597)", "files_name": ["docs/manual/configuring.rst", "pywb/apps/frontendapp.py"]}, {"commit_id": "04d05862448d889e78038fe73a93828f273ec2a9", "commit_date": "Tue Jan 26 15:15:24 2021 -0800", "commit_message": "Rewriting Rules Update (#610)", "files_name": ["pywb/rules.yaml"]}, {"commit_id": "4683d9558038c7c87f302ce80d9e26260c8920b1", "commit_date": "Tue Jan 26 14:35:30 2021 -0800", "commit_message": "cdx sorted output: switch to default list.sort() for cdx output, fixes #608 (#609)", "files_name": ["pywb/indexer/cdxindexer.py"]}, {"commit_id": "841c02c1230f4098443226ee9e3714324f46f60b", "commit_date": "Tue Jan 26 21:54:40 2021 +0000", "commit_message": "Default closest_limit to 100 instead of 10 (#606)", "files_name": ["pywb/warcserver/index/indexsource.py"]}, {"commit_id": "07fb6bbf1d50684d96c8dcf76f12166f80423a7c", "commit_date": "Tue Jan 26 22:43:40 2021 +0100", "commit_message": "Fix default banner css namespacing (#604)", "files_name": ["pywb/static/default_banner.css", "pywb/static/default_banner.js"]}, {"commit_id": "a0aaa7558d867711ac8def879e55af1927355901", "commit_date": "Tue Jan 26 22:40:14 2021 +0100", "commit_message": "Catch uWSGI TypeError for invalid headers (#603)", "files_name": ["pywb/apps/wbrequestresponse.py"]}], "windows_after": [{"commit_id": "f9f5d2dc335b1ad7e105de6482542e4ca052b8ce", "commit_date": "Wed Jun 16 03:12:48 2021 +0200", "commit_message": "Improve docs about CDXJ Server API endpoint (#651)", "files_name": ["docs/manual/cdxserver_api.rst"]}, {"commit_id": "3ca765f84717f0b25f4ab093d22c59b6be305e13", "commit_date": "Thu Jun 17 17:38:40 2021 -0700", "commit_message": "add autoescapding disable to banner.html update CHANGES bump version to 2.6.0b2", "files_name": ["CHANGES.rst", "config.yaml", "pywb/templates/banner.html", "pywb/version.py"]}, {"commit_id": "cff2a9efc5be9e32ccfc145dfe27cfbb30179f40", "commit_date": "Fri Jun 18 14:58:21 2021 -0700", "commit_message": "more locale fixes: (#653)", "files_name": ["CHANGES.rst", "extra_requirements.txt", "pywb/apps/rewriterapp.py", "pywb/manager/manager.py", "pywb/rewrite/templateview.py", "pywb/templates/header.html", "requirements.txt", "setup.py"]}, {"commit_id": "81308780ecc17a393b684d320d80dada309b4694", "commit_date": "Thu Jun 24 11:28:48 2021 -0700", "commit_message": "version display: add -V/--version flag to wb-manager and wayback/pywb commands to display version and exit (#654)", "files_name": ["CHANGES.rst", "config.yaml", "pywb/apps/cli.py", "pywb/manager/manager.py", "pywb/rewrite/templateview.py", "pywb/version.py"]}, {"commit_id": "096850b41dd2ed5f062585427ecfd947eb39ab66", "commit_date": "Wed Jul 7 12:01:38 2021 +0800", "commit_message": "fix errors in docs/manual/rewriter.rst (#655)", "files_name": ["docs/manual/rewriter.rst"]}, {"commit_id": "843fe28ed8cc497c3a11345243dbcfc288455337", "commit_date": "Wed Jul 7 06:07:07 2021 +0200", "commit_message": "Encode url search parameter when performing query (#657)", "files_name": ["pywb/static/search.js"]}, {"commit_id": "3e5d97f70b8fd54eb535551471c76ff3bfdf90d7", "commit_date": "Sun Jul 18 22:50:56 2021 +0200", "commit_message": "Properly encode load_url (#659)", "files_name": ["pywb/warcserver/index/indexsource.py"]}, {"commit_id": "a0faf904efd6a728a59ddeed825d8e60d4c28aa5", "commit_date": "Sun Jul 18 16:40:54 2021 -0700", "commit_message": "rules: add rules for disabling dash for instagram (#662)", "files_name": ["pywb/rules.yaml"]}, {"commit_id": "98c6fba44d4faba1f6c7dda8e05f11d4817078b6", "commit_date": "Sun Jul 18 17:04:34 2021 -0700", "commit_message": "Support for custom data being added via 'PUT /<coll>/record' when\u2026 (#661)", "files_name": ["docs/manual/configuring.rst", "pywb/apps/frontendapp.py", "pywb/version.py", "tests/config_test_record.yaml", "tests/test_record_replay.py"]}, {"commit_id": "342007244b6f584c51a795c0e6384f3ed172fc93", "commit_date": "Sun Jul 18 17:13:12 2021 -0700", "commit_message": "update CHANGES.rst for 2.6.0b4 update wombat to latest", "files_name": ["CHANGES.rst", "wombat"]}, {"commit_id": "b2a460c33c1d9c549995fb1ee4decffde79cbef2", "commit_date": "Tue Aug 10 10:17:40 2021 -0500", "commit_message": "docs: fix broken links (#666)", "files_name": ["docs/manual/owb-to-pywb-deploy.rst", "docs/manual/usage.rst"]}, {"commit_id": "b28c8f17487ab5e7f1267ecdcbe9a5a42d4a280c", "commit_date": "Wed Aug 11 18:45:54 2021 -0700", "commit_message": "Eval Rewriting + Scope Fix (#668)", "files_name": ["pywb/rewrite/regex_rewriters.py", "pywb/rewrite/test/test_regex_rewriters.py", "pywb/static/autoFetchWorker.js", "pywb/static/wombat.js", "wombat"]}, {"commit_id": "96de80f83e2e18a333f488d54d21d98dce3b9433", "commit_date": "Wed Aug 11 18:49:08 2021 -0700", "commit_message": "update CHANGES for 2.6.0 release! README: update for 2.6, add links to guides! bump version to 2.6.0", "files_name": ["CHANGES.rst", "README.rst", "pywb/version.py"]}, {"commit_id": "a6be76642a3844e809c4acabe81afad6e634b201", "commit_date": "Thu Nov 11 22:30:54 2021 -0800", "commit_message": "2.6.1 Release Work (#679)", "files_name": ["CHANGES.rst", "pywb/apps/rewriterapp.py", "pywb/rewrite/html_rewriter.py", "pywb/rewrite/rewrite_dash.py", "pywb/rewrite/templateview.py", "pywb/rewrite/test/test_html_rewriter.py", "pywb/rules.yaml", "pywb/static/wombat.js", "pywb/templates/frame_insert.html", "pywb/version.py", "pywb/warcserver/test/testutils.py", "wombat"]}, {"commit_id": "e64e58f04010d333e088b9deef0a4893cf549069", "commit_date": "Fri Nov 12 17:51:34 2021 -0800", "commit_message": "2.6.2 fix (#682)", "files_name": ["CHANGES.rst", "config.yaml", "pywb/apps/rewriterapp.py", "pywb/rewrite/templateview.py", "pywb/static/css/base.css", "pywb/version.py", "tests/test_integration.py"]}, {"commit_id": "5c35a43dac4c0cb03d8a5da320ffbe7dfe950b9f", "commit_date": "Tue Dec 7 18:09:44 2021 -0600", "commit_message": "Modify examples in cdx-indexer help text to do as stated (#683)", "files_name": ["pywb/indexer/cdxindexer.py"]}, {"commit_id": "c97a66703b534f645b79d533530a0c6590efbd9c", "commit_date": "Wed Dec 22 16:15:27 2021 -0800", "commit_message": "More consistent env var setting / static path fix (#688)", "files_name": ["pywb/apps/frontendapp.py", "pywb/apps/rewriterapp.py", "pywb/version.py", "tests/test_integration.py", "wombat"]}, {"commit_id": "0c4e4068764c98ff6d69bb36a2421fdad4142261", "commit_date": "Wed Dec 22 16:51:02 2021 -0800", "commit_message": "quickfix: localization: ensure placeholder text also marked as localized, fixes #685", "files_name": ["pywb/templates/search.html"]}, {"commit_id": "de9b9310d4123b3db3a33fdfd77a106ec641e7bb", "commit_date": "Wed Dec 22 17:26:45 2021 -0800", "commit_message": "Additional fixes for 2.6.3 (#689)", "files_name": [".github/workflows/release.yaml", "CHANGES.rst", "pywb/rewrite/regex_rewriters.py", "pywb/rewrite/test/test_html_rewriter.py", "pywb/rewrite/test/test_regex_rewriters.py"]}, {"commit_id": "c0519a53c38915e0f9721fa6bf999f27df23a968", "commit_date": "Wed Dec 22 17:38:29 2021 -0800", "commit_message": "ci release: update description", "files_name": [".github/workflows/release.yaml"]}, {"commit_id": "7ff789f1a8e246720dab7744617824aa1e7d06c9", "commit_date": "Wed Dec 22 17:42:19 2021 -0800", "commit_message": "CHANGES: fix typos in changelist", "files_name": ["CHANGES.rst"]}, {"commit_id": "6bde8fd8c420ee1774712496e459798b932a4f97", "commit_date": "Wed Jan 19 18:35:39 2022 -0800", "commit_message": "wombat.js: rebuild wombat.js to 3.3.6 (was not properly rebuilt previously), alternative fix to #690 update CHANGES bump to 2.6.4", "files_name": ["CHANGES.rst", "pywb/static/wombat.js", "pywb/version.py"]}, {"commit_id": "ddcbde573c7d0451df3988adf97fd866113dff25", "commit_date": "Tue Jan 25 21:19:51 2022 -0500", "commit_message": "Documentation: Add periods to end of list of access types in docs to make consistent (#670)", "files_name": ["docs/manual/access-control.rst"]}, {"commit_id": "c42833d4ad284274675e30094f4b4ca5bcbfde62", "commit_date": "Wed Jan 26 13:21:01 2022 +1100", "commit_message": "docs: Fix a few typos (#669)", "files_name": ["pywb/utils/test/test_binsearch.py", "pywb/warcserver/resource/responseloader.py", "pywb/warcserver/resource/test/test_pathresolvers.py"]}, {"commit_id": "38b1952d342b35ac030f87d4a2048af27517cc11", "commit_date": "Tue Jan 25 19:10:28 2022 -0800", "commit_message": "live route fix: (#692)", "files_name": ["pywb/apps/rewriterapp.py", "pywb/warcserver/index/test/test_indexsource.py", "tests/test_redirect_classic.py"]}, {"commit_id": "825e4e54ab42dd81c5caea932bfd40306ef55d4d", "commit_date": "Wed Jan 26 05:40:53 2022 +0000", "commit_message": "rules: feat: remove fbclids (#691)", "files_name": ["pywb/rules.yaml"]}, {"commit_id": "0f05dbde55a55c2d013c77a20450d0b6a64640fd", "commit_date": "Tue Jan 25 23:19:23 2022 -0800", "commit_message": "CHANGES: update changelist for 2.6.4 release", "files_name": ["CHANGES.rst"]}, {"commit_id": "42445562dab4cfe68cabc82ee94d51e3c70ee037", "commit_date": "Sun Feb 20 16:36:28 2022 -0800", "commit_message": "dependency fix (#697)", "files_name": ["CHANGES.rst", "pywb/version.py", "requirements.txt"]}, {"commit_id": "0c3eb4ce94d124f0c0320a91db30951006028dba", "commit_date": "Tue Apr 5 00:59:51 2022 +0100", "commit_message": "Cope when SCRIPT_NAME is not defined (#701)", "files_name": ["pywb/apps/rewriterapp.py"]}, {"commit_id": "63ac82ee6f9f612af56468cf4bd15955033d7bad", "commit_date": "Sun Apr 10 15:48:50 2022 -0300", "commit_message": "Ping werkzeug version to 1.0.1. Fix #704 (#705)", "files_name": ["requirements.txt"]}, {"commit_id": "403167fbe009760d75a1946fe37b61b38c5796df", "commit_date": "Mon Apr 11 14:51:11 2022 -0700", "commit_message": "User-Agent Detection Fix + New-Style rewriting on by default + Dependency Update (2.6.6) (#708)", "files_name": ["CHANGES.rst", "Dockerfile", "pywb/rewrite/default_rewriter.py", "pywb/rewrite/test/test_content_rewriter.py", "pywb/utils/test/test_loaders.py", "pywb/version.py", "requirements.txt", "tests/test_integration.py"]}, {"commit_id": "09f7084aa1c81d5a43567f743f88d26aac99123b", "commit_date": "Thu Apr 14 20:21:24 2022 -0700", "commit_message": "pywb 2.6.7 (#710)", "files_name": ["CHANGES.rst", "pywb/rewrite/regex_rewriters.py", "pywb/rewrite/test/test_regex_rewriters.py", "pywb/version.py", "pywb/warcserver/inputrequest.py", "requirements.txt"]}, {"commit_id": "4f44c2ec9824e13c35d53039bf54c5198fe7b4d7", "commit_date": "Thu Apr 14 21:30:52 2022 -0700", "commit_message": "Post query json parse fix (#711)", "files_name": ["CHANGES.rst", "pywb/warcserver/inputrequest.py"]}, {"commit_id": "62633a48c454221dc1fd4a1d96c96c2c4d4a81a3", "commit_date": "Wed Jun 29 21:02:59 2022 -0400", "commit_message": "Upgrade webassets to v2.0 (#730)", "files_name": ["requirements.txt"]}, {"commit_id": "32e9020fd25469c28b2128ec7425b617a1f286fe", "commit_date": "Mon Aug 1 02:31:04 2022 +0200", "commit_message": "html_rewriter: fixed attribute 'srcset' rewriting (#712)", "files_name": ["pywb/rewrite/html_rewriter.py", "pywb/rewrite/test/test_html_rewriter.py"]}, {"commit_id": "12a9e32129b695dcbd28a6153361edcb1777de10", "commit_date": "Tue Aug 2 21:41:08 2022 -0400", "commit_message": "Prevent jinja2 from autoescaping markup in metadata (#747)", "files_name": ["pywb/templates/search.html"]}, {"commit_id": "8e06c2f351be01322bab35dddaa66311311da72e", "commit_date": "Mon Aug 8 16:18:01 2022 -0400", "commit_message": "Increase uwsgi_buffer_size for nginx config (#716)", "files_name": []}], "parents": [{"commit_id_before": "958795485675aa9e6e44f2e3f73f5afa1c023290", "url_before": "https://api.github.com/repos/webrecorder/pywb/commits/958795485675aa9e6e44f2e3f73f5afa1c023290", "html_url_before": "https://github.com/webrecorder/pywb/commit/958795485675aa9e6e44f2e3f73f5afa1c023290"}], "details": [{"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/CHANGES.rst", "code": "pywb 2.6.0b1 changelist\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAdditional documentation / localization fixes `#650 <https://github.com/webrecorder/pywb/pull/650>`_\n\n* Ensure home page and error page keeps locale, language switching is working.\n\n* Add autoescaping to Jinja2 to avoid XSS issues (suggested by @sebastian-nagel)\n\n* Add support for 'pywb[i18n]' extra to install localization dependencies\n\nDocumentation typo fixes (by @ldko, `#649 <https://github.com/webrecorder/pywb/pull/649>`_)\n\n\npywb 2.6.0b0 changelist\n~~~~~~~~~~~~~~~~~~~~~~~\n\nDocumentation Updates:\n\n* `Embargo + ACL system updates <https://pywb.readthedocs.io/en/latest/manual/access-control.html>`_\n\n* `New ACL header configuration <https://pywb.readthedocs.io/en/latest/manual/usage.html#config-acl-header>`_\n\n* `Locaalization / Multi-lingual Support Guide <https://pywb.readthedocs.io/en/latest/manual/localization.html>`_\n\n\nLocalization Improvements: (`#647 <https://github.com/webrecorder/pywb/pull/647>`_)\n\n* Support for extracting, updating, listing and removing localizable commands via ``wb-manager i18n`` command.\n\n* UI: Add language switch header to all UI templates.\n\n* Mark localizable strings in translatable in existing templates.\n\n\nAccess Control Improvements:\n\n* Support for Embargo System for date-based embargo, overridable via ACL ``allow_ignore_embargo`` `#642 <https://github.com/webrecorder/pywb/pull/642>`_\n\n* Support for custom ACL 'user' specified via ``X-pywb-ACL-User`` header passed from frontend proxies.\n\n* Fixes for exact rule matching `#629 <https://github.com/webrecorder/pywb/pull/629>`_\n\n* Fixes for ACL for auto-collections `#620 <https://github.com/webrecorder/pywb/pull/620>`_\n\n\nRewriting Improvements:\n\n* Updated YT rewriting rules `#635 <https://github.com/webrecorder/pywb/pull/635>`_\n\n* POST-to-get rewriting consistent with cdxj-indexer, wabac.js/replayweb.page `#636 <https://github.com/webrecorder/pywb/pull/636>`_\n\n* Improved fuzzy matching to ensure non-POST requests handled via fuzzy matching.\n\n* Live web: never truncate when reading POST request to avoid hung requests! (Apply limit only on indexing\n\n\nCDX Server / API Compatibility Fixes:\n\n* XmlQuery: set WARC record length field, if available `#633 <https://github.com/webrecorder/pywb/pull/633>`_\n\n* ZipNum: Don't count pages with filter `#631 <https://github.com/webrecorder/pywb/pull/631>`_\n\n* Better handle of CDX Server HTTP status `#624 <https://github.com/webrecorder/pywb/pull/624>`_\n\n* Better handling of errors from CDX Server API with 400 `#623 <https://github.com/webrecorder/pywb/pull/623>`_, `#625 <https://github.com/webrecorder/pywb/pull/625>`_, `#626 <https://github.com/webrecorder/pywb/pull/626>`_,  `#630 <https://github.com/webrecorder/pywb/pull/630>`_\n\n* Backwards compatibility of ``fl`` param  `#621 <https://github.com/webrecorder/pywb/pull/621>`_\n\n\nRecording Redis Dedup mode:\n\n* Fix dedup index config loading `#617 <https://github.com/webrecorder/pywb/pull/617>`_\n\n* Add recording size counter to track any in-flight requests `#637 <https://github.com/webrecorder/pywb/pull/637>`_\n\n\npywb 2.5.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Update to latest wombat.js (3.0.3)\n\n* Dedup Mode: Support for Redis-based dedup index to skip or write revisit records for duplicates, replay from Redis-based index `#597 <https://github.com/webrecorder/pywb/pull/597>`_, `#611 <https://github.com/webrecorder/pywb/pull/611>`_\n\n* Rewriting: Updated Rules for youtube and vimeo replay `#610 <https://github.com/webrecorder/pywb/pull/610>`_\n\n* CDX Indexing: More efficint cdx sorting  `#609 <https://github.com/webrecorder/pywb/pull/609>`_\n\n* Set default CDX closest lookup limit to 100 instead of 10 `#606 <https://github.com/webrecorder/pywb/pull/606>`_\n\n* UI: Try to avoid css class conflicts in injected banner `#604 <https://github.com/webrecorder/pywb/pull/604>`_\n\n* Catch invalid headers in uWSGI `#603 <https://github.com/webrecorder/pywb/pull/603>`_\n\n* Config option to support certificate validation when capturing `#596 <https://github.com/webrecorder/pywb/pull/596>`_\n\n* Fix indexing POST requests with multipart/form-data without boundary `#599 <https://github.com/webrecorder/pywb/pull/599>`_\n\n* New OpenWayback->pywb Transition Guide: `https://pywb.readthedocs.io/en/latest/manual/owb-transition.html <https://pywb.readthedocs.io/en/latest/manual/owb-transition.html>`_\n\n* Sample deployments with Docker Compose for running with Apache, Nginx and OutbackCDX in ``sample-deploy`` directory.\n\n* Update to latest gevent to fix issues with latest python `#583 <https://github.com/webrecorder/pywb/pull/583>`_\n\n\npywb 2.4.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* ensure RemoteCDXIndexSource also passes ``matchType`` to upstream\n\n* cdx-indexer: use ``-o`` flag to specify output, not first param (output to stdout by default)\n\n* static paths cleanup, move ``url-polyfill.min.js`` to correct dir (fixes `#571 <https://github.com/webrecorder/pywb/issues/571>`_)\n\n* minor fixes to docs\n\n* logo: resize new logo to actual size, add logo via absolute link to ensure it works on pypi also\n\n\npywb 2.4.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fix: allow timegate content check in `#564 <https://github.com/webrecorder/pywb/pull/564>`_ to be ignored (for use with derived classes)\n\n\npywb 2.4.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nThis release includes significant update, specifically merging of https://github.com/ukwa/pywb branch into this release.\nA few selected improvements:\n\n* New Access Control System: https://pywb.readthedocs.io/en/latest/manual/access-control.html\n\n* Support for Localization, configuring multiple languages (not enabled by default): https://github.com/ukwa/ukwa-pywb/blob/master/docs/localization.md\n\n* Support for OpenWayback-style XML-based index source (xmlquery)\n\n* Support for loading from WebHDFS via `webhdfs://` scheme.\n\n* Initial support for a new embeds/transclusions replay system, in combination with warcit: https://github.com/webrecorder/warcit/wiki/Warcit-Video-Audio-Conversion\n\n* Proxy mode improvements: handle OPTIONS requests and CORS `#520 <https://github.com/webrecorder/pywb/pull/520>`_\n\n* Memento Prefer header: support for experimental `Prefer` header to select 'raw' or 'rewritten' memento\n\n* Other memento fixes: fix timemap including invalid mementos, correct timegate behavior on top frame `#564 <https://github.com/webrecorder/pywb/pull/564>`_\n\n* Fixes for collection metadata display: `#509 <https://github.com/webrecorder/pywb/pull/520>`_\n\n* Fix for incorrected WARC record length due to re-serialized headers: `#561 <https://github.com/webrecorder/pywb/pull/561>`_\n\n* Filter invalid WARC records `#536 <https://github.com/webrecorder/pywb/pull/536>`_\n\n* Updated fuzzy matching rules and wombat client-side rewriting.\n\n\nFor the full changelist, see this PR: `#565 <https://github.com/webrecorder/pywb/pull/565>`_\n\n* Access Control System\n\n\npywb 2.3.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* General auto-fetch fixes (#503)\n  - Fixed issue that caused HTTP 404 errors to happen when parsing <link> stylesheet hrefs as sheets (webrecorder/wombat #11)\n  - Ensured that requests made are cached by the browser (webrecorder/wombat #13 & #15)\n  - Ensured that the request made by the backing web worker when in proxy mode are not blocked by CORS (webrecorder/wombat #13 & #15)\n\n* SOCKS proxy fixes (#504)\n  - simplify SOCKS config (avoiding global socket monkey patch), default to no cert verify to match non-proxy behavior\n  - SOCKS proxy can be disabled dynamically by setting SOCKS_DISABLE\n\n\npywb 2.3.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Improvements to auto-fetch to support page fetch (webrecroder/wombat#5, #497)\n  - Support fetching page with ``X-Wombat-History-Page`` and title ``X-Wombat-History-Title`` headers present.\n  - Attempt to extract title and pass along with cdx to ``_add_history_page()`` callback in RewriterApp, to indicate a url is a page. (#498)\n  - General auto-fetch fixes: queue messages if worker not yet inited (in proxy mode), only parse <link> stylesheet hrefs as sheets.\n\n* Cookie Rewriting Fix: don't update cookie cache on service worker (``sw_`` modifier) responses (#499)\n* Rewriting: HTML Unescape Fix: Attempt to HTML-entity-decode urls and innline styles that contain ``&#`` to get correct rewriting of encoded urls (#500)\n\n\npywb 2.3.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Proxy Mode: Ensure head insert added even if no ``<head>`` tag, insert after first tag that is not ``<html>`` or ``<head>`` (#496)\n\n\npywb 2.3.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Eval rewriting fix: don't rewrite ``$eval``, only ``eval`` identifier (#493)\n\n* Cookie rewriting improvements: (#491)\n    - Enable domain cookie cache for live index and recording modes using fakeredis, previously only available in Webrecorder\n    - Don't add duplicate cookies to Set-Cookie or Cookie headers\n    - Don't include cached Set-Cookie headers to serviceworkers for non-200 responses.\n    - Add cookies for ``sw_/`` and ``wkrf_`` modifiers\n    - Testing: add initial testing for domain cookie rewriting\n\n* Misc fixes: (#490)\n    - Ensure SCRIPT_NAME never empty (#490)\n    - Static Paths: load ``/index.html`` for paths ending in ``/``, ensure static_prefix always inited correctly\n    - Docker: switch to designated $VOLUME_DIR before initializing\n    - Rules: update rules for soundcloud\n\n\npywb 2.3.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Fix regression in wombat, new window.parent override from (webrecorder/wombat#2) was throwing exception if top-frame was cross-origin (webrecorder/wombat#3)\n* Update to latest wombat, v3.0.0\n\n\npywb 2.3.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Wombat Improvements and modularization:\n    - Client-side rewriting and auto-fetch systems moved to https://github.com/webrecorder/wombat\n    - Module-based setup and full testing for wombat\n    - Continuous auto-fetch up to 20 requests (#484)\n\n* Replay / Fidelity Improvements (#451):\n    - Introduced a new server-side rewriter, JSWorkerRewriter, that handles rewriting JS workers and service-workers\n    - Improvements to JSOP Rewriter to handle empty query (#475)\n    - Improvements to postMessage rewriting, override `eval(` while preserving scope (#475)\n    - Fixes to ``this`` proxy rewrite to include ``, this``\n\n* Misc Changes:\n    - Versioning: switched back to semver to more easily keep track of versions (#488)\n    - Improved handling of open http connections and file handles (#463)\n    - Fixes for latest urllib3, not verifying SSL certs (#467), (#469)\n    - Better logging for invalid cdxlines and cookies (#477), (#478)\n    - Fix warning in yaml.load (#472)\n    - Index invalid form-data as binary (#471)\n\n\npywb 2.2.20190410 changelist\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* Improved rewriting of JSONP, support matching JSONP with ``//`` comments (fixes #459)\n\n\npywb 2.2.20190311 changelist\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* Support for setting timestamp in proxy mode via ``--proxy-default-timestamp`` (fixes #452)\n* Remove any ``WB_wombat_`` found in POST requests from old versions of pywb.\n* Fixes new query UI when loading traditional calendar ``/*/<url>`` pages (#455, #456)\n\n\npywb 2.2.x changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* New Versioning System: (#445)\n    - Switching to hybrid semantic / calendar ``major.minor.yyyymmdd`` versioning.\n    - The ``major.minor`` version will be updated for larger changes.\n    - The ``.yyyymmdd`` date component will be updated for smaller incremental releases, for fidelity improvements and smaller bug fixes.\n    \n\n* Auto Fetch System:\n    - Added ``picture > source[srcset]`` extraction and increased the robustness of relative srcset URLs resolution (#415)\n    - Enabled auto-fetching of video, audio resources (#427)\n    - Expoxed AutoFetchWorker api in proxy mode to allow external JS to initiate checks (#389)\n\n* Build / CI Improvements:\n    - Tweaked usage of wr-tests in CI (#431)\n    - Ensured that usage of XVFB works on travis.ci (#436)\n    - Updated Docker image to support\n    - Python 3.7 support and CI testing (#447)\n\n* Docker:\n    - Updated Docker image to Python 3.7.2, match docker user uid/gid to that of existing volume (#446)\n    - Add documentation for using Docker image and automated images (#448)\n\n* Fuzzy Matching:\n    - Added an additional Facebook rule targeting timeline replay (#440)\n\n* Memento:\n    - Fixed regression in FrontendApp when handling TimeMap requests (#423)\n\n* Recording:\n    - Remove Transer-Encoding from internal response (#437)\n    - If brotli decoding package can't be loaded, remove ``br`` from ``Accept-Encoding`` header (#444)\n\n* Replay / Fidelity Improvements:\n    - Wombat now uses the actual page scheme instead of defaulting to http when extracting the original url (#404)\n    - Improved URL rewriting in web workers (#420)\n    - Improved replay of content coming from a frameset's frame (#438)\n    - Updated rules for facebook (#440)\n    - Introduce new banner behavior and ensured that banner does not become stuck displaying \"Loading...\" (#418)\n\n* Server-Side Rewriting:\n    - Improved the rewriting process of HTTP headers that are encoded in the non-standard ``UTF-8`` encoding (#402)\n    - Improved the JavaScript rewriter's rewrites of the ``location`` symbol in order to avoid rewriting ``$location`` (#403)\n    - Added an additional check of ``text/html`` content to ensure that it is actually ``html`` (#428)\n    - Fixed HTML detection for UTF-8 files starting with BOM (#441)\n    - Fixed parsing of invalid conditional comments, eg. treat '<![endif]-->' as '<![endif]>' (#441)\n\n* UI:\n   -  New Query UI with support for prefix queries, forms for advanced search via cdx server api, incremental results loading (#421)\n\n\n\n\n\npywb 2.1.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Replay Fidelity Improvements:\n   - Improved wombat web worker rewriting overrides, use custom modifier ``wkr_`` (#351)\n   - Added checks to wombat that preserve the behavior of non-wombat added polyfills to native functions (#350)\n   - Framed replay: Ensured the page title and favicon are displayed in the top-frame (#356, #369)\n   - Improved replay of request sent as ``text/html`` but are actually ``application/json``` (#367)\n   - Added replay of compressed resources by forcing decompression if the UA did not indicate it could handle the resources encoding (#372)\n   - Added ``window.origin``, and ``setTimeout``, ``setInterval`` overrides to wombat to handle the non-function callback case (#381)\n   - Added ``CSSStyleSheet.insertRule`` and ```Text``` overrides to wombat improve rewriting of dynamically added/modification of CSS (#382)\n   - Remove extra ``window.frames`` override to avoid extra override if ``window.frames === window`` (#383)\n   - Wombat inited via ``window._WBWombatInit(wbinfo);``, allows for reinit if inited 'synethically' and not from the page html insert (#383)\n   - Added ``document.evaluate`` override in-order to deproxy the context node (#385)\n   - Optimized argument de-proxying in wombat (#385)\n   - Improved iframe srcdoc rewriting in wombat (#386)\n   - Improved rewriting strings of full HTML by making the check case insensitive and looking for ``<!doctype html`` in wombat (#398)\n\n* Auto Fetch System: Background image srcset and media query fetching (#359, #379, #378, #397):\n   - Added image srcset and media query preservation system to wombat\n   - Added ``--proxy-enable-wombat`` cli flag to enable the inject of ``wombatProxyMode.js`` in proxy mode (default: false)\n   - Added ``--enable-auto-fetch`` cli flag to enable the auto fetch web worker system both url rewrite and proxy modes (default: false)\n   - Added ``FrontEndApp.proxy_fetch()`` to allow the auto fetch worker to request cross-origin style sheets\n\n* Fuzzy Matching:\n    - Decreased the aggressiveness of fuzzy matching (#362)\n    - Added an additional Facebook rule targeting timeline replay (#363)\n    - Added vimeo rule that canonicalizes the variable ```hmac/timestamp``` portion of url (#375)\n\n* Server-Side Rewriting:\n    - Refactored the regular expression rewriters in-order to avoid multiple initialization (#354)\n    - Improved unicode URL rewriting (#361, #376, #377, #380)\n    - Improved cookie rewriting in framed replay mode (#386)\n    - Improved handling of bad content-length HTTP header (#386)\n    - Fix parsing of self-closing <script> and <style> tags and rewrite SVG xlink:href (#392)\n    - Ensure 'Status' header is prefix-rewritten\n    - Support using ``X-Forwarded-Proto`` header to specify scheme for URL rewriting (#395)\n\n* Indexing:\n    - Ensure that WARC/0.18 metadata records with mime = ``text/anvl`` are not replayed\n\n* Recording:\n    - Added an option to filter the source collection (#368)\n\n* Misc Changes:\n    - Added Github Issue Templates (#353)\n    - Added replay testing to ci via webrecorder-tests (#355)\n    - Support deploying pywb under a prefix, non-root (#373)\n\n* Documentation improvements:\n   - Improved cli help message (#360)\n   - Fixed documentation enumeration bug (#364)\n   - Add documentation for auto-fetch system (#394)\n\n\npywb 2.0.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Replay Fidelity Improvements:\n   - Ensure title-only change event correctly handled by top-frame banner (#327)\n   - Improved wombat ``document.write`` and ``document.writeln`` overrides to account for the variadic case (#325)\n   - Improved wombat ``postMessage`` override logic of determining correct target origin (#328 and #338)\n   - Improved server-side rewriting of ``link[rel=preload]`` (#332)\n   - Improved server-side and client-side rewriting of \"super relative\" script src values ``script[src=path/it.php?js]`` (#334)\n   - Improved wombat un-rewrite regular expression (#332)\n   - Improved wombat ``Node.[appendChild|replaceChild|insertBefore]`` overrides to account for edge cases (#332)\n   - Added ``MouseEvent`` override to wombat (#332)\n   - Added ``insertAdjacentElement`` override to wombat (#332)\n   - Added client-side rewriting of ``link[rel=preload]`` and ``link[rel=import]`` to wombat (#332)\n   - Added FontFace override to wombat (#340)\n   - Added server-side rewriting of ``link[rel=import]`` (#334)\n   - Added SVG filter attribute rewriting to wombat (#341)\n   - Improved detection of ServiceWorker JS, use ``sw_`` modifier which performs no rewriting but adds ``Service-Worker-Allowed`` header.\n   - Don't bind already overridden ``requestAnimationFrame/clearAnimationFrame`` functions via JS object proxy (#350)\n   - Don't reinit wombat in same window if new document is imported (#339)\n   - Cookies: Use default mod ``mp_`` for client-side rewriting to ensure cookies set correctly on client-side documents (#330)\n\n* Server-Side Rewriting:\n   - Flash: Improved Rewriting for AMF, supporting py2 and py3 (#321)\n   - Improved ``Origin`` header detection: Detect from ``Referer`` header if available (#329)\n   - Expand JSONP matching if url contains 'callback=jsonp' (#336)\n   - Ensure entity-escaped urls are rewritten, with escaping preserved (#337)\n\n* Redirect Improvements:\n   - Improved self-redirect detection for adjacent self-redirect capture results, avoiding self-redirect loops (#345)\n   - Fix possible leak when handling self-redirects\n   - Add slash-preserving redirect, if original ended in '/', ensure replayed version also ends with '/' (#344, #346)\n\n* Misc Fixes:\n   - Testing: Run local ``httpbin`` for any ``httpbin.org`` or ``test.httpbin.org`` tests to avoid external dependency.\n   - Indexing: Avoid indexing error in py2 by decoding in utf-8 if warc has non-ascii target url (#312)\n   - Gevent: Preserve %-escaped request url via ``REQUEST_URI`` (if available) to pass correct url to live upstream.\n\n* Proxy Mode Options (#316, #317):\n   - Add ``use_banner`` option, if false, disables banner insert in proxy mode (default: true)\n   - Add ``use_head_insert`` option, if false, disables injecting ``head_insert.html`` in proxy mode (default: true)\n   - Add ``FrontEndApp.proxy_route_request()`` to allow more customized proxy routing (default: route to fixed default collection)\n   - Expand proxy mode docs\n\n\npywb 2.0.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Miscelaneous fixes:\n   - Fixes for Memento Aggregation when no timeout specified (#310)\n   - Fix HEAD request for replay (#309)\n   - Redis Index: always decode to native string format (decode_respones=True)\n   - Test fixes: Support latest fakeredis, more consistent tests (#313)\n   - Support forcing scheme via ``force_scheme: https`` config option (#314)\n   - Fix typo in rewrite_amf.py (#308)\n\n* Documentation improvements:\n   - Add docs for nginx deployment (#314)\n   - Fix typo in memento docs (#307)\n   - Mention timeout property Warcserver docs (#310)\n\n\npywb 2.0.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Top frame interaction improvements:\n   - Only notify from top replay frame, never from inner replay frames\n   - Don't update top frame from 'about:blank' or 'javascript:' urls\n   - New title change message when 'document.title' changes\n   - Fast redirect to top-frame when loading inner frame first\n\n* addEventListener/removeEventListener override improvements: more generic override, also handle window.onmessage\n\n* Proxy-mode improvements:\n   - don't include wombat.js (unused in proxy mode by default)\n   - set banner title to document.title on load\n   - update docs for configuring proxy mode HTTPS certs\n\n* cli: add -b/--bind flag to wayback cli to specify bind host (default to 0.0.0.0)\n\n\npywb 2.0.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Override ``Function.apply()`` to remove rewriting Proxy object from any native function calls\n* Fix top-frame notifications in new system to use correct window\n* Calendar query: Add back second display\n* Fix tests when no youtube-dl installed (#270)\n* Fix typos, setup.py classifiers, remove py2.6\n\n\npywb 2.0.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nSee the docs at https://pywb.readthedocs.org for more info.\n\n**TODO: more detailed changelist**\n\n\npywb 0.33.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fixes from pull requests:\n   - Better handling of exceptions from in wsgi_wrapper\n   - Fix CommonCrawl tests\n   - Fix broken links in README\n   - Fix travis build (requires certauth<1.2)\n\n\npywb 0.33.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Client Rewriting Improvements:\n   - Better rules for Instagram, Medium\n   - Fix window.fetch() override\n   - Work on eval() override (disabled for more testing)\n\n* Add Python 3 classifiers to setup.py\n\n\npywb 0.33.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Client-Side Rewriting Improvements:\n   - Video: More aggressive ``youtube-dl`` rewriting, try video query for any ``<object>`` with flashvars\n   - proxy: disable most client side rewriting when in proxy mode, keep non-rewriting overrides (random, Date)\n   - host relative extract: ``extract_orig()`` returns host-relative if url starts with ``/``\n   - add geolocation and notifications overrides to (auto-disable)\n   - proxy: use current protocl for video info query.\n   - fix history check bug: support changing history to exact current origin.\n   - add ``window.fetch()`` override\n   - add ``srcset`` attribute rewriting\n   - ajax: don't add ``X-Pywb-Requested-With`` header to ``data:`` urls\n   - general JS fixes, add undefined checks before acccessing ``_wb_js``, top frame, and content frame.\n  \n* Server-Side Rewriting Improvements:\n   - www canonicalization: improve regex to include urls containing ``\\r``\n   - memento: fix potential duplicate memento headers\n   - proxy: when in proxy mode, only rewrite headers related to encoding or cache\n   - proxy: add special 'proxy_js' rewriter which defaults to no rewriting for proxy mode but allows custom JS rules to still be applied. Used for JS and embedded JS in html.\n   - WbUrl: add new modifier form starting with ``$`` in addition to ending with ``_``, eg. ``/$mod:foo/http://example.com/``\n   - ajax: don't rewrite ``text/html`` responses retrieved by ajax requests (when ``X-Pywb-Requested-With`` header is present).\n   \n* Static Handler: if ``wsgi.file_wrapper`` fails, fallback to direct streaming of static ocntent.\n\n\npywb 0.32.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Template Responses: Calculate ``Content-Length`` correctly from encoded utf-8 text length\n\n* WbUrl: Improved detection of url scheme, don't treat ``a.co/?http://foo`` as having a valid scheme\n\n\npywb 0.32.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Cross-Domain Framed Replay\n   - pywb banner (outer) and content (inner) frames can be served from different domains\n   - All cross-frame interaction done via ``postMessage``, including url, hash, cookie change notifications\n  \n* Server-Side Rewriting:\n   - Don't rewrite relative urls (unless contain ``../`` or start with ``/``)\n   - Rewrite svg ``<image>`` tag\n   - Don't rewrite ``Proxy-Authenticate`` or ``WWW-Authenticate`` headers\n   - Rewrite ``href`` on any element\n   - Preserve HTML entities and spaces when rewriting CSS urls\n   - Content detect: handle ``text/plain`` text as JS or CSS if ``js_`` or ``cs_`` modifiers used\n   - Improved rewriting of ``on*`` attributes, ensure ``window.`` is added when accessing rewritten objects.\n  \n* Client-Side Rewriting:\n   - Add cookie notification message for cookies with ``Domain=`` to allow server-side handling\n   - Improved handling of Unicode prefixes, use ``decodeURI``\n   - History API: properly override go, forward, back and preserve pushState/replaceState\n   - Ensure client-rewriting for windows created by ``window.open``\n   - Override ``navigator.sendBeacon``\n   - Rewrite ``poster`` attr in dynamic elems\n   - Rewrite ``src`` attr in video ``source`` elems\n   \n* Record Loader: Option to convert  ARC->WARC records implicitly, return WARC responses (enabled by default)\n \n* Block Loader: Raise exceptions for 4xx or 5xx responses\n \n* CDX API: return not found CDX error as JSON or plain text if using ``output=json`` or ``output=text``\n \n \npywb 0.31.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* HTML rewriting:\n   - preserve empty attrs while parsing, eg. ``<tag attr>`` instead of ``<tag attr=\"\">``\n   - empty ``srcset`` attribute does not cause errors\n   - better error checking of empty attributes for all custom parsers\n\n* wombat/client side improvements:\n   - use ``postMessage()`` for inner replay frame -> outer frame updates\n   - Fix ``window.open()`` rewriting even if prototype is missing\n   - Fix double-slash in relative url rewriting\n   - ``Math.random()`` overrides uses correct window\n  \n* BufferedReader improvements:\n   - More lenient of partially decompressed data, return what was decompressed instead of raising exception.\n   - Support Brotli decompression, properly rewrite ``Content-Encoding: br``\n\n* Python 2/3 Compatibility:\n   - Decode all cdx fields to native string in py2\n  \n* BlockLoader improvements:\n   - support custom profile urls, eg. ``profile+http://`` which allow a custom profile to be selected if a profile loader is registered via ``BlockLoader.set_profile_loader()``\n  \n   - s3 loader: support profiles and AWS creds directly set in username/password of url\n\n* POST replay improvements:\n   - support ``multipart/form-data`` encoding same as ``x-www-form-urlencoded``\n   - support ``application/x-amf`` with experimental AMF rewriter (RewriteContentAMF rewriter)\n   - support generic post-data matching exact base64 encoded value.\n\n\npywb 0.30.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rules: match rule for Twitter video.\n\n* Record Loader: Only parse ``http:`` and ``https:`` urls as HTTP in ``response``, ``request`` and ``revisit`` records.\n\n\npywb 0.30.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Support for Python 3.3+ in addition to Python 2.6+\n\n* statusheaders: ``to_str()`` and ``to_bytes()`` to reconstruct status line and headers, with option to exclude certain headers\n\n* cdxobject improvements:\n   - ``conv_to_json()`` for serializing to json, with optional list of fields\n   - ``to_json()`` and ``to_cdxj()``\n   - Default JSON serialization includes all fields, except starting with ``_``\n   - Default CDXJ serialization includes all fields, except urlkey and timestamp\n   - Comparison operators for cdxobject\n   - Reading cdxline as byte buffer, individual fields as strings (python 3)\n  \n* redis: full testing of ``zrangebylex`` with new fakeredis\n\n* timeutils: add ``datetime_to_iso_date``\n  \n* cdx indexing refactor: rename ``DefaultRecordIter`` -> ``DefaultRecordParser``, a callable which creates an iterator\n\n* warcrecord loader fully read streams with no content-length, don't force 204\n\n* cookie improvements:\n   - use httplib cookie pairs directly to avoid concatenated headers (eg. for ``Set-Cookie``)\n   - don't remove ``max-age`` and ``expires`` when in live rewriting mode\n   - convert `` UTC`` -> `` GMT`` in expires to avoid Python parsing issues\n   - remove ``secure`` only if not serving from https\n   - support custom cookie rewriter\n   \n* wombat/client side improvements:\n   - rewrite ``frameElement`` -> ``WB_wombat_frameElement``, set to null for top replay frame\n   - Allow changing of ``document.domain``\n   - Rewrite ``<form action>`` and <input @value>`` in ``rewrite_elem``\n \n* Tests: improved tests, replaced doctests of dict output to regular tests for improved compatibility with different python implementations\n  \n  \n\n\n\npywb 0.11.5 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* cdx index bug fix: fix bug with cdx indexing with post-append when WARC request and response records do not alternate in the WARC.\n\n* load yaml config: ensure file stream gets closed.\n\n* zipnum: resolve paths specified in zipnum .loc file relative to the .loc file, not to application root.\n\n\npywb 0.11.4 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat: overrides ``window.crypto.getRandomValues()`` to use predictable 'random' values for improved\n  replayability in many JS applications.\n\n* fix gevent/uwsgi: run ``gevent.monkey.patch_all()`` explicitly when loading ``pywb.apps.wayback`` if ``GEVENT_MONKEY_PATCH=1`` env var is set. Set by default in ``uwsgi.ini`` for use with uwsgi. (Was previously relying on uwsgi ``gevent-early-monkey-patch`` but this flag is not yet available until uwsgi 2.1 is released).\n\n\npywb 0.11.3 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* rewrite: fix typo in ``<meta content=\"\">`` rewrite (modifier was not being set)\n\n\npywb 0.11.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rewriting: if no charset specified in original page, don't add charset to allow browser to detect.\n\n* Rewriting: rewrite ``<meta content=\"\">`` attribute if it is a url.\n\n* wb.js: pad shorter timestamp to 14 digits.\n\n* Indexing: fixed exception when indexing empty files.\n\n\npywb 0.11.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* WombatLocation: overriden properties (href, host, etc...) are enumerable to match Location to support cloning methods.\n\n* WombatLocation: reload() override now works.\n   \n* Proxy: Custom ``Pywb-Rewrite-Prefix`` allows adding a custom prefix for proxy mode rewriting\n\n* Proxy: Better error for invalid collection in ip resolve mode\n   \n* Warc Indexing Refactor: Allow custom iterators to buffer payload by overriding ``create_payload_buffer()`` to return a writable buffer.\n\n\npywb 0.11.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* New client-side test system for Wombat.js in place using Karma and SauceLabs with initial set of tests and travis integration.\n\n* Wombat Improvements:\n   - Better Safari/IE support: accessors overriden only when actually supported in browser, override gracefully skipped otherwise\n   - Use ``getOwnPropertyDescriptor()`` to get properties in addition to ``__lookupGetter__``, ``__lookupSetter__``\n   - ``baseURI`` overriden on correct prototype\n   - ``CSSStyleSheet.href`` override\n   - ``HTMLAnchorElement.toString()`` override\n   - Avoid making ``<base>.href`` read-only\n  \n* Proxy Mode Improvements:\n   - To avoid breaking HTTPS envelope, if no content-length provided, chunked encoding is used (HTTP/1.1) or response is buffered and content-length is computed (HTTP/1.0)\n   - Rewriter: Scheme-only rewriter converts embedded urls to http or https to match the scheme of containing page.\n   - IP Resolver: Supports IP cache in Redis\n   - Default resolver set to cookie resolver, eg. ``cookie_resolver: true`` is the default.\n   - Collection/datetime switching options removed from UI when auth or ip resolvers.\n  \n* Encoding: Use webencoding lib to better encode head-insert to match page encoding\n\n* Live Proxy: Support for explicit recording mode, decoupled from using http/https proxy. Enabled when ``LiveRewriter.is_recording()`` is true. By default, http/s proxies imply recording but can be overriden in derived class.\n\n* Rewriting: Convert relative urls for ``rel=canonical`` to absolute urls, even if not rewriting to ensure correct url.\n\n* UI: Use custom webkit scrollbars to minimize scrollbar-in-iframe issues that sometimes occur in Chrome.\n\n* Memento Improvements:\n   - ``/collinfo.json`` by default returns a JSON spec for all collections as Memento endpoints, in a format compatible with MemGator.\n   - ``Add /collinfo.json`` endpoint customizable via ``templates/collinfo.json`` and must be enabled with ``enable_coll_info: true``\n   - 'Not Found' error for timemap query returns empty timemap instead of standard HTML 404.\n  \n* WARC Indexing:\n  - Better detection of content-length < payload, skip to next record boundary and warn, if possible.\n  - Use ujson if proper version (without forward-slash escaping) is available when writing CDXJ\n\n\npywb 0.10.10 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* extensible BlockLoadres: supported 'http', 'https', 's3' and local file system, additional\n  loaders can now be registered by scheme.\n  \n* rewriting fixes:\n   - wombat: fix occasional style rewrite bug that resulted in leaks.\n   - strip leading or trailing spaces in url\n   - charset: default to utf-8 if unknown charset specified in HTML\n\n* live rewrite: LiveRewriter class overridable in config\n\n* WARC indexing: ignore empty records when indexing and continue, rather than stopping at first empty record.\n\n* tests: refactor integration tests to run signficantly faster.\n\n* cdx-indexer\n\n\npywb 0.10.9.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat: fix relative '/' rewrite which incorrectly handles rel scheme '//' urls\n\n\npywb 0.10.9 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* IPProxyResolver: Support new simple proxy resolver where collection and timestamp stored in server-side cache by IP and set via a rest api through `pywb.proxy` eg: ``curl -x \"localhost:8080\" http://pywb.proxy/set?ts=2015&coll=all``. No cookies or proxy auth needed in this mode. Useful for Docker-based deployments where virtual IP is fixed. Enabled with ``cookie_resolver: ip`` in ``proxy_options``.\n\n* CDX Server: Add support for timestamp-bounded queries CDX queries ``from=`` and ``to=``, also support calendar query with (inclusive) ranges, eg. ``/2010-2015/example.com``, ``/2010-/example.com/``, ``/-2015/example.com/``.\n\n* Proxy options: add ``use_banner`` to toggle banner insert, and ``use_client_rewrite`` to toggle wombat rewriting in proxy mode. (Client rewriting requires banner insert).\n\n* Proxy and Video: When in proxy mode, load youtube-dl video info via proxy magic host `pywb.proxy`, and ensure CORS support.\n\n* Rewrite: ensure ``<base>`` tag has trailing slash, or add ``<base>`` with trailing slash for host-name only urls, eg: ``http://localhost:8080/example.com``\n\n* Rules: improved blogspot nav and yt rules, rule file cleanup\n\n* Wombat 2.9 improvements, including:\n\n   - improved handling of relative paths, '..', '.', '/'\n   - better support for proxy mode, avoid cross-origin top-frame issues\n   - rewrite_html() (document.write) override only if any html changed\n   - improved form action rewrite\n   - improved rewriting in 'root collection' mode\n   \n   \npywb 0.10.8 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rewrite: url attribute entity unencoding only if attr starts with 'http', catch any exceptions.\n\n* Fix top frame detection to avoid occasional banner insertion into intermediate frames.\n\n* Fix special case ``href = \".\"`` rewriting.\n\n\npywb 0.10.7 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.8 improvements, including:\n\n    - cookies: fixed rewriting with respect to comma, proper path and domain replacement\n    - form action and textContent rewriting\n    - document.write() improvements, buffering split tag and removing extraneous end tag\n    - document.writeln() rewriting\n    - object data attr conditional rewriting\n    - proper ``setAttribute(\"style\", ...`` rewriting\n    - style rewrite regex now case-insensitive\n    \n* 10-field CDX format fully supported.\n \n* rewrite: \"background\" attr rewriting, proper rewriting of entity-encoded attributes.\n \n* Fix for regression for Vimeo videos that were recorded as Flash but replay as HTML.\n  \n\npywb 0.10.6 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Disable url rewriting in JS by default! No longer needed due to improved client side rewriting of all urls.\n\n* wombat 2.7 more rewriting improvements:\n\n    - ``document.write`` override rewrites all elements, not just one top level elements.\n\n    - iframe ``srcdoc`` also rewritten.\n\n    - support for custom modifiers, such as ``js_`` for ``SCRIPT`` tag rewriting, otherwise for element overrides.\n\n    - improved css rewriting, override standard css attributes on ``CSSStyleDeclaration`` to avoid mutation observers, rewrite ``STYLE`` text content.\n    \n    - ``postMessage``: original ``source`` window now also preserved along with origin.\n\n    - cookie rewrite: don't remove expires, but adjust by date offset. Allow cookies to be deleted by setting to expired date.\n\n* Embed mode, pywb framed replay can now be embedded in an iframe when ``embeddable: True`` option is set. ``postMessage`` on framed replay proxies between replay frame and embedded frame, and ``window.parent`` is not set to top replay frame, allowing access to containing frame.\n\n* vidrw: don't replace video with generic swf, find better match.\n\n* path index loader: ensure each request handled by own file reader.\n\n\npywb 0.10.5 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.6 client side rewriting improvements:\n\n    - Override JS prototype getters and setters on ``href`` and ``src`` attributes of standard HTML elements, so that JavaScript access receives and sets the original url, but the element actually contains the rewritten url internally.\n    \n    - For ``<a>`` element override other url properties ``href``, ``hostname``, ``host``, ``pathname``, ``origin``, ``search``, ``port``, ``protocol``\n    \n    - Improved ``postMessage`` emulation: Ensure the original ``origin`` of the caller is saved, by wrapping ``X.postMessage`` in a special ``X.__WB_pmw(window).postMessage()`` call which will save origin of current window in X. Store origin and destination hosts.\n    \n    - Improved ``message`` listener emulation: Add filtering to skip messages that were not inteded for destination host.\n    \n    - Restored wombat if wiped by ``document.write`` / ``document.open`` (happens on FF).\n    \n    - When rewriting html for ``document.write``, keep ``<html>``, ``<head>``, ``<body>`` tags in rewritten html.\n    \n    \n* Relative urls rewritten to stay relative, eg. ``/path/file.html`` -> ``/coll/http://example.com/path/file.html``\n  Can be disabled with ``no_match_rel=True`` in ``rewrite_opts``.\n    \n* Optional ``force_html_decl`` option to add a ``<!DOCTYPE>`` or other HTML declaration if none is present.\n    \n* Improved handling for `redir_to_exact=False`` mode. When set, no redirect on memento timegate, and serve ``Content-Location   `` headers for actual memento, in conformance with Mememnto RFC Pattern 2.2 (http://tools.ietf.org/html/rfc7089#section-4.2.2)\n\n\n* Proxy Mode Fixes: Ensure ``Content-Length`` header is always added and correct in proxy mode, needed for proper HTTPS      \n  handling within ``CONNECT`` envelope.\n\n* New default ``HostScopeCookieRewriter`` sets cookies with domain ``/coll/https://example.com/`` instead of ``/coll/``.\n  Can be specified with ``cookie_scope: host`` per collection.\n  This is now the default live rewrite proxy and should be much safer/secure. For rare login use cases, the collection\n  root scope can be specified with ``cookie_scope: coll``.\n  \n* Cookie ``Path=`` value always a relative path for all cookie scopes, previously were often absolute paths.\n\n* Default WSGI handler for ``wayback`` back to ``wsgiref``, as ``waitress`` does not support proxy mode.\n\n\npywb 0.10.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.5 update -- significant wombat improvements:\n\n    - Cookies: more comprehensive client-side cookie overriding, including Path, Domain, and expires removal.\n\n    - ``WB_wombat_location`` overriden on Object prototype, defaults to ``location`` if ``_WB_wombat_location``, the actual,     property is not set.\n\n    - ``WB_wombat_location.href`` proxies to actual location, responsive to ``pushState`` / ``replaceState`` location changes.\n    - ``.href`` and ``.src`` attributes correctly return original url in JavaScript.\n    \n    - More consistent and ``lookupGetter/lookupSetter`` overrides with ``Object.defineProperty``.\n\n    - Added baseURI override, ``Element.prototype and ``document``.\n\n    - Added ``insertAdjacentHTML()`` override.\n\n    - Improved iframe override, including check for `contentDocument` changes.\n\n    - Don't rewrite urls that start with ``{``\n\n- Frames mode: ensure hash changes synchronized between inner and outer frames.\n\n- video: don't rewrite generic 'swf' with flowplayer\n\n- deprefix: support deprefixing of url-encoded queries.\n\n\npywb 0.10.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n- Support ``Content-Encoding: deflate`` which was not being handled.\n\n- Fix issues with ``fallback`` handlers: A POST request could result in double read of POST input data.\n\n- ``youtube-dl`` removed from dependency as it is only needed for live proxy. (related tests only run if ``youtube-dl`` is installed).\n\n\npywb 0.10.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Per-collection cacheing settings: ``rewrite_opts.http_cache`` can be set to:\n\n    - ``pass`` - keep cacheing headers as-is (applies to ``Cache-Control``, ``Expires``, ``Etag`` and ``Last-Modified``)\n    - ``0`` - add ``Cache-Control: no-cache; no-store``\n    - ``N`` - add ``Cache-Control: max-age=N`` and corresponding ``Expires`` header\n    - None (default) -- Rewrite cache headers, effectively removing them (current behavior)\n  \n* New improved Wombat, including:\n\n    - better handling of new iframes set to ``about:blank``, add all overrides\n    - createElement() override (can be disabled)\n    - innerHTML prototype override (can be disabled)\n    \n* Rules: Improved rewriting for Google+, Twitter, YT comments\n\n* Video: Improved support for LiveStream playlist, detect newly added <object> and <embed> videos (with mutation observers)\n\n* Indexing: Add contents of ``WARC-Json-Metadata`` to ``metadata`` field in cdx-json\n\n* Buffering: Only buffer when content-length is missing and only up-to first 16K\n\n* ZipNum: Fix bug with contents of last block being inaccessible, improved test coverage for zipnum.\n    \n\n\npywb 0.9.8 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* auto config: allow custom settings set in shared ``config.yaml`` to be used with automatic collections.\n\n* wombat fixes: fixes situation where setAttribute was not being rewritten.\n\n* wombat fixes: obey ``_no_rewrite==true`` more consistently in rewrite_elem\n\n* wombat fixes: remove incorrect timezone offset in Date override.\n\n* wombat: new 'node added' mutation observer which will rewrite any newly added elements, may simplify other\n  rewriting cases. Not enabled by default yet requires setting ``client.use_node_observers`` to use.\n\n* regex rewrite: tweak ``top`` and scheme relative regexes to better avoid false positives\n\n* html rewrite: handle ``parse_comments`` by rewriting as html, instead of as javascript.\n\n* html rewrite: if html content has no <head> tags and no body tags, insert head_insert at end of document.\n\n* html rewrite: don't insert banner in ajax requests, wombat always adds ``X-Requested-With: XMLHttpRequest``.\n\n* scheme relative urls: rewrite to current scheme, if known, otherwise keep scheme relative, instead of defaulting to http.\n\n\npywb 0.9.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* wombat enchancements: support for mutation observers instead of ``setAttribute`` override with ``client.use_attr_observers`` setting.\n  Can also disable worker override with ``skip_disable_worker``\n  \n* wombat fixes: Better check for self-redirect when proxying ``replace()`` and ``assign()``, use ``querySelectorAll()`` for dom selection\n\n* wombat fixes: Don't remove trailing slash in ``extract_orig()``, treat slash and no-slash urls as distinct on the client (as expected).\n\n* cdx-indexer: Validation of HTTP protocol and request verbs now optional. Any protocol and verb will be accepted, unless ``-v`` flag is used,\n  allowing for indexing of content with custom verbs, unexpected protocol, etc...\n\n\npywb 0.9.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* framed replay: fix bug where outer frame url was not updated (in inverse mode) after navigating inner frame.\n\n* framed replay: lookup frame by id, ``replay_iframe``, instead of by using ``window.frames[0]`` to allow for more customization.\n\n* fix typo in wombat ``no_rewrite_prefixes``\n\n\npywb 0.9.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* s3 loading: support ``s3://`` scheme in block loader, allowing for loading index and archive files from s3. ``boto`` library must be installed seperately\n  via ``pip install boto``. Attempt default boto auth path, and if that fails, attempt anonymous s3 connection.\n  \n* Wombat/Client-Side Rewrite Customizations: New ``rewrite_opts.client`` settings from ``config.yaml`` are passed directly to wombat as json. \n  \n  Allows for customizing wombat as needed. Currently supported options are: ``no_rewrite_prefixes`` for ignoring rewrite\n  on certain domains, and ``skip_dom``, ``skip_setAttribute`` and ``skip_postmessage`` options for disabling \n  those overrides. Example usage in config:\n  \n  ::\n\n    rewrite_opts:\n        ...\n        client:\n            no_rewrite_prefixes: ['http://dont-rewrite-this.example.com/']\n  \n            skip_setAttribute: true\n            skip_dom: true\n            skip_postmessage: true\n  \n  \n* Revamp template setup: All templates now use shared env, which is created on first use or can be explicitly set (if embedding)\n  via ``J2TemplateView.init_shared_env()`` call. Support for specifiying a base env, as well as custom template lookup paths also provided\n  \n* Template lookup paths can also be set via config options ``templates_dirs``. The default list is: ``templates``, ``.``, ``/`` in that order.\n\n* Embedding improvements: move custom env (``REL_REQUEST_URI`` setup) into routers, should be able to call router created by ``create_wb_router()`` \n  directly with WSGI enviorn and receive a callable response.\n\n* Embedding improvements: If set, the contents of ``environ['pywb.template_params']`` dictionary are added directly to Jinja context, allowing for custom template\n  params to be passed to pywb jinja templates.\n\n* Root collection support: Can specify a route with `''` which will be the root collection. Fix routing paths to ensure root collection is checked last.\n\n* Customization: support custom route_class for cdx server and pass wbrequest to ``not_found_html``  error handlers.\n\n* Manager: Validate collection names to start with word char and contain alphanum or dash only.\n\n* CLI refactor: easier to create custom cli apps and pass params, inherit shared params. ``live-rewrite-server`` uses new system cli system,\n  defaults to framed inverse mode. Also runs on ``/live/`` path by default. See ``live-rewrite-server -h`` for a list of current options.\n\n* Add ``cookie_scope: removeall`` cookie rewriter, which will, remove all cookies from replay headers.\n\n* Security: disable file:// altogether for live rewrite path.\n\n* Fuzzy match: better support for custom replace string >1 character: leave string, and strip remainder before fuzzy query.\n\n* Urlrewriter and wburl fixes for various corner cases.\n\n* Rangecache: use url as key if digest not present.\n\n* Framed replay: attempt to mitigate chrome OS X scrolling issue by disabling ``-webkit-transform: none`` in framed mode. \n  Improves scrolling on many pages but not always consistent (a chrome bug).\n\n\npywb 0.9.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* framed replay mode: support ``framed_replay: inverse`` where the top frame is the canonical archival url and the inner frame has ``mp_`` modifier.\n\n* wb.js: improved redirect check: only redirect to top frame in framed mode and compare decoded urls.\n\n* charset detection: read first 1024 bytes to determine charset and add to ``Content-Type`` header if no charset is specified there.\n\n* indexing: support indexing of WARC records with ``urn:`` values as target uris, such as those created by `wpull <https://github.com/chfoo/wpull>`_\n\n* remove certauth module: now using standalone `certauth <http://github.com/ikreymer/certauth>`_ package.\n\n* BlockLoader: use ``requests`` instead of ``urllib2``.\n\n* cdx: %-encode any non-ascii chars found in cdx fields.\n\n* cdx: showNumPages query always return valid result (not 404) for 0 pages. If <1 block, load cdx to determine if 1 page or none.\n\n\npywb 0.9.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Collections Manager: Allow adding any templates to shared directory, fix adding WARCs with relative path.\n\n* Replay: Remove limit by HTTP ``Content-Length`` as it may be invalid (only using the record length).\n\n* WARC Revisit-Resolution Improvements: Support indexes and warcs without any ``digest`` field. If no digest is found, attempt to look up\n  the original WARC record from the ``WARC-Refers-To-Target-URI`` and ``WARC-Refers-To-Date`` only, even for same url revisits.\n  (Previously, only used this lookup original url was different from revisit url)\n\n\npywb 0.9.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Implement pagination support for zipnum cluster and added to cdx server api:\n\n  https://github.com/ikreymer/pywb/wiki/CDX-Server-API\n\n* cdx server query: add support for ``url=*.host`` and ``url=host/*`` as shortcuts for ``matchType=domain`` and ``matchType=prefix``\n\n* zipnum cdx cluster: support loading index shared from prefix path instead of seperate location file.\n\n  The ``shard_index_loc`` config property may contain match and replace properties.\n  Regex replacement is then used to obtain path prefix from the shard prefix path.\n\n* wombat: fix `document.write()` rewriting to rewrite each element at a time and use underlying write for better compatibility.\n\n\npywb 0.9.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* New directory-based configuration-less init system! ``config.yaml`` no longer required.\n\n* New ``wb-manager`` collection manager for adding warcs, indexing, adding/removing templates, setting metadata.\n\n  More details at: `Auto-Configuration and Wayback Collections Manager <https://github.com/ikreymer/pywb/wiki/Auto-Configuration-and-Wayback-Collections-Manager>`_\n\n* Support for user metadata via per-collection ``metadata.yaml``\n\n* Templates: improved/simpified home page and collection search page, show user metadata by default.\n\n* Support for writing and reading new cdx JSON format (.cdxj), with searchable key followed by json dictionary: ``urlkey timestamp { ... }`` on each line\n\n* ``cdx-indexer -j``: support for generating cdxj format\n\n* ``cdx-indexer -mj``: support for minimal cdx format (in JSON format) only which skips reading the HTTP record.\n\n    Fields included in minimal format are: urlkey, timestamp, original url, record length, digest, offset, and filename\n\n* ``cdx-indexer --root-dir <dir>``: option for custom root dir for cdx filenames to be relative to this directory.\n\n* ``wb-manager cdx-convert``: option to convert any existing cdx to new cdxj format, including ensuring cdx key is in SURT canonicalized.\n\n* ``wb-manager autoindex `` / ``wayback -a`` -- Support for auto-updating the cdx indexes whenever any WARC/ARC files are modified or created.\n\n* Switch default ``wayback``,  ``cdx-server``, ``live-rewrite-server`` cli apps to use ``waitress`` WSGI container instead of wsgi ref.\n\n  New cli options, including ``-p`` (port), ``-t`` (num threads), and ``-d`` (working directory)\n\n* url rewrite: fixes to JS url rewrite (some urls with unencoded chars were not being rewritten),\n  fixes to WbUrl parsing of urls starting with digits (eg. 1234.example.com) not being parsed properly.\n\n* framed replay: update frame_insert.html to be html5 compliant.\n\n* wombat: fixed to WB_wombat_location.href assignment, properly redirects to dest page even if url is already rewritten\n\n* static paths: static content included with pywb moved from ``static/default`` -> ``static/__pywb`` to free up default as possible collection name\n  and avoid any naming conflicts. For example, wombat.js can be accessed via ``/static/__pywb/wombat.js``\n\n* default to replay with framed mode enabled: ``framed_replay: true``\n\n\npywb 0.8.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* cookie rewrite: all cookie rewriters remove ``secure`` flag to allow equivalent replay of sites with cookies via HTTP and HTTPS.\n\n* html rewrite: fix ``<base>`` tag rewriting to add a trailing slash to the url if it is a hostname with no path, ex:\n\n  ``<base href=\"http://example.com\" />`` -> ``<base href=\"http://localhost:8080/rewrite/http://example.com/\" />``\n\n* framed replay: fix double slash that remainded when rewriting top frame url.\n\n\npywb 0.8.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* rewrite: fix for redirect loop related to pages with 'www.' prefix. Since canonicalization removes the prefix, treat redirect to 'www.' as self-redirect (for now).\n\n* memento: ensure rel=memento url matches timegate redirect exactly (urls may differ due to canonicalization, use actual instead of requested for both)\n\n\npywb 0.8.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* wb.js top frame notification: use ``window.__orig_parent`` when referencing actual parent as ``window.parent`` now overriden.\n\n* live proxy security: enable ssl verification for live proxy by default, for use with python 2.7.9 ssl improvements. Was disabled\n  due to incomplete ssl support in previous versions of python. Can be disabled via ``verify_ssl: False`` per collection.\n\n* cdx-indexer: add recursive option to index warcs in all subdirectories with ``cdx-indexer -r <dir_name>``\n\n\npywb 0.8.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nImprovements to framed replay, memento support, IDN urls, and additional customization support in preparation for further config changes.\n\n* Feature: Full support for 'non-exact' or sticky timestamp browsing in framed and non-framed mode.\n\n  - setting ``redir_to_exact: False`` (per collection), no redirects will be issued to the exact timestamp of the capture.\n    The user-specified timestamp will be preserved and the number of redirects will be reduced.\n\n  - if no timestamp is present (latest-replay request), there is a redirect to the current time UTC timestamp,\n    available via ``pywb.utils.timeutils.timestamp_now()`` function.\n\n  - via head-insert, the exact request timestamp is provided as ``wbinfo.request_ts`` and accessible to the banner insert or the top frame when in framed mode.\n\n* Frame Mode Replay Improvements, including:\n\n  - wombat: modify ``window.parent`` and ``window.frameElement`` to hide top-level non replay frame.\n\n  - memento improvements: add same memento headers to top-level frame to match replay frame to ensure top-level frame\n    passes memento header validation.\n\n  - frame mode uses the request timestamp instead of the capture timestamp to update frame url.\n    By default, request timestamp == capture timestamp, unless ``redir_to_exact: False`` (see above).\n\n* Client-Side Rewrite Improvements:\n\n  - improved ``document.write`` override to also work when in ``<head>`` and append both ``<head>`` and ``<body>``\n\n  - detect multiple calls to rewrite attribute to avoid rewrite loops.\n\n* Customization improvements:\n\n  - ability to override global UrlRewriter with custom class by setting ``urlrewriter_class`` config setting.\n\n  - ability to disable JS url and location rewrite via ``js_rewrite_location: none`` setting.\n\n  - ability to set a custom content loader in place of default ARC/WARC loader in ``ReplayView._init_replay_view``\n\n* Improved Memento compatibility, ensuring all responses have a ``rel=memento`` link.\n\n* IDN support: Improved handling of non-ascii domains.\n\n  - all urls are internally converted to a Punycode host, percent encoded path using IDNA encoding (http://tools.ietf.org/html/rfc3490.html).\n  - when rendering, return convert all urls to fully percent-encoded by default (to allow browser to convert to unicode characters).\n  - ``punycode_links`` rewrite option can be enabled to keep ascii-punycode hostnames instead of percent-encoding.\n\n\npywb 0.7.8 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* live rewrite fix: When forwarding ``X-Forwarded-Proto`` header, set scheme to actual url scheme to avoid possible redirect loops (#57)\n\n\npywb 0.7.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* client-side rewrite: improved rewriting of all style changes using mutation observers\n\n* rules: fix YT rewrite rule, add rule for wikimedia\n\n* cdx-indexer: minor cleanup, add support for custom writer for batched cdx (write_multi_cdx_index)\n\n\npywb 0.7.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* new not found Jinja2 template: Add per-collection-overridable ``not_found.html`` template, specified via ``not_found_html`` option. For missing resources, the ``not_found_html`` template is now used instead of the generic ``error_html``\n\n* client-side rewrite: improved wombat rewrite of postMessage events, unrewrite target on receive, improved Vine replay\n\n* packaging: allow adding multiple packages for Jinja2 template resolving\n\npywb 0.7.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Cross platform fixes to support Windows -- all tests pass on Linux, OS X and Windows now. Improved cross-platform support includes:\n\n  - read all files as binary to avoid line ending issues\n  - properly convert between platform dependent file paths and urls\n  - add .gitattributes to ensure line endings on *.warc*, *.arc*, *.cdx* files are unaltered\n  - avoid platform dependent apis (eg. %s for strftime)\n\n* Change any unhandled exceptions to result in a 500 error, instead of 400.\n\n* Setup: switch to ``zip_safe=True`` to allow for embedding pywb egg in one-file app with `pyinstaller <https://github.com/pyinstaller/pyinstaller>`_\n\n* More compresensive client side ``src`` attribute rewriting (via wombat.js), additional server-side HTML tag rewriting.\n\n\npywb 0.7.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Experiment with disabling DASH for YT\n\n* New ``req_cookie_rewrite`` rewrite directive to rewrite outgoing ``Cookie`` header, can be used to fix a certain cookie for a url prefix.\n\n  A list of regex match/replace rules, applied in succession, can be set for each url prefix. See ``rules.yaml`` for more info.\n\n\npywb 0.7.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* (0.7.1 fixes some missing static files from 0.7.0 release)\n\n* Video/Audio Replay, Live Proxy and Recording Support (with pywb-webrecorder)!\n\n  See: `Video Replay and Recording <https://github.com/ikreymer/pywb/wiki/Video-Replay-and-Recording>`_ for more detailed info.\n\n* Support for replaying HTTP/1.1 range requests for any archived resorce (optional range cache be disabled via `enable_ranges: false`)\n\n* Support for on-the-fly video replacement of Flash with HTML5 using new video rewrite system ``vidrw.js``.\n\n  (Designed for all Flash videos, with varying levels of special cases for YouTube, Vimeo, Soundcloud and Dailymotion)\n\n* Use `youtube-dl <http://rg3.github.io/youtube-dl/>`_ to find actual video streams from page urls, record video info.\n\n* New, improved wombat 2.1 -- improved rewriting of dynamic content, including:\n\n  - setAttribute override\n  - Date override sets date to replay timestamp\n  - Image() object override\n  - ability to disable dynamic attribute rewriting by setting ``_no_rewrite`` on an element.\n\n* Type detection: resolve conflict between text/html that is served under js_ mod, resolve if html or js.\n\n\npywb 0.6.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* JS client side improvements: check for double-inits, preserve anchor in wb.js top location redirect\n\n* JS Rewriters: add mixins for link + location (default), link only, location only rewriting by setting ``js_rewrite_location`` to ``all``, ``urls``, ``location``, respectively.\n\n  (New: location only rewriting does not change JS urls)\n\n* Beginning of new rewrite options, settable per collections and stored in UrlRewriter. Available options:\n\n  - ``rewrite_base`` - set to False to disable rewriting ``<base href=\"...\">`` tag\n  - ``rewrite_rel_canon`` - set to false to disable rewriting ``<link rel=canon href=\"...\">``\n\n* JS rewrite: Don't rewrite location if starting with '$'\n\n\npywb 0.6.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* fix static handling when content type can not be guessed, default to 'application/octet-stream'\n\n* rewrite fix: understand partially encoded urls such as http%3A// in WbUrl, decode correctly\n\n* rewrite fix: rewrite \\/\\/example.com and \\\\/\\\\/example.com in JS same as \\\\example.com\n\n* cookies: add exact cookie rewriter which sets cookie to exact url only, never collection or host root\n\n* don't rewrite rel=canonical links for services which rely on these\n\n* cdx-indexer: Detect non-gzip chunk encoded .warc.gz/arc.gz archive files and show a meaningful\n  error message explaining how to fix issue (uncompress and possibly use warctools warc2warc to recompress)\n\n\npywb 0.6.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Ignore bad multiline headers in warc.\n\n* Rewrite fix: Don't parse html entities in HTML rewriter.\n\n* Ensure cdx iterator closed when reeading.\n\n* Rewrite fix: remove pywb prefix from any query params.\n\n* Rewrite fix: better JS rewriting, avoid // comments when matching protocol-relative urls.\n\n* WARC metadata and resource records include in cdx from cdx-indexer by default\n\n\npywb 0.6.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fixes for extensability and support https://webrecorder.io, easier to override any request (handle_request), handle_replay or handle_query via WBHandler\n\n\npywb 0.6.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Invert framed replay paradigm: Canonical page is always without a modifier (instead of with ``mp_``), if using frames, the page redirects to ``tf_``, and uses replaceState() to change url back to canonical form.\n\n* Enable Memento support for framed replay, include Memento headers in top frame\n\n* Easier to customize just the banner html, via ``banner_html`` setting in the config. Default banner uses ui/banner.html and inserts the script default_banner.js, which creates the banner.\n\n  Other implementations may create banner via custom JS or directly insert HTML, as needed. Setting ``banner_html: False`` will disable the banner.\n\n* Small improvements to streaming response, read in fixed chunks to allow better streaming from live.\n\n* Improved cookie and csrf-token rewriting, including: ability to set ``cookie_scope: root`` per collection to have all replayed cookies have their Path set to application root.\n\n  This is useful for replaying sites which share cookies amongst different pages and across archived time ranges.\n\n* New, implified notation for fuzzy match rules on query params (See: `Fuzzy Match Rules <https://github.com/ikreymer/pywb/wiki/Fuzzy-Match-Rules>`_)\n\n\npywb 0.6.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* HTTPS Proxy Support! (See: `Proxy Mode Usage <https://github.com/ikreymer/pywb/wiki/Pywb-Proxy-Mode-Usage>`_)\n\n* Revamped HTTP/S system: proxy collection and capture time switching via cookie!\n\n* removed *hostnames* setting in config.yaml. pywb no longer needs to know the host(s) it is running on,\n  can infer the correct path from referrer on a fallback handling.\n\n* remove PAC config, just using direct proxy (HTTP and HTTPS) for simplicity.\n\n\npywb 0.5.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* bug fix: self-redirect check resolves relative Location: redirects\n\n* rewrite rules: 'parse_comments' option to parse html comments as JS, regex rewrite update to match '&quot;http:\\\\\\\\/' double backslash\n\n* bug fixes in framed replay for html content, update top frame for html content on load when possible\n\n\npywb 0.5.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n* better framed replay for non-html content -- include live rewrite timestamp via temp 'pywb.timestamp' cookie, updating banner of iframe load. All timestamp formatting moved to client-side for better customization.\n\n* refactoring of replay/live handlers for better extensability.\n\n* banner-only rewrite mode (via 'bn_' modifier) to support only banner insertion with no rewriting, server-side or client-side.\n\n\npywb 0.5.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\nminor fixes:\n\n* cdxindexer accepts unicode filenames, encodes via sys encoding\n\n* SCRIPT_NAME now defaults to '' if not present\n\n\npywb 0.5.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Catch live rewrite errors and display more friendly pywb error message.\n\n* LiveRewriteHandler and WBHandler refactoring: LiveRewriteHandler now supports a root search page html template.\n\n* Proxy mode option: 'unaltered_replay' to proxy archival data with no modifications (no banner, no server or client side rewriting).\n\n* Fix client side rewriting (wombat.js) for proxy mode: only rewrite https -> http in absolute urls.\n\n* Fixes to memento timemap/timegate to work with framed replay mode.\n\n* Support for a fallback handler which will be called from a replay handler instead of a 404 response.\n\n  The handler, specified via the ``fallback`` option, can be the name of any other replay handler. Typically, it can be used with a live rewrite handler to fetch missing content from live instead of showing a 404.\n\n* Live Rewrite can now be included as a 'collection type' in a pywb deployment by setting index path to ``$liveweb``.\n\n* ``live-rewrite-server`` has optional ``--proxy host:port`` param to specify a loading live web data through an HTTP/S proxy, such as for use with a recording proxy.\n\n* wombat: add document.cookie -> document.WB_wombat_cookie rewriting to check and rewrite Path= to archival url\n\n* Better parent relative '../' path rewriting, resolved to correct absolute urls when rewritten. Additional testing for parent relative urls.\n\n* New 'proxy_options' block, including 'use_default_coll' to allow defaulting to first collection w/o proxy auth.\n\n* Improved support for proxy mode, allow different collections to be selected via proxy auth\n\n\npywb 0.4.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Tests: Additional testing of bad cdx lines, missing revisit records.\n\n* Rewrite: Removal of lxml support for now, as it leads to problematic replay and not much performance improvements.\n\n* Rewrite: Parsing of html as raw bytes instead of decode/encode, detection still needed for non-ascii compatible encoding.\n\n* Indexing: Refactoring of cdx-indexer using a seperate 'archive record iterator' and pluggable cdx writer classes. Groundwork for creating custom indexers.\n\n* Indexing: Support for 9 field cdx formats with -9 flag.\n\n* Rewrite: Improved top -> WB_wombat_top rewriting.\n\n* Rewrite: Better handling of framed replay url notification\n\npywb 0.4.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Support for framed or non-framed mode replay, toggleable via the ``framed_replay`` flag in the config.yaml\n\n* Cookie rewriter: remove Max-Age to use ensure session-expiry instead of long-term cookie (experimental).\n\n* Live Rewrite: proxy all headers, instead of a whitelist.\n\n* Fixes to ``<base>`` tag handling, now correctly rewriting remainder of urls with the set base.\n\n* ``cdx-indexer`` options for resolving POST requests, and indexing request records. (``-p`` and ``-a``)\n\n* Improved `POST request replay <https://github.com/ikreymer/pywb/wiki/POST-request-replay>`_, allowing for improved replay of many captures relying on POST requests.\n\npywb 0.4.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Improved test coverage throughout the project.\n\n* live-rewrite-server: A new web server for checking rewriting rules against live content. A white-list of request headers is sent to\n  the destination server. See `rewrite_live.py <https://github.com/ikreymer/pywb/blob/master/pywb/rewrite/rewrite_live.py>`_ for more details.\n\n* Cookie Rewriting in Archival Mode: HTTP Set-Cookie header rewritten to remove Expires, rewrite Path and Domain. If Domain is used, Path is set to / to ensure cookie is visible from all archival urls.\n\n* Much improved handling of chunk encoded responses, better handling of zero-length chunks and fix bug where not enough gzip data was read for a full chunk to be decoded. Support for chunk-decoding w/o gzip decompression\n  (for example, for binary data).\n\n* Redis CDX: Initial support for reading entire CDX 'file' from a redis key via ZRANGEBYLEX, though needs more testing.\n\n* Jinja templates: additional keyword args added to most templates for customization, export 'urlsplit' to use by templates.\n\n* Remove SeekableLineReader, just using standard file-like object for binary search.\n\n* Proper handling of js_ cs_ modifiers to select content-type.\n\n* New, experimental support for top-level 'frame mode', used by live-rewrite-server, to display rewritten content in a frame. The mp_ modifier is used\n  to indicate the main page when top-level page is a frame.\n\n* cdx-indexer: Support for creation of non-SURT, url-ordered as well SURT-ordered CDX files.\n\n* Further rewrite of wombat.js: support for window.open, postMessage overrides, additional rewriting at Node creation time, better hash change detection.\n  Use ``Object.defineProperty`` whenever possible to better override assignment to various JS properties.\n  See `wombat.js <https://github.com/ikreymer/pywb/blob/master/pywb/static/wombat.js>`_ for more info.\n\n* Update wombat.js to support: scheme-relative urls rewriting, dom manipulation rewriting, disable web Worker api which could leak to live requests\n\n* Fixed support for empty arc/warc records. Indexed with '-', replay with '204 No Content'\n\n* Improve lxml rewriting, letting lxml handle parsing and decoding from bytestream directly (to address #36)\n\n\npywb 0.3.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Generate cdx indexs via command-line `cdx-indexer` script. Optionally sorting, and output to either a single combined file or a file per-directory.\n  Refer to ``cdx-indexer -h`` for more info.\n\n* Initial support for prefix url queries, eg: http://localhost:8080/pywb/\\*/http://example.com\\* to query all captures from http://example.com\n\n* Support for optional LXML html-based parser for fastest possible parsing. If lxml is installed on the system and via ``pip install lxml``, lxml parser is enabled by default.\n  (This can be turned off by setting ``use_lxml_parser: false`` in the config)\n\n* Full support for `Memento Protocol RFC7089 <http://www.mementoweb.org/guide/rfc/>`_ Memento, TimeGate and TimeMaps. Memento: TimeMaps in ``application/link-format`` provided via the ``/timemap/*/`` query.. eg: http://localhost:8080/pywb/timemap/\\*/http://example.com\n\n* pywb now features new `domain-specific rules <https://github.com/ikreymer/pywb/blob/master/pywb/rules.yaml>`_ which are applied to resolve and render certain difficult and dynamic content, in order to make accurate web replay work.\n  This ruleset will be under further iteration to address further challenges as the web evoles.\n", "code_before": "pywb 2.6.0b0 changelist\n~~~~~~~~~~~~~~~~~~~~~~~\n\nDocumentation Updates:\n\n* `Embargo + ACL system updates <https://pywb.readthedocs.io/en/latest/manual/access-control.html>`_\n\n* `New ACL header configuration <https://pywb.readthedocs.io/en/latest/manual/usage.html#config-acl-header>`_\n\n* `Locaalization / Multi-lingual Support Guide <https://pywb.readthedocs.io/en/latest/manual/localization.html>`_\n\n\nLocalization Improvements: (`#647 <https://github.com/webrecorder/pywb/pull/647>`_)\n\n* Support for extracting, updating, listing and removing localizable commands via ``wb-manager i18n`` command.\n\n* UI: Add language switch header to all UI templates.\n\n* Mark localizable strings in translatable in existing templates.\n\n\nAccess Control Improvements:\n\n* Support for Embargo System for date-based embargo, overridable via ACL ``allow_ignore_embargo`` `#642 <https://github.com/webrecorder/pywb/pull/642>`_\n\n* Support for custom ACL 'user' specified via ``X-pywb-ACL-User`` header passed from frontend proxies.\n\n* Fixes for exact rule matching `#629 <https://github.com/webrecorder/pywb/pull/629>`_\n\n* Fixes for ACL for auto-collections `#620 <https://github.com/webrecorder/pywb/pull/620>`_\n\n\nRewriting Improvements:\n\n* Updated YT rewriting rules `#635 <https://github.com/webrecorder/pywb/pull/635>`_\n\n* POST-to-get rewriting consistent with cdxj-indexer, wabac.js/replayweb.page `#636 <https://github.com/webrecorder/pywb/pull/636>`_\n\n* Improved fuzzy matching to ensure non-POST requests handled via fuzzy matching.\n\n* Live web: never truncate when reading POST request to avoid hung requests! (Apply limit only on indexing\n\n\nCDX Server / API Compatibility Fixes:\n\n* XmlQuery: set WARC record length field, if available `#633 <https://github.com/webrecorder/pywb/pull/633>`_\n\n* ZipNum: Don't count pages with filter `#631 <https://github.com/webrecorder/pywb/pull/631>`_\n\n* Better handle of CDX Server HTTP status `#624 <https://github.com/webrecorder/pywb/pull/624>`_\n\n* Better handling of errors from CDX Server API with 400 `#623 <https://github.com/webrecorder/pywb/pull/623>`_, `#625 <https://github.com/webrecorder/pywb/pull/625>`_, `#626 <https://github.com/webrecorder/pywb/pull/626>`_,  `#630 <https://github.com/webrecorder/pywb/pull/630>`_\n\n* Backwards compatibility of ``fl`` param  `#621 <https://github.com/webrecorder/pywb/pull/621>`_\n\n\nRecording Redis Dedup mode:\n\n* Fix dedup index config loading `#617 <https://github.com/webrecorder/pywb/pull/617>`_\n\n* Add recording size counter to track any in-flight requests `#637 <https://github.com/webrecorder/pywb/pull/637>`_\n\n\npywb 2.5.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Update to latest wombat.js (3.0.3)\n\n* Dedup Mode: Support for Redis-based dedup index to skip or write revisit records for duplicates, replay from Redis-based index `#597 <https://github.com/webrecorder/pywb/pull/597>`_, `#611 <https://github.com/webrecorder/pywb/pull/611>`_\n\n* Rewriting: Updated Rules for youtube and vimeo replay `#610 <https://github.com/webrecorder/pywb/pull/610>`_\n\n* CDX Indexing: More efficint cdx sorting  `#609 <https://github.com/webrecorder/pywb/pull/609>`_\n\n* Set default CDX closest lookup limit to 100 instead of 10 `#606 <https://github.com/webrecorder/pywb/pull/606>`_\n\n* UI: Try to avoid css class conflicts in injected banner `#604 <https://github.com/webrecorder/pywb/pull/604>`_\n\n* Catch invalid headers in uWSGI `#603 <https://github.com/webrecorder/pywb/pull/603>`_\n\n* Config option to support certificate validation when capturing `#596 <https://github.com/webrecorder/pywb/pull/596>`_\n\n* Fix indexing POST requests with multipart/form-data without boundary `#599 <https://github.com/webrecorder/pywb/pull/599>`_\n\n* New OpenWayback->pywb Transition Guide: `https://pywb.readthedocs.io/en/latest/manual/owb-transition.html <https://pywb.readthedocs.io/en/latest/manual/owb-transition.html>`_\n\n* Sample deployments with Docker Compose for running with Apache, Nginx and OutbackCDX in ``sample-deploy`` directory.\n\n* Update to latest gevent to fix issues with latest python `#583 <https://github.com/webrecorder/pywb/pull/583>`_\n\n\npywb 2.4.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* ensure RemoteCDXIndexSource also passes ``matchType`` to upstream\n\n* cdx-indexer: use ``-o`` flag to specify output, not first param (output to stdout by default)\n\n* static paths cleanup, move ``url-polyfill.min.js`` to correct dir (fixes `#571 <https://github.com/webrecorder/pywb/issues/571>`_)\n\n* minor fixes to docs\n\n* logo: resize new logo to actual size, add logo via absolute link to ensure it works on pypi also\n\n\npywb 2.4.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fix: allow timegate content check in `#564 <https://github.com/webrecorder/pywb/pull/564>`_ to be ignored (for use with derived classes)\n\n\npywb 2.4.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nThis release includes significant update, specifically merging of https://github.com/ukwa/pywb branch into this release.\nA few selected improvements:\n\n* New Access Control System: https://pywb.readthedocs.io/en/latest/manual/access-control.html\n\n* Support for Localization, configuring multiple languages (not enabled by default): https://github.com/ukwa/ukwa-pywb/blob/master/docs/localization.md\n\n* Support for OpenWayback-style XML-based index source (xmlquery)\n\n* Support for loading from WebHDFS via `webhdfs://` scheme.\n\n* Initial support for a new embeds/transclusions replay system, in combination with warcit: https://github.com/webrecorder/warcit/wiki/Warcit-Video-Audio-Conversion\n\n* Proxy mode improvements: handle OPTIONS requests and CORS `#520 <https://github.com/webrecorder/pywb/pull/520>`_\n\n* Memento Prefer header: support for experimental `Prefer` header to select 'raw' or 'rewritten' memento\n\n* Other memento fixes: fix timemap including invalid mementos, correct timegate behavior on top frame `#564 <https://github.com/webrecorder/pywb/pull/564>`_\n\n* Fixes for collection metadata display: `#509 <https://github.com/webrecorder/pywb/pull/520>`_\n\n* Fix for incorrected WARC record length due to re-serialized headers: `#561 <https://github.com/webrecorder/pywb/pull/561>`_\n\n* Filter invalid WARC records `#536 <https://github.com/webrecorder/pywb/pull/536>`_\n\n* Updated fuzzy matching rules and wombat client-side rewriting.\n\n\nFor the full changelist, see this PR: `#565 <https://github.com/webrecorder/pywb/pull/565>`_\n\n* Access Control System\n\n\npywb 2.3.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* General auto-fetch fixes (#503)\n  - Fixed issue that caused HTTP 404 errors to happen when parsing <link> stylesheet hrefs as sheets (webrecorder/wombat #11)\n  - Ensured that requests made are cached by the browser (webrecorder/wombat #13 & #15)\n  - Ensured that the request made by the backing web worker when in proxy mode are not blocked by CORS (webrecorder/wombat #13 & #15)\n\n* SOCKS proxy fixes (#504)\n  - simplify SOCKS config (avoiding global socket monkey patch), default to no cert verify to match non-proxy behavior\n  - SOCKS proxy can be disabled dynamically by setting SOCKS_DISABLE\n\n\npywb 2.3.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Improvements to auto-fetch to support page fetch (webrecroder/wombat#5, #497)\n  - Support fetching page with ``X-Wombat-History-Page`` and title ``X-Wombat-History-Title`` headers present.\n  - Attempt to extract title and pass along with cdx to ``_add_history_page()`` callback in RewriterApp, to indicate a url is a page. (#498)\n  - General auto-fetch fixes: queue messages if worker not yet inited (in proxy mode), only parse <link> stylesheet hrefs as sheets.\n\n* Cookie Rewriting Fix: don't update cookie cache on service worker (``sw_`` modifier) responses (#499)\n* Rewriting: HTML Unescape Fix: Attempt to HTML-entity-decode urls and innline styles that contain ``&#`` to get correct rewriting of encoded urls (#500)\n\n\npywb 2.3.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Proxy Mode: Ensure head insert added even if no ``<head>`` tag, insert after first tag that is not ``<html>`` or ``<head>`` (#496)\n\n\npywb 2.3.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Eval rewriting fix: don't rewrite ``$eval``, only ``eval`` identifier (#493)\n\n* Cookie rewriting improvements: (#491)\n    - Enable domain cookie cache for live index and recording modes using fakeredis, previously only available in Webrecorder\n    - Don't add duplicate cookies to Set-Cookie or Cookie headers\n    - Don't include cached Set-Cookie headers to serviceworkers for non-200 responses.\n    - Add cookies for ``sw_/`` and ``wkrf_`` modifiers\n    - Testing: add initial testing for domain cookie rewriting\n\n* Misc fixes: (#490)\n    - Ensure SCRIPT_NAME never empty (#490)\n    - Static Paths: load ``/index.html`` for paths ending in ``/``, ensure static_prefix always inited correctly\n    - Docker: switch to designated $VOLUME_DIR before initializing\n    - Rules: update rules for soundcloud\n\n\npywb 2.3.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Fix regression in wombat, new window.parent override from (webrecorder/wombat#2) was throwing exception if top-frame was cross-origin (webrecorder/wombat#3)\n* Update to latest wombat, v3.0.0\n\n\npywb 2.3.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Wombat Improvements and modularization:\n    - Client-side rewriting and auto-fetch systems moved to https://github.com/webrecorder/wombat\n    - Module-based setup and full testing for wombat\n    - Continuous auto-fetch up to 20 requests (#484)\n\n* Replay / Fidelity Improvements (#451):\n    - Introduced a new server-side rewriter, JSWorkerRewriter, that handles rewriting JS workers and service-workers\n    - Improvements to JSOP Rewriter to handle empty query (#475)\n    - Improvements to postMessage rewriting, override `eval(` while preserving scope (#475)\n    - Fixes to ``this`` proxy rewrite to include ``, this``\n\n* Misc Changes:\n    - Versioning: switched back to semver to more easily keep track of versions (#488)\n    - Improved handling of open http connections and file handles (#463)\n    - Fixes for latest urllib3, not verifying SSL certs (#467), (#469)\n    - Better logging for invalid cdxlines and cookies (#477), (#478)\n    - Fix warning in yaml.load (#472)\n    - Index invalid form-data as binary (#471)\n\n\npywb 2.2.20190410 changelist\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* Improved rewriting of JSONP, support matching JSONP with ``//`` comments (fixes #459)\n\n\npywb 2.2.20190311 changelist\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* Support for setting timestamp in proxy mode via ``--proxy-default-timestamp`` (fixes #452)\n* Remove any ``WB_wombat_`` found in POST requests from old versions of pywb.\n* Fixes new query UI when loading traditional calendar ``/*/<url>`` pages (#455, #456)\n\n\npywb 2.2.x changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* New Versioning System: (#445)\n    - Switching to hybrid semantic / calendar ``major.minor.yyyymmdd`` versioning.\n    - The ``major.minor`` version will be updated for larger changes.\n    - The ``.yyyymmdd`` date component will be updated for smaller incremental releases, for fidelity improvements and smaller bug fixes.\n    \n\n* Auto Fetch System:\n    - Added ``picture > source[srcset]`` extraction and increased the robustness of relative srcset URLs resolution (#415)\n    - Enabled auto-fetching of video, audio resources (#427)\n    - Expoxed AutoFetchWorker api in proxy mode to allow external JS to initiate checks (#389)\n\n* Build / CI Improvements:\n    - Tweaked usage of wr-tests in CI (#431)\n    - Ensured that usage of XVFB works on travis.ci (#436)\n    - Updated Docker image to support\n    - Python 3.7 support and CI testing (#447)\n\n* Docker:\n    - Updated Docker image to Python 3.7.2, match docker user uid/gid to that of existing volume (#446)\n    - Add documentation for using Docker image and automated images (#448)\n\n* Fuzzy Matching:\n    - Added an additional Facebook rule targeting timeline replay (#440)\n\n* Memento:\n    - Fixed regression in FrontendApp when handling TimeMap requests (#423)\n\n* Recording:\n    - Remove Transer-Encoding from internal response (#437)\n    - If brotli decoding package can't be loaded, remove ``br`` from ``Accept-Encoding`` header (#444)\n\n* Replay / Fidelity Improvements:\n    - Wombat now uses the actual page scheme instead of defaulting to http when extracting the original url (#404)\n    - Improved URL rewriting in web workers (#420)\n    - Improved replay of content coming from a frameset's frame (#438)\n    - Updated rules for facebook (#440)\n    - Introduce new banner behavior and ensured that banner does not become stuck displaying \"Loading...\" (#418)\n\n* Server-Side Rewriting:\n    - Improved the rewriting process of HTTP headers that are encoded in the non-standard ``UTF-8`` encoding (#402)\n    - Improved the JavaScript rewriter's rewrites of the ``location`` symbol in order to avoid rewriting ``$location`` (#403)\n    - Added an additional check of ``text/html`` content to ensure that it is actually ``html`` (#428)\n    - Fixed HTML detection for UTF-8 files starting with BOM (#441)\n    - Fixed parsing of invalid conditional comments, eg. treat '<![endif]-->' as '<![endif]>' (#441)\n\n* UI:\n   -  New Query UI with support for prefix queries, forms for advanced search via cdx server api, incremental results loading (#421)\n\n\n\n\n\npywb 2.1.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Replay Fidelity Improvements:\n   - Improved wombat web worker rewriting overrides, use custom modifier ``wkr_`` (#351)\n   - Added checks to wombat that preserve the behavior of non-wombat added polyfills to native functions (#350)\n   - Framed replay: Ensured the page title and favicon are displayed in the top-frame (#356, #369)\n   - Improved replay of request sent as ``text/html`` but are actually ``application/json``` (#367)\n   - Added replay of compressed resources by forcing decompression if the UA did not indicate it could handle the resources encoding (#372)\n   - Added ``window.origin``, and ``setTimeout``, ``setInterval`` overrides to wombat to handle the non-function callback case (#381)\n   - Added ``CSSStyleSheet.insertRule`` and ```Text``` overrides to wombat improve rewriting of dynamically added/modification of CSS (#382)\n   - Remove extra ``window.frames`` override to avoid extra override if ``window.frames === window`` (#383)\n   - Wombat inited via ``window._WBWombatInit(wbinfo);``, allows for reinit if inited 'synethically' and not from the page html insert (#383)\n   - Added ``document.evaluate`` override in-order to deproxy the context node (#385)\n   - Optimized argument de-proxying in wombat (#385)\n   - Improved iframe srcdoc rewriting in wombat (#386)\n   - Improved rewriting strings of full HTML by making the check case insensitive and looking for ``<!doctype html`` in wombat (#398)\n\n* Auto Fetch System: Background image srcset and media query fetching (#359, #379, #378, #397):\n   - Added image srcset and media query preservation system to wombat\n   - Added ``--proxy-enable-wombat`` cli flag to enable the inject of ``wombatProxyMode.js`` in proxy mode (default: false)\n   - Added ``--enable-auto-fetch`` cli flag to enable the auto fetch web worker system both url rewrite and proxy modes (default: false)\n   - Added ``FrontEndApp.proxy_fetch()`` to allow the auto fetch worker to request cross-origin style sheets\n\n* Fuzzy Matching:\n    - Decreased the aggressiveness of fuzzy matching (#362)\n    - Added an additional Facebook rule targeting timeline replay (#363)\n    - Added vimeo rule that canonicalizes the variable ```hmac/timestamp``` portion of url (#375)\n\n* Server-Side Rewriting:\n    - Refactored the regular expression rewriters in-order to avoid multiple initialization (#354)\n    - Improved unicode URL rewriting (#361, #376, #377, #380)\n    - Improved cookie rewriting in framed replay mode (#386)\n    - Improved handling of bad content-length HTTP header (#386)\n    - Fix parsing of self-closing <script> and <style> tags and rewrite SVG xlink:href (#392)\n    - Ensure 'Status' header is prefix-rewritten\n    - Support using ``X-Forwarded-Proto`` header to specify scheme for URL rewriting (#395)\n\n* Indexing:\n    - Ensure that WARC/0.18 metadata records with mime = ``text/anvl`` are not replayed\n\n* Recording:\n    - Added an option to filter the source collection (#368)\n\n* Misc Changes:\n    - Added Github Issue Templates (#353)\n    - Added replay testing to ci via webrecorder-tests (#355)\n    - Support deploying pywb under a prefix, non-root (#373)\n\n* Documentation improvements:\n   - Improved cli help message (#360)\n   - Fixed documentation enumeration bug (#364)\n   - Add documentation for auto-fetch system (#394)\n\n\npywb 2.0.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Replay Fidelity Improvements:\n   - Ensure title-only change event correctly handled by top-frame banner (#327)\n   - Improved wombat ``document.write`` and ``document.writeln`` overrides to account for the variadic case (#325)\n   - Improved wombat ``postMessage`` override logic of determining correct target origin (#328 and #338)\n   - Improved server-side rewriting of ``link[rel=preload]`` (#332)\n   - Improved server-side and client-side rewriting of \"super relative\" script src values ``script[src=path/it.php?js]`` (#334)\n   - Improved wombat un-rewrite regular expression (#332)\n   - Improved wombat ``Node.[appendChild|replaceChild|insertBefore]`` overrides to account for edge cases (#332)\n   - Added ``MouseEvent`` override to wombat (#332)\n   - Added ``insertAdjacentElement`` override to wombat (#332)\n   - Added client-side rewriting of ``link[rel=preload]`` and ``link[rel=import]`` to wombat (#332)\n   - Added FontFace override to wombat (#340)\n   - Added server-side rewriting of ``link[rel=import]`` (#334)\n   - Added SVG filter attribute rewriting to wombat (#341)\n   - Improved detection of ServiceWorker JS, use ``sw_`` modifier which performs no rewriting but adds ``Service-Worker-Allowed`` header.\n   - Don't bind already overridden ``requestAnimationFrame/clearAnimationFrame`` functions via JS object proxy (#350)\n   - Don't reinit wombat in same window if new document is imported (#339)\n   - Cookies: Use default mod ``mp_`` for client-side rewriting to ensure cookies set correctly on client-side documents (#330)\n\n* Server-Side Rewriting:\n   - Flash: Improved Rewriting for AMF, supporting py2 and py3 (#321)\n   - Improved ``Origin`` header detection: Detect from ``Referer`` header if available (#329)\n   - Expand JSONP matching if url contains 'callback=jsonp' (#336)\n   - Ensure entity-escaped urls are rewritten, with escaping preserved (#337)\n\n* Redirect Improvements:\n   - Improved self-redirect detection for adjacent self-redirect capture results, avoiding self-redirect loops (#345)\n   - Fix possible leak when handling self-redirects\n   - Add slash-preserving redirect, if original ended in '/', ensure replayed version also ends with '/' (#344, #346)\n\n* Misc Fixes:\n   - Testing: Run local ``httpbin`` for any ``httpbin.org`` or ``test.httpbin.org`` tests to avoid external dependency.\n   - Indexing: Avoid indexing error in py2 by decoding in utf-8 if warc has non-ascii target url (#312)\n   - Gevent: Preserve %-escaped request url via ``REQUEST_URI`` (if available) to pass correct url to live upstream.\n\n* Proxy Mode Options (#316, #317):\n   - Add ``use_banner`` option, if false, disables banner insert in proxy mode (default: true)\n   - Add ``use_head_insert`` option, if false, disables injecting ``head_insert.html`` in proxy mode (default: true)\n   - Add ``FrontEndApp.proxy_route_request()`` to allow more customized proxy routing (default: route to fixed default collection)\n   - Expand proxy mode docs\n\n\npywb 2.0.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Miscelaneous fixes:\n   - Fixes for Memento Aggregation when no timeout specified (#310)\n   - Fix HEAD request for replay (#309)\n   - Redis Index: always decode to native string format (decode_respones=True)\n   - Test fixes: Support latest fakeredis, more consistent tests (#313)\n   - Support forcing scheme via ``force_scheme: https`` config option (#314)\n   - Fix typo in rewrite_amf.py (#308)\n\n* Documentation improvements:\n   - Add docs for nginx deployment (#314)\n   - Fix typo in memento docs (#307)\n   - Mention timeout property Warcserver docs (#310)\n\n\npywb 2.0.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Top frame interaction improvements:\n   - Only notify from top replay frame, never from inner replay frames\n   - Don't update top frame from 'about:blank' or 'javascript:' urls\n   - New title change message when 'document.title' changes\n   - Fast redirect to top-frame when loading inner frame first\n\n* addEventListener/removeEventListener override improvements: more generic override, also handle window.onmessage\n\n* Proxy-mode improvements:\n   - don't include wombat.js (unused in proxy mode by default)\n   - set banner title to document.title on load\n   - update docs for configuring proxy mode HTTPS certs\n\n* cli: add -b/--bind flag to wayback cli to specify bind host (default to 0.0.0.0)\n\n\npywb 2.0.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Override ``Function.apply()`` to remove rewriting Proxy object from any native function calls\n* Fix top-frame notifications in new system to use correct window\n* Calendar query: Add back second display\n* Fix tests when no youtube-dl installed (#270)\n* Fix typos, setup.py classifiers, remove py2.6\n\n\npywb 2.0.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nSee the docs at https://pywb.readthedocs.org for more info.\n\n**TODO: more detailed changelist**\n\n\npywb 0.33.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fixes from pull requests:\n   - Better handling of exceptions from in wsgi_wrapper\n   - Fix CommonCrawl tests\n   - Fix broken links in README\n   - Fix travis build (requires certauth<1.2)\n\n\npywb 0.33.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Client Rewriting Improvements:\n   - Better rules for Instagram, Medium\n   - Fix window.fetch() override\n   - Work on eval() override (disabled for more testing)\n\n* Add Python 3 classifiers to setup.py\n\n\npywb 0.33.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Client-Side Rewriting Improvements:\n   - Video: More aggressive ``youtube-dl`` rewriting, try video query for any ``<object>`` with flashvars\n   - proxy: disable most client side rewriting when in proxy mode, keep non-rewriting overrides (random, Date)\n   - host relative extract: ``extract_orig()`` returns host-relative if url starts with ``/``\n   - add geolocation and notifications overrides to (auto-disable)\n   - proxy: use current protocl for video info query.\n   - fix history check bug: support changing history to exact current origin.\n   - add ``window.fetch()`` override\n   - add ``srcset`` attribute rewriting\n   - ajax: don't add ``X-Pywb-Requested-With`` header to ``data:`` urls\n   - general JS fixes, add undefined checks before acccessing ``_wb_js``, top frame, and content frame.\n  \n* Server-Side Rewriting Improvements:\n   - www canonicalization: improve regex to include urls containing ``\\r``\n   - memento: fix potential duplicate memento headers\n   - proxy: when in proxy mode, only rewrite headers related to encoding or cache\n   - proxy: add special 'proxy_js' rewriter which defaults to no rewriting for proxy mode but allows custom JS rules to still be applied. Used for JS and embedded JS in html.\n   - WbUrl: add new modifier form starting with ``$`` in addition to ending with ``_``, eg. ``/$mod:foo/http://example.com/``\n   - ajax: don't rewrite ``text/html`` responses retrieved by ajax requests (when ``X-Pywb-Requested-With`` header is present).\n   \n* Static Handler: if ``wsgi.file_wrapper`` fails, fallback to direct streaming of static ocntent.\n\n\npywb 0.32.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Template Responses: Calculate ``Content-Length`` correctly from encoded utf-8 text length\n\n* WbUrl: Improved detection of url scheme, don't treat ``a.co/?http://foo`` as having a valid scheme\n\n\npywb 0.32.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Cross-Domain Framed Replay\n   - pywb banner (outer) and content (inner) frames can be served from different domains\n   - All cross-frame interaction done via ``postMessage``, including url, hash, cookie change notifications\n  \n* Server-Side Rewriting:\n   - Don't rewrite relative urls (unless contain ``../`` or start with ``/``)\n   - Rewrite svg ``<image>`` tag\n   - Don't rewrite ``Proxy-Authenticate`` or ``WWW-Authenticate`` headers\n   - Rewrite ``href`` on any element\n   - Preserve HTML entities and spaces when rewriting CSS urls\n   - Content detect: handle ``text/plain`` text as JS or CSS if ``js_`` or ``cs_`` modifiers used\n   - Improved rewriting of ``on*`` attributes, ensure ``window.`` is added when accessing rewritten objects.\n  \n* Client-Side Rewriting:\n   - Add cookie notification message for cookies with ``Domain=`` to allow server-side handling\n   - Improved handling of Unicode prefixes, use ``decodeURI``\n   - History API: properly override go, forward, back and preserve pushState/replaceState\n   - Ensure client-rewriting for windows created by ``window.open``\n   - Override ``navigator.sendBeacon``\n   - Rewrite ``poster`` attr in dynamic elems\n   - Rewrite ``src`` attr in video ``source`` elems\n   \n* Record Loader: Option to convert  ARC->WARC records implicitly, return WARC responses (enabled by default)\n \n* Block Loader: Raise exceptions for 4xx or 5xx responses\n \n* CDX API: return not found CDX error as JSON or plain text if using ``output=json`` or ``output=text``\n \n \npywb 0.31.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* HTML rewriting:\n   - preserve empty attrs while parsing, eg. ``<tag attr>`` instead of ``<tag attr=\"\">``\n   - empty ``srcset`` attribute does not cause errors\n   - better error checking of empty attributes for all custom parsers\n\n* wombat/client side improvements:\n   - use ``postMessage()`` for inner replay frame -> outer frame updates\n   - Fix ``window.open()`` rewriting even if prototype is missing\n   - Fix double-slash in relative url rewriting\n   - ``Math.random()`` overrides uses correct window\n  \n* BufferedReader improvements:\n   - More lenient of partially decompressed data, return what was decompressed instead of raising exception.\n   - Support Brotli decompression, properly rewrite ``Content-Encoding: br``\n\n* Python 2/3 Compatibility:\n   - Decode all cdx fields to native string in py2\n  \n* BlockLoader improvements:\n   - support custom profile urls, eg. ``profile+http://`` which allow a custom profile to be selected if a profile loader is registered via ``BlockLoader.set_profile_loader()``\n  \n   - s3 loader: support profiles and AWS creds directly set in username/password of url\n\n* POST replay improvements:\n   - support ``multipart/form-data`` encoding same as ``x-www-form-urlencoded``\n   - support ``application/x-amf`` with experimental AMF rewriter (RewriteContentAMF rewriter)\n   - support generic post-data matching exact base64 encoded value.\n\n\npywb 0.30.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rules: match rule for Twitter video.\n\n* Record Loader: Only parse ``http:`` and ``https:`` urls as HTTP in ``response``, ``request`` and ``revisit`` records.\n\n\npywb 0.30.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Support for Python 3.3+ in addition to Python 2.6+\n\n* statusheaders: ``to_str()`` and ``to_bytes()`` to reconstruct status line and headers, with option to exclude certain headers\n\n* cdxobject improvements:\n   - ``conv_to_json()`` for serializing to json, with optional list of fields\n   - ``to_json()`` and ``to_cdxj()``\n   - Default JSON serialization includes all fields, except starting with ``_``\n   - Default CDXJ serialization includes all fields, except urlkey and timestamp\n   - Comparison operators for cdxobject\n   - Reading cdxline as byte buffer, individual fields as strings (python 3)\n  \n* redis: full testing of ``zrangebylex`` with new fakeredis\n\n* timeutils: add ``datetime_to_iso_date``\n  \n* cdx indexing refactor: rename ``DefaultRecordIter`` -> ``DefaultRecordParser``, a callable which creates an iterator\n\n* warcrecord loader fully read streams with no content-length, don't force 204\n\n* cookie improvements:\n   - use httplib cookie pairs directly to avoid concatenated headers (eg. for ``Set-Cookie``)\n   - don't remove ``max-age`` and ``expires`` when in live rewriting mode\n   - convert `` UTC`` -> `` GMT`` in expires to avoid Python parsing issues\n   - remove ``secure`` only if not serving from https\n   - support custom cookie rewriter\n   \n* wombat/client side improvements:\n   - rewrite ``frameElement`` -> ``WB_wombat_frameElement``, set to null for top replay frame\n   - Allow changing of ``document.domain``\n   - Rewrite ``<form action>`` and <input @value>`` in ``rewrite_elem``\n \n* Tests: improved tests, replaced doctests of dict output to regular tests for improved compatibility with different python implementations\n  \n  \n\n\n\npywb 0.11.5 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* cdx index bug fix: fix bug with cdx indexing with post-append when WARC request and response records do not alternate in the WARC.\n\n* load yaml config: ensure file stream gets closed.\n\n* zipnum: resolve paths specified in zipnum .loc file relative to the .loc file, not to application root.\n\n\npywb 0.11.4 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat: overrides ``window.crypto.getRandomValues()`` to use predictable 'random' values for improved\n  replayability in many JS applications.\n\n* fix gevent/uwsgi: run ``gevent.monkey.patch_all()`` explicitly when loading ``pywb.apps.wayback`` if ``GEVENT_MONKEY_PATCH=1`` env var is set. Set by default in ``uwsgi.ini`` for use with uwsgi. (Was previously relying on uwsgi ``gevent-early-monkey-patch`` but this flag is not yet available until uwsgi 2.1 is released).\n\n\npywb 0.11.3 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* rewrite: fix typo in ``<meta content=\"\">`` rewrite (modifier was not being set)\n\n\npywb 0.11.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rewriting: if no charset specified in original page, don't add charset to allow browser to detect.\n\n* Rewriting: rewrite ``<meta content=\"\">`` attribute if it is a url.\n\n* wb.js: pad shorter timestamp to 14 digits.\n\n* Indexing: fixed exception when indexing empty files.\n\n\npywb 0.11.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* WombatLocation: overriden properties (href, host, etc...) are enumerable to match Location to support cloning methods.\n\n* WombatLocation: reload() override now works.\n   \n* Proxy: Custom ``Pywb-Rewrite-Prefix`` allows adding a custom prefix for proxy mode rewriting\n\n* Proxy: Better error for invalid collection in ip resolve mode\n   \n* Warc Indexing Refactor: Allow custom iterators to buffer payload by overriding ``create_payload_buffer()`` to return a writable buffer.\n\n\npywb 0.11.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* New client-side test system for Wombat.js in place using Karma and SauceLabs with initial set of tests and travis integration.\n\n* Wombat Improvements:\n   - Better Safari/IE support: accessors overriden only when actually supported in browser, override gracefully skipped otherwise\n   - Use ``getOwnPropertyDescriptor()`` to get properties in addition to ``__lookupGetter__``, ``__lookupSetter__``\n   - ``baseURI`` overriden on correct prototype\n   - ``CSSStyleSheet.href`` override\n   - ``HTMLAnchorElement.toString()`` override\n   - Avoid making ``<base>.href`` read-only\n  \n* Proxy Mode Improvements:\n   - To avoid breaking HTTPS envelope, if no content-length provided, chunked encoding is used (HTTP/1.1) or response is buffered and content-length is computed (HTTP/1.0)\n   - Rewriter: Scheme-only rewriter converts embedded urls to http or https to match the scheme of containing page.\n   - IP Resolver: Supports IP cache in Redis\n   - Default resolver set to cookie resolver, eg. ``cookie_resolver: true`` is the default.\n   - Collection/datetime switching options removed from UI when auth or ip resolvers.\n  \n* Encoding: Use webencoding lib to better encode head-insert to match page encoding\n\n* Live Proxy: Support for explicit recording mode, decoupled from using http/https proxy. Enabled when ``LiveRewriter.is_recording()`` is true. By default, http/s proxies imply recording but can be overriden in derived class.\n\n* Rewriting: Convert relative urls for ``rel=canonical`` to absolute urls, even if not rewriting to ensure correct url.\n\n* UI: Use custom webkit scrollbars to minimize scrollbar-in-iframe issues that sometimes occur in Chrome.\n\n* Memento Improvements:\n   - ``/collinfo.json`` by default returns a JSON spec for all collections as Memento endpoints, in a format compatible with MemGator.\n   - ``Add /collinfo.json`` endpoint customizable via ``templates/collinfo.json`` and must be enabled with ``enable_coll_info: true``\n   - 'Not Found' error for timemap query returns empty timemap instead of standard HTML 404.\n  \n* WARC Indexing:\n  - Better detection of content-length < payload, skip to next record boundary and warn, if possible.\n  - Use ujson if proper version (without forward-slash escaping) is available when writing CDXJ\n\n\npywb 0.10.10 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* extensible BlockLoadres: supported 'http', 'https', 's3' and local file system, additional\n  loaders can now be registered by scheme.\n  \n* rewriting fixes:\n   - wombat: fix occasional style rewrite bug that resulted in leaks.\n   - strip leading or trailing spaces in url\n   - charset: default to utf-8 if unknown charset specified in HTML\n\n* live rewrite: LiveRewriter class overridable in config\n\n* WARC indexing: ignore empty records when indexing and continue, rather than stopping at first empty record.\n\n* tests: refactor integration tests to run signficantly faster.\n\n* cdx-indexer\n\n\npywb 0.10.9.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat: fix relative '/' rewrite which incorrectly handles rel scheme '//' urls\n\n\npywb 0.10.9 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* IPProxyResolver: Support new simple proxy resolver where collection and timestamp stored in server-side cache by IP and set via a rest api through `pywb.proxy` eg: ``curl -x \"localhost:8080\" http://pywb.proxy/set?ts=2015&coll=all``. No cookies or proxy auth needed in this mode. Useful for Docker-based deployments where virtual IP is fixed. Enabled with ``cookie_resolver: ip`` in ``proxy_options``.\n\n* CDX Server: Add support for timestamp-bounded queries CDX queries ``from=`` and ``to=``, also support calendar query with (inclusive) ranges, eg. ``/2010-2015/example.com``, ``/2010-/example.com/``, ``/-2015/example.com/``.\n\n* Proxy options: add ``use_banner`` to toggle banner insert, and ``use_client_rewrite`` to toggle wombat rewriting in proxy mode. (Client rewriting requires banner insert).\n\n* Proxy and Video: When in proxy mode, load youtube-dl video info via proxy magic host `pywb.proxy`, and ensure CORS support.\n\n* Rewrite: ensure ``<base>`` tag has trailing slash, or add ``<base>`` with trailing slash for host-name only urls, eg: ``http://localhost:8080/example.com``\n\n* Rules: improved blogspot nav and yt rules, rule file cleanup\n\n* Wombat 2.9 improvements, including:\n\n   - improved handling of relative paths, '..', '.', '/'\n   - better support for proxy mode, avoid cross-origin top-frame issues\n   - rewrite_html() (document.write) override only if any html changed\n   - improved form action rewrite\n   - improved rewriting in 'root collection' mode\n   \n   \npywb 0.10.8 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Rewrite: url attribute entity unencoding only if attr starts with 'http', catch any exceptions.\n\n* Fix top frame detection to avoid occasional banner insertion into intermediate frames.\n\n* Fix special case ``href = \".\"`` rewriting.\n\n\npywb 0.10.7 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.8 improvements, including:\n\n    - cookies: fixed rewriting with respect to comma, proper path and domain replacement\n    - form action and textContent rewriting\n    - document.write() improvements, buffering split tag and removing extraneous end tag\n    - document.writeln() rewriting\n    - object data attr conditional rewriting\n    - proper ``setAttribute(\"style\", ...`` rewriting\n    - style rewrite regex now case-insensitive\n    \n* 10-field CDX format fully supported.\n \n* rewrite: \"background\" attr rewriting, proper rewriting of entity-encoded attributes.\n \n* Fix for regression for Vimeo videos that were recorded as Flash but replay as HTML.\n  \n\npywb 0.10.6 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Disable url rewriting in JS by default! No longer needed due to improved client side rewriting of all urls.\n\n* wombat 2.7 more rewriting improvements:\n\n    - ``document.write`` override rewrites all elements, not just one top level elements.\n\n    - iframe ``srcdoc`` also rewritten.\n\n    - support for custom modifiers, such as ``js_`` for ``SCRIPT`` tag rewriting, otherwise for element overrides.\n\n    - improved css rewriting, override standard css attributes on ``CSSStyleDeclaration`` to avoid mutation observers, rewrite ``STYLE`` text content.\n    \n    - ``postMessage``: original ``source`` window now also preserved along with origin.\n\n    - cookie rewrite: don't remove expires, but adjust by date offset. Allow cookies to be deleted by setting to expired date.\n\n* Embed mode, pywb framed replay can now be embedded in an iframe when ``embeddable: True`` option is set. ``postMessage`` on framed replay proxies between replay frame and embedded frame, and ``window.parent`` is not set to top replay frame, allowing access to containing frame.\n\n* vidrw: don't replace video with generic swf, find better match.\n\n* path index loader: ensure each request handled by own file reader.\n\n\npywb 0.10.5 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.6 client side rewriting improvements:\n\n    - Override JS prototype getters and setters on ``href`` and ``src`` attributes of standard HTML elements, so that JavaScript access receives and sets the original url, but the element actually contains the rewritten url internally.\n    \n    - For ``<a>`` element override other url properties ``href``, ``hostname``, ``host``, ``pathname``, ``origin``, ``search``, ``port``, ``protocol``\n    \n    - Improved ``postMessage`` emulation: Ensure the original ``origin`` of the caller is saved, by wrapping ``X.postMessage`` in a special ``X.__WB_pmw(window).postMessage()`` call which will save origin of current window in X. Store origin and destination hosts.\n    \n    - Improved ``message`` listener emulation: Add filtering to skip messages that were not inteded for destination host.\n    \n    - Restored wombat if wiped by ``document.write`` / ``document.open`` (happens on FF).\n    \n    - When rewriting html for ``document.write``, keep ``<html>``, ``<head>``, ``<body>`` tags in rewritten html.\n    \n    \n* Relative urls rewritten to stay relative, eg. ``/path/file.html`` -> ``/coll/http://example.com/path/file.html``\n  Can be disabled with ``no_match_rel=True`` in ``rewrite_opts``.\n    \n* Optional ``force_html_decl`` option to add a ``<!DOCTYPE>`` or other HTML declaration if none is present.\n    \n* Improved handling for `redir_to_exact=False`` mode. When set, no redirect on memento timegate, and serve ``Content-Location   `` headers for actual memento, in conformance with Mememnto RFC Pattern 2.2 (http://tools.ietf.org/html/rfc7089#section-4.2.2)\n\n\n* Proxy Mode Fixes: Ensure ``Content-Length`` header is always added and correct in proxy mode, needed for proper HTTPS      \n  handling within ``CONNECT`` envelope.\n\n* New default ``HostScopeCookieRewriter`` sets cookies with domain ``/coll/https://example.com/`` instead of ``/coll/``.\n  Can be specified with ``cookie_scope: host`` per collection.\n  This is now the default live rewrite proxy and should be much safer/secure. For rare login use cases, the collection\n  root scope can be specified with ``cookie_scope: coll``.\n  \n* Cookie ``Path=`` value always a relative path for all cookie scopes, previously were often absolute paths.\n\n* Default WSGI handler for ``wayback`` back to ``wsgiref``, as ``waitress`` does not support proxy mode.\n\n\npywb 0.10.2 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* wombat 2.5 update -- significant wombat improvements:\n\n    - Cookies: more comprehensive client-side cookie overriding, including Path, Domain, and expires removal.\n\n    - ``WB_wombat_location`` overriden on Object prototype, defaults to ``location`` if ``_WB_wombat_location``, the actual,     property is not set.\n\n    - ``WB_wombat_location.href`` proxies to actual location, responsive to ``pushState`` / ``replaceState`` location changes.\n    - ``.href`` and ``.src`` attributes correctly return original url in JavaScript.\n    \n    - More consistent and ``lookupGetter/lookupSetter`` overrides with ``Object.defineProperty``.\n\n    - Added baseURI override, ``Element.prototype and ``document``.\n\n    - Added ``insertAdjacentHTML()`` override.\n\n    - Improved iframe override, including check for `contentDocument` changes.\n\n    - Don't rewrite urls that start with ``{``\n\n- Frames mode: ensure hash changes synchronized between inner and outer frames.\n\n- video: don't rewrite generic 'swf' with flowplayer\n\n- deprefix: support deprefixing of url-encoded queries.\n\n\npywb 0.10.1 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n- Support ``Content-Encoding: deflate`` which was not being handled.\n\n- Fix issues with ``fallback`` handlers: A POST request could result in double read of POST input data.\n\n- ``youtube-dl`` removed from dependency as it is only needed for live proxy. (related tests only run if ``youtube-dl`` is installed).\n\n\npywb 0.10.0 changelist\n~~~~~~~~~~~~~~~~~~~~~~\n\n* Per-collection cacheing settings: ``rewrite_opts.http_cache`` can be set to:\n\n    - ``pass`` - keep cacheing headers as-is (applies to ``Cache-Control``, ``Expires``, ``Etag`` and ``Last-Modified``)\n    - ``0`` - add ``Cache-Control: no-cache; no-store``\n    - ``N`` - add ``Cache-Control: max-age=N`` and corresponding ``Expires`` header\n    - None (default) -- Rewrite cache headers, effectively removing them (current behavior)\n  \n* New improved Wombat, including:\n\n    - better handling of new iframes set to ``about:blank``, add all overrides\n    - createElement() override (can be disabled)\n    - innerHTML prototype override (can be disabled)\n    \n* Rules: Improved rewriting for Google+, Twitter, YT comments\n\n* Video: Improved support for LiveStream playlist, detect newly added <object> and <embed> videos (with mutation observers)\n\n* Indexing: Add contents of ``WARC-Json-Metadata`` to ``metadata`` field in cdx-json\n\n* Buffering: Only buffer when content-length is missing and only up-to first 16K\n\n* ZipNum: Fix bug with contents of last block being inaccessible, improved test coverage for zipnum.\n    \n\n\npywb 0.9.8 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* auto config: allow custom settings set in shared ``config.yaml`` to be used with automatic collections.\n\n* wombat fixes: fixes situation where setAttribute was not being rewritten.\n\n* wombat fixes: obey ``_no_rewrite==true`` more consistently in rewrite_elem\n\n* wombat fixes: remove incorrect timezone offset in Date override.\n\n* wombat: new 'node added' mutation observer which will rewrite any newly added elements, may simplify other\n  rewriting cases. Not enabled by default yet requires setting ``client.use_node_observers`` to use.\n\n* regex rewrite: tweak ``top`` and scheme relative regexes to better avoid false positives\n\n* html rewrite: handle ``parse_comments`` by rewriting as html, instead of as javascript.\n\n* html rewrite: if html content has no <head> tags and no body tags, insert head_insert at end of document.\n\n* html rewrite: don't insert banner in ajax requests, wombat always adds ``X-Requested-With: XMLHttpRequest``.\n\n* scheme relative urls: rewrite to current scheme, if known, otherwise keep scheme relative, instead of defaulting to http.\n\n\npywb 0.9.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* wombat enchancements: support for mutation observers instead of ``setAttribute`` override with ``client.use_attr_observers`` setting.\n  Can also disable worker override with ``skip_disable_worker``\n  \n* wombat fixes: Better check for self-redirect when proxying ``replace()`` and ``assign()``, use ``querySelectorAll()`` for dom selection\n\n* wombat fixes: Don't remove trailing slash in ``extract_orig()``, treat slash and no-slash urls as distinct on the client (as expected).\n\n* cdx-indexer: Validation of HTTP protocol and request verbs now optional. Any protocol and verb will be accepted, unless ``-v`` flag is used,\n  allowing for indexing of content with custom verbs, unexpected protocol, etc...\n\n\npywb 0.9.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* framed replay: fix bug where outer frame url was not updated (in inverse mode) after navigating inner frame.\n\n* framed replay: lookup frame by id, ``replay_iframe``, instead of by using ``window.frames[0]`` to allow for more customization.\n\n* fix typo in wombat ``no_rewrite_prefixes``\n\n\npywb 0.9.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* s3 loading: support ``s3://`` scheme in block loader, allowing for loading index and archive files from s3. ``boto`` library must be installed seperately\n  via ``pip install boto``. Attempt default boto auth path, and if that fails, attempt anonymous s3 connection.\n  \n* Wombat/Client-Side Rewrite Customizations: New ``rewrite_opts.client`` settings from ``config.yaml`` are passed directly to wombat as json. \n  \n  Allows for customizing wombat as needed. Currently supported options are: ``no_rewrite_prefixes`` for ignoring rewrite\n  on certain domains, and ``skip_dom``, ``skip_setAttribute`` and ``skip_postmessage`` options for disabling \n  those overrides. Example usage in config:\n  \n  ::\n\n    rewrite_opts:\n        ...\n        client:\n            no_rewrite_prefixes: ['http://dont-rewrite-this.example.com/']\n  \n            skip_setAttribute: true\n            skip_dom: true\n            skip_postmessage: true\n  \n  \n* Revamp template setup: All templates now use shared env, which is created on first use or can be explicitly set (if embedding)\n  via ``J2TemplateView.init_shared_env()`` call. Support for specifiying a base env, as well as custom template lookup paths also provided\n  \n* Template lookup paths can also be set via config options ``templates_dirs``. The default list is: ``templates``, ``.``, ``/`` in that order.\n\n* Embedding improvements: move custom env (``REL_REQUEST_URI`` setup) into routers, should be able to call router created by ``create_wb_router()`` \n  directly with WSGI enviorn and receive a callable response.\n\n* Embedding improvements: If set, the contents of ``environ['pywb.template_params']`` dictionary are added directly to Jinja context, allowing for custom template\n  params to be passed to pywb jinja templates.\n\n* Root collection support: Can specify a route with `''` which will be the root collection. Fix routing paths to ensure root collection is checked last.\n\n* Customization: support custom route_class for cdx server and pass wbrequest to ``not_found_html``  error handlers.\n\n* Manager: Validate collection names to start with word char and contain alphanum or dash only.\n\n* CLI refactor: easier to create custom cli apps and pass params, inherit shared params. ``live-rewrite-server`` uses new system cli system,\n  defaults to framed inverse mode. Also runs on ``/live/`` path by default. See ``live-rewrite-server -h`` for a list of current options.\n\n* Add ``cookie_scope: removeall`` cookie rewriter, which will, remove all cookies from replay headers.\n\n* Security: disable file:// altogether for live rewrite path.\n\n* Fuzzy match: better support for custom replace string >1 character: leave string, and strip remainder before fuzzy query.\n\n* Urlrewriter and wburl fixes for various corner cases.\n\n* Rangecache: use url as key if digest not present.\n\n* Framed replay: attempt to mitigate chrome OS X scrolling issue by disabling ``-webkit-transform: none`` in framed mode. \n  Improves scrolling on many pages but not always consistent (a chrome bug).\n\n\npywb 0.9.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* framed replay mode: support ``framed_replay: inverse`` where the top frame is the canonical archival url and the inner frame has ``mp_`` modifier.\n\n* wb.js: improved redirect check: only redirect to top frame in framed mode and compare decoded urls.\n\n* charset detection: read first 1024 bytes to determine charset and add to ``Content-Type`` header if no charset is specified there.\n\n* indexing: support indexing of WARC records with ``urn:`` values as target uris, such as those created by `wpull <https://github.com/chfoo/wpull>`_\n\n* remove certauth module: now using standalone `certauth <http://github.com/ikreymer/certauth>`_ package.\n\n* BlockLoader: use ``requests`` instead of ``urllib2``.\n\n* cdx: %-encode any non-ascii chars found in cdx fields.\n\n* cdx: showNumPages query always return valid result (not 404) for 0 pages. If <1 block, load cdx to determine if 1 page or none.\n\n\npywb 0.9.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Collections Manager: Allow adding any templates to shared directory, fix adding WARCs with relative path.\n\n* Replay: Remove limit by HTTP ``Content-Length`` as it may be invalid (only using the record length).\n\n* WARC Revisit-Resolution Improvements: Support indexes and warcs without any ``digest`` field. If no digest is found, attempt to look up\n  the original WARC record from the ``WARC-Refers-To-Target-URI`` and ``WARC-Refers-To-Date`` only, even for same url revisits.\n  (Previously, only used this lookup original url was different from revisit url)\n\n\npywb 0.9.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Implement pagination support for zipnum cluster and added to cdx server api:\n\n  https://github.com/ikreymer/pywb/wiki/CDX-Server-API\n\n* cdx server query: add support for ``url=*.host`` and ``url=host/*`` as shortcuts for ``matchType=domain`` and ``matchType=prefix``\n\n* zipnum cdx cluster: support loading index shared from prefix path instead of seperate location file.\n\n  The ``shard_index_loc`` config property may contain match and replace properties.\n  Regex replacement is then used to obtain path prefix from the shard prefix path.\n\n* wombat: fix `document.write()` rewriting to rewrite each element at a time and use underlying write for better compatibility.\n\n\npywb 0.9.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* New directory-based configuration-less init system! ``config.yaml`` no longer required.\n\n* New ``wb-manager`` collection manager for adding warcs, indexing, adding/removing templates, setting metadata.\n\n  More details at: `Auto-Configuration and Wayback Collections Manager <https://github.com/ikreymer/pywb/wiki/Auto-Configuration-and-Wayback-Collections-Manager>`_\n\n* Support for user metadata via per-collection ``metadata.yaml``\n\n* Templates: improved/simpified home page and collection search page, show user metadata by default.\n\n* Support for writing and reading new cdx JSON format (.cdxj), with searchable key followed by json dictionary: ``urlkey timestamp { ... }`` on each line\n\n* ``cdx-indexer -j``: support for generating cdxj format\n\n* ``cdx-indexer -mj``: support for minimal cdx format (in JSON format) only which skips reading the HTTP record.\n\n    Fields included in minimal format are: urlkey, timestamp, original url, record length, digest, offset, and filename\n\n* ``cdx-indexer --root-dir <dir>``: option for custom root dir for cdx filenames to be relative to this directory.\n\n* ``wb-manager cdx-convert``: option to convert any existing cdx to new cdxj format, including ensuring cdx key is in SURT canonicalized.\n\n* ``wb-manager autoindex `` / ``wayback -a`` -- Support for auto-updating the cdx indexes whenever any WARC/ARC files are modified or created.\n\n* Switch default ``wayback``,  ``cdx-server``, ``live-rewrite-server`` cli apps to use ``waitress`` WSGI container instead of wsgi ref.\n\n  New cli options, including ``-p`` (port), ``-t`` (num threads), and ``-d`` (working directory)\n\n* url rewrite: fixes to JS url rewrite (some urls with unencoded chars were not being rewritten),\n  fixes to WbUrl parsing of urls starting with digits (eg. 1234.example.com) not being parsed properly.\n\n* framed replay: update frame_insert.html to be html5 compliant.\n\n* wombat: fixed to WB_wombat_location.href assignment, properly redirects to dest page even if url is already rewritten\n\n* static paths: static content included with pywb moved from ``static/default`` -> ``static/__pywb`` to free up default as possible collection name\n  and avoid any naming conflicts. For example, wombat.js can be accessed via ``/static/__pywb/wombat.js``\n\n* default to replay with framed mode enabled: ``framed_replay: true``\n\n\npywb 0.8.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* cookie rewrite: all cookie rewriters remove ``secure`` flag to allow equivalent replay of sites with cookies via HTTP and HTTPS.\n\n* html rewrite: fix ``<base>`` tag rewriting to add a trailing slash to the url if it is a hostname with no path, ex:\n\n  ``<base href=\"http://example.com\" />`` -> ``<base href=\"http://localhost:8080/rewrite/http://example.com/\" />``\n\n* framed replay: fix double slash that remainded when rewriting top frame url.\n\n\npywb 0.8.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* rewrite: fix for redirect loop related to pages with 'www.' prefix. Since canonicalization removes the prefix, treat redirect to 'www.' as self-redirect (for now).\n\n* memento: ensure rel=memento url matches timegate redirect exactly (urls may differ due to canonicalization, use actual instead of requested for both)\n\n\npywb 0.8.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* wb.js top frame notification: use ``window.__orig_parent`` when referencing actual parent as ``window.parent`` now overriden.\n\n* live proxy security: enable ssl verification for live proxy by default, for use with python 2.7.9 ssl improvements. Was disabled\n  due to incomplete ssl support in previous versions of python. Can be disabled via ``verify_ssl: False`` per collection.\n\n* cdx-indexer: add recursive option to index warcs in all subdirectories with ``cdx-indexer -r <dir_name>``\n\n\npywb 0.8.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\nImprovements to framed replay, memento support, IDN urls, and additional customization support in preparation for further config changes.\n\n* Feature: Full support for 'non-exact' or sticky timestamp browsing in framed and non-framed mode.\n\n  - setting ``redir_to_exact: False`` (per collection), no redirects will be issued to the exact timestamp of the capture.\n    The user-specified timestamp will be preserved and the number of redirects will be reduced.\n\n  - if no timestamp is present (latest-replay request), there is a redirect to the current time UTC timestamp,\n    available via ``pywb.utils.timeutils.timestamp_now()`` function.\n\n  - via head-insert, the exact request timestamp is provided as ``wbinfo.request_ts`` and accessible to the banner insert or the top frame when in framed mode.\n\n* Frame Mode Replay Improvements, including:\n\n  - wombat: modify ``window.parent`` and ``window.frameElement`` to hide top-level non replay frame.\n\n  - memento improvements: add same memento headers to top-level frame to match replay frame to ensure top-level frame\n    passes memento header validation.\n\n  - frame mode uses the request timestamp instead of the capture timestamp to update frame url.\n    By default, request timestamp == capture timestamp, unless ``redir_to_exact: False`` (see above).\n\n* Client-Side Rewrite Improvements:\n\n  - improved ``document.write`` override to also work when in ``<head>`` and append both ``<head>`` and ``<body>``\n\n  - detect multiple calls to rewrite attribute to avoid rewrite loops.\n\n* Customization improvements:\n\n  - ability to override global UrlRewriter with custom class by setting ``urlrewriter_class`` config setting.\n\n  - ability to disable JS url and location rewrite via ``js_rewrite_location: none`` setting.\n\n  - ability to set a custom content loader in place of default ARC/WARC loader in ``ReplayView._init_replay_view``\n\n* Improved Memento compatibility, ensuring all responses have a ``rel=memento`` link.\n\n* IDN support: Improved handling of non-ascii domains.\n\n  - all urls are internally converted to a Punycode host, percent encoded path using IDNA encoding (http://tools.ietf.org/html/rfc3490.html).\n  - when rendering, return convert all urls to fully percent-encoded by default (to allow browser to convert to unicode characters).\n  - ``punycode_links`` rewrite option can be enabled to keep ascii-punycode hostnames instead of percent-encoding.\n\n\npywb 0.7.8 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* live rewrite fix: When forwarding ``X-Forwarded-Proto`` header, set scheme to actual url scheme to avoid possible redirect loops (#57)\n\n\npywb 0.7.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* client-side rewrite: improved rewriting of all style changes using mutation observers\n\n* rules: fix YT rewrite rule, add rule for wikimedia\n\n* cdx-indexer: minor cleanup, add support for custom writer for batched cdx (write_multi_cdx_index)\n\n\npywb 0.7.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* new not found Jinja2 template: Add per-collection-overridable ``not_found.html`` template, specified via ``not_found_html`` option. For missing resources, the ``not_found_html`` template is now used instead of the generic ``error_html``\n\n* client-side rewrite: improved wombat rewrite of postMessage events, unrewrite target on receive, improved Vine replay\n\n* packaging: allow adding multiple packages for Jinja2 template resolving\n\npywb 0.7.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Cross platform fixes to support Windows -- all tests pass on Linux, OS X and Windows now. Improved cross-platform support includes:\n\n  - read all files as binary to avoid line ending issues\n  - properly convert between platform dependent file paths and urls\n  - add .gitattributes to ensure line endings on *.warc*, *.arc*, *.cdx* files are unaltered\n  - avoid platform dependent apis (eg. %s for strftime)\n\n* Change any unhandled exceptions to result in a 500 error, instead of 400.\n\n* Setup: switch to ``zip_safe=True`` to allow for embedding pywb egg in one-file app with `pyinstaller <https://github.com/pyinstaller/pyinstaller>`_\n\n* More compresensive client side ``src`` attribute rewriting (via wombat.js), additional server-side HTML tag rewriting.\n\n\npywb 0.7.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Experiment with disabling DASH for YT\n\n* New ``req_cookie_rewrite`` rewrite directive to rewrite outgoing ``Cookie`` header, can be used to fix a certain cookie for a url prefix.\n\n  A list of regex match/replace rules, applied in succession, can be set for each url prefix. See ``rules.yaml`` for more info.\n\n\npywb 0.7.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* (0.7.1 fixes some missing static files from 0.7.0 release)\n\n* Video/Audio Replay, Live Proxy and Recording Support (with pywb-webrecorder)!\n\n  See: `Video Replay and Recording <https://github.com/ikreymer/pywb/wiki/Video-Replay-and-Recording>`_ for more detailed info.\n\n* Support for replaying HTTP/1.1 range requests for any archived resorce (optional range cache be disabled via `enable_ranges: false`)\n\n* Support for on-the-fly video replacement of Flash with HTML5 using new video rewrite system ``vidrw.js``.\n\n  (Designed for all Flash videos, with varying levels of special cases for YouTube, Vimeo, Soundcloud and Dailymotion)\n\n* Use `youtube-dl <http://rg3.github.io/youtube-dl/>`_ to find actual video streams from page urls, record video info.\n\n* New, improved wombat 2.1 -- improved rewriting of dynamic content, including:\n\n  - setAttribute override\n  - Date override sets date to replay timestamp\n  - Image() object override\n  - ability to disable dynamic attribute rewriting by setting ``_no_rewrite`` on an element.\n\n* Type detection: resolve conflict between text/html that is served under js_ mod, resolve if html or js.\n\n\npywb 0.6.6 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* JS client side improvements: check for double-inits, preserve anchor in wb.js top location redirect\n\n* JS Rewriters: add mixins for link + location (default), link only, location only rewriting by setting ``js_rewrite_location`` to ``all``, ``urls``, ``location``, respectively.\n\n  (New: location only rewriting does not change JS urls)\n\n* Beginning of new rewrite options, settable per collections and stored in UrlRewriter. Available options:\n\n  - ``rewrite_base`` - set to False to disable rewriting ``<base href=\"...\">`` tag\n  - ``rewrite_rel_canon`` - set to false to disable rewriting ``<link rel=canon href=\"...\">``\n\n* JS rewrite: Don't rewrite location if starting with '$'\n\n\npywb 0.6.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* fix static handling when content type can not be guessed, default to 'application/octet-stream'\n\n* rewrite fix: understand partially encoded urls such as http%3A// in WbUrl, decode correctly\n\n* rewrite fix: rewrite \\/\\/example.com and \\\\/\\\\/example.com in JS same as \\\\example.com\n\n* cookies: add exact cookie rewriter which sets cookie to exact url only, never collection or host root\n\n* don't rewrite rel=canonical links for services which rely on these\n\n* cdx-indexer: Detect non-gzip chunk encoded .warc.gz/arc.gz archive files and show a meaningful\n  error message explaining how to fix issue (uncompress and possibly use warctools warc2warc to recompress)\n\n\npywb 0.6.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Ignore bad multiline headers in warc.\n\n* Rewrite fix: Don't parse html entities in HTML rewriter.\n\n* Ensure cdx iterator closed when reeading.\n\n* Rewrite fix: remove pywb prefix from any query params.\n\n* Rewrite fix: better JS rewriting, avoid // comments when matching protocol-relative urls.\n\n* WARC metadata and resource records include in cdx from cdx-indexer by default\n\n\npywb 0.6.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Minor fixes for extensability and support https://webrecorder.io, easier to override any request (handle_request), handle_replay or handle_query via WBHandler\n\n\npywb 0.6.2 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Invert framed replay paradigm: Canonical page is always without a modifier (instead of with ``mp_``), if using frames, the page redirects to ``tf_``, and uses replaceState() to change url back to canonical form.\n\n* Enable Memento support for framed replay, include Memento headers in top frame\n\n* Easier to customize just the banner html, via ``banner_html`` setting in the config. Default banner uses ui/banner.html and inserts the script default_banner.js, which creates the banner.\n\n  Other implementations may create banner via custom JS or directly insert HTML, as needed. Setting ``banner_html: False`` will disable the banner.\n\n* Small improvements to streaming response, read in fixed chunks to allow better streaming from live.\n\n* Improved cookie and csrf-token rewriting, including: ability to set ``cookie_scope: root`` per collection to have all replayed cookies have their Path set to application root.\n\n  This is useful for replaying sites which share cookies amongst different pages and across archived time ranges.\n\n* New, implified notation for fuzzy match rules on query params (See: `Fuzzy Match Rules <https://github.com/ikreymer/pywb/wiki/Fuzzy-Match-Rules>`_)\n\n\npywb 0.6.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* HTTPS Proxy Support! (See: `Proxy Mode Usage <https://github.com/ikreymer/pywb/wiki/Pywb-Proxy-Mode-Usage>`_)\n\n* Revamped HTTP/S system: proxy collection and capture time switching via cookie!\n\n* removed *hostnames* setting in config.yaml. pywb no longer needs to know the host(s) it is running on,\n  can infer the correct path from referrer on a fallback handling.\n\n* remove PAC config, just using direct proxy (HTTP and HTTPS) for simplicity.\n\n\npywb 0.5.4 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* bug fix: self-redirect check resolves relative Location: redirects\n\n* rewrite rules: 'parse_comments' option to parse html comments as JS, regex rewrite update to match '&quot;http:\\\\\\\\/' double backslash\n\n* bug fixes in framed replay for html content, update top frame for html content on load when possible\n\n\npywb 0.5.3 changelist\n~~~~~~~~~~~~~~~~~~~~~\n* better framed replay for non-html content -- include live rewrite timestamp via temp 'pywb.timestamp' cookie, updating banner of iframe load. All timestamp formatting moved to client-side for better customization.\n\n* refactoring of replay/live handlers for better extensability.\n\n* banner-only rewrite mode (via 'bn_' modifier) to support only banner insertion with no rewriting, server-side or client-side.\n\n\npywb 0.5.1 changelist\n~~~~~~~~~~~~~~~~~~~~~\nminor fixes:\n\n* cdxindexer accepts unicode filenames, encodes via sys encoding\n\n* SCRIPT_NAME now defaults to '' if not present\n\n\npywb 0.5.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Catch live rewrite errors and display more friendly pywb error message.\n\n* LiveRewriteHandler and WBHandler refactoring: LiveRewriteHandler now supports a root search page html template.\n\n* Proxy mode option: 'unaltered_replay' to proxy archival data with no modifications (no banner, no server or client side rewriting).\n\n* Fix client side rewriting (wombat.js) for proxy mode: only rewrite https -> http in absolute urls.\n\n* Fixes to memento timemap/timegate to work with framed replay mode.\n\n* Support for a fallback handler which will be called from a replay handler instead of a 404 response.\n\n  The handler, specified via the ``fallback`` option, can be the name of any other replay handler. Typically, it can be used with a live rewrite handler to fetch missing content from live instead of showing a 404.\n\n* Live Rewrite can now be included as a 'collection type' in a pywb deployment by setting index path to ``$liveweb``.\n\n* ``live-rewrite-server`` has optional ``--proxy host:port`` param to specify a loading live web data through an HTTP/S proxy, such as for use with a recording proxy.\n\n* wombat: add document.cookie -> document.WB_wombat_cookie rewriting to check and rewrite Path= to archival url\n\n* Better parent relative '../' path rewriting, resolved to correct absolute urls when rewritten. Additional testing for parent relative urls.\n\n* New 'proxy_options' block, including 'use_default_coll' to allow defaulting to first collection w/o proxy auth.\n\n* Improved support for proxy mode, allow different collections to be selected via proxy auth\n\n\npywb 0.4.7 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Tests: Additional testing of bad cdx lines, missing revisit records.\n\n* Rewrite: Removal of lxml support for now, as it leads to problematic replay and not much performance improvements.\n\n* Rewrite: Parsing of html as raw bytes instead of decode/encode, detection still needed for non-ascii compatible encoding.\n\n* Indexing: Refactoring of cdx-indexer using a seperate 'archive record iterator' and pluggable cdx writer classes. Groundwork for creating custom indexers.\n\n* Indexing: Support for 9 field cdx formats with -9 flag.\n\n* Rewrite: Improved top -> WB_wombat_top rewriting.\n\n* Rewrite: Better handling of framed replay url notification\n\npywb 0.4.5 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Support for framed or non-framed mode replay, toggleable via the ``framed_replay`` flag in the config.yaml\n\n* Cookie rewriter: remove Max-Age to use ensure session-expiry instead of long-term cookie (experimental).\n\n* Live Rewrite: proxy all headers, instead of a whitelist.\n\n* Fixes to ``<base>`` tag handling, now correctly rewriting remainder of urls with the set base.\n\n* ``cdx-indexer`` options for resolving POST requests, and indexing request records. (``-p`` and ``-a``)\n\n* Improved `POST request replay <https://github.com/ikreymer/pywb/wiki/POST-request-replay>`_, allowing for improved replay of many captures relying on POST requests.\n\npywb 0.4.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Improved test coverage throughout the project.\n\n* live-rewrite-server: A new web server for checking rewriting rules against live content. A white-list of request headers is sent to\n  the destination server. See `rewrite_live.py <https://github.com/ikreymer/pywb/blob/master/pywb/rewrite/rewrite_live.py>`_ for more details.\n\n* Cookie Rewriting in Archival Mode: HTTP Set-Cookie header rewritten to remove Expires, rewrite Path and Domain. If Domain is used, Path is set to / to ensure cookie is visible from all archival urls.\n\n* Much improved handling of chunk encoded responses, better handling of zero-length chunks and fix bug where not enough gzip data was read for a full chunk to be decoded. Support for chunk-decoding w/o gzip decompression\n  (for example, for binary data).\n\n* Redis CDX: Initial support for reading entire CDX 'file' from a redis key via ZRANGEBYLEX, though needs more testing.\n\n* Jinja templates: additional keyword args added to most templates for customization, export 'urlsplit' to use by templates.\n\n* Remove SeekableLineReader, just using standard file-like object for binary search.\n\n* Proper handling of js_ cs_ modifiers to select content-type.\n\n* New, experimental support for top-level 'frame mode', used by live-rewrite-server, to display rewritten content in a frame. The mp_ modifier is used\n  to indicate the main page when top-level page is a frame.\n\n* cdx-indexer: Support for creation of non-SURT, url-ordered as well SURT-ordered CDX files.\n\n* Further rewrite of wombat.js: support for window.open, postMessage overrides, additional rewriting at Node creation time, better hash change detection.\n  Use ``Object.defineProperty`` whenever possible to better override assignment to various JS properties.\n  See `wombat.js <https://github.com/ikreymer/pywb/blob/master/pywb/static/wombat.js>`_ for more info.\n\n* Update wombat.js to support: scheme-relative urls rewriting, dom manipulation rewriting, disable web Worker api which could leak to live requests\n\n* Fixed support for empty arc/warc records. Indexed with '-', replay with '204 No Content'\n\n* Improve lxml rewriting, letting lxml handle parsing and decoding from bytestream directly (to address #36)\n\n\npywb 0.3.0 changelist\n~~~~~~~~~~~~~~~~~~~~~\n\n* Generate cdx indexs via command-line `cdx-indexer` script. Optionally sorting, and output to either a single combined file or a file per-directory.\n  Refer to ``cdx-indexer -h`` for more info.\n\n* Initial support for prefix url queries, eg: http://localhost:8080/pywb/\\*/http://example.com\\* to query all captures from http://example.com\n\n* Support for optional LXML html-based parser for fastest possible parsing. If lxml is installed on the system and via ``pip install lxml``, lxml parser is enabled by default.\n  (This can be turned off by setting ``use_lxml_parser: false`` in the config)\n\n* Full support for `Memento Protocol RFC7089 <http://www.mementoweb.org/guide/rfc/>`_ Memento, TimeGate and TimeMaps. Memento: TimeMaps in ``application/link-format`` provided via the ``/timemap/*/`` query.. eg: http://localhost:8080/pywb/timemap/\\*/http://example.com\n\n* pywb now features new `domain-specific rules <https://github.com/ikreymer/pywb/blob/master/pywb/rules.yaml>`_ which are applied to resolve and render certain difficult and dynamic content, in order to make accurate web replay work.\n  This ruleset will be under further iteration to address further challenges as the web evoles.\n", "patch": "@@ -1,3 +1,17 @@\n+pywb 2.6.0b1 changelist\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Additional documentation / localization fixes `#650 <https://github.com/webrecorder/pywb/pull/650>`_\n+\n+* Ensure home page and error page keeps locale, language switching is working.\n+\n+* Add autoescaping to Jinja2 to avoid XSS issues (suggested by @sebastian-nagel)\n+\n+* Add support for 'pywb[i18n]' extra to install localization dependencies\n+\n+Documentation typo fixes (by @ldko, `#649 <https://github.com/webrecorder/pywb/pull/649>`_)\n+\n+\n pywb 2.6.0b0 changelist\n ~~~~~~~~~~~~~~~~~~~~~~~\n ", "file_path": "files/2021_8/288", "file_language": "rst", "file_name": "CHANGES.rst", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/config.yaml", "code": "# pywb config file\n# ========================================\n#\n\ncollections:\n    all: $all\n    pywb:\n        index_paths: ./sample_archive/cdx/\n        archive_paths: ./sample_archive/warcs/\n\n# Settings for each collection\nuse_js_obj_proxy: true\n\n# Memento support, enable\nenable_memento: true\n\n# Replay content in an iframe\nframed_replay: true\n\n", "code_before": "# pywb config file\n# ========================================\n#\n\ncollections:\n    all: $all\n    pywb:\n        index_paths: ./sample_archive/cdx/\n        archive_paths: ./sample_archive/warcs/\n\n# Settings for each collection\nuse_js_obj_proxy: true\n\n# Memento support, enable\nenable_memento: true\n\n# Replay content in an iframe\nframed_replay: true\n\nlocales:\n  - en\n  - es\n", "patch": "@@ -17,6 +17,3 @@ enable_memento: true\n # Replay content in an iframe\n framed_replay: true\n \n-locales:\n-  - en\n-  - es", "file_path": "files/2021_8/289", "file_language": "yaml", "file_name": "config.yaml", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/docs%2Fmanual%2Faccess-control.rst", "code": ".. _access-control:\n\nEmbargo and Access Control\n--------------------------\n\nThe embargo system allows for date-based rules to block access to captures based on their capture dates.\n\nThe access controls system provides additional URL-based rules to allow, block or exclude access to specific URL prefixes or exact URLs.\n\nThe embargo and access control rules are configured per collection.\n\nEmbargo Settings\n================\n\nThe embargo system allows restricting access to all URLs within a collection based on the timestamp of each URL.\nAccess to these resources is 'embargoed' until the date range is adjusted or the time interval passes.\n\nThe embargo can be used to disallow access to captures based on following criteria:\n\n- Captures before an exact date\n- Captures after an exact date\n- Captures newer than a time interval\n- Captures older than a time interval\n\nEmbargo Before/After Exact Date\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo block access to all captures before or after a specific date, use the ``before`` or ``after`` embargo blocks\nwith a specific timestamp.\n\nFor example, the following blocks access to all URLs captured before 2020-12-26 in the collection ``embargo-before``::\n\n  embargo-before:\n      index_paths: ...\n      archive_paths: ...\n      embargo:\n          before: '20201226'\n\n\nThe following blocks access to all URLs captured on or after 2020-12-26 in collection ``embargo-after``::\n\n  embargo-after:\n      index_paths: ...\n      archive_paths: ...\n      embargo:\n          after: '20201226'\n\nEmbargo By Time Interval\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe embargo can also be set for a relative time interval, consisting of years, months, weeks and/or days.\n\n\nFor example, the following blocks access to all URLs newer than 1 year::\n\n  embargo-newer:\n      ...\n      embargo:\n          newer:\n            years: 1\n\n\n\nThe following blocks access to all URLs older than 1 year, 2 months, 3 weeks and 4 days::\n\n  embargo-older:\n      ...\n      embargo:\n          older:\n            years: 1\n            months: 2\n            weeks: 3\n            days: 4\n\n\nAny combination of years, months, weeks and days can be used (as long as at least one is provided) for the ``newer`` or ``older`` embargo settings.\n\n\nAccess Control Settings\n=======================\n\nAccess Control Files (.aclj)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nURL-based access controls are set in one or more access control JSON files (.aclj), sorted in reverse alphabetical order.\nTo determine the best match, a binary search is used (similar to CDXJ lookup) and then the best match is found forward.\n\nAn .aclj file may look as follows::\n\n  org,httpbin)/anything/something - {\"access\": \"allow\", \"url\": \"http://httpbin.org/anything/something\"}\n  org,httpbin)/anything - {\"access\": \"exclude\", \"url\": \"http://httpbin.org/anything\"}\n  org,httpbin)/ - {\"access\": \"block\", \"url\": \"httpbin.org/\"}\n  com, - {\"access\": \"allow\", \"url\": \"com,\"}\n\n\nEach JSON entry contains an ``access`` field and the original ``url`` field that was used to convert to the SURT (if any).\n\nThe JSON entry may also contain a ``user`` field, as explained below.\n\nThe prefix consists of a SURT key and a ``-`` (currently reserved for a timestamp/date range field to be added later).\n\nGiven these rules, a user would:\n\n* be allowed to visit ``http://httpbin.org/anything/something`` (allow)\n* but would receive an 'access blocked' error message when viewing ``http://httpbin.org/`` (block)\n* would receive a 404 not found error when viewing ``http://httpbin.org/anything`` (exclude)\n\n\nAccess Types: allow, block, exclude, allow_ignore_embargo\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe available access types are as follows:\n\n- ``exclude`` - when matched, results are excluded from the index, as if they do not exist. User will receive a 404.\n- ``block`` - when matched, results are not excluded from the index, but access to the actual content is blocked. User will see a 451.\n- ``allow`` - full access to the index and the resource, but may be overriden by embargo\n- ``allow_ignore_embargo`` - full access to the index and resource, overriding any embargo settings\n\nThe difference between ``exclude`` and ``block`` is that when blocked, the user can be notified that access is blocked, while\nwith exclude, no trace of the resource is presented to the user.\n\nThe use of ``allow`` is useful to provide access to more specific resources within a broader block/exclude rule, while ``allow_ignore_embargo``\ncan be used to override any embargo settings.\n\nIf both are present, the embargo restrictions are checked first and take precedence, unless the ``allow_ignore_embargo`` option is used\nto override the embargo.\n\n\nUser-Based Access Controls\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe access control rules can further be customized be specifying different permissions for different 'users'. Since pywb does not have a user system,\na special header, ``X-Pywb-ACL-User`` can be used to indicate a specific user.\n\nThis setting is designed to allow a more privileged user to access additional content or override an embargo.\n\nFor example, the following access control settings restrict access to ``https://example.com/restricted/`` by default, but allow access for the ``staff`` user::\n\n  com,example)/restricted - {\"access\": \"allow\", \"user\": \"staff\"}\n  com,example)/restricted - {\"access\": \"block\"}\n\n\nCombined with the embargo settings, this can also be used to override the embargo for internal organizational users, while keeping the embargo for general access::\n\n  com,example)/restricted - {\"access\": \"allow_ignore_embargo\", \"user\": \"staff\"}\n  com,example)/restricted - {\"access\": \"allow\"}\n\nTo make this work, pywb must be running behind an Apache or Nginx system that is configured to set ``X-Pywb-ACL-User: staff`` based on certain settings.\n\nFor example, this header may be set based on IP range, or based on password authentication.\n\nFurther examples of how to set this header will be provided in the deployments section.\n\n**Note: Do not use the user-based rules without configuring proper authentication on an Apache or Nginx frontend to set or remove this header, otherwise the 'X-Pywb-ACL-User' can easily be faked.**\n\nSee the :ref:`config-acl-header` section in Usage for examples on how to configure this header.\n\n\nAccess Error Messages\n^^^^^^^^^^^^^^^^^^^^^\n\nThe special error code 451 is used to indicate that a resource has been blocked (access setting ``block``).\n\nThe `error.html <https://github.com/webrecorder/pywb/blob/master/pywb/templates/error.html>`_ template contains a special message for this access and can be customized further.\n\nBy design, resources that are ``exclude``-ed simply appear as 404 not found and no special error is provided.\n\n\nManaging Access Lists via Command-Line\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe .aclj files need not ever be added or edited manually.\n\nThe pywb ``wb-manager`` utility has been extended to provide tools for adding, removing and checking access control rules.\n\nThe access rules are written to ``<collection>/acl/access-rules.aclj`` for a given collection ``<collection>`` for automatic collections.\n\nFor example, to add the first line to an ACL file ``access.aclj``, one could run::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something exclude\n\n\nThe URL supplied can be a URL or a SURT prefix. If a SURT is supplied, it is used as is::\n\n  wb-manager acl add <collection> com, allow\n\n\nA specific user for user-based rules can also be specified, for example to add ``allow_ignore_embargo`` for user ``staff`` only, run::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something allow_ignore_embargo -u staff\n\n\nBy default, access control rules apply to a prefix of a given URL or SURT.\n\nTo have the rule apply only to the exact match, use::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something allow --exact-match\n\nRules added with and without the ``--exact-match`` flag are considered distinct rules, and can be added\nand removed separately.\n\nWith the above rules, ``http://httpbin.org/anything/something`` would be allowed, but\n``http://httpbin.org/anything/something/subpath`` would be excluded for any ``subpath``.\n\nTo remove a rule, one can run::\n\n  wb-manager acl remove <collection> http://httpbin.org/anything/something\n\nTo import rules in bulk, such as from an OpenWayback-style excludes.txt and mark them as ``exclude``::\n\n  wb-manager acl importtxt <collection> ./excludes.txt exclude\n\n\nSee ``wb-manager acl -h`` for a list of additional commands such as for validating rules files and running a match against\nan existing rule set.\n\n\n\nAccess Controls for Custom Collections\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor manually configured collections, there are additional options for configuring access controls.\nThe access control files can be specified explicitly using the ``acl_paths`` key and allow specifying multiple ACL files,\nand allow sharing access control files between different collections.\n\nSingle ACLJ::\n\n  collections:\n       test:\n            acl_paths: ./path/to/file.aclj\n            default_access: block\n\n\n\nMultiple ACLJ::\n\n  collections:\n       test:\n            acl_paths:\n                 - ./path/to/allows.aclj\n                 - ./path/to/blocks.aclj\n                 - ./path/to/other.aclj\n                 - ./path/to/directory\n\n            default_access: block\n\nThe ``acl_paths`` can be a single entry or a list, and can also include directories. If a directory is specified, all ``.aclj`` files\nin the directory are checked.\n\nWhen finding the best rule from multiple ``.aclj`` files, each file is binary searched and the result\nset merge-sorted to find the best match (very similar to the CDXJ index lookup).\n\nNote: It might make sense to separate ``allows.aclj`` and ``blocks.aclj`` into individual files for organizational reasons,\nbut there is no specific need to keep more than one access control file.\n\nFinally, ACLJ and embargo settings combined for the same collection might look as follows::\n\n  collections:\n       test:\n            ...\n            embargo:\n                newer:\n                    days: 366\n\n            acl_paths:\n                 - ./path/to/allows.aclj\n                 - ./path/to/blocks.aclj\n\n\nDefault Access\n^^^^^^^^^^^^^^\n\nAn additional ``default_access`` setting can be added to specify the default rule if no other rules match for custom collections.\nIf omitted, this setting is ``default_access: allow``, which is usually the desired default.\n\nSetting ``default_access: block`` and providing a list of ``allow`` rules provides a flexible way to allow access\nto only a limited set of resources, and block access to anything out of scope by default.\n\n\n", "code_before": ".. _access-control:\n\nEmbargo and Access Control\n--------------------------\n\nThe embargo system allows for date-based rules to block access to captures based on their capture dates.\n\nThe access controls system provides additional URL-based rules to allow, block or exclude access to specific URL prefixes or exact URLs.\n\nThe embargo and access control rules are configured per collection.\n\nEmbargo Settings\n================\n\nThe embargo system allows restricting access to all URLs within a collection based on the timestamp of each URL.\nAccess to these resources is 'embargoed' until the date range is adjusted or the time interval passes.\n\nThe embargo can be used to disallow access to captures based on following criteria:\n\n- Captures before an exact date\n- Captures after an exact date\n- Captures newer than a time interval\n- Captures older than a time interval\n\nEmbargo Before/After Exact Date\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo block access to all captures before or after a specific date, use the ``before`` or ``after`` embargo blocks\nwith a specific timestamp.\n\nFor example, the following blocks access to all URLs captured before 2020-12-26 in the collection ``embargo-before``::\n\n  embargo-before:\n      index_paths: ...\n      archive_paths: ...\n      embargo:\n          before: '20201226'\n\n\nThe following blocks access to all URLs captured on or after 2020-12-26 in collection ``embargo-after``::\n\n  embargo-after:\n      index_paths: ...\n      archive_paths: ...\n      embargo:\n          after: '20201226'\n\nEmbargo By Time Interval\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe embargo can also be set for a relative time interval, consisting of years, months, weeks and/or days.\n\n\nFor example, the following blocks access to all URLs newer than 1 year::\n\n  embargo-newer:\n      ...\n      embargo:\n          newer:\n            years: 1\n\n\n\nThe following blocks access to all URLs older than 1 year, 2 months, 3 weeks and 4 days::\n\n  embargo-older:\n      ...\n      embargo:\n          older:\n            years: 1\n            months: 2\n            weeks: 3\n            days: 4\n\n\nAny combination of years, months, weeks and days can be used (as long as at least one is provided) for the ``newer`` or ``older`` embargo settings.\n\n\nAccess Control Settings\n=======================\n\nAccess Control Files (.aclj)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nURL-based access controls are set in one or more access control JSON files (.aclj), sorted in reverse alphabetical order.\nTo determine the best match, a binary search is used (similar to CDXJ lookup) and then the best match is found forward.\n\nAn .aclj file may look as follows::\n\n  org,httpbin)/anything/something - {\"access\": \"allow\", \"url\": \"http://httpbin.org/anything/something\"}\n  org,httpbin)/anything - {\"access\": \"exclude\", \"url\": \"http://httpbin.org/anything\"}\n  org,httpbin)/ - {\"access\": \"block\", \"url\": \"httpbin.org/\"}\n  com, - {\"access\": \"allow\", \"url\": \"com,\"}\n\n\nEach JSON entry contains an ``access`` field and the original ``url`` field that was used to convert to the SURT (if any).\n\nThe JSON entry may also contain a ``user`` field, as explained below.\n\nThe prefix consists of a SURT key and a ``-`` (currently reserved for a timestamp/date range field to be added later).\n\nGiven these rules, a user would:\n\n* be allowed to visit ``http://httpbin.org/anything/something`` (allow)\n* but would receive an 'access blocked' error message when viewing ``http://httpbin.org/`` (block)\n* would receive a 404 not found error when viewing ``http://httpbin.org/anything`` (exclude)\n\n\nAccess Types: allow, block, exclude, allow_ignore_embargo\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe available access types are as follows:\n\n- ``exclude`` - when matched, results are excluded from the index, as if they do not exist. User will receive a 404.\n- ``block`` - when matched, results are not excluded from the index, but access to the actual content is blocked. User will see a 451.\n- ``allow`` - full access to the index and the resource, but may be overriden by embargo\n- ``allow_ignore_embargo`` - full access to the index and resource, overriding any embargo settings\n\nThe difference between ``exclude`` and ``block`` is that when blocked, the user can be notified that access is blocked, while\nwith exclude, no trace of the resource is presented to the user.\n\nThe use of ``allow`` is useful to provide access to more specific resources within a broader block/exclude rule, while ``allow_ignore_embargo``\ncan be used to override any embargo settings.\n\nIf both are present, the embargo restrictions are checked first and take precedence, unless the ``allow_ignore_embargo`` option is used\nto override the embargo.\n\n\nUser-Based Access Controls\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe access control rules can further be customized be specifying different permissions for different 'users'. Since pywb does not have a user system,\na special header, ``X-Pywb-ACL-User`` can be used to indicate a specific user.\n\nThis setting is designed to allow a more privileged user to access additional content or override an embargo.\n\nFor example, the following access control settings restrict access to ``https://example.com/restricted/`` by default, but allow access for the ``staff`` user::\n\n  com,example)/restricted - {\"access\": \"allow\", \"user\": \"staff\"}\n  com,example)/restricted - {\"access\": \"block\"}\n\n\nCombined with the embargo settings, this can also be used to override the embargo for internal organizational users, while keeping the embargo for general access::\n\n  com,example)/restricted - {\"access\": \"allow_ignore_embargo\", \"user\": \"staff\"}\n  com,example)/restricted - {\"access\": \"allow\"}\n\nTo make this work, pywb must be running behind an Apache or Nginx system that is configured to set ``X-Pywb-ACL-User: staff`` based on certain settings.\n\nFor example, this header may be set based on IP range, or based on password authentication.\n\nFurther examples of how to set this header will be provided in the deployments section.\n\n**Note: Do not use the user-based rules without configuring proper authentication on an Apache or Nginx frontend to set or remove this header, otherwise the 'X-Pywb-ACL-User' can easily be faked.**\n\nSee the :ref:`config-acl-header` section in Usage for examples on how to configure this header.\n\n\nAccess Error Messages\n^^^^^^^^^^^^^^^^^^^^^\n\nThe special error code 451 is used to indicate that a resource has been blocked (access setting ``block``).\n\nThe `error.html <https://github.com/webrecorder/pywb/blob/master/pywb/templates/error.html>`_ template contains a special message for this access and can be customized further.\n\nBy design, resources that are ``exclude``-ed simply appear as 404 not found and no special error is provided.\n\n\nManaging Access Lists via Command-Line\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe .aclj files need not ever be added or edited manually.\n\nThe pywb ``wb-manager`` utility has been extended to provide tools for adding, removing and checking access control rules.\n\nThe access rules are written to ``<collection>/acl/access-rules.aclj`` for a given collection ``<collection>`` for automatic collections.\n\nFor example, to add the first line to an ACL file ``access.aclj``, one could run::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something exclude\n\n\nThe URL supplied can be a URL or a SURT prefix. If a SURT is supplied, it is used as is::\n\n  wb-manager acl add <collection> com, allow\n\n\nA specific user for user-based rules can also be specified, for example to add ``allow_ignore_embargo`` for user ``staff`` only, run::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something allow_ignore_embargo staff\n\n\nBy default, access control rules apply to a prefix of a given URL or SURT.\n\nTo have the rule apply only to the exact match, use::\n\n  wb-manager acl add <collection> http://httpbin.org/anything/something allow --exact-match\n\nRules added with and without the ``--exact-match`` flag are considered distinct rules, and can be added\nand removed separately.\n\nWith the above rules, ``http://httpbin.org/anything/something`` would be allowed, but\n``http://httpbin.org/anything/something/subpath`` would be excluded for any ``subpath``.\n\nTo remove a rule, one can run::\n\n  wb-manager acl remove <collection> http://httpbin.org/anything/something\n\nTo import rules in bulk, such as from an OpenWayback-style excludes.txt and mark them as ``exclude``::\n\n  wb-manager acl importtxt <collection> ./excludes.txt exclude\n\n\nSee ``wb-manager acl -h`` for a list of additional commands such as for validating rules files and running a match against\nan existing rule set.\n\n\n\nAccess Controls for Custom Collections\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor manually configured collections, there are additional options for configuring access controls.\nThe access control files can be specified explicitly using the ``acl_paths`` key and allow specifying multiple ACL files,\nand allow sharing access control files between different collections.\n\nSingle ACLJ::\n\n  collections:\n       test:\n            acl_paths: ./path/to/file.aclj\n            default_access: block\n\n\n\nMultiple ACLJ::\n\n  collections:\n       test:\n            acl_paths:\n                 - ./path/to/allows.aclj\n                 - ./path/to/blocks.aclj\n                 - ./path/to/other.aclj\n                 - ./path/to/directory\n\n            default_access: block\n\nThe ``acl_paths`` can be a single entry or a list, and can also include directories. If a directory is specified, all ``.aclj`` files\nin the directory are checked.\n\nWhen finding the best rule from multiple ``.aclj`` files, each file is binary searched and the result\nset merge-sorted to find the best match (very similar to the CDXJ index lookup).\n\nNote: It might make sense to separate ``allows.aclj`` and ``blocks.aclj`` into individual files for organizational reasons,\nbut there is no specific need to keep more than one access control file.\n\nFinally, ACLJ and embargo settings combined for the same collection might look as follows::\n\n  collections:\n       test:\n            ...\n            embargo:\n                newer:\n                    days: 366\n\n            acl_paths:\n                 - ./path/to/allows.aclj\n                 - ./path/to/blocks.aclj\n\n\nDefault Access\n^^^^^^^^^^^^^^\n\nAn additional ``default_access`` setting can be added to specify the default rule if no other rules match for custom collections.\nIf omitted, this setting is ``default_access: allow``, which is usually the desired default.\n\nSetting ``default_access: block`` and providing a list of ``allow`` rules provides a flexible way to allow access\nto only a limited set of resources, and block access to anything out of scope by default.\n\n\n", "patch": "@@ -187,7 +187,7 @@ The URL supplied can be a URL or a SURT prefix. If a SURT is supplied, it is use\n \n A specific user for user-based rules can also be specified, for example to add ``allow_ignore_embargo`` for user ``staff`` only, run::\n \n-  wb-manager acl add <collection> http://httpbin.org/anything/something allow_ignore_embargo staff\n+  wb-manager acl add <collection> http://httpbin.org/anything/something allow_ignore_embargo -u staff\n \n \n By default, access control rules apply to a prefix of a given URL or SURT.", "file_path": "files/2021_8/290", "file_language": "rst", "file_name": "docs/manual/access-control.rst", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/docs%2Fmanual%2Flocalization.rst", "code": ".. _localizaation:\n\nLocalization / Multi-lingual Support\n------------------------------------\n\npywb supports configuring different language locales and loading different language translations, and dynamically switching languages.\n\npywb can extract all text from templates and generate CSV files for translation and convert them back into a binary format used for localization/internationalization.\n\n(pywb uses the `Babel library <http://babel.pocoo.org/en/latest/>`_  which extends the `standard Python i18n system <https://docs.python.org/3/library/gettext.html>`_)\n\nTo ensure all localization related dependencies are installed, first run::\n\n  pip install pywb[i18n]\n\nLocales to use are configured in the ``config.yaml``.\n\nThe command-line ``wb-manager`` utility provides a way to manage locales for translation, including generating extracted text, and to update translated text.\n\n\nAdding a Locale and Extracting Text\n===================================\n\nTo add a new locale for translation and automatically extract all text that needs to be translated, run::\n\n  wb-manager i18n extract <loc>\n\nThe ``<loc>`` can be one or more supported two-letter locales or CLDR language codes. To list available codes, you can run ``pybabel --list-locales``.\n\nLocalization data is placed in the ``i18n`` directory, and translatable strings can be found in ``i18n/translations/<locale>/LC_MESSAGES/messages.csv``\n\nEach CSV file looks as follows, listing each source string and an empty string for the translated version::\n\n  \"location\",\"source\",\"target\"\n  \"pywb/templates/banner.html:6\",\"Live on\",\"\"\n  \"pywb/templates/banner.html:8\",\"Calendar icon\",\"\"\n  \"pywb/templates/banner.html:9 pywb/templates/query.html:45\",\"View All Captures\",\"\"\n  \"pywb/templates/banner.html:10 pywb/templates/header.html:4\",\"Language:\",\"\"\n  \"pywb/templates/banner.html:11\",\"Loading...\",\"\"\n  ...\n\n\nThis CSV can then be passed to translators to translate the text.\n\n(The extraction parameters are configured to load data from ``pywb/templates/*.html`` in ``babel.ini``)\n\n\nFor example, the following will generate translation strings for ``es`` and ``pt`` locales::\n\n   wb-manager i18n extract es pt\n\n\nThe translatable text can then be found in ``i18n/translations/es/LC_MESSAGES/messages.csv`` and ``i18n/translations/pt/LC_MESSAGES/messages.csv``.\n\n\nThe CSV files should be updated with a translation for each string in the ``target`` column.\n\nThe extract command adds any new strings without overwriting existing translations, so after running the update command to compile translated strings (described below), it is safe to run the extract command again.\n\n\nUpdating Locale Catalog\n=======================\n\nOnce the text has been translated, and the CSV files updated, simply run::\n\n  wb-manager i18n update <loc>\n\nThis will parse the CSVs and compile the translated string tables for use with pywb.\n\n\nSpecifying locales in pywb\n==========================\n\nTo enable the locales in pywb, one or more locales can be added to the ``locales`` key in ``config.yaml``, ex::\n\n  locales:\n     - en\n     - es\n\nSingle Language Default Locale\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\npywb can be configured with a default, single-language locale, by setting the ``default_locale`` property in ``config.yaml``::\n\n\n  default_locale: es\n  locales:\n     - es\n\n\nWith this configuration, pywb will automatically use the ``es`` locale for all text strings in pywb pages.\n\npywb will also set the ``<html lang=\"es\">`` so that the browser will recognize the correct locale.\n\n\nMutli-language Translations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf more than one locale is specified, pywb will automatically show a language switching UI at the top of collection and search pages, with an option\nfor each locale listed. To include English as an option, it should also be added as a locale (and no strings translated). For example::\n\n  locales:\n     - en\n     - es\n     - pt\n\nwill configure pywb to show a language switch option on all pages.\n\n\nLocalized Collection Paths\n==========================\n\nWhen localization is enabled, pywb supports the locale prefix for accessing each collection with a localized language:\nIf pywb has a collection ``my-web-archive``, then:\n\n* ``/my-web-archive/`` - loads UI with default language (set via ``default_locale``)\n* ``/en/my-web-archive/`` - loads UI with ``en`` locale\n* ``/es/my-web-archive/`` - loads UI with ``es`` locale\n* ``/pt/my-web-archive/`` - loads UI with ``pt`` locale\n\nThe language switch options work by changing the locale prefix for the same page.\n\nListing and Removing Locales\n============================\n\nTo list the locales that have previously been added, you can also run ``wb-manager i18n list``.\n\nTo disable a locale from being used in pywb, simply remove it from the ``locales`` key in ``config.yaml``.\n\nTo remove data for a locale permanently, you can run: ``wb-manager i18n remove <loc>``. This will remove the locale directory on disk.\n\nTo remove all localization data, you can manually delete the ``i18n`` directory.\n\n\nUI Templates: Adding Localizable Text\n=====================================\n\nText that can be translated, localizable text, can be marked as such directly in the UI templates:\n\n1. By wrapping the text in ``{% trans %}``/``{% endtrans %}`` tags. For example::\n\n   {% trans %}Collection {{ coll }} Search Page{% endtrans %}\n\n2. Short-hand by calling a special ``_()`` function, which can be used in attributes or more dynamically. For example::\n\n   ... title=\"{{ _('Enter a URL to search for') }}\">\n\n\nThese methods can be used in all UI templates and are supported by the Jinja2 templating system.\n\nSee :ref:`ui-customizations` for a list of all available UI templates.\n\n", "code_before": ".. _localizaation:\n\nLocalization / Multi-lingual Support\n------------------------------------\n\npywb supports configuring different language locales and loading different language translations, and dynamically switching languages.\n\npywb can extract all text from templates and generate CSV files for translation and convert them back into a binary format used for localization/internationalization.\n\n(pywb uses the `Babel library <http://babel.pocoo.org/en/latest/>`_  which extends the `standard Python i18n system <https://docs.python.org/3/library/gettext.html>`_)\n\nLocales to use are configured in the ``config.yaml``.\n\nThe command-line ``wb-manager`` utility provides a way to manage locales for translation, including generating extracted text, and to update translated text.\n\nAdding a Locale and Extracting Text\n===================================\n\nTo add a new locale for translation and automatically extract all text that needs to be translated, run::\n\n  wb-manager i18n extract <loc>\n\nThe ``<loc>`` can be one or more supported two-letter locales or CLDR language codes. To list available codes, you can run ``pybabel --list-locales``.\n\nLocalization data is placed in the ``i18n`` directory, and translatable strings can be found in ``i18n/translations/<locale>/LC_MESSAGES/messages.csv``\n\nEach CSV file looks as follows, listing each source string and an empty string for the translated version::\n\n  \"location\",\"source\",\"target\"\n  \"pywb/templates/banner.html:6\",\"Live on\",\"\"\n  \"pywb/templates/banner.html:8\",\"Calendar icon\",\"\"\n  \"pywb/templates/banner.html:9 pywb/templates/query.html:45\",\"View All Captures\",\"\"\n  \"pywb/templates/banner.html:10 pywb/templates/header.html:4\",\"Language:\",\"\"\n  \"pywb/templates/banner.html:11\",\"Loading...\",\"\"\n  ...\n\n\nThis CSV can then be passed to translators to translate the text.\n\n(The extraction parameters are configured to load data from ``pywb/templates/*.html`` in ``babel.ini``)\n\n\nFor example, the following will generate translation strings for ``es`` and ``pt`` locales::\n\n   wb-manager i18n extract es pt\n\n\nThe translatable text can then be found in ``i18n/translations/es/LC_MESSAGES/messages.csv`` and ``i18n/translations/pt/LC_MESSAGES/messages.csv``.\n\n\nThe CSV files should be updated with a translation for each string in the ``target`` column.\n\nThe extract command adds any new strings without overwriting existing translations, so after running the update command to compile translated strings (described below), it is safe to run the extract command again.\n\n\nUpdating Locale Catalog\n=======================\n\nOnce the text has been translated, and the CSV files updated, simply run::\n\n  wb-manager i18n update <loc>\n\nThis will parse the CSVs and compile the translated string tables for use with pywb.\n\n\nSpecifying locales in pywb\n==========================\n\nTo enable the locales in pywb, one or more locales can be added to the ``locales`` key in ``config.yaml``, ex::\n\n  locales:\n     - en\n     - es\n\nSingle Language Default Locale\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\npywb can be configured with a default, single-language locale, by setting the ``default_locale`` property in ``config.yaml``::\n\n\n  default_locale: es\n  locales:\n     - es\n\n\nWith this configuration, pywb will automatically use the ``es`` locale for all text strings in pywb pages.\n\npywb will also set the ``<html lang=\"es\">`` so that the browser will recognize the correct locale.\n\n\nMutli-language Translations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf more than one locale is specified, pywb will automatically show a language switching UI at the top of collection and search pages, with an option\nfor each locale listed. To include English as an option, it should also be added as a locale (and no strings translated). For example::\n\n  locales:\n     - en\n     - es\n     - pt\n\nwill configure pywb to show a language switch option on all pages.\n\n\nLocalized Collection Paths\n==========================\n\nWhen localization is enabled, pywb supports the locale prefix for accessing each collection with a localized language:\nIf pywb has a collection ``my-web-archive``, then:\n\n* ``/my-web-archive/`` - loads UI with default language (set via ``default_locale``)\n* ``/en/my-web-archive/`` - loads UI with ``en`` locale\n* ``/es/my-web-archive/`` - loads UI with ``es`` locale\n* ``/pt/my-web-archive/`` - loads UI with ``pt`` locale\n\nThe language switch options work by changing the locale prefix for the same page.\n\nListing and Removing Locales\n============================\n\nTo list the locales that have previously been added, you can also run ``wb-manager i18n list``.\n\nTo disable a locale from being used in pywb, simply remove it from the ``locales`` key in ``config.yaml``.\n\nTo remove data for a locale permanently, you can run: ``wb-manager i18n remove <loc>``. This will remove the locale directory on disk.\n\nTo remove all localization data, you can manually delete the ``i18n`` directory.\n\n\nUI Templates: Adding Localizable Text\n=====================================\n\nText that can be translated, localizable text, can be marked as such directly in the UI templates:\n\n1. By wrapping the text in ``{% trans %}``/``{% endtrans %}`` tags. For example::\n\n   {% trans %}Collection {{ coll }} Search Page{% endtrans %}\n\n2. Short-hand by calling a special ``_()`` function, which can be used in attributes or more dynamically. For example::\n\n   ... title=\"{{ _('Enter a URL to search for') }}\">\n\n\nThese methods can be used in all UI templates and are supported by the Jinja2 templating system.\n\nSee :ref:`ui-customizations` for a list of all available UI templates.\n\n", "patch": "@@ -9,10 +9,15 @@ pywb can extract all text from templates and generate CSV files for translation\n \n (pywb uses the `Babel library <http://babel.pocoo.org/en/latest/>`_  which extends the `standard Python i18n system <https://docs.python.org/3/library/gettext.html>`_)\n \n+To ensure all localization related dependencies are installed, first run::\n+\n+  pip install pywb[i18n]\n+\n Locales to use are configured in the ``config.yaml``.\n \n The command-line ``wb-manager`` utility provides a way to manage locales for translation, including generating extracted text, and to update translated text.\n \n+\n Adding a Locale and Extracting Text\n ===================================\n ", "file_path": "files/2021_8/291", "file_language": "rst", "file_name": "docs/manual/localization.rst", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Fmanager%2Flocmanager.py", "code": "import os\nimport os.path\nimport shutil\n\nfrom babel.messages.frontend import CommandLineInterface\n\nfrom translate.convert.po2csv import main as po2csv\nfrom translate.convert.csv2po import main as csv2po\n\n\nROOT_DIR = 'i18n'\n\nTRANSLATIONS = os.path.join(ROOT_DIR, 'translations')\n\nMESSAGES = os.path.join(ROOT_DIR, 'messages.pot')\n\n# ============================================================================\nclass LocManager:\n    def process(self, r):\n        if r.name == 'list':\n            r.loc_func(self)\n        elif r.name == 'remove':\n            r.loc_func(self, r.locale)\n        else:\n            r.loc_func(self, r.locale, r.no_csv)\n\n    def extract_loc(self, locale, no_csv):\n        self.extract_text()\n\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if os.path.isdir(loc_dir):\n                self.update_catalog(loc)\n            else:\n                os.makedirs(loc_dir)\n                self.init_catalog(loc)\n\n            if not no_csv:\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n                po2csv([po, csv])\n\n        self.compile_catalog()\n\n    def update_loc(self, locale, no_csv):\n        for loc in locale:\n            if not no_csv:\n                loc_dir = os.path.join(TRANSLATIONS, loc)\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n\n                if os.path.isfile(csv):\n                    csv2po([csv, po])\n\n        self.compile_catalog()\n\n    def remove_loc(self, locale):\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if not os.path.isdir(loc_dir):\n                print('Locale \"{0}\" does not exist'.format(loc))\n                return\n\n            shutil.rmtree(loc_dir)\n            print('Removed locale \"{0}\"'.format(loc))\n\n    def list_loc(self):\n        print('Current locales:')\n        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))\n        print('')\n\n    def extract_text(self):\n        os.makedirs(ROOT_DIR, exist_ok=True)\n\n        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])\n\n    def init_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])\n\n    def update_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])\n\n    def compile_catalog(self):\n        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])\n\n\n    @classmethod\n    def init_parser(cls, parser):\n        \"\"\"Initializes an argument parser for acl commands\n\n        :param argparse.ArgumentParser parser: The parser to be initialized\n        :rtype: None\n        \"\"\"\n        subparsers = parser.add_subparsers(dest='op')\n        subparsers.required = True\n\n        def command(name, func):\n            op = subparsers.add_parser(name)\n            if name != 'list':\n                op.add_argument('locale', nargs='+')\n                if name != 'remove':\n                    op.add_argument('--no-csv', action='store_true')\n\n            op.set_defaults(loc_func=func, name=name)\n\n        command('extract', cls.extract_loc)\n        command('update', cls.update_loc)\n        command('remove', cls.remove_loc)\n        command('list', cls.list_loc)\n", "code_before": "import os\nimport os.path\nimport shutil\n\nfrom babel.messages.frontend import CommandLineInterface\n\nfrom translate.convert.po2csv import main as po2csv\nfrom translate.convert.csv2po import main as csv2po\n\n\nROOT_DIR = 'i18n'\n\nTRANSLATIONS = os.path.join(ROOT_DIR, 'translations')\n\nMESSAGES = os.path.join(ROOT_DIR, 'messages.pot')\n\n# ============================================================================\nclass LocManager:\n    def process(self, r):\n        if r.name == 'list':\n            r.loc_func(self)\n        elif r.name == 'remove':\n            r.loc_func(self, r.locale)\n        else:\n            r.loc_func(self, r.locale, r.no_csv)\n\n    def extract_loc(self, locale, no_csv):\n        self.extract_text()\n\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if os.path.isdir(loc_dir):\n                self.update_catalog(loc)\n            else:\n                os.makedirs(loc_dir)\n                self.init_catalog(loc)\n\n            if not no_csv:\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n                po2csv([po, csv])\n\n    def update_loc(self, locale, no_csv):\n        for loc in locale:\n            if not no_csv:\n                loc_dir = os.path.join(TRANSLATIONS, loc)\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n\n                if os.path.isfile(csv):\n                    csv2po([csv, po])\n\n        self.compile_catalog()\n\n    def remove_loc(self, locale):\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if not os.path.isdir(loc_dir):\n                print('Locale \"{0}\" does not exist'.format(loc))\n                return\n\n            shutil.rmtree(loc_dir)\n            print('Removed locale \"{0}\"'.format(loc))\n\n    def list_loc(self):\n        print('Current locales:')\n        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))\n        print('')\n\n    def extract_text(self):\n        os.makedirs(ROOT_DIR, exist_ok=True)\n\n        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])\n\n    def init_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])\n\n    def update_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])\n\n    def compile_catalog(self):\n        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])\n\n\n    @classmethod\n    def init_parser(cls, parser):\n        \"\"\"Initializes an argument parser for acl commands\n\n        :param argparse.ArgumentParser parser: The parser to be initialized\n        :rtype: None\n        \"\"\"\n        subparsers = parser.add_subparsers(dest='op')\n        subparsers.required = True\n\n        def command(name, func):\n            op = subparsers.add_parser(name)\n            if name != 'list':\n                op.add_argument('locale', nargs='+')\n                if name != 'remove':\n                    op.add_argument('--no-csv', action='store_true')\n\n            op.set_defaults(loc_func=func, name=name)\n\n        command('extract', cls.extract_loc)\n        command('update', cls.update_loc)\n        command('remove', cls.remove_loc)\n        command('list', cls.list_loc)\n", "patch": "@@ -41,6 +41,8 @@ def extract_loc(self, locale, no_csv):\n                 csv = os.path.join(base, 'messages.csv')\n                 po2csv([po, csv])\n \n+        self.compile_catalog()\n+\n     def update_loc(self, locale, no_csv):\n         for loc in locale:\n             if not no_csv:", "file_path": "files/2021_8/292", "file_language": "py", "file_name": "pywb/manager/locmanager.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class LocManager:\n    def process(self, r):\n        if r.name == 'list':\n            r.loc_func(self)\n        elif r.name == 'remove':\n            r.loc_func(self, r.locale)\n        else:\n            r.loc_func(self, r.locale, r.no_csv)\n\n    def extract_loc(self, locale, no_csv):\n        self.extract_text()\n\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if os.path.isdir(loc_dir):\n                self.update_catalog(loc)\n            else:\n                os.makedirs(loc_dir)\n                self.init_catalog(loc)\n\n            if not no_csv:\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n                po2csv([po, csv])\n\n    def update_loc(self, locale, no_csv):\n        for loc in locale:\n            if not no_csv:\n                loc_dir = os.path.join(TRANSLATIONS, loc)\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n\n                if os.path.isfile(csv):\n                    csv2po([csv, po])\n\n        self.compile_catalog()\n\n    def remove_loc(self, locale):\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if not os.path.isdir(loc_dir):\n                print('Locale \"{0}\" does not exist'.format(loc))\n                return\n\n            shutil.rmtree(loc_dir)\n            print('Removed locale \"{0}\"'.format(loc))\n\n    def list_loc(self):\n        print('Current locales:')\n        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))\n        print('')\n\n    def extract_text(self):\n        os.makedirs(ROOT_DIR, exist_ok=True)\n\n        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])\n\n    def init_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])\n\n    def update_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])\n\n    def compile_catalog(self):\n        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])\n\n\n    @classmethod\n    def init_parser(cls, parser):\n        \"\"\"Initializes an argument parser for acl commands\n\n        :param argparse.ArgumentParser parser: The parser to be initialized\n        :rtype: None\n        \"\"\"\n        subparsers = parser.add_subparsers(dest='op')\n        subparsers.required = True\n\n        def command(name, func):\n            op = subparsers.add_parser(name)\n            if name != 'list':\n                op.add_argument('locale', nargs='+')\n                if name != 'remove':\n                    op.add_argument('--no-csv', action='store_true')\n\n            op.set_defaults(loc_func=func, name=name)\n\n        command('extract', cls.extract_loc)\n        command('update', cls.update_loc)\n        command('remove', cls.remove_loc)\n        command('list', cls.list_loc)", "target": 0}], "function_after": [{"function": "class LocManager:\n    def process(self, r):\n        if r.name == 'list':\n            r.loc_func(self)\n        elif r.name == 'remove':\n            r.loc_func(self, r.locale)\n        else:\n            r.loc_func(self, r.locale, r.no_csv)\n\n    def extract_loc(self, locale, no_csv):\n        self.extract_text()\n\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if os.path.isdir(loc_dir):\n                self.update_catalog(loc)\n            else:\n                os.makedirs(loc_dir)\n                self.init_catalog(loc)\n\n            if not no_csv:\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n                po2csv([po, csv])\n\n        self.compile_catalog()\n\n    def update_loc(self, locale, no_csv):\n        for loc in locale:\n            if not no_csv:\n                loc_dir = os.path.join(TRANSLATIONS, loc)\n                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')\n                po = os.path.join(base, 'messages.po')\n                csv = os.path.join(base, 'messages.csv')\n\n                if os.path.isfile(csv):\n                    csv2po([csv, po])\n\n        self.compile_catalog()\n\n    def remove_loc(self, locale):\n        for loc in locale:\n            loc_dir = os.path.join(TRANSLATIONS, loc)\n            if not os.path.isdir(loc_dir):\n                print('Locale \"{0}\" does not exist'.format(loc))\n                return\n\n            shutil.rmtree(loc_dir)\n            print('Removed locale \"{0}\"'.format(loc))\n\n    def list_loc(self):\n        print('Current locales:')\n        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))\n        print('')\n\n    def extract_text(self):\n        os.makedirs(ROOT_DIR, exist_ok=True)\n\n        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])\n\n    def init_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])\n\n    def update_catalog(self, loc):\n        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])\n\n    def compile_catalog(self):\n        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])\n\n\n    @classmethod\n    def init_parser(cls, parser):\n        \"\"\"Initializes an argument parser for acl commands\n\n        :param argparse.ArgumentParser parser: The parser to be initialized\n        :rtype: None\n        \"\"\"\n        subparsers = parser.add_subparsers(dest='op')\n        subparsers.required = True\n\n        def command(name, func):\n            op = subparsers.add_parser(name)\n            if name != 'list':\n                op.add_argument('locale', nargs='+')\n                if name != 'remove':\n                    op.add_argument('--no-csv', action='store_true')\n\n            op.set_defaults(loc_func=func, name=name)\n\n        command('extract', cls.extract_loc)\n        command('update', cls.update_loc)\n        command('remove', cls.remove_loc)\n        command('list', cls.list_loc)", "target": 0}]}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Frewrite%2Ftemplateview.py", "code": "from warcio.timeutils import timestamp_to_datetime, timestamp_to_sec\nfrom warcio.timeutils import timestamp_now\n\nfrom pywb.utils.loaders import load\n\nfrom six.moves.urllib.parse import urlsplit, quote\n\nfrom jinja2 import Environment, TemplateNotFound, contextfunction, select_autoescape\nfrom jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader\n\nfrom babel.support import Translations\n\nfrom webassets.ext.jinja2 import AssetsExtension\nfrom webassets.loaders import YAMLLoader\nfrom webassets.env import Resolver\n\nfrom pkg_resources import resource_filename\n\nimport os\n\ntry:\n    import ujson as json\nexcept ImportError:  # pragma: no cover\n    import json\n\n\n# ============================================================================\nclass RelEnvironment(Environment):\n    \"\"\"Override join_path() to enable relative template paths.\"\"\"\n    def join_path(self, template, parent):\n        return os.path.join(os.path.dirname(parent), template)\n\n\n# ============================================================================\nclass JinjaEnv(object):\n    \"\"\"Pywb JinjaEnv class that provides utility functions used by the templates,\n    configured template loaders and template paths, and contains the actual Jinja\n    env used by each template.\"\"\"\n\n    def __init__(self, paths=None,\n                 packages=None,\n                 assets_path=None,\n                 globals=None,\n                 overlay=None,\n                 extensions=None,\n                 env_template_params_key='pywb.template_params',\n                 env_template_dir_key='pywb.templates_dir'):\n        \"\"\"Construct a new JinjaEnv.\n\n        :param list[str] paths: List of paths to search for templates\n        :param list[str] packages: List of assets package names\n        :param str assets_path: Path to a yaml file containing assets\n        :param dict[str, str] globals: Dictionary of additional globals available during template rendering\n        :param overlay:\n        :param list extensions: List of webassets extension classes\n        :param str env_template_params_key: The full pywb package key for the template params\n        :param str env_template_dir_key: The full pywb package key for the template directory\n        \"\"\"\n\n        if paths is None:\n            paths = ['templates', '.', '/']\n\n        if packages is None:\n            packages = ['pywb']\n\n        self._init_filters()\n\n        loader = ChoiceLoader(self._make_loaders(paths, packages))\n\n        self.env_template_params_key = env_template_params_key\n        self.env_template_dir_key = env_template_dir_key\n\n        extensions = extensions or []\n\n        if assets_path:\n            extensions.append(AssetsExtension)\n\n        if overlay:\n            jinja_env = overlay.jinja_env.overlay(loader=loader,\n                                                  autoescape=select_autoescape(),\n                                                  trim_blocks=True,\n                                                  extensions=extensions)\n        else:\n            jinja_env = RelEnvironment(loader=loader,\n                                       autoescape=select_autoescape(),\n                                       trim_blocks=True,\n                                       extensions=extensions)\n\n        jinja_env.filters.update(self.filters)\n\n        if globals:\n            jinja_env.globals.update(globals)\n\n        self.jinja_env = jinja_env\n\n        # init assets\n        if assets_path:\n            assets_loader = YAMLLoader(load(assets_path))\n            assets_env = assets_loader.load_environment()\n            assets_env.resolver = PkgResResolver()\n            jinja_env.assets_environment = assets_env\n\n        self.default_locale = ''\n\n    def _make_loaders(self, paths, packages):\n        \"\"\"Initialize the template loaders based on the supplied paths and packages.\n\n        :param list[str] paths: List of paths to search for templates\n        :param list[str] packages: List of assets package names\n        :return: A list of loaders to be used for loading the template assets\n        :rtype: list[FileSystemLoader|PackageLoader]\n        \"\"\"\n        loaders = []\n        # add loaders for paths\n        for path in paths:\n            loaders.append(FileSystemLoader(path))\n\n        # add loaders for all specified packages\n        for package in packages:\n            loaders.append(PackageLoader(package))\n\n        return loaders\n\n    def init_loc(self, locales_root_dir, locales, loc_map, default_locale):\n        locales = locales or []\n        locales_root_dir = locales_root_dir or os.path.join('i18n', 'translations')\n        default_locale = default_locale or 'en'\n        self.default_locale = default_locale\n\n        if locales_root_dir:\n            for loc in locales:\n                loc_map[loc] = Translations.load(locales_root_dir, [loc, default_locale])\n                #jinja_env.jinja_env.install_gettext_translations(translations)\n\n        def get_translate(context):\n            loc = context.get('env', {}).get('pywb_lang', default_locale)\n            return loc_map.get(loc)\n\n        def override_func(jinja_env, name):\n            @contextfunction\n            def get_override(context, text):\n                translate = get_translate(context)\n                if not translate:\n                    return text\n\n                func = getattr(translate, name)\n                return func(text)\n\n            jinja_env.globals[name] = get_override\n\n        # standard gettext() translation function\n        override_func(self.jinja_env, 'gettext')\n\n        # single/plural form translation function\n        override_func(self.jinja_env, 'ngettext')\n\n        # Special _Q() function to return %-encoded text, necessary for use\n        # with text in banner\n        @contextfunction\n        def quote_gettext(context, text):\n            translate = get_translate(context)\n            if not translate:\n                return text\n\n            text = translate.gettext(text)\n            return quote(text, safe='/: ')\n\n        self.jinja_env.globals['locales'] = list(loc_map.keys())\n        self.jinja_env.globals['_Q'] = quote_gettext\n        self.jinja_env.globals['default_locale'] = default_locale\n\n        @contextfunction\n        def switch_locale(context, locale):\n            environ = context.get('env')\n            curr_loc = environ.get('pywb_lang', '')\n\n            request_uri = environ.get('REQUEST_URI', environ.get('PATH_INFO'))\n\n            if curr_loc:\n                return request_uri.replace(curr_loc, locale, 1)\n\n            app_prefix = environ.get('pywb.app_prefix', '')\n\n            if app_prefix and request_uri.startswith(app_prefix):\n                request_uri = request_uri.replace(app_prefix, '')\n\n            return app_prefix + '/' + locale + request_uri\n\n        @contextfunction\n        def get_locale_prefixes(context):\n            environ = context.get('env')\n            locale_prefixes = {}\n\n            orig_prefix = environ.get('pywb.app_prefix', '')\n            coll = environ.get('SCRIPT_NAME', '')\n\n            if orig_prefix:\n                coll = coll[len(orig_prefix):]\n\n            curr_loc = environ.get('pywb_lang', '')\n            if curr_loc:\n                coll = coll[len(curr_loc) + 1:]\n\n            for locale in loc_map.keys():\n                locale_prefixes[locale] = orig_prefix + '/' + locale + coll + '/'\n\n            return locale_prefixes\n\n        self.jinja_env.globals['switch_locale'] = switch_locale\n        self.jinja_env.globals['get_locale_prefixes'] = get_locale_prefixes\n\n    def template_filter(self, param=None):\n        \"\"\"Returns a decorator that adds the wrapped function to dictionary of template filters.\n\n        The wrapped function is keyed by either the supplied param (if supplied)\n        or by the wrapped functions name.\n\n        :param param: Optional name to use instead of the name of the function to be wrapped\n        :return: A decorator to wrap a template filter function\n        :rtype: callable\n        \"\"\"\n        def deco(func):\n            name = param or func.__name__\n            self.filters[name] = func\n            return func\n\n        return deco\n\n    def _init_filters(self):\n        \"\"\"Initialize the default pywb provided Jninja filters available during template rendering\"\"\"\n        self.filters = {}\n\n        @self.template_filter()\n        def format_ts(value, format_='%a, %b %d %Y %H:%M:%S'):\n            \"\"\"Formats the supplied timestamp using format_\n\n            :param str value: The timestamp to be formatted\n            :param str format_:  The format string\n            :return: The correctly formatted timestamp as determined by format_\n            :rtype: str\n            \"\"\"\n            if format_ == '%s':\n                return timestamp_to_sec(value)\n            else:\n                value = timestamp_to_datetime(value)\n                return value.strftime(format_)\n\n        @self.template_filter('urlsplit')\n        def get_urlsplit(url):\n            \"\"\"Splits the supplied URL\n\n            :param str url: The url to be split\n            :return: The split url\n            :rtype: urllib.parse.SplitResult\n            \"\"\"\n            split = urlsplit(url)\n            return split\n\n        @self.template_filter()\n        def tojson(obj):\n            \"\"\"Converts the supplied object/array/any to a JSON string if it can be JSONified\n\n            :param any obj: The value to be converted to a JSON string\n            :return: The JSON string representation of the supplied value\n            :rtype: str\n            \"\"\"\n            return json.dumps(obj)\n\n        @self.template_filter()\n        def tobool(bool_val):\n            \"\"\"Converts a python boolean to a JS \"true\" or \"false\" string\n            :param any obj: A value to be evaluated as a boolean\n            :return: The string \"true\" or \"false\" to be inserted into JS\n            \"\"\"\n\n            return 'true' if bool_val else 'false'\n\n\n# ============================================================================\nclass BaseInsertView(object):\n    \"\"\"Base class of all template views used by Pywb\"\"\"\n\n    def __init__(self, jenv, insert_file, banner_view=None):\n        \"\"\"Create a new BaseInsertView.\n\n        :param JinjaEnv jenv: The instance of pywb.rewrite.templateview.JinjaEnv to be used\n        :param str insert_file: The name of the template file\n        :param BaseInsertView banner_view: The banner_view property of pywb.apps.RewriterApp\n        \"\"\"\n        self.jenv = jenv\n        self.insert_file = insert_file\n        self.banner_view = banner_view\n\n    def render_to_string(self, env, **kwargs):\n        \"\"\"Render this template.\n\n        :param dict env: The WSGI environment associated with the request causing this template to be rendered\n        :param any kwargs: The keyword arguments to be supplied to the Jninja template render method\n        :return: The rendered template\n        :rtype: str\n        \"\"\"\n        template = None\n        template_path = env.get(self.jenv.env_template_dir_key)\n\n        if template_path:\n            # jinja paths are not os paths, always use '/' as separator\n            # https://github.com/pallets/jinja/issues/411\n            template_path = template_path + '/' + self.insert_file\n\n            try:\n                template = self.jenv.jinja_env.get_template(template_path)\n            except TemplateNotFound as te:\n                pass\n\n        if not template:\n            template = self.jenv.jinja_env.get_template(self.insert_file)\n\n        params = env.get(self.jenv.env_template_params_key)\n        if params:\n            kwargs.update(params)\n\n        kwargs['env'] = env\n        kwargs['static_prefix'] = env.get('pywb.host_prefix', '') + env.get('pywb.app_prefix', '') + '/static'\n\n\n        return template.render(**kwargs)\n\n\n# ============================================================================\nclass HeadInsertView(BaseInsertView):\n    \"\"\"The template view class associated with rendering the HTML inserted\n    into the head of the pages replayed (WB Insert).\"\"\"\n\n    def create_insert_func(self, wb_url,\n                           wb_prefix,\n                           host_prefix,\n                           top_url,\n                           env,\n                           is_framed,\n                           coll='',\n                           include_ts=True,\n                           **kwargs):\n        \"\"\"Create the function used to render the header insert template for the current request.\n\n        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for\n        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)\n        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)\n        :param str top_url: The full URL for this request (e.g. http://localhost:8080/live/http://example.com)\n        :param dict env: The WSGI environment dictionary for this request\n        :param bool is_framed: Is pywb or a specific collection running in framed mode\n        :param str coll: The name of the collection this request is associated with\n        :param bool include_ts: Should a timestamp be included in the rendered template\n        :param kwargs: Additional keyword arguments to be supplied to the Jninja template render method\n        :return: A function to be used to render the header insert for the request this template is being rendered for\n        :rtype: callable\n        \"\"\"\n        params = kwargs\n        params['host_prefix'] = host_prefix\n        params['wb_prefix'] = wb_prefix\n        params['wb_url'] = wb_url\n        params['top_url'] = top_url\n        params['coll'] = coll\n        params['is_framed'] = is_framed\n\n        def make_head_insert(rule, cdx):\n            params['wombat_ts'] = cdx['timestamp'] if include_ts else ''\n            params['wombat_sec'] = timestamp_to_sec(cdx['timestamp'])\n            params['is_live'] = cdx.get('is_live')\n\n            if self.banner_view:\n                banner_html = self.banner_view.render_to_string(env, cdx=cdx, **params)\n                params['banner_html'] = banner_html\n\n            return self.render_to_string(env, cdx=cdx, **params)\n\n        return make_head_insert\n\n\n# ============================================================================\nclass TopFrameView(BaseInsertView):\n    \"\"\"The template view class associated with rendering the replay iframe\"\"\"\n\n    def get_top_frame(self, wb_url,\n                      wb_prefix,\n                      host_prefix,\n                      env,\n                      frame_mod,\n                      replay_mod,\n                      coll='',\n                      extra_params=None):\n        \"\"\"\n        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for\n        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)\n        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)\n        :param dict env: The WSGI environment dictionary for the request this template is being rendered for\n        :param str frame_mod:  The modifier to be used for framing (e.g. if_)\n        :param str replay_mod: The modifier to be used in the URL of the page being replayed (e.g. mp_)\n        :param str coll: The name of the collection this template is being rendered for\n        :param dict extra_params: Additional parameters to be supplied to the Jninja template render method\n        :return: The frame insert string\n        :rtype: str\n        \"\"\"\n\n        embed_url = wb_url.to_str(mod=replay_mod)\n\n        if wb_url.timestamp:\n            timestamp = wb_url.timestamp\n        else:\n            timestamp = timestamp_now()\n\n        is_proxy = 'wsgiprox.proxy_host' in env\n\n        params = {'host_prefix': host_prefix,\n                  'wb_prefix': wb_prefix,\n                  'wb_url': wb_url,\n                  'coll': coll,\n\n                  'options': {'frame_mod': frame_mod,\n                              'replay_mod': replay_mod},\n\n                  'embed_url': embed_url,\n                  'is_proxy': is_proxy,\n                  'timestamp': timestamp,\n                  'url': wb_url.get_url()\n                 }\n\n        if extra_params:\n            params.update(extra_params)\n\n        if self.banner_view:\n            banner_html = self.banner_view.render_to_string(env, **params)\n            params['banner_html'] = banner_html\n\n        return self.render_to_string(env, **params)\n\n\n# ============================================================================\nclass PkgResResolver(Resolver):\n    \"\"\"Class for resolving pywb package resources when install via pypi or setup.py\"\"\"\n\n    def get_pkg_path(self, item):\n        \"\"\"Get the package path for the\n\n        :param str item: A resources full package path\n        :return: The netloc and path from the items package path\n        :rtype: tuple[str, str]\n        \"\"\"\n        if not isinstance(item, str):\n            return None\n\n        parts = urlsplit(item)\n        if parts.scheme == 'pkg' and parts.netloc:\n            return (parts.netloc, parts.path)\n\n        return None\n\n    def resolve_source(self, ctx, item):\n        pkg = self.get_pkg_path(item)\n        if pkg:\n            filename = resource_filename(pkg[0], pkg[1])\n            if filename:\n                return filename\n\n        return super(PkgResResolver, self).resolve_source(ctx, item)\n\n\n", "code_before": "from warcio.timeutils import timestamp_to_datetime, timestamp_to_sec\nfrom warcio.timeutils import timestamp_now\n\nfrom pywb.utils.loaders import load\n\nfrom six.moves.urllib.parse import urlsplit, quote\n\nfrom jinja2 import Environment, TemplateNotFound, contextfunction\nfrom jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader\n\nfrom babel.support import Translations\n\nfrom webassets.ext.jinja2 import AssetsExtension\nfrom webassets.loaders import YAMLLoader\nfrom webassets.env import Resolver\n\nfrom pkg_resources import resource_filename\n\nimport os\n\ntry:\n    import ujson as json\nexcept ImportError:  # pragma: no cover\n    import json\n\n\n# ============================================================================\nclass RelEnvironment(Environment):\n    \"\"\"Override join_path() to enable relative template paths.\"\"\"\n    def join_path(self, template, parent):\n        return os.path.join(os.path.dirname(parent), template)\n\n\n# ============================================================================\nclass JinjaEnv(object):\n    \"\"\"Pywb JinjaEnv class that provides utility functions used by the templates,\n    configured template loaders and template paths, and contains the actual Jinja\n    env used by each template.\"\"\"\n\n    def __init__(self, paths=None,\n                 packages=None,\n                 assets_path=None,\n                 globals=None,\n                 overlay=None,\n                 extensions=None,\n                 env_template_params_key='pywb.template_params',\n                 env_template_dir_key='pywb.templates_dir'):\n        \"\"\"Construct a new JinjaEnv.\n\n        :param list[str] paths: List of paths to search for templates\n        :param list[str] packages: List of assets package names\n        :param str assets_path: Path to a yaml file containing assets\n        :param dict[str, str] globals: Dictionary of additional globals available during template rendering\n        :param overlay:\n        :param list extensions: List of webassets extension classes\n        :param str env_template_params_key: The full pywb package key for the template params\n        :param str env_template_dir_key: The full pywb package key for the template directory\n        \"\"\"\n\n        if paths is None:\n            paths = ['templates', '.', '/']\n\n        if packages is None:\n            packages = ['pywb']\n\n        self._init_filters()\n\n        loader = ChoiceLoader(self._make_loaders(paths, packages))\n\n        self.env_template_params_key = env_template_params_key\n        self.env_template_dir_key = env_template_dir_key\n\n        extensions = extensions or []\n\n        if assets_path:\n            extensions.append(AssetsExtension)\n\n        if overlay:\n            jinja_env = overlay.jinja_env.overlay(loader=loader,\n                                                  trim_blocks=True,\n                                                  extensions=extensions)\n        else:\n            jinja_env = RelEnvironment(loader=loader,\n                                       trim_blocks=True,\n                                       extensions=extensions)\n\n        jinja_env.filters.update(self.filters)\n\n        if globals:\n            jinja_env.globals.update(globals)\n\n        self.jinja_env = jinja_env\n\n        # init assets\n        if assets_path:\n            assets_loader = YAMLLoader(load(assets_path))\n            assets_env = assets_loader.load_environment()\n            assets_env.resolver = PkgResResolver()\n            jinja_env.assets_environment = assets_env\n\n        self.default_locale = ''\n\n    def _make_loaders(self, paths, packages):\n        \"\"\"Initialize the template loaders based on the supplied paths and packages.\n\n        :param list[str] paths: List of paths to search for templates\n        :param list[str] packages: List of assets package names\n        :return: A list of loaders to be used for loading the template assets\n        :rtype: list[FileSystemLoader|PackageLoader]\n        \"\"\"\n        loaders = []\n        # add loaders for paths\n        for path in paths:\n            loaders.append(FileSystemLoader(path))\n\n        # add loaders for all specified packages\n        for package in packages:\n            loaders.append(PackageLoader(package))\n\n        return loaders\n\n    def init_loc(self, locales_root_dir, locales, loc_map, default_locale):\n        locales = locales or []\n        locales_root_dir = locales_root_dir or os.path.join('i18n', 'translations')\n        default_locale = default_locale or 'en'\n        self.default_locale = default_locale\n\n        if locales_root_dir:\n            for loc in locales:\n                loc_map[loc] = Translations.load(locales_root_dir, [loc, default_locale])\n                #jinja_env.jinja_env.install_gettext_translations(translations)\n\n        def get_translate(context):\n            loc = context.get('env', {}).get('pywb_lang', default_locale)\n            return loc_map.get(loc)\n\n        def override_func(jinja_env, name):\n            @contextfunction\n            def get_override(context, text):\n                translate = get_translate(context)\n                if not translate:\n                    return text\n\n                func = getattr(translate, name)\n                return func(text)\n\n            jinja_env.globals[name] = get_override\n\n        # standard gettext() translation function\n        override_func(self.jinja_env, 'gettext')\n\n        # single/plural form translation function\n        override_func(self.jinja_env, 'ngettext')\n\n        # Special _Q() function to return %-encoded text, necessary for use\n        # with text in banner\n        @contextfunction\n        def quote_gettext(context, text):\n            translate = get_translate(context)\n            if not translate:\n                return text\n\n            text = translate.gettext(text)\n            return quote(text, safe='/: ')\n\n        self.jinja_env.globals['locales'] = list(loc_map.keys())\n        self.jinja_env.globals['_Q'] = quote_gettext\n        self.jinja_env.globals['default_locale'] = default_locale\n\n        @contextfunction\n        def switch_locale(context, locale):\n            environ = context.get('env')\n            curr_loc = environ.get('pywb_lang', '')\n\n            request_uri = environ.get('REQUEST_URI', environ.get('PATH_INFO'))\n\n            if curr_loc:\n                return request_uri.replace(curr_loc, locale, 1)\n\n            app_prefix = environ.get('pywb.app_prefix', '')\n\n            if app_prefix and request_uri.startswith(app_prefix):\n                request_uri = request_uri.replace(app_prefix, '')\n\n            return app_prefix + '/' + locale + request_uri\n\n        @contextfunction\n        def get_locale_prefixes(context):\n            environ = context.get('env')\n            locale_prefixes = {}\n\n            orig_prefix = environ.get('pywb.app_prefix', '')\n            coll = environ.get('SCRIPT_NAME', '')\n\n            if orig_prefix:\n                coll = coll[len(orig_prefix):]\n\n            curr_loc = environ.get('pywb_lang', '')\n            if curr_loc:\n                coll = coll[len(curr_loc) + 1:]\n\n            for locale in loc_map.keys():\n                locale_prefixes[locale] = orig_prefix + '/' + locale + coll + '/'\n\n            return locale_prefixes\n\n        self.jinja_env.globals['switch_locale'] = switch_locale\n        self.jinja_env.globals['get_locale_prefixes'] = get_locale_prefixes\n\n    def template_filter(self, param=None):\n        \"\"\"Returns a decorator that adds the wrapped function to dictionary of template filters.\n\n        The wrapped function is keyed by either the supplied param (if supplied)\n        or by the wrapped functions name.\n\n        :param param: Optional name to use instead of the name of the function to be wrapped\n        :return: A decorator to wrap a template filter function\n        :rtype: callable\n        \"\"\"\n        def deco(func):\n            name = param or func.__name__\n            self.filters[name] = func\n            return func\n\n        return deco\n\n    def _init_filters(self):\n        \"\"\"Initialize the default pywb provided Jninja filters available during template rendering\"\"\"\n        self.filters = {}\n\n        @self.template_filter()\n        def format_ts(value, format_='%a, %b %d %Y %H:%M:%S'):\n            \"\"\"Formats the supplied timestamp using format_\n\n            :param str value: The timestamp to be formatted\n            :param str format_:  The format string\n            :return: The correctly formatted timestamp as determined by format_\n            :rtype: str\n            \"\"\"\n            if format_ == '%s':\n                return timestamp_to_sec(value)\n            else:\n                value = timestamp_to_datetime(value)\n                return value.strftime(format_)\n\n        @self.template_filter('urlsplit')\n        def get_urlsplit(url):\n            \"\"\"Splits the supplied URL\n\n            :param str url: The url to be split\n            :return: The split url\n            :rtype: urllib.parse.SplitResult\n            \"\"\"\n            split = urlsplit(url)\n            return split\n\n        @self.template_filter()\n        def tojson(obj):\n            \"\"\"Converts the supplied object/array/any to a JSON string if it can be JSONified\n\n            :param any obj: The value to be converted to a JSON string\n            :return: The JSON string representation of the supplied value\n            :rtype: str\n            \"\"\"\n            return json.dumps(obj)\n\n        @self.template_filter()\n        def tobool(bool_val):\n            \"\"\"Converts a python boolean to a JS \"true\" or \"false\" string\n            :param any obj: A value to be evaluated as a boolean\n            :return: The string \"true\" or \"false\" to be inserted into JS\n            \"\"\"\n\n            return 'true' if bool_val else 'false'\n\n\n# ============================================================================\nclass BaseInsertView(object):\n    \"\"\"Base class of all template views used by Pywb\"\"\"\n\n    def __init__(self, jenv, insert_file, banner_view=None):\n        \"\"\"Create a new BaseInsertView.\n\n        :param JinjaEnv jenv: The instance of pywb.rewrite.templateview.JinjaEnv to be used\n        :param str insert_file: The name of the template file\n        :param BaseInsertView banner_view: The banner_view property of pywb.apps.RewriterApp\n        \"\"\"\n        self.jenv = jenv\n        self.insert_file = insert_file\n        self.banner_view = banner_view\n\n    def render_to_string(self, env, **kwargs):\n        \"\"\"Render this template.\n\n        :param dict env: The WSGI environment associated with the request causing this template to be rendered\n        :param any kwargs: The keyword arguments to be supplied to the Jninja template render method\n        :return: The rendered template\n        :rtype: str\n        \"\"\"\n        template = None\n        template_path = env.get(self.jenv.env_template_dir_key)\n\n        if template_path:\n            # jinja paths are not os paths, always use '/' as separator\n            # https://github.com/pallets/jinja/issues/411\n            template_path = template_path + '/' + self.insert_file\n\n            try:\n                template = self.jenv.jinja_env.get_template(template_path)\n            except TemplateNotFound as te:\n                pass\n\n        if not template:\n            template = self.jenv.jinja_env.get_template(self.insert_file)\n\n        params = env.get(self.jenv.env_template_params_key)\n        if params:\n            kwargs.update(params)\n\n        kwargs['env'] = env\n        kwargs['static_prefix'] = env.get('pywb.host_prefix', '') + env.get('pywb.app_prefix', '') + '/static'\n\n\n        return template.render(**kwargs)\n\n\n# ============================================================================\nclass HeadInsertView(BaseInsertView):\n    \"\"\"The template view class associated with rendering the HTML inserted\n    into the head of the pages replayed (WB Insert).\"\"\"\n\n    def create_insert_func(self, wb_url,\n                           wb_prefix,\n                           host_prefix,\n                           top_url,\n                           env,\n                           is_framed,\n                           coll='',\n                           include_ts=True,\n                           **kwargs):\n        \"\"\"Create the function used to render the header insert template for the current request.\n\n        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for\n        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)\n        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)\n        :param str top_url: The full URL for this request (e.g. http://localhost:8080/live/http://example.com)\n        :param dict env: The WSGI environment dictionary for this request\n        :param bool is_framed: Is pywb or a specific collection running in framed mode\n        :param str coll: The name of the collection this request is associated with\n        :param bool include_ts: Should a timestamp be included in the rendered template\n        :param kwargs: Additional keyword arguments to be supplied to the Jninja template render method\n        :return: A function to be used to render the header insert for the request this template is being rendered for\n        :rtype: callable\n        \"\"\"\n        params = kwargs\n        params['host_prefix'] = host_prefix\n        params['wb_prefix'] = wb_prefix\n        params['wb_url'] = wb_url\n        params['top_url'] = top_url\n        params['coll'] = coll\n        params['is_framed'] = is_framed\n\n        def make_head_insert(rule, cdx):\n            params['wombat_ts'] = cdx['timestamp'] if include_ts else ''\n            params['wombat_sec'] = timestamp_to_sec(cdx['timestamp'])\n            params['is_live'] = cdx.get('is_live')\n\n            if self.banner_view:\n                banner_html = self.banner_view.render_to_string(env, cdx=cdx, **params)\n                params['banner_html'] = banner_html\n\n            return self.render_to_string(env, cdx=cdx, **params)\n\n        return make_head_insert\n\n\n# ============================================================================\nclass TopFrameView(BaseInsertView):\n    \"\"\"The template view class associated with rendering the replay iframe\"\"\"\n\n    def get_top_frame(self, wb_url,\n                      wb_prefix,\n                      host_prefix,\n                      env,\n                      frame_mod,\n                      replay_mod,\n                      coll='',\n                      extra_params=None):\n        \"\"\"\n        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for\n        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)\n        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)\n        :param dict env: The WSGI environment dictionary for the request this template is being rendered for\n        :param str frame_mod:  The modifier to be used for framing (e.g. if_)\n        :param str replay_mod: The modifier to be used in the URL of the page being replayed (e.g. mp_)\n        :param str coll: The name of the collection this template is being rendered for\n        :param dict extra_params: Additional parameters to be supplied to the Jninja template render method\n        :return: The frame insert string\n        :rtype: str\n        \"\"\"\n\n        embed_url = wb_url.to_str(mod=replay_mod)\n\n        if wb_url.timestamp:\n            timestamp = wb_url.timestamp\n        else:\n            timestamp = timestamp_now()\n\n        is_proxy = 'wsgiprox.proxy_host' in env\n\n        params = {'host_prefix': host_prefix,\n                  'wb_prefix': wb_prefix,\n                  'wb_url': wb_url,\n                  'coll': coll,\n\n                  'options': {'frame_mod': frame_mod,\n                              'replay_mod': replay_mod},\n\n                  'embed_url': embed_url,\n                  'is_proxy': is_proxy,\n                  'timestamp': timestamp,\n                  'url': wb_url.get_url()\n                 }\n\n        if extra_params:\n            params.update(extra_params)\n\n        if self.banner_view:\n            banner_html = self.banner_view.render_to_string(env, **params)\n            params['banner_html'] = banner_html\n\n        return self.render_to_string(env, **params)\n\n\n# ============================================================================\nclass PkgResResolver(Resolver):\n    \"\"\"Class for resolving pywb package resources when install via pypi or setup.py\"\"\"\n\n    def get_pkg_path(self, item):\n        \"\"\"Get the package path for the\n\n        :param str item: A resources full package path\n        :return: The netloc and path from the items package path\n        :rtype: tuple[str, str]\n        \"\"\"\n        if not isinstance(item, str):\n            return None\n\n        parts = urlsplit(item)\n        if parts.scheme == 'pkg' and parts.netloc:\n            return (parts.netloc, parts.path)\n\n        return None\n\n    def resolve_source(self, ctx, item):\n        pkg = self.get_pkg_path(item)\n        if pkg:\n            filename = resource_filename(pkg[0], pkg[1])\n            if filename:\n                return filename\n\n        return super(PkgResResolver, self).resolve_source(ctx, item)\n\n\n", "patch": "@@ -5,7 +5,7 @@\n \n from six.moves.urllib.parse import urlsplit, quote\n \n-from jinja2 import Environment, TemplateNotFound, contextfunction\n+from jinja2 import Environment, TemplateNotFound, contextfunction, select_autoescape\n from jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader\n \n from babel.support import Translations\n@@ -77,10 +77,12 @@ def __init__(self, paths=None,\n \n         if overlay:\n             jinja_env = overlay.jinja_env.overlay(loader=loader,\n+                                                  autoescape=select_autoescape(),\n                                                   trim_blocks=True,\n                                                   extensions=extensions)\n         else:\n             jinja_env = RelEnvironment(loader=loader,\n+                                       autoescape=select_autoescape(),\n                                        trim_blocks=True,\n                                        extensions=extensions)\n ", "file_path": "files/2021_8/293", "file_language": "py", "file_name": "pywb/rewrite/templateview.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Fbase.html", "code": "<!DOCTYPE html>\n<html lang=\"{{ env.pywb_lang | default(default_locale) }}\">\n    <head>\n        <meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8;charset=utf-8\"/>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{% block title %}{% endblock %}</title>\n\n        <!-- jquery and bootstrap dependencies query view -->\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/bootstrap.min.css\"/>\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/font-awesome.min.css\">\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/base.css\">\n\n        <script src=\"{{ static_prefix }}/js/jquery-latest.min.js\"></script>\n        <script src=\"{{ static_prefix }}/js/bootstrap.min.js\"></script>\n\n        {% block head %}\n        {% include 'head.html' ignore missing %}\n        {% endblock %}\n    </head>\n\n    <body>\n        {% block header %}\n        {% include 'header.html' ignore missing %}\n        {% endblock %}\n\n        <section>\n        {% block body %}\n        {% endblock %}\n        </section>\n\n        {% block footer %}\n        {% include 'footer.html' ignore missing %}\n        {% endblock footer %}\n    </body>\n</html>\n", "code_before": "<!DOCTYPE html>\n<html lang=\"{{ env.pywb_lang | default('en') }}\">\n    <head>\n        <meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8;charset=utf-8\"/>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{% block title %}{% endblock %}</title>\n\n        <!-- jquery and bootstrap dependencies query view -->\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/bootstrap.min.css\"/>\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/font-awesome.min.css\">\n        <link rel=\"stylesheet\" href=\"{{ static_prefix }}/css/base.css\">\n\n        <script src=\"{{ static_prefix }}/js/jquery-latest.min.js\"></script>\n        <script src=\"{{ static_prefix }}/js/bootstrap.min.js\"></script>\n\n        {% block head %}\n        {% include 'head.html' ignore missing %}\n        {% endblock %}\n    </head>\n\n    <body>\n        {% block header %}\n        {% include 'header.html' ignore missing %}\n        {% endblock %}\n\n        <section>\n        {% block body %}\n        {% endblock %}\n        </section>\n\n        {% block footer %}\n        {% include 'footer.html' ignore missing %}\n        {% endblock footer %}\n    </body>\n</html>\n", "patch": "@@ -1,5 +1,5 @@\n <!DOCTYPE html>\n-<html lang=\"{{ env.pywb_lang | default('en') }}\">\n+<html lang=\"{{ env.pywb_lang | default(default_locale) }}\">\n     <head>\n         <meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8;charset=utf-8\"/>\n         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">", "file_path": "files/2021_8/294", "file_language": "html", "file_name": "pywb/templates/base.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Ferror.html", "code": "{% extends \"base.html\" %}\n{% block title %}{{ _('Pywb Error') }}{% endblock %}\n{% block body %}\n<div class=\"container text-danger\">\n    <div class=\"row justify-content-center\">\n        <h2 class=\"display-2\">Pywb Error</h2>\n    </div>\n    <div class=\"row\">\n        <div class=\"col-12 text-center\">\n        {% if err_status == 451 %}\n            <p class=\"lead\">{% trans %}Access Blocked to {{ err_msg }}{% endtrans %}</p>\n\n        {% elif err_status == 404 and err_details == 'coll_not_found' %}\n            <p>{% trans %}Collection not found: <b>{{ err_msg }}{% endtrans %}</b></p>\n\n            <p><a href=\"/{{ env.pywb_lang | default('') }}\">{{ _('See list of valid collections') }}</a></p>\n\n        {% elif err_status == 404 and err_details == 'static_file_not_found' %}\n            <p>{% trans %}Static file not found: <b>{{ err_msg }}{% endtrans %}</b></p>\n\n        {% else %}\n\n            <p class=\"lead\">{{ err_msg }}</p>\n\n            {% if err_details %}\n                <p class=\"lead\">{% trans %}Error Details:{% endtrans %}</p>\n                <pre>{{ err_details }}</pre>\n            {% endif %}\n        {% endif %}\n        </div>\n    </div>\n</div>\n{% endblock %}\n", "code_before": "{% extends \"base.html\" %}\n{% block title %}{{ _('Pywb Error') }}{% endblock %}\n{% block body %}\n<div class=\"container text-danger\">\n    <div class=\"row justify-content-center\">\n        <h2 class=\"display-2\">Pywb Error</h2>\n    </div>\n    <div class=\"row\">\n        <div class=\"col-12 text-center\">\n        {% if err_status == 451 %}\n            <p class=\"lead\">{% trans %}Access Blocked to {{ err_msg }}{% endtrans %}</p>\n\n        {% elif err_status == 404 and err_details == 'coll_not_found' %}\n            <p>{% trans %}Collection not found: <b>{{ err_msg }}{% endtrans %}</b></p>\n\n            <p><a href=\"/\">{{ _('See list of valid collections') }}</a></p>\n\n        {% elif err_status == 404 and err_details == 'static_file_not_found' %}\n            <p>{% trans %}Static file not found: <b>{{ err_msg }}{% endtrans %}</b></p>\n\n        {% else %}\n\n            <p class=\"lead\">{{ err_msg }}</p>\n\n            {% if err_details %}\n                <p class=\"lead\">{% trans %}Error Details:{% endtrans %}</p>\n                <pre>{{ err_details }}</pre>\n            {% endif %}\n        {% endif %}\n        </div>\n    </div>\n</div>\n{% endblock %}\n", "patch": "@@ -13,7 +13,7 @@ <h2 class=\"display-2\">Pywb Error</h2>\n         {% elif err_status == 404 and err_details == 'coll_not_found' %}\n             <p>{% trans %}Collection not found: <b>{{ err_msg }}{% endtrans %}</b></p>\n \n-            <p><a href=\"/\">{{ _('See list of valid collections') }}</a></p>\n+            <p><a href=\"/{{ env.pywb_lang | default('') }}\">{{ _('See list of valid collections') }}</a></p>\n \n         {% elif err_status == 404 and err_details == 'static_file_not_found' %}\n             <p>{% trans %}Static file not found: <b>{{ err_msg }}{% endtrans %}</b></p>", "file_path": "files/2021_8/295", "file_language": "html", "file_name": "pywb/templates/error.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Fframe_insert.html", "code": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nhtml, body\n{\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n  border: 0px;\n  overflow: hidden;\n}\n\n</style>\n<script src='{{ static_prefix }}/wb_frame.js'> </script>\n\n{% autoescape false %}\n\n{{ banner_html }}\n\n{% endautoescape %}\n\n</head>\n<body style=\"margin: 0px; padding: 0px;\">\n\n<div id=\"wb_iframe_div\">\n<iframe id=\"replay_iframe\" frameborder=\"0\" seamless=\"seamless\" scrolling=\"yes\" class=\"wb_iframe\" allow=\"autoplay; fullscreen\"></iframe>\n</div>\n<script>\n  var cframe = new ContentFrame({\"url\": \"{{ url }}\" + window.location.hash,\n                                 \"prefix\": \"{{ wb_prefix }}\",\n                                 \"request_ts\": \"{{ wb_url.timestamp }}\",\n                                 \"iframe\": \"#replay_iframe\"});\n\n</script>\n</body>\n</html>\n", "code_before": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nhtml, body\n{\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n  border: 0px;\n  overflow: hidden;\n}\n\n</style>\n<script src='{{ static_prefix }}/wb_frame.js'> </script>\n\n{{ banner_html }}\n\n</head>\n<body style=\"margin: 0px; padding: 0px;\">\n\n<div id=\"wb_iframe_div\">\n<iframe id=\"replay_iframe\" frameborder=\"0\" seamless=\"seamless\" scrolling=\"yes\" class=\"wb_iframe\" allow=\"autoplay; fullscreen\"></iframe>\n</div>\n<script>\n  var cframe = new ContentFrame({\"url\": \"{{ url }}\" + window.location.hash,\n                                 \"prefix\": \"{{ wb_prefix }}\",\n                                 \"request_ts\": \"{{ wb_url.timestamp }}\",\n                                 \"iframe\": \"#replay_iframe\"});\n\n</script>\n</body>\n</html>\n", "patch": "@@ -14,8 +14,12 @@\n </style>\n <script src='{{ static_prefix }}/wb_frame.js'> </script>\n \n+{% autoescape false %}\n+\n {{ banner_html }}\n \n+{% endautoescape %}\n+\n </head>\n <body style=\"margin: 0px; padding: 0px;\">\n ", "file_path": "files/2021_8/296", "file_language": "html", "file_name": "pywb/templates/frame_insert.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Fhead_insert.html", "code": "{% autoescape false %}\n\n<!-- WB Insert -->\n<script>\n{% set urlsplit = cdx.url | urlsplit %}\n  wbinfo = {};\n  wbinfo.top_url = \"{{ top_url }}\";\n{% if is_framed %}\n  // Fast Top-Frame Redirect\n  if (window == window.top && wbinfo.top_url) {\n    var loc = window.location.href.replace(window.location.hash, \"\");\n    loc = decodeURI(loc);\n \n    if (loc != decodeURI(wbinfo.top_url)) {\n        window.location.href = wbinfo.top_url + window.location.hash;\n    }\n  }\n{% endif %}\n  wbinfo.url = \"{{ cdx.url }}\";\n  wbinfo.timestamp = \"{{ cdx.timestamp }}\";\n  wbinfo.request_ts = \"{{ wb_url.timestamp }}\";\n  wbinfo.prefix = decodeURI(\"{{ wb_prefix }}\");\n  wbinfo.mod = \"{{ replay_mod }}\";\n  wbinfo.is_framed = {{ is_framed | tobool }};\n  wbinfo.is_live = {{ is_live | tobool }};\n  wbinfo.coll = \"{{ coll }}\";\n  wbinfo.proxy_magic = \"{{ env.pywb_proxy_magic }}\";\n  wbinfo.static_prefix = \"{{ static_prefix }}/\";\n  wbinfo.enable_auto_fetch = {{ config.enable_auto_fetch | tobool }};\n</script>\n{% if env.pywb_proxy_magic %}\n{% set whichWombat = 'wombatProxyMode.js' %}\n{% else %}\n{% set whichWombat = 'wombat.js' %}\n{% endif %}\n{% if not wb_url.is_banner_only or (env.pywb_proxy_magic and (config.enable_auto_fetch or config.proxy.enable_wombat)) %}\n<script src='{{ static_prefix }}/{{ whichWombat }}'> </script>\n<script>\n  wbinfo.wombat_ts = \"{{ wombat_ts }}\";\n  wbinfo.wombat_sec = \"{{ wombat_sec }}\";\n  wbinfo.wombat_scheme = \"{{ urlsplit.scheme }}\";\n  wbinfo.wombat_host = \"{{ urlsplit.netloc }}\";\n\n  wbinfo.wombat_opts = {};\n\n  if (window && window._WBWombatInit) {\n    window._WBWombatInit(wbinfo);\n  }\n</script>\n{% else %}\n<script>\n  window.devicePixelRatio = 1;\n</script>\n{% endif %}\n\n{% if config.enable_flash_video_rewrite or config.transclusions_version == 1 %}\n<script src='{{ static_prefix }}/vidrw.js'> </script>\n\n{% elif config.transclusions_version == 2 %}\n<script src=\"{{ static_prefix }}/transclusions.js\"> </script>\n\n{% endif %}\n\n{{ banner_html }}\n\n{% endautoescape %}\n\n<!-- End WB Insert -->\n\n", "code_before": "<!-- WB Insert -->\n<script>\n{% set urlsplit = cdx.url | urlsplit %}\n  wbinfo = {};\n  wbinfo.top_url = \"{{ top_url }}\";\n{% if is_framed %}\n  // Fast Top-Frame Redirect\n  if (window == window.top && wbinfo.top_url) {\n    var loc = window.location.href.replace(window.location.hash, \"\");\n    loc = decodeURI(loc);\n \n    if (loc != decodeURI(wbinfo.top_url)) {\n        window.location.href = wbinfo.top_url + window.location.hash;\n    }\n  }\n{% endif %}\n  wbinfo.url = \"{{ cdx.url }}\";\n  wbinfo.timestamp = \"{{ cdx.timestamp }}\";\n  wbinfo.request_ts = \"{{ wb_url.timestamp }}\";\n  wbinfo.prefix = decodeURI(\"{{ wb_prefix }}\");\n  wbinfo.mod = \"{{ replay_mod }}\";\n  wbinfo.is_framed = {{ is_framed | tobool }};\n  wbinfo.is_live = {{ is_live | tobool }};\n  wbinfo.coll = \"{{ coll }}\";\n  wbinfo.proxy_magic = \"{{ env.pywb_proxy_magic }}\";\n  wbinfo.static_prefix = \"{{ static_prefix }}/\";\n  wbinfo.enable_auto_fetch = {{ config.enable_auto_fetch | tobool }};\n</script>\n{% if env.pywb_proxy_magic %}\n{% set whichWombat = 'wombatProxyMode.js' %}\n{% else %}\n{% set whichWombat = 'wombat.js' %}\n{% endif %}\n{% if not wb_url.is_banner_only or (env.pywb_proxy_magic and (config.enable_auto_fetch or config.proxy.enable_wombat)) %}\n<script src='{{ static_prefix }}/{{ whichWombat }}'> </script>\n<script>\n  wbinfo.wombat_ts = \"{{ wombat_ts }}\";\n  wbinfo.wombat_sec = \"{{ wombat_sec }}\";\n  wbinfo.wombat_scheme = \"{{ urlsplit.scheme }}\";\n  wbinfo.wombat_host = \"{{ urlsplit.netloc }}\";\n\n  wbinfo.wombat_opts = {};\n\n  if (window && window._WBWombatInit) {\n    window._WBWombatInit(wbinfo);\n  }\n</script>\n{% else %}\n<script>\n  window.devicePixelRatio = 1;\n</script>\n{% endif %}\n\n{% if config.enable_flash_video_rewrite or config.transclusions_version == 1 %}\n<script src='{{ static_prefix }}/vidrw.js'> </script>\n\n{% elif config.transclusions_version == 2 %}\n<script src=\"{{ static_prefix }}/transclusions.js\"> </script>\n\n{% endif %}\n\n{{ banner_html }}\n\n<!-- End WB Insert -->\n\n", "patch": "@@ -1,3 +1,5 @@\n+{% autoescape false %}\n+\n <!-- WB Insert -->\n <script>\n {% set urlsplit = cdx.url | urlsplit %}\n@@ -61,5 +63,7 @@\n \n {{ banner_html }}\n \n+{% endautoescape %}\n+\n <!-- End WB Insert -->\n ", "file_path": "files/2021_8/297", "file_language": "html", "file_name": "pywb/templates/head_insert.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Fheader.html", "code": "<header>\n   {% if locales|length > 1 %}\n    <div class=\"language-select\">\n        {{ _('Language:') }}\n        <ul role=\"listbox\" aria-activedescendant=\"{{ env.pywb_lang | default(default_locale) }}\" aria-labelledby=\"{{ _('Language select') }}\">\n        {% for locale in locales %}\n          <li role=\"option\" id=\"{{ locale }}\"><a href=\"{{ switch_locale(locale) }}\">{{ locale }}</a></li>\n        {% endfor %}\n        </ul>\n    </div>\n    {% endif %}\n</header>\n\n", "code_before": "", "patch": "@@ -0,0 +1,13 @@\n+<header>\n+   {% if locales|length > 1 %}\n+    <div class=\"language-select\">\n+        {{ _('Language:') }}\n+        <ul role=\"listbox\" aria-activedescendant=\"{{ env.pywb_lang | default(default_locale) }}\" aria-labelledby=\"{{ _('Language select') }}\">\n+        {% for locale in locales %}\n+          <li role=\"option\" id=\"{{ locale }}\"><a href=\"{{ switch_locale(locale) }}\">{{ locale }}</a></li>\n+        {% endfor %}\n+        </ul>\n+    </div>\n+    {% endif %}\n+</header>\n+", "file_path": "files/2021_8/298", "file_language": "html", "file_name": "pywb/templates/header.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Ftemplates%2Findex.html", "code": "{% extends \"base.html\" %}\n{% block body %}\n<div class=\"container\">\n    <div class=\"row\">\n        <h2 class=\"display-2\">{{ _('Pywb Wayback Machine') }}</h2>\n        <p class=\"lead\">{{ _('This archive contains the following collections:') }}</p>\n    </div>\n    <div class=\"row\">\n        <ul>\n            {% for route in routes %}\n                <li>\n                    <a href=\"{{ env['pywb.app_prefix'] + ('/' + env.pywb_lang if env.pywb_lang else '') + '/' + route }}\">{{ '/' + route }}</a>\n                    {% if all_metadata and all_metadata[route] %}\n                        ({{ all_metadata[route].title }})\n                    {% endif %}\n                </li>\n            {% endfor %}\n        </ul>\n    </div>\n</div>\n{% endblock %}\n", "code_before": "{% extends \"base.html\" %}\n{% block body %}\n<div class=\"container\">\n    <div class=\"row\">\n        <h2 class=\"display-2\">{{ _('Pywb Wayback Machine') }}</h2>\n        <p class=\"lead\">{{ _('This archive contains the following collections:') }}</p>\n    </div>\n    <div class=\"row\">\n        <ul>\n            {% for route in routes %}\n                <li>\n                    <a href=\"{{ env['pywb.app_prefix'] + '/' + route }}\">{{ '/' + route }}</a>\n                    {% if all_metadata and all_metadata[route] %}\n                        ({{ all_metadata[route].title }})\n                    {% endif %}\n                </li>\n            {% endfor %}\n        </ul>\n    </div>\n</div>\n{% endblock %}\n", "patch": "@@ -9,7 +9,7 @@ <h2 class=\"display-2\">{{ _('Pywb Wayback Machine') }}</h2>\n         <ul>\n             {% for route in routes %}\n                 <li>\n-                    <a href=\"{{ env['pywb.app_prefix'] + '/' + route }}\">{{ '/' + route }}</a>\n+                    <a href=\"{{ env['pywb.app_prefix'] + ('/' + env.pywb_lang if env.pywb_lang else '') + '/' + route }}\">{{ '/' + route }}</a>\n                     {% if all_metadata and all_metadata[route] %}\n                         ({{ all_metadata[route].title }})\n                     {% endif %}", "file_path": "files/2021_8/299", "file_language": "html", "file_name": "pywb/templates/index.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/pywb%2Fversion.py", "code": "__version__ = '2.6.0b1'\n\nif __name__ == '__main__':\n    print(__version__)\n", "code_before": "__version__ = '2.6.0b0'\n\nif __name__ == '__main__':\n    print(__version__)\n", "patch": "@@ -1,4 +1,4 @@\n-__version__ = '2.6.0b0'\n+__version__ = '2.6.0b1'\n \n if __name__ == '__main__':\n     print(__version__)", "file_path": "files/2021_8/300", "file_language": "py", "file_name": "pywb/version.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/setup.py", "code": "#!/usr/bin/env python\n# vim: set sw=4 et:\n\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test as TestCommand\nimport glob\nimport os\nimport sys\n\nfrom pywb import __version__\n\n\ndef get_long_description():\n    with open('README.rst', 'r') as fh:\n        long_description = fh.read()\n    return long_description\n\n\nclass PyTest(TestCommand):\n    user_options = []\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_suite = ' '\n\n    def run_tests(self):\n        from gevent.monkey import patch_all\n        patch_all()\n\n        import pytest\n        import os\n        os.environ.pop('PYWB_CONFIG_FILE', None)\n        cmdline = '--cov-config .coveragerc --cov pywb'\n        cmdline += ' -v --doctest-modules ./pywb/ tests/'\n\n        errcode = pytest.main(cmdline.split(' '))\n\n        sys.exit(errcode)\n\n\ndef get_git_short_hash():\n    import subprocess\n    try:\n        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()\n        if sys.version_info >= (3, 0):\n            hash_id = hash_id.decode('utf-8')\n\n        return hash_id\n    except Exception:\n        return ''\n\n\ndef generate_git_hash_py(pkg, filename='git_hash.py'):\n    try:\n        git_hash = get_git_short_hash()\n        with open(os.path.join(pkg, filename), 'wt') as fh:\n            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))\n    except Exception:\n        pass\n\n\ndef load_requirements(filename):\n    with open(filename, 'rt') as fh:\n        requirements = fh.read().rstrip().split('\\n')\n    if sys.version_info > (3, 0):\n        requirements.append(\"py3AMF\")\n    else:\n        requirements.append(\"pyAMF\")\n    return requirements\n\n\ndef get_package_data():\n    pkgs = ['static/*.*',\n            'templates/*',\n            '*.yaml']\n\n    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):\n        for dir_ in dirs:\n            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))\n\n    return pkgs\n\n\ngenerate_git_hash_py('pywb')\n\nsetup(\n    name='pywb',\n    version=__version__,\n    url='https://github.com/webrecorder/pywb',\n    author='Ilya Kreymer',\n    author_email='ikreymer@gmail.com',\n    description='Pywb Webrecorder web archive replay and capture tools',\n    long_description=get_long_description(),\n    license='GPL',\n    packages=find_packages(exclude=['tests_disabled']),\n    zip_safe=False,\n    package_data={\n        'pywb': get_package_data(),\n    },\n    data_files=[\n        ('sample_archive/cdx', glob.glob('sample_archive/cdx/*')),\n        ('sample_archive/cdxj', glob.glob('sample_archive/cdxj/*')),\n        ('sample_archive/non-surt-cdx', glob.glob('sample_archive/non-surt-cdx/*')),\n        ('sample_archive/zipcdx', glob.glob('sample_archive/zipcdx/*')),\n        ('sample_archive/warcs', glob.glob('sample_archive/warcs/*')),\n        ('sample_archive/text_content',\n         glob.glob('sample_archive/text_content/*')),\n    ],\n    install_requires=load_requirements('requirements.txt'),\n    extras_require={\n        \"i18n\":  [\"translate_toolkit\"],\n    },\n    tests_require=[\n        'pytest',\n        'WebTest',\n        'pytest-cov',\n        'mock',\n        'urllib3',\n        'werkzeug',\n        'httpbin==0.5.0',\n        'ujson',\n        'lxml'\n    ],\n    cmdclass={'test': PyTest},\n    test_suite='',\n    entry_points=\"\"\"\n        [console_scripts]\n        pywb = pywb.apps.cli:wayback\n        wayback = pywb.apps.cli:wayback\n        cdx-server = pywb.apps.cli:cdx_server\n        live-rewrite-server = pywb.apps.cli:live_rewrite_server\n        cdx-indexer = pywb.indexer.cdxindexer:main\n        wb-manager = pywb.manager.manager:main_wrap_exc\n        warcserver = pywb.apps.cli:warcserver\n        \"\"\",\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Web Environment',\n        'License :: OSI Approved :: GNU General Public License (GPL)',\n        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Topic :: Internet :: Proxy Servers',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Server',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: System :: Archiving',\n        'Topic :: System :: Archiving :: Backup',\n        'Topic :: Utilities',\n    ])\n", "code_before": "#!/usr/bin/env python\n# vim: set sw=4 et:\n\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test as TestCommand\nimport glob\nimport os\nimport sys\n\nfrom pywb import __version__\n\n\ndef get_long_description():\n    with open('README.rst', 'r') as fh:\n        long_description = fh.read()\n    return long_description\n\n\nclass PyTest(TestCommand):\n    user_options = []\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_suite = ' '\n\n    def run_tests(self):\n        from gevent.monkey import patch_all\n        patch_all()\n\n        import pytest\n        import os\n        os.environ.pop('PYWB_CONFIG_FILE', None)\n        cmdline = '--cov-config .coveragerc --cov pywb'\n        cmdline += ' -v --doctest-modules ./pywb/ tests/'\n\n        errcode = pytest.main(cmdline.split(' '))\n\n        sys.exit(errcode)\n\n\ndef get_git_short_hash():\n    import subprocess\n    try:\n        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()\n        if sys.version_info >= (3, 0):\n            hash_id = hash_id.decode('utf-8')\n\n        return hash_id\n    except Exception:\n        return ''\n\n\ndef generate_git_hash_py(pkg, filename='git_hash.py'):\n    try:\n        git_hash = get_git_short_hash()\n        with open(os.path.join(pkg, filename), 'wt') as fh:\n            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))\n    except Exception:\n        pass\n\n\ndef load_requirements(filename):\n    with open(filename, 'rt') as fh:\n        requirements = fh.read().rstrip().split('\\n')\n    if sys.version_info > (3, 0):\n        requirements.append(\"py3AMF\")\n    else:\n        requirements.append(\"pyAMF\")\n    return requirements\n\n\ndef get_package_data():\n    pkgs = ['static/*.*',\n            'templates/*',\n            '*.yaml']\n\n    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):\n        for dir_ in dirs:\n            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))\n\n    return pkgs\n\n\ngenerate_git_hash_py('pywb')\n\nsetup(\n    name='pywb',\n    version=__version__,\n    url='https://github.com/webrecorder/pywb',\n    author='Ilya Kreymer',\n    author_email='ikreymer@gmail.com',\n    description='Pywb Webrecorder web archive replay and capture tools',\n    long_description=get_long_description(),\n    license='GPL',\n    packages=find_packages(exclude=['tests_disabled']),\n    zip_safe=False,\n    package_data={\n        'pywb': get_package_data(),\n    },\n    data_files=[\n        ('sample_archive/cdx', glob.glob('sample_archive/cdx/*')),\n        ('sample_archive/cdxj', glob.glob('sample_archive/cdxj/*')),\n        ('sample_archive/non-surt-cdx', glob.glob('sample_archive/non-surt-cdx/*')),\n        ('sample_archive/zipcdx', glob.glob('sample_archive/zipcdx/*')),\n        ('sample_archive/warcs', glob.glob('sample_archive/warcs/*')),\n        ('sample_archive/text_content',\n         glob.glob('sample_archive/text_content/*')),\n    ],\n    install_requires=load_requirements('requirements.txt'),\n    tests_require=[\n        'pytest',\n        'WebTest',\n        'pytest-cov',\n        'mock',\n        'urllib3',\n        'werkzeug',\n        'httpbin==0.5.0',\n        'ujson',\n        'lxml'\n    ],\n    cmdclass={'test': PyTest},\n    test_suite='',\n    entry_points=\"\"\"\n        [console_scripts]\n        pywb = pywb.apps.cli:wayback\n        wayback = pywb.apps.cli:wayback\n        cdx-server = pywb.apps.cli:cdx_server\n        live-rewrite-server = pywb.apps.cli:live_rewrite_server\n        cdx-indexer = pywb.indexer.cdxindexer:main\n        wb-manager = pywb.manager.manager:main_wrap_exc\n        warcserver = pywb.apps.cli:warcserver\n        \"\"\",\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Web Environment',\n        'License :: OSI Approved :: GNU General Public License (GPL)',\n        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Topic :: Internet :: Proxy Servers',\n        'Topic :: Internet :: WWW/HTTP',\n        'Topic :: Internet :: WWW/HTTP :: WSGI',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware',\n        'Topic :: Internet :: WWW/HTTP :: WSGI :: Server',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: System :: Archiving',\n        'Topic :: System :: Archiving :: Backup',\n        'Topic :: Utilities',\n    ])\n", "patch": "@@ -107,6 +107,9 @@ def get_package_data():\n          glob.glob('sample_archive/text_content/*')),\n     ],\n     install_requires=load_requirements('requirements.txt'),\n+    extras_require={\n+        \"i18n\":  [\"translate_toolkit\"],\n+    },\n     tests_require=[\n         'pytest',\n         'WebTest',", "file_path": "files/2021_8/301", "file_language": "py", "file_name": "setup.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def get_long_description():\n    with open('README.rst', 'r') as fh:\n        long_description = fh.read()\n    return long_description", "target": 0}, {"function": "class PyTest(TestCommand):\n    user_options = []\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_suite = ' '\n\n    def run_tests(self):\n        from gevent.monkey import patch_all\n        patch_all()\n\n        import pytest\n        import os\n        os.environ.pop('PYWB_CONFIG_FILE', None)\n        cmdline = '--cov-config .coveragerc --cov pywb'\n        cmdline += ' -v --doctest-modules ./pywb/ tests/'\n\n        errcode = pytest.main(cmdline.split(' '))\n\n        sys.exit(errcode)", "target": 0}, {"function": "def get_git_short_hash():\n    import subprocess\n    try:\n        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()\n        if sys.version_info >= (3, 0):\n            hash_id = hash_id.decode('utf-8')\n\n        return hash_id\n    except Exception:\n        return ''", "target": 0}, {"function": "def generate_git_hash_py(pkg, filename='git_hash.py'):\n    try:\n        git_hash = get_git_short_hash()\n        with open(os.path.join(pkg, filename), 'wt') as fh:\n            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))\n    except Exception:\n        pass", "target": 0}, {"function": "def load_requirements(filename):\n    with open(filename, 'rt') as fh:\n        requirements = fh.read().rstrip().split('\\n')\n    if sys.version_info > (3, 0):\n        requirements.append(\"py3AMF\")\n    else:\n        requirements.append(\"pyAMF\")\n    return requirements", "target": 0}, {"function": "def get_package_data():\n    pkgs = ['static/*.*',\n            'templates/*',\n            '*.yaml']\n\n    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):\n        for dir_ in dirs:\n            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))\n\n    return pkgs", "target": 0}], "function_after": [{"function": "def get_long_description():\n    with open('README.rst', 'r') as fh:\n        long_description = fh.read()\n    return long_description", "target": 0}, {"function": "class PyTest(TestCommand):\n    user_options = []\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_suite = ' '\n\n    def run_tests(self):\n        from gevent.monkey import patch_all\n        patch_all()\n\n        import pytest\n        import os\n        os.environ.pop('PYWB_CONFIG_FILE', None)\n        cmdline = '--cov-config .coveragerc --cov pywb'\n        cmdline += ' -v --doctest-modules ./pywb/ tests/'\n\n        errcode = pytest.main(cmdline.split(' '))\n\n        sys.exit(errcode)", "target": 0}, {"function": "def get_git_short_hash():\n    import subprocess\n    try:\n        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()\n        if sys.version_info >= (3, 0):\n            hash_id = hash_id.decode('utf-8')\n\n        return hash_id\n    except Exception:\n        return ''", "target": 0}, {"function": "def generate_git_hash_py(pkg, filename='git_hash.py'):\n    try:\n        git_hash = get_git_short_hash()\n        with open(os.path.join(pkg, filename), 'wt') as fh:\n            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))\n    except Exception:\n        pass", "target": 0}, {"function": "def load_requirements(filename):\n    with open(filename, 'rt') as fh:\n        requirements = fh.read().rstrip().split('\\n')\n    if sys.version_info > (3, 0):\n        requirements.append(\"py3AMF\")\n    else:\n        requirements.append(\"pyAMF\")\n    return requirements", "target": 0}, {"function": "def get_package_data():\n    pkgs = ['static/*.*',\n            'templates/*',\n            '*.yaml']\n\n    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):\n        for dir_ in dirs:\n            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))\n\n    return pkgs", "target": 0}]}, {"raw_url": "https://github.com/webrecorder/pywb/raw/f7bd84cdacdd665ff73ae8d09a202f60be2ebae9/tests%2Ftest_auto_colls.py", "code": "from .base_config_test import BaseConfigTest, CollsDirMixin, fmod\n\nimport os\nimport tempfile\nimport shutil\nimport sys\n\nimport webtest\n\nimport time\nimport gevent\n\nfrom six import StringIO\n\nimport webtest\nfrom pytest import raises\nfrom mock import patch\n\nfrom pywb import get_test_dir\nfrom pywb.warcserver.test.testutils import BaseTestClass\n\nfrom pywb.manager.autoindex import AutoIndexer\nfrom pywb.manager.manager import main\n\nfrom pywb.indexer.cdxindexer import main as cdxindexer_main\nfrom pywb.warcserver.index.cdxobject import CDXObject\n\nfrom pywb.apps.frontendapp import FrontEndApp\n\n\n#=============================================================================\nARCHIVE_DIR = 'archive'\nINDEX_DIR = 'indexes'\nCOLLECTIONS = '_test_colls'\n\nINDEX_FILE = 'index.cdxj'\nAUTOINDEX_FILE = 'autoindex.cdxj'\n\n\n#=============================================================================\nclass TestManagedColls(CollsDirMixin, BaseConfigTest):\n    @classmethod\n    def setup_class(cls):\n        super(TestManagedColls, cls).setup_class('config_test.yaml')\n\n    def _check_dirs(self, base, dirlist):\n        for dir_ in dirlist:\n            assert os.path.isdir(os.path.join(base, dir_))\n\n    def _get_sample_warc(self, name):\n        return os.path.join(get_test_dir(), 'warcs', name)\n\n    @patch('pywb.apps.cli.BaseCli.run_gevent', lambda *args, **kwargs: None)\n    def test_run_cli(self):\n        \"\"\" test new wayback cli interface\n        test autoindex error before collections inited\n        \"\"\"\n        from pywb.apps.cli import wayback\n\n        wayback(['-p', '0'])\n\n        # Nothing to auto-index.. yet\n        with raises(SystemExit):\n            wayback(['-a', '-p', '0'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        os.mkdir(colls)\n\n        wayback(['-a', '-p', '0', '--auto-interval', '0'])\n\n    def test_create_first_coll(self):\n        \"\"\" Test first collection creation, with all required dirs\n        \"\"\"\n        main(['init', 'test'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        assert os.path.isdir(colls)\n\n        test = os.path.join(colls, 'test')\n        assert os.path.isdir(test)\n\n        self._check_dirs(test, [INDEX_DIR, ARCHIVE_DIR, 'static', 'templates'])\n\n    def test_add_warcs(self):\n        \"\"\" Test adding warc to new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['add', 'test', warc1])\n\n    def test_add_warcs_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_another_coll(self):\n        \"\"\" Test adding warc to a new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['init', 'foo'])\n\n        main(['add', 'foo', warc1])\n\n    def test_another_coll_replay(self, fmod):\n        resp = self.get('/foo/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_more_warcs(self):\n        \"\"\" Test adding additional warcs, check replay of added content\n        \"\"\"\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example-extra.warc')\n\n        main(['add', 'test', warc1, warc2])\n\n        # Spurrious file in collections\n        with open(os.path.join(self.root_dir, COLLECTIONS, 'blah'), 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        with raises(IOError):\n            main(['add', 'test', 'non-existent-file.warc.gz'])\n\n    def test_add_more_warcs_replay(self, fmod):\n        # check new cdx\n        resp = self.get('/test/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n    def test_add_custom_nested_warcs(self):\n        \"\"\" Test recursive indexing of custom created WARC hierarchy,\n        warcs/A/..., warcs/B/sub/...\n        Ensure CDX is relative to root archive dir, test replay\n        \"\"\"\n\n        main(['init', 'nested'])\n\n        nested_root = os.path.join(self.root_dir, COLLECTIONS, 'nested', ARCHIVE_DIR)\n        nested_a = os.path.join(nested_root, 'A')\n        nested_b = os.path.join(nested_root, 'B', 'sub')\n\n        os.makedirs(nested_a)\n        os.makedirs(nested_b)\n\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example.warc.gz')\n\n        shutil.copy2(warc1, nested_a)\n        shutil.copy2(warc2, nested_b)\n\n        main(['index',\n              'nested',\n              os.path.join(nested_a, 'iana.warc.gz'),\n              os.path.join(nested_b, 'example.warc.gz')\n             ])\n\n        nested_cdx = os.path.join(self.root_dir, COLLECTIONS, 'nested', INDEX_DIR, INDEX_FILE)\n        with open(nested_cdx) as fh:\n            nested_cdx_index = fh.read()\n\n        assert '1043' in nested_cdx_index\n        assert '333' in nested_cdx_index\n        assert 'B/sub/example.warc.gz' in nested_cdx_index\n\n        assert '2258' in nested_cdx_index\n        assert '334' in nested_cdx_index\n        assert 'A/iana.warc.gz' in nested_cdx_index\n\n    def test_nested_replay(self, fmod):\n        resp = self.get('/nested/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n        resp = self.get('/nested/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_merge_vs_reindex_equality(self):\n        \"\"\" Test full reindex vs merged update when adding warcs\n        to ensure equality of indexes\n        \"\"\"\n        # ensure merged index is same as full reindex\n        coll_dir = os.path.join(self.root_dir, COLLECTIONS, 'test', INDEX_DIR)\n        orig = os.path.join(coll_dir, INDEX_FILE)\n        bak = os.path.join(coll_dir, 'index.bak')\n\n        shutil.copy(orig, bak)\n\n        main(['reindex', 'test'])\n\n        with open(orig) as orig_fh:\n            merged_cdx = orig_fh.read()\n\n        with open(bak) as bak_fh:\n            reindex_cdx = bak_fh.read()\n\n        assert len(reindex_cdx.splitlines()) == len(merged_cdx.splitlines())\n        assert merged_cdx == reindex_cdx\n\n    def test_add_static(self):\n        \"\"\" Test adding static file to collection, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, COLLECTIONS, 'test', 'static', 'abc.js')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some JS File */')\n\n        resp = self.testapp.get('/static/_/test/abc.js')\n        assert resp.status_int == 200\n        assert resp.content_type == 'application/javascript'\n        resp.charset = 'utf-8'\n        assert '/* Some JS File */' in resp.text\n\n    def test_add_shared_static(self):\n        \"\"\" Test adding shared static file to root static/ dir, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, 'static', 'foo.css')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some CSS File */')\n\n        resp = self.testapp.get('/static/foo.css')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/css'\n        resp.charset = 'utf-8'\n        assert '/* Some CSS File */' in resp.text\n\n    def test_add_title_metadata_index_page(self):\n        \"\"\" Test adding title metadata to a collection, test\n        retrieval on default index page\n        \"\"\"\n        main(['metadata', 'foo', '--set', 'title=Collection Title'])\n\n        resp = self.testapp.get('/')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n        # test cache\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n    def test_other_metadata_search_page(self):\n        main(['metadata', 'foo', '--set',\n              'desc=Some Description Text',\n              'other=custom value'])\n\n        with raises(ValueError):\n            main(['metadata', 'foo', '--set', 'name_only'])\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n\n        assert 'Collection Title' in resp.text\n\n        assert 'desc' in resp.text\n        assert 'Some Description Text' in resp.text\n\n        assert 'other' in resp.text\n        assert 'custom value' in resp.text\n\n    def test_custom_template_search(self):\n        \"\"\" Test manually added custom search template search.html\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'pywb custom search page')\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' in resp.text\n\n    def test_add_custom_banner(self):\n        \"\"\" Test adding custom banner.html per-collection template\n        \"\"\"\n\n        banner_file = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                   'templates', 'banner.html')\n\n        with open(banner_file, 'w+b') as fh:\n            fh.write(b'<div>Custom Banner Here!</div>')\n            fh.write(b'\\n{{ metadata | tojson }}')\n\n    def test_add_custom_banner_replay(self, fmod):\n        resp = self.get('/test/20140103030321/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n\n    def test_more_custom_templates(self):\n        \"\"\"\n        Test custom templates and metadata\n        Template is relative to collection-specific dir\n        Add custom metadata and test its presence in custom search page\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        # add metadata\n        main(['metadata', 'test', '--set', 'some=value'])\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'overriden search page: ')\n            fh.write(b'{{ metadata | tojson }}\\n')\n\n        # force clear of jinja env cache to reload\n        self.app.rewriterapp.jinja_env.jinja_env.cache = {}\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'overriden search page: ' in resp.text\n        #assert '\"some\":\"value\"' in resp.text, resp.text\n        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n\n    def test_replay_banner_metadata(self, fmod):\n        \"\"\" Test adding metadata in replay banner (both framed and non-frame)\n        \"\"\"\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n        #assert '\"some\":\"value\"' in resp.text\n        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n\n    def test_more_custom_templates_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_default_coll_templates(self):\n        \"\"\" Test add default templates: collection,\n        and overwrite collection template\n        \"\"\"\n        # list\n        main(['template', 'foo', '--list'])\n\n        # Add collection template\n        main(['template', 'foo', '--add', 'query_html'])\n        assert os.path.isfile(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates', 'query.html'))\n\n        # overwrite -- force\n        main(['template', 'foo', '--add', 'query_html', '-f'])\n\n    def test_add_modify_home_template(self):\n        # Add shared template\n        main(['template', '--add', 'home_html'])\n\n        filename = os.path.join(self.root_dir, 'templates', 'index.html')\n        assert os.path.isfile(filename)\n\n        with open(filename, 'r+b') as fh:\n            buf = fh.read()\n            buf = buf.replace(b'Pywb Wayback Machine', b'Custom Test Homepage')\n            fh.seek(0)\n            fh.write(buf)\n\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert resp.content_type == 'text/html'\n        assert 'Custom Test Homepage' in resp.text, resp.text\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'y')\n    def test_add_template_input_yes(self):\n        \"\"\" Test answer 'yes' to overwrite\n        \"\"\"\n        main(['template', 'foo', '--add', 'query_html'])\n\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'n')\n    def test_add_template_input_no(self):\n        \"\"\" Test answer 'no' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'other')\n    def test_add_template_input_other(self):\n        \"\"\" Test answer 'other' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'no')\n    def test_remove_not_confirm(self):\n        \"\"\" Test answer 'no' to remove\n        \"\"\"\n        # don't remove -- not confirmed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'yes')\n    def test_remove_confirm(self):\n        # remove -- confirm\n        main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_no_templates(self):\n        \"\"\" Test removing templates dir, using default template again\n        \"\"\"\n        shutil.rmtree(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates'))\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' not in resp.text\n\n    def test_list_colls(self):\n        \"\"\" Test collection listing, printed to stdout\n        \"\"\"\n        orig_stdout = sys.stdout\n        buff = StringIO()\n        sys.stdout = buff\n\n        try:\n            main(['list'])\n        finally:\n            sys.stdout = orig_stdout\n\n        output = sorted(buff.getvalue().splitlines())\n        assert len(output) == 4\n        assert 'Collections:' in output\n        assert '- foo' in output\n        assert '- nested' in output\n        assert '- test' in output\n\n    def test_convert_cdx(self):\n        \"\"\" Create non-surt cdx, then convert to cdxj\n        \"\"\"\n        migrate_dir = os.path.join(self.root_dir, '_migrate')\n\n        os.mkdir(migrate_dir)\n\n        cdxindexer_main(['-u', '-o', migrate_dir, self._get_sample_warc('')])\n\n        # try one file with -9\n        cdxindexer_main(['-u', '-9', '-o', migrate_dir, self._get_sample_warc('example.warc.gz')])\n\n        cdxs = os.listdir(migrate_dir)\n        assert all(x.endswith('.cdx') for x in cdxs)\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'blah')\n        def do_migrate_no():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_no()\n        assert os.listdir(migrate_dir) == cdxs\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'y')\n        def do_migrate_yes():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_yes()\n        cdxjs = os.listdir(migrate_dir)\n\n        assert len(cdxs) == len(cdxjs)\n        assert all(x.endswith('.cdxj') for x in cdxjs)\n\n        with open(os.path.join(migrate_dir, 'iana.cdxj'), 'rb') as fh:\n            cdx = CDXObject(fh.readline())\n            assert cdx['urlkey'] == 'org,iana)/'\n            assert cdx['timestamp'] == '20140126200624'\n            assert cdx['url'] == 'http://www.iana.org/'\n            #assert fh.readline().startswith('org,iana)/ 20140126200624 {\"url\": \"http://www.iana.org/\",')\n\n        # Nothing else to migrate\n        main(['cdx-convert', migrate_dir])\n\n    def test_auto_index(self):\n        main(['init', 'auto'])\n        auto_dir = os.path.join(self.root_dir, COLLECTIONS, 'auto')\n        archive_dir = os.path.join(auto_dir, ARCHIVE_DIR)\n\n        archive_sub_dir = os.path.join(archive_dir, 'sub')\n        os.makedirs(archive_sub_dir)\n\n        def do_copy():\n            try:\n                time.sleep(1.0)\n                shutil.copy(self._get_sample_warc('example.warc.gz'), archive_dir)\n                shutil.copy(self._get_sample_warc('example-extra.warc'), archive_sub_dir)\n                time.sleep(1.0)\n            finally:\n                indexer.interval = 0\n\n        indexer = AutoIndexer(interval=0.25)\n        indexer.start()\n\n        ge = gevent.spawn(do_copy)\n        ge.join()\n\n        index_file = os.path.join(auto_dir, INDEX_DIR, AUTOINDEX_FILE)\n        assert os.path.isfile(index_file)\n\n        with open(index_file, 'r') as fh:\n            index = fh.read()\n\n        assert '\"example.warc.gz' in index, index\n        assert '\"sub/example-extra.warc' in index, index\n\n        mtime = os.path.getmtime(index_file)\n\n        # Update\n        indexer.interval = 0.25\n        indexer.start()\n\n        os.remove(index_file)\n\n        #thread = threading.Thread(target=do_copy)\n        #thread.daemon = True\n        #thread.start()\n        ge = gevent.spawn(do_copy)\n\n        #wayback(['-p', '0', '-a', '--auto-interval', '0.25'])\n\n        #thread.join()\n        ge.join()\n\n\t# assert file was update\n        assert os.path.getmtime(index_file) > mtime\n\n    def test_err_template_remove(self):\n        \"\"\" Test various error conditions for templates:\n        invalid template name, no collection for collection template\n        no template file found\n        \"\"\"\n        # no such template\n        with raises(KeyError):\n            main(['template', 'foo', '--remove', 'blah_html'])\n\n        # collection needed\n        with raises(IOError):\n            main(['template', '--remove', 'query_html'])\n\n        # already removed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_err_no_such_coll(self):\n        \"\"\" Test error adding warc to non-existant collection\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        with raises(IOError):\n            main(['add', 'bar', warc1])\n\n    def test_err_wrong_warcs(self):\n        warc1 = self._get_sample_warc('example.warc.gz')\n        invalid_warc = os.path.join(self.root_dir, COLLECTIONS, 'test', ARCHIVE_DIR, 'invalid.warc.gz')\n\n        # Empty warc list, argparse calls exit\n        with raises(SystemExit):\n            main(['index', 'test'])\n\n        # Wrong paths not in collection\n        with raises(IOError):\n            main(['index', 'test', warc1])\n\n        # Non-existent\n        with raises(IOError):\n            main(['index', 'test', invalid_warc])\n\n    def test_err_invalid_name(self):\n        \"\"\" Invalid collection name\n        \"\"\"\n        with raises(ValueError):\n            main(['init', '../abc%'])\n\n        with raises(ValueError):\n            main(['init', '45^23'])\n\n    def test_err_missing_dirs(self):\n        \"\"\" Test various errors with missing warcs dir,\n        missing cdx dir, non dir cdx file, and missing collections root\n        \"\"\"\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n\n        # No Statics -- ignorable\n        shutil.rmtree(os.path.join(colls, 'foo', 'static'))\n\n        # No WARCS\n        warcs_path = os.path.join(colls, 'foo', ARCHIVE_DIR)\n        shutil.rmtree(warcs_path)\n\n        with raises(IOError):\n            main(['add', 'foo', 'somewarc'])\n\n        # No CDX\n        cdx_path = os.path.join(colls, 'foo', INDEX_DIR)\n        shutil.rmtree(cdx_path)\n\n        # CDX a file not a dir\n        with open(cdx_path, 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        shutil.rmtree(colls)\n\n        # No Collections to list\n        with raises(IOError):\n            main(['list'])\n\n        # No Collections\n        resp = self.testapp.get('/test/', status=404)\n        assert resp.status_int == 404\n\n", "code_before": "from .base_config_test import BaseConfigTest, CollsDirMixin, fmod\n\nimport os\nimport tempfile\nimport shutil\nimport sys\n\nimport webtest\n\nimport time\nimport gevent\n\nfrom six import StringIO\n\nimport webtest\nfrom pytest import raises\nfrom mock import patch\n\nfrom pywb import get_test_dir\nfrom pywb.warcserver.test.testutils import BaseTestClass\n\nfrom pywb.manager.autoindex import AutoIndexer\nfrom pywb.manager.manager import main\n\nfrom pywb.indexer.cdxindexer import main as cdxindexer_main\nfrom pywb.warcserver.index.cdxobject import CDXObject\n\nfrom pywb.apps.frontendapp import FrontEndApp\n\n\n#=============================================================================\nARCHIVE_DIR = 'archive'\nINDEX_DIR = 'indexes'\nCOLLECTIONS = '_test_colls'\n\nINDEX_FILE = 'index.cdxj'\nAUTOINDEX_FILE = 'autoindex.cdxj'\n\n\n#=============================================================================\nclass TestManagedColls(CollsDirMixin, BaseConfigTest):\n    @classmethod\n    def setup_class(cls):\n        super(TestManagedColls, cls).setup_class('config_test.yaml')\n\n    def _check_dirs(self, base, dirlist):\n        for dir_ in dirlist:\n            assert os.path.isdir(os.path.join(base, dir_))\n\n    def _get_sample_warc(self, name):\n        return os.path.join(get_test_dir(), 'warcs', name)\n\n    @patch('pywb.apps.cli.BaseCli.run_gevent', lambda *args, **kwargs: None)\n    def test_run_cli(self):\n        \"\"\" test new wayback cli interface\n        test autoindex error before collections inited\n        \"\"\"\n        from pywb.apps.cli import wayback\n\n        wayback(['-p', '0'])\n\n        # Nothing to auto-index.. yet\n        with raises(SystemExit):\n            wayback(['-a', '-p', '0'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        os.mkdir(colls)\n\n        wayback(['-a', '-p', '0', '--auto-interval', '0'])\n\n    def test_create_first_coll(self):\n        \"\"\" Test first collection creation, with all required dirs\n        \"\"\"\n        main(['init', 'test'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        assert os.path.isdir(colls)\n\n        test = os.path.join(colls, 'test')\n        assert os.path.isdir(test)\n\n        self._check_dirs(test, [INDEX_DIR, ARCHIVE_DIR, 'static', 'templates'])\n\n    def test_add_warcs(self):\n        \"\"\" Test adding warc to new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['add', 'test', warc1])\n\n    def test_add_warcs_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_another_coll(self):\n        \"\"\" Test adding warc to a new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['init', 'foo'])\n\n        main(['add', 'foo', warc1])\n\n    def test_another_coll_replay(self, fmod):\n        resp = self.get('/foo/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_more_warcs(self):\n        \"\"\" Test adding additional warcs, check replay of added content\n        \"\"\"\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example-extra.warc')\n\n        main(['add', 'test', warc1, warc2])\n\n        # Spurrious file in collections\n        with open(os.path.join(self.root_dir, COLLECTIONS, 'blah'), 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        with raises(IOError):\n            main(['add', 'test', 'non-existent-file.warc.gz'])\n\n    def test_add_more_warcs_replay(self, fmod):\n        # check new cdx\n        resp = self.get('/test/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n    def test_add_custom_nested_warcs(self):\n        \"\"\" Test recursive indexing of custom created WARC hierarchy,\n        warcs/A/..., warcs/B/sub/...\n        Ensure CDX is relative to root archive dir, test replay\n        \"\"\"\n\n        main(['init', 'nested'])\n\n        nested_root = os.path.join(self.root_dir, COLLECTIONS, 'nested', ARCHIVE_DIR)\n        nested_a = os.path.join(nested_root, 'A')\n        nested_b = os.path.join(nested_root, 'B', 'sub')\n\n        os.makedirs(nested_a)\n        os.makedirs(nested_b)\n\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example.warc.gz')\n\n        shutil.copy2(warc1, nested_a)\n        shutil.copy2(warc2, nested_b)\n\n        main(['index',\n              'nested',\n              os.path.join(nested_a, 'iana.warc.gz'),\n              os.path.join(nested_b, 'example.warc.gz')\n             ])\n\n        nested_cdx = os.path.join(self.root_dir, COLLECTIONS, 'nested', INDEX_DIR, INDEX_FILE)\n        with open(nested_cdx) as fh:\n            nested_cdx_index = fh.read()\n\n        assert '1043' in nested_cdx_index\n        assert '333' in nested_cdx_index\n        assert 'B/sub/example.warc.gz' in nested_cdx_index\n\n        assert '2258' in nested_cdx_index\n        assert '334' in nested_cdx_index\n        assert 'A/iana.warc.gz' in nested_cdx_index\n\n    def test_nested_replay(self, fmod):\n        resp = self.get('/nested/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n        resp = self.get('/nested/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_merge_vs_reindex_equality(self):\n        \"\"\" Test full reindex vs merged update when adding warcs\n        to ensure equality of indexes\n        \"\"\"\n        # ensure merged index is same as full reindex\n        coll_dir = os.path.join(self.root_dir, COLLECTIONS, 'test', INDEX_DIR)\n        orig = os.path.join(coll_dir, INDEX_FILE)\n        bak = os.path.join(coll_dir, 'index.bak')\n\n        shutil.copy(orig, bak)\n\n        main(['reindex', 'test'])\n\n        with open(orig) as orig_fh:\n            merged_cdx = orig_fh.read()\n\n        with open(bak) as bak_fh:\n            reindex_cdx = bak_fh.read()\n\n        assert len(reindex_cdx.splitlines()) == len(merged_cdx.splitlines())\n        assert merged_cdx == reindex_cdx\n\n    def test_add_static(self):\n        \"\"\" Test adding static file to collection, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, COLLECTIONS, 'test', 'static', 'abc.js')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some JS File */')\n\n        resp = self.testapp.get('/static/_/test/abc.js')\n        assert resp.status_int == 200\n        assert resp.content_type == 'application/javascript'\n        resp.charset = 'utf-8'\n        assert '/* Some JS File */' in resp.text\n\n    def test_add_shared_static(self):\n        \"\"\" Test adding shared static file to root static/ dir, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, 'static', 'foo.css')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some CSS File */')\n\n        resp = self.testapp.get('/static/foo.css')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/css'\n        resp.charset = 'utf-8'\n        assert '/* Some CSS File */' in resp.text\n\n    def test_add_title_metadata_index_page(self):\n        \"\"\" Test adding title metadata to a collection, test\n        retrieval on default index page\n        \"\"\"\n        main(['metadata', 'foo', '--set', 'title=Collection Title'])\n\n        resp = self.testapp.get('/')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n        # test cache\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n    def test_other_metadata_search_page(self):\n        main(['metadata', 'foo', '--set',\n              'desc=Some Description Text',\n              'other=custom value'])\n\n        with raises(ValueError):\n            main(['metadata', 'foo', '--set', 'name_only'])\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n\n        assert 'Collection Title' in resp.text\n\n        assert 'desc' in resp.text\n        assert 'Some Description Text' in resp.text\n\n        assert 'other' in resp.text\n        assert 'custom value' in resp.text\n\n    def test_custom_template_search(self):\n        \"\"\" Test manually added custom search template search.html\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'pywb custom search page')\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' in resp.text\n\n    def test_add_custom_banner(self):\n        \"\"\" Test adding custom banner.html per-collection template\n        \"\"\"\n\n        banner_file = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                   'templates', 'banner.html')\n\n        with open(banner_file, 'w+b') as fh:\n            fh.write(b'<div>Custom Banner Here!</div>')\n            fh.write(b'\\n{{ metadata | tojson }}')\n\n    def test_add_custom_banner_replay(self, fmod):\n        resp = self.get('/test/20140103030321/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n\n    def test_more_custom_templates(self):\n        \"\"\"\n        Test custom templates and metadata\n        Template is relative to collection-specific dir\n        Add custom metadata and test its presence in custom search page\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        # add metadata\n        main(['metadata', 'test', '--set', 'some=value'])\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'overriden search page: ')\n            fh.write(b'{{ metadata | tojson }}\\n')\n\n        # force clear of jinja env cache to reload\n        self.app.rewriterapp.jinja_env.jinja_env.cache = {}\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'overriden search page: ' in resp.text\n        print(resp.text)\n        assert '\"some\":\"value\"' in resp.text, resp.text\n\n    def test_replay_banner_metadata(self, fmod):\n        \"\"\" Test adding metadata in replay banner (both framed and non-frame)\n        \"\"\"\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n        assert '\"some\":\"value\"' in resp.text\n\n    def test_more_custom_templates_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_default_coll_templates(self):\n        \"\"\" Test add default templates: collection,\n        and overwrite collection template\n        \"\"\"\n        # list\n        main(['template', 'foo', '--list'])\n\n        # Add collection template\n        main(['template', 'foo', '--add', 'query_html'])\n        assert os.path.isfile(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates', 'query.html'))\n\n        # overwrite -- force\n        main(['template', 'foo', '--add', 'query_html', '-f'])\n\n    def test_add_modify_home_template(self):\n        # Add shared template\n        main(['template', '--add', 'home_html'])\n\n        filename = os.path.join(self.root_dir, 'templates', 'index.html')\n        assert os.path.isfile(filename)\n\n        with open(filename, 'r+b') as fh:\n            buf = fh.read()\n            buf = buf.replace(b'Pywb Wayback Machine', b'Custom Test Homepage')\n            fh.seek(0)\n            fh.write(buf)\n\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert resp.content_type == 'text/html'\n        assert 'Custom Test Homepage' in resp.text, resp.text\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'y')\n    def test_add_template_input_yes(self):\n        \"\"\" Test answer 'yes' to overwrite\n        \"\"\"\n        main(['template', 'foo', '--add', 'query_html'])\n\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'n')\n    def test_add_template_input_no(self):\n        \"\"\" Test answer 'no' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'other')\n    def test_add_template_input_other(self):\n        \"\"\" Test answer 'other' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'no')\n    def test_remove_not_confirm(self):\n        \"\"\" Test answer 'no' to remove\n        \"\"\"\n        # don't remove -- not confirmed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'yes')\n    def test_remove_confirm(self):\n        # remove -- confirm\n        main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_no_templates(self):\n        \"\"\" Test removing templates dir, using default template again\n        \"\"\"\n        shutil.rmtree(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates'))\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' not in resp.text\n\n    def test_list_colls(self):\n        \"\"\" Test collection listing, printed to stdout\n        \"\"\"\n        orig_stdout = sys.stdout\n        buff = StringIO()\n        sys.stdout = buff\n\n        try:\n            main(['list'])\n        finally:\n            sys.stdout = orig_stdout\n\n        output = sorted(buff.getvalue().splitlines())\n        assert len(output) == 4\n        assert 'Collections:' in output\n        assert '- foo' in output\n        assert '- nested' in output\n        assert '- test' in output\n\n    def test_convert_cdx(self):\n        \"\"\" Create non-surt cdx, then convert to cdxj\n        \"\"\"\n        migrate_dir = os.path.join(self.root_dir, '_migrate')\n\n        os.mkdir(migrate_dir)\n\n        cdxindexer_main(['-u', '-o', migrate_dir, self._get_sample_warc('')])\n\n        # try one file with -9\n        cdxindexer_main(['-u', '-9', '-o', migrate_dir, self._get_sample_warc('example.warc.gz')])\n\n        cdxs = os.listdir(migrate_dir)\n        assert all(x.endswith('.cdx') for x in cdxs)\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'blah')\n        def do_migrate_no():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_no()\n        assert os.listdir(migrate_dir) == cdxs\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'y')\n        def do_migrate_yes():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_yes()\n        cdxjs = os.listdir(migrate_dir)\n\n        assert len(cdxs) == len(cdxjs)\n        assert all(x.endswith('.cdxj') for x in cdxjs)\n\n        with open(os.path.join(migrate_dir, 'iana.cdxj'), 'rb') as fh:\n            cdx = CDXObject(fh.readline())\n            assert cdx['urlkey'] == 'org,iana)/'\n            assert cdx['timestamp'] == '20140126200624'\n            assert cdx['url'] == 'http://www.iana.org/'\n            #assert fh.readline().startswith('org,iana)/ 20140126200624 {\"url\": \"http://www.iana.org/\",')\n\n        # Nothing else to migrate\n        main(['cdx-convert', migrate_dir])\n\n    def test_auto_index(self):\n        main(['init', 'auto'])\n        auto_dir = os.path.join(self.root_dir, COLLECTIONS, 'auto')\n        archive_dir = os.path.join(auto_dir, ARCHIVE_DIR)\n\n        archive_sub_dir = os.path.join(archive_dir, 'sub')\n        os.makedirs(archive_sub_dir)\n\n        def do_copy():\n            try:\n                time.sleep(1.0)\n                shutil.copy(self._get_sample_warc('example.warc.gz'), archive_dir)\n                shutil.copy(self._get_sample_warc('example-extra.warc'), archive_sub_dir)\n                time.sleep(1.0)\n            finally:\n                indexer.interval = 0\n\n        indexer = AutoIndexer(interval=0.25)\n        indexer.start()\n\n        ge = gevent.spawn(do_copy)\n        ge.join()\n\n        index_file = os.path.join(auto_dir, INDEX_DIR, AUTOINDEX_FILE)\n        assert os.path.isfile(index_file)\n\n        with open(index_file, 'r') as fh:\n            index = fh.read()\n\n        assert '\"example.warc.gz' in index, index\n        assert '\"sub/example-extra.warc' in index, index\n\n        mtime = os.path.getmtime(index_file)\n\n        # Update\n        indexer.interval = 0.25\n        indexer.start()\n\n        os.remove(index_file)\n\n        #thread = threading.Thread(target=do_copy)\n        #thread.daemon = True\n        #thread.start()\n        ge = gevent.spawn(do_copy)\n\n        #wayback(['-p', '0', '-a', '--auto-interval', '0.25'])\n\n        #thread.join()\n        ge.join()\n\n\t# assert file was update\n        assert os.path.getmtime(index_file) > mtime\n\n    def test_err_template_remove(self):\n        \"\"\" Test various error conditions for templates:\n        invalid template name, no collection for collection template\n        no template file found\n        \"\"\"\n        # no such template\n        with raises(KeyError):\n            main(['template', 'foo', '--remove', 'blah_html'])\n\n        # collection needed\n        with raises(IOError):\n            main(['template', '--remove', 'query_html'])\n\n        # already removed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_err_no_such_coll(self):\n        \"\"\" Test error adding warc to non-existant collection\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        with raises(IOError):\n            main(['add', 'bar', warc1])\n\n    def test_err_wrong_warcs(self):\n        warc1 = self._get_sample_warc('example.warc.gz')\n        invalid_warc = os.path.join(self.root_dir, COLLECTIONS, 'test', ARCHIVE_DIR, 'invalid.warc.gz')\n\n        # Empty warc list, argparse calls exit\n        with raises(SystemExit):\n            main(['index', 'test'])\n\n        # Wrong paths not in collection\n        with raises(IOError):\n            main(['index', 'test', warc1])\n\n        # Non-existent\n        with raises(IOError):\n            main(['index', 'test', invalid_warc])\n\n    def test_err_invalid_name(self):\n        \"\"\" Invalid collection name\n        \"\"\"\n        with raises(ValueError):\n            main(['init', '../abc%'])\n\n        with raises(ValueError):\n            main(['init', '45^23'])\n\n    def test_err_missing_dirs(self):\n        \"\"\" Test various errors with missing warcs dir,\n        missing cdx dir, non dir cdx file, and missing collections root\n        \"\"\"\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n\n        # No Statics -- ignorable\n        shutil.rmtree(os.path.join(colls, 'foo', 'static'))\n\n        # No WARCS\n        warcs_path = os.path.join(colls, 'foo', ARCHIVE_DIR)\n        shutil.rmtree(warcs_path)\n\n        with raises(IOError):\n            main(['add', 'foo', 'somewarc'])\n\n        # No CDX\n        cdx_path = os.path.join(colls, 'foo', INDEX_DIR)\n        shutil.rmtree(cdx_path)\n\n        # CDX a file not a dir\n        with open(cdx_path, 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        shutil.rmtree(colls)\n\n        # No Collections to list\n        with raises(IOError):\n            main(['list'])\n\n        # No Collections\n        resp = self.testapp.get('/test/', status=404)\n        assert resp.status_int == 404\n\n", "patch": "@@ -313,15 +313,16 @@ def test_more_custom_templates(self):\n         assert resp.status_int == 200\n         assert resp.content_type == 'text/html'\n         assert 'overriden search page: ' in resp.text\n-        print(resp.text)\n-        assert '\"some\":\"value\"' in resp.text, resp.text\n+        #assert '\"some\":\"value\"' in resp.text, resp.text\n+        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n \n     def test_replay_banner_metadata(self, fmod):\n         \"\"\" Test adding metadata in replay banner (both framed and non-frame)\n         \"\"\"\n         resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n         assert '<div>Custom Banner Here!</div>' in resp.text\n-        assert '\"some\":\"value\"' in resp.text\n+        #assert '\"some\":\"value\"' in resp.text\n+        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n \n     def test_more_custom_templates_replay(self, fmod):\n         resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)", "file_path": "files/2021_8/302", "file_language": "py", "file_name": "tests/test_auto_colls.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class TestManagedColls(CollsDirMixin, BaseConfigTest):\n    @classmethod\n    def setup_class(cls):\n        super(TestManagedColls, cls).setup_class('config_test.yaml')\n\n    def _check_dirs(self, base, dirlist):\n        for dir_ in dirlist:\n            assert os.path.isdir(os.path.join(base, dir_))\n\n    def _get_sample_warc(self, name):\n        return os.path.join(get_test_dir(), 'warcs', name)\n\n    @patch('pywb.apps.cli.BaseCli.run_gevent', lambda *args, **kwargs: None)\n    def test_run_cli(self):\n        \"\"\" test new wayback cli interface\n        test autoindex error before collections inited\n        \"\"\"\n        from pywb.apps.cli import wayback\n\n        wayback(['-p', '0'])\n\n        # Nothing to auto-index.. yet\n        with raises(SystemExit):\n            wayback(['-a', '-p', '0'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        os.mkdir(colls)\n\n        wayback(['-a', '-p', '0', '--auto-interval', '0'])\n\n    def test_create_first_coll(self):\n        \"\"\" Test first collection creation, with all required dirs\n        \"\"\"\n        main(['init', 'test'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        assert os.path.isdir(colls)\n\n        test = os.path.join(colls, 'test')\n        assert os.path.isdir(test)\n\n        self._check_dirs(test, [INDEX_DIR, ARCHIVE_DIR, 'static', 'templates'])\n\n    def test_add_warcs(self):\n        \"\"\" Test adding warc to new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['add', 'test', warc1])\n\n    def test_add_warcs_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_another_coll(self):\n        \"\"\" Test adding warc to a new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['init', 'foo'])\n\n        main(['add', 'foo', warc1])\n\n    def test_another_coll_replay(self, fmod):\n        resp = self.get('/foo/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_more_warcs(self):\n        \"\"\" Test adding additional warcs, check replay of added content\n        \"\"\"\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example-extra.warc')\n\n        main(['add', 'test', warc1, warc2])\n\n        # Spurrious file in collections\n        with open(os.path.join(self.root_dir, COLLECTIONS, 'blah'), 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        with raises(IOError):\n            main(['add', 'test', 'non-existent-file.warc.gz'])\n\n    def test_add_more_warcs_replay(self, fmod):\n        # check new cdx\n        resp = self.get('/test/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n    def test_add_custom_nested_warcs(self):\n        \"\"\" Test recursive indexing of custom created WARC hierarchy,\n        warcs/A/..., warcs/B/sub/...\n        Ensure CDX is relative to root archive dir, test replay\n        \"\"\"\n\n        main(['init', 'nested'])\n\n        nested_root = os.path.join(self.root_dir, COLLECTIONS, 'nested', ARCHIVE_DIR)\n        nested_a = os.path.join(nested_root, 'A')\n        nested_b = os.path.join(nested_root, 'B', 'sub')\n\n        os.makedirs(nested_a)\n        os.makedirs(nested_b)\n\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example.warc.gz')\n\n        shutil.copy2(warc1, nested_a)\n        shutil.copy2(warc2, nested_b)\n\n        main(['index',\n              'nested',\n              os.path.join(nested_a, 'iana.warc.gz'),\n              os.path.join(nested_b, 'example.warc.gz')\n             ])\n\n        nested_cdx = os.path.join(self.root_dir, COLLECTIONS, 'nested', INDEX_DIR, INDEX_FILE)\n        with open(nested_cdx) as fh:\n            nested_cdx_index = fh.read()\n\n        assert '1043' in nested_cdx_index\n        assert '333' in nested_cdx_index\n        assert 'B/sub/example.warc.gz' in nested_cdx_index\n\n        assert '2258' in nested_cdx_index\n        assert '334' in nested_cdx_index\n        assert 'A/iana.warc.gz' in nested_cdx_index\n\n    def test_nested_replay(self, fmod):\n        resp = self.get('/nested/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n        resp = self.get('/nested/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_merge_vs_reindex_equality(self):\n        \"\"\" Test full reindex vs merged update when adding warcs\n        to ensure equality of indexes\n        \"\"\"\n        # ensure merged index is same as full reindex\n        coll_dir = os.path.join(self.root_dir, COLLECTIONS, 'test', INDEX_DIR)\n        orig = os.path.join(coll_dir, INDEX_FILE)\n        bak = os.path.join(coll_dir, 'index.bak')\n\n        shutil.copy(orig, bak)\n\n        main(['reindex', 'test'])\n\n        with open(orig) as orig_fh:\n            merged_cdx = orig_fh.read()\n\n        with open(bak) as bak_fh:\n            reindex_cdx = bak_fh.read()\n\n        assert len(reindex_cdx.splitlines()) == len(merged_cdx.splitlines())\n        assert merged_cdx == reindex_cdx\n\n    def test_add_static(self):\n        \"\"\" Test adding static file to collection, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, COLLECTIONS, 'test', 'static', 'abc.js')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some JS File */')\n\n        resp = self.testapp.get('/static/_/test/abc.js')\n        assert resp.status_int == 200\n        assert resp.content_type == 'application/javascript'\n        resp.charset = 'utf-8'\n        assert '/* Some JS File */' in resp.text\n\n    def test_add_shared_static(self):\n        \"\"\" Test adding shared static file to root static/ dir, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, 'static', 'foo.css')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some CSS File */')\n\n        resp = self.testapp.get('/static/foo.css')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/css'\n        resp.charset = 'utf-8'\n        assert '/* Some CSS File */' in resp.text\n\n    def test_add_title_metadata_index_page(self):\n        \"\"\" Test adding title metadata to a collection, test\n        retrieval on default index page\n        \"\"\"\n        main(['metadata', 'foo', '--set', 'title=Collection Title'])\n\n        resp = self.testapp.get('/')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n        # test cache\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n    def test_other_metadata_search_page(self):\n        main(['metadata', 'foo', '--set',\n              'desc=Some Description Text',\n              'other=custom value'])\n\n        with raises(ValueError):\n            main(['metadata', 'foo', '--set', 'name_only'])\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n\n        assert 'Collection Title' in resp.text\n\n        assert 'desc' in resp.text\n        assert 'Some Description Text' in resp.text\n\n        assert 'other' in resp.text\n        assert 'custom value' in resp.text\n\n    def test_custom_template_search(self):\n        \"\"\" Test manually added custom search template search.html\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'pywb custom search page')\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' in resp.text\n\n    def test_add_custom_banner(self):\n        \"\"\" Test adding custom banner.html per-collection template\n        \"\"\"\n\n        banner_file = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                   'templates', 'banner.html')\n\n        with open(banner_file, 'w+b') as fh:\n            fh.write(b'<div>Custom Banner Here!</div>')\n            fh.write(b'\\n{{ metadata | tojson }}')\n\n    def test_add_custom_banner_replay(self, fmod):\n        resp = self.get('/test/20140103030321/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n\n    def test_more_custom_templates(self):\n        \"\"\"\n        Test custom templates and metadata\n        Template is relative to collection-specific dir\n        Add custom metadata and test its presence in custom search page\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        # add metadata\n        main(['metadata', 'test', '--set', 'some=value'])\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'overriden search page: ')\n            fh.write(b'{{ metadata | tojson }}\\n')\n\n        # force clear of jinja env cache to reload\n        self.app.rewriterapp.jinja_env.jinja_env.cache = {}\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'overriden search page: ' in resp.text\n        print(resp.text)\n        assert '\"some\":\"value\"' in resp.text, resp.text\n\n    def test_replay_banner_metadata(self, fmod):\n        \"\"\" Test adding metadata in replay banner (both framed and non-frame)\n        \"\"\"\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n        assert '\"some\":\"value\"' in resp.text\n\n    def test_more_custom_templates_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_default_coll_templates(self):\n        \"\"\" Test add default templates: collection,\n        and overwrite collection template\n        \"\"\"\n        # list\n        main(['template', 'foo', '--list'])\n\n        # Add collection template\n        main(['template', 'foo', '--add', 'query_html'])\n        assert os.path.isfile(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates', 'query.html'))\n\n        # overwrite -- force\n        main(['template', 'foo', '--add', 'query_html', '-f'])\n\n    def test_add_modify_home_template(self):\n        # Add shared template\n        main(['template', '--add', 'home_html'])\n\n        filename = os.path.join(self.root_dir, 'templates', 'index.html')\n        assert os.path.isfile(filename)\n\n        with open(filename, 'r+b') as fh:\n            buf = fh.read()\n            buf = buf.replace(b'Pywb Wayback Machine', b'Custom Test Homepage')\n            fh.seek(0)\n            fh.write(buf)\n\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert resp.content_type == 'text/html'\n        assert 'Custom Test Homepage' in resp.text, resp.text\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'y')\n    def test_add_template_input_yes(self):\n        \"\"\" Test answer 'yes' to overwrite\n        \"\"\"\n        main(['template', 'foo', '--add', 'query_html'])\n\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'n')\n    def test_add_template_input_no(self):\n        \"\"\" Test answer 'no' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'other')\n    def test_add_template_input_other(self):\n        \"\"\" Test answer 'other' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'no')\n    def test_remove_not_confirm(self):\n        \"\"\" Test answer 'no' to remove\n        \"\"\"\n        # don't remove -- not confirmed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'yes')\n    def test_remove_confirm(self):\n        # remove -- confirm\n        main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_no_templates(self):\n        \"\"\" Test removing templates dir, using default template again\n        \"\"\"\n        shutil.rmtree(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates'))\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' not in resp.text\n\n    def test_list_colls(self):\n        \"\"\" Test collection listing, printed to stdout\n        \"\"\"\n        orig_stdout = sys.stdout\n        buff = StringIO()\n        sys.stdout = buff\n\n        try:\n            main(['list'])\n        finally:\n            sys.stdout = orig_stdout\n\n        output = sorted(buff.getvalue().splitlines())\n        assert len(output) == 4\n        assert 'Collections:' in output\n        assert '- foo' in output\n        assert '- nested' in output\n        assert '- test' in output\n\n    def test_convert_cdx(self):\n        \"\"\" Create non-surt cdx, then convert to cdxj\n        \"\"\"\n        migrate_dir = os.path.join(self.root_dir, '_migrate')\n\n        os.mkdir(migrate_dir)\n\n        cdxindexer_main(['-u', '-o', migrate_dir, self._get_sample_warc('')])\n\n        # try one file with -9\n        cdxindexer_main(['-u', '-9', '-o', migrate_dir, self._get_sample_warc('example.warc.gz')])\n\n        cdxs = os.listdir(migrate_dir)\n        assert all(x.endswith('.cdx') for x in cdxs)\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'blah')\n        def do_migrate_no():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_no()\n        assert os.listdir(migrate_dir) == cdxs\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'y')\n        def do_migrate_yes():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_yes()\n        cdxjs = os.listdir(migrate_dir)\n\n        assert len(cdxs) == len(cdxjs)\n        assert all(x.endswith('.cdxj') for x in cdxjs)\n\n        with open(os.path.join(migrate_dir, 'iana.cdxj'), 'rb') as fh:\n            cdx = CDXObject(fh.readline())\n            assert cdx['urlkey'] == 'org,iana)/'\n            assert cdx['timestamp'] == '20140126200624'\n            assert cdx['url'] == 'http://www.iana.org/'\n            #assert fh.readline().startswith('org,iana)/ 20140126200624 {\"url\": \"http://www.iana.org/\",')\n\n        # Nothing else to migrate\n        main(['cdx-convert', migrate_dir])\n\n    def test_auto_index(self):\n        main(['init', 'auto'])\n        auto_dir = os.path.join(self.root_dir, COLLECTIONS, 'auto')\n        archive_dir = os.path.join(auto_dir, ARCHIVE_DIR)\n\n        archive_sub_dir = os.path.join(archive_dir, 'sub')\n        os.makedirs(archive_sub_dir)\n\n        def do_copy():\n            try:\n                time.sleep(1.0)\n                shutil.copy(self._get_sample_warc('example.warc.gz'), archive_dir)\n                shutil.copy(self._get_sample_warc('example-extra.warc'), archive_sub_dir)\n                time.sleep(1.0)\n            finally:\n                indexer.interval = 0\n\n        indexer = AutoIndexer(interval=0.25)\n        indexer.start()\n\n        ge = gevent.spawn(do_copy)\n        ge.join()\n\n        index_file = os.path.join(auto_dir, INDEX_DIR, AUTOINDEX_FILE)\n        assert os.path.isfile(index_file)\n\n        with open(index_file, 'r') as fh:\n            index = fh.read()\n\n        assert '\"example.warc.gz' in index, index\n        assert '\"sub/example-extra.warc' in index, index\n\n        mtime = os.path.getmtime(index_file)\n\n        # Update\n        indexer.interval = 0.25\n        indexer.start()\n\n        os.remove(index_file)\n\n        #thread = threading.Thread(target=do_copy)\n        #thread.daemon = True\n        #thread.start()\n        ge = gevent.spawn(do_copy)\n\n        #wayback(['-p', '0', '-a', '--auto-interval', '0.25'])\n\n        #thread.join()\n        ge.join()\n\n\t# assert file was update\n        assert os.path.getmtime(index_file) > mtime\n\n    def test_err_template_remove(self):\n        \"\"\" Test various error conditions for templates:\n        invalid template name, no collection for collection template\n        no template file found\n        \"\"\"\n        # no such template\n        with raises(KeyError):\n            main(['template', 'foo', '--remove', 'blah_html'])\n\n        # collection needed\n        with raises(IOError):\n            main(['template', '--remove', 'query_html'])\n\n        # already removed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_err_no_such_coll(self):\n        \"\"\" Test error adding warc to non-existant collection\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        with raises(IOError):\n            main(['add', 'bar', warc1])\n\n    def test_err_wrong_warcs(self):\n        warc1 = self._get_sample_warc('example.warc.gz')\n        invalid_warc = os.path.join(self.root_dir, COLLECTIONS, 'test', ARCHIVE_DIR, 'invalid.warc.gz')\n\n        # Empty warc list, argparse calls exit\n        with raises(SystemExit):\n            main(['index', 'test'])\n\n        # Wrong paths not in collection\n        with raises(IOError):\n            main(['index', 'test', warc1])\n\n        # Non-existent\n        with raises(IOError):\n            main(['index', 'test', invalid_warc])\n\n    def test_err_invalid_name(self):\n        \"\"\" Invalid collection name\n        \"\"\"\n        with raises(ValueError):\n            main(['init', '../abc%'])\n\n        with raises(ValueError):\n            main(['init', '45^23'])\n\n    def test_err_missing_dirs(self):\n        \"\"\" Test various errors with missing warcs dir,\n        missing cdx dir, non dir cdx file, and missing collections root\n        \"\"\"\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n\n        # No Statics -- ignorable\n        shutil.rmtree(os.path.join(colls, 'foo', 'static'))\n\n        # No WARCS\n        warcs_path = os.path.join(colls, 'foo', ARCHIVE_DIR)\n        shutil.rmtree(warcs_path)\n\n        with raises(IOError):\n            main(['add', 'foo', 'somewarc'])\n\n        # No CDX\n        cdx_path = os.path.join(colls, 'foo', INDEX_DIR)\n        shutil.rmtree(cdx_path)\n\n        # CDX a file not a dir\n        with open(cdx_path, 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        shutil.rmtree(colls)\n\n        # No Collections to list\n        with raises(IOError):\n            main(['list'])\n\n        # No Collections\n        resp = self.testapp.get('/test/', status=404)\n        assert resp.status_int == 404", "target": 0}], "function_after": [{"function": "class TestManagedColls(CollsDirMixin, BaseConfigTest):\n    @classmethod\n    def setup_class(cls):\n        super(TestManagedColls, cls).setup_class('config_test.yaml')\n\n    def _check_dirs(self, base, dirlist):\n        for dir_ in dirlist:\n            assert os.path.isdir(os.path.join(base, dir_))\n\n    def _get_sample_warc(self, name):\n        return os.path.join(get_test_dir(), 'warcs', name)\n\n    @patch('pywb.apps.cli.BaseCli.run_gevent', lambda *args, **kwargs: None)\n    def test_run_cli(self):\n        \"\"\" test new wayback cli interface\n        test autoindex error before collections inited\n        \"\"\"\n        from pywb.apps.cli import wayback\n\n        wayback(['-p', '0'])\n\n        # Nothing to auto-index.. yet\n        with raises(SystemExit):\n            wayback(['-a', '-p', '0'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        os.mkdir(colls)\n\n        wayback(['-a', '-p', '0', '--auto-interval', '0'])\n\n    def test_create_first_coll(self):\n        \"\"\" Test first collection creation, with all required dirs\n        \"\"\"\n        main(['init', 'test'])\n\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n        assert os.path.isdir(colls)\n\n        test = os.path.join(colls, 'test')\n        assert os.path.isdir(test)\n\n        self._check_dirs(test, [INDEX_DIR, ARCHIVE_DIR, 'static', 'templates'])\n\n    def test_add_warcs(self):\n        \"\"\" Test adding warc to new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['add', 'test', warc1])\n\n    def test_add_warcs_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_another_coll(self):\n        \"\"\" Test adding warc to a new coll, check replay\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        main(['init', 'foo'])\n\n        main(['add', 'foo', warc1])\n\n    def test_another_coll_replay(self, fmod):\n        resp = self.get('/foo/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_more_warcs(self):\n        \"\"\" Test adding additional warcs, check replay of added content\n        \"\"\"\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example-extra.warc')\n\n        main(['add', 'test', warc1, warc2])\n\n        # Spurrious file in collections\n        with open(os.path.join(self.root_dir, COLLECTIONS, 'blah'), 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        with raises(IOError):\n            main(['add', 'test', 'non-existent-file.warc.gz'])\n\n    def test_add_more_warcs_replay(self, fmod):\n        # check new cdx\n        resp = self.get('/test/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n    def test_add_custom_nested_warcs(self):\n        \"\"\" Test recursive indexing of custom created WARC hierarchy,\n        warcs/A/..., warcs/B/sub/...\n        Ensure CDX is relative to root archive dir, test replay\n        \"\"\"\n\n        main(['init', 'nested'])\n\n        nested_root = os.path.join(self.root_dir, COLLECTIONS, 'nested', ARCHIVE_DIR)\n        nested_a = os.path.join(nested_root, 'A')\n        nested_b = os.path.join(nested_root, 'B', 'sub')\n\n        os.makedirs(nested_a)\n        os.makedirs(nested_b)\n\n        warc1 = self._get_sample_warc('iana.warc.gz')\n        warc2 = self._get_sample_warc('example.warc.gz')\n\n        shutil.copy2(warc1, nested_a)\n        shutil.copy2(warc2, nested_b)\n\n        main(['index',\n              'nested',\n              os.path.join(nested_a, 'iana.warc.gz'),\n              os.path.join(nested_b, 'example.warc.gz')\n             ])\n\n        nested_cdx = os.path.join(self.root_dir, COLLECTIONS, 'nested', INDEX_DIR, INDEX_FILE)\n        with open(nested_cdx) as fh:\n            nested_cdx_index = fh.read()\n\n        assert '1043' in nested_cdx_index\n        assert '333' in nested_cdx_index\n        assert 'B/sub/example.warc.gz' in nested_cdx_index\n\n        assert '2258' in nested_cdx_index\n        assert '334' in nested_cdx_index\n        assert 'A/iana.warc.gz' in nested_cdx_index\n\n    def test_nested_replay(self, fmod):\n        resp = self.get('/nested/20140126200624{0}/http://www.iana.org/', fmod)\n        assert resp.status_int == 200\n\n        resp = self.get('/nested/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_merge_vs_reindex_equality(self):\n        \"\"\" Test full reindex vs merged update when adding warcs\n        to ensure equality of indexes\n        \"\"\"\n        # ensure merged index is same as full reindex\n        coll_dir = os.path.join(self.root_dir, COLLECTIONS, 'test', INDEX_DIR)\n        orig = os.path.join(coll_dir, INDEX_FILE)\n        bak = os.path.join(coll_dir, 'index.bak')\n\n        shutil.copy(orig, bak)\n\n        main(['reindex', 'test'])\n\n        with open(orig) as orig_fh:\n            merged_cdx = orig_fh.read()\n\n        with open(bak) as bak_fh:\n            reindex_cdx = bak_fh.read()\n\n        assert len(reindex_cdx.splitlines()) == len(merged_cdx.splitlines())\n        assert merged_cdx == reindex_cdx\n\n    def test_add_static(self):\n        \"\"\" Test adding static file to collection, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, COLLECTIONS, 'test', 'static', 'abc.js')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some JS File */')\n\n        resp = self.testapp.get('/static/_/test/abc.js')\n        assert resp.status_int == 200\n        assert resp.content_type == 'application/javascript'\n        resp.charset = 'utf-8'\n        assert '/* Some JS File */' in resp.text\n\n    def test_add_shared_static(self):\n        \"\"\" Test adding shared static file to root static/ dir, check access\n        \"\"\"\n        a_static = os.path.join(self.root_dir, 'static', 'foo.css')\n\n        with open(a_static, 'w+b') as fh:\n            fh.write(b'/* Some CSS File */')\n\n        resp = self.testapp.get('/static/foo.css')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/css'\n        resp.charset = 'utf-8'\n        assert '/* Some CSS File */' in resp.text\n\n    def test_add_title_metadata_index_page(self):\n        \"\"\" Test adding title metadata to a collection, test\n        retrieval on default index page\n        \"\"\"\n        main(['metadata', 'foo', '--set', 'title=Collection Title'])\n\n        resp = self.testapp.get('/')\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n        # test cache\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert '(Collection Title)' in resp.text\n\n    def test_other_metadata_search_page(self):\n        main(['metadata', 'foo', '--set',\n              'desc=Some Description Text',\n              'other=custom value'])\n\n        with raises(ValueError):\n            main(['metadata', 'foo', '--set', 'name_only'])\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n\n        assert 'Collection Title' in resp.text\n\n        assert 'desc' in resp.text\n        assert 'Some Description Text' in resp.text\n\n        assert 'other' in resp.text\n        assert 'custom value' in resp.text\n\n    def test_custom_template_search(self):\n        \"\"\" Test manually added custom search template search.html\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'pywb custom search page')\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' in resp.text\n\n    def test_add_custom_banner(self):\n        \"\"\" Test adding custom banner.html per-collection template\n        \"\"\"\n\n        banner_file = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                   'templates', 'banner.html')\n\n        with open(banner_file, 'w+b') as fh:\n            fh.write(b'<div>Custom Banner Here!</div>')\n            fh.write(b'\\n{{ metadata | tojson }}')\n\n    def test_add_custom_banner_replay(self, fmod):\n        resp = self.get('/test/20140103030321/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n\n    def test_more_custom_templates(self):\n        \"\"\"\n        Test custom templates and metadata\n        Template is relative to collection-specific dir\n        Add custom metadata and test its presence in custom search page\n        \"\"\"\n        custom_search = os.path.join(self.root_dir, COLLECTIONS, 'test',\n                                      'templates', 'search.html')\n\n        # add metadata\n        main(['metadata', 'test', '--set', 'some=value'])\n\n        with open(custom_search, 'w+b') as fh:\n            fh.write(b'overriden search page: ')\n            fh.write(b'{{ metadata | tojson }}\\n')\n\n        # force clear of jinja env cache to reload\n        self.app.rewriterapp.jinja_env.jinja_env.cache = {}\n\n        resp = self.testapp.get('/test/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'overriden search page: ' in resp.text\n        #assert '\"some\":\"value\"' in resp.text, resp.text\n        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n\n    def test_replay_banner_metadata(self, fmod):\n        \"\"\" Test adding metadata in replay banner (both framed and non-frame)\n        \"\"\"\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert '<div>Custom Banner Here!</div>' in resp.text\n        #assert '\"some\":\"value\"' in resp.text\n        assert '{&#34;some&#34;:&#34;value&#34;}' in resp.text, resp.text\n\n    def test_more_custom_templates_replay(self, fmod):\n        resp = self.get('/test/20140103030321{0}/http://example.com/?example=1', fmod)\n        assert resp.status_int == 200\n\n    def test_add_default_coll_templates(self):\n        \"\"\" Test add default templates: collection,\n        and overwrite collection template\n        \"\"\"\n        # list\n        main(['template', 'foo', '--list'])\n\n        # Add collection template\n        main(['template', 'foo', '--add', 'query_html'])\n        assert os.path.isfile(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates', 'query.html'))\n\n        # overwrite -- force\n        main(['template', 'foo', '--add', 'query_html', '-f'])\n\n    def test_add_modify_home_template(self):\n        # Add shared template\n        main(['template', '--add', 'home_html'])\n\n        filename = os.path.join(self.root_dir, 'templates', 'index.html')\n        assert os.path.isfile(filename)\n\n        with open(filename, 'r+b') as fh:\n            buf = fh.read()\n            buf = buf.replace(b'Pywb Wayback Machine', b'Custom Test Homepage')\n            fh.seek(0)\n            fh.write(buf)\n\n        resp = self.testapp.get('/')\n        resp.charset = 'utf-8'\n        assert resp.content_type == 'text/html'\n        assert 'Custom Test Homepage' in resp.text, resp.text\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'y')\n    def test_add_template_input_yes(self):\n        \"\"\" Test answer 'yes' to overwrite\n        \"\"\"\n        main(['template', 'foo', '--add', 'query_html'])\n\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'n')\n    def test_add_template_input_no(self):\n        \"\"\" Test answer 'no' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'other')\n    def test_add_template_input_other(self):\n        \"\"\" Test answer 'other' to overwrite\n        \"\"\"\n        with raises(IOError):\n            main(['template', 'foo', '--add', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'no')\n    def test_remove_not_confirm(self):\n        \"\"\" Test answer 'no' to remove\n        \"\"\"\n        # don't remove -- not confirmed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    @patch('pywb.manager.manager.get_input', lambda x: 'yes')\n    def test_remove_confirm(self):\n        # remove -- confirm\n        main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_no_templates(self):\n        \"\"\" Test removing templates dir, using default template again\n        \"\"\"\n        shutil.rmtree(os.path.join(self.root_dir, COLLECTIONS, 'foo', 'templates'))\n\n        resp = self.testapp.get('/foo/')\n        resp.charset = 'utf-8'\n        assert resp.status_int == 200\n        assert resp.content_type == 'text/html'\n        assert 'pywb custom search page' not in resp.text\n\n    def test_list_colls(self):\n        \"\"\" Test collection listing, printed to stdout\n        \"\"\"\n        orig_stdout = sys.stdout\n        buff = StringIO()\n        sys.stdout = buff\n\n        try:\n            main(['list'])\n        finally:\n            sys.stdout = orig_stdout\n\n        output = sorted(buff.getvalue().splitlines())\n        assert len(output) == 4\n        assert 'Collections:' in output\n        assert '- foo' in output\n        assert '- nested' in output\n        assert '- test' in output\n\n    def test_convert_cdx(self):\n        \"\"\" Create non-surt cdx, then convert to cdxj\n        \"\"\"\n        migrate_dir = os.path.join(self.root_dir, '_migrate')\n\n        os.mkdir(migrate_dir)\n\n        cdxindexer_main(['-u', '-o', migrate_dir, self._get_sample_warc('')])\n\n        # try one file with -9\n        cdxindexer_main(['-u', '-9', '-o', migrate_dir, self._get_sample_warc('example.warc.gz')])\n\n        cdxs = os.listdir(migrate_dir)\n        assert all(x.endswith('.cdx') for x in cdxs)\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'blah')\n        def do_migrate_no():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_no()\n        assert os.listdir(migrate_dir) == cdxs\n\n        @patch('pywb.manager.manager.get_input', lambda x: 'y')\n        def do_migrate_yes():\n            main(['cdx-convert', migrate_dir])\n\n        do_migrate_yes()\n        cdxjs = os.listdir(migrate_dir)\n\n        assert len(cdxs) == len(cdxjs)\n        assert all(x.endswith('.cdxj') for x in cdxjs)\n\n        with open(os.path.join(migrate_dir, 'iana.cdxj'), 'rb') as fh:\n            cdx = CDXObject(fh.readline())\n            assert cdx['urlkey'] == 'org,iana)/'\n            assert cdx['timestamp'] == '20140126200624'\n            assert cdx['url'] == 'http://www.iana.org/'\n            #assert fh.readline().startswith('org,iana)/ 20140126200624 {\"url\": \"http://www.iana.org/\",')\n\n        # Nothing else to migrate\n        main(['cdx-convert', migrate_dir])\n\n    def test_auto_index(self):\n        main(['init', 'auto'])\n        auto_dir = os.path.join(self.root_dir, COLLECTIONS, 'auto')\n        archive_dir = os.path.join(auto_dir, ARCHIVE_DIR)\n\n        archive_sub_dir = os.path.join(archive_dir, 'sub')\n        os.makedirs(archive_sub_dir)\n\n        def do_copy():\n            try:\n                time.sleep(1.0)\n                shutil.copy(self._get_sample_warc('example.warc.gz'), archive_dir)\n                shutil.copy(self._get_sample_warc('example-extra.warc'), archive_sub_dir)\n                time.sleep(1.0)\n            finally:\n                indexer.interval = 0\n\n        indexer = AutoIndexer(interval=0.25)\n        indexer.start()\n\n        ge = gevent.spawn(do_copy)\n        ge.join()\n\n        index_file = os.path.join(auto_dir, INDEX_DIR, AUTOINDEX_FILE)\n        assert os.path.isfile(index_file)\n\n        with open(index_file, 'r') as fh:\n            index = fh.read()\n\n        assert '\"example.warc.gz' in index, index\n        assert '\"sub/example-extra.warc' in index, index\n\n        mtime = os.path.getmtime(index_file)\n\n        # Update\n        indexer.interval = 0.25\n        indexer.start()\n\n        os.remove(index_file)\n\n        #thread = threading.Thread(target=do_copy)\n        #thread.daemon = True\n        #thread.start()\n        ge = gevent.spawn(do_copy)\n\n        #wayback(['-p', '0', '-a', '--auto-interval', '0.25'])\n\n        #thread.join()\n        ge.join()\n\n\t# assert file was update\n        assert os.path.getmtime(index_file) > mtime\n\n    def test_err_template_remove(self):\n        \"\"\" Test various error conditions for templates:\n        invalid template name, no collection for collection template\n        no template file found\n        \"\"\"\n        # no such template\n        with raises(KeyError):\n            main(['template', 'foo', '--remove', 'blah_html'])\n\n        # collection needed\n        with raises(IOError):\n            main(['template', '--remove', 'query_html'])\n\n        # already removed\n        with raises(IOError):\n            main(['template', 'foo', '--remove', 'query_html'])\n\n    def test_err_no_such_coll(self):\n        \"\"\" Test error adding warc to non-existant collection\n        \"\"\"\n        warc1 = self._get_sample_warc('example.warc.gz')\n\n        with raises(IOError):\n            main(['add', 'bar', warc1])\n\n    def test_err_wrong_warcs(self):\n        warc1 = self._get_sample_warc('example.warc.gz')\n        invalid_warc = os.path.join(self.root_dir, COLLECTIONS, 'test', ARCHIVE_DIR, 'invalid.warc.gz')\n\n        # Empty warc list, argparse calls exit\n        with raises(SystemExit):\n            main(['index', 'test'])\n\n        # Wrong paths not in collection\n        with raises(IOError):\n            main(['index', 'test', warc1])\n\n        # Non-existent\n        with raises(IOError):\n            main(['index', 'test', invalid_warc])\n\n    def test_err_invalid_name(self):\n        \"\"\" Invalid collection name\n        \"\"\"\n        with raises(ValueError):\n            main(['init', '../abc%'])\n\n        with raises(ValueError):\n            main(['init', '45^23'])\n\n    def test_err_missing_dirs(self):\n        \"\"\" Test various errors with missing warcs dir,\n        missing cdx dir, non dir cdx file, and missing collections root\n        \"\"\"\n        colls = os.path.join(self.root_dir, COLLECTIONS)\n\n        # No Statics -- ignorable\n        shutil.rmtree(os.path.join(colls, 'foo', 'static'))\n\n        # No WARCS\n        warcs_path = os.path.join(colls, 'foo', ARCHIVE_DIR)\n        shutil.rmtree(warcs_path)\n\n        with raises(IOError):\n            main(['add', 'foo', 'somewarc'])\n\n        # No CDX\n        cdx_path = os.path.join(colls, 'foo', INDEX_DIR)\n        shutil.rmtree(cdx_path)\n\n        # CDX a file not a dir\n        with open(cdx_path, 'w+b') as fh:\n            fh.write(b'foo\\n')\n\n        shutil.rmtree(colls)\n\n        # No Collections to list\n        with raises(IOError):\n            main(['list'])\n\n        # No Collections\n        resp = self.testapp.get('/test/', status=404)\n        assert resp.status_int == 404", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
