{"index": 8900, "cve_id": "CVE-2022-3355", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Cross-site Scripting (XSS) - Stored in GitHub repository inventree/inventree prior to 0.8.3.", "cvss": "4.3", "publish_date": "September 29, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "5a08ef908dd5344b4433436a4679d122f7f99e41", "commit_message": "Add sanitation for SVG attachments (#3701)\n\n* add svg parser\r\n\r\n* move svg sanitation out into own file\r\n\r\n* move allowed elements out\r\n\r\n* add test for svg sanitation\r\n\r\n* make allowed elements configureable", "commit_date": "2022-09-23T06:56:29Z", "project": "inventree/inventree", "url": "https://api.github.com/repos/inventree/InvenTree/commits/5a08ef908dd5344b4433436a4679d122f7f99e41", "html_url": "https://github.com/inventree/InvenTree/commit/5a08ef908dd5344b4433436a4679d122f7f99e41", "windows_before": [{"commit_id": "db3d9b551acfa5d6ea7b9b3fb21ec926bedcc0c3", "commit_date": "Thu Sep 22 09:30:04 2022 +1000", "commit_message": "Cleanup javascript console log messages (#3706)", "files_name": ["InvenTree/InvenTree/static/script/inventree/inventree.js", "InvenTree/templates/js/dynamic/nav.js"]}, {"commit_id": "829a9d8311307aed092c554ae128773d4c9d2c75", "commit_date": "Wed Sep 21 23:31:24 2022 +1000", "commit_message": "Parameter ordering fix (#3704)", "files_name": ["InvenTree/part/api.py", "InvenTree/part/serializers.py", "InvenTree/part/templates/part/detail.html", "InvenTree/templates/js/translated/part.js"]}, {"commit_id": "33326f6eaf3581a7dfcf7c8210f7ac1ac38bdc99", "commit_date": "Wed Sep 21 18:19:31 2022 +1000", "commit_message": "Update CompleteBuildOrder form (#3702)", "files_name": ["InvenTree/build/serializers.py", "InvenTree/build/templates/build/build_base.html", "InvenTree/templates/js/translated/build.js"]}, {"commit_id": "2a846c7030ede0fcc0eda0df9f71ea0ddd3b7289", "commit_date": "Wed Sep 21 14:01:30 2022 +1000", "commit_message": "Only limit length of link if specified (#3700)", "files_name": ["InvenTree/templates/js/translated/helpers.js"]}, {"commit_id": "2129eecf24ab6fde1a7f83d3a27c5f4e2a40ed90", "commit_date": "Wed Sep 21 12:51:28 2022 +1000", "commit_message": "New Crowdin updates (#3693)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/da/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/en/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/es_MX/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/pt_br/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "e6225bd8b5e6a15151aed7dc3b1b5fa3d106a6d8", "commit_date": "Wed Sep 21 11:59:54 2022 +1000", "commit_message": "Form field sanitization (#3699)", "files_name": ["InvenTree/InvenTree/static/css/inventree.css", "InvenTree/templates/js/translated/forms.js", "InvenTree/templates/js/translated/helpers.js", "InvenTree/templates/js/translated/part.js"]}, {"commit_id": "04b3f022a0f074a16ead2a6cc2e232042581206c", "commit_date": "Tue Sep 20 19:02:08 2022 +1000", "commit_message": "Path name bug fix (#3694)", "files_name": ["InvenTree/InvenTree/helpers.py", "InvenTree/InvenTree/models.py", "InvenTree/part/test_category.py", "InvenTree/stock/tests.py"]}, {"commit_id": "06ba4099b3148cecdeb0e47c5c93629fb49b0e86", "commit_date": "Tue Sep 20 18:17:22 2022 +1000", "commit_message": "Short strings (#3695)", "files_name": ["InvenTree/templates/js/translated/build.js", "InvenTree/templates/js/translated/helpers.js", "InvenTree/templates/js/translated/part.js", "InvenTree/templates/js/translated/stock.js", "InvenTree/templates/js/translated/tables.js"]}, {"commit_id": "24f2338d77025c4b4ab3a3dee2543fbb787e436c", "commit_date": "Sun Sep 18 17:40:22 2022 -0700", "commit_message": "Update config_template.yaml (#3689)", "files_name": ["InvenTree/config_template.yaml"]}, {"commit_id": "187707c89259ded328af0b63ce19a8e61ba53d5c", "commit_date": "Thu Sep 15 14:14:51 2022 +1000", "commit_message": "Barcode Refactor (#3640)", "files_name": ["InvenTree/InvenTree/api_version.py", "InvenTree/InvenTree/helpers.py", "InvenTree/InvenTree/models.py", "InvenTree/InvenTree/tests.py", "InvenTree/build/models.py", "InvenTree/company/migrations/0048_auto_20220913_0312.py", "InvenTree/company/models.py", "InvenTree/company/templates/company/supplier_part.html", "InvenTree/company/urls.py", "InvenTree/company/views.py", "InvenTree/label/models.py", "InvenTree/order/models.py", "InvenTree/order/serializers.py", "InvenTree/order/test_api.py", "InvenTree/part/migrations/0086_auto_20220912_0007.py", "InvenTree/part/models.py", "InvenTree/part/templates/part/part_base.html", "InvenTree/part/test_part.py", "InvenTree/plugin/base/barcodes/api.py", "InvenTree/plugin/base/barcodes/mixins.py", "InvenTree/plugin/base/barcodes/test_barcode.py", "InvenTree/plugin/builtin/barcodes/inventree_barcode.py", "InvenTree/plugin/builtin/barcodes/test_inventree_barcode.py", "InvenTree/stock/fixtures/stock.yaml", "InvenTree/stock/migrations/0084_auto_20220903_0154.py", "InvenTree/stock/migrations/0085_auto_20220903_0225.py", "InvenTree/stock/migrations/0086_remove_stockitem_uid.py", "InvenTree/stock/migrations/0087_auto_20220912_2341.py", "InvenTree/stock/models.py", "InvenTree/stock/serializers.py", "InvenTree/stock/templates/stock/item_base.html", "InvenTree/stock/templates/stock/location.html", "InvenTree/stock/tests.py", "InvenTree/templates/js/translated/barcode.js"]}, {"commit_id": "7645492cc2e457bc118235d411740478a60fe70f", "commit_date": "Wed Sep 14 17:03:51 2022 +1000", "commit_message": "Adds callback for clipboard button (#3678)", "files_name": ["InvenTree/InvenTree/static/script/inventree/inventree.js"]}, {"commit_id": "3f31d90666375c8add28703c906dcd127b28ad0f", "commit_date": "Wed Sep 14 15:00:37 2022 +1000", "commit_message": "Add support for Danish (#3675)", "files_name": ["InvenTree/InvenTree/settings.py", "InvenTree/locale/da/LC_MESSAGES/django.po"]}, {"commit_id": "6e36ae5f744cb43efa67bd2c2140edad2b435b14", "commit_date": "Wed Sep 14 14:59:08 2022 +1000", "commit_message": "Fix purchase order report template (#3674)", "files_name": ["InvenTree/report/templates/report/inventree_po_report.html"]}, {"commit_id": "b306d2a34a60c453aab57197c895ed7a64651f18", "commit_date": "Fri Sep 9 14:42:52 2022 +1000", "commit_message": "New Crowdin updates (#3646)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/en/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/es_MX/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/pt_br/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "1b479ec0cce277ca871841ffb24c78706a1dd183", "commit_date": "Fri Sep 9 12:43:07 2022 +1000", "commit_message": "PO: Use supplier currency when creating a new extra line (#3666)", "files_name": ["InvenTree/order/templates/order/purchase_order_detail.html"]}, {"commit_id": "c4db308dce00a0d17963b1b53374f8c1f5e4789f", "commit_date": "Thu Sep 8 16:26:07 2022 +1000", "commit_message": "Display more units (#3664)", "files_name": ["InvenTree/part/templates/part/part_base.html", "InvenTree/templates/js/translated/bom.js"]}, {"commit_id": "875dda7e5940340f9eda5116ce846a0c6d139a53", "commit_date": "Thu Sep 8 15:18:43 2022 +1000", "commit_message": "Null units fix (#3663)", "files_name": ["InvenTree/company/templates/company/supplier_part.html", "InvenTree/part/templates/part/part_base.html", "InvenTree/part/templates/part/part_units.html", "InvenTree/part/templates/part/stock_count.html", "InvenTree/stock/templates/stock/item_base.html", "InvenTree/stock/test_views.py", "InvenTree/templates/email/build_order_required_stock.html", "InvenTree/templates/js/translated/company.js", "InvenTree/templates/js/translated/part.js", "InvenTree/templates/js/translated/stock.js"]}, {"commit_id": "b827f14bf6e654c995de263768738c4f277c5cd8", "commit_date": "Thu Sep 8 13:44:53 2022 +1000", "commit_message": "Pack quantity improvements (#3661)", "files_name": ["InvenTree/InvenTree/fields.py", "InvenTree/company/serializers.py", "InvenTree/part/templates/part/part_base.html", "InvenTree/part/templates/part/stock_count.html", "InvenTree/templates/js/translated/company.js", "InvenTree/templates/js/translated/part.js", "InvenTree/templates/js/translated/stock.js"]}, {"commit_id": "2242088f904940d4316864e003ae560cdad6bfd2", "commit_date": "Thu Sep 8 10:20:35 2022 +1000", "commit_message": "Add extra information callout to stock item display (#3658)", "files_name": ["InvenTree/stock/templates/stock/item_base.html"]}, {"commit_id": "198ac9b2756ead6569b673e4169f187fbdcfd0f6", "commit_date": "Thu Sep 8 09:49:14 2022 +1000", "commit_message": "Feature: Supplier part pack size (#3644)", "files_name": ["InvenTree/InvenTree/api_version.py", "InvenTree/company/api.py", "InvenTree/company/migrations/0047_supplierpart_pack_size.py", "InvenTree/company/models.py", "InvenTree/company/serializers.py", "InvenTree/company/templates/company/supplier_part.html", "InvenTree/order/models.py", "InvenTree/order/serializers.py", "InvenTree/order/templates/order/order_base.html", "InvenTree/order/tests.py", "InvenTree/part/filters.py", "InvenTree/part/models.py", "InvenTree/part/test_api.py", "InvenTree/templates/js/translated/company.js", "InvenTree/templates/js/translated/order.js", "InvenTree/templates/js/translated/part.js", "tasks.py"]}, {"commit_id": "890c99842097a323b4288af4cb15250d0d56ce39", "commit_date": "Thu Sep 8 09:49:03 2022 +1000", "commit_message": "Fix part link in stock table (#3657)", "files_name": ["InvenTree/templates/js/translated/stock.js"]}, {"commit_id": "ea60cdc6a8a7eaa5a445148f5067e5c0137c5377", "commit_date": "Wed Sep 7 00:04:06 2022 +1000", "commit_message": "Fix splash screen for maintenance mode 503 page (#3651)", "files_name": []}], "windows_after": [{"commit_id": "a7e4d27d6d81ce13572bd9a95a12ccaa247a3fca", "commit_date": "Sat Sep 24 13:00:12 2022 +1000", "commit_message": "Add user setting for configuring table string length (#3715)", "files_name": ["InvenTree/common/models.py", "InvenTree/templates/InvenTree/settings/user_display.html", "InvenTree/templates/js/translated/helpers.js"]}, {"commit_id": "1b421fb59a5b92acbb546ff0e51bc56a487b3f47", "commit_date": "Sat Sep 24 23:45:56 2022 +1000", "commit_message": "Adds 'consumable' field to BomItem model (#2890)", "files_name": [".github/ISSUE_TEMPLATE/feature_request.yaml", "InvenTree/build/models.py", "InvenTree/build/serializers.py", "InvenTree/part/api.py", "InvenTree/part/migrations/0087_bomitem_consumable.py", "InvenTree/part/models.py", "InvenTree/part/serializers.py", "InvenTree/part/test_bom_export.py", "InvenTree/part/test_bom_item.py", "InvenTree/stock/migrations/0088_remove_stockitem_infinite.py", "InvenTree/stock/models.py", "InvenTree/templates/js/translated/bom.js", "InvenTree/templates/js/translated/build.js", "InvenTree/templates/js/translated/table_filters.js"]}, {"commit_id": "bfbafb99128c2170b5af8f7d36647e9375f67bf8", "commit_date": "Tue Sep 27 12:52:07 2022 +1000", "commit_message": "New Crowdin updates (#3707)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/da/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/en/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/es_MX/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/pt_br/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "fbde70d531d48217847688601922dd9201597da0", "commit_date": "Tue Sep 27 13:30:25 2022 +1000", "commit_message": "Bug fix for multi-level display in BOM table (#3720)", "files_name": ["InvenTree/templates/js/translated/bom.js"]}, {"commit_id": "dce10072efe14c6941377fc76ffad5ac434541d7", "commit_date": "Wed Sep 28 00:53:22 2022 +0200", "commit_message": "Add typecasting to certain settings (#3726)", "files_name": ["InvenTree/InvenTree/config.py", "InvenTree/InvenTree/settings.py"]}, {"commit_id": "7568d2367030996987be028daf0071a2ce853817", "commit_date": "Wed Sep 28 00:56:03 2022 +0200", "commit_message": "APIMixin: Add flag for passing data as json (#3635)", "files_name": ["InvenTree/plugin/base/integration/mixins.py", "InvenTree/plugin/base/integration/test_mixins.py"]}, {"commit_id": "8bcf72fbb2d0f7285cd21a96a03d32703097429f", "commit_date": "Wed Sep 28 10:28:39 2022 +1000", "commit_message": "Barcode scan fix (#3727)", "files_name": ["InvenTree/plugin/builtin/barcodes/inventree_barcode.py", "InvenTree/templates/js/translated/barcode.js"]}, {"commit_id": "a3c9331a087a5d5ddba691149462478d0b9eda56", "commit_date": "Fri Sep 30 02:47:56 2022 +0200", "commit_message": "Add content headers to config (#3731)", "files_name": ["docker/nginx.dev.conf", "docker/production/nginx.prod.conf"]}, {"commit_id": "1f2859d8c92869e4f2836048ff72cecdde95f45e", "commit_date": "Fri Sep 30 15:08:38 2022 +1000", "commit_message": "Bug fix for stock adjustment actions (#3735)", "files_name": ["InvenTree/templates/js/translated/stock.js"]}, {"commit_id": "52071f2c3fc33a2404763648429420a6540c5937", "commit_date": "Sat Oct 1 16:08:32 2022 +1000", "commit_message": "Show placeholder for null IPN values in \"stock\" table (#3737)", "files_name": ["InvenTree/templates/js/translated/stock.js"]}, {"commit_id": "61a6ecdcfa17991220212393988be29c5ce9c72d", "commit_date": "Mon Oct 3 10:04:59 2022 +1100", "commit_message": "New Crowdin updates (#3738)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/da/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "a1c91cfd8e8f9d927c139ba94d40bf808bf9f8b6", "commit_date": "Tue Oct 4 08:29:15 2022 +0200", "commit_message": "remove broken action (#3742)", "files_name": [".github/workflows/welcome.yml"]}, {"commit_id": "b13c5b2c130e55d07bed3764687e31ecd63e0e6e", "commit_date": "Thu Oct 6 13:32:01 2022 +0200", "commit_message": "update pre-commit (#3744)", "files_name": [".pre-commit-config.yaml"]}, {"commit_id": "cfff5ea264fc39dbdc7ad0e5cb7ca19b480e7a08", "commit_date": "Thu Oct 6 13:35:20 2022 +0200", "commit_message": "Last Connection date for user in admin panel (#3747)", "files_name": ["InvenTree/users/admin.py"]}, {"commit_id": "d194aef79e5f7809d45381e9a8b7464bcdab5186", "commit_date": "Fri Oct 7 00:18:11 2022 +1100", "commit_message": "Adds 'status_text' functions to models (#3752)", "files_name": ["InvenTree/build/models.py", "InvenTree/order/models.py", "InvenTree/stock/models.py"]}, {"commit_id": "5d6423fb643e6c6ba1447466aef89af16c627c46", "commit_date": "Fri Oct 7 00:18:38 2022 +1100", "commit_message": "UI fixes for barcode actions (#3751)", "files_name": ["InvenTree/templates/js/translated/barcode.js"]}, {"commit_id": "fbc99257bd9abd4837d2a0f552b1fc948d35fd28", "commit_date": "Thu Oct 6 22:23:53 2022 -0400", "commit_message": "Fixes #3514 (#3754)", "files_name": ["InvenTree/part/templates/part/detail.html"]}, {"commit_id": "cc68cd83a93798600c61f73e2ca71d7b2b5d84af", "commit_date": "Sat Oct 8 23:46:08 2022 +1100", "commit_message": "Bug fix for boolean settings (#3760)", "files_name": ["InvenTree/templates/InvenTree/settings/setting.html", "InvenTree/templates/InvenTree/settings/setting_boolean.html", "InvenTree/templates/InvenTree/settings/settings.html"]}, {"commit_id": "67740581fed8af303f71891331151be0f99b5be0", "commit_date": "Sun Oct 9 09:06:59 2022 +1100", "commit_message": "New Crowdin updates (#3756)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/da/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/en/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/es_MX/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/pt_br/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "c146256170c55b0675e3a4601ca6f7199d659122", "commit_date": "Sun Oct 9 09:07:51 2022 +1100", "commit_message": "Allow auto-loading of plugins in certain conditions (#3762)", "files_name": ["InvenTree/InvenTree/ready.py", "InvenTree/plugin/apps.py"]}, {"commit_id": "86b72549a2cc68a9262e7710e3dfd3e726906ac8", "commit_date": "Tue Oct 11 23:15:24 2022 +1100", "commit_message": "Plugin load fix (#3768)", "files_name": ["InvenTree/plugin/helpers.py", "InvenTree/plugin/plugin.py", "InvenTree/templates/InvenTree/settings/plugin_settings.html"]}, {"commit_id": "1c6eb8096ff25d0b1b7444c731ba8467da07d353", "commit_date": "Wed Oct 12 09:23:41 2022 +1100", "commit_message": "Display build output status code (#3771)", "files_name": ["InvenTree/templates/js/translated/build.js"]}, {"commit_id": "9002a1e5b35b4712cdc938bb3cf691dbf7de8798", "commit_date": "Wed Oct 12 14:07:15 2022 +1100", "commit_message": "New Crowdin updates (#3765)", "files_name": ["InvenTree/locale/cs/LC_MESSAGES/django.po", "InvenTree/locale/da/LC_MESSAGES/django.po", "InvenTree/locale/de/LC_MESSAGES/django.po", "InvenTree/locale/el/LC_MESSAGES/django.po", "InvenTree/locale/en/LC_MESSAGES/django.po", "InvenTree/locale/es/LC_MESSAGES/django.po", "InvenTree/locale/es_MX/LC_MESSAGES/django.po", "InvenTree/locale/fa/LC_MESSAGES/django.po", "InvenTree/locale/fr/LC_MESSAGES/django.po", "InvenTree/locale/he/LC_MESSAGES/django.po", "InvenTree/locale/hu/LC_MESSAGES/django.po", "InvenTree/locale/id/LC_MESSAGES/django.po", "InvenTree/locale/it/LC_MESSAGES/django.po", "InvenTree/locale/ja/LC_MESSAGES/django.po", "InvenTree/locale/ko/LC_MESSAGES/django.po", "InvenTree/locale/nl/LC_MESSAGES/django.po", "InvenTree/locale/no/LC_MESSAGES/django.po", "InvenTree/locale/pl/LC_MESSAGES/django.po", "InvenTree/locale/pt/LC_MESSAGES/django.po", "InvenTree/locale/pt_br/LC_MESSAGES/django.po", "InvenTree/locale/ru/LC_MESSAGES/django.po", "InvenTree/locale/sv/LC_MESSAGES/django.po", "InvenTree/locale/th/LC_MESSAGES/django.po", "InvenTree/locale/tr/LC_MESSAGES/django.po", "InvenTree/locale/vi/LC_MESSAGES/django.po", "InvenTree/locale/zh/LC_MESSAGES/django.po"]}, {"commit_id": "193b69eeb59e0fb8fe431dd1905626b380446067", "commit_date": "Wed Oct 12 16:34:57 2022 +1100", "commit_message": "Adjust display of extra \"add bom item\" button at bottom of BOM table (#3773)", "files_name": ["InvenTree/part/templates/part/detail.html", "InvenTree/templates/js/translated/bom.js"]}], "parents": [{"commit_id_before": "db3d9b551acfa5d6ea7b9b3fb21ec926bedcc0c3", "url_before": "https://api.github.com/repos/inventree/InvenTree/commits/db3d9b551acfa5d6ea7b9b3fb21ec926bedcc0c3", "html_url_before": "https://github.com/inventree/InvenTree/commit/db3d9b551acfa5d6ea7b9b3fb21ec926bedcc0c3"}], "details": [{"raw_url": "https://github.com/inventree/InvenTree/raw/5a08ef908dd5344b4433436a4679d122f7f99e41/InvenTree%2FInvenTree%2Fmodels.py", "code": "\"\"\"Generic models which provide extra functionality over base Django model types.\"\"\"\n\nimport logging\nimport os\nimport re\nfrom datetime import datetime\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.models import User\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.db.models.signals import post_save, pre_delete\nfrom django.dispatch import receiver\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\n\nfrom error_report.models import Error\nfrom mptt.exceptions import InvalidMove\nfrom mptt.models import MPTTModel, TreeForeignKey\n\nimport InvenTree.format\nimport InvenTree.helpers\nfrom common.models import InvenTreeSetting\nfrom InvenTree.fields import InvenTreeURLField\nfrom InvenTree.sanitizer import sanitize_svg\n\nlogger = logging.getLogger('inventree')\n\n\ndef rename_attachment(instance, filename):\n    \"\"\"Function for renaming an attachment file. The subdirectory for the uploaded file is determined by the implementing class.\n\n    Args:\n        instance: Instance of a PartAttachment object\n        filename: name of uploaded file\n\n    Returns:\n        path to store file, format: '<subdir>/<id>/filename'\n    \"\"\"\n    # Construct a path to store a file attachment for a given model type\n    return os.path.join(instance.getSubdir(), filename)\n\n\nclass DataImportMixin(object):\n    \"\"\"Model mixin class which provides support for 'data import' functionality.\n\n    Models which implement this mixin should provide information on the fields available for import\n    \"\"\"\n\n    # Define a map of fields avaialble for import\n    IMPORT_FIELDS = {}\n\n    @classmethod\n    def get_import_fields(cls):\n        \"\"\"Return all available import fields.\n\n        Where information on a particular field is not explicitly provided,\n        introspect the base model to (attempt to) find that information.\n        \"\"\"\n        fields = cls.IMPORT_FIELDS\n\n        for name, field in fields.items():\n\n            # Attempt to extract base field information from the model\n            base_field = None\n\n            for f in cls._meta.fields:\n                if f.name == name:\n                    base_field = f\n                    break\n\n            if base_field:\n                if 'label' not in field:\n                    field['label'] = base_field.verbose_name\n\n                if 'help_text' not in field:\n                    field['help_text'] = base_field.help_text\n\n            fields[name] = field\n\n        return fields\n\n    @classmethod\n    def get_required_import_fields(cls):\n        \"\"\"Return all *required* import fields.\"\"\"\n        fields = {}\n\n        for name, field in cls.get_import_fields().items():\n            required = field.get('required', False)\n\n            if required:\n                fields[name] = field\n\n        return fields\n\n\nclass ReferenceIndexingMixin(models.Model):\n    \"\"\"A mixin for keeping track of numerical copies of the \"reference\" field.\n\n    Here, we attempt to convert a \"reference\" field value (char) to an integer,\n    for performing fast natural sorting.\n\n    This requires extra database space (due to the extra table column),\n    but is required as not all supported database backends provide equivalent casting.\n\n    This mixin adds a field named 'reference_int'.\n\n    - If the 'reference' field can be cast to an integer, it is stored here\n    - If the 'reference' field *starts* with an integer, it is stored here\n    - Otherwise, we store zero\n    \"\"\"\n\n    # Name of the global setting which defines the required reference pattern for this model\n    REFERENCE_PATTERN_SETTING = None\n\n    @classmethod\n    def get_reference_pattern(cls):\n        \"\"\"Returns the reference pattern associated with this model.\n\n        This is defined by a global setting object, specified by the REFERENCE_PATTERN_SETTING attribute\n        \"\"\"\n\n        # By default, we return an empty string\n        if cls.REFERENCE_PATTERN_SETTING is None:\n            return ''\n\n        return InvenTreeSetting.get_setting(cls.REFERENCE_PATTERN_SETTING, create=False).strip()\n\n    @classmethod\n    def get_reference_context(cls):\n        \"\"\"Generate context data for generating the 'reference' field for this class.\n\n        - Returns a python dict object which contains the context data for formatting the reference string.\n        - The default implementation provides some default context information\n        \"\"\"\n\n        return {\n            'ref': cls.get_next_reference(),\n            'date': datetime.now(),\n        }\n\n    @classmethod\n    def get_most_recent_item(cls):\n        \"\"\"Return the item which is 'most recent'\n\n        In practice, this means the item with the highest reference value\n        \"\"\"\n\n        query = cls.objects.all().order_by('-reference_int', '-pk')\n\n        if query.exists():\n            return query.first()\n        else:\n            return None\n\n    @classmethod\n    def get_next_reference(cls):\n        \"\"\"Return the next available reference value for this particular class.\"\"\"\n\n        # Find the \"most recent\" item\n        latest = cls.get_most_recent_item()\n\n        if not latest:\n            # No existing items\n            return 1\n\n        reference = latest.reference.strip\n\n        try:\n            reference = InvenTree.format.extract_named_group('ref', reference, cls.get_reference_pattern())\n        except Exception:\n            # If reference cannot be extracted using the pattern, try just the integer value\n            reference = str(latest.reference_int)\n\n        # Attempt to perform 'intelligent' incrementing of the reference field\n        incremented = InvenTree.helpers.increment(reference)\n\n        try:\n            incremented = int(incremented)\n        except ValueError:\n            pass\n\n        return incremented\n\n    @classmethod\n    def generate_reference(cls):\n        \"\"\"Generate the next 'reference' field based on specified pattern\"\"\"\n\n        fmt = cls.get_reference_pattern()\n        ctx = cls.get_reference_context()\n\n        reference = None\n\n        attempts = set()\n\n        while reference is None:\n            try:\n                ref = fmt.format(**ctx)\n\n                if ref in attempts:\n                    # We are stuck in a loop!\n                    reference = ref\n                    break\n                else:\n                    attempts.add(ref)\n\n                    if cls.objects.filter(reference=ref).exists():\n                        # Handle case where we have duplicated an existing reference\n                        ctx['ref'] = InvenTree.helpers.increment(ctx['ref'])\n                    else:\n                        # We have found an 'unused' reference\n                        reference = ref\n                        break\n\n            except Exception:\n                # If anything goes wrong, return the most recent reference\n                recent = cls.get_most_recent_item()\n                if recent:\n                    reference = recent.reference\n                else:\n                    reference = \"\"\n\n        return reference\n\n    @classmethod\n    def validate_reference_pattern(cls, pattern):\n        \"\"\"Ensure that the provided pattern is valid\"\"\"\n\n        ctx = cls.get_reference_context()\n\n        try:\n            info = InvenTree.format.parse_format_string(pattern)\n        except Exception:\n            raise ValidationError({\n                \"value\": _(\"Improperly formatted pattern\"),\n            })\n\n        # Check that only 'allowed' keys are provided\n        for key in info.keys():\n            if key not in ctx.keys():\n                raise ValidationError({\n                    \"value\": _(\"Unknown format key specified\") + f\": '{key}'\"\n                })\n\n        # Check that the 'ref' variable is specified\n        if 'ref' not in info.keys():\n            raise ValidationError({\n                'value': _(\"Missing required format key\") + \": 'ref'\"\n            })\n\n    @classmethod\n    def validate_reference_field(cls, value):\n        \"\"\"Check that the provided 'reference' value matches the requisite pattern\"\"\"\n\n        pattern = cls.get_reference_pattern()\n\n        value = str(value).strip()\n\n        if len(value) == 0:\n            raise ValidationError(_(\"Reference field cannot be empty\"))\n\n        # An 'empty' pattern means no further validation is required\n        if not pattern:\n            return\n\n        if not InvenTree.format.validate_string(value, pattern):\n            raise ValidationError(_(\"Reference must match required pattern\") + \": \" + pattern)\n\n        # Check that the reference field can be rebuild\n        cls.rebuild_reference_field(value, validate=True)\n\n    class Meta:\n        \"\"\"Metaclass options. Abstract ensures no database table is created.\"\"\"\n\n        abstract = True\n\n    @classmethod\n    def rebuild_reference_field(cls, reference, validate=False):\n        \"\"\"Extract integer out of reference for sorting.\n\n        If the 'integer' portion is buried somewhere 'within' the reference,\n        we can first try to extract it using the pattern.\n\n        Example:\n        reference - BO-123-ABC\n        pattern - BO-{ref}-???\n        extracted - 123\n\n        If we cannot extract using the pattern for some reason, fallback to the entire reference\n        \"\"\"\n\n        try:\n            # Extract named group based on provided pattern\n            reference = InvenTree.format.extract_named_group('ref', reference, cls.get_reference_pattern())\n        except Exception:\n            pass\n\n        reference_int = extract_int(reference)\n\n        if validate:\n            if reference_int > models.BigIntegerField.MAX_BIGINT:\n                raise ValidationError({\n                    \"reference\": _(\"Reference number is too large\")\n                })\n\n        return reference_int\n\n    reference_int = models.BigIntegerField(default=0)\n\n\ndef extract_int(reference, clip=0x7fffffff, allow_negative=False):\n    \"\"\"Extract an integer out of reference.\"\"\"\n\n    # Default value if we cannot convert to an integer\n    ref_int = 0\n\n    reference = str(reference).strip()\n\n    # Ignore empty string\n    if len(reference) == 0:\n        return 0\n\n    # Look at the start of the string - can it be \"integerized\"?\n    result = re.match(r\"^(\\d+)\", reference)\n\n    if result and len(result.groups()) == 1:\n        ref = result.groups()[0]\n        try:\n            ref_int = int(ref)\n        except Exception:\n            ref_int = 0\n    else:\n        # Look at the \"end\" of the string\n        result = re.search(r'(\\d+)$', reference)\n\n        if result and len(result.groups()) == 1:\n            ref = result.groups()[0]\n            try:\n                ref_int = int(ref)\n            except Exception:\n                ref_int = 0\n\n    # Ensure that the returned values are within the range that can be stored in an IntegerField\n    # Note: This will result in large values being \"clipped\"\n    if clip is not None:\n        if ref_int > clip:\n            ref_int = clip\n        elif ref_int < -clip:\n            ref_int = -clip\n\n    if not allow_negative and ref_int < 0:\n        ref_int = abs(ref_int)\n\n    return ref_int\n\n\nclass InvenTreeAttachment(models.Model):\n    \"\"\"Provides an abstracted class for managing file attachments.\n\n    An attachment can be either an uploaded file, or an external URL\n\n    Attributes:\n        attachment: File\n        comment: String descriptor for the attachment\n        user: User associated with file upload\n        upload_date: Date the file was uploaded\n    \"\"\"\n\n    def getSubdir(self):\n        \"\"\"Return the subdirectory under which attachments should be stored.\n\n        Note: Re-implement this for each subclass of InvenTreeAttachment\n        \"\"\"\n        return \"attachments\"\n\n    def save(self, *args, **kwargs):\n        \"\"\"Provide better validation error.\"\"\"\n        # Either 'attachment' or 'link' must be specified!\n        if not self.attachment and not self.link:\n            raise ValidationError({\n                'attachment': _('Missing file'),\n                'link': _('Missing external link'),\n            })\n\n        if self.attachment.name.lower().endswith('.svg'):\n            self.attachment.file.file = self.clean_svg(self.attachment)\n\n        super().save(*args, **kwargs)\n\n    def clean_svg(self, field):\n        \"\"\"Sanitize SVG file before saving.\"\"\"\n        cleaned = sanitize_svg(field.file.read())\n        return BytesIO(bytes(cleaned, 'utf8'))\n\n    def __str__(self):\n        \"\"\"Human name for attachment.\"\"\"\n        if self.attachment is not None:\n            return os.path.basename(self.attachment.name)\n        else:\n            return str(self.link)\n\n    attachment = models.FileField(upload_to=rename_attachment, verbose_name=_('Attachment'),\n                                  help_text=_('Select file to attach'),\n                                  blank=True, null=True\n                                  )\n\n    link = InvenTreeURLField(\n        blank=True, null=True,\n        verbose_name=_('Link'),\n        help_text=_('Link to external URL')\n    )\n\n    comment = models.CharField(blank=True, max_length=100, verbose_name=_('Comment'), help_text=_('File comment'))\n\n    user = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        blank=True, null=True,\n        verbose_name=_('User'),\n        help_text=_('User'),\n    )\n\n    upload_date = models.DateField(auto_now_add=True, null=True, blank=True, verbose_name=_('upload date'))\n\n    @property\n    def basename(self):\n        \"\"\"Base name/path for attachment.\"\"\"\n        if self.attachment:\n            return os.path.basename(self.attachment.name)\n        else:\n            return None\n\n    @basename.setter\n    def basename(self, fn):\n        \"\"\"Function to rename the attachment file.\n\n        - Filename cannot be empty\n        - Filename cannot contain illegal characters\n        - Filename must specify an extension\n        - Filename cannot match an existing file\n        \"\"\"\n        fn = fn.strip()\n\n        if len(fn) == 0:\n            raise ValidationError(_('Filename must not be empty'))\n\n        attachment_dir = settings.MEDIA_ROOT.joinpath(self.getSubdir())\n        old_file = settings.MEDIA_ROOT.joinpath(self.attachment.name)\n        new_file = settings.MEDIA_ROOT.joinpath(self.getSubdir(), fn).resolve()\n\n        # Check that there are no directory tricks going on...\n        if new_file.parent != attachment_dir:\n            logger.error(f\"Attempted to rename attachment outside valid directory: '{new_file}'\")\n            raise ValidationError(_(\"Invalid attachment directory\"))\n\n        # Ignore further checks if the filename is not actually being renamed\n        if new_file == old_file:\n            return\n\n        forbidden = [\"'\", '\"', \"#\", \"@\", \"!\", \"&\", \"^\", \"<\", \">\", \":\", \";\", \"/\", \"\\\\\", \"|\", \"?\", \"*\", \"%\", \"~\", \"`\"]\n\n        for c in forbidden:\n            if c in fn:\n                raise ValidationError(_(f\"Filename contains illegal character '{c}'\"))\n\n        if len(fn.split('.')) < 2:\n            raise ValidationError(_(\"Filename missing extension\"))\n\n        if not old_file.exists():\n            logger.error(f\"Trying to rename attachment '{old_file}' which does not exist\")\n            return\n\n        if new_file.exists():\n            raise ValidationError(_(\"Attachment with this filename already exists\"))\n\n        try:\n            os.rename(old_file, new_file)\n            self.attachment.name = os.path.join(self.getSubdir(), fn)\n            self.save()\n        except Exception:\n            raise ValidationError(_(\"Error renaming file\"))\n\n    class Meta:\n        \"\"\"Metaclass options. Abstract ensures no database table is created.\"\"\"\n\n        abstract = True\n\n\nclass InvenTreeTree(MPTTModel):\n    \"\"\"Provides an abstracted self-referencing tree model for data categories.\n\n    - Each Category has one parent Category, which can be blank (for a top-level Category).\n    - Each Category can have zero-or-more child Categor(y/ies)\n\n    Attributes:\n        name: brief name\n        description: longer form description\n        parent: The item immediately above this one. An item with a null parent is a top-level item\n    \"\"\"\n\n    def api_instance_filters(self):\n        \"\"\"Instance filters for InvenTreeTree models.\"\"\"\n        return {\n            'parent': {\n                'exclude_tree': self.pk,\n            }\n        }\n\n    def save(self, *args, **kwargs):\n        \"\"\"Custom save method for InvenTreeTree abstract model\"\"\"\n\n        try:\n            super().save(*args, **kwargs)\n        except InvalidMove:\n            # Provide better error for parent selection\n            raise ValidationError({\n                'parent': _(\"Invalid choice\"),\n            })\n\n        # Re-calculate the 'pathstring' field\n        pathstring = InvenTree.helpers.constructPathString(\n            [item.name for item in self.path]\n        )\n\n        if pathstring != self.pathstring:\n\n            if 'force_insert' in kwargs:\n                del kwargs['force_insert']\n\n            kwargs['force_update'] = True\n\n            self.pathstring = pathstring\n            super().save(*args, **kwargs)\n\n            # Ensure that the pathstring changes are propagated down the tree also\n            for child in self.get_children():\n                child.save(*args, **kwargs)\n\n    class Meta:\n        \"\"\"Metaclass defines extra model properties.\"\"\"\n\n        abstract = True\n\n        # Names must be unique at any given level in the tree\n        unique_together = ('name', 'parent')\n\n    class MPTTMeta:\n        \"\"\"Set insert order.\"\"\"\n        order_insertion_by = ['name']\n\n    name = models.CharField(\n        blank=False,\n        max_length=100,\n        verbose_name=_(\"Name\"),\n        help_text=_(\"Name\"),\n    )\n\n    description = models.CharField(\n        blank=True,\n        max_length=250,\n        verbose_name=_(\"Description\"),\n        help_text=_(\"Description (optional)\")\n    )\n\n    # When a category is deleted, graft the children onto its parent\n    parent = TreeForeignKey('self',\n                            on_delete=models.DO_NOTHING,\n                            blank=True,\n                            null=True,\n                            verbose_name=_(\"parent\"),\n                            related_name='children')\n\n    # The 'pathstring' field is calculated each time the model is saved\n    pathstring = models.CharField(\n        blank=True,\n        max_length=250,\n        verbose_name=_('Path'),\n        help_text=_('Path')\n    )\n\n    @property\n    def item_count(self):\n        \"\"\"Return the number of items which exist *under* this node in the tree.\n\n        Here an 'item' is considered to be the 'leaf' at the end of each branch,\n        and the exact nature here will depend on the class implementation.\n\n        The default implementation returns zero\n        \"\"\"\n        return 0\n\n    def getUniqueParents(self):\n        \"\"\"Return a flat set of all parent items that exist above this node.\n\n        If any parents are repeated (which would be very bad!), the process is halted\n        \"\"\"\n        return self.get_ancestors()\n\n    def getUniqueChildren(self, include_self=True):\n        \"\"\"Return a flat set of all child items that exist under this node.\n\n        If any child items are repeated, the repetitions are omitted.\n        \"\"\"\n        return self.get_descendants(include_self=include_self)\n\n    @property\n    def has_children(self):\n        \"\"\"True if there are any children under this item.\"\"\"\n        return self.getUniqueChildren(include_self=False).count() > 0\n\n    def getAcceptableParents(self):\n        \"\"\"Returns a list of acceptable parent items within this model Acceptable parents are ones which are not underneath this item.\n\n        Setting the parent of an item to its own child results in recursion.\n        \"\"\"\n        contents = ContentType.objects.get_for_model(type(self))\n\n        available = contents.get_all_objects_for_this_type()\n\n        # List of child IDs\n        childs = self.getUniqueChildren()\n\n        acceptable = [None]\n\n        for a in available:\n            if a.id not in childs:\n                acceptable.append(a)\n\n        return acceptable\n\n    @property\n    def parentpath(self):\n        \"\"\"Get the parent path of this category.\n\n        Returns:\n            List of category names from the top level to the parent of this category\n        \"\"\"\n        return [a for a in self.get_ancestors()]\n\n    @property\n    def path(self):\n        \"\"\"Get the complete part of this category.\n\n        e.g. [\"Top\", \"Second\", \"Third\", \"This\"]\n\n        Returns:\n            List of category names from the top level to this category\n        \"\"\"\n        return self.parentpath + [self]\n\n    def __str__(self):\n        \"\"\"String representation of a category is the full path to that category.\"\"\"\n        return \"{path} - {desc}\".format(path=self.pathstring, desc=self.description)\n\n\nclass InvenTreeBarcodeMixin(models.Model):\n    \"\"\"A mixin class for adding barcode functionality to a model class.\n\n    Two types of barcodes are supported:\n\n    - Internal barcodes (QR codes using a strictly defined format)\n    - External barcodes (assign third party barcode data to a model instance)\n\n    The following fields are added to any model which implements this mixin:\n\n    - barcode_data : Raw data associated with an assigned barcode\n    - barcode_hash : A 'hash' of the assigned barcode data used to improve matching\n    \"\"\"\n\n    class Meta:\n        \"\"\"Metaclass options for this mixin.\n\n        Note: abstract must be true, as this is only a mixin, not a separate table\n        \"\"\"\n        abstract = True\n\n    barcode_data = models.CharField(\n        blank=True, max_length=500,\n        verbose_name=_('Barcode Data'),\n        help_text=_('Third party barcode data'),\n    )\n\n    barcode_hash = models.CharField(\n        blank=True, max_length=128,\n        verbose_name=_('Barcode Hash'),\n        help_text=_('Unique hash of barcode data')\n    )\n\n    @classmethod\n    def barcode_model_type(cls):\n        \"\"\"Return the model 'type' for creating a custom QR code.\"\"\"\n\n        # By default, use the name of the class\n        return cls.__name__.lower()\n\n    def format_barcode(self, **kwargs):\n        \"\"\"Return a JSON string for formatting a QR code for this model instance.\"\"\"\n\n        return InvenTree.helpers.MakeBarcode(\n            self.__class__.barcode_model_type(),\n            self.pk,\n            **kwargs\n        )\n\n    @property\n    def barcode(self):\n        \"\"\"Format a minimal barcode string (e.g. for label printing)\"\"\"\n\n        return self.format_barcode(brief=True)\n\n    @classmethod\n    def lookup_barcode(cls, barcode_hash):\n        \"\"\"Check if a model instance exists with the specified third-party barcode hash.\"\"\"\n\n        return cls.objects.filter(barcode_hash=barcode_hash).first()\n\n    def assign_barcode(self, barcode_hash=None, barcode_data=None, raise_error=True):\n        \"\"\"Assign an external (third-party) barcode to this object.\"\"\"\n\n        # Must provide either barcode_hash or barcode_data\n        if barcode_hash is None and barcode_data is None:\n            raise ValueError(\"Provide either 'barcode_hash' or 'barcode_data'\")\n\n        # If barcode_hash is not provided, create from supplier barcode_data\n        if barcode_hash is None:\n            barcode_hash = InvenTree.helpers.hash_barcode(barcode_data)\n\n        # Check for existing item\n        if self.__class__.lookup_barcode(barcode_hash) is not None:\n            if raise_error:\n                raise ValidationError(_(\"Existing barcode found\"))\n            else:\n                return False\n\n        if barcode_data is not None:\n            self.barcode_data = barcode_data\n\n        self.barcode_hash = barcode_hash\n\n        self.save()\n\n        return True\n\n    def unassign_barcode(self):\n        \"\"\"Unassign custom barcode from this model\"\"\"\n\n        self.barcode_data = ''\n        self.barcode_hash = ''\n\n        self.save()\n\n\n@receiver(pre_delete, sender=InvenTreeTree, dispatch_uid='tree_pre_delete_log')\ndef before_delete_tree_item(sender, instance, using, **kwargs):\n    \"\"\"Receives pre_delete signal from InvenTreeTree object.\n\n    Before an item is deleted, update each child object to point to the parent of the object being deleted.\n    \"\"\"\n    # Update each tree item below this one\n    for child in instance.children.all():\n        child.parent = instance.parent\n        child.save()\n\n\n@receiver(post_save, sender=Error, dispatch_uid='error_post_save_notification')\ndef after_error_logged(sender, instance: Error, created: bool, **kwargs):\n    \"\"\"Callback when a server error is logged.\n\n    - Send a UI notification to all users with staff status\n    \"\"\"\n\n    if created:\n        try:\n            import common.notifications\n\n            users = get_user_model().objects.filter(is_staff=True)\n\n            link = InvenTree.helpers.construct_absolute_url(\n                reverse('admin:error_report_error_change', kwargs={'object_id': instance.pk})\n            )\n\n            context = {\n                'error': instance,\n                'name': _('Server Error'),\n                'message': _('An error has been logged by the server.'),\n                'link': link\n            }\n\n            common.notifications.trigger_notification(\n                instance,\n                'inventree.error_log',\n                context=context,\n                targets=users,\n                delivery_methods=set([common.notifications.UIMessageNotification]),\n            )\n\n        except Exception as exc:\n            \"\"\"We do not want to throw an exception while reporting an exception\"\"\"\n            logger.error(exc)\n", "code_before": "\"\"\"Generic models which provide extra functionality over base Django model types.\"\"\"\n\nimport logging\nimport os\nimport re\nfrom datetime import datetime\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.models import User\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.db.models.signals import post_save, pre_delete\nfrom django.dispatch import receiver\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\n\nfrom error_report.models import Error\nfrom mptt.exceptions import InvalidMove\nfrom mptt.models import MPTTModel, TreeForeignKey\n\nimport InvenTree.format\nimport InvenTree.helpers\nfrom common.models import InvenTreeSetting\nfrom InvenTree.fields import InvenTreeURLField\n\nlogger = logging.getLogger('inventree')\n\n\ndef rename_attachment(instance, filename):\n    \"\"\"Function for renaming an attachment file. The subdirectory for the uploaded file is determined by the implementing class.\n\n    Args:\n        instance: Instance of a PartAttachment object\n        filename: name of uploaded file\n\n    Returns:\n        path to store file, format: '<subdir>/<id>/filename'\n    \"\"\"\n    # Construct a path to store a file attachment for a given model type\n    return os.path.join(instance.getSubdir(), filename)\n\n\nclass DataImportMixin(object):\n    \"\"\"Model mixin class which provides support for 'data import' functionality.\n\n    Models which implement this mixin should provide information on the fields available for import\n    \"\"\"\n\n    # Define a map of fields avaialble for import\n    IMPORT_FIELDS = {}\n\n    @classmethod\n    def get_import_fields(cls):\n        \"\"\"Return all available import fields.\n\n        Where information on a particular field is not explicitly provided,\n        introspect the base model to (attempt to) find that information.\n        \"\"\"\n        fields = cls.IMPORT_FIELDS\n\n        for name, field in fields.items():\n\n            # Attempt to extract base field information from the model\n            base_field = None\n\n            for f in cls._meta.fields:\n                if f.name == name:\n                    base_field = f\n                    break\n\n            if base_field:\n                if 'label' not in field:\n                    field['label'] = base_field.verbose_name\n\n                if 'help_text' not in field:\n                    field['help_text'] = base_field.help_text\n\n            fields[name] = field\n\n        return fields\n\n    @classmethod\n    def get_required_import_fields(cls):\n        \"\"\"Return all *required* import fields.\"\"\"\n        fields = {}\n\n        for name, field in cls.get_import_fields().items():\n            required = field.get('required', False)\n\n            if required:\n                fields[name] = field\n\n        return fields\n\n\nclass ReferenceIndexingMixin(models.Model):\n    \"\"\"A mixin for keeping track of numerical copies of the \"reference\" field.\n\n    Here, we attempt to convert a \"reference\" field value (char) to an integer,\n    for performing fast natural sorting.\n\n    This requires extra database space (due to the extra table column),\n    but is required as not all supported database backends provide equivalent casting.\n\n    This mixin adds a field named 'reference_int'.\n\n    - If the 'reference' field can be cast to an integer, it is stored here\n    - If the 'reference' field *starts* with an integer, it is stored here\n    - Otherwise, we store zero\n    \"\"\"\n\n    # Name of the global setting which defines the required reference pattern for this model\n    REFERENCE_PATTERN_SETTING = None\n\n    @classmethod\n    def get_reference_pattern(cls):\n        \"\"\"Returns the reference pattern associated with this model.\n\n        This is defined by a global setting object, specified by the REFERENCE_PATTERN_SETTING attribute\n        \"\"\"\n\n        # By default, we return an empty string\n        if cls.REFERENCE_PATTERN_SETTING is None:\n            return ''\n\n        return InvenTreeSetting.get_setting(cls.REFERENCE_PATTERN_SETTING, create=False).strip()\n\n    @classmethod\n    def get_reference_context(cls):\n        \"\"\"Generate context data for generating the 'reference' field for this class.\n\n        - Returns a python dict object which contains the context data for formatting the reference string.\n        - The default implementation provides some default context information\n        \"\"\"\n\n        return {\n            'ref': cls.get_next_reference(),\n            'date': datetime.now(),\n        }\n\n    @classmethod\n    def get_most_recent_item(cls):\n        \"\"\"Return the item which is 'most recent'\n\n        In practice, this means the item with the highest reference value\n        \"\"\"\n\n        query = cls.objects.all().order_by('-reference_int', '-pk')\n\n        if query.exists():\n            return query.first()\n        else:\n            return None\n\n    @classmethod\n    def get_next_reference(cls):\n        \"\"\"Return the next available reference value for this particular class.\"\"\"\n\n        # Find the \"most recent\" item\n        latest = cls.get_most_recent_item()\n\n        if not latest:\n            # No existing items\n            return 1\n\n        reference = latest.reference.strip\n\n        try:\n            reference = InvenTree.format.extract_named_group('ref', reference, cls.get_reference_pattern())\n        except Exception:\n            # If reference cannot be extracted using the pattern, try just the integer value\n            reference = str(latest.reference_int)\n\n        # Attempt to perform 'intelligent' incrementing of the reference field\n        incremented = InvenTree.helpers.increment(reference)\n\n        try:\n            incremented = int(incremented)\n        except ValueError:\n            pass\n\n        return incremented\n\n    @classmethod\n    def generate_reference(cls):\n        \"\"\"Generate the next 'reference' field based on specified pattern\"\"\"\n\n        fmt = cls.get_reference_pattern()\n        ctx = cls.get_reference_context()\n\n        reference = None\n\n        attempts = set()\n\n        while reference is None:\n            try:\n                ref = fmt.format(**ctx)\n\n                if ref in attempts:\n                    # We are stuck in a loop!\n                    reference = ref\n                    break\n                else:\n                    attempts.add(ref)\n\n                    if cls.objects.filter(reference=ref).exists():\n                        # Handle case where we have duplicated an existing reference\n                        ctx['ref'] = InvenTree.helpers.increment(ctx['ref'])\n                    else:\n                        # We have found an 'unused' reference\n                        reference = ref\n                        break\n\n            except Exception:\n                # If anything goes wrong, return the most recent reference\n                recent = cls.get_most_recent_item()\n                if recent:\n                    reference = recent.reference\n                else:\n                    reference = \"\"\n\n        return reference\n\n    @classmethod\n    def validate_reference_pattern(cls, pattern):\n        \"\"\"Ensure that the provided pattern is valid\"\"\"\n\n        ctx = cls.get_reference_context()\n\n        try:\n            info = InvenTree.format.parse_format_string(pattern)\n        except Exception:\n            raise ValidationError({\n                \"value\": _(\"Improperly formatted pattern\"),\n            })\n\n        # Check that only 'allowed' keys are provided\n        for key in info.keys():\n            if key not in ctx.keys():\n                raise ValidationError({\n                    \"value\": _(\"Unknown format key specified\") + f\": '{key}'\"\n                })\n\n        # Check that the 'ref' variable is specified\n        if 'ref' not in info.keys():\n            raise ValidationError({\n                'value': _(\"Missing required format key\") + \": 'ref'\"\n            })\n\n    @classmethod\n    def validate_reference_field(cls, value):\n        \"\"\"Check that the provided 'reference' value matches the requisite pattern\"\"\"\n\n        pattern = cls.get_reference_pattern()\n\n        value = str(value).strip()\n\n        if len(value) == 0:\n            raise ValidationError(_(\"Reference field cannot be empty\"))\n\n        # An 'empty' pattern means no further validation is required\n        if not pattern:\n            return\n\n        if not InvenTree.format.validate_string(value, pattern):\n            raise ValidationError(_(\"Reference must match required pattern\") + \": \" + pattern)\n\n        # Check that the reference field can be rebuild\n        cls.rebuild_reference_field(value, validate=True)\n\n    class Meta:\n        \"\"\"Metaclass options. Abstract ensures no database table is created.\"\"\"\n\n        abstract = True\n\n    @classmethod\n    def rebuild_reference_field(cls, reference, validate=False):\n        \"\"\"Extract integer out of reference for sorting.\n\n        If the 'integer' portion is buried somewhere 'within' the reference,\n        we can first try to extract it using the pattern.\n\n        Example:\n        reference - BO-123-ABC\n        pattern - BO-{ref}-???\n        extracted - 123\n\n        If we cannot extract using the pattern for some reason, fallback to the entire reference\n        \"\"\"\n\n        try:\n            # Extract named group based on provided pattern\n            reference = InvenTree.format.extract_named_group('ref', reference, cls.get_reference_pattern())\n        except Exception:\n            pass\n\n        reference_int = extract_int(reference)\n\n        if validate:\n            if reference_int > models.BigIntegerField.MAX_BIGINT:\n                raise ValidationError({\n                    \"reference\": _(\"Reference number is too large\")\n                })\n\n        return reference_int\n\n    reference_int = models.BigIntegerField(default=0)\n\n\ndef extract_int(reference, clip=0x7fffffff, allow_negative=False):\n    \"\"\"Extract an integer out of reference.\"\"\"\n\n    # Default value if we cannot convert to an integer\n    ref_int = 0\n\n    reference = str(reference).strip()\n\n    # Ignore empty string\n    if len(reference) == 0:\n        return 0\n\n    # Look at the start of the string - can it be \"integerized\"?\n    result = re.match(r\"^(\\d+)\", reference)\n\n    if result and len(result.groups()) == 1:\n        ref = result.groups()[0]\n        try:\n            ref_int = int(ref)\n        except Exception:\n            ref_int = 0\n    else:\n        # Look at the \"end\" of the string\n        result = re.search(r'(\\d+)$', reference)\n\n        if result and len(result.groups()) == 1:\n            ref = result.groups()[0]\n            try:\n                ref_int = int(ref)\n            except Exception:\n                ref_int = 0\n\n    # Ensure that the returned values are within the range that can be stored in an IntegerField\n    # Note: This will result in large values being \"clipped\"\n    if clip is not None:\n        if ref_int > clip:\n            ref_int = clip\n        elif ref_int < -clip:\n            ref_int = -clip\n\n    if not allow_negative and ref_int < 0:\n        ref_int = abs(ref_int)\n\n    return ref_int\n\n\nclass InvenTreeAttachment(models.Model):\n    \"\"\"Provides an abstracted class for managing file attachments.\n\n    An attachment can be either an uploaded file, or an external URL\n\n    Attributes:\n        attachment: File\n        comment: String descriptor for the attachment\n        user: User associated with file upload\n        upload_date: Date the file was uploaded\n    \"\"\"\n\n    def getSubdir(self):\n        \"\"\"Return the subdirectory under which attachments should be stored.\n\n        Note: Re-implement this for each subclass of InvenTreeAttachment\n        \"\"\"\n        return \"attachments\"\n\n    def save(self, *args, **kwargs):\n        \"\"\"Provide better validation error.\"\"\"\n        # Either 'attachment' or 'link' must be specified!\n        if not self.attachment and not self.link:\n            raise ValidationError({\n                'attachment': _('Missing file'),\n                'link': _('Missing external link'),\n            })\n\n        super().save(*args, **kwargs)\n\n    def __str__(self):\n        \"\"\"Human name for attachment.\"\"\"\n        if self.attachment is not None:\n            return os.path.basename(self.attachment.name)\n        else:\n            return str(self.link)\n\n    attachment = models.FileField(upload_to=rename_attachment, verbose_name=_('Attachment'),\n                                  help_text=_('Select file to attach'),\n                                  blank=True, null=True\n                                  )\n\n    link = InvenTreeURLField(\n        blank=True, null=True,\n        verbose_name=_('Link'),\n        help_text=_('Link to external URL')\n    )\n\n    comment = models.CharField(blank=True, max_length=100, verbose_name=_('Comment'), help_text=_('File comment'))\n\n    user = models.ForeignKey(\n        User,\n        on_delete=models.SET_NULL,\n        blank=True, null=True,\n        verbose_name=_('User'),\n        help_text=_('User'),\n    )\n\n    upload_date = models.DateField(auto_now_add=True, null=True, blank=True, verbose_name=_('upload date'))\n\n    @property\n    def basename(self):\n        \"\"\"Base name/path for attachment.\"\"\"\n        if self.attachment:\n            return os.path.basename(self.attachment.name)\n        else:\n            return None\n\n    @basename.setter\n    def basename(self, fn):\n        \"\"\"Function to rename the attachment file.\n\n        - Filename cannot be empty\n        - Filename cannot contain illegal characters\n        - Filename must specify an extension\n        - Filename cannot match an existing file\n        \"\"\"\n        fn = fn.strip()\n\n        if len(fn) == 0:\n            raise ValidationError(_('Filename must not be empty'))\n\n        attachment_dir = settings.MEDIA_ROOT.joinpath(self.getSubdir())\n        old_file = settings.MEDIA_ROOT.joinpath(self.attachment.name)\n        new_file = settings.MEDIA_ROOT.joinpath(self.getSubdir(), fn).resolve()\n\n        # Check that there are no directory tricks going on...\n        if new_file.parent != attachment_dir:\n            logger.error(f\"Attempted to rename attachment outside valid directory: '{new_file}'\")\n            raise ValidationError(_(\"Invalid attachment directory\"))\n\n        # Ignore further checks if the filename is not actually being renamed\n        if new_file == old_file:\n            return\n\n        forbidden = [\"'\", '\"', \"#\", \"@\", \"!\", \"&\", \"^\", \"<\", \">\", \":\", \";\", \"/\", \"\\\\\", \"|\", \"?\", \"*\", \"%\", \"~\", \"`\"]\n\n        for c in forbidden:\n            if c in fn:\n                raise ValidationError(_(f\"Filename contains illegal character '{c}'\"))\n\n        if len(fn.split('.')) < 2:\n            raise ValidationError(_(\"Filename missing extension\"))\n\n        if not old_file.exists():\n            logger.error(f\"Trying to rename attachment '{old_file}' which does not exist\")\n            return\n\n        if new_file.exists():\n            raise ValidationError(_(\"Attachment with this filename already exists\"))\n\n        try:\n            os.rename(old_file, new_file)\n            self.attachment.name = os.path.join(self.getSubdir(), fn)\n            self.save()\n        except Exception:\n            raise ValidationError(_(\"Error renaming file\"))\n\n    class Meta:\n        \"\"\"Metaclass options. Abstract ensures no database table is created.\"\"\"\n\n        abstract = True\n\n\nclass InvenTreeTree(MPTTModel):\n    \"\"\"Provides an abstracted self-referencing tree model for data categories.\n\n    - Each Category has one parent Category, which can be blank (for a top-level Category).\n    - Each Category can have zero-or-more child Categor(y/ies)\n\n    Attributes:\n        name: brief name\n        description: longer form description\n        parent: The item immediately above this one. An item with a null parent is a top-level item\n    \"\"\"\n\n    def api_instance_filters(self):\n        \"\"\"Instance filters for InvenTreeTree models.\"\"\"\n        return {\n            'parent': {\n                'exclude_tree': self.pk,\n            }\n        }\n\n    def save(self, *args, **kwargs):\n        \"\"\"Custom save method for InvenTreeTree abstract model\"\"\"\n\n        try:\n            super().save(*args, **kwargs)\n        except InvalidMove:\n            # Provide better error for parent selection\n            raise ValidationError({\n                'parent': _(\"Invalid choice\"),\n            })\n\n        # Re-calculate the 'pathstring' field\n        pathstring = InvenTree.helpers.constructPathString(\n            [item.name for item in self.path]\n        )\n\n        if pathstring != self.pathstring:\n\n            if 'force_insert' in kwargs:\n                del kwargs['force_insert']\n\n            kwargs['force_update'] = True\n\n            self.pathstring = pathstring\n            super().save(*args, **kwargs)\n\n            # Ensure that the pathstring changes are propagated down the tree also\n            for child in self.get_children():\n                child.save(*args, **kwargs)\n\n    class Meta:\n        \"\"\"Metaclass defines extra model properties.\"\"\"\n\n        abstract = True\n\n        # Names must be unique at any given level in the tree\n        unique_together = ('name', 'parent')\n\n    class MPTTMeta:\n        \"\"\"Set insert order.\"\"\"\n        order_insertion_by = ['name']\n\n    name = models.CharField(\n        blank=False,\n        max_length=100,\n        verbose_name=_(\"Name\"),\n        help_text=_(\"Name\"),\n    )\n\n    description = models.CharField(\n        blank=True,\n        max_length=250,\n        verbose_name=_(\"Description\"),\n        help_text=_(\"Description (optional)\")\n    )\n\n    # When a category is deleted, graft the children onto its parent\n    parent = TreeForeignKey('self',\n                            on_delete=models.DO_NOTHING,\n                            blank=True,\n                            null=True,\n                            verbose_name=_(\"parent\"),\n                            related_name='children')\n\n    # The 'pathstring' field is calculated each time the model is saved\n    pathstring = models.CharField(\n        blank=True,\n        max_length=250,\n        verbose_name=_('Path'),\n        help_text=_('Path')\n    )\n\n    @property\n    def item_count(self):\n        \"\"\"Return the number of items which exist *under* this node in the tree.\n\n        Here an 'item' is considered to be the 'leaf' at the end of each branch,\n        and the exact nature here will depend on the class implementation.\n\n        The default implementation returns zero\n        \"\"\"\n        return 0\n\n    def getUniqueParents(self):\n        \"\"\"Return a flat set of all parent items that exist above this node.\n\n        If any parents are repeated (which would be very bad!), the process is halted\n        \"\"\"\n        return self.get_ancestors()\n\n    def getUniqueChildren(self, include_self=True):\n        \"\"\"Return a flat set of all child items that exist under this node.\n\n        If any child items are repeated, the repetitions are omitted.\n        \"\"\"\n        return self.get_descendants(include_self=include_self)\n\n    @property\n    def has_children(self):\n        \"\"\"True if there are any children under this item.\"\"\"\n        return self.getUniqueChildren(include_self=False).count() > 0\n\n    def getAcceptableParents(self):\n        \"\"\"Returns a list of acceptable parent items within this model Acceptable parents are ones which are not underneath this item.\n\n        Setting the parent of an item to its own child results in recursion.\n        \"\"\"\n        contents = ContentType.objects.get_for_model(type(self))\n\n        available = contents.get_all_objects_for_this_type()\n\n        # List of child IDs\n        childs = self.getUniqueChildren()\n\n        acceptable = [None]\n\n        for a in available:\n            if a.id not in childs:\n                acceptable.append(a)\n\n        return acceptable\n\n    @property\n    def parentpath(self):\n        \"\"\"Get the parent path of this category.\n\n        Returns:\n            List of category names from the top level to the parent of this category\n        \"\"\"\n        return [a for a in self.get_ancestors()]\n\n    @property\n    def path(self):\n        \"\"\"Get the complete part of this category.\n\n        e.g. [\"Top\", \"Second\", \"Third\", \"This\"]\n\n        Returns:\n            List of category names from the top level to this category\n        \"\"\"\n        return self.parentpath + [self]\n\n    def __str__(self):\n        \"\"\"String representation of a category is the full path to that category.\"\"\"\n        return \"{path} - {desc}\".format(path=self.pathstring, desc=self.description)\n\n\nclass InvenTreeBarcodeMixin(models.Model):\n    \"\"\"A mixin class for adding barcode functionality to a model class.\n\n    Two types of barcodes are supported:\n\n    - Internal barcodes (QR codes using a strictly defined format)\n    - External barcodes (assign third party barcode data to a model instance)\n\n    The following fields are added to any model which implements this mixin:\n\n    - barcode_data : Raw data associated with an assigned barcode\n    - barcode_hash : A 'hash' of the assigned barcode data used to improve matching\n    \"\"\"\n\n    class Meta:\n        \"\"\"Metaclass options for this mixin.\n\n        Note: abstract must be true, as this is only a mixin, not a separate table\n        \"\"\"\n        abstract = True\n\n    barcode_data = models.CharField(\n        blank=True, max_length=500,\n        verbose_name=_('Barcode Data'),\n        help_text=_('Third party barcode data'),\n    )\n\n    barcode_hash = models.CharField(\n        blank=True, max_length=128,\n        verbose_name=_('Barcode Hash'),\n        help_text=_('Unique hash of barcode data')\n    )\n\n    @classmethod\n    def barcode_model_type(cls):\n        \"\"\"Return the model 'type' for creating a custom QR code.\"\"\"\n\n        # By default, use the name of the class\n        return cls.__name__.lower()\n\n    def format_barcode(self, **kwargs):\n        \"\"\"Return a JSON string for formatting a QR code for this model instance.\"\"\"\n\n        return InvenTree.helpers.MakeBarcode(\n            self.__class__.barcode_model_type(),\n            self.pk,\n            **kwargs\n        )\n\n    @property\n    def barcode(self):\n        \"\"\"Format a minimal barcode string (e.g. for label printing)\"\"\"\n\n        return self.format_barcode(brief=True)\n\n    @classmethod\n    def lookup_barcode(cls, barcode_hash):\n        \"\"\"Check if a model instance exists with the specified third-party barcode hash.\"\"\"\n\n        return cls.objects.filter(barcode_hash=barcode_hash).first()\n\n    def assign_barcode(self, barcode_hash=None, barcode_data=None, raise_error=True):\n        \"\"\"Assign an external (third-party) barcode to this object.\"\"\"\n\n        # Must provide either barcode_hash or barcode_data\n        if barcode_hash is None and barcode_data is None:\n            raise ValueError(\"Provide either 'barcode_hash' or 'barcode_data'\")\n\n        # If barcode_hash is not provided, create from supplier barcode_data\n        if barcode_hash is None:\n            barcode_hash = InvenTree.helpers.hash_barcode(barcode_data)\n\n        # Check for existing item\n        if self.__class__.lookup_barcode(barcode_hash) is not None:\n            if raise_error:\n                raise ValidationError(_(\"Existing barcode found\"))\n            else:\n                return False\n\n        if barcode_data is not None:\n            self.barcode_data = barcode_data\n\n        self.barcode_hash = barcode_hash\n\n        self.save()\n\n        return True\n\n    def unassign_barcode(self):\n        \"\"\"Unassign custom barcode from this model\"\"\"\n\n        self.barcode_data = ''\n        self.barcode_hash = ''\n\n        self.save()\n\n\n@receiver(pre_delete, sender=InvenTreeTree, dispatch_uid='tree_pre_delete_log')\ndef before_delete_tree_item(sender, instance, using, **kwargs):\n    \"\"\"Receives pre_delete signal from InvenTreeTree object.\n\n    Before an item is deleted, update each child object to point to the parent of the object being deleted.\n    \"\"\"\n    # Update each tree item below this one\n    for child in instance.children.all():\n        child.parent = instance.parent\n        child.save()\n\n\n@receiver(post_save, sender=Error, dispatch_uid='error_post_save_notification')\ndef after_error_logged(sender, instance: Error, created: bool, **kwargs):\n    \"\"\"Callback when a server error is logged.\n\n    - Send a UI notification to all users with staff status\n    \"\"\"\n\n    if created:\n        try:\n            import common.notifications\n\n            users = get_user_model().objects.filter(is_staff=True)\n\n            link = InvenTree.helpers.construct_absolute_url(\n                reverse('admin:error_report_error_change', kwargs={'object_id': instance.pk})\n            )\n\n            context = {\n                'error': instance,\n                'name': _('Server Error'),\n                'message': _('An error has been logged by the server.'),\n                'link': link\n            }\n\n            common.notifications.trigger_notification(\n                instance,\n                'inventree.error_log',\n                context=context,\n                targets=users,\n                delivery_methods=set([common.notifications.UIMessageNotification]),\n            )\n\n        except Exception as exc:\n            \"\"\"We do not want to throw an exception while reporting an exception\"\"\"\n            logger.error(exc)\n", "patch": "@@ -4,6 +4,7 @@\n import os\n import re\n from datetime import datetime\n+from io import BytesIO\n \n from django.conf import settings\n from django.contrib.auth import get_user_model\n@@ -24,6 +25,7 @@\n import InvenTree.helpers\n from common.models import InvenTreeSetting\n from InvenTree.fields import InvenTreeURLField\n+from InvenTree.sanitizer import sanitize_svg\n \n logger = logging.getLogger('inventree')\n \n@@ -383,8 +385,16 @@ def save(self, *args, **kwargs):\n                 'link': _('Missing external link'),\n             })\n \n+        if self.attachment.name.lower().endswith('.svg'):\n+            self.attachment.file.file = self.clean_svg(self.attachment)\n+\n         super().save(*args, **kwargs)\n \n+    def clean_svg(self, field):\n+        \"\"\"Sanitize SVG file before saving.\"\"\"\n+        cleaned = sanitize_svg(field.file.read())\n+        return BytesIO(bytes(cleaned, 'utf8'))\n+\n     def __str__(self):\n         \"\"\"Human name for attachment.\"\"\"\n         if self.attachment is not None:", "file_path": "files/2022_9/75", "file_language": "py", "file_name": "InvenTree/InvenTree/models.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/inventree/InvenTree/raw/5a08ef908dd5344b4433436a4679d122f7f99e41/InvenTree%2FInvenTree%2Fsanitizer.py", "code": "\"\"\"Functions to sanitize user input files.\"\"\"\nfrom bleach import clean\nfrom bleach.css_sanitizer import CSSSanitizer\n\nALLOWED_ELEMENTS_SVG = [\n    'a', 'animate', 'animateColor', 'animateMotion',\n    'animateTransform', 'circle', 'defs', 'desc', 'ellipse', 'font-face',\n    'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n]\n\nALLOWED_ATTRIBUTES_SVG = [\n    'accent-height', 'accumulate', 'additive', 'alphabetic',\n    'arabic-form', 'ascent', 'attributeName', 'attributeType',\n    'baseProfile', 'bbox', 'begin', 'by', 'calcMode', 'cap-height',\n    'class', 'color', 'color-rendering', 'content', 'cx', 'cy', 'd', 'dx',\n    'dy', 'descent', 'display', 'dur', 'end', 'fill', 'fill-opacity',\n    'fill-rule', 'font-family', 'font-size', 'font-stretch', 'font-style',\n    'font-variant', 'font-weight', 'from', 'fx', 'fy', 'g1', 'g2',\n    'glyph-name', 'gradientUnits', 'hanging', 'height', 'horiz-adv-x',\n    'horiz-origin-x', 'id', 'ideographic', 'k', 'keyPoints',\n    'keySplines', 'keyTimes', 'lang', 'marker-end', 'marker-mid',\n    'marker-start', 'markerHeight', 'markerUnits', 'markerWidth',\n    'mathematical', 'max', 'min', 'name', 'offset', 'opacity', 'orient',\n    'origin', 'overline-position', 'overline-thickness', 'panose-1',\n    'path', 'pathLength', 'points', 'preserveAspectRatio', 'r', 'refX',\n    'refY', 'repeatCount', 'repeatDur', 'requiredExtensions',\n    'requiredFeatures', 'restart', 'rotate', 'rx', 'ry', 'slope',\n    'stemh', 'stemv', 'stop-color', 'stop-opacity',\n    'strikethrough-position', 'strikethrough-thickness', 'stroke',\n    'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap',\n    'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity',\n    'stroke-width', 'systemLanguage', 'target', 'text-anchor', 'to',\n    'transform', 'type', 'u1', 'u2', 'underline-position',\n    'underline-thickness', 'unicode', 'unicode-range', 'units-per-em',\n    'values', 'version', 'viewBox', 'visibility', 'width', 'widths', 'x',\n    'x-height', 'x1', 'x2', 'xlink:actuate', 'xlink:arcrole',\n    'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title',\n    'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'xmlns',\n    'xmlns:xlink', 'y', 'y1', 'y2', 'zoomAndPan', 'style'\n]\n\n\ndef sanitize_svg(file_data: str, strip: bool = True, elements: str = ALLOWED_ELEMENTS_SVG, attributes: str = ALLOWED_ATTRIBUTES_SVG) -> str:\n    \"\"\"Sanatize a SVG file.\n\n    Args:\n        file_data (str): SVG as string.\n        strip (bool, optional): Should invalid elements get removed. Defaults to True.\n        elements (str, optional): Allowed elements. Defaults to ALLOWED_ELEMENTS_SVG.\n        attributes (str, optional): Allowed attributes. Defaults to ALLOWED_ATTRIBUTES_SVG.\n\n    Returns:\n        str: Sanitzied SVG file.\n    \"\"\"\n\n    cleaned = clean(\n        file_data,\n        tags=elements,\n        attributes=attributes,\n        strip=strip,\n        strip_comments=strip,\n        css_sanitizer=CSSSanitizer()\n    )\n    return cleaned\n", "code_before": "", "patch": "@@ -0,0 +1,67 @@\n+\"\"\"Functions to sanitize user input files.\"\"\"\n+from bleach import clean\n+from bleach.css_sanitizer import CSSSanitizer\n+\n+ALLOWED_ELEMENTS_SVG = [\n+    'a', 'animate', 'animateColor', 'animateMotion',\n+    'animateTransform', 'circle', 'defs', 'desc', 'ellipse', 'font-face',\n+    'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n+    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n+    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n+    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n+]\n+\n+ALLOWED_ATTRIBUTES_SVG = [\n+    'accent-height', 'accumulate', 'additive', 'alphabetic',\n+    'arabic-form', 'ascent', 'attributeName', 'attributeType',\n+    'baseProfile', 'bbox', 'begin', 'by', 'calcMode', 'cap-height',\n+    'class', 'color', 'color-rendering', 'content', 'cx', 'cy', 'd', 'dx',\n+    'dy', 'descent', 'display', 'dur', 'end', 'fill', 'fill-opacity',\n+    'fill-rule', 'font-family', 'font-size', 'font-stretch', 'font-style',\n+    'font-variant', 'font-weight', 'from', 'fx', 'fy', 'g1', 'g2',\n+    'glyph-name', 'gradientUnits', 'hanging', 'height', 'horiz-adv-x',\n+    'horiz-origin-x', 'id', 'ideographic', 'k', 'keyPoints',\n+    'keySplines', 'keyTimes', 'lang', 'marker-end', 'marker-mid',\n+    'marker-start', 'markerHeight', 'markerUnits', 'markerWidth',\n+    'mathematical', 'max', 'min', 'name', 'offset', 'opacity', 'orient',\n+    'origin', 'overline-position', 'overline-thickness', 'panose-1',\n+    'path', 'pathLength', 'points', 'preserveAspectRatio', 'r', 'refX',\n+    'refY', 'repeatCount', 'repeatDur', 'requiredExtensions',\n+    'requiredFeatures', 'restart', 'rotate', 'rx', 'ry', 'slope',\n+    'stemh', 'stemv', 'stop-color', 'stop-opacity',\n+    'strikethrough-position', 'strikethrough-thickness', 'stroke',\n+    'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap',\n+    'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity',\n+    'stroke-width', 'systemLanguage', 'target', 'text-anchor', 'to',\n+    'transform', 'type', 'u1', 'u2', 'underline-position',\n+    'underline-thickness', 'unicode', 'unicode-range', 'units-per-em',\n+    'values', 'version', 'viewBox', 'visibility', 'width', 'widths', 'x',\n+    'x-height', 'x1', 'x2', 'xlink:actuate', 'xlink:arcrole',\n+    'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title',\n+    'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'xmlns',\n+    'xmlns:xlink', 'y', 'y1', 'y2', 'zoomAndPan', 'style'\n+]\n+\n+\n+def sanitize_svg(file_data: str, strip: bool = True, elements: str = ALLOWED_ELEMENTS_SVG, attributes: str = ALLOWED_ATTRIBUTES_SVG) -> str:\n+    \"\"\"Sanatize a SVG file.\n+\n+    Args:\n+        file_data (str): SVG as string.\n+        strip (bool, optional): Should invalid elements get removed. Defaults to True.\n+        elements (str, optional): Allowed elements. Defaults to ALLOWED_ELEMENTS_SVG.\n+        attributes (str, optional): Allowed attributes. Defaults to ALLOWED_ATTRIBUTES_SVG.\n+\n+    Returns:\n+        str: Sanitzied SVG file.\n+    \"\"\"\n+\n+    cleaned = clean(\n+        file_data,\n+        tags=elements,\n+        attributes=attributes,\n+        strip=strip,\n+        strip_comments=strip,\n+        css_sanitizer=CSSSanitizer()\n+    )\n+    return cleaned", "file_path": "files/2022_9/76", "file_language": "py", "file_name": "InvenTree/InvenTree/sanitizer.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/inventree/InvenTree/raw/5a08ef908dd5344b4433436a4679d122f7f99e41/InvenTree%2FInvenTree%2Ftests.py", "code": "\"\"\"Test general functions and helpers.\"\"\"\n\nimport json\nimport os\nimport time\nfrom decimal import Decimal\nfrom unittest import mock\n\nimport django.core.exceptions as django_exceptions\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase, override_settings\n\nimport requests\nfrom djmoney.contrib.exchange.exceptions import MissingRate\nfrom djmoney.contrib.exchange.models import Rate, convert_money\nfrom djmoney.money import Money\n\nimport InvenTree.format\nimport InvenTree.helpers\nimport InvenTree.tasks\nfrom common.models import InvenTreeSetting\nfrom common.settings import currency_codes\nfrom InvenTree.sanitizer import sanitize_svg\nfrom part.models import Part, PartCategory\nfrom stock.models import StockItem, StockLocation\n\nfrom . import config, helpers, ready, status, version\nfrom .tasks import offload_task\nfrom .validators import validate_overage, validate_part_name\n\n\nclass ValidatorTest(TestCase):\n    \"\"\"Simple tests for custom field validators.\"\"\"\n\n    def test_part_name(self):\n        \"\"\"Test part name validator.\"\"\"\n        validate_part_name('hello world')\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_part_name('This | name is not } valid')\n\n    def test_overage(self):\n        \"\"\"Test overage validator.\"\"\"\n        validate_overage(\"100%\")\n        validate_overage(\"10\")\n        validate_overage(\"45.2 %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"-1\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"-2.04 %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"105%\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"xxx %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"aaaa\")\n\n\nclass FormatTest(TestCase):\n    \"\"\"Unit tests for custom string formatting functionality\"\"\"\n\n    def test_parse(self):\n        \"\"\"Tests for the 'parse_format_string' function\"\"\"\n\n        # Extract data from a valid format string\n        fmt = \"PO-{abc:02f}-{ref:04d}-{date}-???\"\n\n        info = InvenTree.format.parse_format_string(fmt)\n\n        self.assertIn('abc', info)\n        self.assertIn('ref', info)\n        self.assertIn('date', info)\n\n        # Try with invalid strings\n        for fmt in [\n            'PO-{{xyz}',\n            'PO-{xyz}}',\n            'PO-{xyz}-{',\n        ]:\n\n            with self.assertRaises(ValueError):\n                InvenTree.format.parse_format_string(fmt)\n\n    def test_create_regex(self):\n        \"\"\"Test function for creating a regex from a format string\"\"\"\n\n        tests = {\n            \"PO-123-{ref:04f}\": r\"^PO\\-123\\-(?P<ref>.+)$\",\n            \"{PO}-???-{ref}-{date}-22\": r\"^(?P<PO>.+)\\-...\\-(?P<ref>.+)\\-(?P<date>.+)\\-22$\",\n            \"ABC-123-###-{ref}\": r\"^ABC\\-123\\-\\d\\d\\d\\-(?P<ref>.+)$\",\n            \"ABC-123\": r\"^ABC\\-123$\",\n        }\n\n        for fmt, reg in tests.items():\n            self.assertEqual(InvenTree.format.construct_format_regex(fmt), reg)\n\n    def test_validate_format(self):\n        \"\"\"Test that string validation works as expected\"\"\"\n\n        # These tests should pass\n        for value, pattern in {\n            \"ABC-hello-123\": \"???-{q}-###\",\n            \"BO-1234\": \"BO-{ref}\",\n            \"111.222.fred.china\": \"???.###.{name}.{place}\",\n            \"PO-1234\": \"PO-{ref:04d}\"\n        }.items():\n            self.assertTrue(InvenTree.format.validate_string(value, pattern))\n\n        # These tests should fail\n        for value, pattern in {\n            \"ABC-hello-123\": \"###-{q}-???\",\n            \"BO-1234\": \"BO.{ref}\",\n            \"BO-####\": \"BO-{pattern}-{next}\",\n            \"BO-123d\": \"BO-{ref:04d}\"\n        }.items():\n            self.assertFalse(InvenTree.format.validate_string(value, pattern))\n\n    def test_extract_value(self):\n        \"\"\"Test that we can extract named values based on a format string\"\"\"\n\n        # Simple tests based on a straight-forward format string\n        fmt = \"PO-###-{ref:04d}\"\n\n        tests = {\n            \"123\": \"PO-123-123\",\n            \"456\": \"PO-123-456\",\n            \"789\": \"PO-123-789\",\n        }\n\n        for k, v in tests.items():\n            self.assertEqual(InvenTree.format.extract_named_group('ref', v, fmt), k)\n\n        # However these ones should fail\n        tests = {\n            'abc': 'PO-123-abc',\n            'xyz': 'PO-123-xyz',\n        }\n\n        for v in tests.values():\n            with self.assertRaises(ValueError):\n                InvenTree.format.extract_named_group('ref', v, fmt)\n\n        # More complex tests\n        fmt = \"PO-{date}-{test}-???-{ref}-###\"\n        val = \"PO-2022-02-01-hello-ABC-12345-222\"\n\n        data = {\n            'date': '2022-02-01',\n            'test': 'hello',\n            'ref': '12345',\n        }\n\n        for k, v in data.items():\n            self.assertEqual(InvenTree.format.extract_named_group(k, val, fmt), v)\n\n        # Test for error conditions\n\n        # Raises a ValueError as the format string is bad\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-1234-5\",\n                \"PO-{test}-{\"\n            )\n\n        # Raises a NameError as the named group does not exist in the format string\n        with self.assertRaises(NameError):\n            InvenTree.format.extract_named_group(\n                \"missing\",\n                \"PO-12345\",\n                \"PO-{test}\",\n            )\n\n        # Raises a ValueError as the value does not match the format string\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-1234\",\n                \"PO-{test}-1234\",\n            )\n\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-ABC-xyz\",\n                \"PO-###-{test}\",\n            )\n\n\nclass TestHelpers(TestCase):\n    \"\"\"Tests for InvenTree helper functions.\"\"\"\n\n    def test_image_url(self):\n        \"\"\"Test if a filename looks like an image.\"\"\"\n        for name in ['ape.png', 'bat.GiF', 'apple.WeBP', 'BiTMap.Bmp']:\n            self.assertTrue(helpers.TestIfImageURL(name))\n\n        for name in ['no.doc', 'nah.pdf', 'whatpng']:\n            self.assertFalse(helpers.TestIfImageURL(name))\n\n    def test_str2bool(self):\n        \"\"\"Test string to boolean conversion.\"\"\"\n        for s in ['yes', 'Y', 'ok', '1', 'OK', 'Ok', 'tRuE', 'oN']:\n            self.assertTrue(helpers.str2bool(s))\n            self.assertFalse(helpers.str2bool(s, test=False))\n\n        for s in ['nO', '0', 'none', 'noNE', None, False, 'falSe', 'off']:\n            self.assertFalse(helpers.str2bool(s))\n            self.assertTrue(helpers.str2bool(s, test=False))\n\n        for s in ['wombat', '', 'xxxx']:\n            self.assertFalse(helpers.str2bool(s))\n            self.assertFalse(helpers.str2bool(s, test=False))\n\n    def test_isnull(self):\n        \"\"\"Test isNull.\"\"\"\n        for s in ['null', 'none', '', '-1', 'false']:\n            self.assertTrue(helpers.isNull(s))\n\n        for s in ['yes', 'frog', 'llama', 'true']:\n            self.assertFalse(helpers.isNull(s))\n\n    def testStaticUrl(self):\n        \"\"\"Test static url helpers.\"\"\"\n        self.assertEqual(helpers.getStaticUrl('test.jpg'), '/static/test.jpg')\n        self.assertEqual(helpers.getBlankImage(), '/static/img/blank_image.png')\n        self.assertEqual(helpers.getBlankThumbnail(), '/static/img/blank_image.thumbnail.png')\n\n    def testMediaUrl(self):\n        \"\"\"Test getMediaUrl.\"\"\"\n        self.assertEqual(helpers.getMediaUrl('xx/yy.png'), '/media/xx/yy.png')\n\n    def testDecimal2String(self):\n        \"\"\"Test decimal2string.\"\"\"\n        self.assertEqual(helpers.decimal2string(Decimal('1.2345000')), '1.2345')\n        self.assertEqual(helpers.decimal2string('test'), 'test')\n\n    def test_logo_image(self):\n        \"\"\"Test for retrieving logo image\"\"\"\n\n        # By default, there is no custom logo provided\n\n        logo = helpers.getLogoImage()\n        self.assertEqual(logo, '/static/img/inventree.png')\n\n        logo = helpers.getLogoImage(as_file=True)\n        self.assertEqual(logo, f'file://{settings.STATIC_ROOT}/img/inventree.png')\n\n    def test_download_image(self):\n        \"\"\"Test function for downloading image from remote URL\"\"\"\n\n        # Run check with a sequency of bad URLs\n        for url in [\n            \"blog\",\n            \"htp://test.com/?\",\n            \"google\",\n            \"\\\\invalid-url\"\n        ]:\n            with self.assertRaises(django_exceptions.ValidationError):\n                helpers.download_image_from_url(url)\n\n        # Attempt to download an image which throws a 404\n        with self.assertRaises(requests.exceptions.HTTPError):\n            helpers.download_image_from_url(\"https://httpstat.us/404\", timeout=10)\n\n        # Attempt to download, but timeout\n        with self.assertRaises(requests.exceptions.Timeout):\n            helpers.download_image_from_url(\"https://httpstat.us/200?sleep=5000\")\n\n        # Attempt to download, but not a valid image\n        with self.assertRaises(TypeError):\n            helpers.download_image_from_url(\"https://httpstat.us/200\", timeout=10)\n\n        large_img = \"https://github.com/inventree/InvenTree/raw/master/InvenTree/InvenTree/static/img/paper_splash_large.jpg\"\n\n        InvenTreeSetting.set_setting('INVENTREE_DOWNLOAD_IMAGE_MAX_SIZE', 1, change_user=None)\n\n        # Attempt to download an image which is too large\n        with self.assertRaises(ValueError):\n            helpers.download_image_from_url(large_img, timeout=10)\n\n        # Increase allowable download size\n        InvenTreeSetting.set_setting('INVENTREE_DOWNLOAD_IMAGE_MAX_SIZE', 5, change_user=None)\n\n        # Download a valid image (should not throw an error)\n        helpers.download_image_from_url(large_img, timeout=10)\n\n\nclass TestQuoteWrap(TestCase):\n    \"\"\"Tests for string wrapping.\"\"\"\n\n    def test_single(self):\n        \"\"\"Test WrapWithQuotes.\"\"\"\n        self.assertEqual(helpers.WrapWithQuotes('hello'), '\"hello\"')\n        self.assertEqual(helpers.WrapWithQuotes('hello\"'), '\"hello\"')\n\n\nclass TestIncrement(TestCase):\n    \"\"\"Tests for increment function.\"\"\"\n\n    def tests(self):\n        \"\"\"Test 'intelligent' incrementing function.\"\"\"\n        tests = [\n            (\"\", \"\"),\n            (1, \"2\"),\n            (\"001\", \"002\"),\n            (\"1001\", \"1002\"),\n            (\"ABC123\", \"ABC124\"),\n            (\"XYZ0\", \"XYZ1\"),\n            (\"123Q\", \"123Q\"),\n            (\"QQQ\", \"QQQ\"),\n        ]\n\n        for test in tests:\n            a, b = test\n\n            result = helpers.increment(a)\n            self.assertEqual(result, b)\n\n\nclass TestMakeBarcode(TestCase):\n    \"\"\"Tests for barcode string creation.\"\"\"\n\n    def test_barcode_extended(self):\n        \"\"\"Test creation of barcode with extended data.\"\"\"\n        bc = helpers.MakeBarcode(\n            \"part\",\n            3,\n            {\n                \"id\": 3,\n                \"url\": \"www.google.com\",\n            },\n            brief=False\n        )\n\n        self.assertIn('part', bc)\n        self.assertIn('tool', bc)\n        self.assertIn('\"tool\": \"InvenTree\"', bc)\n\n        data = json.loads(bc)\n\n        self.assertEqual(data['part']['id'], 3)\n        self.assertEqual(data['part']['url'], 'www.google.com')\n\n    def test_barcode_brief(self):\n        \"\"\"Test creation of simple barcode.\"\"\"\n        bc = helpers.MakeBarcode(\n            \"stockitem\",\n            7,\n        )\n\n        data = json.loads(bc)\n        self.assertEqual(len(data), 1)\n        self.assertEqual(data['stockitem'], 7)\n\n\nclass TestDownloadFile(TestCase):\n    \"\"\"Tests for DownloadFile.\"\"\"\n\n    def test_download(self):\n        \"\"\"Tests for DownloadFile.\"\"\"\n        helpers.DownloadFile(\"hello world\", \"out.txt\")\n        helpers.DownloadFile(bytes(b\"hello world\"), \"out.bin\")\n\n\nclass TestMPTT(TestCase):\n    \"\"\"Tests for the MPTT tree models.\"\"\"\n\n    fixtures = [\n        'location',\n    ]\n\n    def setUp(self):\n        \"\"\"Setup for all tests.\"\"\"\n        super().setUp()\n\n        StockLocation.objects.rebuild()\n\n    def test_self_as_parent(self):\n        \"\"\"Test that we cannot set self as parent.\"\"\"\n        loc = StockLocation.objects.get(pk=4)\n        loc.parent = loc\n\n        with self.assertRaises(ValidationError):\n            loc.save()\n\n    def test_child_as_parent(self):\n        \"\"\"Test that we cannot set a child as parent.\"\"\"\n        parent = StockLocation.objects.get(pk=4)\n        child = StockLocation.objects.get(pk=5)\n\n        parent.parent = child\n\n        with self.assertRaises(ValidationError):\n            parent.save()\n\n    def test_move(self):\n        \"\"\"Move an item to a different tree.\"\"\"\n        drawer = StockLocation.objects.get(name='Drawer_1')\n\n        # Record the tree ID\n        tree = drawer.tree_id\n\n        home = StockLocation.objects.get(name='Home')\n\n        drawer.parent = home\n        drawer.save()\n\n        self.assertNotEqual(tree, drawer.tree_id)\n\n\nclass TestSerialNumberExtraction(TestCase):\n    \"\"\"Tests for serial number extraction code.\"\"\"\n\n    def test_simple(self):\n        \"\"\"Test simple serial numbers.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        sn = e(\"1-5\", 5, 1)\n        self.assertEqual(len(sn), 5, 1)\n        for i in range(1, 6):\n            self.assertIn(i, sn)\n\n        sn = e(\"1, 2, 3, 4, 5\", 5, 1)\n        self.assertEqual(len(sn), 5)\n\n        # Test partially specifying serials\n        sn = e(\"1, 2, 4+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 4, 5, 6])\n\n        # Test groups are not interpolated if enough serials are supplied\n        sn = e(\"1, 2, 3, AF5-69H, 5\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 3, \"AF5-69H\", 5])\n\n        # Test groups are not interpolated with more than one hyphen in a word\n        sn = e(\"1, 2, TG-4SR-92, 4+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, \"TG-4SR-92\", 4, 5])\n\n        # Test groups are not interpolated with alpha characters\n        sn = e(\"1, A-2, 3+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, \"A-2\", 3, 4, 5])\n\n        # Test multiple placeholders\n        sn = e(\"1 2 ~ ~ ~\", 5, 3)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 3, 4, 5])\n\n        sn = e(\"1-5, 10-15\", 11, 1)\n        self.assertIn(3, sn)\n        self.assertIn(13, sn)\n\n        sn = e(\"1+\", 10, 1)\n        self.assertEqual(len(sn), 10)\n        self.assertEqual(sn, [_ for _ in range(1, 11)])\n\n        sn = e(\"4, 1+2\", 4, 1)\n        self.assertEqual(len(sn), 4)\n        self.assertEqual(sn, [4, 1, 2, 3])\n\n        sn = e(\"~\", 1, 1)\n        self.assertEqual(len(sn), 1)\n        self.assertEqual(sn, [1])\n\n        sn = e(\"~\", 1, 3)\n        self.assertEqual(len(sn), 1)\n        self.assertEqual(sn, [3])\n\n        sn = e(\"~+\", 2, 5)\n        self.assertEqual(len(sn), 2)\n        self.assertEqual(sn, [5, 6])\n\n        sn = e(\"~+3\", 4, 5)\n        self.assertEqual(len(sn), 4)\n        self.assertEqual(sn, [5, 6, 7, 8])\n\n    def test_failures(self):\n        \"\"\"Test wron serial numbers.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        # Test duplicates\n        with self.assertRaises(ValidationError):\n            e(\"1,2,3,3,3\", 5, 1)\n\n        # Test invalid length\n        with self.assertRaises(ValidationError):\n            e(\"1,2,3\", 5, 1)\n\n        # Test empty string\n        with self.assertRaises(ValidationError):\n            e(\", , ,\", 0, 1)\n\n        # Test incorrect sign in group\n        with self.assertRaises(ValidationError):\n            e(\"10-2\", 8, 1)\n\n        # Test invalid group\n        with self.assertRaises(ValidationError):\n            e(\"1-5-10\", 10, 1)\n\n        with self.assertRaises(ValidationError):\n            e(\"10, a, 7-70j\", 4, 1)\n\n        # Test groups are not interpolated with word characters\n        with self.assertRaises(ValidationError):\n            e(\"1, 2, 3, E-5\", 5, 1)\n\n    def test_combinations(self):\n        \"\"\"Test complex serial number combinations.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        sn = e(\"1 3-5 9+2\", 7, 1)\n        self.assertEqual(len(sn), 7)\n        self.assertEqual(sn, [1, 3, 4, 5, 9, 10, 11])\n\n        sn = e(\"1,3-5,9+2\", 7, 1)\n        self.assertEqual(len(sn), 7)\n        self.assertEqual(sn, [1, 3, 4, 5, 9, 10, 11])\n\n        sn = e(\"~+2\", 3, 14)\n        self.assertEqual(len(sn), 3)\n        self.assertEqual(sn, [14, 15, 16])\n\n        sn = e(\"~+\", 2, 14)\n        self.assertEqual(len(sn), 2)\n        self.assertEqual(sn, [14, 15])\n\n\nclass TestVersionNumber(TestCase):\n    \"\"\"Unit tests for version number functions.\"\"\"\n\n    def test_tuple(self):\n        \"\"\"Test inventreeVersionTuple.\"\"\"\n        v = version.inventreeVersionTuple()\n        self.assertEqual(len(v), 3)\n\n        s = '.'.join([str(i) for i in v])\n\n        self.assertTrue(s in version.inventreeVersion())\n\n    def test_comparison(self):\n        \"\"\"Test direct comparison of version numbers.\"\"\"\n        v_a = version.inventreeVersionTuple('1.2.0')\n        v_b = version.inventreeVersionTuple('1.2.3')\n        v_c = version.inventreeVersionTuple('1.2.4')\n        v_d = version.inventreeVersionTuple('2.0.0')\n\n        self.assertTrue(v_b > v_a)\n        self.assertTrue(v_c > v_b)\n        self.assertTrue(v_d > v_c)\n        self.assertTrue(v_d > v_a)\n\n    def test_commit_info(self):\n        \"\"\"Test that the git commit information is extracted successfully.\"\"\"\n        envs = {\n            'INVENTREE_COMMIT_HASH': 'abcdef',\n            'INVENTREE_COMMIT_DATE': '2022-12-31'\n        }\n\n        # Check that the environment variables take priority\n\n        with mock.patch.dict(os.environ, envs):\n            self.assertEqual(version.inventreeCommitHash(), 'abcdef')\n            self.assertEqual(version.inventreeCommitDate(), '2022-12-31')\n\n        import subprocess\n\n        # Check that the current .git values work too\n\n        hash = str(subprocess.check_output('git rev-parse --short HEAD'.split()), 'utf-8').strip()\n        self.assertEqual(hash, version.inventreeCommitHash())\n\n        d = str(subprocess.check_output('git show -s --format=%ci'.split()), 'utf-8').strip().split(' ')[0]\n        self.assertEqual(d, version.inventreeCommitDate())\n\n\nclass CurrencyTests(TestCase):\n    \"\"\"Unit tests for currency / exchange rate functionality.\"\"\"\n\n    def test_rates(self):\n        \"\"\"Test exchange rate update.\"\"\"\n        # Initially, there will not be any exchange rate information\n        rates = Rate.objects.all()\n\n        self.assertEqual(rates.count(), 0)\n\n        # Without rate information, we cannot convert anything...\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'USD'), 'AUD')\n\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'AUD'), 'USD')\n\n        update_successful = False\n\n        # Note: the update sometimes fails in CI, let's give it a few chances\n        for _ in range(10):\n            InvenTree.tasks.update_exchange_rates()\n\n            rates = Rate.objects.all()\n\n            if rates.count() == len(currency_codes()):\n                update_successful = True\n                break\n\n            else:  # pragma: no cover\n                print(\"Exchange rate update failed - retrying\")\n                time.sleep(1)\n\n        self.assertTrue(update_successful)\n\n        # Now that we have some exchange rate information, we can perform conversions\n\n        # Forwards\n        convert_money(Money(100, 'USD'), 'AUD')\n\n        # Backwards\n        convert_money(Money(100, 'AUD'), 'USD')\n\n        # Convert between non base currencies\n        convert_money(Money(100, 'CAD'), 'NZD')\n\n        # Convert to a symbol which is not covered\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'GBP'), 'ZWL')\n\n\nclass TestStatus(TestCase):\n    \"\"\"Unit tests for status functions.\"\"\"\n\n    def test_check_system_healt(self):\n        \"\"\"Test that the system health check is false in testing -> background worker not running.\"\"\"\n        self.assertEqual(status.check_system_health(), False)\n\n    def test_TestMode(self):\n        \"\"\"Test isInTestMode check.\"\"\"\n        self.assertTrue(ready.isInTestMode())\n\n    def test_Importing(self):\n        \"\"\"Test isImportingData check.\"\"\"\n        self.assertEqual(ready.isImportingData(), False)\n\n\nclass TestSettings(helpers.InvenTreeTestCase):\n    \"\"\"Unit tests for settings.\"\"\"\n\n    superuser = True\n\n    def in_env_context(self, envs=None):\n        \"\"\"Patch the env to include the given dict.\"\"\"\n        # Set default - see B006\n        if envs is None:\n            envs = {}\n\n        return mock.patch.dict(os.environ, envs)\n\n    def run_reload(self, envs=None):\n        \"\"\"Helper function to reload InvenTree.\"\"\"\n        # Set default - see B006\n        if envs is None:\n            envs = {}\n\n        from plugin import registry\n\n        with self.in_env_context(envs):\n            settings.USER_ADDED = False\n            registry.reload_plugins()\n\n    @override_settings(TESTING_ENV=True)\n    def test_set_user_to_few(self):\n        \"\"\"Test adding an admin user via env variables.\"\"\"\n        user_model = get_user_model()\n        # add shortcut\n        user_count = user_model.objects.count\n        # enable testing mode\n        settings.TESTING_ENV = True\n\n        # nothing set\n        self.run_reload()\n        self.assertEqual(user_count(), 1)\n\n        # not enough set\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': 'admin'\n        })\n        self.assertEqual(user_count(), 1)\n\n        # enough set\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': 'admin',  # set username\n            'INVENTREE_ADMIN_EMAIL': 'info@example.com',  # set email\n            'INVENTREE_ADMIN_PASSWORD': 'password123'  # set password\n        })\n        self.assertEqual(user_count(), 2)\n\n        username2 = 'testuser1'\n        email2 = 'test1@testing.com'\n        password2 = 'password1'\n\n        # create user manually\n        user_model.objects.create_user(username2, email2, password2)\n        self.assertEqual(user_count(), 3)\n        # check it will not be created again\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': username2,\n            'INVENTREE_ADMIN_EMAIL': email2,\n            'INVENTREE_ADMIN_PASSWORD': password2,\n        })\n        self.assertEqual(user_count(), 3)\n\n        # make sure to clean up\n        settings.TESTING_ENV = False\n\n    def test_initial_install(self):\n        \"\"\"Test if install of plugins on startup works.\"\"\"\n        from plugin import registry\n\n        # Check an install run\n        response = registry.install_plugin_file()\n        self.assertEqual(response, 'first_run')\n\n        # Set dynamic setting to True and rerun to launch install\n        InvenTreeSetting.set_setting('PLUGIN_ON_STARTUP', True, self.user)\n        registry.reload_plugins(full_reload=True)\n\n        # Check that there was anotehr run\n        response = registry.install_plugin_file()\n        self.assertEqual(response, True)\n\n    def test_helpers_cfg_file(self):\n        \"\"\"Test get_config_file.\"\"\"\n        # normal run - not configured\n\n        valid = [\n            'inventree/config.yaml',\n            'inventree/data/config.yaml',\n        ]\n\n        self.assertTrue(any([opt in str(config.get_config_file()).lower() for opt in valid]))\n\n        # with env set\n        with self.in_env_context({'INVENTREE_CONFIG_FILE': 'my_special_conf.yaml'}):\n            self.assertIn('inventree/my_special_conf.yaml', str(config.get_config_file()).lower())\n\n    def test_helpers_plugin_file(self):\n        \"\"\"Test get_plugin_file.\"\"\"\n        # normal run - not configured\n\n        valid = [\n            'inventree/plugins.txt',\n            'inventree/data/plugins.txt',\n        ]\n\n        self.assertTrue(any([opt in str(config.get_plugin_file()).lower() for opt in valid]))\n\n        # with env set\n        with self.in_env_context({'INVENTREE_PLUGIN_FILE': 'my_special_plugins.txt'}):\n            self.assertIn('my_special_plugins.txt', str(config.get_plugin_file()))\n\n    def test_helpers_setting(self):\n        \"\"\"Test get_setting.\"\"\"\n        TEST_ENV_NAME = '123TEST'\n        # check that default gets returned if not present\n        self.assertEqual(config.get_setting(TEST_ENV_NAME, None, '123!'), '123!')\n\n        # with env set\n        with self.in_env_context({TEST_ENV_NAME: '321'}):\n            self.assertEqual(config.get_setting(TEST_ENV_NAME, None), '321')\n\n\nclass TestInstanceName(helpers.InvenTreeTestCase):\n    \"\"\"Unit tests for instance name.\"\"\"\n\n    def test_instance_name(self):\n        \"\"\"Test instance name settings.\"\"\"\n        # default setting\n        self.assertEqual(version.inventreeInstanceTitle(), 'InvenTree')\n\n        # set up required setting\n        InvenTreeSetting.set_setting(\"INVENTREE_INSTANCE_TITLE\", True, self.user)\n        InvenTreeSetting.set_setting(\"INVENTREE_INSTANCE\", \"Testing title\", self.user)\n\n        self.assertEqual(version.inventreeInstanceTitle(), 'Testing title')\n\n        # The site should also be changed\n        site_obj = Site.objects.all().order_by('id').first()\n        self.assertEqual(site_obj.name, 'Testing title')\n\n    def test_instance_url(self):\n        \"\"\"Test instance url settings.\"\"\"\n        # Set up required setting\n        InvenTreeSetting.set_setting(\"INVENTREE_BASE_URL\", \"http://127.1.2.3\", self.user)\n\n        # The site should also be changed\n        site_obj = Site.objects.all().order_by('id').first()\n        self.assertEqual(site_obj.domain, 'http://127.1.2.3')\n\n\nclass TestOffloadTask(helpers.InvenTreeTestCase):\n    \"\"\"Tests for offloading tasks to the background worker\"\"\"\n\n    fixtures = [\n        'category',\n        'part',\n        'location',\n        'stock',\n    ]\n\n    def test_offload_tasks(self):\n        \"\"\"Test that we can offload various tasks to the background worker thread.\n\n        This set of tests also ensures that various types of objects\n        can be encoded by the django-q serialization layer!\n\n        Note that as the background worker is not actually running for the tests,\n        the call to 'offload_task' won't really *do* anything!\n\n        However, it serves as a validation that object serialization works!\n\n        Ref: https://github.com/inventree/InvenTree/pull/3273\n        \"\"\"\n\n        offload_task(\n            'dummy_tasks.parts',\n            part=Part.objects.get(pk=1),\n            cat=PartCategory.objects.get(pk=1),\n            force_async=True\n        )\n\n        offload_task(\n            'dummy_tasks.stock',\n            item=StockItem.objects.get(pk=1),\n            loc=StockLocation.objects.get(pk=1),\n            force_async=True\n        )\n\n        offload_task(\n            'dummy_task.numbers',\n            1, 2, 3, 4, 5,\n            force_async=True\n        )\n\n\nclass BarcodeMixinTest(helpers.InvenTreeTestCase):\n    \"\"\"Tests for the InvenTreeBarcodeMixin mixin class\"\"\"\n\n    def test_barcode_model_type(self):\n        \"\"\"Test that the barcode_model_type property works for each class\"\"\"\n\n        from part.models import Part\n        from stock.models import StockItem, StockLocation\n\n        self.assertEqual(Part.barcode_model_type(), 'part')\n        self.assertEqual(StockItem.barcode_model_type(), 'stockitem')\n        self.assertEqual(StockLocation.barcode_model_type(), 'stocklocation')\n\n    def test_bacode_hash(self):\n        \"\"\"Test that the barcode hashing function provides correct results\"\"\"\n\n        # Test multiple values for the hashing function\n        # This is to ensure that the hash function is always \"backwards compatible\"\n        hashing_tests = {\n            'abcdefg': '7ac66c0f148de9519b8bd264312c4d64',\n            'ABCDEFG': 'bb747b3df3130fe1ca4afa93fb7d97c9',\n            '1234567': 'fcea920f7412b5da7be0cf42b8c93759',\n            '{\"part\": 17, \"stockitem\": 12}': 'c88c11ed0628eb7fef0d59b098b96975',\n        }\n\n        for barcode, hash in hashing_tests.items():\n            self.assertEqual(InvenTree.helpers.hash_barcode(barcode), hash)\n\n\nclass SanitizerTest(TestCase):\n    \"\"\"Simple tests for sanitizer functions.\"\"\"\n\n    def test_svg_sanitizer(self):\n        \"\"\"Test that SVGs are sanitized acordingly.\"\"\"\n        valid_string = \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" id=\"svg2\" height=\"400\" width=\"400\">{0}\n        <path id=\"path1\" d=\"m -151.78571,359.62883 v 112.76373 l 97.068507,-56.04253 V 303.14815 Z\" style=\"fill:#ddbc91;\"></path>\n        </svg>\"\"\"\n        dangerous_string = valid_string.format('<script>alert();</script>')\n\n        # Test that valid string\n        self.assertEqual(valid_string, sanitize_svg(valid_string))\n\n        # Test that invalid string is cleanded\n        self.assertNotEqual(dangerous_string, sanitize_svg(dangerous_string))\n", "code_before": "\"\"\"Test general functions and helpers.\"\"\"\n\nimport json\nimport os\nimport time\nfrom decimal import Decimal\nfrom unittest import mock\n\nimport django.core.exceptions as django_exceptions\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.core.exceptions import ValidationError\nfrom django.test import TestCase, override_settings\n\nimport requests\nfrom djmoney.contrib.exchange.exceptions import MissingRate\nfrom djmoney.contrib.exchange.models import Rate, convert_money\nfrom djmoney.money import Money\n\nimport InvenTree.format\nimport InvenTree.helpers\nimport InvenTree.tasks\nfrom common.models import InvenTreeSetting\nfrom common.settings import currency_codes\nfrom part.models import Part, PartCategory\nfrom stock.models import StockItem, StockLocation\n\nfrom . import config, helpers, ready, status, version\nfrom .tasks import offload_task\nfrom .validators import validate_overage, validate_part_name\n\n\nclass ValidatorTest(TestCase):\n    \"\"\"Simple tests for custom field validators.\"\"\"\n\n    def test_part_name(self):\n        \"\"\"Test part name validator.\"\"\"\n        validate_part_name('hello world')\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_part_name('This | name is not } valid')\n\n    def test_overage(self):\n        \"\"\"Test overage validator.\"\"\"\n        validate_overage(\"100%\")\n        validate_overage(\"10\")\n        validate_overage(\"45.2 %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"-1\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"-2.04 %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"105%\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"xxx %\")\n\n        with self.assertRaises(django_exceptions.ValidationError):\n            validate_overage(\"aaaa\")\n\n\nclass FormatTest(TestCase):\n    \"\"\"Unit tests for custom string formatting functionality\"\"\"\n\n    def test_parse(self):\n        \"\"\"Tests for the 'parse_format_string' function\"\"\"\n\n        # Extract data from a valid format string\n        fmt = \"PO-{abc:02f}-{ref:04d}-{date}-???\"\n\n        info = InvenTree.format.parse_format_string(fmt)\n\n        self.assertIn('abc', info)\n        self.assertIn('ref', info)\n        self.assertIn('date', info)\n\n        # Try with invalid strings\n        for fmt in [\n            'PO-{{xyz}',\n            'PO-{xyz}}',\n            'PO-{xyz}-{',\n        ]:\n\n            with self.assertRaises(ValueError):\n                InvenTree.format.parse_format_string(fmt)\n\n    def test_create_regex(self):\n        \"\"\"Test function for creating a regex from a format string\"\"\"\n\n        tests = {\n            \"PO-123-{ref:04f}\": r\"^PO\\-123\\-(?P<ref>.+)$\",\n            \"{PO}-???-{ref}-{date}-22\": r\"^(?P<PO>.+)\\-...\\-(?P<ref>.+)\\-(?P<date>.+)\\-22$\",\n            \"ABC-123-###-{ref}\": r\"^ABC\\-123\\-\\d\\d\\d\\-(?P<ref>.+)$\",\n            \"ABC-123\": r\"^ABC\\-123$\",\n        }\n\n        for fmt, reg in tests.items():\n            self.assertEqual(InvenTree.format.construct_format_regex(fmt), reg)\n\n    def test_validate_format(self):\n        \"\"\"Test that string validation works as expected\"\"\"\n\n        # These tests should pass\n        for value, pattern in {\n            \"ABC-hello-123\": \"???-{q}-###\",\n            \"BO-1234\": \"BO-{ref}\",\n            \"111.222.fred.china\": \"???.###.{name}.{place}\",\n            \"PO-1234\": \"PO-{ref:04d}\"\n        }.items():\n            self.assertTrue(InvenTree.format.validate_string(value, pattern))\n\n        # These tests should fail\n        for value, pattern in {\n            \"ABC-hello-123\": \"###-{q}-???\",\n            \"BO-1234\": \"BO.{ref}\",\n            \"BO-####\": \"BO-{pattern}-{next}\",\n            \"BO-123d\": \"BO-{ref:04d}\"\n        }.items():\n            self.assertFalse(InvenTree.format.validate_string(value, pattern))\n\n    def test_extract_value(self):\n        \"\"\"Test that we can extract named values based on a format string\"\"\"\n\n        # Simple tests based on a straight-forward format string\n        fmt = \"PO-###-{ref:04d}\"\n\n        tests = {\n            \"123\": \"PO-123-123\",\n            \"456\": \"PO-123-456\",\n            \"789\": \"PO-123-789\",\n        }\n\n        for k, v in tests.items():\n            self.assertEqual(InvenTree.format.extract_named_group('ref', v, fmt), k)\n\n        # However these ones should fail\n        tests = {\n            'abc': 'PO-123-abc',\n            'xyz': 'PO-123-xyz',\n        }\n\n        for v in tests.values():\n            with self.assertRaises(ValueError):\n                InvenTree.format.extract_named_group('ref', v, fmt)\n\n        # More complex tests\n        fmt = \"PO-{date}-{test}-???-{ref}-###\"\n        val = \"PO-2022-02-01-hello-ABC-12345-222\"\n\n        data = {\n            'date': '2022-02-01',\n            'test': 'hello',\n            'ref': '12345',\n        }\n\n        for k, v in data.items():\n            self.assertEqual(InvenTree.format.extract_named_group(k, val, fmt), v)\n\n        # Test for error conditions\n\n        # Raises a ValueError as the format string is bad\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-1234-5\",\n                \"PO-{test}-{\"\n            )\n\n        # Raises a NameError as the named group does not exist in the format string\n        with self.assertRaises(NameError):\n            InvenTree.format.extract_named_group(\n                \"missing\",\n                \"PO-12345\",\n                \"PO-{test}\",\n            )\n\n        # Raises a ValueError as the value does not match the format string\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-1234\",\n                \"PO-{test}-1234\",\n            )\n\n        with self.assertRaises(ValueError):\n            InvenTree.format.extract_named_group(\n                \"test\",\n                \"PO-ABC-xyz\",\n                \"PO-###-{test}\",\n            )\n\n\nclass TestHelpers(TestCase):\n    \"\"\"Tests for InvenTree helper functions.\"\"\"\n\n    def test_image_url(self):\n        \"\"\"Test if a filename looks like an image.\"\"\"\n        for name in ['ape.png', 'bat.GiF', 'apple.WeBP', 'BiTMap.Bmp']:\n            self.assertTrue(helpers.TestIfImageURL(name))\n\n        for name in ['no.doc', 'nah.pdf', 'whatpng']:\n            self.assertFalse(helpers.TestIfImageURL(name))\n\n    def test_str2bool(self):\n        \"\"\"Test string to boolean conversion.\"\"\"\n        for s in ['yes', 'Y', 'ok', '1', 'OK', 'Ok', 'tRuE', 'oN']:\n            self.assertTrue(helpers.str2bool(s))\n            self.assertFalse(helpers.str2bool(s, test=False))\n\n        for s in ['nO', '0', 'none', 'noNE', None, False, 'falSe', 'off']:\n            self.assertFalse(helpers.str2bool(s))\n            self.assertTrue(helpers.str2bool(s, test=False))\n\n        for s in ['wombat', '', 'xxxx']:\n            self.assertFalse(helpers.str2bool(s))\n            self.assertFalse(helpers.str2bool(s, test=False))\n\n    def test_isnull(self):\n        \"\"\"Test isNull.\"\"\"\n        for s in ['null', 'none', '', '-1', 'false']:\n            self.assertTrue(helpers.isNull(s))\n\n        for s in ['yes', 'frog', 'llama', 'true']:\n            self.assertFalse(helpers.isNull(s))\n\n    def testStaticUrl(self):\n        \"\"\"Test static url helpers.\"\"\"\n        self.assertEqual(helpers.getStaticUrl('test.jpg'), '/static/test.jpg')\n        self.assertEqual(helpers.getBlankImage(), '/static/img/blank_image.png')\n        self.assertEqual(helpers.getBlankThumbnail(), '/static/img/blank_image.thumbnail.png')\n\n    def testMediaUrl(self):\n        \"\"\"Test getMediaUrl.\"\"\"\n        self.assertEqual(helpers.getMediaUrl('xx/yy.png'), '/media/xx/yy.png')\n\n    def testDecimal2String(self):\n        \"\"\"Test decimal2string.\"\"\"\n        self.assertEqual(helpers.decimal2string(Decimal('1.2345000')), '1.2345')\n        self.assertEqual(helpers.decimal2string('test'), 'test')\n\n    def test_logo_image(self):\n        \"\"\"Test for retrieving logo image\"\"\"\n\n        # By default, there is no custom logo provided\n\n        logo = helpers.getLogoImage()\n        self.assertEqual(logo, '/static/img/inventree.png')\n\n        logo = helpers.getLogoImage(as_file=True)\n        self.assertEqual(logo, f'file://{settings.STATIC_ROOT}/img/inventree.png')\n\n    def test_download_image(self):\n        \"\"\"Test function for downloading image from remote URL\"\"\"\n\n        # Run check with a sequency of bad URLs\n        for url in [\n            \"blog\",\n            \"htp://test.com/?\",\n            \"google\",\n            \"\\\\invalid-url\"\n        ]:\n            with self.assertRaises(django_exceptions.ValidationError):\n                helpers.download_image_from_url(url)\n\n        # Attempt to download an image which throws a 404\n        with self.assertRaises(requests.exceptions.HTTPError):\n            helpers.download_image_from_url(\"https://httpstat.us/404\", timeout=10)\n\n        # Attempt to download, but timeout\n        with self.assertRaises(requests.exceptions.Timeout):\n            helpers.download_image_from_url(\"https://httpstat.us/200?sleep=5000\")\n\n        # Attempt to download, but not a valid image\n        with self.assertRaises(TypeError):\n            helpers.download_image_from_url(\"https://httpstat.us/200\", timeout=10)\n\n        large_img = \"https://github.com/inventree/InvenTree/raw/master/InvenTree/InvenTree/static/img/paper_splash_large.jpg\"\n\n        InvenTreeSetting.set_setting('INVENTREE_DOWNLOAD_IMAGE_MAX_SIZE', 1, change_user=None)\n\n        # Attempt to download an image which is too large\n        with self.assertRaises(ValueError):\n            helpers.download_image_from_url(large_img, timeout=10)\n\n        # Increase allowable download size\n        InvenTreeSetting.set_setting('INVENTREE_DOWNLOAD_IMAGE_MAX_SIZE', 5, change_user=None)\n\n        # Download a valid image (should not throw an error)\n        helpers.download_image_from_url(large_img, timeout=10)\n\n\nclass TestQuoteWrap(TestCase):\n    \"\"\"Tests for string wrapping.\"\"\"\n\n    def test_single(self):\n        \"\"\"Test WrapWithQuotes.\"\"\"\n        self.assertEqual(helpers.WrapWithQuotes('hello'), '\"hello\"')\n        self.assertEqual(helpers.WrapWithQuotes('hello\"'), '\"hello\"')\n\n\nclass TestIncrement(TestCase):\n    \"\"\"Tests for increment function.\"\"\"\n\n    def tests(self):\n        \"\"\"Test 'intelligent' incrementing function.\"\"\"\n        tests = [\n            (\"\", \"\"),\n            (1, \"2\"),\n            (\"001\", \"002\"),\n            (\"1001\", \"1002\"),\n            (\"ABC123\", \"ABC124\"),\n            (\"XYZ0\", \"XYZ1\"),\n            (\"123Q\", \"123Q\"),\n            (\"QQQ\", \"QQQ\"),\n        ]\n\n        for test in tests:\n            a, b = test\n\n            result = helpers.increment(a)\n            self.assertEqual(result, b)\n\n\nclass TestMakeBarcode(TestCase):\n    \"\"\"Tests for barcode string creation.\"\"\"\n\n    def test_barcode_extended(self):\n        \"\"\"Test creation of barcode with extended data.\"\"\"\n        bc = helpers.MakeBarcode(\n            \"part\",\n            3,\n            {\n                \"id\": 3,\n                \"url\": \"www.google.com\",\n            },\n            brief=False\n        )\n\n        self.assertIn('part', bc)\n        self.assertIn('tool', bc)\n        self.assertIn('\"tool\": \"InvenTree\"', bc)\n\n        data = json.loads(bc)\n\n        self.assertEqual(data['part']['id'], 3)\n        self.assertEqual(data['part']['url'], 'www.google.com')\n\n    def test_barcode_brief(self):\n        \"\"\"Test creation of simple barcode.\"\"\"\n        bc = helpers.MakeBarcode(\n            \"stockitem\",\n            7,\n        )\n\n        data = json.loads(bc)\n        self.assertEqual(len(data), 1)\n        self.assertEqual(data['stockitem'], 7)\n\n\nclass TestDownloadFile(TestCase):\n    \"\"\"Tests for DownloadFile.\"\"\"\n\n    def test_download(self):\n        \"\"\"Tests for DownloadFile.\"\"\"\n        helpers.DownloadFile(\"hello world\", \"out.txt\")\n        helpers.DownloadFile(bytes(b\"hello world\"), \"out.bin\")\n\n\nclass TestMPTT(TestCase):\n    \"\"\"Tests for the MPTT tree models.\"\"\"\n\n    fixtures = [\n        'location',\n    ]\n\n    def setUp(self):\n        \"\"\"Setup for all tests.\"\"\"\n        super().setUp()\n\n        StockLocation.objects.rebuild()\n\n    def test_self_as_parent(self):\n        \"\"\"Test that we cannot set self as parent.\"\"\"\n        loc = StockLocation.objects.get(pk=4)\n        loc.parent = loc\n\n        with self.assertRaises(ValidationError):\n            loc.save()\n\n    def test_child_as_parent(self):\n        \"\"\"Test that we cannot set a child as parent.\"\"\"\n        parent = StockLocation.objects.get(pk=4)\n        child = StockLocation.objects.get(pk=5)\n\n        parent.parent = child\n\n        with self.assertRaises(ValidationError):\n            parent.save()\n\n    def test_move(self):\n        \"\"\"Move an item to a different tree.\"\"\"\n        drawer = StockLocation.objects.get(name='Drawer_1')\n\n        # Record the tree ID\n        tree = drawer.tree_id\n\n        home = StockLocation.objects.get(name='Home')\n\n        drawer.parent = home\n        drawer.save()\n\n        self.assertNotEqual(tree, drawer.tree_id)\n\n\nclass TestSerialNumberExtraction(TestCase):\n    \"\"\"Tests for serial number extraction code.\"\"\"\n\n    def test_simple(self):\n        \"\"\"Test simple serial numbers.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        sn = e(\"1-5\", 5, 1)\n        self.assertEqual(len(sn), 5, 1)\n        for i in range(1, 6):\n            self.assertIn(i, sn)\n\n        sn = e(\"1, 2, 3, 4, 5\", 5, 1)\n        self.assertEqual(len(sn), 5)\n\n        # Test partially specifying serials\n        sn = e(\"1, 2, 4+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 4, 5, 6])\n\n        # Test groups are not interpolated if enough serials are supplied\n        sn = e(\"1, 2, 3, AF5-69H, 5\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 3, \"AF5-69H\", 5])\n\n        # Test groups are not interpolated with more than one hyphen in a word\n        sn = e(\"1, 2, TG-4SR-92, 4+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, \"TG-4SR-92\", 4, 5])\n\n        # Test groups are not interpolated with alpha characters\n        sn = e(\"1, A-2, 3+\", 5, 1)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, \"A-2\", 3, 4, 5])\n\n        # Test multiple placeholders\n        sn = e(\"1 2 ~ ~ ~\", 5, 3)\n        self.assertEqual(len(sn), 5)\n        self.assertEqual(sn, [1, 2, 3, 4, 5])\n\n        sn = e(\"1-5, 10-15\", 11, 1)\n        self.assertIn(3, sn)\n        self.assertIn(13, sn)\n\n        sn = e(\"1+\", 10, 1)\n        self.assertEqual(len(sn), 10)\n        self.assertEqual(sn, [_ for _ in range(1, 11)])\n\n        sn = e(\"4, 1+2\", 4, 1)\n        self.assertEqual(len(sn), 4)\n        self.assertEqual(sn, [4, 1, 2, 3])\n\n        sn = e(\"~\", 1, 1)\n        self.assertEqual(len(sn), 1)\n        self.assertEqual(sn, [1])\n\n        sn = e(\"~\", 1, 3)\n        self.assertEqual(len(sn), 1)\n        self.assertEqual(sn, [3])\n\n        sn = e(\"~+\", 2, 5)\n        self.assertEqual(len(sn), 2)\n        self.assertEqual(sn, [5, 6])\n\n        sn = e(\"~+3\", 4, 5)\n        self.assertEqual(len(sn), 4)\n        self.assertEqual(sn, [5, 6, 7, 8])\n\n    def test_failures(self):\n        \"\"\"Test wron serial numbers.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        # Test duplicates\n        with self.assertRaises(ValidationError):\n            e(\"1,2,3,3,3\", 5, 1)\n\n        # Test invalid length\n        with self.assertRaises(ValidationError):\n            e(\"1,2,3\", 5, 1)\n\n        # Test empty string\n        with self.assertRaises(ValidationError):\n            e(\", , ,\", 0, 1)\n\n        # Test incorrect sign in group\n        with self.assertRaises(ValidationError):\n            e(\"10-2\", 8, 1)\n\n        # Test invalid group\n        with self.assertRaises(ValidationError):\n            e(\"1-5-10\", 10, 1)\n\n        with self.assertRaises(ValidationError):\n            e(\"10, a, 7-70j\", 4, 1)\n\n        # Test groups are not interpolated with word characters\n        with self.assertRaises(ValidationError):\n            e(\"1, 2, 3, E-5\", 5, 1)\n\n    def test_combinations(self):\n        \"\"\"Test complex serial number combinations.\"\"\"\n        e = helpers.extract_serial_numbers\n\n        sn = e(\"1 3-5 9+2\", 7, 1)\n        self.assertEqual(len(sn), 7)\n        self.assertEqual(sn, [1, 3, 4, 5, 9, 10, 11])\n\n        sn = e(\"1,3-5,9+2\", 7, 1)\n        self.assertEqual(len(sn), 7)\n        self.assertEqual(sn, [1, 3, 4, 5, 9, 10, 11])\n\n        sn = e(\"~+2\", 3, 14)\n        self.assertEqual(len(sn), 3)\n        self.assertEqual(sn, [14, 15, 16])\n\n        sn = e(\"~+\", 2, 14)\n        self.assertEqual(len(sn), 2)\n        self.assertEqual(sn, [14, 15])\n\n\nclass TestVersionNumber(TestCase):\n    \"\"\"Unit tests for version number functions.\"\"\"\n\n    def test_tuple(self):\n        \"\"\"Test inventreeVersionTuple.\"\"\"\n        v = version.inventreeVersionTuple()\n        self.assertEqual(len(v), 3)\n\n        s = '.'.join([str(i) for i in v])\n\n        self.assertTrue(s in version.inventreeVersion())\n\n    def test_comparison(self):\n        \"\"\"Test direct comparison of version numbers.\"\"\"\n        v_a = version.inventreeVersionTuple('1.2.0')\n        v_b = version.inventreeVersionTuple('1.2.3')\n        v_c = version.inventreeVersionTuple('1.2.4')\n        v_d = version.inventreeVersionTuple('2.0.0')\n\n        self.assertTrue(v_b > v_a)\n        self.assertTrue(v_c > v_b)\n        self.assertTrue(v_d > v_c)\n        self.assertTrue(v_d > v_a)\n\n    def test_commit_info(self):\n        \"\"\"Test that the git commit information is extracted successfully.\"\"\"\n        envs = {\n            'INVENTREE_COMMIT_HASH': 'abcdef',\n            'INVENTREE_COMMIT_DATE': '2022-12-31'\n        }\n\n        # Check that the environment variables take priority\n\n        with mock.patch.dict(os.environ, envs):\n            self.assertEqual(version.inventreeCommitHash(), 'abcdef')\n            self.assertEqual(version.inventreeCommitDate(), '2022-12-31')\n\n        import subprocess\n\n        # Check that the current .git values work too\n\n        hash = str(subprocess.check_output('git rev-parse --short HEAD'.split()), 'utf-8').strip()\n        self.assertEqual(hash, version.inventreeCommitHash())\n\n        d = str(subprocess.check_output('git show -s --format=%ci'.split()), 'utf-8').strip().split(' ')[0]\n        self.assertEqual(d, version.inventreeCommitDate())\n\n\nclass CurrencyTests(TestCase):\n    \"\"\"Unit tests for currency / exchange rate functionality.\"\"\"\n\n    def test_rates(self):\n        \"\"\"Test exchange rate update.\"\"\"\n        # Initially, there will not be any exchange rate information\n        rates = Rate.objects.all()\n\n        self.assertEqual(rates.count(), 0)\n\n        # Without rate information, we cannot convert anything...\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'USD'), 'AUD')\n\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'AUD'), 'USD')\n\n        update_successful = False\n\n        # Note: the update sometimes fails in CI, let's give it a few chances\n        for _ in range(10):\n            InvenTree.tasks.update_exchange_rates()\n\n            rates = Rate.objects.all()\n\n            if rates.count() == len(currency_codes()):\n                update_successful = True\n                break\n\n            else:  # pragma: no cover\n                print(\"Exchange rate update failed - retrying\")\n                time.sleep(1)\n\n        self.assertTrue(update_successful)\n\n        # Now that we have some exchange rate information, we can perform conversions\n\n        # Forwards\n        convert_money(Money(100, 'USD'), 'AUD')\n\n        # Backwards\n        convert_money(Money(100, 'AUD'), 'USD')\n\n        # Convert between non base currencies\n        convert_money(Money(100, 'CAD'), 'NZD')\n\n        # Convert to a symbol which is not covered\n        with self.assertRaises(MissingRate):\n            convert_money(Money(100, 'GBP'), 'ZWL')\n\n\nclass TestStatus(TestCase):\n    \"\"\"Unit tests for status functions.\"\"\"\n\n    def test_check_system_healt(self):\n        \"\"\"Test that the system health check is false in testing -> background worker not running.\"\"\"\n        self.assertEqual(status.check_system_health(), False)\n\n    def test_TestMode(self):\n        \"\"\"Test isInTestMode check.\"\"\"\n        self.assertTrue(ready.isInTestMode())\n\n    def test_Importing(self):\n        \"\"\"Test isImportingData check.\"\"\"\n        self.assertEqual(ready.isImportingData(), False)\n\n\nclass TestSettings(helpers.InvenTreeTestCase):\n    \"\"\"Unit tests for settings.\"\"\"\n\n    superuser = True\n\n    def in_env_context(self, envs=None):\n        \"\"\"Patch the env to include the given dict.\"\"\"\n        # Set default - see B006\n        if envs is None:\n            envs = {}\n\n        return mock.patch.dict(os.environ, envs)\n\n    def run_reload(self, envs=None):\n        \"\"\"Helper function to reload InvenTree.\"\"\"\n        # Set default - see B006\n        if envs is None:\n            envs = {}\n\n        from plugin import registry\n\n        with self.in_env_context(envs):\n            settings.USER_ADDED = False\n            registry.reload_plugins()\n\n    @override_settings(TESTING_ENV=True)\n    def test_set_user_to_few(self):\n        \"\"\"Test adding an admin user via env variables.\"\"\"\n        user_model = get_user_model()\n        # add shortcut\n        user_count = user_model.objects.count\n        # enable testing mode\n        settings.TESTING_ENV = True\n\n        # nothing set\n        self.run_reload()\n        self.assertEqual(user_count(), 1)\n\n        # not enough set\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': 'admin'\n        })\n        self.assertEqual(user_count(), 1)\n\n        # enough set\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': 'admin',  # set username\n            'INVENTREE_ADMIN_EMAIL': 'info@example.com',  # set email\n            'INVENTREE_ADMIN_PASSWORD': 'password123'  # set password\n        })\n        self.assertEqual(user_count(), 2)\n\n        username2 = 'testuser1'\n        email2 = 'test1@testing.com'\n        password2 = 'password1'\n\n        # create user manually\n        user_model.objects.create_user(username2, email2, password2)\n        self.assertEqual(user_count(), 3)\n        # check it will not be created again\n        self.run_reload({\n            'INVENTREE_ADMIN_USER': username2,\n            'INVENTREE_ADMIN_EMAIL': email2,\n            'INVENTREE_ADMIN_PASSWORD': password2,\n        })\n        self.assertEqual(user_count(), 3)\n\n        # make sure to clean up\n        settings.TESTING_ENV = False\n\n    def test_initial_install(self):\n        \"\"\"Test if install of plugins on startup works.\"\"\"\n        from plugin import registry\n\n        # Check an install run\n        response = registry.install_plugin_file()\n        self.assertEqual(response, 'first_run')\n\n        # Set dynamic setting to True and rerun to launch install\n        InvenTreeSetting.set_setting('PLUGIN_ON_STARTUP', True, self.user)\n        registry.reload_plugins(full_reload=True)\n\n        # Check that there was anotehr run\n        response = registry.install_plugin_file()\n        self.assertEqual(response, True)\n\n    def test_helpers_cfg_file(self):\n        \"\"\"Test get_config_file.\"\"\"\n        # normal run - not configured\n\n        valid = [\n            'inventree/config.yaml',\n            'inventree/data/config.yaml',\n        ]\n\n        self.assertTrue(any([opt in str(config.get_config_file()).lower() for opt in valid]))\n\n        # with env set\n        with self.in_env_context({'INVENTREE_CONFIG_FILE': 'my_special_conf.yaml'}):\n            self.assertIn('inventree/my_special_conf.yaml', str(config.get_config_file()).lower())\n\n    def test_helpers_plugin_file(self):\n        \"\"\"Test get_plugin_file.\"\"\"\n        # normal run - not configured\n\n        valid = [\n            'inventree/plugins.txt',\n            'inventree/data/plugins.txt',\n        ]\n\n        self.assertTrue(any([opt in str(config.get_plugin_file()).lower() for opt in valid]))\n\n        # with env set\n        with self.in_env_context({'INVENTREE_PLUGIN_FILE': 'my_special_plugins.txt'}):\n            self.assertIn('my_special_plugins.txt', str(config.get_plugin_file()))\n\n    def test_helpers_setting(self):\n        \"\"\"Test get_setting.\"\"\"\n        TEST_ENV_NAME = '123TEST'\n        # check that default gets returned if not present\n        self.assertEqual(config.get_setting(TEST_ENV_NAME, None, '123!'), '123!')\n\n        # with env set\n        with self.in_env_context({TEST_ENV_NAME: '321'}):\n            self.assertEqual(config.get_setting(TEST_ENV_NAME, None), '321')\n\n\nclass TestInstanceName(helpers.InvenTreeTestCase):\n    \"\"\"Unit tests for instance name.\"\"\"\n\n    def test_instance_name(self):\n        \"\"\"Test instance name settings.\"\"\"\n        # default setting\n        self.assertEqual(version.inventreeInstanceTitle(), 'InvenTree')\n\n        # set up required setting\n        InvenTreeSetting.set_setting(\"INVENTREE_INSTANCE_TITLE\", True, self.user)\n        InvenTreeSetting.set_setting(\"INVENTREE_INSTANCE\", \"Testing title\", self.user)\n\n        self.assertEqual(version.inventreeInstanceTitle(), 'Testing title')\n\n        # The site should also be changed\n        site_obj = Site.objects.all().order_by('id').first()\n        self.assertEqual(site_obj.name, 'Testing title')\n\n    def test_instance_url(self):\n        \"\"\"Test instance url settings.\"\"\"\n        # Set up required setting\n        InvenTreeSetting.set_setting(\"INVENTREE_BASE_URL\", \"http://127.1.2.3\", self.user)\n\n        # The site should also be changed\n        site_obj = Site.objects.all().order_by('id').first()\n        self.assertEqual(site_obj.domain, 'http://127.1.2.3')\n\n\nclass TestOffloadTask(helpers.InvenTreeTestCase):\n    \"\"\"Tests for offloading tasks to the background worker\"\"\"\n\n    fixtures = [\n        'category',\n        'part',\n        'location',\n        'stock',\n    ]\n\n    def test_offload_tasks(self):\n        \"\"\"Test that we can offload various tasks to the background worker thread.\n\n        This set of tests also ensures that various types of objects\n        can be encoded by the django-q serialization layer!\n\n        Note that as the background worker is not actually running for the tests,\n        the call to 'offload_task' won't really *do* anything!\n\n        However, it serves as a validation that object serialization works!\n\n        Ref: https://github.com/inventree/InvenTree/pull/3273\n        \"\"\"\n\n        offload_task(\n            'dummy_tasks.parts',\n            part=Part.objects.get(pk=1),\n            cat=PartCategory.objects.get(pk=1),\n            force_async=True\n        )\n\n        offload_task(\n            'dummy_tasks.stock',\n            item=StockItem.objects.get(pk=1),\n            loc=StockLocation.objects.get(pk=1),\n            force_async=True\n        )\n\n        offload_task(\n            'dummy_task.numbers',\n            1, 2, 3, 4, 5,\n            force_async=True\n        )\n\n\nclass BarcodeMixinTest(helpers.InvenTreeTestCase):\n    \"\"\"Tests for the InvenTreeBarcodeMixin mixin class\"\"\"\n\n    def test_barcode_model_type(self):\n        \"\"\"Test that the barcode_model_type property works for each class\"\"\"\n\n        from part.models import Part\n        from stock.models import StockItem, StockLocation\n\n        self.assertEqual(Part.barcode_model_type(), 'part')\n        self.assertEqual(StockItem.barcode_model_type(), 'stockitem')\n        self.assertEqual(StockLocation.barcode_model_type(), 'stocklocation')\n\n    def test_bacode_hash(self):\n        \"\"\"Test that the barcode hashing function provides correct results\"\"\"\n\n        # Test multiple values for the hashing function\n        # This is to ensure that the hash function is always \"backwards compatible\"\n        hashing_tests = {\n            'abcdefg': '7ac66c0f148de9519b8bd264312c4d64',\n            'ABCDEFG': 'bb747b3df3130fe1ca4afa93fb7d97c9',\n            '1234567': 'fcea920f7412b5da7be0cf42b8c93759',\n            '{\"part\": 17, \"stockitem\": 12}': 'c88c11ed0628eb7fef0d59b098b96975',\n        }\n\n        for barcode, hash in hashing_tests.items():\n            self.assertEqual(InvenTree.helpers.hash_barcode(barcode), hash)\n", "patch": "@@ -23,6 +23,7 @@\n import InvenTree.tasks\n from common.models import InvenTreeSetting\n from common.settings import currency_codes\n+from InvenTree.sanitizer import sanitize_svg\n from part.models import Part, PartCategory\n from stock.models import StockItem, StockLocation\n \n@@ -878,3 +879,20 @@ def test_bacode_hash(self):\n \n         for barcode, hash in hashing_tests.items():\n             self.assertEqual(InvenTree.helpers.hash_barcode(barcode), hash)\n+\n+\n+class SanitizerTest(TestCase):\n+    \"\"\"Simple tests for sanitizer functions.\"\"\"\n+\n+    def test_svg_sanitizer(self):\n+        \"\"\"Test that SVGs are sanitized acordingly.\"\"\"\n+        valid_string = \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" id=\"svg2\" height=\"400\" width=\"400\">{0}\n+        <path id=\"path1\" d=\"m -151.78571,359.62883 v 112.76373 l 97.068507,-56.04253 V 303.14815 Z\" style=\"fill:#ddbc91;\"></path>\n+        </svg>\"\"\"\n+        dangerous_string = valid_string.format('<script>alert();</script>')\n+\n+        # Test that valid string\n+        self.assertEqual(valid_string, sanitize_svg(valid_string))\n+\n+        # Test that invalid string is cleanded\n+        self.assertNotEqual(dangerous_string, sanitize_svg(dangerous_string))", "file_path": "files/2022_9/77", "file_language": "py", "file_name": "InvenTree/InvenTree/tests.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
