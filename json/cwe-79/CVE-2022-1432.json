{"index": 8200, "cve_id": "CVE-2022-1432", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Cross-site Scripting (XSS) - Generic in GitHub repository octoprint/octoprint prior to 1.8.0.", "cvss": "6.4", "publish_date": "May 18, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "HIGH", "UI": "REQUIRED", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "6d259d7e6f5b0de9a1c762831537a386e53978d3", "commit_message": "\ud83d\udd12\ufe0f Fix XSS in webcam stream test", "commit_date": "2022-05-11T14:40:07Z", "project": "octoprint/octoprint", "url": "https://api.github.com/repos/OctoPrint/OctoPrint/commits/6d259d7e6f5b0de9a1c762831537a386e53978d3", "html_url": "https://github.com/OctoPrint/OctoPrint/commit/6d259d7e6f5b0de9a1c762831537a386e53978d3", "windows_before": [{"commit_id": "5ef16773c89df25be4c10b8adf38988b549b3f71", "commit_date": "Wed May 11 13:03:40 2022 +0200", "commit_message": "\ud83d\udd12\ufe0f Escape requested user id", "files_name": ["src/octoprint/templates/login.jinja2"]}, {"commit_id": "8087528e4a7ddd15c7d95ff662deb5ef7de90045", "commit_date": "Wed May 11 13:02:52 2022 +0200", "commit_message": "\ud83d\udd12\ufe0f Sanitize and validate login redirect", "files_name": ["src/octoprint/server/views.py"]}, {"commit_id": "0cf869a6fe36156b2dbfa041fdd14e3f5ca8b645", "commit_date": "Wed May 11 09:52:53 2022 +0100", "commit_message": "\u23eb Upgrade to FontAwesome 6 (#4484)", "files_name": ["src/octoprint/plugin/types.py", "src/octoprint/plugins/action_command_notification/__init__.py", "src/octoprint/plugins/pluginmanager/templates/pluginmanager_settings.jinja2", "src/octoprint/server/__init__.py", "src/octoprint/static/vendor/font-awesome-5.15.1/css/all.css", "src/octoprint/static/vendor/font-awesome-5.15.1/css/all.min.css", "src/octoprint/static/vendor/font-awesome-5.15.1/css/v4-shims.min.css", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-brands-400.eot", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-brands-400.svg", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-brands-400.ttf", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-brands-400.woff", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-brands-400.woff2", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-regular-400.eot", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-regular-400.svg", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-regular-400.ttf", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-regular-400.woff", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-regular-400.woff2", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-solid-900.eot", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-solid-900.svg", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-solid-900.ttf", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-solid-900.woff", "src/octoprint/static/vendor/font-awesome-5.15.1/webfonts/fa-solid-900.woff2", "src/octoprint/static/vendor/fontawesome-6.1.1/css/all.css", "src/octoprint/static/vendor/fontawesome-6.1.1/css/all.min.css", "src/octoprint/static/vendor/fontawesome-6.1.1/css/v4-shims.css", "src/octoprint/static/vendor/fontawesome-6.1.1/css/v4-shims.min.css", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-brands-400.ttf", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-brands-400.woff2", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-regular-400.ttf", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-regular-400.woff2", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-solid-900.ttf", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-solid-900.woff2", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-v4compatibility.ttf", "src/octoprint/static/vendor/fontawesome-6.1.1/webfonts/fa-v4compatibility.woff2", "src/octoprint/templates/index.jinja2", "src/octoprint/templates/stylesheets-preload.jinja2"]}, {"commit_id": "700034d028ff3518b563a7b4ba4dacc920142d07", "commit_date": "Tue May 10 20:56:48 2022 +0200", "commit_message": "\ud83d\udd12\ufe0f Set remember_me cookie http only", "files_name": ["src/octoprint/server/__init__.py"]}, {"commit_id": "500729607d00069e65ca2105f5af42919d861792", "commit_date": "Wed May 4 09:29:15 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["885ca31168957533213ccbf471717d60afebe730 - Wed May 4 11:28:25 2022 +0200 : \ud83d\udc77\u200d\u2642\ufe0f Fix nightly merge", ".github/workflows/nightly_merge.yml"]}, {"commit_id": "cafd480642857755eff64c2c68589f8cb44bc716", "commit_date": "Tue May 3 01:49:27 2022 +1000", "commit_message": ":bug: Don't block unused keys when keyboard control is active (#4483)", "files_name": ["src/octoprint/static/js/app/viewmodels/control.js"]}, {"commit_id": "1a5de41a0ff2f1c5b6488ee9f7f4a6ef5a767dd3", "commit_date": "Mon May 2 08:40:13 2022 -0700", "commit_message": "\ud83d\udc1b Remove use of HTML entity degree symbol in temperature title attribute (#4490)", "files_name": ["AUTHORS.md", "src/octoprint/static/js/app/helpers.js", "src/octoprint/templates/tabs/temperature.jinja2", "tests/static/js/test-helpers.html", "tests/static/js/test-helpers.js"]}, {"commit_id": "64c21ba8f051051ae3824ddcdd3fe60d5a5f587e", "commit_date": "Sun Apr 24 09:21:13 2022 -0700", "commit_message": ":pencil2: Documentation spelling fixes (#4497)", "files_name": ["docs/api/datamodel.rst", "docs/configuration/config_yaml.rst", "docs/development/virtual_printer.rst", "docs/features/accesscontrol.rst", "docs/plugins/hooks.rst", "docs/plugins/python3_migration.rst"]}, {"commit_id": "671829a4f13b6ad22e82e5ac0a70ef1b3646644f", "commit_date": "Fri Apr 22 10:31:30 2022 -0700", "commit_message": ":pencil2: Fix minor spelling issue (#4492)", "files_name": ["src/octoprint/plugins/softwareupdate/templates/softwareupdate_settings.jinja2"]}, {"commit_id": "e5af809795a4e729ab915683a050bcea7fe89b06", "commit_date": "Tue Apr 12 16:22:15 2022 +0200", "commit_message": "Merge branch 'staging/maintenance' into maintenance", "files_name": ["53dbde2ef97c6152841fce3fd35ff43252f4931e - Tue Apr 12 16:21:41 2022 +0200 : \ud83d\udd16 staging/maintenance is now 1.8.0rc6.dev", ".versioneer-lookup"]}, {"commit_id": "45598764e6c7f6257de87a98d15964209ddc9e09", "commit_date": "Tue Apr 12 15:30:56 2022 +0200", "commit_message": "\ud83d\udd16 Preparing release of 1.8.0rc5", "files_name": ["src/octoprint/plugins/errortracking/__init__.py"]}, {"commit_id": "2ecc1c944f9f00bbd4a3e273f0c591e74d06305d", "commit_date": "Tue Apr 12 14:26:55 2022 +0200", "commit_message": "\ud83e\udd45 Only use the first value pair for a temp sensor", "files_name": ["src/octoprint/util/comm.py", "tests/util/test_comm_helpers.py"]}, {"commit_id": "d81504c12e84c07a767176f93a40f61f790ce3a6", "commit_date": "Mon Apr 11 16:51:22 2022 +0200", "commit_message": "\ud83d\udc1b Fix folder saving & config migration", "files_name": ["src/octoprint/server/api/settings.py", "src/octoprint/settings.py"]}, {"commit_id": "d1c96cbb3706fb774494b37d350d5a660d70a6eb", "commit_date": "Thu Apr 7 14:07:35 2022 +0200", "commit_message": ":pencil2: Replace 'mm/s' with 'mm/min' in docs (#4470)", "files_name": ["docs/features/custom_controls.rst", "src/octoprint/printer/profile.py"]}, {"commit_id": "9ec00f9471564ea797336d58f4d40684a036f69b", "commit_date": "Thu Apr 7 07:00:23 2022 -0500", "commit_message": ":pencil2: Tiny documentation typo, timeouts -> timeout (#4468)", "files_name": ["src/octoprint/settings.py"]}, {"commit_id": "2e4af01b0f5e22b9caaf44be73cbe2e26d229f3b", "commit_date": "Wed Apr 6 12:31:42 2022 +0200", "commit_message": "\u2b06\ufe0f Upgrade flask-login & werkzeug", "files_name": ["setup.py"]}, {"commit_id": "a0128a3a3953697b2129d82339899a277b3db45f", "commit_date": "Tue Apr 5 14:50:02 2022 +0200", "commit_message": "Merge branch 'staging/maintenance' into maintenance", "files_name": ["302ccc087b46fff590494f184096b29bb2d09c3b - Tue Apr 5 14:49:48 2022 +0200 : \ud83d\udd16 staging/maintenance is now 1.8.0rc5.dev", ".versioneer-lookup"]}, {"commit_id": "c5b095a8b905d759c84acab5e8a65ed3170d124c", "commit_date": "Tue Apr 5 13:25:05 2022 +0200", "commit_message": "\ud83d\udd16 Preparing release of 1.8.0rc4", "files_name": ["SUPPORTERS.md", "src/octoprint/plugins/errortracking/__init__.py"]}, {"commit_id": "f4b4f50cfddf81465b128cb6c67709b9c1a6f4c5", "commit_date": "Mon Apr 4 19:02:44 2022 +0200", "commit_message": "\ud83d\udc1b Fix handling of invalid intermittend values", "files_name": ["src/octoprint/settings.py", "tests/settings/test_settings.py"]}, {"commit_id": "fe2d17622108b3324c9b80178a1a8016b8e6d3d5", "commit_date": "Wed Mar 30 16:03:22 2022 +0200", "commit_message": "\u2b06\ufe0f Upgrade Sphinx et al", "files_name": ["docs/_static/theme_overrides.css", "docs/api/printerprofiles.rst", "docs/api/users.rst", "docs/bundledplugins/loginui.rst", "docs/conf.py", "docs/plugins/gettingstarted.rst", "docs/plugins/helpers.rst", "docs/plugins/hooks.rst", "docs/plugins/mixins.rst", "setup.py", "src/octoprint/plugin/types.py", "src/octoprint/util/__init__.py", "src/octoprint/util/commandline.py"]}, {"commit_id": "7a124d186138fb9502a2c42b6aa707135183e538", "commit_date": "Tue Mar 29 14:06:37 2022 +0200", "commit_message": "Merge branch 'staging/maintenance' into maintenance", "files_name": ["9faec6e9823aaec24d883bcfa692252c59c7f59a - Tue Mar 29 14:05:23 2022 +0200 : \ud83d\udd16 staging/maintenance is now 1.8.0rc4.dev", ".versioneer-lookup"]}, {"commit_id": "3c478036ae9edde3dd294af28bf1d8c78a2555d5", "commit_date": "Tue Mar 29 11:19:35 2022 +0200", "commit_message": "Merge branch 'master' into staging/maintenance", "files_name": ["76e87ba81329e6ce761c9307d3e80c291000871e - Tue Mar 29 11:19:16 2022 +0200 : \ud83d\udc9a Pin click in pre-commit black", ".pre-commit-config.yaml"]}, {"commit_id": "ad32bbfdb819b92dbedc10ea083fd57a7017116d", "commit_date": "Tue Mar 29 10:55:15 2022 +0200", "commit_message": "\ud83d\udc1b Add back accidentally removed flask-login req", "files_name": ["setup.py"]}, {"commit_id": "ccd5fa56a239d42830cb6825b779bc5aa141ee93", "commit_date": "Tue Mar 29 10:38:04 2022 +0200", "commit_message": "\ud83d\udccc Pin werkzeug to 2.0.x for now", "files_name": ["setup.py"]}, {"commit_id": "24b5b3a857d0339107904536ba004a64b69920b3", "commit_date": "Mon Mar 28 16:42:46 2022 +0200", "commit_message": "\ud83d\udc1b Fix potential race condition in webassets", "files_name": ["src/octoprint/server/__init__.py", "src/octoprint/server/util/webassets.py"]}, {"commit_id": "3be85646cd599841f57afcd5a4acc5a240c018c5", "commit_date": "Mon Mar 28 14:27:38 2022 +0200", "commit_message": "\ud83d\udd16 Preparing release of 1.8.0rc3", "files_name": ["SUPPORTERS.md", "src/octoprint/plugins/errortracking/__init__.py", "src/octoprint/translations/de/LC_MESSAGES/messages.mo", "src/octoprint/translations/de/LC_MESSAGES/messages.po", "translations/de/LC_MESSAGES/messages.mo", "translations/de/LC_MESSAGES/messages.po", "translations/messages.pot"]}, {"commit_id": "54207abbe16533513a46787172308963e7f507f7", "commit_date": "Mon Mar 28 11:23:35 2022 +0200", "commit_message": "\u2b06\ufe0f Require latest version of the PiSupport plugin", "files_name": ["setup.py"]}, {"commit_id": "37bc8741315847d8d417f59aaa107927bb01dbe7", "commit_date": "Wed Mar 23 10:55:12 2022 +0100", "commit_message": "\u2b06\ufe0f pre-commit: upgrade flake8-bugbear & fix issues", "files_name": [".pre-commit-config.yaml", "src/octoprint/plugin/types.py", "src/octoprint/server/util/watchdog.py", "src/octoprint/server/views.py", "src/octoprint/util/comm.py"]}, {"commit_id": "bf96e6321f91a41be8052e0865b739f6aabb562c", "commit_date": "Wed Mar 23 10:24:55 2022 +0100", "commit_message": "Merge branch 'staging/maintenance' into maintenance", "files_name": ["4c4721518c55d2afe5c61054a7313551dec57c0a - Wed Mar 23 10:24:02 2022 +0100 : Merge branch 'master' into staging/maintenance", "772f9f95da25839dadcc8e3036abd986fc5788af - Wed Mar 23 10:23:18 2022 +0100 : \ud83d\udccc pre-commit: Pin flake8 bugbear", ".pre-commit-config.yaml"]}, {"commit_id": "a8b6483b8ce1557f5ba7acf31146d49ee37abcb9", "commit_date": "Wed Mar 23 08:42:16 2022 +0100", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["a2f490ef9abad78ca4025b07035cd9b7e9b44881 - Wed Mar 23 08:39:32 2022 +0100 : Merge branch 'maintenance' of github.com:OctoPrint/OctoPrint into maintenance", "34e935bd0b94b9c46007192e52bcfe715eefb87d - Tue Mar 22 17:09:21 2022 +0100 : \ud83d\udc1b GCV: Moves may be arcs too", "src/octoprint/plugins/gcodeviewer/static/js/viewer/renderer.js"]}, {"commit_id": "6728a174486eb29d2f393414f312324775be107d", "commit_date": "Tue Mar 22 12:07:59 2022 +0100", "commit_message": "\ud83d\udeb8 Re-enable connect dialog w/ no serial ports", "files_name": ["src/octoprint/static/js/app/viewmodels/connection.js"]}, {"commit_id": "7bc2a79642db98aa7a3f4477fe1cedeaec22a74e", "commit_date": "Thu Mar 17 17:32:24 2022 -0500", "commit_message": ":pencil2: Spelling correction in software update docs (#4466)", "files_name": ["AUTHORS.md", "docs/bundledplugins/softwareupdate.rst"]}, {"commit_id": "8c9536f323b13bfc3f8db29eba1f395af32b049c", "commit_date": "Thu Mar 17 14:28:16 2022 +0100", "commit_message": "\ud83d\udc1b GCV: Send the final layer to the UI as well", "files_name": ["src/octoprint/plugins/gcodeviewer/static/js/viewer/worker.js"]}, {"commit_id": "1695dd45b9d3c27f612f7fa6ed482e15ddb427f5", "commit_date": "Thu Mar 17 00:10:16 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["594b660bb6eacc61a1b8f0f01f3b167de12ba3d2 - Wed Mar 16 21:44:03 2022 +0000 : :pencil2", "docs/configuration/config_yaml.rst"]}, {"commit_id": "635d6179e38123377ba2a76bdd2c6048dcdbf7e8", "commit_date": "Wed Mar 16 11:53:51 2022 +0100", "commit_message": "Merge branch 'staging/maintenance' into maintenance", "files_name": ["23f90060c6ab8d281fc30e8475dd0aefb1dabac2 - Wed Mar 16 11:53:23 2022 +0100 : \ud83d\udd16 staging/maintenance is now 1.8.0rc3.dev", ".versioneer-lookup"]}, {"commit_id": "76c59245329b8f485061ba20d21a56df4d474c34", "commit_date": "Wed Mar 16 10:45:52 2022 +0100", "commit_message": "\u2b06\ufe0f Force upgrade PiSupport to 2022.3.1+", "files_name": ["setup.py"]}, {"commit_id": "6fc2edcc1fcbe2694959c0373f9bd5d917291469", "commit_date": "Tue Mar 15 19:30:30 2022 +0100", "commit_message": "\ud83d\udeb8 Expose serial.ignoreEmptyPorts on UI", "files_name": ["src/octoprint/static/js/app/viewmodels/settings.js", "src/octoprint/templates/dialogs/settings/serialconnection.jinja2"]}], "windows_after": [{"commit_id": "4d9e86ca0fcb5d99a08a6a27ecc79bfcd02eb950", "commit_date": "Thu May 12 10:57:39 2022 +0200", "commit_message": "\ud83d\udc1b We also recognize webrtcs: for webcam streams", "files_name": ["src/octoprint/static/js/app/helpers.js"]}, {"commit_id": "d1fca86636ba8b990e9055d4825f20f062619f9b", "commit_date": "Thu May 12 10:58:08 2022 +0200", "commit_message": "\ud83e\udd45 Better error handling", "files_name": ["src/octoprint/static/js/app/viewmodels/control.js"]}, {"commit_id": "8ca327669c7417e13294259d831afed438de3641", "commit_date": "Thu May 12 18:58:16 2022 +0200", "commit_message": "\ud83d\udd12\ufe0f XSS in webcam stream URL test in Chrome", "files_name": ["src/octoprint/static/js/app/viewmodels/control.js", "src/octoprint/static/js/app/viewmodels/settings.js"]}, {"commit_id": "d2a9aacedacf2b582faca462d6e915f88676a3d5", "commit_date": "Mon May 16 14:55:05 2022 +0200", "commit_message": "\ud83d\udd16 Preparing release of 1.8.0", "files_name": ["SUPPORTERS.md", "babel.cfg", "src/octoprint/plugins/errortracking/__init__.py", "src/octoprint/translations/de/LC_MESSAGES/messages.mo", "src/octoprint/translations/de/LC_MESSAGES/messages.po", "translations/de/LC_MESSAGES/messages.mo", "translations/de/LC_MESSAGES/messages.po", "translations/messages.pot"]}, {"commit_id": "f430257d7072a83692fc2392c683ed8c97ae47b6", "commit_date": "Mon May 16 14:58:38 2022 +0200", "commit_message": "Merge branch 'rc/maintenance'", "files_name": ["158a5c2522fa26fb8ff6f4f6368e229a16301389 - Tue May 17 13:38:49 2022 +0200 : Merge branch 'master' into maintenance", "4daa5f61fb09918be1a5f48862d158767a963480 - Tue May 17 13:42:15 2022 +0200 : Merge branch 'maintenance' of github.com:OctoPrint/OctoPrint into maintenance", "26aac1701fecaf955c125f936f1dcbf91ff2a110 - Thu May 19 09:25:03 2022 +0200 : \ud83d\udd16 staging/bugfix is 1.8.1.dev", ".versioneer-lookup"]}, {"commit_id": "89fbcfd2143f3e98d79d71d4aab7eec164b2ac6c", "commit_date": "Thu May 19 09:38:00 2022 +0200", "commit_message": "\ud83d\udc1b Gracefully handle errors scanning /dev", "files_name": ["src/octoprint/util/comm.py"]}, {"commit_id": "77904a71b45e6d017cf4c7e5eb8b8d973693c146", "commit_date": "Thu May 19 13:08:16 2022 +0200", "commit_message": "\ud83d\udd12\ufe0f Fix an XSS issue in the user/group delete confirmation", "files_name": ["src/octoprint/static/js/app/viewmodels/access.js"]}, {"commit_id": "866c9a20d73396bbac6f57186f3d8aacaad9386a", "commit_date": "Tue May 24 10:26:57 2022 +0200", "commit_message": "\ud83d\udc1b Fix a redirect loop on login", "files_name": ["src/octoprint/server/util/__init__.py"]}, {"commit_id": "d56e8302c7a4e783a7a2d25029af820c645e33a1", "commit_date": "Tue May 24 10:27:54 2022 +0200", "commit_message": "Update black to 22.3.0 (#4510)", "files_name": [".pre-commit-config.yaml"]}, {"commit_id": "6709f9ca3c0fef9aaaca9d767ed5748633ceb4d0", "commit_date": "Tue May 24 10:28:42 2022 +0200", "commit_message": "Migrate black configuration to pyproject.toml (#4511)", "files_name": [".pre-commit-config.yaml", "docs/development/environment.rst", "pyproject.toml"]}, {"commit_id": "9a8dde165004ae38f032a4d35397cf8b2b916b71", "commit_date": "Tue May 24 10:32:53 2022 +0200", "commit_message": "Use lazy logging in octoprint. (#4512)", "files_name": ["src/octoprint/__init__.py"]}, {"commit_id": "260a1aef11432c421246019e25b6b744abbaed60", "commit_date": "Tue May 24 10:55:31 2022 +0200", "commit_message": "\ud83d\udd16 Preparing release of 1.8.1", "files_name": ["src/octoprint/plugins/errortracking/__init__.py"]}, {"commit_id": "7aa5cab728d7adfc9c27d084448e80c0c37ec334", "commit_date": "Tue May 24 12:24:11 2022 +0200", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["9491db60daf3c0a6037d6426eddf3b5fb0029725 - Tue May 24 12:24:17 2022 +0200 : Merge branch 'maintenance' of github.com:OctoPrint/OctoPrint into maintenance", "422e3d2b662315c8bf76a685660be6d37bb2796b - Tue May 24 12:25:17 2022 +0200 : \ud83d\udd16 staging/bugfix is now 1.8.2.dev", ".versioneer-lookup"]}, {"commit_id": "cd7f44cb57a9056aa0c6918f79bc24b012bcbdb5", "commit_date": "Wed May 25 16:01:31 2022 +0200", "commit_message": "There are not files with \\r-only line endings (#4450)", "files_name": ["src/octoprint/plugins/gcodeviewer/static/js/gcodeviewer.js"]}, {"commit_id": "c491f4fedc11e19972b278e389698cb2217752ef", "commit_date": "Mon May 30 10:04:51 2022 +0100", "commit_message": ":arrow_up: Bump wrapt to fix Python 3.11 compatibility (#4530)", "files_name": ["setup.py"]}, {"commit_id": "e2349b4565f5b1a41a0efde7feeaf372600b0b55", "commit_date": "Mon May 30 14:45:16 2022 +0200", "commit_message": "\ud83d\udc77 Ignore errors on Discord hook & e2e", "files_name": [".github/workflows/build.yml", ".github/workflows/test_install.yml"]}, {"commit_id": "53b9b6185781c07e8c4744a6e28462e96448f249", "commit_date": "Mon May 30 14:51:54 2022 +0200", "commit_message": "\ud83d\udc77 Only trigger release jobs on main repo", "files_name": [".github/workflows/build.yml"]}, {"commit_id": "5931d4493de856988478870bfbf31e45ca44dc35", "commit_date": "Mon May 30 13:00:08 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["fe84605f2477ed050bb4f9daa8533f418008aeac - Tue May 31 05:16:47 2022 -0700 : \ud83d\udc77 Add JS QUnit tests to build workflow with node-qunit-puppeteer (#4534)", ".github/workflows/build.yml"]}, {"commit_id": "e8be86c15f8de90b2b429e80ca75594c44345e0c", "commit_date": "Tue May 31 05:17:27 2022 -0700", "commit_message": "\u2705 Add a few unit tests for helpers.js (#4529)", "files_name": ["src/octoprint/static/js/app/helpers.js", "tests/static/js/test-helpers.js"]}, {"commit_id": "999ccac2308d613903448aaf654a4f38f767a870", "commit_date": "Tue May 31 08:18:38 2022 -0400", "commit_message": "\u270f\ufe0f Fix misc. typos (#4533)", "files_name": ["docs/api/timelapse.rst", "docs/api/util.rst", "docs/features/accesscontrol.rst", "docs/plugins/hooks.rst", "docs/plugins/python3_migration.rst", "src/octoprint/plugins/pluginmanager/__init__.py", "src/octoprint/static/js/app/viewmodels/control.js", "src/octoprint/static/js/recovery/recovery.js", "src/octoprint/static/less/bootstrap/reset.less", "src/octoprint/util/json/serializing.py", "src/octoprint/util/pip.py", "tests/filemanager/test_localstorage.py"]}, {"commit_id": "64ad527753873cb8cd78a800d07eb0c879581022", "commit_date": "Tue Jun 7 13:43:50 2022 +0200", "commit_message": "\u2728 Record last fan speed (#4531)", "files_name": ["docs/features/gcode_scripts.rst", "src/octoprint/util/comm.py"]}, {"commit_id": "10ec9cd4e4edf536c1dcf2a62a4bdb5e442670f9", "commit_date": "Wed Jun 8 03:03:23 2022 -0700", "commit_message": "\u2705 Add more unit tests for `helpers.js` (#4536)", "files_name": ["src/octoprint/static/js/app/helpers.js", "tests/static/js/test-helpers.html", "tests/static/js/test-helpers.js"]}, {"commit_id": "8a8c0b16a2191950c2c78ba2e1e3933f0bfcae4d", "commit_date": "Thu Jun 9 12:43:22 2022 +0200", "commit_message": "\u267b\ufe0f Migrate default settings to pydantic model", "files_name": ["setup.py", "src/octoprint/schema/__init__.py", "src/octoprint/schema/config/__init__.py", "src/octoprint/schema/config/access_control.py", "src/octoprint/schema/config/api.py", "src/octoprint/schema/config/appearance.py", "src/octoprint/schema/config/controls.py", "src/octoprint/schema/config/devel.py", "src/octoprint/schema/config/estimation.py", "src/octoprint/schema/config/events.py", "src/octoprint/schema/config/feature.py", "src/octoprint/schema/config/folder.py", "src/octoprint/schema/config/gcode_analysis.py", "src/octoprint/schema/config/plugins.py", "src/octoprint/schema/config/printer_parameters.py", "src/octoprint/schema/config/printer_profiles.py", "src/octoprint/schema/config/scripts.py", "src/octoprint/schema/config/serial.py", "src/octoprint/schema/config/server.py", "src/octoprint/schema/config/slicing.py", "src/octoprint/schema/config/system.py", "src/octoprint/schema/config/temperature.py", "src/octoprint/schema/config/terminalfilters.py", "src/octoprint/schema/config/webcam.py", "src/octoprint/settings/__init__.py"]}, {"commit_id": "9a18fa0f244241c4dea7239a16853c63e5877c8f", "commit_date": "Thu Jun 9 13:04:10 2022 +0200", "commit_message": "\ud83d\udc1b Fix version of pydantic-settings", "files_name": ["setup.py"]}, {"commit_id": "8174a8e16b3bc8ffaaddee97f938246e964a005a", "commit_date": "Thu Jun 9 13:08:09 2022 +0200", "commit_message": "\ud83d\udc1b Fix version of pydantic-settings, 2nd try", "files_name": ["setup.py"]}, {"commit_id": "01f24e6cea84051798c990190df51ee220c65986", "commit_date": "Mon Jun 20 15:49:00 2022 +0200", "commit_message": "\ud83d\udc77\u200d\u2642\ufe0f Add issues/PRs to backlog automatically", "files_name": [".github/workflows/add_to_backlog.yml"]}, {"commit_id": "008292ce600869c4d74b880bf4d5bbf364a03cba", "commit_date": "Mon Jun 20 15:56:07 2022 +0200", "commit_message": "Use org wide secret", "files_name": [".github/workflows/add_to_backlog.yml"]}, {"commit_id": "2b092a9899cf362d64951e4744927b3a84ccc55b", "commit_date": "Tue Jun 21 00:12:10 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["6bddada8c2b36e254c333ae86a16731d9c2a8ea4 - Tue Jun 21 10:12:53 2022 +0200 : \ud83d\udc77\u200d\u2642\ufe0f Add task labeling", ".github/workflows/issue_automation.yml"]}, {"commit_id": "c3531bc5b498b2bda0b92dcc80014915ad26217f", "commit_date": "Tue Jun 21 15:29:11 2022 +0200", "commit_message": "\ud83d\udc84 GCV: Fix settings markup.", "files_name": ["src/octoprint/plugins/gcodeviewer/templates/gcodeviewer_settings.jinja2"]}, {"commit_id": "2259d251533f431485c86c91f548c6972cb42c50", "commit_date": "Wed Jun 22 00:14:34 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["2e1ec42c5b7602be7bb57b1792598a851441c156 - Thu Jun 23 10:50:06 2022 +0200 : \ud83d\udc77\u200d\u2642\ufe0f Needs to run against pull_request_target", ".github/workflows/add_to_backlog.yml"]}, {"commit_id": "3087548664b2343eca3afe3a74530cd224196a6e", "commit_date": "Thu Jun 23 16:33:19 2022 +0200", "commit_message": "\ud83d\udc77 Add DeploySentinel to e2e tests", "files_name": [".github/workflows/build.yml", "tests/cypress/package-lock.json", "tests/cypress/package.json", "tests/cypress/plugins/index.js", "tests/cypress/support/index.js"]}, {"commit_id": "41d11d8a753a7f1144602e632c1cc3bc7f04525f", "commit_date": "Fri Jun 24 00:11:53 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["151c38a51505018e087bf60d86d541848f86f44c - Mon Jun 27 09:09:11 2022 +0100 : :bug: gcodeInterpreter: Avoid ZeroDivisionError with firmware retraction (#4555)", "src/octoprint/util/gcodeInterpreter.py"]}, {"commit_id": "eaad6350fda5bbdb0185e7f7d2f59c9bf30a65a3", "commit_date": "Mon Jun 27 10:19:54 2022 +0200", "commit_message": "Fixed typo (#4553)", "files_name": ["translations/de/LC_MESSAGES/messages.po"]}, {"commit_id": "bfe40f0c74a2f4077b64ff2d7876216d46eb1b2c", "commit_date": "Mon Jun 27 13:55:17 2022 +0200", "commit_message": "\ud83d\udc77 More work on DeploySentinel integration", "files_name": [".github/workflows/build.yml"]}, {"commit_id": "306e513ee3c8a4b52a2807a439f35f4378036554", "commit_date": "Mon Jun 27 16:57:16 2022 +0200", "commit_message": "\u2728 GCodeViewer: in-memory compression (#4435)", "files_name": ["THIRDPARTYLICENSES.md", "src/octoprint/plugins/gcodeviewer/__init__.py", "src/octoprint/plugins/gcodeviewer/static/js/gcodeviewer.js", "src/octoprint/plugins/gcodeviewer/static/js/viewer/pako.js", "src/octoprint/plugins/gcodeviewer/static/js/viewer/reader.js", "src/octoprint/plugins/gcodeviewer/static/js/viewer/renderer.js", "src/octoprint/plugins/gcodeviewer/static/js/viewer/worker.js", "src/octoprint/plugins/gcodeviewer/templates/gcodeviewer_settings.jinja2", "src/octoprint/plugins/gcodeviewer/templates/gcodeviewer_tab.jinja2"]}, {"commit_id": "18b0565ea636902d692677a4969f6e47bb997fca", "commit_date": "Tue Jun 28 11:19:31 2022 +0200", "commit_message": "\ud83d\udc1b swu: Fix multiple credentials saving", "files_name": ["src/octoprint/plugins/softwareupdate/__init__.py"]}, {"commit_id": "0af5972a285a516d960c97250b5b66bff76cb3a1", "commit_date": "Tue Jun 28 13:35:37 2022 +0100", "commit_message": "\ud83d\udc1b Fix skip dialog in wizard popping up twice (#4561)", "files_name": ["AUTHORS.md", "src/octoprint/static/js/lib/jquery/jquery.bootstrap.wizard.js"]}, {"commit_id": "ae4426e4c2ef48dbb90e61a7e717f73e551f9ac1", "commit_date": "Wed Jun 29 16:23:29 2022 +0200", "commit_message": "\ud83d\udc1b Fix handling of % in timelapse filenames (#4563)", "files_name": ["src/octoprint/timelapse.py"]}, {"commit_id": "c18a5046d50ed082cac62fdf50fa5d88f85159a1", "commit_date": "Tue Jul 12 19:48:39 2022 +0200", "commit_message": ":pencil2: timelapse.rst: Fix typos (#4569)", "files_name": ["docs/api/timelapse.rst"]}, {"commit_id": "a2e9aefe9c8a51120931e9b14bb95ebf9ea6c7f5", "commit_date": "Wed Jul 13 00:14:54 2022 +0000", "commit_message": "Merge branch 'master' into maintenance", "files_name": ["936af41d0ef6dcbf570f1ba0e1950fc76d2719a1 - Mon Jul 18 11:22:41 2022 -0400 : :bug: Invert start and end angles for G02 commands (#4580)", "src/octoprint/util/gcodeInterpreter.py"]}, {"commit_id": "8680ca449573f1efbc48f2eb3f05bf09e4e877fe", "commit_date": "Mon Aug 1 09:23:56 2022 +0200", "commit_message": "\ud83c\udfa8 Convert type comments into Python type hints (#4575)", "files_name": ["docs/sphinxext/codeblockext.py"]}], "parents": [{"commit_id_before": "5ef16773c89df25be4c10b8adf38988b549b3f71", "url_before": "https://api.github.com/repos/OctoPrint/OctoPrint/commits/5ef16773c89df25be4c10b8adf38988b549b3f71", "html_url_before": "https://github.com/OctoPrint/OctoPrint/commit/5ef16773c89df25be4c10b8adf38988b549b3f71"}], "details": [{"raw_url": "https://github.com/OctoPrint/OctoPrint/raw/6d259d7e6f5b0de9a1c762831537a386e53978d3/src%2Foctoprint%2Fstatic%2Fjs%2Fapp%2Fhelpers.js", "code": "function ItemListHelper(\n    listType,\n    supportedSorting,\n    supportedFilters,\n    defaultSorting,\n    defaultFilters,\n    exclusiveFilters,\n    defaultPageSize,\n    persistPageSize\n) {\n    var self = this;\n\n    self.listType = listType;\n    self.supportedSorting = supportedSorting;\n    self.supportedFilters = supportedFilters;\n    self.defaultSorting = defaultSorting;\n    self.defaultFilters = defaultFilters;\n    self.exclusiveFilters = exclusiveFilters;\n    self.defaultPageSize = defaultPageSize;\n    self.persistPageSize = !!persistPageSize;\n\n    self.searchFunction = undefined;\n\n    self.allItems = [];\n    self.allSize = ko.observable(0);\n\n    self.items = ko.observableArray([]);\n    self.pageSize = ko.observable(self.defaultPageSize);\n    self.currentPage = ko.observable(0);\n    self.currentSorting = ko.observable(self.defaultSorting);\n    self.currentFilters = ko.observableArray(self.defaultFilters);\n    self.selectedItem = ko.observable(undefined);\n    self.filterSearch = ko.observable(true);\n\n    self.storageIds = {\n        currentSorting: self.listType + \".\" + \"currentSorting\",\n        currentFilters: self.listType + \".\" + \"currentFilters\",\n        pageSize: self.listType + \".\" + \"pageSize\"\n    };\n\n    //~~ item handling\n\n    self.refresh = function () {\n        self._updateItems();\n    };\n\n    self.updateItems = function (items) {\n        if (items === undefined) items = [];\n        self.allItems = items;\n        self.allSize(items.length);\n        self._updateItems();\n    };\n\n    self.selectItem = function (matcher) {\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                self.selectedItem(itemList[i]);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    self.selectNone = function () {\n        self.selectedItem(undefined);\n    };\n\n    self.isSelected = function (data) {\n        return self.selectedItem() === data;\n    };\n\n    self.isSelectedByMatcher = function (matcher) {\n        return matcher(self.selectedItem());\n    };\n\n    self.removeItem = function (matcher) {\n        var index = self.getIndex(matcher, true);\n        if (index > -1) {\n            self.allItems.splice(index, 1);\n            self._updateItems();\n        }\n    };\n\n    self.updateItem = function (matcher, item) {\n        var index = self.allItems.findIndex(matcher);\n        if (index > -1) {\n            self.allItems[index] = item;\n            self._updateItems();\n        }\n    };\n\n    self.addItem = function (item) {\n        self.allItems.push(item);\n        self._updateItems();\n    };\n\n    //~~ pagination\n\n    self.paginatedItems = ko.dependentObservable(function () {\n        if (self.items() === undefined) {\n            return [];\n        } else if (self.pageSize() === 0) {\n            return self.items();\n        } else {\n            var from = Math.max(self.currentPage() * self.pageSize(), 0);\n            var to = Math.min(from + self.pageSize(), self.items().length);\n            return self.items().slice(from, to);\n        }\n    });\n    self.lastPage = ko.dependentObservable(function () {\n        return self.pageSize() === 0\n            ? 1\n            : Math.ceil(self.items().length / self.pageSize()) - 1;\n    });\n    self.pages = ko.dependentObservable(function () {\n        var pages = [];\n        var i;\n\n        if (self.pageSize() === 0) {\n            pages.push({number: 0, text: 1});\n        } else if (self.lastPage() < 7) {\n            for (i = 0; i < self.lastPage() + 1; i++) {\n                pages.push({number: i, text: i + 1});\n            }\n        } else {\n            pages.push({number: 0, text: 1});\n            if (self.currentPage() < 5) {\n                for (i = 1; i < 5; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            } else if (self.currentPage() > self.lastPage() - 5) {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.lastPage() - 4; i < self.lastPage(); i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n            } else {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.currentPage() - 1; i <= self.currentPage() + 1; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            }\n            pages.push({number: self.lastPage(), text: self.lastPage() + 1});\n        }\n        return pages;\n    });\n\n    self.switchToItem = function (matcher) {\n        var pos = -1;\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos > -1) {\n            var page = Math.floor(pos / self.pageSize());\n            self.changePage(page);\n        }\n    };\n\n    self.changePage = function (newPage) {\n        if (newPage < 0 || newPage > self.lastPage()) return;\n        self.currentPage(newPage);\n    };\n    self.prevPage = function () {\n        if (self.currentPage() > 0) {\n            self.currentPage(self.currentPage() - 1);\n        }\n    };\n    self.nextPage = function () {\n        if (self.currentPage() < self.lastPage()) {\n            self.currentPage(self.currentPage() + 1);\n        }\n    };\n\n    self.getIndex = function (matcher, all) {\n        var itemList;\n        if (all !== undefined && all === true) {\n            itemList = self.allItems;\n        } else {\n            itemList = self.items();\n        }\n\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.getItem = function (matcher, all) {\n        var index = self.getIndex(matcher, all);\n        if (all !== undefined && all === true) {\n            return index > -1 ? self.allItems[index] : undefined;\n        } else {\n            return index > -1 ? self.items()[index] : undefined;\n        }\n    };\n\n    self.resetPage = function () {\n        if (self.currentPage() > self.lastPage()) {\n            self.currentPage(self.lastPage());\n        }\n    };\n\n    //~~ searching\n\n    self.changeSearchFunction = function (searchFunction) {\n        self.searchFunction = searchFunction;\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.resetSearch = function () {\n        self.changeSearchFunction(undefined);\n    };\n\n    //~~ sorting\n\n    self.changeSorting = function (sorting) {\n        if (!_.contains(_.keys(self.supportedSorting), sorting)) return;\n\n        self.currentSorting(sorting);\n        self._saveCurrentSortingToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ filtering\n\n    self.setFilterSearch = function (enabled) {\n        if (self.filterSearch() === enabled) return;\n\n        self.filterSearch(enabled);\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.toggleFilterSearch = function () {\n        self.setFilterSearch(!self.filterSearch());\n    };\n\n    self.toggleFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        if (_.contains(self.currentFilters(), filter)) {\n            self.removeFilter(filter);\n        } else {\n            self.addFilter(filter);\n        }\n    };\n\n    self.addFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        for (var i = 0; i < self.exclusiveFilters.length; i++) {\n            if (_.contains(self.exclusiveFilters[i], filter)) {\n                for (var j = 0; j < self.exclusiveFilters[i].length; j++) {\n                    if (self.exclusiveFilters[i][j] === filter) continue;\n                    self.removeFilter(self.exclusiveFilters[i][j]);\n                }\n            }\n        }\n\n        var filters = self.currentFilters();\n        filters.push(filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.removeFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        var filters = self.currentFilters();\n        filters = _.without(filters, filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ update for sorted and filtered view\n\n    self._updateItems = function () {\n        // determine comparator\n        var comparator = undefined;\n        var currentSorting = self.currentSorting();\n        if (\n            typeof currentSorting !== \"undefined\" &&\n            typeof self.supportedSorting[currentSorting] !== \"undefined\"\n        ) {\n            comparator = self.supportedSorting[currentSorting];\n        }\n\n        // work on all items\n        var result = self.allItems;\n\n        var hasSearch = typeof self.searchFunction !== \"undefined\" && self.searchFunction;\n\n        // filter if we're not searching or have search filtering enabled\n        if (!hasSearch || self.filterSearch()) {\n            var filters = self.currentFilters();\n            _.each(filters, function (filter) {\n                if (\n                    typeof filter !== \"undefined\" &&\n                    typeof supportedFilters[filter] !== \"undefined\"\n                )\n                    result = _.filter(result, supportedFilters[filter]);\n            });\n        }\n\n        // search if necessary\n        if (hasSearch) {\n            result = _.filter(result, self.searchFunction);\n        }\n\n        // sort if necessary\n        if (typeof comparator !== \"undefined\") result.sort(comparator);\n\n        // set result list\n        self.items(result);\n    };\n\n    //~~ local storage\n\n    self._saveCurrentSortingToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var currentSorting = self.currentSorting();\n            if (currentSorting !== undefined)\n                localStorage[self.storageIds.currentSorting] = currentSorting;\n            else localStorage[self.storageIds.currentSorting] = undefined;\n        }\n    };\n\n    self._loadCurrentSortingFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            if (\n                _.contains(\n                    _.keys(supportedSorting),\n                    localStorage[self.storageIds.currentSorting]\n                )\n            )\n                self.currentSorting(localStorage[self.storageIds.currentSorting]);\n            else self.currentSorting(defaultSorting);\n        }\n    };\n\n    self._saveCurrentFiltersToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var filters = _.intersection(\n                _.keys(self.supportedFilters),\n                self.currentFilters()\n            );\n            localStorage[self.storageIds.currentFilters] = JSON.stringify(filters);\n        }\n    };\n\n    self._loadCurrentFiltersFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            self.currentFilters(\n                _.intersection(\n                    _.keys(self.supportedFilters),\n                    JSON.parse(localStorage[self.storageIds.currentFilters])\n                )\n            );\n        }\n    };\n\n    self._savePageSizeToLocalStorage = function (pageSize) {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            localStorage[self.storageIds.pageSize] = pageSize;\n        }\n    };\n\n    self.pageSize.subscribe(self._savePageSizeToLocalStorage);\n\n    self._loadPageSizeFromLocalStorage = function () {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            self.pageSize(parseInt(localStorage[self.storageIds.pageSize]));\n        }\n    };\n\n    self._initializeLocalStorage = function () {\n        if (!Modernizr.localstorage) return false;\n\n        if (\n            localStorage[self.storageIds.currentSorting] !== undefined &&\n            localStorage[self.storageIds.currentFilters] !== undefined &&\n            JSON.parse(localStorage[self.storageIds.currentFilters]) instanceof Array &&\n            localStorage[self.storageIds.pageSize] !== undefined\n        )\n            return true;\n\n        localStorage[self.storageIds.currentSorting] = self.defaultSorting;\n        localStorage[self.storageIds.currentFilters] = JSON.stringify(\n            self.defaultFilters\n        );\n        localStorage[self.storageIds.pageSize] = self.defaultPageSize;\n\n        return true;\n    };\n\n    self._loadCurrentFiltersFromLocalStorage();\n    self._loadCurrentSortingFromLocalStorage();\n    self._loadPageSizeFromLocalStorage();\n}\n\nfunction formatSize(bytes) {\n    if (!bytes) return \"-\";\n\n    var units = [\"bytes\", \"KB\", \"MB\", \"GB\"];\n    for (var i = 0; i < units.length; i++) {\n        if (bytes < 1024) {\n            return _.sprintf(\"%3.1f%s\", bytes, units[i]);\n        }\n        bytes /= 1024;\n    }\n    return _.sprintf(\"%.1f%s\", bytes, \"TB\");\n}\n\nfunction formatHuman(number) {\n    if (number === undefined) return \"-\";\n    if (number < 1000) return number;\n\n    return _.sprintf(\"%.1fK\", number / 1000);\n}\n\nfunction bytesFromSize(size) {\n    if (size === undefined || size.trim() === \"\") return undefined;\n\n    var parsed = size.match(/^([+]?[0-9]*\\.?[0-9]+)(?:\\s*)?(.*)$/);\n    var number = parsed[1];\n    var unit = parsed[2].trim();\n\n    if (unit === \"\") return parseFloat(number);\n\n    var units = {\n        b: 1,\n        byte: 1,\n        bytes: 1,\n        kb: 1024,\n        mb: Math.pow(1024, 2),\n        gb: Math.pow(1024, 3),\n        tb: Math.pow(1024, 4)\n    };\n    unit = unit.toLowerCase();\n\n    if (!units.hasOwnProperty(unit)) {\n        return undefined;\n    }\n\n    var factor = units[unit];\n    return number * factor;\n}\n\nfunction formatDuration(seconds) {\n    if (!seconds) return \"-\";\n    if (seconds < 1) return \"00:00:00\";\n\n    var s = seconds % 60;\n    var m = (seconds % 3600) / 60;\n    var h = seconds / 3600;\n\n    return _.sprintf(\n        gettext(/* L10N: duration format */ \"%(hour)02d:%(minute)02d:%(second)02d\"),\n        {hour: h, minute: m, second: s}\n    );\n}\n\nfunction formatFuzzyEstimation(seconds, base) {\n    if (!seconds || seconds < 1) return \"-\";\n\n    var m;\n    if (base !== undefined) {\n        m = moment(base);\n    } else {\n        m = moment();\n    }\n\n    m.add(seconds, \"s\");\n    return m.fromNow(true);\n}\n\nfunction formatFuzzyPrintTime(totalSeconds) {\n    /**\n     * Formats a print time estimate in a very fuzzy way.\n     *\n     * Accuracy decreases the higher the estimation is:\n     *\n     *   * less than 30s: \"a few seconds\"\n     *   * 30s to a minute: \"less than a minute\"\n     *   * 1 to 30min: rounded to full minutes, above 30s is minute + 1 (\"27 minutes\", \"2 minutes\")\n     *   * 30min to 40min: \"40 minutes\"\n     *   * 40min to 50min: \"50 minutes\"\n     *   * 50min to 1h: \"1 hour\"\n     *   * 1 to 12h: rounded to half hours, 15min to 45min is \".5\", above that hour + 1 (\"4 hours\", \"2.5 hours\")\n     *   * 12 to 24h: rounded to full hours, above 30min is hour + 1, over 23.5h is \"1 day\"\n     *   * Over a day: rounded to half days, 8h to 16h is \".5\", above that days + 1 (\"1 day\", \"4 days\", \"2.5 days\")\n     */\n\n    if (!totalSeconds || totalSeconds < 1) return \"-\";\n\n    var d = moment.duration(totalSeconds, \"seconds\");\n\n    var seconds = d.seconds();\n    var minutes = d.minutes();\n    var hours = d.hours();\n    var days = d.days();\n\n    var replacements = {\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        totalSeconds: totalSeconds\n    };\n\n    var text = \"-\";\n\n    if (days >= 1) {\n        // days\n        if (hours >= 16) {\n            replacements.days += 1;\n\n            if (replacements.days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        } else if (hours >= 8 && hours < 16) {\n            text = gettext(\"%(days)d.5 days\");\n        } else {\n            if (days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        }\n    } else if (hours >= 1) {\n        // only hours\n        if (hours < 12) {\n            if (minutes < 15) {\n                // less than .15 => .0\n                if (hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            } else if (minutes >= 15 && minutes < 45) {\n                // between .25 and .75 => .5\n                text = gettext(\"%(hours)d.5 hours\");\n            } else {\n                // over .75 => hours + 1\n                replacements.hours += 1;\n\n                if (replacements.hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            }\n        } else {\n            if (hours === 23 && minutes > 30) {\n                // over 23.5 hours => 1 day\n                text = gettext(\"1 day\");\n            } else {\n                if (minutes > 30) {\n                    // over .5 => hours + 1\n                    replacements.hours += 1;\n                }\n                text = gettext(\"%(hours)d hours\");\n            }\n        }\n    } else if (minutes >= 1) {\n        // only minutes\n        if (minutes < 2) {\n            if (seconds < 30) {\n                text = gettext(\"a minute\");\n            } else {\n                text = gettext(\"2 minutes\");\n            }\n        } else if (minutes < 30) {\n            if (seconds > 30) {\n                replacements.minutes += 1;\n            }\n            text = gettext(\"%(minutes)d minutes\");\n        } else if (minutes <= 40) {\n            text = gettext(\"40 minutes\");\n        } else if (minutes <= 50) {\n            text = gettext(\"50 minutes\");\n        } else {\n            text = gettext(\"1 hour\");\n        }\n    } else {\n        // only seconds\n        if (seconds < 30) {\n            text = gettext(\"a few seconds\");\n        } else {\n            text = gettext(\"less than a minute\");\n        }\n    }\n\n    return _.sprintf(text, replacements);\n}\n\nfunction formatDate(unixTimestamp, options) {\n    if (!options) {\n        options = {seconds: false};\n    }\n\n    if (!unixTimestamp) return \"-\";\n\n    var format = gettext(/* L10N: Date format */ \"YYYY-MM-DD HH:mm\");\n    if (options.seconds) {\n        format = gettext(/* L10N: Date format with seconds */ \"YYYY-MM-DD HH:mm:ss\");\n    }\n\n    return moment.unix(unixTimestamp).format(format);\n}\n\nfunction formatTimeAgo(unixTimestamp) {\n    if (!unixTimestamp) return \"-\";\n    return moment.unix(unixTimestamp).fromNow();\n}\n\nfunction formatFilament(filament) {\n    if (!filament || !filament[\"length\"]) return \"-\";\n    var result = \"%(length).02fm\";\n    if (filament.hasOwnProperty(\"volume\") && filament.volume) {\n        result += \" / \" + \"%(volume).02fcm\u00b3\";\n    }\n    return _.sprintf(result, {\n        length: filament[\"length\"] / 1000,\n        volume: filament[\"volume\"]\n    });\n}\n\nfunction cleanTemperature(temp, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    return temp;\n}\n\nfunction formatTemperature(temp, showF, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    if (showF) {\n        return _.sprintf(\"%.1f&deg;C (%.1f&deg;F)\", temp, (temp * 9) / 5 + 32);\n    } else {\n        return _.sprintf(\"%.1f&deg;C\", temp);\n    }\n}\n\nfunction formatNumberK(num) {\n    if (num > 1000) {\n        num = num / 1000.0;\n        return _.sprintf(\"%.2fk\", num);\n    } else {\n        return _.sprintf(\"%i\", num);\n    }\n}\n\nfunction pnotifyAdditionalInfo(inner) {\n    return (\n        '<div class=\"pnotify_additional_info\">' +\n        '<div class=\"pnotify_more\"><a href=\"#\" onclick=\"$(this).children().toggleClass(\\'icon-caret-right icon-caret-down\\').parent().parent().next().slideToggle(\\'fast\\')\">More <i class=\"icon-caret-right\"></i></a></div>' +\n        '<div class=\"pnotify_more_container hide\">' +\n        inner +\n        \"</div>\" +\n        \"</div>\"\n    );\n}\n\nfunction ping(url, callback) {\n    var img = new Image();\n    var calledBack = false;\n\n    img.onload = function () {\n        callback(true);\n        calledBack = true;\n    };\n    img.onerror = function () {\n        if (!calledBack) {\n            callback(true);\n            calledBack = true;\n        }\n    };\n    img.src = url;\n    setTimeout(function () {\n        if (!calledBack) {\n            callback(false);\n            calledBack = true;\n        }\n    }, 1500);\n}\n\nfunction showOfflineOverlay(title, message, reconnectCallback) {\n    if (title === undefined) {\n        title = gettext(\"Server is offline\");\n    }\n\n    $(\"#offline_overlay_title\").text(title);\n    $(\"#offline_overlay_message\").html(message);\n    $(\"#offline_overlay_reconnect\").click(reconnectCallback);\n\n    var overlay = $(\"#offline_overlay\");\n    if (!overlay.is(\":visible\")) overlay.show();\n}\n\nfunction hideOfflineOverlay() {\n    $(\"#offline_overlay\").hide();\n}\n\nfunction showMessageDialog(msg, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n    }\n\n    var title = options.title || \"\";\n    var message = options.message || \"\";\n    var close = options.close || gettext(\"Close\");\n    var onclose = options.onclose || undefined;\n    var onshow = options.onshow || undefined;\n    var onshown = options.onshown || undefined;\n    var nofade = options.nofade || false;\n\n    if (_.isString(message)) {\n        message = $(\"<p>\" + message + \"</p>\");\n    }\n\n    var modalHeader = $(\n        '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n            title +\n            \"</h3>\"\n    );\n    var modalBody = $(message);\n    var modalFooter = $(\n        '<a href=\"javascript:void(0)\" class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">' +\n            close +\n            \"</a>\"\n    );\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    modal\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(modalFooter));\n\n    modal.on(\"hidden\", function () {\n        if (onclose && _.isFunction(onclose)) {\n            onclose();\n        }\n    });\n\n    if (onshow) {\n        modal.on(\"show\", onshow);\n    }\n\n    if (onshown) {\n        modal.on(\"shown\", onshown);\n    }\n\n    modal.modal(\"show\");\n    return modal;\n}\n\nfunction showConfirmationDialog(msg, onacknowledge, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n        options.onproceed = onacknowledge;\n    }\n\n    var title = options.title || gettext(\"Are you sure?\");\n\n    var message = options.message || \"\";\n    var question = options.question || gettext(\"Are you sure you want to proceed?\");\n\n    var html = options.html;\n\n    var checkboxes = options.checkboxes;\n\n    var cancel = options.cancel || gettext(\"Cancel\");\n    var proceed = options.proceed || gettext(\"Proceed\");\n    var proceedClass = options.proceedClass || \"danger\";\n    var onproceed = options.onproceed || undefined;\n    var oncancel = options.oncancel || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n    var noclose = options.noclose || false;\n\n    var modalHeader;\n    if (noclose) {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    } else {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    }\n\n    var modalBody;\n    if (html) {\n        modalBody = $(html);\n    } else {\n        modalBody = $(\"<p>\" + message + \"</p><p>\" + question + \"</p>\");\n    }\n\n    var cancelButton = $('<a href=\"javascript:void(0)\" class=\"btn\">' + cancel + \"</a>\")\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    if (!_.isArray(proceed)) {\n        proceed = [proceed];\n    }\n\n    var proceedButtons = [];\n    _.each(proceed, function (text) {\n        proceedButtons.push(\n            $('<a href=\"javascript:void(0)\" class=\"btn\">' + text + \"</a>\").addClass(\n                \"btn-\" + proceedClass\n            )\n        );\n    });\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n\n    var buttons = $(\"<div></div>\").addClass(\"modal-footer\").append(cancelButton);\n    _.each(proceedButtons, function (button) {\n        buttons.append(button);\n    });\n\n    modal\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append(buttons);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n\n    var modalOptions = {};\n    if (noclose) {\n        modalOptions.backdrop = \"static\";\n        modalOptions.keyboard = false;\n    }\n    modal.modal(modalOptions);\n\n    _.each(proceedButtons, function (button, idx) {\n        button.click(function (e) {\n            e.preventDefault();\n            if (onproceed && _.isFunction(onproceed)) {\n                onproceed(idx, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n    cancelButton.click(function (e) {\n        if (oncancel && _.isFunction(oncancel)) {\n            oncancel(e);\n        }\n    });\n\n    return modal;\n}\n\nfunction showSelectionDialog(options) {\n    var title = options.title;\n    var message = options.message || undefined;\n    var selections = options.selections || [];\n\n    var maycancel = options.maycancel || false;\n    var cancel = options.cancel || undefined;\n    var onselect = options.onselect || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n\n    // header\n    var modalHeader;\n    if (maycancel) {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    } else {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    }\n\n    // body\n    var buttons = [];\n    var selectionBody = $(\"<div></div>\");\n    var container;\n    var additionalClass;\n\n    if (selections.length === 1) {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    } else if (selections.length === 2) {\n        container = $(\"<div class='row-fluid'></div>\");\n        selectionBody.append(container);\n        additionalClass = \"span6\";\n    } else {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    }\n\n    _.each(selections, function (s, i) {\n        var button = $(\n            '<button class=\"btn\" style=\"white-space: normal; word-wrap: break-word\" data-index=\"' +\n                i +\n                '\">' +\n                selections[i] +\n                \"</button>\"\n        );\n        if (additionalClass) {\n            button.addClass(additionalClass);\n        }\n        container.append(button);\n        buttons.push(button);\n\n        if (selections.length > 2 && i < selections.length - 1) {\n            container = $(\"<div class='row-fluid'></div>\");\n            selectionBody.append(container);\n        }\n    });\n\n    // divs\n    var headerDiv = $(\"<div></div>\").addClass(\"modal-header\").append(modalHeader);\n\n    var bodyDiv = $(\"<div></div>\").addClass(\"modal-body\");\n    if (message) {\n        bodyDiv.append($(\"<p>\" + message + \"</p>\"));\n    }\n    bodyDiv.append(selectionBody);\n\n    // create modal and do final wiring up\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    if (!cancel) {\n        modal.data(\"backdrop\", \"static\").data(\"keyboard\", \"false\");\n    }\n\n    modal.addClass(dialogClass).append(headerDiv).append(bodyDiv);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n    modal.modal(\"show\");\n\n    _.each(buttons, function (button) {\n        button.click(function (e) {\n            e.preventDefault();\n            var index = button.data(\"index\");\n            if (index < 0) {\n                return;\n            }\n\n            if (onselect && _.isFunction(onselect)) {\n                onselect(index, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n\n    return modal;\n}\n\n/**\n * Shows a progress modal depending on a supplied promise.\n *\n * Will listen to the supplied promise, update the progress on .progress events and\n * enabling the close button and (optionally) closing the dialog on promise resolve.\n *\n * The calling code should call \"notify\" on the deferred backing the promise and supply:\n *\n *   * the text to display on the progress bar and the optional output field and\n *     a boolean value indicating whether the operation behind that update was successful or not\n *   * a short text to display on the progress bar, a long text to display on the optional output\n *     field and a boolean value indicating whether the operation behind that update was\n *     successful or not\n *\n * Non-successful progress updates will remove the barClassSuccess class from the progress bar and\n * apply the barClassFailure class and also apply the outputClassFailure to the produced line\n * in the output.\n *\n * To determine the progress, calling code should supply the prognosed maximum number of\n * progress events. An internal counter will increment on each progress event and used together\n * with the max value to calculate the percentage to display on the progress bar.\n *\n * If no max value is set, the progress bar will show a striped animation at 100% fill status\n * to visualize \"unknown but ongoing\" status.\n *\n * Available options:\n *\n *   * title: the title of the modal, defaults to \"Progress\"\n *   * message: the message of the modal, defaults to \"\"\n *   * buttonText: the text on the close button, defaults to \"Close\"\n *   * max: maximum number of expected progress events (when 100% will be reached), defaults\n *     to undefined\n *   * close: whether to close the dialog on completion, defaults to false\n *   * output: whether to display the progress texts in an output field, defaults to false\n *   * dialogClass: additional class to apply to the dialog div\n *   * barClassSuccess: additional class for the progress bar while all progress events are\n *     successful\n *   * barClassFailure: additional class for the progress bar when a progress event was\n *     unsuccessful\n *   * outputClassSuccess: additional class for successful output lines\n *   * outputClassFailure: additional class for unsuccessful output lines\n *\n * @param options modal options\n * @param promise promise to monitor\n * @returns {*|jQuery} the modal object\n */\nfunction showProgressModal(options, promise) {\n    var title = options.title || gettext(\"Progress\");\n    var message = options.message || \"\";\n    var buttonText = options.button || gettext(\"Close\");\n    var max = options.max || undefined;\n    var close = options.close || false;\n    var output = options.output || false;\n\n    var dialogClass = options.dialogClass || \"\";\n    var barClassSuccess = options.barClassSuccess || \"\";\n    var barClassFailure = options.barClassFailure || \"bar-danger\";\n    var outputClassSuccess = options.outputClassSuccess || \"\";\n    var outputClassFailure = options.outputClassFailure || \"text-error\";\n\n    var modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    var paragraph = $(\"<p>\" + message + \"</p>\");\n\n    var progress = $('<div class=\"progress progress-text-centered\"></div>');\n    var progressBar = $('<div class=\"bar\"></div>').addClass(barClassSuccess);\n    var progressText = $('<span class=\"progress-text-back\"></span>');\n\n    if (max === undefined) {\n        progress.addClass(\"progress-striped active\");\n        progressBar.width(\"100%\");\n    }\n\n    progress.append(progressBar).append(progressText);\n\n    var button = $('<button class=\"btn\">' + buttonText + \"</button>\")\n        .prop(\"disabled\", true)\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    var modalBody = $(\"<div></div>\")\n        .addClass(\"modal-body\")\n        .append(paragraph)\n        .append(progress);\n\n    var pre;\n    if (output) {\n        pre = $(\n            \"<pre class='pre-scrollable pre-output' style='height: 70px; font-size: 0.8em'></pre>\"\n        );\n        modalBody.append(pre);\n    }\n\n    var modal = $(\"<div></div>\")\n        .addClass(\"modal hide fade-in\")\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append(modalBody)\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(button));\n    modal.modal({keyboard: false, backdrop: \"static\", show: true});\n\n    var counter = 0;\n    promise\n        .progress(function () {\n            var short, long, success;\n            if (arguments.length === 2) {\n                short = long = arguments[0];\n                success = arguments[1];\n            } else if (arguments.length === 3) {\n                short = arguments[0];\n                long = arguments[1];\n                success = arguments[2];\n            } else {\n                throw Error(\n                    \"Invalid parameters for showProgressModal, expected either (text, success) or (short, long, success)\"\n                );\n            }\n\n            var value;\n\n            if (max === undefined || max <= 0) {\n                value = 100;\n            } else {\n                counter++;\n                value = Math.max(Math.min((counter * 100) / max, 100), 0);\n            }\n\n            // update progress bar\n            progressBar.width(String(value) + \"%\");\n            progressText.text(short);\n            if (value < 50 && progressText.hasClass(\"progress-text-front\")) {\n                progressText\n                    .removeClass(\"progress-text-front\")\n                    .addClass(\"progress-text-back\");\n            } else if (value >= 50 && progressText.hasClass(\"progress-text-back\")) {\n                progressText\n                    .removeClass(\"progress-text-back\")\n                    .addClass(\"progress-text-front\");\n            }\n\n            // if not successful, apply failure class\n            if (!success && !progressBar.hasClass(barClassFailure)) {\n                progressBar.removeClass(barClassSuccess).addClass(barClassFailure);\n            }\n\n            if (output && pre) {\n                if (success) {\n                    pre.append(\n                        $(\"<span class='\" + outputClassSuccess + \"'>\" + long + \"</span>\")\n                    );\n                } else {\n                    pre.append(\n                        $(\"<span class='\" + outputClassFailure + \"'>\" + long + \"</span>\")\n                    );\n                }\n                pre.scrollTop(pre[0].scrollHeight - pre.height());\n            }\n        })\n        .done(function () {\n            button.prop(\"disabled\", false);\n            if (close) {\n                modal.modal(\"hide\");\n            }\n        })\n        .fail(function () {\n            button.prop(\"disabled\", false);\n        });\n\n    return modal;\n}\n\nfunction showReloadOverlay() {\n    $(\"#reloadui_overlay\").show();\n}\n\nfunction wrapPromiseWithAlways(p) {\n    var deferred = $.Deferred();\n    p.always(function () {\n        deferred.resolve.apply(deferred, arguments);\n    });\n    return deferred.promise();\n}\n\nfunction commentableLinesToArray(lines) {\n    return splitTextToArray(lines, \"\\n\", true, function (item) {\n        return !_.startsWith(item, \"#\");\n    });\n}\n\nfunction splitTextToArray(text, sep, stripEmpty, filter) {\n    return _.filter(\n        _.map(text.split(sep), function (item) {\n            return item ? item.trim() : \"\";\n        }),\n        function (item) {\n            return (stripEmpty ? item : true) && (filter ? filter(item) : true);\n        }\n    );\n}\n\n/**\n * Returns true if comparing data and oldData yields changes, false otherwise.\n *\n * E.g.\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\", key: \"value\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\", four: \"4\"}}\n *   )\n *\n * will return\n *\n *   true\n *\n * and\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   false\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction hasDataChanged(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == oldData && data == undefined) {\n        return false;\n    }\n\n    if (_.isPlainObject(data) && _.isPlainObject(oldData)) {\n        return _.any(_.keys(data), function (key) {\n            return hasDataChanged(data[key], oldData[key]);\n        });\n    } else {\n        return !_.isEqual(data, oldData);\n    }\n}\n\n/**\n * Compare provided data and oldData plain objects and only return those\n * substructures of data that actually changed.\n *\n * E.g.\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {fnord: {three: \"three\"}}\n *\n * and\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {}\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction getOnlyChangedData(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == undefined) {\n        return {};\n    }\n\n    // noinspection EqualityComparisonWithCoercionJS\n    if (oldData == undefined) {\n        return data;\n    }\n\n    var f = function (root, oldRoot) {\n        if (!_.isPlainObject(root)) {\n            return root;\n        }\n\n        var retval = {};\n        _.forOwn(root, function (value, key) {\n            var oldValue = undefined;\n            // noinspection EqualityComparisonWithCoercionJS\n            if (oldRoot != undefined && oldRoot.hasOwnProperty(key)) {\n                oldValue = oldRoot[key];\n            }\n            if (_.isPlainObject(value)) {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (oldValue == undefined) {\n                    retval[key] = value;\n                } else if (hasDataChanged(value, oldValue)) {\n                    retval[key] = f(value, oldValue);\n                }\n            } else {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (\n                    !(value == oldValue && value == undefined) &&\n                    !_.isEqual(value, oldValue)\n                ) {\n                    retval[key] = value;\n                }\n            }\n        });\n        return retval;\n    };\n\n    return f(data, oldData);\n}\n\nfunction setOnViewModels(allViewModels, key, value) {\n    setOnViewModelsIf(allViewModels, key, value, undefined);\n}\n\nfunction setOnViewModelsIf(allViewModels, key, value, condition) {\n    if (!allViewModels) return;\n    _.each(allViewModels, function (viewModel) {\n        setOnViewModelIf(viewModel, key, value, condition);\n    });\n}\n\nfunction setOnViewModel(viewModel, key, value) {\n    setOnViewModelIf(viewModel, key, value, undefined);\n}\n\nfunction setOnViewModelIf(viewModel, key, value, condition) {\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    try {\n        if (!condition(viewModel)) {\n            return;\n        }\n\n        viewModel[key] = value;\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        log.error(\n            \"Error while setting\",\n            key,\n            \"to\",\n            value,\n            \"on view model\",\n            viewModel.constructor.name,\n            \":\",\n            exc.stack || exc\n        );\n    }\n}\n\nfunction callViewModels(allViewModels, method, callback) {\n    callViewModelsIf(allViewModels, method, undefined, callback);\n}\n\nfunction callViewModelsIf(allViewModels, method, condition, callback) {\n    if (!allViewModels) return;\n\n    _.each(allViewModels, function (viewModel) {\n        try {\n            callViewModelIf(viewModel, method, condition, callback);\n        } catch (exc) {\n            if (typeof Sentry !== \"undefined\") {\n                Sentry.captureException(exc);\n            }\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    });\n}\n\nfunction callViewModel(viewModel, method, callback, raiseErrors) {\n    callViewModelIf(viewModel, method, undefined, callback, raiseErrors);\n}\n\nfunction callViewModelIf(viewModel, method, condition, callback, raiseErrors) {\n    raiseErrors = raiseErrors === true || false;\n\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    if (!_.isFunction(viewModel[method]) || !condition(viewModel, method)) return;\n\n    var parameters = undefined;\n    if (!_.isFunction(callback)) {\n        // if callback is not a function that means we are supposed to directly\n        // call the view model method instead of providing it to the callback\n        // - let's figure out how\n\n        if (callback === undefined) {\n            // directly call view model method with no parameters\n            parameters = undefined;\n            log.trace(\"Calling method\", method, \"on view model\");\n        } else if (_.isArray(callback)) {\n            // directly call view model method with these parameters\n            parameters = callback;\n            log.trace(\n                \"Calling method\",\n                method,\n                \"on view model with specified parameters\",\n                parameters\n            );\n        } else {\n            // ok, this doesn't make sense, callback is neither undefined nor\n            // an array, we'll return without doing anything\n            return;\n        }\n\n        // we reset this here so we now further down that we want to call\n        // the method directly\n        callback = undefined;\n    } else {\n        log.trace(\n            \"Providing method\",\n            method,\n            \"on view model to specified callback\",\n            callback\n        );\n    }\n\n    try {\n        if (callback === undefined) {\n            if (parameters !== undefined) {\n                // call the method with the provided parameters\n                viewModel[method].apply(viewModel, parameters);\n            } else {\n                // call the method without parameters\n                viewModel[method]();\n            }\n        } else {\n            // provide the method to the callback\n            callback(viewModel[method], viewModel);\n        }\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        if (raiseErrors) {\n            throw exc;\n        } else {\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    }\n}\n\nvar sizeObservable = function (observable) {\n    return ko.computed({\n        read: function () {\n            return formatSize(observable());\n        },\n        write: function (value) {\n            var result = bytesFromSize(value);\n            if (result !== undefined) {\n                observable(result);\n            }\n        }\n    });\n};\n\nvar getQueryParameterByName = function (name, url) {\n    // from http://stackoverflow.com/a/901144/2028598\n    if (!url) {\n        url = window.location.href;\n    }\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return \"\";\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n};\n\n/**\n * Escapes unprintable ASCII characters in the provided string.\n *\n * E.g. turns a null byte in the string into \"\\x00\".\n *\n * Characters 0 to 31 excluding 9, 10 and 13 will be escaped, as will\n * 127, 128 to 159 and 255. That should leave printable characters and unicode\n * alone.\n *\n * Originally based on\n * https://gist.github.com/mathiasbynens/1243213#gistcomment-53590\n *\n * @param str The string to escape\n * @returns {string}\n */\nvar escapeUnprintableCharacters = function (str) {\n    var result = \"\";\n    var index = 0;\n    var charCode;\n\n    while (!isNaN((charCode = str.charCodeAt(index)))) {\n        if (\n            (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) ||\n            charCode === 127 ||\n            (charCode >= 128 && charCode <= 159) ||\n            charCode === 255\n        ) {\n            // special hex chars\n            result += \"\\\\x\" + (charCode > 15 ? \"\" : \"0\") + charCode.toString(16);\n        } else {\n            // anything else\n            result += str[index];\n        }\n\n        index++;\n    }\n    return result;\n};\n\nvar copyToClipboard = function (text) {\n    var temp = $(\"<textarea>\");\n    $(\"body\").append(temp);\n    temp.val(text).select();\n    document.execCommand(\"copy\");\n    temp.remove();\n};\n\nvar getExternalHostUrl = function () {\n    var loc = window.location;\n    var port = \"\";\n    if (\n        (loc.protocol === \"http:\" && loc.port !== \"80\") ||\n        (loc.protocol === \"https:\" && loc.port !== \"443\")\n    ) {\n        port = \":\" + loc.port;\n    }\n    return loc.protocol + \"//\" + loc.hostname + port;\n};\n\nvar validateWebcamUrl = function (streamUrl) {\n    if (!streamUrl) {\n        return false;\n    }\n\n    var lower = streamUrl.toLowerCase();\n    var toParse = streamUrl;\n\n    if (lower.startsWith(\"//\")) {\n        // protocol relative\n        toParse = window.location.protocol + streamUrl;\n    } else if (lower.startsWith(\"/\")) {\n        // host relative\n        toParse = getExternalHostUrl() + streamUrl;\n    } else if (\n        lower.startsWith(\"http:\") ||\n        lower.startsWith(\"https:\") ||\n        lower.startsWith(\"webrtc:\")\n    ) {\n        // absolute & http/https/webrtc\n        toParse = streamUrl;\n    } else {\n        return false;\n    }\n\n    try {\n        return new URL(toParse);\n    } catch (e) {\n        return false;\n    }\n};\n\nvar determineWebcamStreamType = function (streamUrl) {\n    if (!streamUrl) {\n        throw \"Empty streamUrl. Cannot determine stream type.\";\n    }\n\n    var parsed = validateWebcamUrl(streamUrl);\n    if (!parsed) {\n        throw \"Invalid streamUrl. Cannot determine stream type.\";\n    }\n\n    if (parsed.protocol === \"webrtc:\") {\n        return \"webrtc\";\n    }\n\n    var lastDotPosition = parsed.pathname.lastIndexOf(\".\");\n    if (lastDotPosition !== -1) {\n        var extension = parsed.pathname.substring(lastDotPosition + 1);\n        if (extension.toLowerCase() === \"m3u8\") {\n            return \"hls\";\n        }\n    }\n\n    // By default, 'mjpg' is the stream type.\n    return \"mjpg\";\n};\n\nvar saveToLocalStorage = function (key, data) {\n    if (!Modernizr.localstorage) return;\n    localStorage[key] = JSON.stringify(data);\n};\n\nvar loadFromLocalStorage = function (key, defaultValue) {\n    defaultValue = defaultValue === undefined ? {} : defaultValue;\n\n    if (!Modernizr.localstorage) return defaultValue;\n\n    var currentString = localStorage[key];\n    var current;\n    if (currentString === undefined) {\n        current = defaultValue;\n    } else {\n        try {\n            current = JSON.parse(currentString);\n        } catch (ex) {\n            current = defaultValue;\n        }\n    }\n    return current;\n};\n\nvar deepMerge = function (target, source) {\n    /**\n     * Implements an object deep merge, which contrary to _.merge doesn't try to\n     * merge arrays.\n     */\n    if (!_.isObject(target)) {\n        return target;\n    }\n\n    _.forOwn(source, function (value, key) {\n        if (\n            target.hasOwnProperty(key) &&\n            _.isPlainObject(target[key]) &&\n            _.isPlainObject(value)\n        ) {\n            target[key] = deepMerge(target[key], value);\n        } else {\n            target[key] = value;\n        }\n    });\n\n    return target;\n};\n\nvar isWebRTCAvailable = function () {\n    return (\n        typeof RTCPeerConnection == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addTransceiver == \"function\" &&\n        typeof RTCPeerConnection.prototype.createOffer == \"function\" &&\n        typeof RTCPeerConnection.prototype.setLocalDescription == \"function\" &&\n        typeof RTCPeerConnection.prototype.removeEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.setRemoteDescription == \"function\"\n    );\n};\n\nvar negotiateWebRTC = function (streamUrl) {\n    pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n    pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n    return pc\n        .createOffer()\n        .then(function (offer) {\n            return pc.setLocalDescription(offer);\n        })\n        .then(function () {\n            // Wait for ICE gathering to complete\n            return new Promise(function (resolve) {\n                if (pc.iceGatheringState === \"complete\") {\n                    resolve();\n                } else {\n                    function checkState() {\n                        if (pc.iceGatheringState === \"complete\") {\n                            pc.removeEventListener(\"icegatheringstatechange\", checkState);\n                            resolve();\n                        }\n                    }\n                    pc.addEventListener(\"icegatheringstatechange\", checkState);\n                }\n            });\n        })\n        .then(function () {\n            var offer = pc.localDescription;\n            // webrtc://host.com becomes http://host.com\n            // webrtcs://host.com becomes https://host.com\n            streamUrl = \"http\" + streamUrl.slice(\"webrtc\".length);\n            return $.ajax({\n                url: streamUrl,\n                type: \"POST\",\n                dataType: \"json\",\n                data: JSON.stringify({\n                    sdp: offer.sdp,\n                    type: offer.type\n                }),\n                contentType: \"application/json; charset=UTF-8\"\n            });\n        })\n        .then(function (response) {\n            return pc.setRemoteDescription(response);\n        })\n        .catch(function (e) {\n            console.error(e);\n        });\n};\n\nvar startWebRTC = function (videoElement, streamUrl, iceServers) {\n    var config = {\n        sdpSemantics: \"unified-plan\"\n    };\n    if (iceServers) {\n        config.iceServers = [{urls: iceServers}];\n    }\n    pc = new RTCPeerConnection(config);\n    pc.addEventListener(\"track\", function (evt) {\n        if (evt.track.kind == \"video\") {\n            videoElement.srcObject = evt.streams[0];\n        }\n    });\n\n    negotiateWebRTC(streamUrl);\n    return pc;\n};\n", "code_before": "function ItemListHelper(\n    listType,\n    supportedSorting,\n    supportedFilters,\n    defaultSorting,\n    defaultFilters,\n    exclusiveFilters,\n    defaultPageSize,\n    persistPageSize\n) {\n    var self = this;\n\n    self.listType = listType;\n    self.supportedSorting = supportedSorting;\n    self.supportedFilters = supportedFilters;\n    self.defaultSorting = defaultSorting;\n    self.defaultFilters = defaultFilters;\n    self.exclusiveFilters = exclusiveFilters;\n    self.defaultPageSize = defaultPageSize;\n    self.persistPageSize = !!persistPageSize;\n\n    self.searchFunction = undefined;\n\n    self.allItems = [];\n    self.allSize = ko.observable(0);\n\n    self.items = ko.observableArray([]);\n    self.pageSize = ko.observable(self.defaultPageSize);\n    self.currentPage = ko.observable(0);\n    self.currentSorting = ko.observable(self.defaultSorting);\n    self.currentFilters = ko.observableArray(self.defaultFilters);\n    self.selectedItem = ko.observable(undefined);\n    self.filterSearch = ko.observable(true);\n\n    self.storageIds = {\n        currentSorting: self.listType + \".\" + \"currentSorting\",\n        currentFilters: self.listType + \".\" + \"currentFilters\",\n        pageSize: self.listType + \".\" + \"pageSize\"\n    };\n\n    //~~ item handling\n\n    self.refresh = function () {\n        self._updateItems();\n    };\n\n    self.updateItems = function (items) {\n        if (items === undefined) items = [];\n        self.allItems = items;\n        self.allSize(items.length);\n        self._updateItems();\n    };\n\n    self.selectItem = function (matcher) {\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                self.selectedItem(itemList[i]);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    self.selectNone = function () {\n        self.selectedItem(undefined);\n    };\n\n    self.isSelected = function (data) {\n        return self.selectedItem() === data;\n    };\n\n    self.isSelectedByMatcher = function (matcher) {\n        return matcher(self.selectedItem());\n    };\n\n    self.removeItem = function (matcher) {\n        var index = self.getIndex(matcher, true);\n        if (index > -1) {\n            self.allItems.splice(index, 1);\n            self._updateItems();\n        }\n    };\n\n    self.updateItem = function (matcher, item) {\n        var index = self.allItems.findIndex(matcher);\n        if (index > -1) {\n            self.allItems[index] = item;\n            self._updateItems();\n        }\n    };\n\n    self.addItem = function (item) {\n        self.allItems.push(item);\n        self._updateItems();\n    };\n\n    //~~ pagination\n\n    self.paginatedItems = ko.dependentObservable(function () {\n        if (self.items() === undefined) {\n            return [];\n        } else if (self.pageSize() === 0) {\n            return self.items();\n        } else {\n            var from = Math.max(self.currentPage() * self.pageSize(), 0);\n            var to = Math.min(from + self.pageSize(), self.items().length);\n            return self.items().slice(from, to);\n        }\n    });\n    self.lastPage = ko.dependentObservable(function () {\n        return self.pageSize() === 0\n            ? 1\n            : Math.ceil(self.items().length / self.pageSize()) - 1;\n    });\n    self.pages = ko.dependentObservable(function () {\n        var pages = [];\n        var i;\n\n        if (self.pageSize() === 0) {\n            pages.push({number: 0, text: 1});\n        } else if (self.lastPage() < 7) {\n            for (i = 0; i < self.lastPage() + 1; i++) {\n                pages.push({number: i, text: i + 1});\n            }\n        } else {\n            pages.push({number: 0, text: 1});\n            if (self.currentPage() < 5) {\n                for (i = 1; i < 5; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            } else if (self.currentPage() > self.lastPage() - 5) {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.lastPage() - 4; i < self.lastPage(); i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n            } else {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.currentPage() - 1; i <= self.currentPage() + 1; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            }\n            pages.push({number: self.lastPage(), text: self.lastPage() + 1});\n        }\n        return pages;\n    });\n\n    self.switchToItem = function (matcher) {\n        var pos = -1;\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos > -1) {\n            var page = Math.floor(pos / self.pageSize());\n            self.changePage(page);\n        }\n    };\n\n    self.changePage = function (newPage) {\n        if (newPage < 0 || newPage > self.lastPage()) return;\n        self.currentPage(newPage);\n    };\n    self.prevPage = function () {\n        if (self.currentPage() > 0) {\n            self.currentPage(self.currentPage() - 1);\n        }\n    };\n    self.nextPage = function () {\n        if (self.currentPage() < self.lastPage()) {\n            self.currentPage(self.currentPage() + 1);\n        }\n    };\n\n    self.getIndex = function (matcher, all) {\n        var itemList;\n        if (all !== undefined && all === true) {\n            itemList = self.allItems;\n        } else {\n            itemList = self.items();\n        }\n\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.getItem = function (matcher, all) {\n        var index = self.getIndex(matcher, all);\n        if (all !== undefined && all === true) {\n            return index > -1 ? self.allItems[index] : undefined;\n        } else {\n            return index > -1 ? self.items()[index] : undefined;\n        }\n    };\n\n    self.resetPage = function () {\n        if (self.currentPage() > self.lastPage()) {\n            self.currentPage(self.lastPage());\n        }\n    };\n\n    //~~ searching\n\n    self.changeSearchFunction = function (searchFunction) {\n        self.searchFunction = searchFunction;\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.resetSearch = function () {\n        self.changeSearchFunction(undefined);\n    };\n\n    //~~ sorting\n\n    self.changeSorting = function (sorting) {\n        if (!_.contains(_.keys(self.supportedSorting), sorting)) return;\n\n        self.currentSorting(sorting);\n        self._saveCurrentSortingToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ filtering\n\n    self.setFilterSearch = function (enabled) {\n        if (self.filterSearch() === enabled) return;\n\n        self.filterSearch(enabled);\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.toggleFilterSearch = function () {\n        self.setFilterSearch(!self.filterSearch());\n    };\n\n    self.toggleFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        if (_.contains(self.currentFilters(), filter)) {\n            self.removeFilter(filter);\n        } else {\n            self.addFilter(filter);\n        }\n    };\n\n    self.addFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        for (var i = 0; i < self.exclusiveFilters.length; i++) {\n            if (_.contains(self.exclusiveFilters[i], filter)) {\n                for (var j = 0; j < self.exclusiveFilters[i].length; j++) {\n                    if (self.exclusiveFilters[i][j] === filter) continue;\n                    self.removeFilter(self.exclusiveFilters[i][j]);\n                }\n            }\n        }\n\n        var filters = self.currentFilters();\n        filters.push(filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.removeFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        var filters = self.currentFilters();\n        filters = _.without(filters, filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ update for sorted and filtered view\n\n    self._updateItems = function () {\n        // determine comparator\n        var comparator = undefined;\n        var currentSorting = self.currentSorting();\n        if (\n            typeof currentSorting !== \"undefined\" &&\n            typeof self.supportedSorting[currentSorting] !== \"undefined\"\n        ) {\n            comparator = self.supportedSorting[currentSorting];\n        }\n\n        // work on all items\n        var result = self.allItems;\n\n        var hasSearch = typeof self.searchFunction !== \"undefined\" && self.searchFunction;\n\n        // filter if we're not searching or have search filtering enabled\n        if (!hasSearch || self.filterSearch()) {\n            var filters = self.currentFilters();\n            _.each(filters, function (filter) {\n                if (\n                    typeof filter !== \"undefined\" &&\n                    typeof supportedFilters[filter] !== \"undefined\"\n                )\n                    result = _.filter(result, supportedFilters[filter]);\n            });\n        }\n\n        // search if necessary\n        if (hasSearch) {\n            result = _.filter(result, self.searchFunction);\n        }\n\n        // sort if necessary\n        if (typeof comparator !== \"undefined\") result.sort(comparator);\n\n        // set result list\n        self.items(result);\n    };\n\n    //~~ local storage\n\n    self._saveCurrentSortingToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var currentSorting = self.currentSorting();\n            if (currentSorting !== undefined)\n                localStorage[self.storageIds.currentSorting] = currentSorting;\n            else localStorage[self.storageIds.currentSorting] = undefined;\n        }\n    };\n\n    self._loadCurrentSortingFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            if (\n                _.contains(\n                    _.keys(supportedSorting),\n                    localStorage[self.storageIds.currentSorting]\n                )\n            )\n                self.currentSorting(localStorage[self.storageIds.currentSorting]);\n            else self.currentSorting(defaultSorting);\n        }\n    };\n\n    self._saveCurrentFiltersToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var filters = _.intersection(\n                _.keys(self.supportedFilters),\n                self.currentFilters()\n            );\n            localStorage[self.storageIds.currentFilters] = JSON.stringify(filters);\n        }\n    };\n\n    self._loadCurrentFiltersFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            self.currentFilters(\n                _.intersection(\n                    _.keys(self.supportedFilters),\n                    JSON.parse(localStorage[self.storageIds.currentFilters])\n                )\n            );\n        }\n    };\n\n    self._savePageSizeToLocalStorage = function (pageSize) {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            localStorage[self.storageIds.pageSize] = pageSize;\n        }\n    };\n\n    self.pageSize.subscribe(self._savePageSizeToLocalStorage);\n\n    self._loadPageSizeFromLocalStorage = function () {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            self.pageSize(parseInt(localStorage[self.storageIds.pageSize]));\n        }\n    };\n\n    self._initializeLocalStorage = function () {\n        if (!Modernizr.localstorage) return false;\n\n        if (\n            localStorage[self.storageIds.currentSorting] !== undefined &&\n            localStorage[self.storageIds.currentFilters] !== undefined &&\n            JSON.parse(localStorage[self.storageIds.currentFilters]) instanceof Array &&\n            localStorage[self.storageIds.pageSize] !== undefined\n        )\n            return true;\n\n        localStorage[self.storageIds.currentSorting] = self.defaultSorting;\n        localStorage[self.storageIds.currentFilters] = JSON.stringify(\n            self.defaultFilters\n        );\n        localStorage[self.storageIds.pageSize] = self.defaultPageSize;\n\n        return true;\n    };\n\n    self._loadCurrentFiltersFromLocalStorage();\n    self._loadCurrentSortingFromLocalStorage();\n    self._loadPageSizeFromLocalStorage();\n}\n\nfunction formatSize(bytes) {\n    if (!bytes) return \"-\";\n\n    var units = [\"bytes\", \"KB\", \"MB\", \"GB\"];\n    for (var i = 0; i < units.length; i++) {\n        if (bytes < 1024) {\n            return _.sprintf(\"%3.1f%s\", bytes, units[i]);\n        }\n        bytes /= 1024;\n    }\n    return _.sprintf(\"%.1f%s\", bytes, \"TB\");\n}\n\nfunction formatHuman(number) {\n    if (number === undefined) return \"-\";\n    if (number < 1000) return number;\n\n    return _.sprintf(\"%.1fK\", number / 1000);\n}\n\nfunction bytesFromSize(size) {\n    if (size === undefined || size.trim() === \"\") return undefined;\n\n    var parsed = size.match(/^([+]?[0-9]*\\.?[0-9]+)(?:\\s*)?(.*)$/);\n    var number = parsed[1];\n    var unit = parsed[2].trim();\n\n    if (unit === \"\") return parseFloat(number);\n\n    var units = {\n        b: 1,\n        byte: 1,\n        bytes: 1,\n        kb: 1024,\n        mb: Math.pow(1024, 2),\n        gb: Math.pow(1024, 3),\n        tb: Math.pow(1024, 4)\n    };\n    unit = unit.toLowerCase();\n\n    if (!units.hasOwnProperty(unit)) {\n        return undefined;\n    }\n\n    var factor = units[unit];\n    return number * factor;\n}\n\nfunction formatDuration(seconds) {\n    if (!seconds) return \"-\";\n    if (seconds < 1) return \"00:00:00\";\n\n    var s = seconds % 60;\n    var m = (seconds % 3600) / 60;\n    var h = seconds / 3600;\n\n    return _.sprintf(\n        gettext(/* L10N: duration format */ \"%(hour)02d:%(minute)02d:%(second)02d\"),\n        {hour: h, minute: m, second: s}\n    );\n}\n\nfunction formatFuzzyEstimation(seconds, base) {\n    if (!seconds || seconds < 1) return \"-\";\n\n    var m;\n    if (base !== undefined) {\n        m = moment(base);\n    } else {\n        m = moment();\n    }\n\n    m.add(seconds, \"s\");\n    return m.fromNow(true);\n}\n\nfunction formatFuzzyPrintTime(totalSeconds) {\n    /**\n     * Formats a print time estimate in a very fuzzy way.\n     *\n     * Accuracy decreases the higher the estimation is:\n     *\n     *   * less than 30s: \"a few seconds\"\n     *   * 30s to a minute: \"less than a minute\"\n     *   * 1 to 30min: rounded to full minutes, above 30s is minute + 1 (\"27 minutes\", \"2 minutes\")\n     *   * 30min to 40min: \"40 minutes\"\n     *   * 40min to 50min: \"50 minutes\"\n     *   * 50min to 1h: \"1 hour\"\n     *   * 1 to 12h: rounded to half hours, 15min to 45min is \".5\", above that hour + 1 (\"4 hours\", \"2.5 hours\")\n     *   * 12 to 24h: rounded to full hours, above 30min is hour + 1, over 23.5h is \"1 day\"\n     *   * Over a day: rounded to half days, 8h to 16h is \".5\", above that days + 1 (\"1 day\", \"4 days\", \"2.5 days\")\n     */\n\n    if (!totalSeconds || totalSeconds < 1) return \"-\";\n\n    var d = moment.duration(totalSeconds, \"seconds\");\n\n    var seconds = d.seconds();\n    var minutes = d.minutes();\n    var hours = d.hours();\n    var days = d.days();\n\n    var replacements = {\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        totalSeconds: totalSeconds\n    };\n\n    var text = \"-\";\n\n    if (days >= 1) {\n        // days\n        if (hours >= 16) {\n            replacements.days += 1;\n\n            if (replacements.days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        } else if (hours >= 8 && hours < 16) {\n            text = gettext(\"%(days)d.5 days\");\n        } else {\n            if (days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        }\n    } else if (hours >= 1) {\n        // only hours\n        if (hours < 12) {\n            if (minutes < 15) {\n                // less than .15 => .0\n                if (hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            } else if (minutes >= 15 && minutes < 45) {\n                // between .25 and .75 => .5\n                text = gettext(\"%(hours)d.5 hours\");\n            } else {\n                // over .75 => hours + 1\n                replacements.hours += 1;\n\n                if (replacements.hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            }\n        } else {\n            if (hours === 23 && minutes > 30) {\n                // over 23.5 hours => 1 day\n                text = gettext(\"1 day\");\n            } else {\n                if (minutes > 30) {\n                    // over .5 => hours + 1\n                    replacements.hours += 1;\n                }\n                text = gettext(\"%(hours)d hours\");\n            }\n        }\n    } else if (minutes >= 1) {\n        // only minutes\n        if (minutes < 2) {\n            if (seconds < 30) {\n                text = gettext(\"a minute\");\n            } else {\n                text = gettext(\"2 minutes\");\n            }\n        } else if (minutes < 30) {\n            if (seconds > 30) {\n                replacements.minutes += 1;\n            }\n            text = gettext(\"%(minutes)d minutes\");\n        } else if (minutes <= 40) {\n            text = gettext(\"40 minutes\");\n        } else if (minutes <= 50) {\n            text = gettext(\"50 minutes\");\n        } else {\n            text = gettext(\"1 hour\");\n        }\n    } else {\n        // only seconds\n        if (seconds < 30) {\n            text = gettext(\"a few seconds\");\n        } else {\n            text = gettext(\"less than a minute\");\n        }\n    }\n\n    return _.sprintf(text, replacements);\n}\n\nfunction formatDate(unixTimestamp, options) {\n    if (!options) {\n        options = {seconds: false};\n    }\n\n    if (!unixTimestamp) return \"-\";\n\n    var format = gettext(/* L10N: Date format */ \"YYYY-MM-DD HH:mm\");\n    if (options.seconds) {\n        format = gettext(/* L10N: Date format with seconds */ \"YYYY-MM-DD HH:mm:ss\");\n    }\n\n    return moment.unix(unixTimestamp).format(format);\n}\n\nfunction formatTimeAgo(unixTimestamp) {\n    if (!unixTimestamp) return \"-\";\n    return moment.unix(unixTimestamp).fromNow();\n}\n\nfunction formatFilament(filament) {\n    if (!filament || !filament[\"length\"]) return \"-\";\n    var result = \"%(length).02fm\";\n    if (filament.hasOwnProperty(\"volume\") && filament.volume) {\n        result += \" / \" + \"%(volume).02fcm\u00b3\";\n    }\n    return _.sprintf(result, {\n        length: filament[\"length\"] / 1000,\n        volume: filament[\"volume\"]\n    });\n}\n\nfunction cleanTemperature(temp, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    return temp;\n}\n\nfunction formatTemperature(temp, showF, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    if (showF) {\n        return _.sprintf(\"%.1f&deg;C (%.1f&deg;F)\", temp, (temp * 9) / 5 + 32);\n    } else {\n        return _.sprintf(\"%.1f&deg;C\", temp);\n    }\n}\n\nfunction formatNumberK(num) {\n    if (num > 1000) {\n        num = num / 1000.0;\n        return _.sprintf(\"%.2fk\", num);\n    } else {\n        return _.sprintf(\"%i\", num);\n    }\n}\n\nfunction pnotifyAdditionalInfo(inner) {\n    return (\n        '<div class=\"pnotify_additional_info\">' +\n        '<div class=\"pnotify_more\"><a href=\"#\" onclick=\"$(this).children().toggleClass(\\'icon-caret-right icon-caret-down\\').parent().parent().next().slideToggle(\\'fast\\')\">More <i class=\"icon-caret-right\"></i></a></div>' +\n        '<div class=\"pnotify_more_container hide\">' +\n        inner +\n        \"</div>\" +\n        \"</div>\"\n    );\n}\n\nfunction ping(url, callback) {\n    var img = new Image();\n    var calledBack = false;\n\n    img.onload = function () {\n        callback(true);\n        calledBack = true;\n    };\n    img.onerror = function () {\n        if (!calledBack) {\n            callback(true);\n            calledBack = true;\n        }\n    };\n    img.src = url;\n    setTimeout(function () {\n        if (!calledBack) {\n            callback(false);\n            calledBack = true;\n        }\n    }, 1500);\n}\n\nfunction showOfflineOverlay(title, message, reconnectCallback) {\n    if (title === undefined) {\n        title = gettext(\"Server is offline\");\n    }\n\n    $(\"#offline_overlay_title\").text(title);\n    $(\"#offline_overlay_message\").html(message);\n    $(\"#offline_overlay_reconnect\").click(reconnectCallback);\n\n    var overlay = $(\"#offline_overlay\");\n    if (!overlay.is(\":visible\")) overlay.show();\n}\n\nfunction hideOfflineOverlay() {\n    $(\"#offline_overlay\").hide();\n}\n\nfunction showMessageDialog(msg, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n    }\n\n    var title = options.title || \"\";\n    var message = options.message || \"\";\n    var close = options.close || gettext(\"Close\");\n    var onclose = options.onclose || undefined;\n    var onshow = options.onshow || undefined;\n    var onshown = options.onshown || undefined;\n    var nofade = options.nofade || false;\n\n    if (_.isString(message)) {\n        message = $(\"<p>\" + message + \"</p>\");\n    }\n\n    var modalHeader = $(\n        '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n            title +\n            \"</h3>\"\n    );\n    var modalBody = $(message);\n    var modalFooter = $(\n        '<a href=\"javascript:void(0)\" class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">' +\n            close +\n            \"</a>\"\n    );\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    modal\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(modalFooter));\n\n    modal.on(\"hidden\", function () {\n        if (onclose && _.isFunction(onclose)) {\n            onclose();\n        }\n    });\n\n    if (onshow) {\n        modal.on(\"show\", onshow);\n    }\n\n    if (onshown) {\n        modal.on(\"shown\", onshown);\n    }\n\n    modal.modal(\"show\");\n    return modal;\n}\n\nfunction showConfirmationDialog(msg, onacknowledge, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n        options.onproceed = onacknowledge;\n    }\n\n    var title = options.title || gettext(\"Are you sure?\");\n\n    var message = options.message || \"\";\n    var question = options.question || gettext(\"Are you sure you want to proceed?\");\n\n    var html = options.html;\n\n    var checkboxes = options.checkboxes;\n\n    var cancel = options.cancel || gettext(\"Cancel\");\n    var proceed = options.proceed || gettext(\"Proceed\");\n    var proceedClass = options.proceedClass || \"danger\";\n    var onproceed = options.onproceed || undefined;\n    var oncancel = options.oncancel || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n    var noclose = options.noclose || false;\n\n    var modalHeader;\n    if (noclose) {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    } else {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    }\n\n    var modalBody;\n    if (html) {\n        modalBody = $(html);\n    } else {\n        modalBody = $(\"<p>\" + message + \"</p><p>\" + question + \"</p>\");\n    }\n\n    var cancelButton = $('<a href=\"javascript:void(0)\" class=\"btn\">' + cancel + \"</a>\")\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    if (!_.isArray(proceed)) {\n        proceed = [proceed];\n    }\n\n    var proceedButtons = [];\n    _.each(proceed, function (text) {\n        proceedButtons.push(\n            $('<a href=\"javascript:void(0)\" class=\"btn\">' + text + \"</a>\").addClass(\n                \"btn-\" + proceedClass\n            )\n        );\n    });\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n\n    var buttons = $(\"<div></div>\").addClass(\"modal-footer\").append(cancelButton);\n    _.each(proceedButtons, function (button) {\n        buttons.append(button);\n    });\n\n    modal\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append(buttons);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n\n    var modalOptions = {};\n    if (noclose) {\n        modalOptions.backdrop = \"static\";\n        modalOptions.keyboard = false;\n    }\n    modal.modal(modalOptions);\n\n    _.each(proceedButtons, function (button, idx) {\n        button.click(function (e) {\n            e.preventDefault();\n            if (onproceed && _.isFunction(onproceed)) {\n                onproceed(idx, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n    cancelButton.click(function (e) {\n        if (oncancel && _.isFunction(oncancel)) {\n            oncancel(e);\n        }\n    });\n\n    return modal;\n}\n\nfunction showSelectionDialog(options) {\n    var title = options.title;\n    var message = options.message || undefined;\n    var selections = options.selections || [];\n\n    var maycancel = options.maycancel || false;\n    var cancel = options.cancel || undefined;\n    var onselect = options.onselect || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n\n    // header\n    var modalHeader;\n    if (maycancel) {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    } else {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    }\n\n    // body\n    var buttons = [];\n    var selectionBody = $(\"<div></div>\");\n    var container;\n    var additionalClass;\n\n    if (selections.length === 1) {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    } else if (selections.length === 2) {\n        container = $(\"<div class='row-fluid'></div>\");\n        selectionBody.append(container);\n        additionalClass = \"span6\";\n    } else {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    }\n\n    _.each(selections, function (s, i) {\n        var button = $(\n            '<button class=\"btn\" style=\"white-space: normal; word-wrap: break-word\" data-index=\"' +\n                i +\n                '\">' +\n                selections[i] +\n                \"</button>\"\n        );\n        if (additionalClass) {\n            button.addClass(additionalClass);\n        }\n        container.append(button);\n        buttons.push(button);\n\n        if (selections.length > 2 && i < selections.length - 1) {\n            container = $(\"<div class='row-fluid'></div>\");\n            selectionBody.append(container);\n        }\n    });\n\n    // divs\n    var headerDiv = $(\"<div></div>\").addClass(\"modal-header\").append(modalHeader);\n\n    var bodyDiv = $(\"<div></div>\").addClass(\"modal-body\");\n    if (message) {\n        bodyDiv.append($(\"<p>\" + message + \"</p>\"));\n    }\n    bodyDiv.append(selectionBody);\n\n    // create modal and do final wiring up\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    if (!cancel) {\n        modal.data(\"backdrop\", \"static\").data(\"keyboard\", \"false\");\n    }\n\n    modal.addClass(dialogClass).append(headerDiv).append(bodyDiv);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n    modal.modal(\"show\");\n\n    _.each(buttons, function (button) {\n        button.click(function (e) {\n            e.preventDefault();\n            var index = button.data(\"index\");\n            if (index < 0) {\n                return;\n            }\n\n            if (onselect && _.isFunction(onselect)) {\n                onselect(index, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n\n    return modal;\n}\n\n/**\n * Shows a progress modal depending on a supplied promise.\n *\n * Will listen to the supplied promise, update the progress on .progress events and\n * enabling the close button and (optionally) closing the dialog on promise resolve.\n *\n * The calling code should call \"notify\" on the deferred backing the promise and supply:\n *\n *   * the text to display on the progress bar and the optional output field and\n *     a boolean value indicating whether the operation behind that update was successful or not\n *   * a short text to display on the progress bar, a long text to display on the optional output\n *     field and a boolean value indicating whether the operation behind that update was\n *     successful or not\n *\n * Non-successful progress updates will remove the barClassSuccess class from the progress bar and\n * apply the barClassFailure class and also apply the outputClassFailure to the produced line\n * in the output.\n *\n * To determine the progress, calling code should supply the prognosed maximum number of\n * progress events. An internal counter will increment on each progress event and used together\n * with the max value to calculate the percentage to display on the progress bar.\n *\n * If no max value is set, the progress bar will show a striped animation at 100% fill status\n * to visualize \"unknown but ongoing\" status.\n *\n * Available options:\n *\n *   * title: the title of the modal, defaults to \"Progress\"\n *   * message: the message of the modal, defaults to \"\"\n *   * buttonText: the text on the close button, defaults to \"Close\"\n *   * max: maximum number of expected progress events (when 100% will be reached), defaults\n *     to undefined\n *   * close: whether to close the dialog on completion, defaults to false\n *   * output: whether to display the progress texts in an output field, defaults to false\n *   * dialogClass: additional class to apply to the dialog div\n *   * barClassSuccess: additional class for the progress bar while all progress events are\n *     successful\n *   * barClassFailure: additional class for the progress bar when a progress event was\n *     unsuccessful\n *   * outputClassSuccess: additional class for successful output lines\n *   * outputClassFailure: additional class for unsuccessful output lines\n *\n * @param options modal options\n * @param promise promise to monitor\n * @returns {*|jQuery} the modal object\n */\nfunction showProgressModal(options, promise) {\n    var title = options.title || gettext(\"Progress\");\n    var message = options.message || \"\";\n    var buttonText = options.button || gettext(\"Close\");\n    var max = options.max || undefined;\n    var close = options.close || false;\n    var output = options.output || false;\n\n    var dialogClass = options.dialogClass || \"\";\n    var barClassSuccess = options.barClassSuccess || \"\";\n    var barClassFailure = options.barClassFailure || \"bar-danger\";\n    var outputClassSuccess = options.outputClassSuccess || \"\";\n    var outputClassFailure = options.outputClassFailure || \"text-error\";\n\n    var modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    var paragraph = $(\"<p>\" + message + \"</p>\");\n\n    var progress = $('<div class=\"progress progress-text-centered\"></div>');\n    var progressBar = $('<div class=\"bar\"></div>').addClass(barClassSuccess);\n    var progressText = $('<span class=\"progress-text-back\"></span>');\n\n    if (max === undefined) {\n        progress.addClass(\"progress-striped active\");\n        progressBar.width(\"100%\");\n    }\n\n    progress.append(progressBar).append(progressText);\n\n    var button = $('<button class=\"btn\">' + buttonText + \"</button>\")\n        .prop(\"disabled\", true)\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    var modalBody = $(\"<div></div>\")\n        .addClass(\"modal-body\")\n        .append(paragraph)\n        .append(progress);\n\n    var pre;\n    if (output) {\n        pre = $(\n            \"<pre class='pre-scrollable pre-output' style='height: 70px; font-size: 0.8em'></pre>\"\n        );\n        modalBody.append(pre);\n    }\n\n    var modal = $(\"<div></div>\")\n        .addClass(\"modal hide fade-in\")\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append(modalBody)\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(button));\n    modal.modal({keyboard: false, backdrop: \"static\", show: true});\n\n    var counter = 0;\n    promise\n        .progress(function () {\n            var short, long, success;\n            if (arguments.length === 2) {\n                short = long = arguments[0];\n                success = arguments[1];\n            } else if (arguments.length === 3) {\n                short = arguments[0];\n                long = arguments[1];\n                success = arguments[2];\n            } else {\n                throw Error(\n                    \"Invalid parameters for showProgressModal, expected either (text, success) or (short, long, success)\"\n                );\n            }\n\n            var value;\n\n            if (max === undefined || max <= 0) {\n                value = 100;\n            } else {\n                counter++;\n                value = Math.max(Math.min((counter * 100) / max, 100), 0);\n            }\n\n            // update progress bar\n            progressBar.width(String(value) + \"%\");\n            progressText.text(short);\n            if (value < 50 && progressText.hasClass(\"progress-text-front\")) {\n                progressText\n                    .removeClass(\"progress-text-front\")\n                    .addClass(\"progress-text-back\");\n            } else if (value >= 50 && progressText.hasClass(\"progress-text-back\")) {\n                progressText\n                    .removeClass(\"progress-text-back\")\n                    .addClass(\"progress-text-front\");\n            }\n\n            // if not successful, apply failure class\n            if (!success && !progressBar.hasClass(barClassFailure)) {\n                progressBar.removeClass(barClassSuccess).addClass(barClassFailure);\n            }\n\n            if (output && pre) {\n                if (success) {\n                    pre.append(\n                        $(\"<span class='\" + outputClassSuccess + \"'>\" + long + \"</span>\")\n                    );\n                } else {\n                    pre.append(\n                        $(\"<span class='\" + outputClassFailure + \"'>\" + long + \"</span>\")\n                    );\n                }\n                pre.scrollTop(pre[0].scrollHeight - pre.height());\n            }\n        })\n        .done(function () {\n            button.prop(\"disabled\", false);\n            if (close) {\n                modal.modal(\"hide\");\n            }\n        })\n        .fail(function () {\n            button.prop(\"disabled\", false);\n        });\n\n    return modal;\n}\n\nfunction showReloadOverlay() {\n    $(\"#reloadui_overlay\").show();\n}\n\nfunction wrapPromiseWithAlways(p) {\n    var deferred = $.Deferred();\n    p.always(function () {\n        deferred.resolve.apply(deferred, arguments);\n    });\n    return deferred.promise();\n}\n\nfunction commentableLinesToArray(lines) {\n    return splitTextToArray(lines, \"\\n\", true, function (item) {\n        return !_.startsWith(item, \"#\");\n    });\n}\n\nfunction splitTextToArray(text, sep, stripEmpty, filter) {\n    return _.filter(\n        _.map(text.split(sep), function (item) {\n            return item ? item.trim() : \"\";\n        }),\n        function (item) {\n            return (stripEmpty ? item : true) && (filter ? filter(item) : true);\n        }\n    );\n}\n\n/**\n * Returns true if comparing data and oldData yields changes, false otherwise.\n *\n * E.g.\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\", key: \"value\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\", four: \"4\"}}\n *   )\n *\n * will return\n *\n *   true\n *\n * and\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   false\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction hasDataChanged(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == oldData && data == undefined) {\n        return false;\n    }\n\n    if (_.isPlainObject(data) && _.isPlainObject(oldData)) {\n        return _.any(_.keys(data), function (key) {\n            return hasDataChanged(data[key], oldData[key]);\n        });\n    } else {\n        return !_.isEqual(data, oldData);\n    }\n}\n\n/**\n * Compare provided data and oldData plain objects and only return those\n * substructures of data that actually changed.\n *\n * E.g.\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {fnord: {three: \"three\"}}\n *\n * and\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {}\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction getOnlyChangedData(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == undefined) {\n        return {};\n    }\n\n    // noinspection EqualityComparisonWithCoercionJS\n    if (oldData == undefined) {\n        return data;\n    }\n\n    var f = function (root, oldRoot) {\n        if (!_.isPlainObject(root)) {\n            return root;\n        }\n\n        var retval = {};\n        _.forOwn(root, function (value, key) {\n            var oldValue = undefined;\n            // noinspection EqualityComparisonWithCoercionJS\n            if (oldRoot != undefined && oldRoot.hasOwnProperty(key)) {\n                oldValue = oldRoot[key];\n            }\n            if (_.isPlainObject(value)) {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (oldValue == undefined) {\n                    retval[key] = value;\n                } else if (hasDataChanged(value, oldValue)) {\n                    retval[key] = f(value, oldValue);\n                }\n            } else {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (\n                    !(value == oldValue && value == undefined) &&\n                    !_.isEqual(value, oldValue)\n                ) {\n                    retval[key] = value;\n                }\n            }\n        });\n        return retval;\n    };\n\n    return f(data, oldData);\n}\n\nfunction setOnViewModels(allViewModels, key, value) {\n    setOnViewModelsIf(allViewModels, key, value, undefined);\n}\n\nfunction setOnViewModelsIf(allViewModels, key, value, condition) {\n    if (!allViewModels) return;\n    _.each(allViewModels, function (viewModel) {\n        setOnViewModelIf(viewModel, key, value, condition);\n    });\n}\n\nfunction setOnViewModel(viewModel, key, value) {\n    setOnViewModelIf(viewModel, key, value, undefined);\n}\n\nfunction setOnViewModelIf(viewModel, key, value, condition) {\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    try {\n        if (!condition(viewModel)) {\n            return;\n        }\n\n        viewModel[key] = value;\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        log.error(\n            \"Error while setting\",\n            key,\n            \"to\",\n            value,\n            \"on view model\",\n            viewModel.constructor.name,\n            \":\",\n            exc.stack || exc\n        );\n    }\n}\n\nfunction callViewModels(allViewModels, method, callback) {\n    callViewModelsIf(allViewModels, method, undefined, callback);\n}\n\nfunction callViewModelsIf(allViewModels, method, condition, callback) {\n    if (!allViewModels) return;\n\n    _.each(allViewModels, function (viewModel) {\n        try {\n            callViewModelIf(viewModel, method, condition, callback);\n        } catch (exc) {\n            if (typeof Sentry !== \"undefined\") {\n                Sentry.captureException(exc);\n            }\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    });\n}\n\nfunction callViewModel(viewModel, method, callback, raiseErrors) {\n    callViewModelIf(viewModel, method, undefined, callback, raiseErrors);\n}\n\nfunction callViewModelIf(viewModel, method, condition, callback, raiseErrors) {\n    raiseErrors = raiseErrors === true || false;\n\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    if (!_.isFunction(viewModel[method]) || !condition(viewModel, method)) return;\n\n    var parameters = undefined;\n    if (!_.isFunction(callback)) {\n        // if callback is not a function that means we are supposed to directly\n        // call the view model method instead of providing it to the callback\n        // - let's figure out how\n\n        if (callback === undefined) {\n            // directly call view model method with no parameters\n            parameters = undefined;\n            log.trace(\"Calling method\", method, \"on view model\");\n        } else if (_.isArray(callback)) {\n            // directly call view model method with these parameters\n            parameters = callback;\n            log.trace(\n                \"Calling method\",\n                method,\n                \"on view model with specified parameters\",\n                parameters\n            );\n        } else {\n            // ok, this doesn't make sense, callback is neither undefined nor\n            // an array, we'll return without doing anything\n            return;\n        }\n\n        // we reset this here so we now further down that we want to call\n        // the method directly\n        callback = undefined;\n    } else {\n        log.trace(\n            \"Providing method\",\n            method,\n            \"on view model to specified callback\",\n            callback\n        );\n    }\n\n    try {\n        if (callback === undefined) {\n            if (parameters !== undefined) {\n                // call the method with the provided parameters\n                viewModel[method].apply(viewModel, parameters);\n            } else {\n                // call the method without parameters\n                viewModel[method]();\n            }\n        } else {\n            // provide the method to the callback\n            callback(viewModel[method], viewModel);\n        }\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        if (raiseErrors) {\n            throw exc;\n        } else {\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    }\n}\n\nvar sizeObservable = function (observable) {\n    return ko.computed({\n        read: function () {\n            return formatSize(observable());\n        },\n        write: function (value) {\n            var result = bytesFromSize(value);\n            if (result !== undefined) {\n                observable(result);\n            }\n        }\n    });\n};\n\nvar getQueryParameterByName = function (name, url) {\n    // from http://stackoverflow.com/a/901144/2028598\n    if (!url) {\n        url = window.location.href;\n    }\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return \"\";\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n};\n\n/**\n * Escapes unprintable ASCII characters in the provided string.\n *\n * E.g. turns a null byte in the string into \"\\x00\".\n *\n * Characters 0 to 31 excluding 9, 10 and 13 will be escaped, as will\n * 127, 128 to 159 and 255. That should leave printable characters and unicode\n * alone.\n *\n * Originally based on\n * https://gist.github.com/mathiasbynens/1243213#gistcomment-53590\n *\n * @param str The string to escape\n * @returns {string}\n */\nvar escapeUnprintableCharacters = function (str) {\n    var result = \"\";\n    var index = 0;\n    var charCode;\n\n    while (!isNaN((charCode = str.charCodeAt(index)))) {\n        if (\n            (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) ||\n            charCode === 127 ||\n            (charCode >= 128 && charCode <= 159) ||\n            charCode === 255\n        ) {\n            // special hex chars\n            result += \"\\\\x\" + (charCode > 15 ? \"\" : \"0\") + charCode.toString(16);\n        } else {\n            // anything else\n            result += str[index];\n        }\n\n        index++;\n    }\n    return result;\n};\n\nvar copyToClipboard = function (text) {\n    var temp = $(\"<textarea>\");\n    $(\"body\").append(temp);\n    temp.val(text).select();\n    document.execCommand(\"copy\");\n    temp.remove();\n};\n\nvar determineWebcamStreamType = function (streamUrl) {\n    if (streamUrl) {\n        if (streamUrl.startsWith(\"webrtc\")) {\n            return \"webrtc\";\n        }\n\n        var lastDotPosition = streamUrl.lastIndexOf(\".\");\n        var firstQuotationSignPosition = streamUrl.indexOf(\"?\");\n        if (\n            lastDotPosition != -1 &&\n            firstQuotationSignPosition != -1 &&\n            lastDotPosition >= firstQuotationSignPosition\n        ) {\n            throw \"Malformed URL. Cannot determine stream type.\";\n        }\n\n        // If we have found a dot, try to extract the extension.\n        if (lastDotPosition > -1) {\n            if (firstQuotationSignPosition > -1) {\n                var extension = streamUrl.slice(\n                    lastDotPosition + 1,\n                    firstQuotationSignPosition - 1\n                );\n            } else {\n                var extension = streamUrl.slice(lastDotPosition + 1);\n            }\n            if (extension.toLowerCase() == \"m3u8\") {\n                return \"hls\";\n            }\n        }\n        // By default, 'mjpg' is the stream type.\n        return \"mjpg\";\n    } else {\n        throw \"Empty streamUrl. Cannot determine stream type.\";\n    }\n};\n\nvar saveToLocalStorage = function (key, data) {\n    if (!Modernizr.localstorage) return;\n    localStorage[key] = JSON.stringify(data);\n};\n\nvar loadFromLocalStorage = function (key, defaultValue) {\n    defaultValue = defaultValue === undefined ? {} : defaultValue;\n\n    if (!Modernizr.localstorage) return defaultValue;\n\n    var currentString = localStorage[key];\n    var current;\n    if (currentString === undefined) {\n        current = defaultValue;\n    } else {\n        try {\n            current = JSON.parse(currentString);\n        } catch (ex) {\n            current = defaultValue;\n        }\n    }\n    return current;\n};\n\nvar deepMerge = function (target, source) {\n    /**\n     * Implements an object deep merge, which contrary to _.merge doesn't try to\n     * merge arrays.\n     */\n    if (!_.isObject(target)) {\n        return target;\n    }\n\n    _.forOwn(source, function (value, key) {\n        if (\n            target.hasOwnProperty(key) &&\n            _.isPlainObject(target[key]) &&\n            _.isPlainObject(value)\n        ) {\n            target[key] = deepMerge(target[key], value);\n        } else {\n            target[key] = value;\n        }\n    });\n\n    return target;\n};\n\nvar isWebRTCAvailable = function () {\n    return (\n        typeof RTCPeerConnection == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addTransceiver == \"function\" &&\n        typeof RTCPeerConnection.prototype.createOffer == \"function\" &&\n        typeof RTCPeerConnection.prototype.setLocalDescription == \"function\" &&\n        typeof RTCPeerConnection.prototype.removeEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.setRemoteDescription == \"function\"\n    );\n};\n\nvar negotiateWebRTC = function (streamUrl) {\n    pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n    pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n    return pc\n        .createOffer()\n        .then(function (offer) {\n            return pc.setLocalDescription(offer);\n        })\n        .then(function () {\n            // Wait for ICE gathering to complete\n            return new Promise(function (resolve) {\n                if (pc.iceGatheringState === \"complete\") {\n                    resolve();\n                } else {\n                    function checkState() {\n                        if (pc.iceGatheringState === \"complete\") {\n                            pc.removeEventListener(\"icegatheringstatechange\", checkState);\n                            resolve();\n                        }\n                    }\n                    pc.addEventListener(\"icegatheringstatechange\", checkState);\n                }\n            });\n        })\n        .then(function () {\n            var offer = pc.localDescription;\n            // webrtc://host.com becomes http://host.com\n            // webrtcs://host.com becomes https://host.com\n            streamUrl = \"http\" + streamUrl.slice(\"webrtc\".length);\n            return $.ajax({\n                url: streamUrl,\n                type: \"POST\",\n                dataType: \"json\",\n                data: JSON.stringify({\n                    sdp: offer.sdp,\n                    type: offer.type\n                }),\n                contentType: \"application/json; charset=UTF-8\"\n            });\n        })\n        .then(function (response) {\n            return pc.setRemoteDescription(response);\n        })\n        .catch(function (e) {\n            console.error(e);\n        });\n};\n\nvar startWebRTC = function (videoElement, streamUrl, iceServers) {\n    var config = {\n        sdpSemantics: \"unified-plan\"\n    };\n    if (iceServers) {\n        config.iceServers = [{urls: iceServers}];\n    }\n    pc = new RTCPeerConnection(config);\n    pc.addEventListener(\"track\", function (evt) {\n        if (evt.track.kind == \"video\") {\n            videoElement.srcObject = evt.streams[0];\n        }\n    });\n\n    negotiateWebRTC(streamUrl);\n    return pc;\n};\n", "patch": "@@ -1542,41 +1542,74 @@ var copyToClipboard = function (text) {\n     temp.remove();\n };\n \n-var determineWebcamStreamType = function (streamUrl) {\n-    if (streamUrl) {\n-        if (streamUrl.startsWith(\"webrtc\")) {\n-            return \"webrtc\";\n-        }\n+var getExternalHostUrl = function () {\n+    var loc = window.location;\n+    var port = \"\";\n+    if (\n+        (loc.protocol === \"http:\" && loc.port !== \"80\") ||\n+        (loc.protocol === \"https:\" && loc.port !== \"443\")\n+    ) {\n+        port = \":\" + loc.port;\n+    }\n+    return loc.protocol + \"//\" + loc.hostname + port;\n+};\n \n-        var lastDotPosition = streamUrl.lastIndexOf(\".\");\n-        var firstQuotationSignPosition = streamUrl.indexOf(\"?\");\n-        if (\n-            lastDotPosition != -1 &&\n-            firstQuotationSignPosition != -1 &&\n-            lastDotPosition >= firstQuotationSignPosition\n-        ) {\n-            throw \"Malformed URL. Cannot determine stream type.\";\n-        }\n+var validateWebcamUrl = function (streamUrl) {\n+    if (!streamUrl) {\n+        return false;\n+    }\n \n-        // If we have found a dot, try to extract the extension.\n-        if (lastDotPosition > -1) {\n-            if (firstQuotationSignPosition > -1) {\n-                var extension = streamUrl.slice(\n-                    lastDotPosition + 1,\n-                    firstQuotationSignPosition - 1\n-                );\n-            } else {\n-                var extension = streamUrl.slice(lastDotPosition + 1);\n-            }\n-            if (extension.toLowerCase() == \"m3u8\") {\n-                return \"hls\";\n-            }\n-        }\n-        // By default, 'mjpg' is the stream type.\n-        return \"mjpg\";\n+    var lower = streamUrl.toLowerCase();\n+    var toParse = streamUrl;\n+\n+    if (lower.startsWith(\"//\")) {\n+        // protocol relative\n+        toParse = window.location.protocol + streamUrl;\n+    } else if (lower.startsWith(\"/\")) {\n+        // host relative\n+        toParse = getExternalHostUrl() + streamUrl;\n+    } else if (\n+        lower.startsWith(\"http:\") ||\n+        lower.startsWith(\"https:\") ||\n+        lower.startsWith(\"webrtc:\")\n+    ) {\n+        // absolute & http/https/webrtc\n+        toParse = streamUrl;\n     } else {\n+        return false;\n+    }\n+\n+    try {\n+        return new URL(toParse);\n+    } catch (e) {\n+        return false;\n+    }\n+};\n+\n+var determineWebcamStreamType = function (streamUrl) {\n+    if (!streamUrl) {\n         throw \"Empty streamUrl. Cannot determine stream type.\";\n     }\n+\n+    var parsed = validateWebcamUrl(streamUrl);\n+    if (!parsed) {\n+        throw \"Invalid streamUrl. Cannot determine stream type.\";\n+    }\n+\n+    if (parsed.protocol === \"webrtc:\") {\n+        return \"webrtc\";\n+    }\n+\n+    var lastDotPosition = parsed.pathname.lastIndexOf(\".\");\n+    if (lastDotPosition !== -1) {\n+        var extension = parsed.pathname.substring(lastDotPosition + 1);\n+        if (extension.toLowerCase() === \"m3u8\") {\n+            return \"hls\";\n+        }\n+    }\n+\n+    // By default, 'mjpg' is the stream type.\n+    return \"mjpg\";\n };\n \n var saveToLocalStorage = function (key, data) {", "file_path": "files/2022_5/485", "file_language": "js", "file_name": "src/octoprint/static/js/app/helpers.js", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1}, {"raw_url": "https://github.com/OctoPrint/OctoPrint/raw/6d259d7e6f5b0de9a1c762831537a386e53978d3/src%2Foctoprint%2Fstatic%2Fjs%2Fapp%2Fviewmodels%2Fsettings.js", "code": "$(function () {\n    function SettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n        self.printerProfiles = parameters[2];\n        self.about = parameters[3];\n\n        // TODO: remove in upcoming version, this is only for backwards compatibility\n        self.users = parameters[4];\n\n        // use this promise to do certain things once the SettingsViewModel has processed\n        // its first request\n        var firstRequest = $.Deferred();\n        self.firstRequest = firstRequest.promise();\n\n        self.allViewModels = [];\n\n        self.receiving = ko.observable(false);\n        self.sending = ko.observable(false);\n        self.exchanging = ko.pureComputed(function () {\n            return self.receiving() || self.sending();\n        });\n        self.outstanding = [];\n\n        self.active = false;\n        self.sawUpdateEventWhileActive = false;\n        self.ignoreNextUpdateEvent = false;\n\n        self.settingsDialog = undefined;\n        self.settings_dialog_update_detected = undefined;\n        self.translationManagerDialog = undefined;\n        self.translationUploadElement = $(\n            \"#settings_appearance_managelanguagesdialog_upload\"\n        );\n        self.translationUploadButton = $(\n            \"#settings_appearance_managelanguagesdialog_upload_start\"\n        );\n\n        self.translationUploadFilename = ko.observable();\n        self.invalidTranslationArchive = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                !(\n                    _.endsWith(name.toLocaleLowerCase(), \".zip\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar.gz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tgz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar\")\n                )\n            );\n        });\n        self.enableTranslationUpload = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                name.trim() != \"\" &&\n                !self.invalidTranslationArchive()\n            );\n        });\n\n        self.translations = new ItemListHelper(\n            \"settings.translations\",\n            {\n                locale: function (a, b) {\n                    // sorts ascending\n                    if (a[\"locale\"].toLocaleLowerCase() < b[\"locale\"].toLocaleLowerCase())\n                        return -1;\n                    if (a[\"locale\"].toLocaleLowerCase() > b[\"locale\"].toLocaleLowerCase())\n                        return 1;\n                    return 0;\n                }\n            },\n            {},\n            \"locale\",\n            [],\n            [],\n            0\n        );\n\n        self.appearance_available_colors = ko.observable([\n            {key: \"default\", name: gettext(\"default\")},\n            {key: \"red\", name: gettext(\"red\")},\n            {key: \"orange\", name: gettext(\"orange\")},\n            {key: \"yellow\", name: gettext(\"yellow\")},\n            {key: \"green\", name: gettext(\"green\")},\n            {key: \"blue\", name: gettext(\"blue\")},\n            {key: \"violet\", name: gettext(\"violet\")},\n            {key: \"black\", name: gettext(\"black\")},\n            {key: \"white\", name: gettext(\"white\")}\n        ]);\n\n        self.appearance_colorName = function (color) {\n            switch (color) {\n                case \"red\":\n                    return gettext(\"red\");\n                case \"orange\":\n                    return gettext(\"orange\");\n                case \"yellow\":\n                    return gettext(\"yellow\");\n                case \"green\":\n                    return gettext(\"green\");\n                case \"blue\":\n                    return gettext(\"blue\");\n                case \"violet\":\n                    return gettext(\"violet\");\n                case \"black\":\n                    return gettext(\"black\");\n                case \"white\":\n                    return gettext(\"white\");\n                case \"default\":\n                    return gettext(\"default\");\n                default:\n                    return color;\n            }\n        };\n\n        self.webcam_available_ratios = [\"16:9\", \"4:3\"];\n        self.webcam_available_videocodecs = [\"libx264\", \"mpeg2video\"];\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Autodetect from browser\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.api_key = ko.observable(undefined);\n        self.api_allowCrossOrigin = ko.observable(undefined);\n\n        self.appearance_name = ko.observable(undefined);\n        self.appearance_color = ko.observable(undefined);\n        self.appearance_colorTransparent = ko.observable();\n        self.appearance_colorIcon = ko.observable();\n        self.appearance_defaultLanguage = ko.observable();\n        self.appearance_showFahrenheitAlso = ko.observable(undefined);\n        self.appearance_fuzzyTimes = ko.observable(undefined);\n        self.appearance_closeModalsWithClick = ko.observable(undefined);\n        self.appearance_showInternalFilename = ko.observable(undefined);\n\n        self.printer_defaultExtrusionLength = ko.observable(undefined);\n\n        self.webcam_webcamEnabled = ko.observable(undefined);\n        self.webcam_timelapseEnabled = ko.observable(undefined);\n        self.webcam_streamUrl = ko.observable(undefined);\n        self.webcam_streamRatio = ko.observable(undefined);\n        self.webcam_streamTimeout = ko.observable(undefined);\n        self.webcam_streamWebrtcIceServers = ko.observable(undefined);\n        self.webcam_snapshotUrl = ko.observable(undefined);\n        self.webcam_snapshotTimeout = ko.observable(undefined);\n        self.webcam_snapshotSslValidation = ko.observable(undefined);\n        self.webcam_ffmpegPath = ko.observable(undefined);\n        self.webcam_ffmpegCommandline = ko.observable(undefined);\n        self.webcam_bitrate = ko.observable(undefined);\n        self.webcam_ffmpegThreads = ko.observable(undefined);\n        self.webcam_ffmpegVideoCodec = ko.observable(undefined);\n        self.webcam_watermark = ko.observable(undefined);\n        self.webcam_flipH = ko.observable(undefined);\n        self.webcam_flipV = ko.observable(undefined);\n        self.webcam_rotate90 = ko.observable(undefined);\n        self.webcam_cacheBuster = ko.observable(undefined);\n\n        self.feature_temperatureGraph = ko.observable(undefined);\n        self.feature_sdSupport = ko.observable(undefined);\n        self.feature_keyboardControl = ko.observable(undefined);\n        self.feature_pollWatched = ko.observable(undefined);\n        self.feature_modelSizeDetection = ko.observable(undefined);\n        self.feature_rememberFileFolder = ko.observable(undefined);\n        self.feature_printStartConfirmation = ko.observable(undefined);\n        self.feature_printCancelConfirmation = ko.observable(undefined);\n        self.feature_uploadOverwriteConfirmation = ko.observable(undefined);\n        self.feature_g90InfluencesExtruder = ko.observable(undefined);\n        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\n\n        self.gcodeAnalysis_runAt = ko.observable(undefined);\n\n        self.serial_port = ko.observable();\n        self.serial_baudrate = ko.observable();\n        self.serial_exclusive = ko.observable();\n        self.serial_lowLatency = ko.observable();\n        self.serial_portOptions = ko.observableArray([]);\n        self.serial_baudrateOptions = ko.observableArray([]);\n        self.serial_autoconnect = ko.observable(undefined);\n        self.serial_timeoutConnection = ko.observable(undefined);\n        self.serial_timeoutDetectionFirst = ko.observable(undefined);\n        self.serial_timeoutDetectionConsecutive = ko.observable(undefined);\n        self.serial_timeoutCommunication = ko.observable(undefined);\n        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\n        self.serial_timeoutTemperature = ko.observable(undefined);\n        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\n        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\n        self.serial_timeoutSdStatus = ko.observable(undefined);\n        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\n        self.serial_timeoutPosAutoreport = ko.observable(undefined);\n        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\n        self.serial_timeoutPositionLogWait = ko.observable(undefined);\n        self.serial_log = ko.observable(undefined);\n        self.serial_additionalPorts = ko.observable(undefined);\n        self.serial_additionalBaudrates = ko.observable(undefined);\n        self.serial_blacklistedPorts = ko.observable(undefined);\n        self.serial_blacklistedBaudrates = ko.observable(undefined);\n        self.serial_longRunningCommands = ko.observable(undefined);\n        self.serial_checksumRequiringCommands = ko.observable(undefined);\n        self.serial_blockedCommands = ko.observable(undefined);\n        self.serial_ignoredCommands = ko.observable(undefined);\n        self.serial_pausingCommands = ko.observable(undefined);\n        self.serial_sdCancelCommand = ko.observable(undefined);\n        self.serial_emergencyCommands = ko.observable(undefined);\n        self.serial_helloCommand = ko.observable(undefined);\n        self.serial_serialErrorBehaviour = ko.observable(\"cancel\");\n        self.serial_triggerOkForM29 = ko.observable(undefined);\n        self.serial_waitForStart = ko.observable(undefined);\n        self.serial_sendChecksum = ko.observable(\"print\");\n        self.serial_sendChecksumWithUnknownCommands = ko.observable(undefined);\n        self.serial_unknownCommandsNeedAck = ko.observable(undefined);\n        self.serial_sdRelativePath = ko.observable(undefined);\n        self.serial_sdLowerCase = ko.observable(undefined);\n        self.serial_sdAlwaysAvailable = ko.observable(undefined);\n        self.serial_swallowOkAfterResend = ko.observable(undefined);\n        self.serial_repetierTargetTemp = ko.observable(undefined);\n        self.serial_disableExternalHeatupDetection = ko.observable(undefined);\n        self.serial_ignoreIdenticalResends = ko.observable(undefined);\n        self.serial_firmwareDetection = ko.observable(undefined);\n        self.serial_blockWhileDwelling = ko.observable(undefined);\n        self.serial_useParityWorkaround = ko.observable(undefined);\n        self.serial_sanityCheckTools = ko.observable(undefined);\n        self.serial_supportResendsWithoutOk = ko.observable(undefined);\n        self.serial_logPositionOnPause = ko.observable(undefined);\n        self.serial_logPositionOnCancel = ko.observable(undefined);\n        self.serial_abortHeatupOnCancel = ko.observable(undefined);\n        self.serial_maxTimeoutsIdle = ko.observable(undefined);\n        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\n        self.serial_maxTimeoutsLong = ko.observable(undefined);\n        self.serial_capAutoreportTemp = ko.observable(undefined);\n        self.serial_capAutoreportSdStatus = ko.observable(undefined);\n        self.serial_capAutoreportPos = ko.observable(undefined);\n        self.serial_capBusyProtocol = ko.observable(undefined);\n        self.serial_capEmergencyParser = ko.observable(undefined);\n        self.serial_capExtendedM20 = ko.observable(undefined);\n        self.serial_sendM112OnError = ko.observable(undefined);\n        self.serial_disableSdPrintingDetection = ko.observable(undefined);\n        self.serial_ackMax = ko.observable(undefined);\n        self.serial_resendRatioThreshold = ko.observable(100);\n        self.serial_resendRatioStart = ko.observable(100);\n        self.serial_ignoreEmptyPorts = ko.observable(undefined);\n        self.serial_enableShutdownActionCommand = ko.observable(undefined);\n\n        self.folder_uploads = ko.observable(undefined);\n        self.folder_timelapse = ko.observable(undefined);\n        self.folder_timelapseTmp = ko.observable(undefined);\n        self.folder_logs = ko.observable(undefined);\n        self.folder_watched = ko.observable(undefined);\n\n        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\n        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\n        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\n        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\n        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\n        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\n        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\n        self.scripts_gcode_afterToolChange = ko.observable(undefined);\n        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\n\n        self.temperature_profiles = ko.observableArray(undefined);\n        self.temperature_cutoff = ko.observable(undefined);\n        self.temperature_sendAutomatically = ko.observable(undefined);\n        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\n\n        self.system_actions = ko.observableArray([]);\n\n        self.terminalFilters = ko.observableArray([]);\n\n        self.server_commands_systemShutdownCommand = ko.observable(undefined);\n        self.server_commands_systemRestartCommand = ko.observable(undefined);\n        self.server_commands_serverRestartCommand = ko.observable(undefined);\n\n        self.server_diskspace_warning = ko.observable();\n        self.server_diskspace_critical = ko.observable();\n        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\n        self.server_diskspace_critical_str = sizeObservable(\n            self.server_diskspace_critical\n        );\n\n        self.server_onlineCheck_enabled = ko.observable();\n        self.server_onlineCheck_interval = ko.observable();\n        self.server_onlineCheck_host = ko.observable();\n        self.server_onlineCheck_port = ko.observable();\n        self.server_onlineCheck_name = ko.observable();\n\n        self.server_pluginBlacklist_enabled = ko.observable();\n        self.server_pluginBlacklist_url = ko.observable();\n        self.server_pluginBlacklist_ttl = ko.observable();\n\n        self.server_allowFraming = ko.observable();\n\n        self.settings = undefined;\n        self.lastReceivedSettings = undefined;\n\n        self.webcam_ffmpegPathText = ko.observable();\n        self.webcam_ffmpegPathOk = ko.observable(false);\n        self.webcam_ffmpegPathBroken = ko.observable(false);\n        self.webcam_ffmpegPathReset = function () {\n            self.webcam_ffmpegPathText(\"\");\n            self.webcam_ffmpegPathOk(false);\n            self.webcam_ffmpegPathBroken(false);\n        };\n        self.webcam_streamType = ko.pureComputed(function () {\n            try {\n                return determineWebcamStreamType(self.webcam_streamUrl());\n            } catch (e) {\n                return \"\";\n            }\n        });\n        self.webcam_streamValid = ko.pureComputed(function () {\n            var url = self.webcam_streamUrl();\n            return !url || validateWebcamUrl(url);\n        });\n\n        self.server_onlineCheckText = ko.observable();\n        self.server_onlineCheckOk = ko.observable(false);\n        self.server_onlineCheckBroken = ko.observable(false);\n        self.server_onlineCheckReset = function () {\n            self.server_onlineCheckText(\"\");\n            self.server_onlineCheckOk(false);\n            self.server_onlineCheckBroken(false);\n        };\n        self.server_onlineCheckResolutionText = ko.observable();\n        self.server_onlineCheckResolutionOk = ko.observable(false);\n        self.server_onlineCheckResolutionBroken = ko.observable(false);\n        self.server_onlineCheckResolutionReset = function () {\n            self.server_onlineCheckResolutionText(\"\");\n            self.server_onlineCheckResolutionOk(false);\n            self.server_onlineCheckResolutionBroken(false);\n        };\n\n        var folderTypes = [\"uploads\", \"timelapse\", \"timelapseTmp\", \"logs\", \"watched\"];\n\n        var checkForDuplicateFolders = function () {\n            _.each(folderTypes, function (folderType) {\n                var path = self[\"folder_\" + folderType]();\n                var duplicate = false;\n                _.each(folderTypes, function (otherFolderType) {\n                    if (folderType !== otherFolderType) {\n                        duplicate =\n                            duplicate || path === self[\"folder_\" + otherFolderType]();\n                    }\n                });\n                self.testFolderConfigDuplicate[folderType](duplicate);\n            });\n        };\n\n        self.testFolderConfigText = {};\n        self.testFolderConfigOk = {};\n        self.testFolderConfigBroken = {};\n        self.testFolderConfigDuplicate = {};\n        self.testFolderConfigError = {};\n        self.testFolderConfigSuccess = {};\n        _.each(folderTypes, function (folderType) {\n            self.testFolderConfigText[folderType] = ko.observable(\"\");\n            self.testFolderConfigOk[folderType] = ko.observable(false);\n            self.testFolderConfigBroken[folderType] = ko.observable(false);\n            self.testFolderConfigDuplicate[folderType] = ko.observable(false);\n            self.testFolderConfigError[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigBroken[folderType]() ||\n                    self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self.testFolderConfigSuccess[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigOk[folderType]() &&\n                    !self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self[\"folder_\" + folderType].subscribe(checkForDuplicateFolders);\n        });\n        self.testFolderConfigReset = function () {\n            _.each(folderTypes, function (folderType) {\n                self.testFolderConfigText[folderType](\"\");\n                self.testFolderConfigOk[folderType](false);\n                self.testFolderConfigBroken[folderType](false);\n            });\n        };\n        self.testFoldersDuplicate = ko.pureComputed(function () {\n            var foundDupe = false;\n            _.each(folderTypes, function (folderType) {\n                foundDupe = foundDupe || self.testFolderConfigDuplicate[folderType]();\n            });\n            return foundDupe;\n        });\n\n        self.observableCopies = {\n            feature_waitForStart: \"serial_waitForStart\",\n            feature_sendChecksum: \"serial_sendChecksum\",\n            feature_sdRelativePath: \"serial_sdRelativePath\",\n            feature_sdAlwaysAvailable: \"serial_sdAlwaysAvailable\",\n            feature_swallowOkAfterResend: \"serial_swallowOkAfterResend\",\n            feature_repetierTargetTemp: \"serial_repetierTargetTemp\",\n            feature_disableExternalHeatupDetection:\n                \"serial_disableExternalHeatupDetection\",\n            feature_ignoreIdenticalResends: \"serial_ignoreIdenticalResends\",\n            feature_firmwareDetection: \"serial_firmwareDetection\",\n            feature_blockWhileDwelling: \"serial_blockWhileDwelling\",\n            serial_: \"feature_\"\n        };\n        _.each(self.observableCopies, function (value, key) {\n            if (self.hasOwnProperty(value)) {\n                self[key] = self[value];\n            }\n        });\n\n        self.addTemperatureProfile = function () {\n            self.temperature_profiles.push({\n                name: \"New\",\n                extruder: 0,\n                bed: 0,\n                chamber: 0\n            });\n        };\n\n        self.removeTemperatureProfile = function (profile) {\n            self.temperature_profiles.remove(profile);\n        };\n\n        self.addTerminalFilter = function () {\n            self.terminalFilters.push({\n                name: \"New\",\n                regex: \"(Send:\\\\s+(N\\\\d+\\\\s+)?M105)|(Recv:\\\\s+(ok\\\\s+([PBN]\\\\d+\\\\s+)*)?.*([BCLPR]|T\\\\d*):-?\\\\d+)\"\n            });\n        };\n\n        self.removeTerminalFilter = function (filter) {\n            self.terminalFilters.remove(filter);\n        };\n\n        self.testWebcamStreamUrlBusy = ko.observable(false);\n        self.testWebcamStreamUrl = function () {\n            if (!self.webcam_streamUrl()) {\n                return;\n            }\n\n            if (self.testWebcamStreamUrlBusy()) {\n                return;\n            }\n\n            var text = gettext(\n                \"If you see your webcam stream below, the entered stream URL is ok.\"\n            );\n\n            var streamType;\n            try {\n                streamType = self.webcam_streamType();\n            } catch (e) {\n                streamType = \"\";\n            }\n\n            var webcam_element;\n            var webrtc_peer_connection;\n            if (streamType === \"mjpg\") {\n                webcam_element = $('<img src=\"' + self.webcam_streamUrl() + '\">');\n            } else if (streamType === \"hls\") {\n                webcam_element = $(\n                    '<video id=\"webcam_hls\" muted autoplay style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n                if (video_element.canPlayType(\"application/vnd.apple.mpegurl\")) {\n                    video_element.src = self.webcam_streamUrl();\n                } else if (Hls.isSupported()) {\n                    var hls = new Hls();\n                    hls.loadSource(self.webcam_streamUrl());\n                    hls.attachMedia(video_element);\n                }\n            } else if (isWebRTCAvailable() && streamType === \"webrtc\") {\n                webcam_element = $(\n                    '<video id=\"webcam_webrtc\" muted autoplay playsinline controls style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n\n                webrtc_peer_connection = startWebRTC(\n                    video_element,\n                    self.webcam_streamUrl(),\n                    self.webcam_streamWebrtcIceServers()\n                );\n            } else {\n                throw \"Unknown stream type \" + streamType;\n            }\n\n            var message = $(\"<div id='webcamTestContainer'></div>\")\n                .append($(\"<p></p>\"))\n                .append(text)\n                .append(webcam_element);\n\n            self.testWebcamStreamUrlBusy(true);\n            showMessageDialog({\n                title: gettext(\"Stream test\"),\n                message: message,\n                onclose: function () {\n                    self.testWebcamStreamUrlBusy(false);\n                    if (webrtc_peer_connection != null) {\n                        webrtc_peer_connection.close();\n                        webrtc_peer_connection = null;\n                    }\n                }\n            });\n        };\n\n        self.testWebcamSnapshotUrlBusy = ko.observable(false);\n        self.testWebcamSnapshotUrl = function (viewModel, event) {\n            if (!self.webcam_snapshotUrl()) {\n                return;\n            }\n\n            if (self.testWebcamSnapshotUrlBusy()) {\n                return;\n            }\n\n            var errorText = gettext(\n                \"Could not retrieve snapshot URL, please double check the URL\"\n            );\n            var errorTitle = gettext(\"Snapshot test failed\");\n\n            self.testWebcamSnapshotUrlBusy(true);\n            OctoPrint.util\n                .testUrl(self.webcam_snapshotUrl(), {\n                    method: \"GET\",\n                    response: \"bytes\",\n                    timeout: self.webcam_snapshotTimeout(),\n                    validSsl: self.webcam_snapshotSslValidation(),\n                    content_type_whitelist: [\"image/*\"],\n                    content_type_guess: true\n                })\n                .done(function (response) {\n                    if (!response.result) {\n                        if (\n                            response.status &&\n                            response.response &&\n                            response.response.content_type\n                        ) {\n                            // we could contact the server, but something else was wrong, probably the mime type\n                            errorText = gettext(\n                                \"Could retrieve the snapshot URL, but it didn't look like an \" +\n                                    \"image. Got this as a content type header: <code>%(content_type)s</code>. Please \" +\n                                    \"double check that the URL is returning static images, not multipart data \" +\n                                    \"or videos.\"\n                            );\n                            errorText = _.sprintf(errorText, {\n                                content_type: _.escape(response.response.content_type)\n                            });\n                        }\n\n                        showMessageDialog({\n                            title: errorTitle,\n                            message: errorText,\n                            onclose: function () {\n                                self.testWebcamSnapshotUrlBusy(false);\n                            }\n                        });\n                        return;\n                    }\n\n                    var content = response.response.content;\n                    var contentType = response.response.assumed_content_type;\n\n                    var mimeType = \"image/jpeg\";\n                    if (contentType) {\n                        mimeType = contentType.split(\";\")[0];\n                    }\n\n                    var text = gettext(\n                        \"If you see your webcam snapshot picture below, the entered snapshot URL is ok.\"\n                    );\n                    showMessageDialog({\n                        title: gettext(\"Snapshot test\"),\n                        message: $(\n                            \"<p>\" +\n                                text +\n                                '</p><p><img src=\"data:' +\n                                mimeType +\n                                \";base64,\" +\n                                content +\n                                '\" style=\"border: 1px solid black\" /></p>'\n                        ),\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                })\n                .fail(function () {\n                    showMessageDialog({\n                        title: errorTitle,\n                        message: errorText,\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                });\n        };\n\n        self.testWebcamFfmpegPathBusy = ko.observable(false);\n        self.testWebcamFfmpegPath = function () {\n            if (!self.webcam_ffmpegPath()) {\n                return;\n            }\n\n            if (self.testWebcamFfmpegPathBusy()) {\n                return;\n            }\n\n            self.testWebcamFfmpegPathBusy(true);\n            OctoPrint.util\n                .testExecutable(self.webcam_ffmpegPath())\n                .done(function (response) {\n                    if (!response.result) {\n                        if (!response.exists) {\n                            self.webcam_ffmpegPathText(gettext(\"The path doesn't exist\"));\n                        } else if (!response.typeok) {\n                            self.webcam_ffmpegPathText(gettext(\"The path is not a file\"));\n                        } else if (!response.access) {\n                            self.webcam_ffmpegPathText(\n                                gettext(\"The path is not an executable\")\n                            );\n                        }\n                    } else {\n                        self.webcam_ffmpegPathText(gettext(\"The path is valid\"));\n                    }\n                    self.webcam_ffmpegPathOk(response.result);\n                    self.webcam_ffmpegPathBroken(!response.result);\n                })\n                .always(function () {\n                    self.testWebcamFfmpegPathBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityConfig = function () {\n            if (!self.server_onlineCheck_host()) return;\n            if (!self.server_onlineCheck_port()) return;\n            if (self.testOnlineConnectivityConfigBusy()) return;\n\n            self.testOnlineConnectivityConfigBusy(true);\n            OctoPrint.util\n                .testServer(\n                    self.server_onlineCheck_host(),\n                    self.server_onlineCheck_port()\n                )\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckText(\n                            gettext(\"The server is not reachable\")\n                        );\n                    } else {\n                        self.server_onlineCheckText(gettext(\"The server is reachable\"));\n                    }\n                    self.server_onlineCheckOk(response.result);\n                    self.server_onlineCheckBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityConfigBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityResolutionConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityResolutionConfig = function () {\n            if (!self.server_onlineCheck_name()) return;\n            if (self.testOnlineConnectivityResolutionConfigBusy()) return;\n\n            self.testOnlineConnectivityResolutionConfigBusy(true);\n            OctoPrint.util\n                .testResolution(self.server_onlineCheck_name())\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name cannot be resolved\")\n                        );\n                    } else {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name can be resolved\")\n                        );\n                    }\n                    self.server_onlineCheckResolutionOk(response.result);\n                    self.server_onlineCheckResolutionBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityResolutionConfigBusy(false);\n                });\n        };\n\n        self.testFolderConfigBusy = ko.observable(false);\n        self.testFolderConfig = function (folder) {\n            var observable = \"folder_\" + folder;\n            if (!self.hasOwnProperty(observable)) return;\n\n            if (self.testFolderConfigBusy()) return;\n            self.testFolderConfigBusy(true);\n\n            var opts = {\n                check_type: \"dir\",\n                check_access: \"w\",\n                allow_create_dir: true,\n                check_writable_dir: true\n            };\n            var path = self[observable]();\n            OctoPrint.util\n                .testPath(path, opts)\n                .done(function (response) {\n                    if (!response.result) {\n                        if (response.broken_symlink) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is a broken symlink.\")\n                            );\n                        } else if (!response.exists) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path does not exist and cannot be created.\")\n                            );\n                        } else if (!response.typeok) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not a folder.\")\n                            );\n                        } else if (!response.access) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not writable.\")\n                            );\n                        }\n                    } else {\n                        self.testFolderConfigText[folder](gettext(\"The path is valid\"));\n                    }\n                    self.testFolderConfigOk[folder](response.result);\n                    self.testFolderConfigBroken[folder](!response.result);\n                })\n                .always(function () {\n                    self.testFolderConfigBusy(false);\n                });\n        };\n\n        self.onSettingsHidden = function () {\n            self.webcam_ffmpegPathReset();\n            self.server_onlineCheckReset();\n            self.server_onlineCheckResolutionReset();\n            self.testFolderConfigReset();\n        };\n\n        self.isDialogActive = function () {\n            return self.settingsDialog.is(\":visible\");\n        };\n\n        self.onStartup = function () {\n            self.settingsDialog = $(\"#settings_dialog\");\n            self.settingsUpdatedDialog = $(\"#settings_dialog_update_detected\");\n            self.translationManagerDialog = $(\n                \"#settings_appearance_managelanguagesdialog\"\n            );\n            self.translationUploadElement = $(\n                \"#settings_appearance_managelanguagesdialog_upload\"\n            );\n            self.translationUploadButton = $(\n                \"#settings_appearance_managelanguagesdialog_upload_start\"\n            );\n\n            self.translationUploadElement.fileupload({\n                dataType: \"json\",\n                maxNumberOfFiles: 1,\n                autoUpload: false,\n                headers: OctoPrint.getRequestHeaders(),\n                add: function (e, data) {\n                    if (data.files.length == 0) {\n                        return false;\n                    }\n\n                    self.translationUploadFilename(data.files[0].name);\n\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadButton.bind(\"click\", function () {\n                        data.submit();\n                        return false;\n                    });\n                },\n                done: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                    self.fromTranslationResponse(data.result);\n                },\n                fail: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                }\n            });\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.allViewModels = allViewModels;\n\n            self.settingsDialog.on(\"show\", function (event) {\n                OctoPrint.coreui.settingsOpen = true;\n                if (event.target.id == \"settings_dialog\") {\n                    self.requestTranslationData();\n                    callViewModels(allViewModels, \"onSettingsShown\");\n                }\n            });\n            self.settingsDialog.on(\"hidden\", function (event) {\n                OctoPrint.coreui.settingsOpen = false;\n                if (event.target.id == \"settings_dialog\") {\n                    callViewModels(allViewModels, \"onSettingsHidden\");\n                }\n            });\n            self.settingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onSettingsBeforeSave\");\n            });\n\n            $(\".reload_all\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData();\n                return false;\n            });\n            $(\".reload_nonconflicts\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData(true);\n                return false;\n            });\n\n            // reset scroll position on tab change\n            $('ul.nav-list a[data-toggle=\"tab\"]', self.settingsDialog).on(\n                \"show\",\n                function () {\n                    self._resetScrollPosition();\n                }\n            );\n        };\n\n        self.show = function (tab) {\n            // select first or specified tab\n            self.selectTab(tab);\n\n            // reset scroll position\n            self._resetScrollPosition();\n\n            // show settings, ensure centered position\n            self.settingsDialog\n                .modal({\n                    minHeight: function () {\n                        return Math.max($.fn.modal.defaults.maxHeight() - 80, 250);\n                    }\n                })\n                .css({\n                    \"margin-left\": function () {\n                        return -($(this).width() / 2);\n                    }\n                });\n\n            return false;\n        };\n\n        self.hide = function () {\n            self.settingsDialog.modal(\"hide\");\n        };\n\n        self.generateApiKey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                ),\n                function () {\n                    OctoPrint.settings.generateApiKey().done(function (response) {\n                        self.api_key(response.apikey);\n                        self.requestData();\n                    });\n                }\n            );\n        };\n\n        self.copyApiKey = function () {\n            copyToClipboard(self.api_key());\n        };\n\n        self.showTranslationManager = function () {\n            self.translationManagerDialog.modal();\n            return false;\n        };\n\n        self.requestData = function (local) {\n            // handle old parameter format\n            var callback = undefined;\n            if (arguments.length === 2 || _.isFunction(local)) {\n                var exc = new Error();\n                log.warn(\n                    \"The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:\",\n                    exc.stack || exc.stacktrace || \"<n/a>\"\n                );\n\n                if (arguments.length === 2) {\n                    callback = arguments[0];\n                    local = arguments[1];\n                } else {\n                    callback = local;\n                    local = false;\n                }\n            }\n\n            // handler for any explicitly provided callbacks\n            var callbackHandler = function () {\n                if (!callback) return;\n                try {\n                    callback();\n                } catch (exc) {\n                    log.error(\n                        \"Error calling settings callback\",\n                        callback,\n                        \":\",\n                        exc.stack || exc.stacktrace || exc\n                    );\n                }\n            };\n\n            // if a request is already active, create a new deferred and return\n            // its promise, it will be resolved in the response handler of the\n            // current request\n            if (self.receiving()) {\n                var deferred = $.Deferred();\n                self.outstanding.push(deferred);\n\n                if (callback) {\n                    // if we have a callback, we need to make sure it will\n                    // get called when the deferred is resolved\n                    deferred.done(callbackHandler);\n                }\n\n                return deferred.promise();\n            }\n\n            // perform the request\n            self.receiving(true);\n            return OctoPrint.settings\n                .get()\n                .always(function () {\n                    self.receiving(false);\n                })\n                .done(function (response) {\n                    self.fromResponse(response, local);\n\n                    if (callback) {\n                        var deferred = $.Deferred();\n                        deferred.done(callbackHandler);\n                        self.outstanding.push(deferred);\n                    }\n\n                    // resolve all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.resolve(args);\n                    });\n                    self.outstanding = [];\n                })\n                .fail(function () {\n                    // reject all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.reject(args);\n                    });\n                    self.outstanding = [];\n                });\n        };\n\n        self.requestTranslationData = function () {\n            return OctoPrint.languages.list().done(self.fromTranslationResponse);\n        };\n\n        self.fromTranslationResponse = function (response) {\n            var translationsByLocale = {};\n            _.each(response.language_packs, function (item, key) {\n                _.each(item.languages, function (pack) {\n                    var locale = pack.locale;\n                    if (!_.has(translationsByLocale, locale)) {\n                        translationsByLocale[locale] = {\n                            locale: locale,\n                            display: pack.locale_display,\n                            english: pack.locale_english,\n                            packs: []\n                        };\n                    }\n\n                    translationsByLocale[locale][\"packs\"].push({\n                        identifier: key,\n                        display: item.display,\n                        pack: pack\n                    });\n                });\n            });\n\n            var translations = [];\n            _.each(translationsByLocale, function (item) {\n                item[\"packs\"].sort(function (a, b) {\n                    if (a.identifier == \"_core\") return -1;\n                    if (b.identifier == \"_core\") return 1;\n\n                    if (a.display < b.display) return -1;\n                    if (a.display > b.display) return 1;\n                    return 0;\n                });\n                translations.push(item);\n            });\n\n            self.translations.updateItems(translations);\n        };\n\n        self.languagePackDisplay = function (item) {\n            return (\n                item.display +\n                (item.english != undefined ? \" (\" + item.english + \")\" : \"\")\n            );\n        };\n\n        self.languagePacksAvailable = ko.pureComputed(function () {\n            return self.translations.allSize() > 0;\n        });\n\n        self.deleteLanguagePack = function (locale, pack) {\n            OctoPrint.languages.delete(locale, pack).done(self.fromTranslationResponse);\n        };\n\n        /**\n         * Fetches the settings as currently stored in this client instance.\n         */\n        self.getLocalData = function () {\n            var data = {};\n            if (self.settings != undefined) {\n                data = ko.mapping.toJS(self.settings);\n            }\n\n            // some special read functions for various observables\n            var specialMappings = {\n                feature: {\n                    autoUppercaseBlacklist: function () {\n                        return splitTextToArray(\n                            self.feature_autoUppercaseBlacklist(),\n                            \",\",\n                            true\n                        );\n                    }\n                },\n                serial: {\n                    additionalPorts: function () {\n                        return commentableLinesToArray(self.serial_additionalPorts());\n                    },\n                    additionalBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_additionalBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    blacklistedPorts: function () {\n                        return commentableLinesToArray(self.serial_blacklistedPorts());\n                    },\n                    blacklistedBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_blacklistedBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    longRunningCommands: function () {\n                        return splitTextToArray(\n                            self.serial_longRunningCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    checksumRequiringCommands: function () {\n                        return splitTextToArray(\n                            self.serial_checksumRequiringCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    blockedCommands: function () {\n                        return splitTextToArray(self.serial_blockedCommands(), \",\", true);\n                    },\n                    ignoredCommands: function () {\n                        return splitTextToArray(self.serial_ignoredCommands(), \",\", true);\n                    },\n                    pausingCommands: function () {\n                        return splitTextToArray(self.serial_pausingCommands(), \",\", true);\n                    },\n                    emergencyCommands: function () {\n                        return splitTextToArray(\n                            self.serial_emergencyCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    externalHeatupDetection: function () {\n                        return !self.serial_disableExternalHeatupDetection();\n                    },\n                    alwaysSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"always\";\n                    },\n                    neverSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"never\";\n                    },\n                    ignoreErrorsFromFirmware: function () {\n                        return self.serial_serialErrorBehaviour() === \"ignore\";\n                    },\n                    disconnectOnErrors: function () {\n                        return self.serial_serialErrorBehaviour() === \"disconnect\";\n                    }\n                },\n                scripts: {\n                    gcode: function () {\n                        // we have a special handler function for the gcode scripts since the\n                        // server will always send us those that have been set already, so we\n                        // can't depend on all keys that we support to be present in the\n                        // original request we iterate through in mapFromObservables to\n                        // generate our response - hence we use our observables instead\n                        //\n                        // Note: If we ever introduce sub categories in the gcode scripts\n                        // here (more _ after the prefix), we'll need to adjust this code\n                        // to be able to cope with that, right now it only strips the prefix\n                        // and uses the rest as key in the result, no recursive translation\n                        // is done!\n                        var result = {};\n                        var prefix = \"scripts_gcode_\";\n                        var observables = _.filter(_.keys(self), function (key) {\n                            return _.startsWith(key, prefix);\n                        });\n                        _.each(observables, function (observable) {\n                            var script = observable.substring(prefix.length);\n                            result[script] = self[observable]();\n                        });\n                        return result;\n                    }\n                },\n                temperature: {\n                    profiles: function () {\n                        var result = [];\n                        _.each(self.temperature_profiles(), function (profile) {\n                            try {\n                                result.push({\n                                    name: profile.name,\n                                    extruder: Math.floor(\n                                        _.isNumber(profile.extruder)\n                                            ? profile.extruder\n                                            : parseInt(profile.extruder)\n                                    ),\n                                    bed: Math.floor(\n                                        _.isNumber(profile.bed)\n                                            ? profile.bed\n                                            : parseInt(profile.bed)\n                                    ),\n                                    chamber: Math.floor(\n                                        _.isNumber(profile.chamber)\n                                            ? profile.chamber\n                                            : _.isNumber(parseInt(profile.chamber))\n                                            ? parseInt(profile.chamber)\n                                            : 0\n                                    )\n                                });\n                            } catch (ex) {\n                                // ignore\n                            }\n                        });\n                        return result;\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function () {\n                        return splitTextToArray(\n                            self.webcam_streamWebrtcIceServers(),\n                            \",\",\n                            true\n                        );\n                    }\n                }\n            };\n\n            var mapFromObservables = function (data, mapping, keyPrefix) {\n                var flag = false;\n                var result = {};\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix !== undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\n                        result[key] = mapping[key]();\n                        flag = true;\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        var subresult = mapFromObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            observable\n                        );\n                        if (subresult !== undefined) {\n                            // we only set something on our result if we got something back\n                            result[key] = subresult;\n                            flag = true;\n                        }\n                    } else if (self.hasOwnProperty(observable)) {\n                        result[key] = self[observable]();\n                        flag = true;\n                    }\n                });\n\n                // if we set something on our result (flag is true), we return result, else we return undefined\n                return flag ? result : undefined;\n            };\n\n            // map local observables based on our existing data\n            var dataFromObservables = mapFromObservables(data, specialMappings);\n\n            data = deepMerge(data, dataFromObservables);\n            return data;\n        };\n\n        self.fromResponse = function (response, local) {\n            // server side changes to set\n            var serverChangedData;\n\n            // client side changes to keep\n            var clientChangedData;\n\n            if (local) {\n                // local is true, so we'll keep all local changes and only update what's been updated server side\n                serverChangedData = getOnlyChangedData(\n                    response,\n                    self.lastReceivedSettings\n                );\n                clientChangedData = getOnlyChangedData(\n                    self.getLocalData(),\n                    self.lastReceivedSettings\n                );\n            } else {\n                // local is false or unset, so we'll forcefully update with the settings from the server\n                serverChangedData = response;\n                clientChangedData = undefined;\n            }\n\n            // last received settings reset to response\n            self.lastReceivedSettings = response;\n\n            if (self.settings === undefined) {\n                self.settings = ko.mapping.fromJS(serverChangedData);\n            } else {\n                ko.mapping.fromJS(serverChangedData, self.settings);\n            }\n\n            // some special apply functions for various observables\n            var specialMappings = {\n                appearance: {\n                    defaultLanguage: function (value) {\n                        self.appearance_defaultLanguage(\"_default\");\n                        if (_.includes(self.locale_languages, value)) {\n                            self.appearance_defaultLanguage(value);\n                        }\n                    }\n                },\n                feature: {\n                    autoUppercaseBlacklist: function (value) {\n                        self.feature_autoUppercaseBlacklist(value.join(\", \"));\n                    }\n                },\n                serial: {\n                    additionalPorts: function (value) {\n                        self.serial_additionalPorts(value.join(\"\\n\"));\n                    },\n                    additionalBaudrates: function (value) {\n                        self.serial_additionalBaudrates(value.join(\", \"));\n                    },\n                    blacklistedPorts: function (value) {\n                        self.serial_blacklistedPorts(value.join(\"\\n\"));\n                    },\n                    blacklistedBaudrates: function (value) {\n                        self.serial_blacklistedBaudrates(value.join(\", \"));\n                    },\n                    longRunningCommands: function (value) {\n                        self.serial_longRunningCommands(value.join(\", \"));\n                    },\n                    checksumRequiringCommands: function (value) {\n                        self.serial_checksumRequiringCommands(value.join(\", \"));\n                    },\n                    blockedCommands: function (value) {\n                        self.serial_blockedCommands(value.join(\", \"));\n                    },\n                    ignoredCommands: function (value) {\n                        self.serial_ignoredCommands(value.join(\", \"));\n                    },\n                    pausingCommands: function (value) {\n                        self.serial_pausingCommands(value.join(\", \"));\n                    },\n                    emergencyCommands: function (value) {\n                        self.serial_emergencyCommands(value.join(\", \"));\n                    },\n                    externalHeatupDetection: function (value) {\n                        self.serial_disableExternalHeatupDetection(!value);\n                    },\n                    alwaysSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"always\");\n                        }\n                    },\n                    neverSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"never\");\n                        }\n                    },\n                    ignoreErrorsFromFirmware: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"ignore\");\n                        }\n                    },\n                    disconnectOnErrors: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"disconnect\");\n                        }\n                    }\n                },\n                terminalFilters: function (value) {\n                    self.terminalFilters($.extend(true, [], value));\n                },\n                temperature: {\n                    profiles: function (value) {\n                        self.temperature_profiles($.extend(true, [], value));\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function (value) {\n                        self.webcam_streamWebrtcIceServers(value.join(\", \"));\n                    }\n                }\n            };\n\n            var mapToObservables = function (data, mapping, local, keyPrefix) {\n                if (!_.isPlainObject(data)) {\n                    return;\n                }\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix != undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    var haveLocalVersion = local && local.hasOwnProperty(key);\n\n                    if (\n                        mapping &&\n                        mapping[key] &&\n                        _.isFunction(mapping[key]) &&\n                        !haveLocalVersion\n                    ) {\n                        // if we have a custom apply function for this, we'll use it\n                        mapping[key](value);\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        mapToObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            local && local[key] ? local[key] : undefined,\n                            observable\n                        );\n                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\n                        // if we have a matching observable, we'll use that\n                        self[observable](value);\n                    }\n                });\n            };\n\n            mapToObservables(serverChangedData, specialMappings, clientChangedData);\n\n            firstRequest.resolve();\n        };\n\n        self.cancelData = function () {\n            // revert unsaved changes\n            self.fromResponse(self.lastReceivedSettings);\n\n            self.hide();\n        };\n\n        self.saveData = function (data, successCallback, setAsSending) {\n            var options;\n            if (_.isPlainObject(successCallback)) {\n                options = successCallback;\n            } else {\n                options = {\n                    success: successCallback,\n                    sending: setAsSending === true\n                };\n            }\n\n            self.settingsDialog.trigger(\"beforeSave\");\n\n            self.sawUpdateEventWhileSending = false;\n            self.sending(data === undefined || options.sending || false);\n\n            if (data === undefined) {\n                // we also only send data that actually changed when no data is specified\n                var localData = self.getLocalData();\n                data = getOnlyChangedData(localData, self.lastReceivedSettings);\n            }\n\n            // final validation\n            if (self.testFoldersDuplicate()) {\n                // duplicate folders configured, we refuse to send any folder config\n                // to the server\n                delete data.folder;\n            }\n\n            self.active = true;\n            return OctoPrint.settings\n                .save(data)\n                .done(function (data, status, xhr) {\n                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\n                    self.active = false;\n\n                    self.receiving(true);\n                    self.sending(false);\n\n                    try {\n                        self.fromResponse(data);\n                        if (options.success) options.success(data, status, xhr);\n                    } finally {\n                        self.receiving(false);\n                    }\n                })\n                .fail(function (xhr, status, error) {\n                    self.sending(false);\n                    self.active = false;\n                    if (options.error) options.error(xhr, status, error);\n                })\n                .always(function (xhr, status) {\n                    if (options.complete) options.complete(xhr, status);\n                });\n        };\n\n        self.onEventSettingsUpdated = function () {\n            if (self.active) {\n                self.sawUpdateEventWhileActive = true;\n            }\n\n            var preventSettingsRefresh = _.any(self.allViewModels, function (viewModel) {\n                if (viewModel.hasOwnProperty(\"onSettingsPreventRefresh\")) {\n                    try {\n                        return viewModel[\"onSettingsPreventRefresh\"]();\n                    } catch (e) {\n                        log.warn(\n                            \"Error while calling onSettingsPreventRefresh on\",\n                            viewModel,\n                            \":\",\n                            e\n                        );\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            });\n\n            if (preventSettingsRefresh) {\n                // if any of our viewmodels prevented this refresh, we'll just return now\n                return;\n            }\n\n            if (self.isDialogActive()) {\n                // dialog is open and not currently busy...\n                if (\n                    self.sending() ||\n                    self.receiving() ||\n                    self.active ||\n                    self.ignoreNextUpdateEvent\n                ) {\n                    self.ignoreNextUpdateEvent = false;\n                    return;\n                }\n\n                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\n                    // we don't have local changes, so just fetch new data\n                    self.requestData();\n                } else {\n                    // we have local changes, show update dialog\n                    self.settingsUpdatedDialog.modal(\"show\");\n                }\n            } else {\n                // dialog is not open, just fetch new data\n                self.requestData();\n            }\n        };\n\n        self._resetScrollPosition = function () {\n            $(\"#settings_dialog_content\", self.settingsDialog).scrollTop(0);\n\n            // also reset any contained tabs/pills/lists to first pane\n            $(\n                '#settings_dialog_content ul.nav-pills a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-list a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-tabs a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n        };\n\n        self.selectTab = function (tab) {\n            if (tab != undefined) {\n                if (!_.startsWith(tab, \"#\")) {\n                    tab = \"#\" + tab;\n                }\n                $('ul.nav-list a[href=\"' + tab + '\"]', self.settingsDialog).tab(\"show\");\n            } else {\n                $('ul.nav-list a[data-toggle=\"tab\"]:first', self.settingsDialog).tab(\n                    \"show\"\n                );\n            }\n        };\n\n        self.onServerReconnect = function () {\n            // the settings might have changed if the server was just restarted,\n            // better refresh them now\n            self.requestData();\n        };\n\n        self.onUserPermissionsChanged =\n            self.onUserLoggedIn =\n            self.onUserLoggedOut =\n                function () {\n                    // we might have other user rights now, refresh (but only if startup has fully completed)\n                    if (!self._startupComplete) return;\n                    self.requestData();\n                };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: SettingsViewModel,\n        dependencies: [\n            \"loginStateViewModel\",\n            \"accessViewModel\",\n            \"printerProfilesViewModel\",\n            \"aboutViewModel\",\n            \"usersViewModel\"\n        ],\n        elements: [\"#settings_dialog\", \"#navbar_settings\"]\n    });\n});\n", "code_before": "$(function () {\n    function SettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n        self.printerProfiles = parameters[2];\n        self.about = parameters[3];\n\n        // TODO: remove in upcoming version, this is only for backwards compatibility\n        self.users = parameters[4];\n\n        // use this promise to do certain things once the SettingsViewModel has processed\n        // its first request\n        var firstRequest = $.Deferred();\n        self.firstRequest = firstRequest.promise();\n\n        self.allViewModels = [];\n\n        self.receiving = ko.observable(false);\n        self.sending = ko.observable(false);\n        self.exchanging = ko.pureComputed(function () {\n            return self.receiving() || self.sending();\n        });\n        self.outstanding = [];\n\n        self.active = false;\n        self.sawUpdateEventWhileActive = false;\n        self.ignoreNextUpdateEvent = false;\n\n        self.settingsDialog = undefined;\n        self.settings_dialog_update_detected = undefined;\n        self.translationManagerDialog = undefined;\n        self.translationUploadElement = $(\n            \"#settings_appearance_managelanguagesdialog_upload\"\n        );\n        self.translationUploadButton = $(\n            \"#settings_appearance_managelanguagesdialog_upload_start\"\n        );\n\n        self.translationUploadFilename = ko.observable();\n        self.invalidTranslationArchive = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                !(\n                    _.endsWith(name.toLocaleLowerCase(), \".zip\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar.gz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tgz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar\")\n                )\n            );\n        });\n        self.enableTranslationUpload = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                name.trim() != \"\" &&\n                !self.invalidTranslationArchive()\n            );\n        });\n\n        self.translations = new ItemListHelper(\n            \"settings.translations\",\n            {\n                locale: function (a, b) {\n                    // sorts ascending\n                    if (a[\"locale\"].toLocaleLowerCase() < b[\"locale\"].toLocaleLowerCase())\n                        return -1;\n                    if (a[\"locale\"].toLocaleLowerCase() > b[\"locale\"].toLocaleLowerCase())\n                        return 1;\n                    return 0;\n                }\n            },\n            {},\n            \"locale\",\n            [],\n            [],\n            0\n        );\n\n        self.appearance_available_colors = ko.observable([\n            {key: \"default\", name: gettext(\"default\")},\n            {key: \"red\", name: gettext(\"red\")},\n            {key: \"orange\", name: gettext(\"orange\")},\n            {key: \"yellow\", name: gettext(\"yellow\")},\n            {key: \"green\", name: gettext(\"green\")},\n            {key: \"blue\", name: gettext(\"blue\")},\n            {key: \"violet\", name: gettext(\"violet\")},\n            {key: \"black\", name: gettext(\"black\")},\n            {key: \"white\", name: gettext(\"white\")}\n        ]);\n\n        self.appearance_colorName = function (color) {\n            switch (color) {\n                case \"red\":\n                    return gettext(\"red\");\n                case \"orange\":\n                    return gettext(\"orange\");\n                case \"yellow\":\n                    return gettext(\"yellow\");\n                case \"green\":\n                    return gettext(\"green\");\n                case \"blue\":\n                    return gettext(\"blue\");\n                case \"violet\":\n                    return gettext(\"violet\");\n                case \"black\":\n                    return gettext(\"black\");\n                case \"white\":\n                    return gettext(\"white\");\n                case \"default\":\n                    return gettext(\"default\");\n                default:\n                    return color;\n            }\n        };\n\n        self.webcam_available_ratios = [\"16:9\", \"4:3\"];\n        self.webcam_available_videocodecs = [\"libx264\", \"mpeg2video\"];\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Autodetect from browser\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.api_key = ko.observable(undefined);\n        self.api_allowCrossOrigin = ko.observable(undefined);\n\n        self.appearance_name = ko.observable(undefined);\n        self.appearance_color = ko.observable(undefined);\n        self.appearance_colorTransparent = ko.observable();\n        self.appearance_colorIcon = ko.observable();\n        self.appearance_defaultLanguage = ko.observable();\n        self.appearance_showFahrenheitAlso = ko.observable(undefined);\n        self.appearance_fuzzyTimes = ko.observable(undefined);\n        self.appearance_closeModalsWithClick = ko.observable(undefined);\n        self.appearance_showInternalFilename = ko.observable(undefined);\n\n        self.printer_defaultExtrusionLength = ko.observable(undefined);\n\n        self.webcam_webcamEnabled = ko.observable(undefined);\n        self.webcam_timelapseEnabled = ko.observable(undefined);\n        self.webcam_streamUrl = ko.observable(undefined);\n        self.webcam_streamRatio = ko.observable(undefined);\n        self.webcam_streamTimeout = ko.observable(undefined);\n        self.webcam_streamWebrtcIceServers = ko.observable(undefined);\n        self.webcam_snapshotUrl = ko.observable(undefined);\n        self.webcam_snapshotTimeout = ko.observable(undefined);\n        self.webcam_snapshotSslValidation = ko.observable(undefined);\n        self.webcam_ffmpegPath = ko.observable(undefined);\n        self.webcam_ffmpegCommandline = ko.observable(undefined);\n        self.webcam_bitrate = ko.observable(undefined);\n        self.webcam_ffmpegThreads = ko.observable(undefined);\n        self.webcam_ffmpegVideoCodec = ko.observable(undefined);\n        self.webcam_watermark = ko.observable(undefined);\n        self.webcam_flipH = ko.observable(undefined);\n        self.webcam_flipV = ko.observable(undefined);\n        self.webcam_rotate90 = ko.observable(undefined);\n        self.webcam_cacheBuster = ko.observable(undefined);\n\n        self.feature_temperatureGraph = ko.observable(undefined);\n        self.feature_sdSupport = ko.observable(undefined);\n        self.feature_keyboardControl = ko.observable(undefined);\n        self.feature_pollWatched = ko.observable(undefined);\n        self.feature_modelSizeDetection = ko.observable(undefined);\n        self.feature_rememberFileFolder = ko.observable(undefined);\n        self.feature_printStartConfirmation = ko.observable(undefined);\n        self.feature_printCancelConfirmation = ko.observable(undefined);\n        self.feature_uploadOverwriteConfirmation = ko.observable(undefined);\n        self.feature_g90InfluencesExtruder = ko.observable(undefined);\n        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\n\n        self.gcodeAnalysis_runAt = ko.observable(undefined);\n\n        self.serial_port = ko.observable();\n        self.serial_baudrate = ko.observable();\n        self.serial_exclusive = ko.observable();\n        self.serial_lowLatency = ko.observable();\n        self.serial_portOptions = ko.observableArray([]);\n        self.serial_baudrateOptions = ko.observableArray([]);\n        self.serial_autoconnect = ko.observable(undefined);\n        self.serial_timeoutConnection = ko.observable(undefined);\n        self.serial_timeoutDetectionFirst = ko.observable(undefined);\n        self.serial_timeoutDetectionConsecutive = ko.observable(undefined);\n        self.serial_timeoutCommunication = ko.observable(undefined);\n        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\n        self.serial_timeoutTemperature = ko.observable(undefined);\n        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\n        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\n        self.serial_timeoutSdStatus = ko.observable(undefined);\n        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\n        self.serial_timeoutPosAutoreport = ko.observable(undefined);\n        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\n        self.serial_timeoutPositionLogWait = ko.observable(undefined);\n        self.serial_log = ko.observable(undefined);\n        self.serial_additionalPorts = ko.observable(undefined);\n        self.serial_additionalBaudrates = ko.observable(undefined);\n        self.serial_blacklistedPorts = ko.observable(undefined);\n        self.serial_blacklistedBaudrates = ko.observable(undefined);\n        self.serial_longRunningCommands = ko.observable(undefined);\n        self.serial_checksumRequiringCommands = ko.observable(undefined);\n        self.serial_blockedCommands = ko.observable(undefined);\n        self.serial_ignoredCommands = ko.observable(undefined);\n        self.serial_pausingCommands = ko.observable(undefined);\n        self.serial_sdCancelCommand = ko.observable(undefined);\n        self.serial_emergencyCommands = ko.observable(undefined);\n        self.serial_helloCommand = ko.observable(undefined);\n        self.serial_serialErrorBehaviour = ko.observable(\"cancel\");\n        self.serial_triggerOkForM29 = ko.observable(undefined);\n        self.serial_waitForStart = ko.observable(undefined);\n        self.serial_sendChecksum = ko.observable(\"print\");\n        self.serial_sendChecksumWithUnknownCommands = ko.observable(undefined);\n        self.serial_unknownCommandsNeedAck = ko.observable(undefined);\n        self.serial_sdRelativePath = ko.observable(undefined);\n        self.serial_sdLowerCase = ko.observable(undefined);\n        self.serial_sdAlwaysAvailable = ko.observable(undefined);\n        self.serial_swallowOkAfterResend = ko.observable(undefined);\n        self.serial_repetierTargetTemp = ko.observable(undefined);\n        self.serial_disableExternalHeatupDetection = ko.observable(undefined);\n        self.serial_ignoreIdenticalResends = ko.observable(undefined);\n        self.serial_firmwareDetection = ko.observable(undefined);\n        self.serial_blockWhileDwelling = ko.observable(undefined);\n        self.serial_useParityWorkaround = ko.observable(undefined);\n        self.serial_sanityCheckTools = ko.observable(undefined);\n        self.serial_supportResendsWithoutOk = ko.observable(undefined);\n        self.serial_logPositionOnPause = ko.observable(undefined);\n        self.serial_logPositionOnCancel = ko.observable(undefined);\n        self.serial_abortHeatupOnCancel = ko.observable(undefined);\n        self.serial_maxTimeoutsIdle = ko.observable(undefined);\n        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\n        self.serial_maxTimeoutsLong = ko.observable(undefined);\n        self.serial_capAutoreportTemp = ko.observable(undefined);\n        self.serial_capAutoreportSdStatus = ko.observable(undefined);\n        self.serial_capAutoreportPos = ko.observable(undefined);\n        self.serial_capBusyProtocol = ko.observable(undefined);\n        self.serial_capEmergencyParser = ko.observable(undefined);\n        self.serial_capExtendedM20 = ko.observable(undefined);\n        self.serial_sendM112OnError = ko.observable(undefined);\n        self.serial_disableSdPrintingDetection = ko.observable(undefined);\n        self.serial_ackMax = ko.observable(undefined);\n        self.serial_resendRatioThreshold = ko.observable(100);\n        self.serial_resendRatioStart = ko.observable(100);\n        self.serial_ignoreEmptyPorts = ko.observable(undefined);\n        self.serial_enableShutdownActionCommand = ko.observable(undefined);\n\n        self.folder_uploads = ko.observable(undefined);\n        self.folder_timelapse = ko.observable(undefined);\n        self.folder_timelapseTmp = ko.observable(undefined);\n        self.folder_logs = ko.observable(undefined);\n        self.folder_watched = ko.observable(undefined);\n\n        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\n        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\n        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\n        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\n        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\n        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\n        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\n        self.scripts_gcode_afterToolChange = ko.observable(undefined);\n        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\n\n        self.temperature_profiles = ko.observableArray(undefined);\n        self.temperature_cutoff = ko.observable(undefined);\n        self.temperature_sendAutomatically = ko.observable(undefined);\n        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\n\n        self.system_actions = ko.observableArray([]);\n\n        self.terminalFilters = ko.observableArray([]);\n\n        self.server_commands_systemShutdownCommand = ko.observable(undefined);\n        self.server_commands_systemRestartCommand = ko.observable(undefined);\n        self.server_commands_serverRestartCommand = ko.observable(undefined);\n\n        self.server_diskspace_warning = ko.observable();\n        self.server_diskspace_critical = ko.observable();\n        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\n        self.server_diskspace_critical_str = sizeObservable(\n            self.server_diskspace_critical\n        );\n\n        self.server_onlineCheck_enabled = ko.observable();\n        self.server_onlineCheck_interval = ko.observable();\n        self.server_onlineCheck_host = ko.observable();\n        self.server_onlineCheck_port = ko.observable();\n        self.server_onlineCheck_name = ko.observable();\n\n        self.server_pluginBlacklist_enabled = ko.observable();\n        self.server_pluginBlacklist_url = ko.observable();\n        self.server_pluginBlacklist_ttl = ko.observable();\n\n        self.server_allowFraming = ko.observable();\n\n        self.settings = undefined;\n        self.lastReceivedSettings = undefined;\n\n        self.webcam_ffmpegPathText = ko.observable();\n        self.webcam_ffmpegPathOk = ko.observable(false);\n        self.webcam_ffmpegPathBroken = ko.observable(false);\n        self.webcam_ffmpegPathReset = function () {\n            self.webcam_ffmpegPathText(\"\");\n            self.webcam_ffmpegPathOk(false);\n            self.webcam_ffmpegPathBroken(false);\n        };\n        self.webcam_streamType = ko.pureComputed(function () {\n            try {\n                return determineWebcamStreamType(self.webcam_streamUrl());\n            } catch (e) {\n                return \"\";\n            }\n        });\n\n        self.server_onlineCheckText = ko.observable();\n        self.server_onlineCheckOk = ko.observable(false);\n        self.server_onlineCheckBroken = ko.observable(false);\n        self.server_onlineCheckReset = function () {\n            self.server_onlineCheckText(\"\");\n            self.server_onlineCheckOk(false);\n            self.server_onlineCheckBroken(false);\n        };\n        self.server_onlineCheckResolutionText = ko.observable();\n        self.server_onlineCheckResolutionOk = ko.observable(false);\n        self.server_onlineCheckResolutionBroken = ko.observable(false);\n        self.server_onlineCheckResolutionReset = function () {\n            self.server_onlineCheckResolutionText(\"\");\n            self.server_onlineCheckResolutionOk(false);\n            self.server_onlineCheckResolutionBroken(false);\n        };\n\n        var folderTypes = [\"uploads\", \"timelapse\", \"timelapseTmp\", \"logs\", \"watched\"];\n\n        var checkForDuplicateFolders = function () {\n            _.each(folderTypes, function (folderType) {\n                var path = self[\"folder_\" + folderType]();\n                var duplicate = false;\n                _.each(folderTypes, function (otherFolderType) {\n                    if (folderType !== otherFolderType) {\n                        duplicate =\n                            duplicate || path === self[\"folder_\" + otherFolderType]();\n                    }\n                });\n                self.testFolderConfigDuplicate[folderType](duplicate);\n            });\n        };\n\n        self.testFolderConfigText = {};\n        self.testFolderConfigOk = {};\n        self.testFolderConfigBroken = {};\n        self.testFolderConfigDuplicate = {};\n        self.testFolderConfigError = {};\n        self.testFolderConfigSuccess = {};\n        _.each(folderTypes, function (folderType) {\n            self.testFolderConfigText[folderType] = ko.observable(\"\");\n            self.testFolderConfigOk[folderType] = ko.observable(false);\n            self.testFolderConfigBroken[folderType] = ko.observable(false);\n            self.testFolderConfigDuplicate[folderType] = ko.observable(false);\n            self.testFolderConfigError[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigBroken[folderType]() ||\n                    self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self.testFolderConfigSuccess[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigOk[folderType]() &&\n                    !self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self[\"folder_\" + folderType].subscribe(checkForDuplicateFolders);\n        });\n        self.testFolderConfigReset = function () {\n            _.each(folderTypes, function (folderType) {\n                self.testFolderConfigText[folderType](\"\");\n                self.testFolderConfigOk[folderType](false);\n                self.testFolderConfigBroken[folderType](false);\n            });\n        };\n        self.testFoldersDuplicate = ko.pureComputed(function () {\n            var foundDupe = false;\n            _.each(folderTypes, function (folderType) {\n                foundDupe = foundDupe || self.testFolderConfigDuplicate[folderType]();\n            });\n            return foundDupe;\n        });\n\n        self.observableCopies = {\n            feature_waitForStart: \"serial_waitForStart\",\n            feature_sendChecksum: \"serial_sendChecksum\",\n            feature_sdRelativePath: \"serial_sdRelativePath\",\n            feature_sdAlwaysAvailable: \"serial_sdAlwaysAvailable\",\n            feature_swallowOkAfterResend: \"serial_swallowOkAfterResend\",\n            feature_repetierTargetTemp: \"serial_repetierTargetTemp\",\n            feature_disableExternalHeatupDetection:\n                \"serial_disableExternalHeatupDetection\",\n            feature_ignoreIdenticalResends: \"serial_ignoreIdenticalResends\",\n            feature_firmwareDetection: \"serial_firmwareDetection\",\n            feature_blockWhileDwelling: \"serial_blockWhileDwelling\",\n            serial_: \"feature_\"\n        };\n        _.each(self.observableCopies, function (value, key) {\n            if (self.hasOwnProperty(value)) {\n                self[key] = self[value];\n            }\n        });\n\n        self.addTemperatureProfile = function () {\n            self.temperature_profiles.push({\n                name: \"New\",\n                extruder: 0,\n                bed: 0,\n                chamber: 0\n            });\n        };\n\n        self.removeTemperatureProfile = function (profile) {\n            self.temperature_profiles.remove(profile);\n        };\n\n        self.addTerminalFilter = function () {\n            self.terminalFilters.push({\n                name: \"New\",\n                regex: \"(Send:\\\\s+(N\\\\d+\\\\s+)?M105)|(Recv:\\\\s+(ok\\\\s+([PBN]\\\\d+\\\\s+)*)?.*([BCLPR]|T\\\\d*):-?\\\\d+)\"\n            });\n        };\n\n        self.removeTerminalFilter = function (filter) {\n            self.terminalFilters.remove(filter);\n        };\n\n        self.testWebcamStreamUrlBusy = ko.observable(false);\n        self.testWebcamStreamUrl = function () {\n            if (!self.webcam_streamUrl()) {\n                return;\n            }\n\n            if (self.testWebcamStreamUrlBusy()) {\n                return;\n            }\n\n            var text = gettext(\n                \"If you see your webcam stream below, the entered stream URL is ok.\"\n            );\n            var streamType = self.webcam_streamType();\n            var webcam_element;\n            var webrtc_peer_connection;\n            if (streamType == \"mjpg\") {\n                webcam_element = $('<img src=\"' + self.webcam_streamUrl() + '\">');\n            } else if (streamType == \"hls\") {\n                webcam_element = $(\n                    '<video id=\"webcam_hls\" muted autoplay style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n                if (video_element.canPlayType(\"application/vnd.apple.mpegurl\")) {\n                    video_element.src = self.webcam_streamUrl();\n                } else if (Hls.isSupported()) {\n                    var hls = new Hls();\n                    hls.loadSource(self.webcam_streamUrl());\n                    hls.attachMedia(video_element);\n                }\n            } else if (isWebRTCAvailable() && streamType == \"webrtc\") {\n                webcam_element = $(\n                    '<video id=\"webcam_webrtc\" muted autoplay playsinline controls style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n\n                webrtc_peer_connection = startWebRTC(\n                    video_element,\n                    self.webcam_streamUrl(),\n                    self.webcam_streamWebrtcIceServers()\n                );\n            } else {\n                throw \"Unknown stream type \" + streamType;\n            }\n\n            var message = $(\"<div id='webcamTestContainer'></div>\")\n                .append($(\"<p></p>\"))\n                .append(text)\n                .append(webcam_element);\n\n            self.testWebcamStreamUrlBusy(true);\n            showMessageDialog({\n                title: gettext(\"Stream test\"),\n                message: message,\n                onclose: function () {\n                    self.testWebcamStreamUrlBusy(false);\n                    if (webrtc_peer_connection != null) {\n                        webrtc_peer_connection.close();\n                        webrtc_peer_connection = null;\n                    }\n                }\n            });\n        };\n\n        self.testWebcamSnapshotUrlBusy = ko.observable(false);\n        self.testWebcamSnapshotUrl = function (viewModel, event) {\n            if (!self.webcam_snapshotUrl()) {\n                return;\n            }\n\n            if (self.testWebcamSnapshotUrlBusy()) {\n                return;\n            }\n\n            var errorText = gettext(\n                \"Could not retrieve snapshot URL, please double check the URL\"\n            );\n            var errorTitle = gettext(\"Snapshot test failed\");\n\n            self.testWebcamSnapshotUrlBusy(true);\n            OctoPrint.util\n                .testUrl(self.webcam_snapshotUrl(), {\n                    method: \"GET\",\n                    response: \"bytes\",\n                    timeout: self.webcam_snapshotTimeout(),\n                    validSsl: self.webcam_snapshotSslValidation(),\n                    content_type_whitelist: [\"image/*\"],\n                    content_type_guess: true\n                })\n                .done(function (response) {\n                    if (!response.result) {\n                        if (\n                            response.status &&\n                            response.response &&\n                            response.response.content_type\n                        ) {\n                            // we could contact the server, but something else was wrong, probably the mime type\n                            errorText = gettext(\n                                \"Could retrieve the snapshot URL, but it didn't look like an \" +\n                                    \"image. Got this as a content type header: <code>%(content_type)s</code>. Please \" +\n                                    \"double check that the URL is returning static images, not multipart data \" +\n                                    \"or videos.\"\n                            );\n                            errorText = _.sprintf(errorText, {\n                                content_type: _.escape(response.response.content_type)\n                            });\n                        }\n\n                        showMessageDialog({\n                            title: errorTitle,\n                            message: errorText,\n                            onclose: function () {\n                                self.testWebcamSnapshotUrlBusy(false);\n                            }\n                        });\n                        return;\n                    }\n\n                    var content = response.response.content;\n                    var contentType = response.response.assumed_content_type;\n\n                    var mimeType = \"image/jpeg\";\n                    if (contentType) {\n                        mimeType = contentType.split(\";\")[0];\n                    }\n\n                    var text = gettext(\n                        \"If you see your webcam snapshot picture below, the entered snapshot URL is ok.\"\n                    );\n                    showMessageDialog({\n                        title: gettext(\"Snapshot test\"),\n                        message: $(\n                            \"<p>\" +\n                                text +\n                                '</p><p><img src=\"data:' +\n                                mimeType +\n                                \";base64,\" +\n                                content +\n                                '\" style=\"border: 1px solid black\" /></p>'\n                        ),\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                })\n                .fail(function () {\n                    showMessageDialog({\n                        title: errorTitle,\n                        message: errorText,\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                });\n        };\n\n        self.testWebcamFfmpegPathBusy = ko.observable(false);\n        self.testWebcamFfmpegPath = function () {\n            if (!self.webcam_ffmpegPath()) {\n                return;\n            }\n\n            if (self.testWebcamFfmpegPathBusy()) {\n                return;\n            }\n\n            self.testWebcamFfmpegPathBusy(true);\n            OctoPrint.util\n                .testExecutable(self.webcam_ffmpegPath())\n                .done(function (response) {\n                    if (!response.result) {\n                        if (!response.exists) {\n                            self.webcam_ffmpegPathText(gettext(\"The path doesn't exist\"));\n                        } else if (!response.typeok) {\n                            self.webcam_ffmpegPathText(gettext(\"The path is not a file\"));\n                        } else if (!response.access) {\n                            self.webcam_ffmpegPathText(\n                                gettext(\"The path is not an executable\")\n                            );\n                        }\n                    } else {\n                        self.webcam_ffmpegPathText(gettext(\"The path is valid\"));\n                    }\n                    self.webcam_ffmpegPathOk(response.result);\n                    self.webcam_ffmpegPathBroken(!response.result);\n                })\n                .always(function () {\n                    self.testWebcamFfmpegPathBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityConfig = function () {\n            if (!self.server_onlineCheck_host()) return;\n            if (!self.server_onlineCheck_port()) return;\n            if (self.testOnlineConnectivityConfigBusy()) return;\n\n            self.testOnlineConnectivityConfigBusy(true);\n            OctoPrint.util\n                .testServer(\n                    self.server_onlineCheck_host(),\n                    self.server_onlineCheck_port()\n                )\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckText(\n                            gettext(\"The server is not reachable\")\n                        );\n                    } else {\n                        self.server_onlineCheckText(gettext(\"The server is reachable\"));\n                    }\n                    self.server_onlineCheckOk(response.result);\n                    self.server_onlineCheckBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityConfigBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityResolutionConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityResolutionConfig = function () {\n            if (!self.server_onlineCheck_name()) return;\n            if (self.testOnlineConnectivityResolutionConfigBusy()) return;\n\n            self.testOnlineConnectivityResolutionConfigBusy(true);\n            OctoPrint.util\n                .testResolution(self.server_onlineCheck_name())\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name cannot be resolved\")\n                        );\n                    } else {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name can be resolved\")\n                        );\n                    }\n                    self.server_onlineCheckResolutionOk(response.result);\n                    self.server_onlineCheckResolutionBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityResolutionConfigBusy(false);\n                });\n        };\n\n        self.testFolderConfigBusy = ko.observable(false);\n        self.testFolderConfig = function (folder) {\n            var observable = \"folder_\" + folder;\n            if (!self.hasOwnProperty(observable)) return;\n\n            if (self.testFolderConfigBusy()) return;\n            self.testFolderConfigBusy(true);\n\n            var opts = {\n                check_type: \"dir\",\n                check_access: \"w\",\n                allow_create_dir: true,\n                check_writable_dir: true\n            };\n            var path = self[observable]();\n            OctoPrint.util\n                .testPath(path, opts)\n                .done(function (response) {\n                    if (!response.result) {\n                        if (response.broken_symlink) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is a broken symlink.\")\n                            );\n                        } else if (!response.exists) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path does not exist and cannot be created.\")\n                            );\n                        } else if (!response.typeok) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not a folder.\")\n                            );\n                        } else if (!response.access) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not writable.\")\n                            );\n                        }\n                    } else {\n                        self.testFolderConfigText[folder](gettext(\"The path is valid\"));\n                    }\n                    self.testFolderConfigOk[folder](response.result);\n                    self.testFolderConfigBroken[folder](!response.result);\n                })\n                .always(function () {\n                    self.testFolderConfigBusy(false);\n                });\n        };\n\n        self.onSettingsHidden = function () {\n            self.webcam_ffmpegPathReset();\n            self.server_onlineCheckReset();\n            self.server_onlineCheckResolutionReset();\n            self.testFolderConfigReset();\n        };\n\n        self.isDialogActive = function () {\n            return self.settingsDialog.is(\":visible\");\n        };\n\n        self.onStartup = function () {\n            self.settingsDialog = $(\"#settings_dialog\");\n            self.settingsUpdatedDialog = $(\"#settings_dialog_update_detected\");\n            self.translationManagerDialog = $(\n                \"#settings_appearance_managelanguagesdialog\"\n            );\n            self.translationUploadElement = $(\n                \"#settings_appearance_managelanguagesdialog_upload\"\n            );\n            self.translationUploadButton = $(\n                \"#settings_appearance_managelanguagesdialog_upload_start\"\n            );\n\n            self.translationUploadElement.fileupload({\n                dataType: \"json\",\n                maxNumberOfFiles: 1,\n                autoUpload: false,\n                headers: OctoPrint.getRequestHeaders(),\n                add: function (e, data) {\n                    if (data.files.length == 0) {\n                        return false;\n                    }\n\n                    self.translationUploadFilename(data.files[0].name);\n\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadButton.bind(\"click\", function () {\n                        data.submit();\n                        return false;\n                    });\n                },\n                done: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                    self.fromTranslationResponse(data.result);\n                },\n                fail: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                }\n            });\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.allViewModels = allViewModels;\n\n            self.settingsDialog.on(\"show\", function (event) {\n                OctoPrint.coreui.settingsOpen = true;\n                if (event.target.id == \"settings_dialog\") {\n                    self.requestTranslationData();\n                    callViewModels(allViewModels, \"onSettingsShown\");\n                }\n            });\n            self.settingsDialog.on(\"hidden\", function (event) {\n                OctoPrint.coreui.settingsOpen = false;\n                if (event.target.id == \"settings_dialog\") {\n                    callViewModels(allViewModels, \"onSettingsHidden\");\n                }\n            });\n            self.settingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onSettingsBeforeSave\");\n            });\n\n            $(\".reload_all\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData();\n                return false;\n            });\n            $(\".reload_nonconflicts\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData(true);\n                return false;\n            });\n\n            // reset scroll position on tab change\n            $('ul.nav-list a[data-toggle=\"tab\"]', self.settingsDialog).on(\n                \"show\",\n                function () {\n                    self._resetScrollPosition();\n                }\n            );\n        };\n\n        self.show = function (tab) {\n            // select first or specified tab\n            self.selectTab(tab);\n\n            // reset scroll position\n            self._resetScrollPosition();\n\n            // show settings, ensure centered position\n            self.settingsDialog\n                .modal({\n                    minHeight: function () {\n                        return Math.max($.fn.modal.defaults.maxHeight() - 80, 250);\n                    }\n                })\n                .css({\n                    \"margin-left\": function () {\n                        return -($(this).width() / 2);\n                    }\n                });\n\n            return false;\n        };\n\n        self.hide = function () {\n            self.settingsDialog.modal(\"hide\");\n        };\n\n        self.generateApiKey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                ),\n                function () {\n                    OctoPrint.settings.generateApiKey().done(function (response) {\n                        self.api_key(response.apikey);\n                        self.requestData();\n                    });\n                }\n            );\n        };\n\n        self.copyApiKey = function () {\n            copyToClipboard(self.api_key());\n        };\n\n        self.showTranslationManager = function () {\n            self.translationManagerDialog.modal();\n            return false;\n        };\n\n        self.requestData = function (local) {\n            // handle old parameter format\n            var callback = undefined;\n            if (arguments.length === 2 || _.isFunction(local)) {\n                var exc = new Error();\n                log.warn(\n                    \"The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:\",\n                    exc.stack || exc.stacktrace || \"<n/a>\"\n                );\n\n                if (arguments.length === 2) {\n                    callback = arguments[0];\n                    local = arguments[1];\n                } else {\n                    callback = local;\n                    local = false;\n                }\n            }\n\n            // handler for any explicitly provided callbacks\n            var callbackHandler = function () {\n                if (!callback) return;\n                try {\n                    callback();\n                } catch (exc) {\n                    log.error(\n                        \"Error calling settings callback\",\n                        callback,\n                        \":\",\n                        exc.stack || exc.stacktrace || exc\n                    );\n                }\n            };\n\n            // if a request is already active, create a new deferred and return\n            // its promise, it will be resolved in the response handler of the\n            // current request\n            if (self.receiving()) {\n                var deferred = $.Deferred();\n                self.outstanding.push(deferred);\n\n                if (callback) {\n                    // if we have a callback, we need to make sure it will\n                    // get called when the deferred is resolved\n                    deferred.done(callbackHandler);\n                }\n\n                return deferred.promise();\n            }\n\n            // perform the request\n            self.receiving(true);\n            return OctoPrint.settings\n                .get()\n                .always(function () {\n                    self.receiving(false);\n                })\n                .done(function (response) {\n                    self.fromResponse(response, local);\n\n                    if (callback) {\n                        var deferred = $.Deferred();\n                        deferred.done(callbackHandler);\n                        self.outstanding.push(deferred);\n                    }\n\n                    // resolve all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.resolve(args);\n                    });\n                    self.outstanding = [];\n                })\n                .fail(function () {\n                    // reject all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.reject(args);\n                    });\n                    self.outstanding = [];\n                });\n        };\n\n        self.requestTranslationData = function () {\n            return OctoPrint.languages.list().done(self.fromTranslationResponse);\n        };\n\n        self.fromTranslationResponse = function (response) {\n            var translationsByLocale = {};\n            _.each(response.language_packs, function (item, key) {\n                _.each(item.languages, function (pack) {\n                    var locale = pack.locale;\n                    if (!_.has(translationsByLocale, locale)) {\n                        translationsByLocale[locale] = {\n                            locale: locale,\n                            display: pack.locale_display,\n                            english: pack.locale_english,\n                            packs: []\n                        };\n                    }\n\n                    translationsByLocale[locale][\"packs\"].push({\n                        identifier: key,\n                        display: item.display,\n                        pack: pack\n                    });\n                });\n            });\n\n            var translations = [];\n            _.each(translationsByLocale, function (item) {\n                item[\"packs\"].sort(function (a, b) {\n                    if (a.identifier == \"_core\") return -1;\n                    if (b.identifier == \"_core\") return 1;\n\n                    if (a.display < b.display) return -1;\n                    if (a.display > b.display) return 1;\n                    return 0;\n                });\n                translations.push(item);\n            });\n\n            self.translations.updateItems(translations);\n        };\n\n        self.languagePackDisplay = function (item) {\n            return (\n                item.display +\n                (item.english != undefined ? \" (\" + item.english + \")\" : \"\")\n            );\n        };\n\n        self.languagePacksAvailable = ko.pureComputed(function () {\n            return self.translations.allSize() > 0;\n        });\n\n        self.deleteLanguagePack = function (locale, pack) {\n            OctoPrint.languages.delete(locale, pack).done(self.fromTranslationResponse);\n        };\n\n        /**\n         * Fetches the settings as currently stored in this client instance.\n         */\n        self.getLocalData = function () {\n            var data = {};\n            if (self.settings != undefined) {\n                data = ko.mapping.toJS(self.settings);\n            }\n\n            // some special read functions for various observables\n            var specialMappings = {\n                feature: {\n                    autoUppercaseBlacklist: function () {\n                        return splitTextToArray(\n                            self.feature_autoUppercaseBlacklist(),\n                            \",\",\n                            true\n                        );\n                    }\n                },\n                serial: {\n                    additionalPorts: function () {\n                        return commentableLinesToArray(self.serial_additionalPorts());\n                    },\n                    additionalBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_additionalBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    blacklistedPorts: function () {\n                        return commentableLinesToArray(self.serial_blacklistedPorts());\n                    },\n                    blacklistedBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_blacklistedBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    longRunningCommands: function () {\n                        return splitTextToArray(\n                            self.serial_longRunningCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    checksumRequiringCommands: function () {\n                        return splitTextToArray(\n                            self.serial_checksumRequiringCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    blockedCommands: function () {\n                        return splitTextToArray(self.serial_blockedCommands(), \",\", true);\n                    },\n                    ignoredCommands: function () {\n                        return splitTextToArray(self.serial_ignoredCommands(), \",\", true);\n                    },\n                    pausingCommands: function () {\n                        return splitTextToArray(self.serial_pausingCommands(), \",\", true);\n                    },\n                    emergencyCommands: function () {\n                        return splitTextToArray(\n                            self.serial_emergencyCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    externalHeatupDetection: function () {\n                        return !self.serial_disableExternalHeatupDetection();\n                    },\n                    alwaysSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"always\";\n                    },\n                    neverSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"never\";\n                    },\n                    ignoreErrorsFromFirmware: function () {\n                        return self.serial_serialErrorBehaviour() === \"ignore\";\n                    },\n                    disconnectOnErrors: function () {\n                        return self.serial_serialErrorBehaviour() === \"disconnect\";\n                    }\n                },\n                scripts: {\n                    gcode: function () {\n                        // we have a special handler function for the gcode scripts since the\n                        // server will always send us those that have been set already, so we\n                        // can't depend on all keys that we support to be present in the\n                        // original request we iterate through in mapFromObservables to\n                        // generate our response - hence we use our observables instead\n                        //\n                        // Note: If we ever introduce sub categories in the gcode scripts\n                        // here (more _ after the prefix), we'll need to adjust this code\n                        // to be able to cope with that, right now it only strips the prefix\n                        // and uses the rest as key in the result, no recursive translation\n                        // is done!\n                        var result = {};\n                        var prefix = \"scripts_gcode_\";\n                        var observables = _.filter(_.keys(self), function (key) {\n                            return _.startsWith(key, prefix);\n                        });\n                        _.each(observables, function (observable) {\n                            var script = observable.substring(prefix.length);\n                            result[script] = self[observable]();\n                        });\n                        return result;\n                    }\n                },\n                temperature: {\n                    profiles: function () {\n                        var result = [];\n                        _.each(self.temperature_profiles(), function (profile) {\n                            try {\n                                result.push({\n                                    name: profile.name,\n                                    extruder: Math.floor(\n                                        _.isNumber(profile.extruder)\n                                            ? profile.extruder\n                                            : parseInt(profile.extruder)\n                                    ),\n                                    bed: Math.floor(\n                                        _.isNumber(profile.bed)\n                                            ? profile.bed\n                                            : parseInt(profile.bed)\n                                    ),\n                                    chamber: Math.floor(\n                                        _.isNumber(profile.chamber)\n                                            ? profile.chamber\n                                            : _.isNumber(parseInt(profile.chamber))\n                                            ? parseInt(profile.chamber)\n                                            : 0\n                                    )\n                                });\n                            } catch (ex) {\n                                // ignore\n                            }\n                        });\n                        return result;\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function () {\n                        return splitTextToArray(\n                            self.webcam_streamWebrtcIceServers(),\n                            \",\",\n                            true\n                        );\n                    }\n                }\n            };\n\n            var mapFromObservables = function (data, mapping, keyPrefix) {\n                var flag = false;\n                var result = {};\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix !== undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\n                        result[key] = mapping[key]();\n                        flag = true;\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        var subresult = mapFromObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            observable\n                        );\n                        if (subresult !== undefined) {\n                            // we only set something on our result if we got something back\n                            result[key] = subresult;\n                            flag = true;\n                        }\n                    } else if (self.hasOwnProperty(observable)) {\n                        result[key] = self[observable]();\n                        flag = true;\n                    }\n                });\n\n                // if we set something on our result (flag is true), we return result, else we return undefined\n                return flag ? result : undefined;\n            };\n\n            // map local observables based on our existing data\n            var dataFromObservables = mapFromObservables(data, specialMappings);\n\n            data = deepMerge(data, dataFromObservables);\n            return data;\n        };\n\n        self.fromResponse = function (response, local) {\n            // server side changes to set\n            var serverChangedData;\n\n            // client side changes to keep\n            var clientChangedData;\n\n            if (local) {\n                // local is true, so we'll keep all local changes and only update what's been updated server side\n                serverChangedData = getOnlyChangedData(\n                    response,\n                    self.lastReceivedSettings\n                );\n                clientChangedData = getOnlyChangedData(\n                    self.getLocalData(),\n                    self.lastReceivedSettings\n                );\n            } else {\n                // local is false or unset, so we'll forcefully update with the settings from the server\n                serverChangedData = response;\n                clientChangedData = undefined;\n            }\n\n            // last received settings reset to response\n            self.lastReceivedSettings = response;\n\n            if (self.settings === undefined) {\n                self.settings = ko.mapping.fromJS(serverChangedData);\n            } else {\n                ko.mapping.fromJS(serverChangedData, self.settings);\n            }\n\n            // some special apply functions for various observables\n            var specialMappings = {\n                appearance: {\n                    defaultLanguage: function (value) {\n                        self.appearance_defaultLanguage(\"_default\");\n                        if (_.includes(self.locale_languages, value)) {\n                            self.appearance_defaultLanguage(value);\n                        }\n                    }\n                },\n                feature: {\n                    autoUppercaseBlacklist: function (value) {\n                        self.feature_autoUppercaseBlacklist(value.join(\", \"));\n                    }\n                },\n                serial: {\n                    additionalPorts: function (value) {\n                        self.serial_additionalPorts(value.join(\"\\n\"));\n                    },\n                    additionalBaudrates: function (value) {\n                        self.serial_additionalBaudrates(value.join(\", \"));\n                    },\n                    blacklistedPorts: function (value) {\n                        self.serial_blacklistedPorts(value.join(\"\\n\"));\n                    },\n                    blacklistedBaudrates: function (value) {\n                        self.serial_blacklistedBaudrates(value.join(\", \"));\n                    },\n                    longRunningCommands: function (value) {\n                        self.serial_longRunningCommands(value.join(\", \"));\n                    },\n                    checksumRequiringCommands: function (value) {\n                        self.serial_checksumRequiringCommands(value.join(\", \"));\n                    },\n                    blockedCommands: function (value) {\n                        self.serial_blockedCommands(value.join(\", \"));\n                    },\n                    ignoredCommands: function (value) {\n                        self.serial_ignoredCommands(value.join(\", \"));\n                    },\n                    pausingCommands: function (value) {\n                        self.serial_pausingCommands(value.join(\", \"));\n                    },\n                    emergencyCommands: function (value) {\n                        self.serial_emergencyCommands(value.join(\", \"));\n                    },\n                    externalHeatupDetection: function (value) {\n                        self.serial_disableExternalHeatupDetection(!value);\n                    },\n                    alwaysSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"always\");\n                        }\n                    },\n                    neverSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"never\");\n                        }\n                    },\n                    ignoreErrorsFromFirmware: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"ignore\");\n                        }\n                    },\n                    disconnectOnErrors: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"disconnect\");\n                        }\n                    }\n                },\n                terminalFilters: function (value) {\n                    self.terminalFilters($.extend(true, [], value));\n                },\n                temperature: {\n                    profiles: function (value) {\n                        self.temperature_profiles($.extend(true, [], value));\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function (value) {\n                        self.webcam_streamWebrtcIceServers(value.join(\", \"));\n                    }\n                }\n            };\n\n            var mapToObservables = function (data, mapping, local, keyPrefix) {\n                if (!_.isPlainObject(data)) {\n                    return;\n                }\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix != undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    var haveLocalVersion = local && local.hasOwnProperty(key);\n\n                    if (\n                        mapping &&\n                        mapping[key] &&\n                        _.isFunction(mapping[key]) &&\n                        !haveLocalVersion\n                    ) {\n                        // if we have a custom apply function for this, we'll use it\n                        mapping[key](value);\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        mapToObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            local && local[key] ? local[key] : undefined,\n                            observable\n                        );\n                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\n                        // if we have a matching observable, we'll use that\n                        self[observable](value);\n                    }\n                });\n            };\n\n            mapToObservables(serverChangedData, specialMappings, clientChangedData);\n\n            firstRequest.resolve();\n        };\n\n        self.cancelData = function () {\n            // revert unsaved changes\n            self.fromResponse(self.lastReceivedSettings);\n\n            self.hide();\n        };\n\n        self.saveData = function (data, successCallback, setAsSending) {\n            var options;\n            if (_.isPlainObject(successCallback)) {\n                options = successCallback;\n            } else {\n                options = {\n                    success: successCallback,\n                    sending: setAsSending === true\n                };\n            }\n\n            self.settingsDialog.trigger(\"beforeSave\");\n\n            self.sawUpdateEventWhileSending = false;\n            self.sending(data === undefined || options.sending || false);\n\n            if (data === undefined) {\n                // we also only send data that actually changed when no data is specified\n                var localData = self.getLocalData();\n                data = getOnlyChangedData(localData, self.lastReceivedSettings);\n            }\n\n            // final validation\n            if (self.testFoldersDuplicate()) {\n                // duplicate folders configured, we refuse to send any folder config\n                // to the server\n                delete data.folder;\n            }\n\n            self.active = true;\n            return OctoPrint.settings\n                .save(data)\n                .done(function (data, status, xhr) {\n                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\n                    self.active = false;\n\n                    self.receiving(true);\n                    self.sending(false);\n\n                    try {\n                        self.fromResponse(data);\n                        if (options.success) options.success(data, status, xhr);\n                    } finally {\n                        self.receiving(false);\n                    }\n                })\n                .fail(function (xhr, status, error) {\n                    self.sending(false);\n                    self.active = false;\n                    if (options.error) options.error(xhr, status, error);\n                })\n                .always(function (xhr, status) {\n                    if (options.complete) options.complete(xhr, status);\n                });\n        };\n\n        self.onEventSettingsUpdated = function () {\n            if (self.active) {\n                self.sawUpdateEventWhileActive = true;\n            }\n\n            var preventSettingsRefresh = _.any(self.allViewModels, function (viewModel) {\n                if (viewModel.hasOwnProperty(\"onSettingsPreventRefresh\")) {\n                    try {\n                        return viewModel[\"onSettingsPreventRefresh\"]();\n                    } catch (e) {\n                        log.warn(\n                            \"Error while calling onSettingsPreventRefresh on\",\n                            viewModel,\n                            \":\",\n                            e\n                        );\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            });\n\n            if (preventSettingsRefresh) {\n                // if any of our viewmodels prevented this refresh, we'll just return now\n                return;\n            }\n\n            if (self.isDialogActive()) {\n                // dialog is open and not currently busy...\n                if (\n                    self.sending() ||\n                    self.receiving() ||\n                    self.active ||\n                    self.ignoreNextUpdateEvent\n                ) {\n                    self.ignoreNextUpdateEvent = false;\n                    return;\n                }\n\n                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\n                    // we don't have local changes, so just fetch new data\n                    self.requestData();\n                } else {\n                    // we have local changes, show update dialog\n                    self.settingsUpdatedDialog.modal(\"show\");\n                }\n            } else {\n                // dialog is not open, just fetch new data\n                self.requestData();\n            }\n        };\n\n        self._resetScrollPosition = function () {\n            $(\"#settings_dialog_content\", self.settingsDialog).scrollTop(0);\n\n            // also reset any contained tabs/pills/lists to first pane\n            $(\n                '#settings_dialog_content ul.nav-pills a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-list a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-tabs a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n        };\n\n        self.selectTab = function (tab) {\n            if (tab != undefined) {\n                if (!_.startsWith(tab, \"#\")) {\n                    tab = \"#\" + tab;\n                }\n                $('ul.nav-list a[href=\"' + tab + '\"]', self.settingsDialog).tab(\"show\");\n            } else {\n                $('ul.nav-list a[data-toggle=\"tab\"]:first', self.settingsDialog).tab(\n                    \"show\"\n                );\n            }\n        };\n\n        self.onServerReconnect = function () {\n            // the settings might have changed if the server was just restarted,\n            // better refresh them now\n            self.requestData();\n        };\n\n        self.onUserPermissionsChanged =\n            self.onUserLoggedIn =\n            self.onUserLoggedOut =\n                function () {\n                    // we might have other user rights now, refresh (but only if startup has fully completed)\n                    if (!self._startupComplete) return;\n                    self.requestData();\n                };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: SettingsViewModel,\n        dependencies: [\n            \"loginStateViewModel\",\n            \"accessViewModel\",\n            \"printerProfilesViewModel\",\n            \"aboutViewModel\",\n            \"usersViewModel\"\n        ],\n        elements: [\"#settings_dialog\", \"#navbar_settings\"]\n    });\n});\n", "patch": "@@ -319,6 +319,10 @@ $(function () {\n                 return \"\";\n             }\n         });\n+        self.webcam_streamValid = ko.pureComputed(function () {\n+            var url = self.webcam_streamUrl();\n+            return !url || validateWebcamUrl(url);\n+        });\n \n         self.server_onlineCheckText = ko.observable();\n         self.server_onlineCheckOk = ko.observable(false);\n@@ -450,12 +454,19 @@ $(function () {\n             var text = gettext(\n                 \"If you see your webcam stream below, the entered stream URL is ok.\"\n             );\n-            var streamType = self.webcam_streamType();\n+\n+            var streamType;\n+            try {\n+                streamType = self.webcam_streamType();\n+            } catch (e) {\n+                streamType = \"\";\n+            }\n+\n             var webcam_element;\n             var webrtc_peer_connection;\n-            if (streamType == \"mjpg\") {\n+            if (streamType === \"mjpg\") {\n                 webcam_element = $('<img src=\"' + self.webcam_streamUrl() + '\">');\n-            } else if (streamType == \"hls\") {\n+            } else if (streamType === \"hls\") {\n                 webcam_element = $(\n                     '<video id=\"webcam_hls\" muted autoplay style=\"width: 100%\"/>'\n                 );\n@@ -467,7 +478,7 @@ $(function () {\n                     hls.loadSource(self.webcam_streamUrl());\n                     hls.attachMedia(video_element);\n                 }\n-            } else if (isWebRTCAvailable() && streamType == \"webrtc\") {\n+            } else if (isWebRTCAvailable() && streamType === \"webrtc\") {\n                 webcam_element = $(\n                     '<video id=\"webcam_webrtc\" muted autoplay playsinline controls style=\"width: 100%\"/>'\n                 );", "file_path": "files/2022_5/486", "file_language": "js", "file_name": "src/octoprint/static/js/app/viewmodels/settings.js", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/OctoPrint/OctoPrint/raw/6d259d7e6f5b0de9a1c762831537a386e53978d3/src%2Foctoprint%2Ftemplates%2Fsnippets%2Fsettings%2Fwebcam%2FwebcamStreamUrl.jinja2", "code": "<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\" data-bind=\"css: { error: !webcam_streamValid() }\">\n    <label class=\"control-label\" for=\"settings-webcamStreamUrl\">{{ _('Stream URL') }}</label>\n    <div class=\"controls\">\n        <div class=\"input-append\">\n            <input type=\"text\" class=\"input-block-level\" data-bind=\"value: webcam_streamUrl, valueUpdate: 'afterkeydown'\" id=\"settings-webcamStreamUrl\">\n            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: !testWebcamStreamUrlBusy() && webcam_streamValid(), css: {disabled: testWebcamStreamUrlBusy() || !webcam_streamValid()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n        </div>\n        <span class=\"help-block\">\n            <p>{% trans %}Needs to be reachable from the browser displaying the OctoPrint UI, used to embed the webcam stream into the page.{% endtrans %}</p>\n            <p data-bind=\"visible: webcam_streamType() === 'webrtc'\">{% trans %}<strong>Heads-up!</strong> WebRTC support is still in beta and subject to change, monitor the changelog of future versions closely for heads-ups regarding the WebRTC support in OctoPrint.{% endtrans %}</p>\n        </span>\n    </div>\n</div>\n", "code_before": "<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\">\n    <label class=\"control-label\" for=\"settings-webcamStreamUrl\">{{ _('Stream URL') }}</label>\n    <div class=\"controls\">\n        <div class=\"input-append\">\n            <input type=\"text\" class=\"input-block-level\" data-bind=\"value: webcam_streamUrl, valueUpdate: 'afterkeydown'\" id=\"settings-webcamStreamUrl\">\n            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: webcam_streamUrl() && !testWebcamStreamUrlBusy(), css: {disabled: !webcam_streamUrl() || testWebcamStreamUrlBusy()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n        </div>\n        <span class=\"help-block\">\n            <p>{% trans %}Needs to be reachable from the browser displaying the OctoPrint UI, used to embed the webcam stream into the page.{% endtrans %}</p>\n            <p data-bind=\"visible: webcam_streamType() === 'webrtc'\">{% trans %}<strong>Heads-up!</strong> WebRTC support is still in beta and subject to change, monitor the changelog of future versions closely for heads-ups regarding the WebRTC support in OctoPrint.{% endtrans %}</p>\n        </span>\n    </div>\n</div>\n", "patch": "@@ -1,9 +1,9 @@\n-<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\">\n+<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\" data-bind=\"css: { error: !webcam_streamValid() }\">\n     <label class=\"control-label\" for=\"settings-webcamStreamUrl\">{{ _('Stream URL') }}</label>\n     <div class=\"controls\">\n         <div class=\"input-append\">\n             <input type=\"text\" class=\"input-block-level\" data-bind=\"value: webcam_streamUrl, valueUpdate: 'afterkeydown'\" id=\"settings-webcamStreamUrl\">\n-            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: webcam_streamUrl() && !testWebcamStreamUrlBusy(), css: {disabled: !webcam_streamUrl() || testWebcamStreamUrlBusy()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n+            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: !testWebcamStreamUrlBusy() && webcam_streamValid(), css: {disabled: testWebcamStreamUrlBusy() || !webcam_streamValid()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n         </div>\n         <span class=\"help-block\">\n             <p>{% trans %}Needs to be reachable from the browser displaying the OctoPrint UI, used to embed the webcam stream into the page.{% endtrans %}</p>", "file_path": "files/2022_5/487", "file_language": "jinja2", "file_name": "src/octoprint/templates/snippets/settings/webcam/webcamStreamUrl.jinja2", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
