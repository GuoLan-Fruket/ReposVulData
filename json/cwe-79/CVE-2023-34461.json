{"index": 11682, "cve_id": "CVE-2023-34461", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "PyBB is an open source bulletin board. A manual code review of the PyBB bulletin board server has revealed that a vulnerability could have been exploited in which users could submit any type of HTML tag, and have said tag run. For example, a malicious `<a>` that looks like ```<a href=javascript:alert (1)>xss</a>``` could have been used to run code through JavaScript on the client side. The problem has been patched as of commit `5defd92`, and users are advised to upgrade. Attackers do need posting privilege in order to exploit this vulnerability. This vulnerability is present within the 0.1.0 release, and users are advised to upgrade to 0.1.1. Users unable to upgrade may be able to work around the attack by either; Removing the ability to create posts, removing the `|safe` tag from the Jinja2 template titled \"post.html\" in templates or by adding manual validation of links in the post creation section.", "cvss": "5.4", "publish_date": "June 19, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "5defd922ab05a193a783392d447c6538628cf854", "commit_message": "Merge pull request from GHSA-mv96-w49p-438p\n\nfixed possible xss", "commit_date": "2023-06-19T12:21:54Z", "project": "benjjvi/pybb", "url": "https://api.github.com/repos/benjjvi/PyBB/commits/5defd922ab05a193a783392d447c6538628cf854", "html_url": "https://github.com/benjjvi/PyBB/commit/5defd922ab05a193a783392d447c6538628cf854", "windows_before": [{"commit_id": "8ef7c05de31e2d69d5b3e5a023b84a065893bdf5", "commit_date": "Sun Jun 18 14:59:41 2023 +0100", "commit_message": "formatting and small bug fixes", "files_name": ["BulletinDatabaseModule.py", "configure.py", "main.py"]}, {"commit_id": "0b438fe6c2e9294f3b28e0314e86a748334ef61a", "commit_date": "Sun Jun 18 14:52:50 2023 +0100", "commit_message": "fix the configure file", "files_name": ["configure.py"]}, {"commit_id": "4c2cf2c392a1e8ff888380f1f252c80361962bec", "commit_date": "Sun Jun 18 14:48:38 2023 +0100", "commit_message": "add ability to create posts", "files_name": ["BulletinDatabaseModule.py", "README.md", "example_database/bb.db3", "example_database/captchas", "example_database/log.db3", "main.py", "requirements.txt", "static/docs/docs.html", "static/style.css", "templates/_navigation.html", "templates/createpost.html", "templates/home.html", "templates/post.html"]}, {"commit_id": "91276a5c3b10b8fe24b1a21edae4c166e0cc1d5f", "commit_date": "Sun Jun 18 11:58:01 2023 +0100", "commit_message": "update requirements", "files_name": ["requirements.txt"]}, {"commit_id": "cc035f9ce38e5b5f49df908830fa066ae55acf9f", "commit_date": "Sat Jun 17 16:47:56 2023 +0100", "commit_message": "add log to gitignore", "files_name": [".gitignore"]}, {"commit_id": "f0b8a37b17fbc54b3925d48f841d9abf97e8782a", "commit_date": "Sat Jun 17 16:47:42 2023 +0100", "commit_message": "remove log file", "files_name": ["access.log"]}, {"commit_id": "4f15d05053d9aa417344181a9bf157f26b9b4751", "commit_date": "Sat Jun 17 16:43:51 2023 +0100", "commit_message": "remove debug mode for security", "files_name": ["main.py"]}, {"commit_id": "6b874ab667a540002e299f2e2185a98cda3da886", "commit_date": "Sat Jun 17 16:41:56 2023 +0100", "commit_message": "formatting", "files_name": ["captcha_module.py", "configure.py", "deploy.py", "main.py"]}, {"commit_id": "d6dc650391a47e18a9b885979e42dcd9365ba648", "commit_date": "Sat Jun 17 16:41:37 2023 +0100", "commit_message": "remove comments", "files_name": ["configure.py"]}, {"commit_id": "0e8ea3a9a8a22420ea22384fb824faa7b0566981", "commit_date": "Sat Jun 17 16:41:15 2023 +0100", "commit_message": "full WSGI and config", "files_name": [".gitignore", "BulletinDatabaseModule.py", "README.md", "access.log", "configure.py", "defaults.conf", "deploy.py", "deploy.sh", "requirements.txt"]}, {"commit_id": "1e76ecd171c7ee40e931480ab232bd0716bd2927", "commit_date": "Sat Jun 17 11:52:00 2023 +0100", "commit_message": "modify a few things, replace debug host with WSGI", "files_name": [".gitignore", "BulletinDatabaseModule.py", "README.md", "bbcrypto.py", "captcha_module.py", "deploy.sh", "main.py", "requirements.txt", "run.sh"]}, {"commit_id": "e0466a4989d19624ab37d8d3ec1dca66f2512c42", "commit_date": "Fri Jun 16 14:55:29 2023 +0100", "commit_message": "Captchas and Registers Now Available", "files_name": [".gitignore", "BulletinDatabaseModule.py", "captcha_module.py", "captcha_voice/en/0/default.wav", "captcha_voice/en/1/default.wav", "captcha_voice/en/2/default.wav", "captcha_voice/en/3/default.wav", "captcha_voice/en/4/default.wav", "captcha_voice/en/5/default.wav", "captcha_voice/en/6/default.wav", "captcha_voice/en/7/default.wav", "captcha_voice/en/8/default.wav", "captcha_voice/en/9/default.wav", "captcha_voice/en/a/default.wav", "captcha_voice/en/b/default.wav", "captcha_voice/en/c/default.wav", "captcha_voice/en/d/default.wav", "captcha_voice/en/e/default.wav", "captcha_voice/en/f/default.wav", "captcha_voice/en/g/default.wav", "captcha_voice/en/h/default.wav", "captcha_voice/en/i/default.wav", "captcha_voice/en/j/default.wav", "captcha_voice/en/k/default.wav", "captcha_voice/en/l/default.wav", "captcha_voice/en/m/default.wav", "captcha_voice/en/n/default.wav", "captcha_voice/en/o/default.wav", "captcha_voice/en/p/default.wav", "captcha_voice/en/q/default.wav", "captcha_voice/en/r/default.wav", "captcha_voice/en/s/default.wav", "captcha_voice/en/t/default.wav", "captcha_voice/en/u/default.wav", "captcha_voice/en/v/default.wav", "captcha_voice/en/w/default.wav", "captcha_voice/en/x/default.wav", "captcha_voice/en/y/default.wav", "captcha_voice/en/z/default.wav", "main.py", "requirements.txt", "templates/base.html", "templates/login.html", "templates/register.html"]}, {"commit_id": "683eb68f48b6e5df3199dc7a27afb20c4018f80e", "commit_date": "Tue Jun 13 21:28:44 2023 +0100", "commit_message": "removed debug logging", "files_name": ["BulletinDatabaseModule.py"]}, {"commit_id": "bf7351565092bb4277b54abfcf390e9c24fa1819", "commit_date": "Tue Jun 13 21:28:00 2023 +0100", "commit_message": "fixed problems re. posts", "files_name": ["BulletinDatabaseModule.py"]}, {"commit_id": "c265750f5efd6b5aae899380f4a268145eb08d9f", "commit_date": "Tue Jun 13 20:24:14 2023 +0100", "commit_message": "added example database files", "files_name": [".gitignore", "example_database/bb.db3", "example_database/log.db3"]}, {"commit_id": "380e470a48229bf872e23a61bdaaac8e7c545cdc", "commit_date": "Tue Jun 13 20:22:47 2023 +0100", "commit_message": "fix errors, add login system", "files_name": ["BulletinDatabaseModule.py", "cryptography.py", "defaults.conf", "main.py", "reset.sh", "templates/_navigation.html", "templates/login.html"]}, {"commit_id": "eaf19995be5bb36c5cd13525e44b9343f1f12509", "commit_date": "Tue Jun 13 12:34:11 2023 +0100", "commit_message": "continue the move to sanitized SQL", "files_name": ["BulletinDatabaseModule.py"]}, {"commit_id": "dcaeccd37198ecd3e41ea766d1099354b60d69c2", "commit_date": "Tue Jun 13 12:20:22 2023 +0100", "commit_message": "fix possible data leaks", "files_name": [".gitignore", "BulletinDatabaseModule.py", "cryptography.py", "main.py", "static/style.css", "templates/_navigation.html", "templates/login.html", "templates/register.html"]}, {"commit_id": "7bbd84c0f447a5fba2d3225826b03f4648478855", "commit_date": "Tue Jun 13 12:19:44 2023 +0100", "commit_message": "fix possible data leaks", "files_name": ["BulletinDatabaseModule.py"]}, {"commit_id": "f19c658ba91845d8f643a40789d47eaeeda92641", "commit_date": "Mon Jun 12 14:41:05 2023 +0100", "commit_message": "change logging, and graphical improvements", "files_name": ["BulletinDatabaseModule.py", "main.py", "run.sh", "static/style.css", "templates/post.html"]}, {"commit_id": "9967bce2b0e050999074daa5dca8d38c5ac9222a", "commit_date": "Sun Jun 11 14:45:37 2023 +0100", "commit_message": "lots of small changes.", "files_name": [".gitignore", "BulletinDatabaseModule.py", "defaults.conf", "main.py", "static/NunitoSans.ttf", "static/style.css", "templates/_footer.html", "templates/_navigation.html", "templates/about.html", "templates/base.html", "templates/post.html"]}, {"commit_id": "6945b7087da1ab38d3aa7454fc8b2ee632de9c2b", "commit_date": "Sat Jun 10 20:09:14 2023 +0100", "commit_message": "results.html was never meant to be published.", "files_name": ["templates/results.html"]}, {"commit_id": "4aad722f3859bf297c5f25d8621ff6ad68148680", "commit_date": "Sat Jun 10 20:08:54 2023 +0100", "commit_message": "update defaults.", "files_name": ["defaults.conf"]}, {"commit_id": "12c4013b65383fed3ab9d29cae766c93e1c6a361", "commit_date": "Sat Jun 10 19:59:42 2023 +0100", "commit_message": "code formatting", "files_name": ["BulletinDatabaseModule.py", "cryptography.py", "main.py"]}, {"commit_id": "c89b8b111e673e89e17d72138e0a307f4c02d48d", "commit_date": "Sat Jun 10 14:45:44 2023 +0100", "commit_message": "verbage caused problems.", "files_name": ["main.py"]}, {"commit_id": "dd2d531ceca037cf5445700baea9a85c7044a185", "commit_date": "Sat Jun 10 14:42:20 2023 +0100", "commit_message": "few small mistakes i didn't get.", "files_name": ["BulletinDatabaseModule.py"]}, {"commit_id": "beff839d9c890864b5d59032290642e44d48bc8a", "commit_date": "Sat Jun 10 14:39:44 2023 +0100", "commit_message": "lets gitignore the fact i forgot to upload reset", "files_name": [".gitignore", "reset.sh"]}, {"commit_id": "1138a833a3f7a42f6b9b62863ac8a04cc3773604", "commit_date": "Sat Jun 10 14:38:06 2023 +0100", "commit_message": "we have a prototype!", "files_name": ["BulletinDatabaseModule.py", "main.py", "templates/_navigation.html", "templates/board.html", "templates/home.html", "templates/post.html"]}], "windows_after": [{"commit_id": "3c150fe96e156e2a0e10faf331c0cc13043c57e2", "commit_date": "Mon Jun 19 15:35:48 2023 +0100", "commit_message": "Merge pull request #1 from benjjvi/development", "files_name": ["445712e0683295751b8742737963650c97708f76 - Mon Jun 19 15:38:44 2023 +0100 : Merge pull request #2 from benjjvi/main", "685bb6f7f2f46aeb4ab8476b1b3de8f4e01979c5 - Mon Jun 19 15:39:12 2023 +0100 : Merge pull request #3 from benjjvi/development", "50f65b8f916f416829ecbff2e96dc8913e0d327a - Mon Jun 19 15:53:30 2023 +0100 : update the escaping", "main.py"]}, {"commit_id": "402073447bd958b7a378fb762b56c75f5e6b3534", "commit_date": "Mon Jun 19 15:55:34 2023 +0100", "commit_message": "formatting", "files_name": ["main.py"]}, {"commit_id": "e9e624f5926c350a6d7b7cdc8e3f187d463af9e7", "commit_date": "Mon Jun 19 15:56:06 2023 +0100", "commit_message": "Merge pull request #4 from benjjvi/dev", "files_name": ["86a66bd097c9f7f89fdc7cd90b8287c79db40d6f - Mon Jun 19 16:06:04 2023 +0100 : Create bandit.yml", ".github/workflows/bandit.yml"]}, {"commit_id": "8fd2cf67e02efca9a6a6f350597811cb294049e7", "commit_date": "Mon Jun 19 16:06:44 2023 +0100", "commit_message": "Merge pull request #5 from benjjvi/dev", "files_name": ["c170125c07b0a12a3a5080282850b8ae65560462 - Mon Jun 19 16:09:31 2023 +0100 : remove code used to debug", "deploy.py"]}, {"commit_id": "b40c528c54e543b09fd762ad2b7d6e3cd6f5b4f0", "commit_date": "Tue Jun 20 13:41:20 2023 +0100", "commit_message": "changes to efficiency", "files_name": [".github/workflows/bandit.yml", "BulletinDatabaseModule.py", "main.py"]}, {"commit_id": "8a681c64d7a2f8c9075a1c43add04bb71be52e74", "commit_date": "Tue Jun 20 13:41:35 2023 +0100", "commit_message": "fix possible error where user has not run config before deploying", "files_name": ["deploy.py"]}, {"commit_id": "6ef955b985bb35b5692b3313309d1f68ee6ff306", "commit_date": "Sat Jun 24 11:24:33 2023 +0100", "commit_message": "Merge pull request #6 from benjjvi/dev", "files_name": []}], "parents": [{"commit_id_before": "8ef7c05de31e2d69d5b3e5a023b84a065893bdf5", "url_before": "https://api.github.com/repos/benjjvi/PyBB/commits/8ef7c05de31e2d69d5b3e5a023b84a065893bdf5", "html_url_before": "https://github.com/benjjvi/PyBB/commit/8ef7c05de31e2d69d5b3e5a023b84a065893bdf5"}, {"commit_id_before": "681c9821957c1f25e0e97860345b2cb0b5dc9475", "url_before": "https://api.github.com/repos/benjjvi/PyBB/commits/681c9821957c1f25e0e97860345b2cb0b5dc9475", "html_url_before": "https://github.com/benjjvi/PyBB/commit/681c9821957c1f25e0e97860345b2cb0b5dc9475"}], "details": [{"raw_url": "https://github.com/benjjvi/PyBB/raw/5defd922ab05a193a783392d447c6538628cf854/main.py", "code": "import re\nfrom datetime import datetime\n\nimport html\n\nfrom flask import Flask, make_response, redirect, render_template, request\n\nimport bbcrypto\nimport BulletinDatabaseModule\nimport captcha_module\n\napp = Flask(__name__)\nConfig = BulletinDatabaseModule.Configure()\nDatabase = BulletinDatabaseModule.DB(Config.get_config())\n\n# Note for logging:\n# To get the client's IP address, we use request.environ['REMOTE_ADDR'].\n# To log to the database, we use Database.write_log(f\"{request.environ['REMOTE_ADDR']}\").\n\n\ndef generate_register(error):\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=error,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp\n\n\n@app.route(\"/\")\ndef home():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Get the boards from the database:\n    boards = Database.get_boards()\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to home page from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        request.environ[\"REMOTE_ADDR\"],\n    )\n\n    # resp = make_response(render_template(\n    #     \"home.html\",\n    #     title=Config.get_config()[\"title\"],\n    #     description=Config.get_config()[\"short_description\"],\n    #     boards=boards,\n    # ))\n    # resp.set_cookie('userID', \"test\", max_age=2*60*60)\n\n    # Render the home page, with the boards:\n    print(Config.get_config()[\"title\"])\n    return render_template(\n        \"home.html\",\n        title=Config.get_config()[\"title\"],\n        description=Config.get_config()[\"short_description\"],\n        boards=boards,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/about\")\ndef about():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to about page from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"about.html\",\n        description=Config.get_config()[\"long_description\"].split(\"<br>\"),\n        username=loggedInUsername,\n    )\n\n\n@app.template_filter(\"date\")\ndef date_filter(s):\n    return datetime.utcnow().strftime(\"%Y\")\n\n\n# Using args\n\n# @app.route('/my-route')\n# def my_route():\n#  page = request.args.get('page', default = 1, type = int)\n#  filter = request.args.get('filter', default = '*', type = str)\n# /my-route?page=34               -> page: 34  filter: '*'\n# /my-route                       -> page:  1  filter: '*'\n# /my-route?page=10&filter=test   -> page: 10  filter: 'test'\n# /my-route?page=10&filter=10     -> page: 10  filter: '10'\n# /my-route?page=*&filter=*       -> page:  1  filter: '*'\n\n\n@app.route(\"/board\")\ndef boardView():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    boardID = request.args.get(\"board\", default=1, type=int)\n    pageID = request.args.get(\"page\", default=1, type=int)\n\n    # Get the board information:\n    boardInfo = Database.get_board_info(boardID)\n\n    # Get the posts from the board:\n    posts = Database.get_posts_from_board(boardID)\n\n    # Reduce the list to 15 items (starting from the index specified by pageID).\n    posts = posts[(pageID - 1) * 15 : pageID * 15]\n\n    # Get the number of pages:\n    numberOfPages = len(Database.get_posts_from_board(boardID)) // 15 + 1\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to board page with id {boardID} and page with ID {pageID} from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"board.html\",\n        title=boardInfo[0][1],\n        description=boardInfo[0][2],\n        posts=posts,\n        numberOfPages=numberOfPages,\n        boardID=boardID,\n        pageID=pageID,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/post\")\ndef postView():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Get the post ID from the URL:\n    postID = request.args.get(\"postid\", default=1, type=int)\n\n    # Get the post information:\n    postInfo = Database.get_post_info(postID)\n\n    # Get the comments from the post:\n    comments = Database.get_comments_from_post(postID)\n\n    # Get the user information:\n    userInfo = Database.get_user_info(postInfo[4])\n\n    # We need to turn postInfo from a tuple to a list.\n    postInfo = list(postInfo)\n\n    # We also need to turn each comment in the array to a list from a tuple.\n    comments = [list(comment) for comment in comments]\n\n    # We can handle turning the date from &Y&M&d in the postInfo[5] into a &d &M &Y format here.\n    # We can also handle turning the date from &Y&M&d in the comments[5] into a &d &M &Y format here.\n    print(postInfo)\n    postInfo[5] = datetime.strptime(str(postInfo[5]), \"%Y%m%d\").strftime(\"%d %B %Y\")\n    for comment in comments:\n        comment[5] = datetime.strptime(str(comment[5]), \"%Y%m%d\").strftime(\"%d %B %Y\")\n\n    # We can also handle times here. Turn postInfo[6] and comments[6] into a 24 hour clock.\n    postInfo[6] = datetime.strptime(str(postInfo[6]), \"%H%M%S\").strftime(\"%H:%M UTC\")\n    for comment in comments:\n        comment[6] = datetime.strptime(str(comment[6]), \"%H%M%S\").strftime(\"%H:%M UTC\")\n\n    # We want to add a new index, 7, which will be the comment author's author profile.\n    # To do this, we can use get_user_info() from the database module, feeding in index 3 of the comment.\n    for comment in comments:\n        commentAuthorInfo = Database.get_user_info(comment[3])\n        commentAuthorInfo = list(commentAuthorInfo)\n        comment.append(commentAuthorInfo)\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to post page with id {postID} from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"post.html\",\n        user=userInfo,\n        post=postInfo,\n        comments=comments,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/postcreation\")\ndef postcreation():\n    # This page is used to create a post.\n    # We need to get the board ID from the URL, and validate it exists in the database.\n    boardID = request.args.get(\"board\", default=1, type=int)\n    boardInfo = Database.get_board_info(boardID)\n\n    # Get the boards from the database:\n    boards = Database.get_boards()\n    # Output looks like:\n    # [(1, 'General', 'General discussion', ''), (2, 'Pictures', 'A picture sharing board, where you can upload links to your favourite photos you want to share with everyone!', ''), (3, 'Videos', 'A video sharing board, where you can upload links to your favourite videos you want to share with everyone!', ''), (4, 'Documents', 'A document sharing board, where you can upload links to your favourite documents you want to share with everyone!', ''), (5, 'Memes', 'A meme sharing board, where you can upload links to your favourite memes you want to share with everyone!', '')]\n    # Strip this down to a list of lists where each list is [boardID, boardName].\n    boards = [[board[0], board[1]] for board in boards]\n    print(boards)\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token does not exists, we need to redirect to the home page:\n    if loggedInUsername is None:\n        return redirect(\"/\")\n    else:\n        # If it does, we can render the post creation page:\n        return render_template(\n            \"createpost.html\",\n            boardInfo=boardInfo,\n            boards=boards,\n            username=loggedInUsername,\n        )\n\n\n@app.route(\"/createpost\", methods=[\"POST\"])\ndef createpost():\n    # Get the contents of fields title and content from the form:\n    title = request.form[\"title\"]\n    content = request.form[\"content\"]\n    boardID = request.form[\"boardID\"]\n\n    # Before looking at a regex to find URLs, we need to unescape the HTML submitted. This could be HTML that is malicious, so we need to escape it.\n    # We can do this by using the html.unescape() function.\n    content = html.unescape(content)\n\n    # urls is a regex that finds all URLs and their pages. e.g youtube.com/page/page2 is one entire URL. url's dont need to have a https:// at the beginning.\n    urls = re.findall(r\"(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\", content)\n    for url in urls:\n        content = (\n            content.replace(url, f\"<a href='https://{url}'>{url}</a>\")\n            if url[:8] != \"https://\" and url[:7] != \"http://\"\n            else f\"<a href='{url}'>{url}</a>\"\n        )\n\n    # Because we unescape the HTML, we need to escape the tags that could cause XSS attacks.\n    # These tags are <script>, <iframe>, and and any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n    # We can do this by using the re.sub() function.\n    content = re.sub(r\"<script>\", \"&lt;script&gt;\", content)\n    content = re.sub(r\"<\\/script>\", \"&lt;/script&gt;\", content)\n    content = re.sub(r\"<iframe>\", \"&lt;iframe&gt;\", content)\n    content = re.sub(r\"<\\/iframe>\", \"&lt;/iframe&gt;\", content)\n\n    # Next, we need to escape any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n    # We can do this by using the re.sub() function.\n    # The regex that detects anything that doesnt start with https://, http://. or follow xxx.xx is as follows:\n    # (?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\n    # We want the user to be able to see the URL, just not make it clickable, so remove the <a> tags.\n    content = re.sub(r\"<a href='(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+'>(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+<\\/a>\", r\"\\g<0>\".replace(\"<a href='\", \"\").replace(\"'>\", \"\"), content)\n\n    # The final regex we need will turn <a href=javascript:alert(1)>xss</a> into <a>xss</a>, where anything can be after javascript.\n    # We can do this by using the re.sub() function.\n    content = re.sub(r\"<a href=javascript:.*>(.*)<\\/a>\", r\"<a>\\g<1></a>\", content)\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token does not exists, we need to redirect to the home page:\n    if loggedInUsername is None:\n        return redirect(\"/\")\n    else:\n        # If it does, we can create the post:\n        # To do this, we can use the create_post() function from the database module.\n        # This function takes in the title, content, and board ID, and returns the post ID.\n        uid = Database.get_user_id_from_username(loggedInUsername)\n        pid = Database.create_post(boardID, title, content, uid)\n\n        # And redirect to the post page:\n        return redirect(f\"/post?postid={pid}\")\n\n\n@app.route(\"/loginuser\", methods=[\"POST\"])\ndef loginuser():\n    # Get the username and password from the form:\n    username = request.form[\"username\"]\n    password = request.form[\"password\"]\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token exists, we can redirect to the home page:\n    if loggedInUsername is not None:\n        return redirect(\"/\")\n\n    # Check if the username and password are correct:\n    if len(Database.check_user_credentials(username, password)) != 0:\n        try:\n            # If they are, generate a session token:\n            uid = Database.get_user_id_from_username(username)\n\n            if uid == None:\n                raise Exception(\"User ID is None.\")\n            else:\n                Database.write_log(\n                    f\"INFO: User {username} logged in.\", request.environ[\"REMOTE_ADDR\"]\n                )\n                session_token = bbcrypto.create_session(uid)\n                # And set the cookie:\n                resp = make_response(redirect(\"/\"))\n                resp.set_cookie(\"session_token\", session_token)\n                return resp\n        except Exception:\n            # Write a log to the log.\n            Database.write_log(\n                f\"ERROR: User {username} tried logging in, but upon searching for userid, {Database.get_user_id_from_username(username)} was recieved.\",\n                request.environ[\"REMOTE_ADDR\"],\n            )\n    else:\n        # If they aren't, redirect to the login page, with an error message passed through as error:\n        Database.write_log(\n            f\"WARN: User {username} tried logging in with password {password}, but the credentials were incorrect.\",\n            request.environ[\"REMOTE_ADDR\"],\n        )\n        return render_template(\n            \"login.html\",\n            username=loggedInUsername,\n            error=\"Incorrect username or password.\",\n        )\n\n\n@app.route(\"/login\")\ndef login():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername is None:\n        return render_template(\"login.html\", username=loggedInUsername, error=None)\n    else:\n        return redirect(\"/\")\n\n\n@app.route(\"/logout\")\ndef logout():\n    resp = make_response(redirect(\"/\"))\n    resp.set_cookie(\"session_token\", \"\", expires=0)\n    return resp\n\n\n@app.route(\"/createaccount\", methods=[\"POST\"])\ndef create_account():\n    username = request.form[\"username\"]\n    email = request.form[\"email\"]\n    password = request.form[\"pwd\"]\n    password_confirmed = request.form[\"pwd-confirm\"]\n    captchaHash = request.cookies.get(\"captcha\")\n    captchaResponse = request.form[\"captcha\"]\n\n    # First, check the username is not already in database.\n    if Database.get_user_id_from_username(username) != None:\n        return generate_register(\"Username already exists.\")\n\n    # Next, check the email is not already in database.\n    if Database.get_user_id_from_email(email) != None:\n        return generate_register(\"Email already exists.\")\n\n    # Next, let's check if the email is in the xxx@xxx.xxx format using regex.\n    if re.match(r\"[^@]+@[^@]+\\.[^@]+\", email) == None:\n        return generate_register(\"Email is not in the correct format.\")\n\n    # Next, check the passwords match.\n    if password != password_confirmed:\n        return generate_register(\"Passwords do not match.\")\n\n    # Next, check password is at least 8 characters long with at least one number, one letter, and one special character.\n    if (\n        re.match(\n            r\"^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$\", password\n        )\n        == None\n    ):\n        return generate_register(\n            \"Password is not in the correct format. You must have at least 8 characters, of which having one number, one letter, and one special character.\"\n        )\n\n    # Next, check the captcha is correct.\n    if captcha_module.check_captcha(captchaHash, captchaResponse) == False:\n        return generate_register(\"Captcha is incorrect.\")\n\n    # If all of these checks pass, we can create the account.\n    # To do this, we can use the create_user() function from the database module.\n    # This function takes in the username, email, and password, and returns the user ID.\n    # We can then use this user ID to create a session token, and set the cookie.\n    uid = Database.create_user(username, email, password)\n    session_token = bbcrypto.create_session(uid)\n    resp = make_response(redirect(\"/\"))\n    resp.set_cookie(\"session_token\", session_token)\n    return resp\n\n\n@app.route(\"/register\")\ndef register():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=None,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp\n\n\nif __name__ == \"__main__\":\n    print(\"Do not run this file!\")\n    print(\"Run deploy.py instead.\")\n", "code_before": "import re\nfrom datetime import datetime\n\nimport html\n\nfrom flask import Flask, make_response, redirect, render_template, request\n\nimport bbcrypto\nimport BulletinDatabaseModule\nimport captcha_module\n\napp = Flask(__name__)\nConfig = BulletinDatabaseModule.Configure()\nDatabase = BulletinDatabaseModule.DB(Config.get_config())\n\n# Note for logging:\n# To get the client's IP address, we use request.environ['REMOTE_ADDR'].\n# To log to the database, we use Database.write_log(f\"{request.environ['REMOTE_ADDR']}\").\n\n\ndef generate_register(error):\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=error,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp\n\n\n@app.route(\"/\")\ndef home():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Get the boards from the database:\n    boards = Database.get_boards()\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to home page from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        request.environ[\"REMOTE_ADDR\"],\n    )\n\n    # resp = make_response(render_template(\n    #     \"home.html\",\n    #     title=Config.get_config()[\"title\"],\n    #     description=Config.get_config()[\"short_description\"],\n    #     boards=boards,\n    # ))\n    # resp.set_cookie('userID', \"test\", max_age=2*60*60)\n\n    # Render the home page, with the boards:\n    print(Config.get_config()[\"title\"])\n    return render_template(\n        \"home.html\",\n        title=Config.get_config()[\"title\"],\n        description=Config.get_config()[\"short_description\"],\n        boards=boards,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/about\")\ndef about():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to about page from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"about.html\",\n        description=Config.get_config()[\"long_description\"].split(\"<br>\"),\n        username=loggedInUsername,\n    )\n\n\n@app.template_filter(\"date\")\ndef date_filter(s):\n    return datetime.utcnow().strftime(\"%Y\")\n\n\n# Using args\n\n# @app.route('/my-route')\n# def my_route():\n#  page = request.args.get('page', default = 1, type = int)\n#  filter = request.args.get('filter', default = '*', type = str)\n# /my-route?page=34               -> page: 34  filter: '*'\n# /my-route                       -> page:  1  filter: '*'\n# /my-route?page=10&filter=test   -> page: 10  filter: 'test'\n# /my-route?page=10&filter=10     -> page: 10  filter: '10'\n# /my-route?page=*&filter=*       -> page:  1  filter: '*'\n\n\n@app.route(\"/board\")\ndef boardView():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    boardID = request.args.get(\"board\", default=1, type=int)\n    pageID = request.args.get(\"page\", default=1, type=int)\n\n    # Get the board information:\n    boardInfo = Database.get_board_info(boardID)\n\n    # Get the posts from the board:\n    posts = Database.get_posts_from_board(boardID)\n\n    # Reduce the list to 15 items (starting from the index specified by pageID).\n    posts = posts[(pageID - 1) * 15 : pageID * 15]\n\n    # Get the number of pages:\n    numberOfPages = len(Database.get_posts_from_board(boardID)) // 15 + 1\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to board page with id {boardID} and page with ID {pageID} from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"board.html\",\n        title=boardInfo[0][1],\n        description=boardInfo[0][2],\n        posts=posts,\n        numberOfPages=numberOfPages,\n        boardID=boardID,\n        pageID=pageID,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/post\")\ndef postView():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # Get the post ID from the URL:\n    postID = request.args.get(\"postid\", default=1, type=int)\n\n    # Get the post information:\n    postInfo = Database.get_post_info(postID)\n\n    # Get the comments from the post:\n    comments = Database.get_comments_from_post(postID)\n\n    # Get the user information:\n    userInfo = Database.get_user_info(postInfo[4])\n\n    # We need to turn postInfo from a tuple to a list.\n    postInfo = list(postInfo)\n\n    # We also need to turn each comment in the array to a list from a tuple.\n    comments = [list(comment) for comment in comments]\n\n    # We can handle turning the date from &Y&M&d in the postInfo[5] into a &d &M &Y format here.\n    # We can also handle turning the date from &Y&M&d in the comments[5] into a &d &M &Y format here.\n    print(postInfo)\n    postInfo[5] = datetime.strptime(str(postInfo[5]), \"%Y%m%d\").strftime(\"%d %B %Y\")\n    for comment in comments:\n        comment[5] = datetime.strptime(str(comment[5]), \"%Y%m%d\").strftime(\"%d %B %Y\")\n\n    # We can also handle times here. Turn postInfo[6] and comments[6] into a 24 hour clock.\n    postInfo[6] = datetime.strptime(str(postInfo[6]), \"%H%M%S\").strftime(\"%H:%M UTC\")\n    for comment in comments:\n        comment[6] = datetime.strptime(str(comment[6]), \"%H%M%S\").strftime(\"%H:%M UTC\")\n\n    # We want to add a new index, 7, which will be the comment author's author profile.\n    # To do this, we can use get_user_info() from the database module, feeding in index 3 of the comment.\n    for comment in comments:\n        commentAuthorInfo = Database.get_user_info(comment[3])\n        commentAuthorInfo = list(commentAuthorInfo)\n        comment.append(commentAuthorInfo)\n\n    # Write to the log:\n    Database.write_log(\n        f\"Request to post page with id {postID} from {request.environ['REMOTE_ADDR']} with user token {session_token}.\",\n        f\"{request.environ['REMOTE_ADDR']}\",\n    )\n\n    return render_template(\n        \"post.html\",\n        user=userInfo,\n        post=postInfo,\n        comments=comments,\n        username=loggedInUsername,\n    )\n\n\n@app.route(\"/postcreation\")\ndef postcreation():\n    # This page is used to create a post.\n    # We need to get the board ID from the URL, and validate it exists in the database.\n    boardID = request.args.get(\"board\", default=1, type=int)\n    boardInfo = Database.get_board_info(boardID)\n\n    # Get the boards from the database:\n    boards = Database.get_boards()\n    # Output looks like:\n    # [(1, 'General', 'General discussion', ''), (2, 'Pictures', 'A picture sharing board, where you can upload links to your favourite photos you want to share with everyone!', ''), (3, 'Videos', 'A video sharing board, where you can upload links to your favourite videos you want to share with everyone!', ''), (4, 'Documents', 'A document sharing board, where you can upload links to your favourite documents you want to share with everyone!', ''), (5, 'Memes', 'A meme sharing board, where you can upload links to your favourite memes you want to share with everyone!', '')]\n    # Strip this down to a list of lists where each list is [boardID, boardName].\n    boards = [[board[0], board[1]] for board in boards]\n    print(boards)\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token does not exists, we need to redirect to the home page:\n    if loggedInUsername is None:\n        return redirect(\"/\")\n    else:\n        # If it does, we can render the post creation page:\n        return render_template(\n            \"createpost.html\",\n            boardInfo=boardInfo,\n            boards=boards,\n            username=loggedInUsername,\n        )\n\n\n@app.route(\"/createpost\", methods=[\"POST\"])\ndef createpost():\n    # Get the contents of fields title and content from the form:\n    title = request.form[\"title\"]\n    content = request.form[\"content\"]\n    boardID = request.form[\"boardID\"]\n\n    # Before looking at a regex to find URLs, we need to unescape the HTML submitted. This could be HTML that is malicious, so we need to escape it.\n    # We can do this by using the html.unescape() function.\n    content = html.unescape(content)\n\n    # urls is a regex that finds all URLs and their pages. e.g youtube.com/page/page2 is one entire URL. url's dont need to have a https:// at the beginning.\n    urls = re.findall(r\"(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\", content)\n    for url in urls:\n        content = (\n            content.replace(url, f\"<a href='https://{url}'>{url}</a>\")\n            if url[:8] != \"https://\" and url[:7] != \"http://\"\n            else f\"<a href='{url}'>{url}</a>\"\n        )\n\n    # Because we unescape the HTML, we need to escape the tags that could cause XSS attacks.\n    # These tags are <script>, <iframe>, and and any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n    # We can do this by using the re.sub() function.\n    content = re.sub(r\"<script>\", \"&lt;script&gt;\", content)\n    content = re.sub(r\"<\\/script>\", \"&lt;/script&gt;\", content)\n    content = re.sub(r\"<iframe>\", \"&lt;iframe&gt;\", content)\n    content = re.sub(r\"<\\/iframe>\", \"&lt;/iframe&gt;\", content)\n\n    # Next, we need to escape any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n    # We can do this by using the re.sub() function.\n    # The regex that detects anything that doesnt start with https://, http://. or follow xxx.xx is as follows:\n    # (?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\n    # We want the user to be able to see the URL, just not make it clickable, so remove the <a> tags.\n    content = re.sub(r\"<a href='(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+'>(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+<\\/a>\", r\"\\g<0>\".replace(\"<a href='\", \"\").replace(\"'>\", \"\"), content)\n\n    # The final regex we need will turn <a href=javascript:alert(1)>xss</a> into <a>xss</a>, where anything can be after javascript.\n    # We can do this by using the re.sub() function.\n    content = re.sub(r\"<a href=javascript:.*>(.*)<\\/a>\", r\"<a>\\g<1></a>\", content)\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token does not exists, we need to redirect to the home page:\n    if loggedInUsername is None:\n        return redirect(\"/\")\n    else:\n        # If it does, we can create the post:\n        # To do this, we can use the create_post() function from the database module.\n        # This function takes in the title, content, and board ID, and returns the post ID.\n        uid = Database.get_user_id_from_username(loggedInUsername)\n        pid = Database.create_post(boardID, title, content, uid)\n\n        # And redirect to the post page:\n        return redirect(f\"/post?postid={pid}\")\n\n\n@app.route(\"/loginuser\", methods=[\"POST\"])\ndef loginuser():\n    # Get the username and password from the form:\n    username = request.form[\"username\"]\n    password = request.form[\"password\"]\n\n    # Get the session token, to check if it already exists:\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    # If the session token exists, we can redirect to the home page:\n    if loggedInUsername is not None:\n        return redirect(\"/\")\n\n    # Check if the username and password are correct:\n    if len(Database.check_user_credentials(username, password)) != 0:\n        try:\n            # If they are, generate a session token:\n            uid = Database.get_user_id_from_username(username)\n\n            if uid == None:\n                raise Exception(\"User ID is None.\")\n            else:\n                Database.write_log(\n                    f\"INFO: User {username} logged in.\", request.environ[\"REMOTE_ADDR\"]\n                )\n                session_token = bbcrypto.create_session(uid)\n                # And set the cookie:\n                resp = make_response(redirect(\"/\"))\n                resp.set_cookie(\"session_token\", session_token)\n                return resp\n        except Exception:\n            # Write a log to the log.\n            Database.write_log(\n                f\"ERROR: User {username} tried logging in, but upon searching for userid, {Database.get_user_id_from_username(username)} was recieved.\",\n                request.environ[\"REMOTE_ADDR\"],\n            )\n    else:\n        # If they aren't, redirect to the login page, with an error message passed through as error:\n        Database.write_log(\n            f\"WARN: User {username} tried logging in with password {password}, but the credentials were incorrect.\",\n            request.environ[\"REMOTE_ADDR\"],\n        )\n        return render_template(\n            \"login.html\",\n            username=loggedInUsername,\n            error=\"Incorrect username or password.\",\n        )\n\n\n@app.route(\"/login\")\ndef login():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername is None:\n        return render_template(\"login.html\", username=loggedInUsername, error=None)\n    else:\n        return redirect(\"/\")\n\n\n@app.route(\"/logout\")\ndef logout():\n    resp = make_response(redirect(\"/\"))\n    resp.set_cookie(\"session_token\", \"\", expires=0)\n    return resp\n\n\n@app.route(\"/createaccount\", methods=[\"POST\"])\ndef create_account():\n    username = request.form[\"username\"]\n    email = request.form[\"email\"]\n    password = request.form[\"pwd\"]\n    password_confirmed = request.form[\"pwd-confirm\"]\n    captchaHash = request.cookies.get(\"captcha\")\n    captchaResponse = request.form[\"captcha\"]\n\n    # First, check the username is not already in database.\n    if Database.get_user_id_from_username(username) != None:\n        return generate_register(\"Username already exists.\")\n\n    # Next, check the email is not already in database.\n    if Database.get_user_id_from_email(email) != None:\n        return generate_register(\"Email already exists.\")\n\n    # Next, let's check if the email is in the xxx@xxx.xxx format using regex.\n    if re.match(r\"[^@]+@[^@]+\\.[^@]+\", email) == None:\n        return generate_register(\"Email is not in the correct format.\")\n\n    # Next, check the passwords match.\n    if password != password_confirmed:\n        return generate_register(\"Passwords do not match.\")\n\n    # Next, check password is at least 8 characters long with at least one number, one letter, and one special character.\n    if (\n        re.match(\n            r\"^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$\", password\n        )\n        == None\n    ):\n        return generate_register(\n            \"Password is not in the correct format. You must have at least 8 characters, of which having one number, one letter, and one special character.\"\n        )\n\n    # Next, check the captcha is correct.\n    if captcha_module.check_captcha(captchaHash, captchaResponse) == False:\n        return generate_register(\"Captcha is incorrect.\")\n\n    # If all of these checks pass, we can create the account.\n    # To do this, we can use the create_user() function from the database module.\n    # This function takes in the username, email, and password, and returns the user ID.\n    # We can then use this user ID to create a session token, and set the cookie.\n    uid = Database.create_user(username, email, password)\n    session_token = bbcrypto.create_session(uid)\n    resp = make_response(redirect(\"/\"))\n    resp.set_cookie(\"session_token\", session_token)\n    return resp\n\n\n@app.route(\"/register\")\ndef register():\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=None,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp\n\n\nif __name__ == \"__main__\":\n    print(\"Do not run this file!\")\n    print(\"Run deploy.py instead.\")\n", "patch": "@@ -1,6 +1,8 @@\n import re\n from datetime import datetime\n \n+import html\n+\n from flask import Flask, make_response, redirect, render_template, request\n \n import bbcrypto\n@@ -272,16 +274,38 @@ def createpost():\n     content = request.form[\"content\"]\n     boardID = request.form[\"boardID\"]\n \n+    # Before looking at a regex to find URLs, we need to unescape the HTML submitted. This could be HTML that is malicious, so we need to escape it.\n+    # We can do this by using the html.unescape() function.\n+    content = html.unescape(content)\n+\n     # urls is a regex that finds all URLs and their pages. e.g youtube.com/page/page2 is one entire URL. url's dont need to have a https:// at the beginning.\n     urls = re.findall(r\"(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\", content)\n     for url in urls:\n-        print(url)\n         content = (\n             content.replace(url, f\"<a href='https://{url}'>{url}</a>\")\n             if url[:8] != \"https://\" and url[:7] != \"http://\"\n             else f\"<a href='{url}'>{url}</a>\"\n         )\n \n+    # Because we unescape the HTML, we need to escape the tags that could cause XSS attacks.\n+    # These tags are <script>, <iframe>, and and any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n+    # We can do this by using the re.sub() function.\n+    content = re.sub(r\"<script>\", \"&lt;script&gt;\", content)\n+    content = re.sub(r\"<\\/script>\", \"&lt;/script&gt;\", content)\n+    content = re.sub(r\"<iframe>\", \"&lt;iframe&gt;\", content)\n+    content = re.sub(r\"<\\/iframe>\", \"&lt;/iframe&gt;\", content)\n+\n+    # Next, we need to escape any hrefs that begin with ANYTHING other than https://, http://, or follow a domain pattern.\n+    # We can do this by using the re.sub() function.\n+    # The regex that detects anything that doesnt start with https://, http://. or follow xxx.xx is as follows:\n+    # (?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+\n+    # We want the user to be able to see the URL, just not make it clickable, so remove the <a> tags.\n+    content = re.sub(r\"<a href='(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+'>(?:(?:https?|http):\\/\\/)?[\\w/\\-?=%.]+\\.[\\w/\\-&?=%.]+<\\/a>\", r\"\\g<0>\".replace(\"<a href='\", \"\").replace(\"'>\", \"\"), content)\n+\n+    # The final regex we need will turn <a href=javascript:alert(1)>xss</a> into <a>xss</a>, where anything can be after javascript.\n+    # We can do this by using the re.sub() function.\n+    content = re.sub(r\"<a href=javascript:.*>(.*)<\\/a>\", r\"<a>\\g<1></a>\", content)\n+\n     # Get the session token, to check if it already exists:\n     session_token = request.cookies.get(\"session_token\")\n     loggedInUsername = (", "file_path": "files/2023_6/498", "file_language": "py", "file_name": "main.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 1, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.flask.security.injection.raw-html-concat.raw-html-format                                \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`flask.render_template`) which will safely render HTML instead.                  \n          Details: https://sg.run/Pb7e                                                                \n\n          287\u2506 else f\"<a href='{url}'>{url}</a>\"", "       python.django.security.injection.raw-html-format.raw-html-format                               \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`django.shortcuts.render`) which will safely render HTML instead.                \n          Details: https://sg.run/oYj1                                                                \n\n          287\u2506 else f\"<a href='{url}'>{url}</a>\"", "       python.flask.security.injection.tainted-url-host.tainted-url-host                             \n          User data flows into the host portion of this manually-constructed URL. This could allow an\n          attacker to send data to their own server, potentially exposing sensitive data such as     \n          cookies or authorization information sent with this request. They could also probe internal\n          servers or other resources that the server runnig this code can access. (This is called    \n          server-side request forgery, or SSRF.) Do not allow arbitrary hosts. Instead, create an    \n          allowlist for approved hosts hardcode the correct host.                                    \n          Details: https://sg.run/RXpK                                                               \n\n          285\u2506 content.replace(url, f\"<a href='https://{url}'>{url}</a>\")", "       python.flask.security.injection.raw-html-concat.raw-html-format                                \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`flask.render_template`) which will safely render HTML instead.                  \n          Details: https://sg.run/Pb7e                                                                \n\n          285\u2506 content.replace(url, f\"<a href='https://{url}'>{url}</a>\")", "       python.django.security.injection.tainted-url-host.tainted-url-host                            \n          User data flows into the host portion of this manually-constructed URL. This could allow an\n          attacker to send data to their own server, potentially exposing sensitive data such as     \n          cookies or authorization information sent with this request. They could also probe internal\n          servers or other resources that the server runnig this code can access. (This is called    \n          server-side request forgery, or SSRF.) Do not allow arbitrary hosts. Instead, create an    \n          allowlist for approved hosts hardcode the correct host.                                    \n          Details: https://sg.run/oYz6                                                               \n\n          285\u2506 content.replace(url, f\"<a href='https://{url}'>{url}</a>\")", "       python.django.security.injection.raw-html-format.raw-html-format                               \n          Detected user input flowing into a manually constructed HTML string. You may be accidentally\n          bypassing secure methods of rendering HTML by manually constructing HTML and this could     \n          create a cross-site scripting vulnerability, which could let attackers steal sensitive user \n          data. To be sure this is safe, check that the HTML is rendered safely. Otherwise, use       \n          templates (`django.shortcuts.render`) which will safely render HTML instead.                \n          Details: https://sg.run/oYj1                                                                \n\n          285\u2506 content.replace(url, f\"<a href='https://{url}'>{url}</a>\")"]]}, "target": 1, "function_before": [{"function": "def generate_register(error):\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=error,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp", "target": 0}], "function_after": [{"function": "def generate_register(error):\n    session_token = request.cookies.get(\"session_token\")\n    loggedInUsername = (\n        Database.get_username_from_user_id(bbcrypto.lookup_session_token(session_token))\n        if session_token is not None\n        else None\n    )\n\n    if loggedInUsername != None:\n        return redirect(\"/\")\n\n    # Get Captcha\n    captcha = captcha_module.create_audio_and_image_captcha()\n\n    captchaAnswer = captcha.split(\":\")[0]\n    captchaHash = captcha.split(\":\")[1]\n\n    audiocaptcha = f\"captchas/{captchaAnswer}.wav\"\n    imagecaptcha = f\"captchas/{captchaAnswer}.png\"\n\n    resp = make_response(\n        render_template(\n            \"register.html\",\n            audiocaptcha=audiocaptcha,\n            imagecaptcha=imagecaptcha,\n            username=loggedInUsername,\n            error=error,\n        )\n    )\n    resp.set_cookie(\"captcha\", captchaHash)\n    return resp", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
