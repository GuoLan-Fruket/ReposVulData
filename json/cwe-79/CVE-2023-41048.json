{"index": 12294, "cve_id": "CVE-2023-41048", "cwe_id": ["CWE-79", "CWE-80"], "cve_language": "Python", "cve_description": "plone.namedfile allows users to handle `File` and `Image` fields targeting, but not depending on, Plone Dexterity content. Prior to versions 5.6.1, 6.0.3, 6.1.3, and 6.2.1, there is a stored cross site scripting vulnerability for SVG images. A security hotfix from 2021 already partially fixed this by making sure SVG images are always downloaded instead of shown inline. But the same problem still exists for scales of SVG images. Note that an image tag with an SVG image as source is not vulnerable, even when the SVG image contains malicious code. To exploit the vulnerability, an attacker would first need to upload an image, and then trick a user into following a specially crafted link. Patches are available in versions 5.6.1 (for Plone 5.2), 6.0.3 (for Plone 6.0.0-6.0.4), 6.1.3 (for Plone 6.0.5-6.0.6), and 6.2.1 (for Plone 6.0.7). There are no known workarounds.", "cvss": "5.4", "publish_date": "September 21, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "ff5269fb4c79f4eb91dd934561b8824a49a03b60", "commit_message": "Merge pull request from GHSA-jj7c-jrv4-c65x\n\nForce download of image scales when inline is not allowed for mime type [5.x]", "commit_date": "2023-09-21T11:22:31Z", "project": "plone/plone.namedfile", "url": "https://api.github.com/repos/plone/plone.namedfile/commits/ff5269fb4c79f4eb91dd934561b8824a49a03b60", "html_url": "https://github.com/plone/plone.namedfile/commit/ff5269fb4c79f4eb91dd934561b8824a49a03b60", "windows_before": [{"commit_id": "f0f911f2a72b2e5c923dc2ab9179319cc47788f9", "commit_date": "Thu Sep 21 13:22:31 2023 +0200", "commit_message": "Merge pull request from GHSA-jj7c-jrv4-c65x", "files_name": ["07a890a857ff14c6077fa5eabab42bdf99061162 - Fri Sep 1 00:57:26 2023 +0200 : Force download of image scales when inline is not allowed for this mimetype.", "news/1.bugfix", "plone/namedfile/scaling.py", "plone/namedfile/tests/test_display_file.py"]}, {"commit_id": "628805e3b1dad01b731721555f7bb819a7ea1531", "commit_date": "Thu Sep 14 14:40:43 2023 +0200", "commit_message": "Back to development: 6.2.1", "files_name": ["setup.py"]}, {"commit_id": "76f30bb5ccc72a846412be2885795e0c659cb6aa", "commit_date": "Thu Sep 14 14:38:29 2023 +0200", "commit_message": "Preparing release 6.2.0", "files_name": ["CHANGES.rst", "news/149.feature", "news/150.feature", "setup.py"]}, {"commit_id": "00ff0e311f3666e1b6dd9ed4f8ed7b9b0c03098c", "commit_date": "Thu Sep 14 02:24:55 2023 +0200", "commit_message": "Bumped version for feature release.", "files_name": ["setup.py"]}, {"commit_id": "f2f4488b184f41e435c2f88442f3db412501ead3", "commit_date": "Thu Sep 14 02:24:32 2023 +0200", "commit_message": "Renamed news snippets, as they feel more like features.", "files_name": ["news/149.feature", "news/150.feature"]}, {"commit_id": "afdf3c9175cd9430bf5b52ea6423a60d4aa8aced", "commit_date": "Thu Sep 14 02:23:31 2023 +0200", "commit_message": "Merge pull request #152 from plone/mle-new-timestamp-for-hash_key", "files_name": ["28044bd2801a29a0460f7374252b9c65381a5c31 - Mon Sep 11 22:22:10 2023 -0700 : Merge pull request #150 from plone/mle-internal-modification-timestamp", "5a4fe5a2e9a97a0affc31acc3022c8701c28bb83 - Mon Sep 11 11:14:12 2023 -0400 : Add explicit fallback test to _p_time for scale invalidation.", "plone/namedfile/tests/test_scaling.py"]}, {"commit_id": "1511ce5d23a6210a096083ed02c76807becd9ef5", "commit_date": "Thu Sep 7 08:54:33 2023 -0400", "commit_message": "Use new internal modification timestamp as part of the hash key for scales.", "files_name": ["news/150.internal", "plone/namedfile/scaling.py", "plone/namedfile/tests/test_scaling.py"]}, {"commit_id": "056ad6ae630a9576198966b38b5e26786e573842", "commit_date": "Wed Sep 6 14:24:43 2023 -0400", "commit_message": "Add internal modification timestamp with fallback to _p_mtime.", "files_name": ["news/149.internal", "plone/namedfile/file.py", "plone/namedfile/tests/__init__.py", "plone/namedfile/tests/test_blobfile.py", "plone/namedfile/tests/test_image.py", "plone/namedfile/tests/test_scaling.py"]}, {"commit_id": "f814162c1fb2993d2750dadbf1baca1a9f7340f1", "commit_date": "Thu Aug 31 23:40:35 2023 +0200", "commit_message": "Back to development: 6.1.3", "files_name": ["setup.py"]}, {"commit_id": "f2a16e4c34b1279120f8ccda80d1d18ab249c663", "commit_date": "Thu Aug 31 23:40:12 2023 +0200", "commit_message": "Preparing release 6.1.2", "files_name": ["CHANGES.rst", "news/147.bugfix", "setup.py"]}, {"commit_id": "2fe758af36ea14feb4b79ed984e01af16a4241bb", "commit_date": "Mon Aug 28 11:45:42 2023 +0200", "commit_message": "Merge pull request #148 from plone/mliebischer-support-svg-with-large-header", "files_name": ["99c67897b2948b221c0196f35caaf6caa3dda08c - Tue Aug 22 16:44:42 2023 +0200 : Merge branch 'mliebischer-601-support-svg-with-large-header' into mliebischer-support-svg-with-large-header", "edcf90ab69a19530719c7709143d3d6c7829586f - Tue Aug 22 16:44:18 2023 +0200 : Add changenote", "news/147.bugfix"]}, {"commit_id": "2035c6b8a0eca79bef3ba6e06bf29552497ee3e0", "commit_date": "Tue Aug 22 15:12:07 2023 +0200", "commit_message": "Merge branch 'master' into mliebischer-support-svg-with-large-header", "files_name": ["18f39bb3e0b9eb284d855b576150e6bbf68fde85 - Mon Aug 21 19:07:13 2023 +0200 : Fix extracting dimensions of SVG files with lots of metadata (e.g. <svg> tag bigger than `MAX_INFO_BYTES`)", "plone/namedfile/file.py", "plone/namedfile/tests/__init__.py", "plone/namedfile/tests/image_large_header.svg", "plone/namedfile/tests/test_blobfile.py", "plone/namedfile/tests/test_svg.py", "plone/namedfile/utils/svg_utils.py"]}, {"commit_id": "d99b0358f4680ca8ffc3a42598e3980b6b4c1197", "commit_date": "Thu Jun 22 21:12:40 2023 +0200", "commit_message": "Back to development: 6.1.2", "files_name": ["setup.py"]}, {"commit_id": "73856dfa1d5c2fc8b0b2edbc8a77bc3cbfa58ff8", "commit_date": "Thu Jun 22 21:12:22 2023 +0200", "commit_message": "Preparing release 6.1.1", "files_name": ["CHANGES.rst", "news/144.bugfix", "news/867.tests", "setup.py"]}, {"commit_id": "4f554b6201ccbeda7f2f0d3fd4edd7ffee212d44", "commit_date": "Mon Jun 19 09:58:25 2023 +0200", "commit_message": "Merge pull request #146 from plone/maurits-fix-tests-with-newer-beautifulsoup", "files_name": ["c0f54ef3354b2aa4141acf7db0442877fb90926d - Fri Jun 16 18:07:34 2023 +0200 : Fix tests to work with various beautifulsoup4 versions.", "news/867.tests", "plone/namedfile/tests/test_scaling.py"]}, {"commit_id": "1ba19d137bac2e720b969ebe85b3b394932a5c2f", "commit_date": "Fri Jun 16 15:04:05 2023 +0200", "commit_message": "Merge pull request #145 from plone/fix-error-missing-images-subpath", "files_name": ["b2dc69f99ee6625baa513ca086bbcb300c1c5e52 - Wed Jun 14 14:08:48 2023 -0700 : block publishing of @@images without making it callable in page templates", "plone/namedfile/scaling.py"]}, {"commit_id": "a09498b93a880555294a559192ee4aefc3feefc1", "commit_date": "Tue Jun 13 16:50:27 2023 -0700", "commit_message": "Handle missing subpath for @@images view", "files_name": ["news/144.bugfix", "plone/namedfile/scaling.py", "plone/namedfile/tests/test_scaling_functional.py"]}, {"commit_id": "38c575683669677cf1adb9d422b24b2c8a590741", "commit_date": "Mon May 22 23:10:06 2023 +0200", "commit_message": "Back to development: 6.1.1", "files_name": ["setup.py"]}, {"commit_id": "f055591dc932490da042f7937b9dcc9408f9ac61", "commit_date": "Mon May 22 23:09:49 2023 +0200", "commit_message": "Preparing release 6.1.0", "files_name": ["CHANGES.rst", "news/3764.feature", "setup.py"]}, {"commit_id": "f2dc64d553d9d823c67ddae2533d71a53e5369b8", "commit_date": "Mon May 22 23:09:38 2023 +0200", "commit_message": "Bumped version for feature release.", "files_name": ["setup.py"]}, {"commit_id": "c00fc95d6ee09ef0202bfc31414d5b8d68f27687", "commit_date": "Mon May 22 23:09:10 2023 +0200", "commit_message": "Update news snippet.", "files_name": ["news/3764.feature", "news/3764.internal"]}, {"commit_id": "c2b3a34be56db46a4665f49a796d8ca9857b829f", "commit_date": "Sat May 20 13:36:39 2023 +0200", "commit_message": "Merge pull request #141 from plone/break-dependency-cycle", "files_name": ["25821b0ae966f1f6bc76f756be4b97e2f40d944e - Sun Apr 9 19:12:09 2023 +0200 : Add news entry", "news/3764.internal"]}, {"commit_id": "56ad2bc07f567b9370b765977cd449646f6d0dff", "commit_date": "Sun Apr 9 19:10:12 2023 +0200", "commit_message": "feat: move code from plone.app.z3cform", "files_name": ["plone/namedfile/storages.py", "plone/namedfile/z3c-blobfile.zcml"]}, {"commit_id": "ad362890b4357e71d7f526381b7fcdd408ce1748", "commit_date": "Mon May 8 21:44:58 2023 +0200", "commit_message": "Back to development: 6.0.3", "files_name": ["setup.py"]}, {"commit_id": "7cd6783f7f6140a4e0142c8e8c3c180ed99182b4", "commit_date": "Mon May 8 21:44:37 2023 +0200", "commit_message": "Preparing release 6.0.2", "files_name": ["CHANGES.rst", "news/142.bugfix", "setup.py"]}, {"commit_id": "cf8574af9cb90adcfacdc014c49c2f20d24ac876", "commit_date": "Tue May 2 10:34:05 2023 +0200", "commit_message": "Merge pull request #143 from plone/maurits-fix-update_src_scale-for-full-image-urls", "files_name": ["5d0bbcf3105a75e4bbb31fdd6b4682bcf1c514c0 - Tue Apr 25 16:59:16 2023 +0200 : Fix picture tag when original image is used instead of a scale.", "news/142.bugfix", "plone/namedfile/picture.py", "plone/namedfile/tests/test_scaling.py"]}, {"commit_id": "aae60d162e72dbf97e98baca2e9d7d9024532f35", "commit_date": "Tue Mar 14 23:28:18 2023 +0100", "commit_message": "Back to development: 6.0.2", "files_name": ["setup.py"]}, {"commit_id": "b1f1904bbffeee46a3438f85d0686c498fd1aacf", "commit_date": "Tue Mar 14 23:27:58 2023 +0100", "commit_message": "Preparing release 6.0.1", "files_name": ["CHANGES.rst", "news/50.tests", "setup.py"]}, {"commit_id": "bbfb3c7e10714252f7a912e917759448b608256b", "commit_date": "Tue Mar 14 23:27:40 2023 +0100", "commit_message": "Add python_requires 3.7+.", "files_name": ["setup.py"]}, {"commit_id": "4e7dd9672b9ed8087e13f8b37168a45769ac9b48", "commit_date": "Fri Mar 3 11:41:52 2023 +0100", "commit_message": "Merge pull request #139 from plone/maurits-tox-explicitly-test-only-current-package", "files_name": ["eac11a7847bc46970240aa331b65d6d8944e6a29 - Fri Mar 3 11:25:05 2023 +0100 : Tox: explicitly test only the plone.namedfile package.", "news/50.tests", "pyproject.toml", "tox.ini"]}, {"commit_id": "76825c60af0c8fc60db82357da901b1ed1cb23be", "commit_date": "Tue Nov 22 22:46:44 2022 +0100", "commit_message": "Back to development: 6.0.1", "files_name": ["setup.py"]}, {"commit_id": "7178b138f455c1da41c19809b74fb20810a7aad1", "commit_date": "Tue Nov 22 22:46:14 2022 +0100", "commit_message": "Preparing release 6.0.0", "files_name": ["CHANGES.rst", "news/134.bugfix", "news/135.bugfix", "news/3678.bugfix", "setup.py"]}, {"commit_id": "294fd510d19f5fe2b25e13e7c2115b8cbb63a80a", "commit_date": "Tue Nov 22 21:13:49 2022 +0100", "commit_message": "Merge pull request #138 from plone/maurits-picture-variant-more-robust", "files_name": ["d4982268fb8e43d00e511273c0cac8302c4126c8 - Mon Nov 21 22:04:26 2022 +0100 : Use mxdev pre release (3.0.0b1) for testing.", "tox.ini"]}, {"commit_id": "59ca577d28f4ca0cc40fb13d3f0b93a24c4d86a0", "commit_date": "Mon Nov 21 18:03:12 2022 +0100", "commit_message": "Prevent exception when an anonymous user is the first to load a page with a private image.", "files_name": ["news/135.bugfix", "plone/namedfile/picture.py", "setup.py", "sources-52.ini"]}, {"commit_id": "68d23edfd491e97dc36e34d4b7d89fa98616994a", "commit_date": "Mon Nov 21 17:47:20 2022 +0100", "commit_message": "Log a warning when a scale for a picture variant is not found.", "files_name": ["news/134.bugfix", "plone/namedfile/picture.py"]}, {"commit_id": "5f367ab6a531f68d6d9a79058bc4ee114db843fb", "commit_date": "Mon Nov 21 17:20:43 2022 +0100", "commit_message": "Merge pull request #136 from plone/maurits-want-original", "files_name": ["a9af18956b69861086b61fa863a17f79aced0ef3 - Mon Nov 21 16:06:36 2022 +0100 : Merge pull request #137 from plone/maurits-tox-311", "7b6412fc9bafeb906597ad75a8809c295e60197e - Mon Nov 21 15:54:06 2022 +0100 : gh-actions/tox: test on Python 3.11.", ".github/workflows/tests.yml", "setup.py", "tox.ini"]}, {"commit_id": "8064f435dfd54717679e784cccf54318fadc8831", "commit_date": "Mon Nov 21 15:37:13 2022 +0100", "commit_message": "Fixed writing to the database each time an original is requested.", "files_name": ["news/3678.bugfix", "plone/namedfile/scaling.py"]}, {"commit_id": "04fad1206fa570d9ed931915ac838c2cf7248680", "commit_date": "Mon Nov 21 10:14:15 2022 +0200", "commit_message": "fix formating", "files_name": ["plone/namedfile/scaling.py"]}, {"commit_id": "dbd9ed928cc7cd12101f756680772b2bf8cb6dd2", "commit_date": "Mon Nov 21 10:14:06 2022 +0200", "commit_message": "return original image data if want_original is set", "files_name": ["plone/namedfile/scaling.py"]}, {"commit_id": "dfb4f4564eccb86c2f4c32021d58bebc927cd308", "commit_date": "Mon Oct 3 10:47:30 2022 +0200", "commit_message": "Back to development: 6.0.0b6", "files_name": ["setup.py"]}, {"commit_id": "54e70b1ac2203551289fb1b4e1fa22593e73392f", "commit_date": "Mon Oct 3 10:46:29 2022 +0200", "commit_message": "Preparing release 6.0.0b5", "files_name": ["CHANGES.rst", "news/102.bugfix", "news/3637.breaking", "setup.py"]}, {"commit_id": "2a50173cf5f3ce09863d59d61abe9ceddbbaaf8f", "commit_date": "Mon Oct 3 10:46:11 2022 +0200", "commit_message": "Update classifiers.", "files_name": ["setup.py"]}, {"commit_id": "c0a681c9eb2f7970732a488346295846c363c718", "commit_date": "Thu Sep 29 20:50:11 2022 +0200", "commit_message": "Merge pull request #131 from plone/petschki-mode-scaling-take-3", "files_name": ["40b89772ddc152d561a5a463008ae759253fc90f - Thu Sep 29 11:55:32 2022 +0200 : No longer test Plone 5.2 on 3.6 and Plone 6.0 on 3.7.", ".github/workflows/tests.yml", "news/3637.breaking", "tox.ini"]}, {"commit_id": "6fb907775c45eb7e2e2c7f87bf4a98657f10a083", "commit_date": "Thu Sep 29 11:52:38 2022 +0200", "commit_message": "In DefaultImageScalingFactory call, get rid of the direction parameter early.", "files_name": ["plone/namedfile/scaling.py"]}], "windows_after": [{"commit_id": "f0f911f2a72b2e5c923dc2ab9179319cc47788f9", "commit_date": "Thu Sep 21 13:22:31 2023 +0200", "commit_message": "Merge pull request from GHSA-jj7c-jrv4-c65x", "files_name": ["81b20f8abc244cbefb0c3d4e367f14891998a4dd - Thu Sep 21 13:24:37 2023 +0200 : Preparing release 6.2.1", "CHANGES.rst", "news/1.bugfix", "setup.py"]}, {"commit_id": "48c5af884f401515b75322b91de3998463ae2074", "commit_date": "Thu Sep 21 13:24:55 2023 +0200", "commit_message": "Back to development: 6.2.2", "files_name": ["setup.py"]}, {"commit_id": "8e918168ae60f8fdbab64f697776e914e3bb5d44", "commit_date": "Tue Oct 17 20:30:21 2023 -0700", "commit_message": "Fix the modified property", "files_name": ["plone/namedfile/file.py", "plone/namedfile/tests/test_blobfile.py"]}, {"commit_id": "1a7588449bf21a6cb6d7a87933a370cf4052bd2c", "commit_date": "Tue Oct 17 20:36:04 2023 -0700", "commit_message": "changelog", "files_name": ["news/153.bugfix"]}, {"commit_id": "1cd966a0b5683ee06bb33987e193d05881eb8a79", "commit_date": "Wed Oct 18 11:39:10 2023 +0200", "commit_message": "Merge pull request #153 from plone/fix-modified", "files_name": ["6139432763282095d65d0f7d84b9de50dd893a05 - Wed Oct 18 15:04:20 2023 +0200 : Preparing release 6.2.2", "CHANGES.rst", "news/153.bugfix", "setup.py"]}, {"commit_id": "429171cc3c456b615ae91849d48d55a2d2c19027", "commit_date": "Wed Oct 18 15:04:51 2023 +0200", "commit_message": "Back to development: 6.2.3", "files_name": ["setup.py"]}, {"commit_id": "6687472bac29807942219a5fde4721f75fdb1132", "commit_date": "Fri Oct 27 02:20:31 2023 +0200", "commit_message": "Be more strict when checking if mimetype is allowed to be displayed inline.", "files_name": ["news/1167.bugfix", "plone/namedfile/browser.py", "plone/namedfile/scaling.py", "plone/namedfile/utils/__init__.py"]}, {"commit_id": "17dbec4aa50d86370af8328977808141bd90c094", "commit_date": "Fri Oct 27 09:32:21 2023 +0200", "commit_message": "Only define extract_media_type when we cannot import it from Zope.", "files_name": ["plone/namedfile/utils/__init__.py"]}, {"commit_id": "ff616cced3aca4651c0d4814e31b4d0001362420", "commit_date": "Fri Oct 27 09:35:08 2023 +0200", "commit_message": "Copy unit test for extract_media_type from Zope.", "files_name": ["plone/namedfile/tests/test_image.py"]}, {"commit_id": "17a21d40b7089bdc61162e5be8da36de0982eee3", "commit_date": "Sat Oct 28 10:00:32 2023 -0700", "commit_message": "Merge pull request #154 from plone/maurits-extract-media-type-master", "files_name": ["d4262ef2d694009f380486970688936ffcadec1e - Fri Nov 3 23:27:31 2023 +0100 : Preparing release 6.2.3", "CHANGES.rst", "news/1167.bugfix", "setup.py"]}, {"commit_id": "52fe93bc613d3450b5c7ac92504df331a5069140", "commit_date": "Fri Nov 3 23:28:04 2023 +0100", "commit_message": "Back to development: 6.2.4", "files_name": ["setup.py"]}, {"commit_id": "e8a44b8688e596a123b10a4a2e6ae48c82cdf140", "commit_date": "Fri Nov 3 23:29:04 2023 +0100", "commit_message": "setup.py: make description one string.", "files_name": ["setup.py"]}], "parents": [{"commit_id_before": "435816001d6b7b7e5a805e116571833e2db017f8", "url_before": "https://api.github.com/repos/plone/plone.namedfile/commits/435816001d6b7b7e5a805e116571833e2db017f8", "html_url_before": "https://github.com/plone/plone.namedfile/commit/435816001d6b7b7e5a805e116571833e2db017f8"}, {"commit_id_before": "776cb9b54241adff1fccd940c3d6abed35ca83e4", "url_before": "https://api.github.com/repos/plone/plone.namedfile/commits/776cb9b54241adff1fccd940c3d6abed35ca83e4", "html_url_before": "https://github.com/plone/plone.namedfile/commit/776cb9b54241adff1fccd940c3d6abed35ca83e4"}], "details": [{"raw_url": "https://github.com/plone/plone.namedfile/raw/ff5269fb4c79f4eb91dd934561b8824a49a03b60/news%2F1.bugfix", "code": "Fix stored XSS (Cross Site Scripting) for SVG images.\nDone by forcing a download instead of displaying inline.\nSee `security advisory <https://github.com/plone/plone.namedfile/security/advisories/GHSA-jj7c-jrv4-c65x>`_.\n[maurits]\n", "code_before": "Fix stored XSS (Cross Site Scripting) for SVG images.\nDone by forcing a download instead of displaying inline.\nSee `security advisory <https://github.com/plone/plone.namedfile/security/advisories/GHSA-jj7c-jrv4-c65x>`_.\n[maurits]\n", "patch": "@@ -0,0 +1,4 @@\n+Fix stored XSS (Cross Site Scripting) for SVG images.\n+Done by forcing a download instead of displaying inline.\n+See `security advisory <https://github.com/plone/plone.namedfile/security/advisories/GHSA-jj7c-jrv4-c65x>`_.\n+[maurits]", "file_path": "files/2023_9/179", "file_language": "bugfix", "file_name": "news/1.bugfix", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 1}, {"raw_url": "https://github.com/plone/plone.namedfile/raw/ff5269fb4c79f4eb91dd934561b8824a49a03b60/plone%2Fnamedfile%2Fscaling.py", "code": "# -*- coding: utf-8 -*-\nfrom AccessControl.ZopeGuards import guarded_getattr\nfrom Acquisition import aq_base\nfrom DateTime import DateTime\nfrom io import BytesIO\nfrom plone.memoize import ram\nfrom plone.namedfile.file import FILECHUNK_CLASSES\nfrom plone.namedfile.browser import ALLOWED_INLINE_MIMETYPES\nfrom plone.namedfile.browser import DISALLOWED_INLINE_MIMETYPES\nfrom plone.namedfile.browser import USE_DENYLIST\nfrom plone.namedfile.interfaces import IAvailableSizes\nfrom plone.namedfile.interfaces import IStableImageScale\nfrom plone.namedfile.utils import getHighPixelDensityScales\nfrom plone.namedfile.utils import set_headers\nfrom plone.namedfile.utils import stream_data\nfrom plone.protect.interfaces import IDisableCSRFProtection\nfrom plone.rfc822.interfaces import IPrimaryFieldInfo\nfrom plone.scale.interfaces import IImageScaleFactory\nfrom plone.scale.interfaces import IScaledImageQuality\nfrom plone.scale.scale import scaleImage\nfrom plone.scale.storage import AnnotationStorage\nfrom Products.CMFPlone.utils import safe_encode\nfrom Products.Five import BrowserView\nfrom xml.sax.saxutils import quoteattr\nfrom zExceptions import Unauthorized\nfrom ZODB.blob import BlobFile\nfrom ZODB.POSException import ConflictError\nfrom zope.component import queryUtility\nfrom zope.deprecation import deprecate\nfrom zope.interface import alsoProvides\nfrom zope.interface import implementer\nfrom zope.publisher.interfaces import IPublishTraverse\nfrom zope.publisher.interfaces import NotFound\nfrom zope.traversing.interfaces import ITraversable\nfrom zope.traversing.interfaces import TraversalError\n\nimport functools\nimport logging\nimport six\n\n\nlogger = logging.getLogger(__name__)\n_marker = object()\n\n\nclass ImageScale(BrowserView):\n    \"\"\" view used for rendering image scales \"\"\"\n\n    # Grant full access to this view even if the object being viewed is\n    # protected\n    # (it's okay because we explicitly validate access to the image attribute\n    # when we retrieve it)\n    __roles__ = (\"Anonymous\",)\n    __allow_access_to_unprotected_subobjects__ = 1\n    data = None\n\n    # You can control which mimetypes may be shown inline\n    # and which must always be downloaded, for security reasons.\n    # Make the configuration available on the class.\n    # Then subclasses can override this.\n    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n    use_denylist = USE_DENYLIST\n\n    def __init__(self, context, request, **info):\n        self.context = context\n        self.request = request\n        self.__dict__.update(**info)\n        if self.data is None:\n            self.data = getattr(self.context, self.fieldname)\n\n        url = self.context.absolute_url()\n        extension = self.data.contentType.split(\"/\")[-1].lower()\n        if self.data.contentType == \"image/svg+xml\":\n            extension = \"svg\"\n        if \"uid\" in info:\n            name = info[\"uid\"]\n        else:\n            name = info[\"fieldname\"]\n        self.__name__ = u\"{0}.{1}\".format(name, extension)\n        self.url = u\"{0}/@@images/{1}\".format(url, self.__name__)\n        self.srcset = info.get(\"srcset\", [])\n\n    def absolute_url(self):\n        return self.url\n\n    def srcset_attribute(self):\n        _srcset_attr = []\n        extension = self.data.contentType.split(\"/\")[-1].lower()\n        for scale in self.srcset:\n            _srcset_attr.append(\n                u\"{0}/@@images/{1}.{2} {3}x\".format(\n                    self.context.absolute_url(), scale[\"uid\"], extension, scale[\"scale\"]\n                )\n            )\n        srcset_attr = \", \".join(_srcset_attr)\n        return srcset_attr\n\n    def tag(\n        self,\n        height=_marker,\n        width=_marker,\n        alt=_marker,\n        css_class=None,\n        title=_marker,\n        **kwargs\n    ):\n        \"\"\"Create a tag including scale\n        \"\"\"\n        if height is _marker:\n            height = getattr(self, \"height\", self.data._height)\n        if width is _marker:\n            width = getattr(self, \"width\", self.data._width)\n\n        if alt is _marker:\n            alt = self.context.Title()\n        if title is _marker:\n            title = self.context.Title()\n\n        values = [\n            (\"src\", self.url),\n            (\"alt\", alt),\n            (\"title\", title),\n            (\"height\", height),\n            (\"width\", width),\n            (\"class\", css_class),\n        ]\n\n        srcset_attr = self.srcset_attribute()\n        if srcset_attr:\n            values.append((\"srcset\", srcset_attr))\n\n        values.extend(kwargs.items())\n\n        parts = [\"<img\"]\n        for k, v in values:\n            if v is None:\n                continue\n            if isinstance(v, int):\n                v = str(v)\n            elif isinstance(v, six.binary_type):\n                v = six.text_type(v, \"utf8\")\n            parts.append(u\"{0}={1}\".format(k, quoteattr(v)))\n        parts.append(\"/>\")\n\n        return u\" \".join(parts)\n\n    def validate_access(self):\n        fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))\n        guarded_getattr(self.context, fieldname)\n\n    def _should_force_download(self):\n        # If this returns True, the caller should call set_headers with a filename.\n        if not hasattr(self.data, \"contentType\"):\n            return\n        mimetype = self.data.contentType\n        if self.use_denylist:\n            # We explicitly deny a few mimetypes, and allow the rest.\n            return mimetype in self.disallowed_inline_mimetypes\n        # Use the allowlist.\n        # We only explicitly allow a few mimetypes, and deny the rest.\n        return mimetype not in self.allowed_inline_mimetypes\n\n    def set_headers(self, response=None):\n        # set headers for the image\n        image = self.data\n        if response is None:\n            response = self.request.response\n        filename = None\n        if self._should_force_download():\n            # We MUST pass a filename, even a dummy one if needed.\n            filename = getattr(image, \"filename\", getattr(self, \"filename\", None))\n            if filename is None:\n                filename = getattr(image, \"fieldname\", getattr(self, \"fieldname\", None))\n                if filename is None:\n                    filename = \"image.ext\"\n        set_headers(image, response, filename=filename)\n\n    def index_html(self):\n        \"\"\" download the image \"\"\"\n        self.validate_access()\n        self.set_headers()\n        return stream_data(self.data)\n\n    def manage_DAVget(self):\n        \"\"\"Get scale via webdav.\"\"\"\n        return self.manage_FTPget()\n\n    def manage_FTPget(self):\n        \"\"\"Get scale via ftp.\"\"\"\n        return self.index_html()\n\n    def __call__(self):\n        # avoid the need to prefix with nocall: in TAL\n        return self\n\n    def HEAD(self, REQUEST, RESPONSE=None):\n        \"\"\" Obtain metainformation about the image implied by the request\n            without transfer of the image itself\n        \"\"\"\n        self.validate_access()\n        self.set_headers(response=REQUEST.response)\n        return \"\"\n\n    HEAD.__roles__ = (\"Anonymous\",)\n\n\n@implementer(ITraversable)\nclass ImmutableTraverser(object):\n    def __init__(self, scale):\n        self.scale = scale\n\n    def traverse(self, name, furtherPath):\n        if furtherPath:\n            raise TraversalError(\"Do not know how to handle further path\")\n        else:\n            if self.scale:\n                return self.scale.tag()\n            else:\n                raise TraversalError(name)\n\n\n@implementer(IImageScaleFactory)\nclass DefaultImageScalingFactory(object):\n    def __init__(self, context):\n        self.context = context\n        # fieldname will be set for real in the __call__ method.\n        self.fieldname = None\n\n    def get_original_value(self):\n        \"\"\"Get the image value.\n\n        In most cases this will be a NamedBlobImage field.\n        \"\"\"\n        if self.fieldname is None:\n            primary = IPrimaryFieldInfo(self.context, None)\n            if primary is None:\n                return\n            self.fieldname = primary.fieldname\n        return getattr(self.context, self.fieldname, None)\n\n    def get_raw_data(self, orig_value):\n        \"\"\"Get the raw image data.\n\n        The result may be an open file, in which case it is the responsibility\n        of the caller to close it.  Or it may be a string.\n        \"\"\"\n        orig_data = None\n        try:\n            orig_data = orig_value.open()\n        except AttributeError:\n            orig_data = getattr(aq_base(orig_value), \"data\", orig_value)\n        if not orig_data:\n            return\n        # Handle cases where large image data is stored in FileChunks instead\n        # of plain string\n        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):\n            # Convert data to 8-bit string\n            # (FileChunk does not provide read() access)\n            orig_data = str(orig_data)\n        return orig_data\n\n    def url(self):\n        # url of the context\n        return self.context.absolute_url()\n\n    def get_quality(self):\n        \"\"\"Get plone.app.imaging's quality setting\"\"\"\n        getScaledImageQuality = queryUtility(IScaledImageQuality)\n        if getScaledImageQuality is None:\n            return None\n        return getScaledImageQuality()\n\n    def update_parameters(self, **parameters):\n        # If quality wasn't in the parameters, try the site's default scaling\n        # quality if it exists.\n        if \"quality\" not in parameters:\n            quality = self.get_quality()\n            if quality:\n                parameters[\"quality\"] = quality\n        return parameters\n\n    def create_scale(self, data, direction, height, width, **parameters):\n        return scaleImage(\n            data, direction=direction, height=height, width=width, **parameters\n        )\n\n    def handle_image(\n        self, orig_value, orig_data, direction, height, width, **parameters\n    ):\n        \"\"\"Return a scaled image, its mimetype format, and width and height.\"\"\"\n        if getattr(orig_value, \"contentType\", \"\") == \"image/svg+xml\":\n            # No need to scale, we can simply use the original data,\n            # but report a different width and height.\n            if isinstance(orig_data, (six.text_type)):\n                orig_data = safe_encode(orig_data)\n            if isinstance(orig_data, (bytes)):\n                orig_data = BytesIO(orig_data)\n            result = orig_data.read(), \"svg+xml\", (width, height)\n            return result\n        try:\n            result = self.create_scale(\n                orig_data, direction=direction, height=height, width=width, **parameters\n            )\n        except (ConflictError, KeyboardInterrupt):\n            raise\n        except Exception:\n            logger.exception(\n                'Could not scale \"{0!r}\" of {1!r}'.format(\n                    orig_value,\n                    self.url(),\n                ),\n            )\n            return\n        return result\n\n    def __call__(\n        self,\n        fieldname=None,\n        direction=\"thumbnail\",\n        height=None,\n        width=None,\n        scale=None,\n        **parameters\n    ):\n\n        \"\"\"Factory for image scales`.\n\n        Note: the 'scale' keyword argument is ignored.\n        You should pass a height and width.\n        \"\"\"\n        # Save self.fieldname for use in self.get_original_value\n        # and other methods where we do not pass the fieldname explicitly.\n        self.fieldname = fieldname\n        orig_value = self.get_original_value()\n        if orig_value is None:\n            return\n\n        if height is None and width is None:\n            # We don't seem to want an image, so we return nothing\n            # as image value (the first argument).\n            dummy, format_ = orig_value.contentType.split(\"/\", 1)\n            return None, format_, (orig_value._width, orig_value._height)\n        if (\n            not parameters\n            and height\n            and width\n            and height == getattr(orig_value, \"_height\", None)\n            and width == getattr(orig_value, \"_width\", None)\n        ):\n            # No special wishes, and the original image already has the\n            # requested height and width.  Return the original.\n            dummy, format_ = orig_value.contentType.split(\"/\", 1)\n            return orig_value, format_, (orig_value._width, orig_value._height)\n\n        orig_data = self.get_raw_data(orig_value)\n        if not orig_data:\n            return\n\n        parameters = self.update_parameters(**parameters)\n        try:\n            result = self.handle_image(\n                orig_value, orig_data, direction, height, width, **parameters\n            )\n        finally:\n            # Make sure the file is closed to avoid error:\n            # ZODB-5.5.1-py3.7.egg/ZODB/blob.py:339: ResourceWarning:\n            # unclosed file <_io.FileIO ... mode='rb' closefd=True>\n            if isinstance(orig_data, BlobFile):\n                orig_data.close()\n        if result is None:\n            return\n\n        # Note: the format may differ from the original.\n        # For example a TIFF may have been turned into a PNG.\n        data, format_, dimensions = result\n        mimetype = \"image/{0}\".format(format_.lower())\n        value = orig_value.__class__(\n            data, contentType=mimetype, filename=orig_value.filename,\n        )\n        value.fieldname = self.fieldname\n\n        return value, format_, dimensions\n\n\n@implementer(ITraversable, IPublishTraverse)\nclass ImageScaling(BrowserView):\n    \"\"\" view used for generating (and storing) image scales \"\"\"\n\n    # Ignore some stacks to help with accessing via webdav, otherwise you get a\n    # 404 NotFound error.\n    _ignored_stacks = (\"manage_DAVget\", \"manage_FTPget\")\n    _scale_view_class = ImageScale\n\n    def publishTraverse(self, request, name):\n        \"\"\" used for traversal via publisher, i.e. when using as a url \"\"\"\n        stack = request.get(\"TraversalRequestNameStack\")\n        image = None\n        if stack and stack[-1] not in self._ignored_stacks:\n            # field and scale name were given...\n            scale = stack.pop()\n            image = self.scale(name, scale)  # this is an aq-wrapped scale_view\n            if image:\n                return image\n        elif \"-\" in name:\n            # we got a uid...\n            if \".\" in name:\n                name, ext = name.rsplit(\".\", 1)\n            storage = AnnotationStorage(self.context)\n            info = storage.get(name)\n            if info is None:\n                raise NotFound(self, name, self.request)\n            scale_view = self._scale_view_class(self.context, self.request, **info)\n            alsoProvides(scale_view, IStableImageScale)\n            return scale_view\n        else:\n            # otherwise `name` must refer to a field...\n            if \".\" in name:\n                name, ext = name.rsplit(\".\", 1)\n            value = getattr(self.context, name)\n            scale_view = self._scale_view_class(\n                self.context, self.request, data=value, fieldname=name,\n            )\n            return scale_view\n        raise NotFound(self, name, self.request)\n\n    def traverse(self, name, furtherPath):\n        \"\"\" used for path traversal, i.e. in zope page templates \"\"\"\n        # validate access\n        value = self.guarded_orig_image(name)\n        if not furtherPath:\n            image = self._scale_view_class(\n                self.context, self.request, data=value, fieldname=name,\n            )\n        else:\n            return ImmutableTraverser(self.scale(name, furtherPath[-1]))\n\n        if image is not None:\n            return image.tag()\n        raise TraversalError(self, name)\n\n    _sizes = {}\n\n    @deprecate(\"use property available_sizes instead\")\n    def getAvailableSizes(self, fieldname=None):\n        if fieldname:\n            logger.warning(\n                \"fieldname was passed to deprecated getAvailableSizes, but \"\n                \"will be ignored.\",\n            )\n        return self.available_sizes\n\n    @property\n    def available_sizes(self):\n        # fieldname is ignored by default\n        sizes_util = queryUtility(IAvailableSizes)\n        if sizes_util is None:\n            return self._sizes\n        sizes = sizes_util()\n        if sizes is None:\n            return {}\n        return sizes\n\n    @available_sizes.setter\n    def available_sizes(self, value):\n        self._sizes = value\n\n    def getImageSize(self, fieldname=None):\n        if fieldname is not None:\n            try:\n                value = self.guarded_orig_image(fieldname)\n            except Unauthorized:\n                # This is a corner case that can be seen in some tests,\n                # at least plone.app.caching and plone.formwidget.namedfile.\n                # When it is *really* unauthorized to get this image,\n                # it will go wrong somewhere else.\n                value = None\n            if value is None:\n                return (0, 0)\n            return value.getImageSize()\n        value = IPrimaryFieldInfo(self.context).value\n        return value.getImageSize()\n\n    def guarded_orig_image(self, fieldname):\n        return guarded_getattr(self.context, fieldname, None)\n\n    @deprecate(\"use getHighPixelDensityScales instead\")\n    def getRetinaScales(self):\n        return getHighPixelDensityScales()\n\n    def getHighPixelDensityScales(self):\n        return getHighPixelDensityScales()\n\n    def modified(self, fieldname=None):\n        \"\"\"Provide a callable to return the modification time of content\n        items, so stored image scales can be invalidated.\n        \"\"\"\n        context = aq_base(self.context)\n        if fieldname is not None:\n            field = getattr(context, fieldname, None)\n            field_p_mtime = getattr(field, \"_p_mtime\", None)\n            date = DateTime(field_p_mtime or context._p_mtime)\n        else:\n            date = DateTime(context._p_mtime)\n        return date.millis()\n\n    def scale(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        **parameters\n    ):\n        if fieldname is None:\n            primary_field = IPrimaryFieldInfo(self.context, None)\n            if primary_field is None:\n                return  # 404\n            fieldname = primary_field.fieldname\n        if scale is not None:\n            if width is not None or height is not None:\n                logger.warn(\n                    \"A scale name and width/heigth are given. Those are\"\n                    \"mutually exclusive: solved by ignoring width/heigth and \"\n                    \"taking name\",\n                )\n            available = self.available_sizes\n            if scale not in available:\n                return None  # 404\n            width, height = available[scale]\n        if IDisableCSRFProtection and self.request is not None:\n            alsoProvides(self.request, IDisableCSRFProtection)\n        storage = AnnotationStorage(\n            self.context,\n            functools.partial(self.modified, fieldname)\n        )\n        info = storage.scale(\n            fieldname=fieldname,\n            height=height,\n            width=width,\n            direction=direction,\n            scale=scale,\n            **parameters\n        )\n        if info is None:\n            return  # 404\n\n        info[\"srcset\"] = self.calculate_srcset(\n            fieldname=fieldname,\n            height=height,\n            width=width,\n            direction=direction,\n            scale=scale,\n            storage=storage,\n            **parameters\n        )\n        info[\"fieldname\"] = fieldname\n        scale_view = self._scale_view_class(self.context, self.request, **info)\n        return scale_view\n\n    def calculate_srcset(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        storage=None,\n        **parameters\n    ):\n        srcset = []\n        if storage is None:\n            return srcset\n        (orig_width, orig_height) = self.getImageSize(fieldname)\n        for hdScale in self.getHighPixelDensityScales():\n            # Don't create retina scales larger than the source image.\n            if (height and orig_height and orig_height < height * hdScale[\"scale\"]) or (\n                width and orig_width and orig_width < width * hdScale[\"scale\"]\n            ):\n                continue\n            parameters[\"quality\"] = hdScale[\"quality\"]\n            scale_src = storage.scale(\n                fieldname=fieldname,\n                height=height * hdScale[\"scale\"] if height else height,\n                width=width * hdScale[\"scale\"] if width else width,\n                direction=direction,\n                **parameters\n            )\n            scale_src[\"scale\"] = hdScale[\"scale\"]\n            if scale_src is not None:\n                srcset.append(scale_src)\n        return srcset\n\n    def tag(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        **kwargs\n    ):\n        scale = self.scale(fieldname, scale, height, width, direction)\n        return scale.tag(**kwargs) if scale else None\n\n\nclass NavigationRootScaling(ImageScaling):\n    def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n        return (\n            self.context.absolute_url(),\n            brain.UID,\n            brain.modified,\n            fieldname,\n            kwargs,\n        )\n\n    @ram.cache(_scale_cachekey)\n    def tag(self, brain, fieldname, **kwargs):\n        obj = brain.getObject()\n        images = obj.restrictedTraverse(\"@@images\")\n        tag = images.tag(fieldname, **kwargs)\n        return tag\n", "code_before": "# -*- coding: utf-8 -*-\nfrom AccessControl.ZopeGuards import guarded_getattr\nfrom Acquisition import aq_base\nfrom DateTime import DateTime\nfrom io import BytesIO\nfrom plone.memoize import ram\nfrom plone.namedfile.file import FILECHUNK_CLASSES\nfrom plone.namedfile.browser import ALLOWED_INLINE_MIMETYPES\nfrom plone.namedfile.browser import DISALLOWED_INLINE_MIMETYPES\nfrom plone.namedfile.browser import USE_DENYLIST\nfrom plone.namedfile.interfaces import IAvailableSizes\nfrom plone.namedfile.interfaces import IStableImageScale\nfrom plone.namedfile.utils import getHighPixelDensityScales\nfrom plone.namedfile.utils import set_headers\nfrom plone.namedfile.utils import stream_data\nfrom plone.protect.interfaces import IDisableCSRFProtection\nfrom plone.rfc822.interfaces import IPrimaryFieldInfo\nfrom plone.scale.interfaces import IImageScaleFactory\nfrom plone.scale.interfaces import IScaledImageQuality\nfrom plone.scale.scale import scaleImage\nfrom plone.scale.storage import AnnotationStorage\nfrom Products.CMFPlone.utils import safe_encode\nfrom Products.Five import BrowserView\nfrom xml.sax.saxutils import quoteattr\nfrom zExceptions import Unauthorized\nfrom ZODB.blob import BlobFile\nfrom ZODB.POSException import ConflictError\nfrom zope.component import queryUtility\nfrom zope.deprecation import deprecate\nfrom zope.interface import alsoProvides\nfrom zope.interface import implementer\nfrom zope.publisher.interfaces import IPublishTraverse\nfrom zope.publisher.interfaces import NotFound\nfrom zope.traversing.interfaces import ITraversable\nfrom zope.traversing.interfaces import TraversalError\n\nimport functools\nimport logging\nimport six\n\n\nlogger = logging.getLogger(__name__)\n_marker = object()\n\n\nclass ImageScale(BrowserView):\n    \"\"\" view used for rendering image scales \"\"\"\n\n    # Grant full access to this view even if the object being viewed is\n    # protected\n    # (it's okay because we explicitly validate access to the image attribute\n    # when we retrieve it)\n    __roles__ = (\"Anonymous\",)\n    __allow_access_to_unprotected_subobjects__ = 1\n    data = None\n\n    # You can control which mimetypes may be shown inline\n    # and which must always be downloaded, for security reasons.\n    # Make the configuration available on the class.\n    # Then subclasses can override this.\n    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n    use_denylist = USE_DENYLIST\n\n    def __init__(self, context, request, **info):\n        self.context = context\n        self.request = request\n        self.__dict__.update(**info)\n        if self.data is None:\n            self.data = getattr(self.context, self.fieldname)\n\n        url = self.context.absolute_url()\n        extension = self.data.contentType.split(\"/\")[-1].lower()\n        if self.data.contentType == \"image/svg+xml\":\n            extension = \"svg\"\n        if \"uid\" in info:\n            name = info[\"uid\"]\n        else:\n            name = info[\"fieldname\"]\n        self.__name__ = u\"{0}.{1}\".format(name, extension)\n        self.url = u\"{0}/@@images/{1}\".format(url, self.__name__)\n        self.srcset = info.get(\"srcset\", [])\n\n    def absolute_url(self):\n        return self.url\n\n    def srcset_attribute(self):\n        _srcset_attr = []\n        extension = self.data.contentType.split(\"/\")[-1].lower()\n        for scale in self.srcset:\n            _srcset_attr.append(\n                u\"{0}/@@images/{1}.{2} {3}x\".format(\n                    self.context.absolute_url(), scale[\"uid\"], extension, scale[\"scale\"]\n                )\n            )\n        srcset_attr = \", \".join(_srcset_attr)\n        return srcset_attr\n\n    def tag(\n        self,\n        height=_marker,\n        width=_marker,\n        alt=_marker,\n        css_class=None,\n        title=_marker,\n        **kwargs\n    ):\n        \"\"\"Create a tag including scale\n        \"\"\"\n        if height is _marker:\n            height = getattr(self, \"height\", self.data._height)\n        if width is _marker:\n            width = getattr(self, \"width\", self.data._width)\n\n        if alt is _marker:\n            alt = self.context.Title()\n        if title is _marker:\n            title = self.context.Title()\n\n        values = [\n            (\"src\", self.url),\n            (\"alt\", alt),\n            (\"title\", title),\n            (\"height\", height),\n            (\"width\", width),\n            (\"class\", css_class),\n        ]\n\n        srcset_attr = self.srcset_attribute()\n        if srcset_attr:\n            values.append((\"srcset\", srcset_attr))\n\n        values.extend(kwargs.items())\n\n        parts = [\"<img\"]\n        for k, v in values:\n            if v is None:\n                continue\n            if isinstance(v, int):\n                v = str(v)\n            elif isinstance(v, six.binary_type):\n                v = six.text_type(v, \"utf8\")\n            parts.append(u\"{0}={1}\".format(k, quoteattr(v)))\n        parts.append(\"/>\")\n\n        return u\" \".join(parts)\n\n    def validate_access(self):\n        fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))\n        guarded_getattr(self.context, fieldname)\n\n    def _should_force_download(self):\n        # If this returns True, the caller should call set_headers with a filename.\n        if not hasattr(self.data, \"contentType\"):\n            return\n        mimetype = self.data.contentType\n        if self.use_denylist:\n            # We explicitly deny a few mimetypes, and allow the rest.\n            return mimetype in self.disallowed_inline_mimetypes\n        # Use the allowlist.\n        # We only explicitly allow a few mimetypes, and deny the rest.\n        return mimetype not in self.allowed_inline_mimetypes\n\n    def set_headers(self, response=None):\n        # set headers for the image\n        image = self.data\n        if response is None:\n            response = self.request.response\n        filename = None\n        if self._should_force_download():\n            # We MUST pass a filename, even a dummy one if needed.\n            filename = getattr(image, \"filename\", getattr(self, \"filename\", None))\n            if filename is None:\n                filename = getattr(image, \"fieldname\", getattr(self, \"fieldname\", None))\n                if filename is None:\n                    filename = \"image.ext\"\n        set_headers(image, response, filename=filename)\n\n    def index_html(self):\n        \"\"\" download the image \"\"\"\n        self.validate_access()\n        self.set_headers()\n        return stream_data(self.data)\n\n    def manage_DAVget(self):\n        \"\"\"Get scale via webdav.\"\"\"\n        return self.manage_FTPget()\n\n    def manage_FTPget(self):\n        \"\"\"Get scale via ftp.\"\"\"\n        return self.index_html()\n\n    def __call__(self):\n        # avoid the need to prefix with nocall: in TAL\n        return self\n\n    def HEAD(self, REQUEST, RESPONSE=None):\n        \"\"\" Obtain metainformation about the image implied by the request\n            without transfer of the image itself\n        \"\"\"\n        self.validate_access()\n        self.set_headers(response=REQUEST.response)\n        return \"\"\n\n    HEAD.__roles__ = (\"Anonymous\",)\n\n\n@implementer(ITraversable)\nclass ImmutableTraverser(object):\n    def __init__(self, scale):\n        self.scale = scale\n\n    def traverse(self, name, furtherPath):\n        if furtherPath:\n            raise TraversalError(\"Do not know how to handle further path\")\n        else:\n            if self.scale:\n                return self.scale.tag()\n            else:\n                raise TraversalError(name)\n\n\n@implementer(IImageScaleFactory)\nclass DefaultImageScalingFactory(object):\n    def __init__(self, context):\n        self.context = context\n        # fieldname will be set for real in the __call__ method.\n        self.fieldname = None\n\n    def get_original_value(self):\n        \"\"\"Get the image value.\n\n        In most cases this will be a NamedBlobImage field.\n        \"\"\"\n        if self.fieldname is None:\n            primary = IPrimaryFieldInfo(self.context, None)\n            if primary is None:\n                return\n            self.fieldname = primary.fieldname\n        return getattr(self.context, self.fieldname, None)\n\n    def get_raw_data(self, orig_value):\n        \"\"\"Get the raw image data.\n\n        The result may be an open file, in which case it is the responsibility\n        of the caller to close it.  Or it may be a string.\n        \"\"\"\n        orig_data = None\n        try:\n            orig_data = orig_value.open()\n        except AttributeError:\n            orig_data = getattr(aq_base(orig_value), \"data\", orig_value)\n        if not orig_data:\n            return\n        # Handle cases where large image data is stored in FileChunks instead\n        # of plain string\n        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):\n            # Convert data to 8-bit string\n            # (FileChunk does not provide read() access)\n            orig_data = str(orig_data)\n        return orig_data\n\n    def url(self):\n        # url of the context\n        return self.context.absolute_url()\n\n    def get_quality(self):\n        \"\"\"Get plone.app.imaging's quality setting\"\"\"\n        getScaledImageQuality = queryUtility(IScaledImageQuality)\n        if getScaledImageQuality is None:\n            return None\n        return getScaledImageQuality()\n\n    def update_parameters(self, **parameters):\n        # If quality wasn't in the parameters, try the site's default scaling\n        # quality if it exists.\n        if \"quality\" not in parameters:\n            quality = self.get_quality()\n            if quality:\n                parameters[\"quality\"] = quality\n        return parameters\n\n    def create_scale(self, data, direction, height, width, **parameters):\n        return scaleImage(\n            data, direction=direction, height=height, width=width, **parameters\n        )\n\n    def handle_image(\n        self, orig_value, orig_data, direction, height, width, **parameters\n    ):\n        \"\"\"Return a scaled image, its mimetype format, and width and height.\"\"\"\n        if getattr(orig_value, \"contentType\", \"\") == \"image/svg+xml\":\n            # No need to scale, we can simply use the original data,\n            # but report a different width and height.\n            if isinstance(orig_data, (six.text_type)):\n                orig_data = safe_encode(orig_data)\n            if isinstance(orig_data, (bytes)):\n                orig_data = BytesIO(orig_data)\n            result = orig_data.read(), \"svg+xml\", (width, height)\n            return result\n        try:\n            result = self.create_scale(\n                orig_data, direction=direction, height=height, width=width, **parameters\n            )\n        except (ConflictError, KeyboardInterrupt):\n            raise\n        except Exception:\n            logger.exception(\n                'Could not scale \"{0!r}\" of {1!r}'.format(\n                    orig_value,\n                    self.url(),\n                ),\n            )\n            return\n        return result\n\n    def __call__(\n        self,\n        fieldname=None,\n        direction=\"thumbnail\",\n        height=None,\n        width=None,\n        scale=None,\n        **parameters\n    ):\n\n        \"\"\"Factory for image scales`.\n\n        Note: the 'scale' keyword argument is ignored.\n        You should pass a height and width.\n        \"\"\"\n        # Save self.fieldname for use in self.get_original_value\n        # and other methods where we do not pass the fieldname explicitly.\n        self.fieldname = fieldname\n        orig_value = self.get_original_value()\n        if orig_value is None:\n            return\n\n        if height is None and width is None:\n            # We don't seem to want an image, so we return nothing\n            # as image value (the first argument).\n            dummy, format_ = orig_value.contentType.split(\"/\", 1)\n            return None, format_, (orig_value._width, orig_value._height)\n        if (\n            not parameters\n            and height\n            and width\n            and height == getattr(orig_value, \"_height\", None)\n            and width == getattr(orig_value, \"_width\", None)\n        ):\n            # No special wishes, and the original image already has the\n            # requested height and width.  Return the original.\n            dummy, format_ = orig_value.contentType.split(\"/\", 1)\n            return orig_value, format_, (orig_value._width, orig_value._height)\n\n        orig_data = self.get_raw_data(orig_value)\n        if not orig_data:\n            return\n\n        parameters = self.update_parameters(**parameters)\n        try:\n            result = self.handle_image(\n                orig_value, orig_data, direction, height, width, **parameters\n            )\n        finally:\n            # Make sure the file is closed to avoid error:\n            # ZODB-5.5.1-py3.7.egg/ZODB/blob.py:339: ResourceWarning:\n            # unclosed file <_io.FileIO ... mode='rb' closefd=True>\n            if isinstance(orig_data, BlobFile):\n                orig_data.close()\n        if result is None:\n            return\n\n        # Note: the format may differ from the original.\n        # For example a TIFF may have been turned into a PNG.\n        data, format_, dimensions = result\n        mimetype = \"image/{0}\".format(format_.lower())\n        value = orig_value.__class__(\n            data, contentType=mimetype, filename=orig_value.filename,\n        )\n        value.fieldname = self.fieldname\n\n        return value, format_, dimensions\n\n\n@implementer(ITraversable, IPublishTraverse)\nclass ImageScaling(BrowserView):\n    \"\"\" view used for generating (and storing) image scales \"\"\"\n\n    # Ignore some stacks to help with accessing via webdav, otherwise you get a\n    # 404 NotFound error.\n    _ignored_stacks = (\"manage_DAVget\", \"manage_FTPget\")\n    _scale_view_class = ImageScale\n\n    def publishTraverse(self, request, name):\n        \"\"\" used for traversal via publisher, i.e. when using as a url \"\"\"\n        stack = request.get(\"TraversalRequestNameStack\")\n        image = None\n        if stack and stack[-1] not in self._ignored_stacks:\n            # field and scale name were given...\n            scale = stack.pop()\n            image = self.scale(name, scale)  # this is an aq-wrapped scale_view\n            if image:\n                return image\n        elif \"-\" in name:\n            # we got a uid...\n            if \".\" in name:\n                name, ext = name.rsplit(\".\", 1)\n            storage = AnnotationStorage(self.context)\n            info = storage.get(name)\n            if info is None:\n                raise NotFound(self, name, self.request)\n            scale_view = self._scale_view_class(self.context, self.request, **info)\n            alsoProvides(scale_view, IStableImageScale)\n            return scale_view\n        else:\n            # otherwise `name` must refer to a field...\n            if \".\" in name:\n                name, ext = name.rsplit(\".\", 1)\n            value = getattr(self.context, name)\n            scale_view = self._scale_view_class(\n                self.context, self.request, data=value, fieldname=name,\n            )\n            return scale_view\n        raise NotFound(self, name, self.request)\n\n    def traverse(self, name, furtherPath):\n        \"\"\" used for path traversal, i.e. in zope page templates \"\"\"\n        # validate access\n        value = self.guarded_orig_image(name)\n        if not furtherPath:\n            image = self._scale_view_class(\n                self.context, self.request, data=value, fieldname=name,\n            )\n        else:\n            return ImmutableTraverser(self.scale(name, furtherPath[-1]))\n\n        if image is not None:\n            return image.tag()\n        raise TraversalError(self, name)\n\n    _sizes = {}\n\n    @deprecate(\"use property available_sizes instead\")\n    def getAvailableSizes(self, fieldname=None):\n        if fieldname:\n            logger.warning(\n                \"fieldname was passed to deprecated getAvailableSizes, but \"\n                \"will be ignored.\",\n            )\n        return self.available_sizes\n\n    @property\n    def available_sizes(self):\n        # fieldname is ignored by default\n        sizes_util = queryUtility(IAvailableSizes)\n        if sizes_util is None:\n            return self._sizes\n        sizes = sizes_util()\n        if sizes is None:\n            return {}\n        return sizes\n\n    @available_sizes.setter\n    def available_sizes(self, value):\n        self._sizes = value\n\n    def getImageSize(self, fieldname=None):\n        if fieldname is not None:\n            try:\n                value = self.guarded_orig_image(fieldname)\n            except Unauthorized:\n                # This is a corner case that can be seen in some tests,\n                # at least plone.app.caching and plone.formwidget.namedfile.\n                # When it is *really* unauthorized to get this image,\n                # it will go wrong somewhere else.\n                value = None\n            if value is None:\n                return (0, 0)\n            return value.getImageSize()\n        value = IPrimaryFieldInfo(self.context).value\n        return value.getImageSize()\n\n    def guarded_orig_image(self, fieldname):\n        return guarded_getattr(self.context, fieldname, None)\n\n    @deprecate(\"use getHighPixelDensityScales instead\")\n    def getRetinaScales(self):\n        return getHighPixelDensityScales()\n\n    def getHighPixelDensityScales(self):\n        return getHighPixelDensityScales()\n\n    def modified(self, fieldname=None):\n        \"\"\"Provide a callable to return the modification time of content\n        items, so stored image scales can be invalidated.\n        \"\"\"\n        context = aq_base(self.context)\n        if fieldname is not None:\n            field = getattr(context, fieldname, None)\n            field_p_mtime = getattr(field, \"_p_mtime\", None)\n            date = DateTime(field_p_mtime or context._p_mtime)\n        else:\n            date = DateTime(context._p_mtime)\n        return date.millis()\n\n    def scale(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        **parameters\n    ):\n        if fieldname is None:\n            primary_field = IPrimaryFieldInfo(self.context, None)\n            if primary_field is None:\n                return  # 404\n            fieldname = primary_field.fieldname\n        if scale is not None:\n            if width is not None or height is not None:\n                logger.warn(\n                    \"A scale name and width/heigth are given. Those are\"\n                    \"mutually exclusive: solved by ignoring width/heigth and \"\n                    \"taking name\",\n                )\n            available = self.available_sizes\n            if scale not in available:\n                return None  # 404\n            width, height = available[scale]\n        if IDisableCSRFProtection and self.request is not None:\n            alsoProvides(self.request, IDisableCSRFProtection)\n        storage = AnnotationStorage(\n            self.context,\n            functools.partial(self.modified, fieldname)\n        )\n        info = storage.scale(\n            fieldname=fieldname,\n            height=height,\n            width=width,\n            direction=direction,\n            scale=scale,\n            **parameters\n        )\n        if info is None:\n            return  # 404\n\n        info[\"srcset\"] = self.calculate_srcset(\n            fieldname=fieldname,\n            height=height,\n            width=width,\n            direction=direction,\n            scale=scale,\n            storage=storage,\n            **parameters\n        )\n        info[\"fieldname\"] = fieldname\n        scale_view = self._scale_view_class(self.context, self.request, **info)\n        return scale_view\n\n    def calculate_srcset(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        storage=None,\n        **parameters\n    ):\n        srcset = []\n        if storage is None:\n            return srcset\n        (orig_width, orig_height) = self.getImageSize(fieldname)\n        for hdScale in self.getHighPixelDensityScales():\n            # Don't create retina scales larger than the source image.\n            if (height and orig_height and orig_height < height * hdScale[\"scale\"]) or (\n                width and orig_width and orig_width < width * hdScale[\"scale\"]\n            ):\n                continue\n            parameters[\"quality\"] = hdScale[\"quality\"]\n            scale_src = storage.scale(\n                fieldname=fieldname,\n                height=height * hdScale[\"scale\"] if height else height,\n                width=width * hdScale[\"scale\"] if width else width,\n                direction=direction,\n                **parameters\n            )\n            scale_src[\"scale\"] = hdScale[\"scale\"]\n            if scale_src is not None:\n                srcset.append(scale_src)\n        return srcset\n\n    def tag(\n        self,\n        fieldname=None,\n        scale=None,\n        height=None,\n        width=None,\n        direction=\"thumbnail\",\n        **kwargs\n    ):\n        scale = self.scale(fieldname, scale, height, width, direction)\n        return scale.tag(**kwargs) if scale else None\n\n\nclass NavigationRootScaling(ImageScaling):\n    def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n        return (\n            self.context.absolute_url(),\n            brain.UID,\n            brain.modified,\n            fieldname,\n            kwargs,\n        )\n\n    @ram.cache(_scale_cachekey)\n    def tag(self, brain, fieldname, **kwargs):\n        obj = brain.getObject()\n        images = obj.restrictedTraverse(\"@@images\")\n        tag = images.tag(fieldname, **kwargs)\n        return tag\n", "patch": "@@ -5,6 +5,9 @@\n from io import BytesIO\n from plone.memoize import ram\n from plone.namedfile.file import FILECHUNK_CLASSES\n+from plone.namedfile.browser import ALLOWED_INLINE_MIMETYPES\n+from plone.namedfile.browser import DISALLOWED_INLINE_MIMETYPES\n+from plone.namedfile.browser import USE_DENYLIST\n from plone.namedfile.interfaces import IAvailableSizes\n from plone.namedfile.interfaces import IStableImageScale\n from plone.namedfile.utils import getHighPixelDensityScales\n@@ -51,6 +54,14 @@ class ImageScale(BrowserView):\n     __allow_access_to_unprotected_subobjects__ = 1\n     data = None\n \n+    # You can control which mimetypes may be shown inline\n+    # and which must always be downloaded, for security reasons.\n+    # Make the configuration available on the class.\n+    # Then subclasses can override this.\n+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n+    use_denylist = USE_DENYLIST\n+\n     def __init__(self, context, request, **info):\n         self.context = context\n         self.request = request\n@@ -138,10 +149,37 @@ def validate_access(self):\n         fieldname = getattr(self.data, \"fieldname\", getattr(self, \"fieldname\", None))\n         guarded_getattr(self.context, fieldname)\n \n+    def _should_force_download(self):\n+        # If this returns True, the caller should call set_headers with a filename.\n+        if not hasattr(self.data, \"contentType\"):\n+            return\n+        mimetype = self.data.contentType\n+        if self.use_denylist:\n+            # We explicitly deny a few mimetypes, and allow the rest.\n+            return mimetype in self.disallowed_inline_mimetypes\n+        # Use the allowlist.\n+        # We only explicitly allow a few mimetypes, and deny the rest.\n+        return mimetype not in self.allowed_inline_mimetypes\n+\n+    def set_headers(self, response=None):\n+        # set headers for the image\n+        image = self.data\n+        if response is None:\n+            response = self.request.response\n+        filename = None\n+        if self._should_force_download():\n+            # We MUST pass a filename, even a dummy one if needed.\n+            filename = getattr(image, \"filename\", getattr(self, \"filename\", None))\n+            if filename is None:\n+                filename = getattr(image, \"fieldname\", getattr(self, \"fieldname\", None))\n+                if filename is None:\n+                    filename = \"image.ext\"\n+        set_headers(image, response, filename=filename)\n+\n     def index_html(self):\n         \"\"\" download the image \"\"\"\n         self.validate_access()\n-        set_headers(self.data, self.request.response)\n+        self.set_headers()\n         return stream_data(self.data)\n \n     def manage_DAVget(self):\n@@ -161,7 +199,7 @@ def HEAD(self, REQUEST, RESPONSE=None):\n             without transfer of the image itself\n         \"\"\"\n         self.validate_access()\n-        set_headers(self.data, REQUEST.response)\n+        self.set_headers(response=REQUEST.response)\n         return \"\"\n \n     HEAD.__roles__ = (\"Anonymous\",)", "file_path": "files/2023_9/180", "file_language": "py", "file_name": "plone/namedfile/scaling.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/plone/plone.namedfile/raw/ff5269fb4c79f4eb91dd934561b8824a49a03b60/plone%2Fnamedfile%2Ftests%2Ftest_display_file.py", "code": "# -*- coding: utf-8 -*-\nfrom OFS.SimpleItem import SimpleItem\nfrom plone.app.testing import SITE_OWNER_NAME\nfrom plone.app.testing import SITE_OWNER_PASSWORD\nfrom plone.namedfile import field\nfrom plone.namedfile import file\nfrom plone.namedfile.interfaces import IAvailableSizes\nfrom plone.namedfile.interfaces import IImageScaleTraversable\nfrom plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING\nfrom plone.namedfile.tests import getFile\nfrom plone.testing.zope import Browser\nfrom Products.CMFPlone.utils import safe_unicode\nfrom zope.annotation import IAnnotations\nfrom zope.annotation import IAttributeAnnotatable\nfrom zope.component import getSiteManager\nfrom zope.interface import implementer\n\nimport os\nimport transaction\nimport unittest\n\n\nclass ISchema(IImageScaleTraversable):\n    image = field.NamedImage()\n    blob_image = field.NamedBlobImage()\n    file = field.NamedFile()\n    blob_file = field.NamedBlobFile()\n\n\n@implementer(IAttributeAnnotatable, ISchema)\nclass DummyContent(SimpleItem):\n    # Adapted from test_scaling_functional.py\n    image = None\n    blob_image = None\n    file = None\n    blob_file = None\n    # modified = DateTime\n    id = __name__ = \"item\"\n    title = \"foo\"\n\n    def Title(self):\n        return self.title\n\n\ndef get_disposition_header(browser):\n    # Could be CamelCase or all lowercase.\n    name = \"Content-Disposition\"\n    if name in browser.headers.keys():\n        return browser.headers.get(name)\n    name = name.lower()\n    return browser.headers.get(name, None)\n\n\ndef custom_available_sizes():\n    # Define available image scales.\n    return {\"custom\": (10, 10)}\n\n\nclass TestAttackVectorNamedImage(unittest.TestCase):\n    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n    field_class = file.NamedImage\n    field_name = \"image\"\n\n    def setUp(self):\n        self.portal = self.layer[\"app\"]\n        item = DummyContent()\n        self.layer[\"app\"]._setOb(\"item\", item)\n        self.item = self.layer[\"app\"].item\n        sm = getSiteManager()\n        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)\n\n    def tearDown(self):\n        sm = getSiteManager()\n        sm.unregisterUtility(provided=IAvailableSizes)\n\n    def get_admin_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        browser.addHeader(\n            \"Authorization\",\n            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n        )\n        return browser\n\n    def get_anon_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        return browser\n\n    def _named_file(self, name):\n        data = getFile(name)\n        return self.field_class(data, filename=safe_unicode(name))\n\n    def assert_download_works(self, base_url):\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_display_inline_works(self, base_url):\n        # Test that displaying this file inline works.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_display_inline_is_download(self, base_url):\n        # Test that displaying this file inline turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_scale_view_works(self, base_url):\n        # Test that accessing a scale view shows the image inline.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        # Note: the 'custom' scale is defined in an adapter above.\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_scale_view_is_download(self, base_url):\n        # Test that accessing a scale view turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def test_png_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.png\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_works(base_url)\n\n    def test_svg_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_none(self):\n        # A 'None' filename probably does not happen during normal upload,\n        # but if an attacker manages this, even @@download would show inline.\n        # We prevent this.\n        data = self._named_file(\"image.svg\")\n        data.filename = None\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_empty(self):\n        # An empty filename is probably no problem, but let's check.\n        data = self._named_file(\"image.svg\")\n        data.filename = u\"\"\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n\nclass TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n    field_class = file.NamedBlobImage\n\n\nclass TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n    field_class = file.NamedFile\n    field_name = \"file\"\n\n    def test_html_file(self):\n        data = self.field_class(\n            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")\n        )\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n\n    def test_pdf(self):\n        # By popular request we allow PDF.\n        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n\n\nclass TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n    field_class = file.NamedBlobFile\n", "code_before": "# -*- coding: utf-8 -*-\nfrom OFS.SimpleItem import SimpleItem\nfrom plone.app.testing import SITE_OWNER_NAME\nfrom plone.app.testing import SITE_OWNER_PASSWORD\nfrom plone.namedfile import field\nfrom plone.namedfile import file\nfrom plone.namedfile.interfaces import IAvailableSizes\nfrom plone.namedfile.interfaces import IImageScaleTraversable\nfrom plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING\nfrom plone.namedfile.tests import getFile\nfrom plone.testing.zope import Browser\nfrom Products.CMFPlone.utils import safe_unicode\nfrom zope.annotation import IAnnotations\nfrom zope.annotation import IAttributeAnnotatable\nfrom zope.component import getSiteManager\nfrom zope.interface import implementer\n\nimport os\nimport transaction\nimport unittest\n\n\nclass ISchema(IImageScaleTraversable):\n    image = field.NamedImage()\n    blob_image = field.NamedBlobImage()\n    file = field.NamedFile()\n    blob_file = field.NamedBlobFile()\n\n\n@implementer(IAttributeAnnotatable, ISchema)\nclass DummyContent(SimpleItem):\n    # Adapted from test_scaling_functional.py\n    image = None\n    blob_image = None\n    file = None\n    blob_file = None\n    # modified = DateTime\n    id = __name__ = \"item\"\n    title = \"foo\"\n\n    def Title(self):\n        return self.title\n\n\ndef get_disposition_header(browser):\n    # Could be CamelCase or all lowercase.\n    name = \"Content-Disposition\"\n    if name in browser.headers.keys():\n        return browser.headers.get(name)\n    name = name.lower()\n    return browser.headers.get(name, None)\n\n\ndef custom_available_sizes():\n    # Define available image scales.\n    return {\"custom\": (10, 10)}\n\n\nclass TestAttackVectorNamedImage(unittest.TestCase):\n    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n    field_class = file.NamedImage\n    field_name = \"image\"\n\n    def setUp(self):\n        self.portal = self.layer[\"app\"]\n        item = DummyContent()\n        self.layer[\"app\"]._setOb(\"item\", item)\n        self.item = self.layer[\"app\"].item\n        sm = getSiteManager()\n        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)\n\n    def tearDown(self):\n        sm = getSiteManager()\n        sm.unregisterUtility(provided=IAvailableSizes)\n\n    def get_admin_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        browser.addHeader(\n            \"Authorization\",\n            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n        )\n        return browser\n\n    def get_anon_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        return browser\n\n    def _named_file(self, name):\n        data = getFile(name)\n        return self.field_class(data, filename=safe_unicode(name))\n\n    def assert_download_works(self, base_url):\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_display_inline_works(self, base_url):\n        # Test that displaying this file inline works.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_display_inline_is_download(self, base_url):\n        # Test that displaying this file inline turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_scale_view_works(self, base_url):\n        # Test that accessing a scale view shows the image inline.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        # Note: the 'custom' scale is defined in an adapter above.\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_scale_view_is_download(self, base_url):\n        # Test that accessing a scale view turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def test_png_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.png\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_works(base_url)\n\n    def test_svg_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_none(self):\n        # A 'None' filename probably does not happen during normal upload,\n        # but if an attacker manages this, even @@download would show inline.\n        # We prevent this.\n        data = self._named_file(\"image.svg\")\n        data.filename = None\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_empty(self):\n        # An empty filename is probably no problem, but let's check.\n        data = self._named_file(\"image.svg\")\n        data.filename = u\"\"\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n\nclass TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n    field_class = file.NamedBlobImage\n\n\nclass TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n    field_class = file.NamedFile\n    field_name = \"file\"\n\n    def test_html_file(self):\n        data = self.field_class(\n            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")\n        )\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n\n    def test_pdf(self):\n        # By popular request we allow PDF.\n        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n\n\nclass TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n    field_class = file.NamedBlobFile\n", "patch": "@@ -4,12 +4,15 @@\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.namedfile import field\n from plone.namedfile import file\n+from plone.namedfile.interfaces import IAvailableSizes\n from plone.namedfile.interfaces import IImageScaleTraversable\n from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n from plone.namedfile.tests import getFile\n from plone.testing.zope import Browser\n from Products.CMFPlone.utils import safe_unicode\n+from zope.annotation import IAnnotations\n from zope.annotation import IAttributeAnnotatable\n+from zope.component import getSiteManager\n from zope.interface import implementer\n \n import os\n@@ -48,6 +51,11 @@ def get_disposition_header(browser):\n     return browser.headers.get(name, None)\n \n \n+def custom_available_sizes():\n+    # Define available image scales.\n+    return {\"custom\": (10, 10)}\n+\n+\n class TestAttackVectorNamedImage(unittest.TestCase):\n     layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n     field_class = file.NamedImage\n@@ -58,6 +66,12 @@ def setUp(self):\n         item = DummyContent()\n         self.layer[\"app\"]._setOb(\"item\", item)\n         self.item = self.layer[\"app\"].item\n+        sm = getSiteManager()\n+        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)\n+\n+    def tearDown(self):\n+        sm = getSiteManager()\n+        sm.unregisterUtility(provided=IAvailableSizes)\n \n     def get_admin_browser(self):\n         browser = Browser(self.layer[\"app\"])\n@@ -100,30 +114,73 @@ def assert_display_inline_is_download(self, base_url):\n         self.assertIn(\"attachment\", header)\n         self.assertIn(\"filename\", header)\n \n+    def assert_scale_view_works(self, base_url):\n+        # Test that accessing a scale view shows the image inline.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n+        self.assertIsNone(get_disposition_header(browser))\n+\n+        # Note: the 'custom' scale is defined in an adapter above.\n+        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n+        self.assertIsNone(get_disposition_header(browser))\n+\n+        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n+        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n+        self.assertIsNone(get_disposition_header(browser))\n+\n+    def assert_scale_view_is_download(self, base_url):\n+        # Test that accessing a scale view turns into a download.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn(\"attachment\", header)\n+        self.assertIn(\"filename\", header)\n+\n+        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn(\"attachment\", header)\n+        self.assertIn(\"filename\", header)\n+\n+        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n+        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn(\"attachment\", header)\n+        self.assertIn(\"filename\", header)\n+\n     def test_png_image(self):\n         setattr(self.item, self.field_name, self._named_file(\"image.png\"))\n         transaction.commit()\n         base_url = self.item.absolute_url()\n         self.assert_download_works(base_url)\n         self.assert_display_inline_works(base_url)\n+        if self.field_name == \"image\":\n+            self.assert_scale_view_works(base_url)\n \n     def test_svg_image(self):\n         setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n         transaction.commit()\n         base_url = self.item.absolute_url()\n         self.assert_download_works(base_url)\n         self.assert_display_inline_is_download(base_url)\n+        if self.field_name == \"image\":\n+            self.assert_scale_view_is_download(base_url)\n \n     def test_filename_none(self):\n-        # A 'None' filename None probably does not happen during normal upload,\n-        # but if an attacker manages this, even @@download will show inline.\n+        # A 'None' filename probably does not happen during normal upload,\n+        # but if an attacker manages this, even @@download would show inline.\n+        # We prevent this.\n         data = self._named_file(\"image.svg\")\n         data.filename = None\n         setattr(self.item, self.field_name, data)\n         transaction.commit()\n         base_url = self.item.absolute_url()\n         self.assert_download_works(base_url)\n         self.assert_display_inline_is_download(base_url)\n+        if self.field_name == \"image\":\n+            self.assert_scale_view_is_download(base_url)\n \n     def test_filename_empty(self):\n         # An empty filename is probably no problem, but let's check.\n@@ -134,6 +191,8 @@ def test_filename_empty(self):\n         base_url = self.item.absolute_url()\n         self.assert_download_works(base_url)\n         self.assert_display_inline_is_download(base_url)\n+        if self.field_name == \"image\":\n+            self.assert_scale_view_is_download(base_url)\n \n \n class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):", "file_path": "files/2023_9/181", "file_language": "py", "file_name": "plone/namedfile/tests/test_display_file.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class ISchema(IImageScaleTraversable):\n    image = field.NamedImage()\n    blob_image = field.NamedBlobImage()\n    file = field.NamedFile()\n    blob_file = field.NamedBlobFile()", "target": 0}, {"function": "def get_disposition_header(browser):\n    # Could be CamelCase or all lowercase.\n    name = \"Content-Disposition\"\n    if name in browser.headers.keys():\n        return browser.headers.get(name)\n    name = name.lower()\n    return browser.headers.get(name, None)", "target": 0}, {"function": "def custom_available_sizes():\n    # Define available image scales.\n    return {\"custom\": (10, 10)}", "target": 0}, {"function": "class TestAttackVectorNamedImage(unittest.TestCase):\n    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n    field_class = file.NamedImage\n    field_name = \"image\"\n\n    def setUp(self):\n        self.portal = self.layer[\"app\"]\n        item = DummyContent()\n        self.layer[\"app\"]._setOb(\"item\", item)\n        self.item = self.layer[\"app\"].item\n        sm = getSiteManager()\n        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)\n\n    def tearDown(self):\n        sm = getSiteManager()\n        sm.unregisterUtility(provided=IAvailableSizes)\n\n    def get_admin_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        browser.addHeader(\n            \"Authorization\",\n            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n        )\n        return browser\n\n    def get_anon_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        return browser\n\n    def _named_file(self, name):\n        data = getFile(name)\n        return self.field_class(data, filename=safe_unicode(name))\n\n    def assert_download_works(self, base_url):\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_display_inline_works(self, base_url):\n        # Test that displaying this file inline works.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_display_inline_is_download(self, base_url):\n        # Test that displaying this file inline turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_scale_view_works(self, base_url):\n        # Test that accessing a scale view shows the image inline.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        # Note: the 'custom' scale is defined in an adapter above.\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_scale_view_is_download(self, base_url):\n        # Test that accessing a scale view turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def test_png_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.png\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_works(base_url)\n\n    def test_svg_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_none(self):\n        # A 'None' filename probably does not happen during normal upload,\n        # but if an attacker manages this, even @@download would show inline.\n        # We prevent this.\n        data = self._named_file(\"image.svg\")\n        data.filename = None\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_empty(self):\n        # An empty filename is probably no problem, but let's check.\n        data = self._named_file(\"image.svg\")\n        data.filename = u\"\"\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)", "target": 0}, {"function": "class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n    field_class = file.NamedBlobImage", "target": 0}, {"function": "class TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n    field_class = file.NamedFile\n    field_name = \"file\"\n\n    def test_html_file(self):\n        data = self.field_class(\n            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")\n        )\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n\n    def test_pdf(self):\n        # By popular request we allow PDF.\n        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)", "target": 0}, {"function": "class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n    field_class = file.NamedBlobFile", "target": 0}], "function_after": [{"function": "class ISchema(IImageScaleTraversable):\n    image = field.NamedImage()\n    blob_image = field.NamedBlobImage()\n    file = field.NamedFile()\n    blob_file = field.NamedBlobFile()", "target": 0}, {"function": "def get_disposition_header(browser):\n    # Could be CamelCase or all lowercase.\n    name = \"Content-Disposition\"\n    if name in browser.headers.keys():\n        return browser.headers.get(name)\n    name = name.lower()\n    return browser.headers.get(name, None)", "target": 0}, {"function": "def custom_available_sizes():\n    # Define available image scales.\n    return {\"custom\": (10, 10)}", "target": 0}, {"function": "class TestAttackVectorNamedImage(unittest.TestCase):\n    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n    field_class = file.NamedImage\n    field_name = \"image\"\n\n    def setUp(self):\n        self.portal = self.layer[\"app\"]\n        item = DummyContent()\n        self.layer[\"app\"]._setOb(\"item\", item)\n        self.item = self.layer[\"app\"].item\n        sm = getSiteManager()\n        sm.registerUtility(component=custom_available_sizes, provided=IAvailableSizes)\n\n    def tearDown(self):\n        sm = getSiteManager()\n        sm.unregisterUtility(provided=IAvailableSizes)\n\n    def get_admin_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        browser.addHeader(\n            \"Authorization\",\n            \"Basic {0}:{1}\".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n        )\n        return browser\n\n    def get_anon_browser(self):\n        browser = Browser(self.layer[\"app\"])\n        browser.handleErrors = False\n        return browser\n\n    def _named_file(self, name):\n        data = getFile(name)\n        return self.field_class(data, filename=safe_unicode(name))\n\n    def assert_download_works(self, base_url):\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@download/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_display_inline_works(self, base_url):\n        # Test that displaying this file inline works.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_display_inline_is_download(self, base_url):\n        # Test that displaying this file inline turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@display-file/{0}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def assert_scale_view_works(self, base_url):\n        # Test that accessing a scale view shows the image inline.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        # Note: the 'custom' scale is defined in an adapter above.\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        self.assertIsNone(get_disposition_header(browser))\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        self.assertIsNone(get_disposition_header(browser))\n\n    def assert_scale_view_is_download(self, base_url):\n        # Test that accessing a scale view turns into a download.\n        browser = self.get_anon_browser()\n        browser.open(base_url + \"/@@images/{}\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        browser.open(base_url + \"/@@images/{}/custom\".format(self.field_name))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n        unique_scale_id = list(IAnnotations(self.item)[\"plone.scale\"].keys())[0]\n        browser.open(base_url + \"/@@images/{}\".format(unique_scale_id))\n        header = get_disposition_header(browser)\n        self.assertIsNotNone(header)\n        self.assertIn(\"attachment\", header)\n        self.assertIn(\"filename\", header)\n\n    def test_png_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.png\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_works(base_url)\n\n    def test_svg_image(self):\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_none(self):\n        # A 'None' filename probably does not happen during normal upload,\n        # but if an attacker manages this, even @@download would show inline.\n        # We prevent this.\n        data = self._named_file(\"image.svg\")\n        data.filename = None\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)\n\n    def test_filename_empty(self):\n        # An empty filename is probably no problem, but let's check.\n        data = self._named_file(\"image.svg\")\n        data.filename = u\"\"\n        setattr(self.item, self.field_name, self._named_file(\"image.svg\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n        if self.field_name == \"image\":\n            self.assert_scale_view_is_download(base_url)", "target": 0}, {"function": "class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n    field_class = file.NamedBlobImage", "target": 0}, {"function": "class TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n    field_class = file.NamedFile\n    field_name = \"file\"\n\n    def test_html_file(self):\n        data = self.field_class(\n            \"<h1>Attacker</h1>\", filename=safe_unicode(\"attacker.html\")\n        )\n        setattr(self.item, self.field_name, data)\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_is_download(base_url)\n\n    def test_pdf(self):\n        # By popular request we allow PDF.\n        setattr(self.item, self.field_name, self._named_file(\"file.pdf\"))\n        transaction.commit()\n        base_url = self.item.absolute_url()\n        self.assert_download_works(base_url)\n        self.assert_display_inline_works(base_url)", "target": 0}, {"function": "class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n    field_class = file.NamedBlobFile", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
