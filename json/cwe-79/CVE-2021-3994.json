{"index": 7010, "cve_id": "CVE-2021-3994", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "django-helpdesk is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "cvss": "9.6", "publish_date": "December 1, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "CHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "a22eb0673fe0b7784f99c6b5fd343b64a6700f06", "commit_message": "Update pattern", "commit_date": "2021-11-19T16:11:33Z", "project": "django-helpdesk/django-helpdesk", "url": "https://api.github.com/repos/django-helpdesk/django-helpdesk/commits/a22eb0673fe0b7784f99c6b5fd343b64a6700f06", "html_url": "https://github.com/django-helpdesk/django-helpdesk/commit/a22eb0673fe0b7784f99c6b5fd343b64a6700f06", "windows_before": [{"commit_id": "7097c9c4c0b255ec1f10f3ea14fa2b9c47f6c706", "commit_date": "Fri Nov 19 18:54:34 2021 +0700", "commit_message": "Update pattern and code check", "files_name": ["helpdesk/models.py"]}, {"commit_id": "4a2ca815fd1788b6e4852d8324035b88f9276454", "commit_date": "Fri Nov 19 15:24:40 2021 +0700", "commit_message": "update pattern fix issue multi-line in text can be bypass", "files_name": ["helpdesk/models.py"]}, {"commit_id": "c54b89f1430c7f2b3d44be46e0f3390f0c64cf7a", "commit_date": "Fri Nov 19 13:00:03 2021 +0700", "commit_message": "Add URL schemes that are allowed within links Fix bug Stored XSS via markdown Disclosure: https://huntr.dev/bounties/be7f211d-4bfd-44fd-91e8-682329906fbd/", "files_name": ["helpdesk/models.py", "helpdesk/settings.py"]}, {"commit_id": "ffcc83f91df2e41898ad194cf42499798e292945", "commit_date": "Fri Nov 19 00:37:23 2021 -0500", "commit_message": "Sync master with 0.3", "files_name": ["96338bd73fd0d6756a4fb9eb73350ce4fc6f6647 - Fri Nov 19 00:34:21 2021 -0500 : Bump version to 0.3.1", "demo/setup.py", "setup.py"]}, {"commit_id": "44abb197120a843cce5b5fe8276e4a44b8bb2f48", "commit_date": "Fri Nov 19 00:30:20 2021 -0500", "commit_message": "Backport #980, #981, #984 to 0.3", "files_name": ["helpdesk/lib.py", "helpdesk/tasks.py", "helpdesk/templates/helpdesk/ticket_list.html"]}, {"commit_id": "b78f89c3ef58810f20227f93376df6d120b072b7", "commit_date": "Thu Nov 18 02:55:39 2021 -0500", "commit_message": "Merge pull request #984 from noobpk/noobpk-patch-validators", "files_name": ["04483bdac3b5196737516398b5ce0383875a5c60 - Thu Nov 18 10:42:02 2021 +0700 : Add `att.full_clean()` before saving", "helpdesk/lib.py"]}, {"commit_id": "73787bd24580b039f540324631128d3d34fa2976", "commit_date": "Wed Nov 17 12:14:56 2021 -0500", "commit_message": "Merge pull request #981 from GibbsConsulting/master", "files_name": ["fedcca42adb7385e9c0f7d9cf7e3f0ca82607e46 - Fri Nov 12 11:56:22 2021 -0800 : Update tasks.py", "helpdesk/tasks.py"]}, {"commit_id": "91b37f6d73e31dc312c8e3a54b9578b0a0851624", "commit_date": "Fri Nov 12 12:02:19 2021 -0500", "commit_message": "Merge pull request #980 from noobpk/noobpk-fix-xss", "files_name": ["2c7065e0c4296e0c692fb4a7ee19c7357583af30 - Thu Nov 11 17:32:09 2021 +0700 : Add function `htmlEntities`", "helpdesk/templates/helpdesk/ticket_list.html"]}, {"commit_id": "e016e6699d5ab96682785a7f5c3b9c3e2003708e", "commit_date": "Wed Oct 20 08:11:08 2021 -0400", "commit_message": "fix minutes representation in models.py, see #978", "files_name": ["helpdesk/models.py"]}, {"commit_id": "3f245871ac91356fd91a4e2cea5048bcac1d833e", "commit_date": "Wed Oct 20 08:09:02 2021 -0400", "commit_message": "Merge pull request #978 from AmatorAVG/master", "files_name": ["5538985fe1321de79a24d8c1c625ebeba52dbd1d - Wed Oct 20 14:18:38 2021 +0700 : Update models.py", "helpdesk/models.py"]}, {"commit_id": "7a4046b237c4c9614cbf42e188d6c21478dba7ac", "commit_date": "Tue Oct 19 04:41:56 2021 -0400", "commit_message": "azure does not yet support python 3.10", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "08c41b7206cf514b18fb151ad478e32fab949dfb", "commit_date": "Tue Oct 19 03:31:22 2021 -0400", "commit_message": "Really fix azure pipeline testing", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "8e632830de6785ab3367bfee95df428d912ff815", "commit_date": "Tue Oct 19 02:54:52 2021 -0400", "commit_message": "Fix azure pipeline testing", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "d0bbb6905a429a3c2086b19405220236317577b7", "commit_date": "Mon Oct 18 23:05:38 2021 -0400", "commit_message": "Merge fixes from branch '0.3'", "files_name": ["914e751a6de7c097ddf07b75e1f33fe359101cf6 - Mon Oct 18 23:05:03 2021 -0400 : Fix quicktest and update azure config", "azure-pipelines.yml", "quicktest.py"]}, {"commit_id": "e6d14b1d3d2e7e78a76641b376bd0d84fb023eee", "commit_date": "Mon Oct 18 22:31:43 2021 -0400", "commit_message": "Update README with azure build status", "files_name": ["README.rst", "azure-pipelines.yml"]}, {"commit_id": "5ca1f39c232da827c0670c2f763fa00afa074cb4", "commit_date": "Mon Oct 18 01:16:39 2021 -0400", "commit_message": "Update versions and copyrights to begin the 0.4 release dev cycle", "files_name": ["README.rst", "demo/setup.py", "docs/install.rst", "docs/license.rst", "docs/upgrade.rst", "setup.py"]}, {"commit_id": "266694509f7470566f0460fc82a9b7465f56f56c", "commit_date": "Mon Oct 18 01:02:55 2021 -0400", "commit_message": "Update CONTRIBUTING to reference the new 0.3 release branch", "files_name": ["CONTRIBUTING.rst"]}, {"commit_id": "ec96538a54d7e332563a8418533148f9bb79af0a", "commit_date": "Mon Oct 18 00:57:31 2021 -0400", "commit_message": "Set end date for official 0.2 support, update license copyright years", "files_name": ["LICENSE", "SECURITY.md", "demo/setup.py", "setup.py"]}, {"commit_id": "122d8f7b6a9e8be55ef42be66d90596626c78ea7", "commit_date": "Sun Oct 17 23:49:16 2021 -0400", "commit_message": "Update documentation for 0.3.0 release, restrict support to python 3.8+ because earlier pythons are no longer supported upstream anyway", "files_name": ["MANIFEST.in", "README.rst", "azure-pipelines.yml", "demo/README.rst", "demo/setup.py", "docs/install.rst", "docs/upgrade.rst", "setup.py"]}, {"commit_id": "0be0e279b78512beaf26219280f92d1d25a17b9c", "commit_date": "Sun Oct 17 23:34:23 2021 -0400", "commit_message": "Update azure pipelines config to test all versions of django supported", "files_name": ["azure-pipelines.yml", "constraints-Django22.txt", "constraints-Django32.txt"]}, {"commit_id": "751459e5c5efcd9d76e443d586bbc18d0d07f429", "commit_date": "Fri Oct 15 02:33:25 2021 -0400", "commit_message": "Set max 1 parallel", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "2d839df7a0f2dfa06be498c1151040dfa5582e38", "commit_date": "Fri Oct 15 02:22:45 2021 -0400", "commit_message": "Parallel testing isn't free automatically so skip for now", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "36e5370a7d9dca9b28f3d3480d90376e9c14be05", "commit_date": "Fri Oct 15 02:20:40 2021 -0400", "commit_message": "Set up CI with Azure Pipelines", "files_name": ["azure-pipelines.yml"]}, {"commit_id": "558318f35209b617461b0228f43f4b858a92db69", "commit_date": "Tue Oct 5 06:28:13 2021 -0400", "commit_message": "Remove old py2 import from setup", "files_name": ["setup.py"]}, {"commit_id": "aff67184d4f4ecb9ccf7045fcebe132c22a43c0d", "commit_date": "Tue Oct 5 06:25:42 2021 -0400", "commit_message": "Add attachment validator when uploading attachment to tickets", "files_name": ["Makefile", "demo/README.rst", "demo/demodesk/manage.py", "demo/setup.py", "helpdesk/forms.py", "helpdesk/migrations/0036_add_attachment_validator.py", "helpdesk/models.py", "helpdesk/validators.py", "helpdesk/views/staff.py", "setup.py"]}, {"commit_id": "a5f801bb526a18e9cbcea7de422b4c3c56540d3c", "commit_date": "Mon Oct 4 23:13:38 2021 -0400", "commit_message": "use csrf tokens in all forms", "files_name": ["helpdesk/templates/helpdesk/ticket_desc_table.html", "helpdesk/views/staff.py"]}, {"commit_id": "02bdaea76a535ae994e2057f0b8890a5e355b498", "commit_date": "Mon Sep 27 23:19:06 2021 -0400", "commit_message": "Add security warning to comments of demodesk about using secure cookies", "files_name": ["demo/demodesk/config/settings.py"]}, {"commit_id": "166d552fba626c562394f6b5555c2121ab510a47", "commit_date": "Mon Sep 27 22:12:32 2021 -0400", "commit_message": "Turn on secure cookie support if the server os environment expects to use secure connections", "files_name": ["helpdesk/settings.py"]}, {"commit_id": "e8efa4d2631df59914eab5deedddd663ae3b0bc4", "commit_date": "Mon Sep 27 18:59:31 2021 -0400", "commit_message": "Merge remote-tracking branch 'upstream/master'", "files_name": ["3216ff0c55abfe7c6022cfc88daac9b1d8dff562 - Thu Sep 23 10:19:52 2021 -0400 : Merge pull request #974 from passiv/master", "6a0b367171d9fad4557bdf06def065512a5c7b26 - Thu Sep 23 10:07:12 2021 -0300 : fix: strip extraneous whitespace characters that are returned in the Message-ID and In-Reply-To fields from some email providers", "helpdesk/email.py"]}, {"commit_id": "66ed61ee6abf6a93f9fde2dc59a7b2e6f328e1db", "commit_date": "Fri Sep 17 10:09:20 2021 -0400", "commit_message": "Set default autofield to be compatible for django 3.2", "files_name": ["demo/demodesk/config/settings.py", "demo/manage.py", "demo/setup.py", "helpdesk/apps.py", "setup.py"]}, {"commit_id": "f53ee1366db1c98cc30140f1f3450751b3b9b4aa", "commit_date": "Fri Sep 17 07:57:08 2021 -0400", "commit_message": "Create SECURITY.md", "files_name": ["SECURITY.md"]}, {"commit_id": "fc9002b2ac443e712b1fc76267877e3372809bd4", "commit_date": "Wed Sep 15 17:16:30 2021 -0400", "commit_message": "Merge pull request #972 from auto-mat/kb-items-dashboard", "files_name": ["247fd2e26d52352fcec80f34a8ac5666891a64a6 - Tue Sep 14 21:59:25 2021 +0200 : Don't show kbitems on dashboard if there are no unassigned tickets in them", "helpdesk/templates/helpdesk/include/unassigned.html"]}, {"commit_id": "fe171240927fad1196d698bb0c958c9a48a16797", "commit_date": "Tue Sep 14 02:15:54 2021 -0400", "commit_message": "Merge pull request #970 from auto-mat/kb-base-iframe", "files_name": ["650665b21e590201c3a30b528b3da4d477d87bb5 - Mon Sep 13 23:55:49 2021 +0200 : Fix wording of iframe ticket creation buttons", "helpdesk/templates/helpdesk/kb_category_base.html"]}, {"commit_id": "92caf5f284ceaf1b8eee6d1e7db844109340073f", "commit_date": "Mon Sep 13 23:42:03 2021 +0200", "commit_message": "Change ; to & when separating query params", "files_name": ["helpdesk/templates/helpdesk/kb_category_base.html"]}, {"commit_id": "00edddbaad1170fb1ccf6dcd198011e22af6c891", "commit_date": "Fri Aug 20 02:12:55 2021 -0400", "commit_message": "Update docs to recommend using django 3.2 LTS", "files_name": ["README.rst", "docs/install.rst"]}, {"commit_id": "15593339934336fe32f96e5514b8369e5827beda", "commit_date": "Fri Aug 20 02:05:21 2021 -0400", "commit_message": "Fix some docs and migrations in prep for 0.3 release, see #878", "files_name": ["demo/demodesk/config/settings.py", "docs/index.rst", "docs/install.rst", "docs/upgrade.rst", "helpdesk/migrations/0035_alter_email_on_ticket_change.py", "requirements-no-pinax.txt", "requirements.txt"]}, {"commit_id": "8a40ceedddb6c03c37ea156acae833051a232b8b", "commit_date": "Thu Aug 19 16:09:35 2021 -0400", "commit_message": "Merge pull request #967 from auto-mat/iframe-defaults-fix", "files_name": ["a9e5cfa52def60b236b17db8a71e6a920c75d86b - Thu Aug 19 22:00:18 2021 +0200 : Fix hidden field query args", "helpdesk/forms.py"]}, {"commit_id": "b708b786d435ff2f738d862b9f977f21765ddca6", "commit_date": "Thu Aug 19 22:00:06 2021 +0200", "commit_message": "Add failing test for hidden field query args", "files_name": ["helpdesk/tests/test_ticket_submission.py"]}, {"commit_id": "f4b7e899fa106cd2941aa8a1f2465993fe00600b", "commit_date": "Thu Aug 19 20:45:51 2021 +0200", "commit_message": "Change query arg delimiter from ; to &", "files_name": ["docs/integration.rst", "helpdesk/templates/helpdesk/kb_category_base.html", "helpdesk/tests/test_kb.py"]}, {"commit_id": "610460dfd610bd1fe6c5cf486e6a4aa956dd8c99", "commit_date": "Thu Aug 19 14:04:26 2021 -0400", "commit_message": "Merge pull request #965 from auto-mat/large-desk-performance", "files_name": ["9c6e8574cc157bbdd4a0a23e13e5dbc7bf5b31d5 - Thu Aug 5 14:16:14 2021 -0400 : Merge pull request #964 from regiov/pinax-remove", "9fd5d466e59af45b51cdbe990defec8e8cbfcffc - Thu Aug 5 13:19:03 2021 -0400 : Merge pull request #963 from koriaf/dev-subject-length", "563b28ed1425996748501df74526fdc86b3fb25e - Wed Aug 4 11:19:14 2021 -0300 : Merge branch 'master' into pinax-remove", "4f5e9d6006a77bb68abaae9fab1d991188a7e643 - Wed Aug 4 10:38:28 2021 -0300 : Included settings to disable teams", "quicktest.py"]}, {"commit_id": "f6fe738b58a0dce4b41e95a5e6576723bc3bc6a0", "commit_date": "Wed Aug 4 10:26:32 2021 -0300", "commit_message": "Disabled optional apps related to teams", "files_name": ["quicktest.py"]}, {"commit_id": "86c4ceb1a8f6e7778bfcf6a23838c3f1f8f78954", "commit_date": "Thu Jul 29 13:14:42 2021 +0200", "commit_message": "fix(emails): Avoid 'value too long for type character varying(200) ' error when incoming message has too long subject", "files_name": ["helpdesk/models.py", "helpdesk/tests/test_files/blank-body-with-attachment.eml", "helpdesk/tests/test_get_email.py"]}, {"commit_id": "63bb949d63001bdcface90cc866d3cfda57b3712", "commit_date": "Wed Jul 7 20:40:34 2021 +0200", "commit_message": "Don't use redis cache at all for ticket querysets as this breaks pagination", "files_name": ["helpdesk/query.py", "helpdesk/views/staff.py"]}, {"commit_id": "f840136e1ecbfeb2161aaa5a4e9c3ccd0a809010", "commit_date": "Wed Jul 7 20:38:20 2021 +0200", "commit_message": "Don't crash if use email is None", "files_name": ["helpdesk/views/staff.py"]}, {"commit_id": "df05ce2b1f13e2bc2eb4fe55033e0a69e41349f6", "commit_date": "Sun May 16 03:25:14 2021 -0400", "commit_message": "Test against Django 3.2", "files_name": []}], "windows_after": [{"commit_id": "f73651f8f9808fe740b5bbbe589fb8dc5a14413d", "commit_date": "Sun Nov 21 23:16:16 2021 -0500", "commit_message": "Merge pull request #985 from noobpk/noobpk-fix-xss-markdown", "files_name": ["0d79b6266d583d0d809a6fff3c10097dd28f468e - Sun Nov 21 23:25:54 2021 -0500 : Backport patch for #985", "helpdesk/models.py", "helpdesk/settings.py"]}, {"commit_id": "e7de309159dad498bbb1d8dcf2c24986860772b6", "commit_date": "Sun Nov 21 23:36:17 2021 -0500", "commit_message": "Update CONTRIBUTING for the new branch naming scheme", "files_name": ["CONTRIBUTING.rst"]}, {"commit_id": "94902ec44fc93d1e9fd2858cc2327902d028137a", "commit_date": "Sun Nov 21 23:37:25 2021 -0500", "commit_message": "Bump version to 0.3.2 for bugfix", "files_name": ["demo/setup.py", "setup.py"]}, {"commit_id": "dee21a7727f4f10f2ebfa85be6d4d697a57b1bc4", "commit_date": "Sun Nov 21 23:40:20 2021 -0500", "commit_message": "Merge in 0.3.2 bugfix release", "files_name": ["916ffe750cb1a29b5f95da105358b6be8285f877 - Sun Nov 21 23:52:46 2021 -0500 : Update azure pipelines for new branch names", "azure-pipelines.yml"]}, {"commit_id": "345a713777d7a7c559610f72db1ae22d6187f985", "commit_date": "Fri Dec 31 14:59:37 2021 -0800", "commit_message": "updated validate_file_extension() to look for defined VALID_EXTENTIONS in settings.py so its configurable", "files_name": ["helpdesk/validators.py"]}, {"commit_id": "ae73fec2a0a5a024028d218db00e9cdb488c2a5e", "commit_date": "Fri Dec 31 22:21:28 2021 -0500", "commit_message": "Spellchecking in validators.py", "files_name": ["helpdesk/validators.py"]}, {"commit_id": "09494e961ea00b2715c97c415e3bf8edeff4a975", "commit_date": "Fri Dec 31 22:22:45 2021 -0500", "commit_message": "Merge pull request #987 from wheelert/email-attachment-settings", "files_name": ["3695cfa19dd860ab1b6f38486b5d1ff0ade3c52f - Tue Jan 4 11:47:31 2022 -0500 : Remove comma in staff.py to address #988", "helpdesk/views/staff.py"]}, {"commit_id": "7ac8d20cbefcaae9e627fde65897161fada0c6c7", "commit_date": "Wed Jan 26 14:26:52 2022 -0500", "commit_message": "Fix Javascript typo", "files_name": ["helpdesk/templates/helpdesk/ticket.html"]}, {"commit_id": "e6fddd154e2cbb93500feede45914aadb32a93dc", "commit_date": "Wed Jan 26 19:07:15 2022 -0500", "commit_message": "Merge pull request #989 from jrenaut/patch-1", "files_name": ["a2782c07f46c9e241fd1ca9fefd1c47e8523ed5b - Thu Jan 27 09:51:00 2022 +0100 : Show active page in sidebar depending on the request path url", "helpdesk/templates/helpdesk/navigation-sidebar.html"]}, {"commit_id": "17a1e064e6a5aa2919a426f6c0bd72b87efcfcd3", "commit_date": "Thu Jan 27 10:27:49 2022 +0100", "commit_message": "Undo PR #989", "files_name": ["helpdesk/templates/helpdesk/ticket.html"]}, {"commit_id": "2a8c1511ef04d1e795eb54e820a6dd19d6558023", "commit_date": "Thu Jan 27 07:56:15 2022 -0500", "commit_message": "Merge pull request #990 from auto-mat/preset", "files_name": ["075cdd4cdb93b3462ed11e7ecc27ffb5a4ecceaf - Thu Jan 27 07:58:48 2022 -0500 : Merge pull request #991 from Benbb96/active-sidebar", "e0c075454399ca719a53c7029363860f92c8b3d4 - Wed Feb 9 05:15:14 2022 -0500 : Update to fontawesome 5.15.4", "helpdesk/static/helpdesk/vendor/fontawesome-free/attribution.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/all.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/all.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/brands.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/brands.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/fontawesome.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/fontawesome.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/regular.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/regular.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/solid.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/solid.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/svg-with-js.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/svg-with-js.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/v4-shims.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/css/v4-shims.min.css", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/all.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/all.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/brands.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/brands.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/conflict-detection.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/conflict-detection.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/fontawesome.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/fontawesome.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/regular.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/regular.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/solid.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/solid.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/v4-shims.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/js/v4-shims.min.js", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/_icons.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/_variables.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/brands.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/fontawesome.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/regular.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/solid.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/less/v4-shims.less", "helpdesk/static/helpdesk/vendor/fontawesome-free/metadata/icons.json", "helpdesk/static/helpdesk/vendor/fontawesome-free/metadata/icons.yml", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/_icons.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/_variables.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/brands.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/fontawesome.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/regular.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/solid.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/scss/v4-shims.scss", "helpdesk/static/helpdesk/vendor/fontawesome-free/sprites/brands.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/sprites/regular.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/sprites/solid.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/500px.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/accessible-icon.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/accusoft.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/acquisitions-incorporated.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/adn.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/adversal.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/affiliatetheme.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/airbnb.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/algolia.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/alipay.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/amazon-pay.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/amazon.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/amilia.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/android.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/angellist.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/angrycreative.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/angular.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/app-store-ios.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/app-store.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/apper.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/apple-pay.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/apple.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/artstation.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/asymmetrik.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/atlassian.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/audible.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/autoprefixer.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/avianex.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/aviato.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/aws.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bandcamp.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/battle-net.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/behance-square.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/behance.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bimobject.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bitbucket.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bitcoin.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bity.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/black-tie.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/blackberry.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/blogger-b.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/blogger.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bluetooth-b.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bluetooth.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/bootstrap.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/btc.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/buffer.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/buromobelexperte.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/buy-n-large.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/buysellads.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/canadian-maple-leaf.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-amazon-pay.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-amex.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-apple-pay.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-diners-club.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-discover.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-jcb.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-mastercard.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-paypal.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-stripe.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cc-visa.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/centercode.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/centos.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/chrome.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/chromecast.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cloudflare.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cloudscale.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cloudsmith.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cloudversify.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/codepen.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/codiepie.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/confluence.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/connectdevelop.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/contao.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cotton-bureau.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cpanel.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-by.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-nc-eu.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-nc-jp.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-nc.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-nd.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-pd-alt.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-pd.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-remix.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-sa.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-sampling-plus.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-sampling.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-share.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons-zero.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/creative-commons.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/critical-role.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/css3-alt.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/css3.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/cuttlefish.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/d-and-d-beyond.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/d-and-d.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/dailymotion.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/dashcube.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/deezer.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/delicious.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/deploydog.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/deskpro.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/dev.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/deviantart.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/dhl.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/diaspora.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/digg.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/digital-ocean.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/discord.svg", "helpdesk/static/helpdesk/vendor/fontawesome-free/svgs/brands/discourse.svg"]}], "parents": [{"commit_id_before": "7097c9c4c0b255ec1f10f3ea14fa2b9c47f6c706", "url_before": "https://api.github.com/repos/django-helpdesk/django-helpdesk/commits/7097c9c4c0b255ec1f10f3ea14fa2b9c47f6c706", "html_url_before": "https://github.com/django-helpdesk/django-helpdesk/commit/7097c9c4c0b255ec1f10f3ea14fa2b9c47f6c706"}], "details": [{"raw_url": "https://github.com/django-helpdesk/django-helpdesk/raw/a22eb0673fe0b7784f99c6b5fd343b64a6700f06/helpdesk%2Fmodels.py", "code": "\"\"\"\ndjango-helpdesk - A Django powered ticket tracker for small enterprise.\n\n(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.\n\nmodels.py - Model (and hence database) definitions. This is the core of the\n            helpdesk structure.\n\"\"\"\n\nfrom django.contrib.auth.models import Permission\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\nfrom django.db import models\nfrom django.conf import settings\nfrom django.utils import timezone\nfrom django.utils.translation import ugettext_lazy as _, ugettext\nfrom io import StringIO\nimport re\nimport os\nimport mimetypes\nimport datetime\n\nfrom django.utils.safestring import mark_safe\nfrom markdown import markdown\nfrom markdown.extensions import Extension\n\n\nimport uuid\n\nfrom helpdesk import settings as helpdesk_settings\n\nfrom .validators import validate_file_extension\n\nfrom .templated_email import send_templated_mail\n\n\ndef format_time_spent(time_spent):\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds % 3600 // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent\n\n\nclass EscapeHtml(Extension):\n    def extendMarkdown(self, md, md_globals):\n        del md.preprocessors['html_block']\n        del md.inlinePatterns['html']\n\n\ndef get_markdown(text):\n    if not text:\n        return \"\"\n\n    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\s\\S]*?)\\)'\n    # Regex check\n    if re.match(pattern, text):\n        # get get value of group regex\n        scheme = re.search(pattern, text, re.IGNORECASE).group(2)\n        # scheme check\n        if scheme in helpdesk_settings.ALLOWED_URL_SCHEMES:\n            replacement = '\\\\1(\\\\2:\\\\3)'\n        else:\n            replacement = '\\\\1(\\\\3)'\n\n        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)\n\n    return mark_safe(\n        markdown(\n            text,\n            extensions=[\n                EscapeHtml(), 'markdown.extensions.nl2br',\n                'markdown.extensions.fenced_code'\n            ]\n        )\n    )\n\n\nclass Queue(models.Model):\n    \"\"\"\n    A queue is a collection of tickets into what would generally be business\n    areas or departments.\n\n    For example, a company may have a queue for each Product they provide, or\n    a queue for each of Accounts, Pre-Sales, and Support.\n\n    \"\"\"\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n        max_length=50,\n        unique=True,\n        help_text=_('This slug is used when building ticket ID\\'s. Once set, '\n                    'try not to change it or e-mailing may get messy.'),\n    )\n\n    email_address = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('All outgoing e-mails for this queue will use this e-mail '\n                    'address. If you use IMAP or POP3, this should be the e-mail '\n                    'address for that mailbox.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this queue. All correspondence in this '\n                    'queue will be in this language.'),\n    )\n\n    allow_public_submission = models.BooleanField(\n        _('Allow Public Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Should this queue be listed on the public submission form?'),\n    )\n\n    allow_email_submission = models.BooleanField(\n        _('Allow E-Mail Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to poll the e-mail box below for new '\n                    'tickets?'),\n    )\n\n    escalate_days = models.IntegerField(\n        _('Escalation Days'),\n        blank=True,\n        null=True,\n        help_text=_('For tickets which are not held, how often do you wish to '\n                    'increase their priority? Set to 0 for no escalation.'),\n    )\n\n    new_ticket_cc = models.CharField(\n        _('New Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all new tickets created for this queue. '\n                    'Enter a comma between multiple e-mail addresses.'),\n    )\n\n    updated_ticket_cc = models.CharField(\n        _('Updated Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all activity (new tickets, closed '\n                    'tickets, updates, reassignments, etc) for this queue. Separate '\n                    'multiple addresses with a comma.'),\n    )\n\n    enable_notifications_on_email_events = models.BooleanField(\n        _('Notify contacts when email updates arrive'),\n        blank=True,\n        default=False,\n        help_text=_('When an email arrives to either create a ticket or to '\n                    'interact with an existing discussion. Should email notifications be sent ? '\n                    'Note: the new_ticket_cc and updated_ticket_cc work independently of this feature'),\n    )\n\n    email_box_type = models.CharField(\n        _('E-Mail Box Type'),\n        max_length=5,\n        choices=(('pop3', _('POP 3')), ('imap', _('IMAP')), ('local', _('Local Directory'))),\n        blank=True,\n        null=True,\n        help_text=_('E-Mail server type for creating tickets automatically '\n                    'from a mailbox - both POP3 and IMAP are supported, as well as '\n                    'reading from a local directory.'),\n    )\n\n    email_box_host = models.CharField(\n        _('E-Mail Hostname'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Your e-mail server address - either the domain name or '\n                    'IP address. May be \"localhost\".'),\n    )\n\n    email_box_port = models.IntegerField(\n        _('E-Mail Port'),\n        blank=True,\n        null=True,\n        help_text=_('Port number to use for accessing e-mail. Default for '\n                    'POP3 is \"110\", and for IMAP is \"143\". This may differ on some '\n                    'servers. Leave it blank to use the defaults.'),\n    )\n\n    email_box_ssl = models.BooleanField(\n        _('Use SSL for E-Mail?'),\n        blank=True,\n        default=False,\n        help_text=_('Whether to use SSL for IMAP or POP3 - the default ports '\n                    'when using SSL are 993 for IMAP and 995 for POP3.'),\n    )\n\n    email_box_user = models.CharField(\n        _('E-Mail Username'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Username for accessing this mailbox.'),\n    )\n\n    email_box_pass = models.CharField(\n        _('E-Mail Password'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Password for the above username'),\n    )\n\n    email_box_imap_folder = models.CharField(\n        _('IMAP Folder'),\n        max_length=100,\n        blank=True,\n        null=True,\n        help_text=_('If using IMAP, what folder do you wish to fetch messages '\n                    'from? This allows you to use one IMAP account for multiple '\n                    'queues, by filtering messages on your IMAP server into separate '\n                    'folders. Default: INBOX.'),\n    )\n\n    email_box_local_dir = models.CharField(\n        _('E-Mail Local Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If using a local directory, what directory path do you '\n                    'wish to poll for new email? '\n                    'Example: /var/lib/mail/helpdesk/'),\n    )\n\n    permission_name = models.CharField(\n        _('Django auth permission name'),\n        max_length=72,  # based on prepare_permission_name() pre-pending chars to slug\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('Name used in the django.contrib.auth permission system'),\n    )\n\n    email_box_interval = models.IntegerField(\n        _('E-Mail Check Interval'),\n        help_text=_('How often do you wish to check this mailbox? (in Minutes)'),\n        blank=True,\n        null=True,\n        default='5',\n    )\n\n    email_box_last_check = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        # This is updated by management/commands/get_mail.py.\n    )\n\n    socks_proxy_type = models.CharField(\n        _('Socks Proxy Type'),\n        max_length=8,\n        choices=(('socks4', _('SOCKS4')), ('socks5', _('SOCKS5'))),\n        blank=True,\n        null=True,\n        help_text=_('SOCKS4 or SOCKS5 allows you to proxy your connections through a SOCKS server.'),\n    )\n\n    socks_proxy_host = models.GenericIPAddressField(\n        _('Socks Proxy Host'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy IP address. Default: 127.0.0.1'),\n    )\n\n    socks_proxy_port = models.IntegerField(\n        _('Socks Proxy Port'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy port number. Default: 9150 (default TOR port)'),\n    )\n\n    logging_type = models.CharField(\n        _('Logging Type'),\n        max_length=5,\n        choices=(\n            ('none', _('None')),\n            ('debug', _('Debug')),\n            ('info', _('Information')),\n            ('warn', _('Warning')),\n            ('error', _('Error')),\n            ('crit', _('Critical'))\n        ),\n        blank=True,\n        null=True,\n        help_text=_('Set the default logging level. All messages at that '\n                    'level or above will be logged to the directory set '\n                    'below. If no level is set, logging will be disabled.'),\n    )\n\n    logging_dir = models.CharField(\n        _('Logging Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If logging is enabled, what directory should we use to '\n                    'store log files for this queue? '\n                    'The standard logging mechanims are used if no directory is set'),\n    )\n\n    default_owner = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.SET_NULL,\n        related_name='default_owner',\n        blank=True,\n        null=True,\n        verbose_name=_('Default owner'),\n    )\n\n    dedicated_time = models.DurationField(\n        help_text=_(\"Time to be spent on this Queue in total\"),\n        blank=True, null=True\n    )\n\n    def __str__(self):\n        return \"%s\" % self.title\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Queue')\n        verbose_name_plural = _('Queues')\n\n    def _from_address(self):\n        \"\"\"\n        Short property to provide a sender address in SMTP format,\n        eg 'Name <email>'. We do this so we can put a simple error message\n        in the sender name field, so hopefully the admin can see and fix it.\n        \"\"\"\n        if not self.email_address:\n            # must check if given in format \"Foo <foo@example.com>\"\n            default_email = re.match(\".*<(?P<email>.*@*.)>\", settings.DEFAULT_FROM_EMAIL)\n            if default_email is not None:\n                # already in the right format, so just include it here\n                return u'NO QUEUE EMAIL ADDRESS DEFINED %s' % settings.DEFAULT_FROM_EMAIL\n            else:\n                return u'NO QUEUE EMAIL ADDRESS DEFINED <%s>' % settings.DEFAULT_FROM_EMAIL\n        else:\n            return u'%s <%s>' % (self.title, self.email_address)\n    from_address = property(_from_address)\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.ticket_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def prepare_permission_name(self):\n        \"\"\"Prepare internally the codename for the permission and store it in permission_name.\n        :return: The codename that can be used to create a new Permission object.\n        \"\"\"\n        # Prepare the permission associated to this Queue\n        basename = \"queue_access_%s\" % self.slug\n        self.permission_name = \"helpdesk.%s\" % basename\n        return basename\n\n    def save(self, *args, **kwargs):\n        if self.email_box_type == 'imap' and not self.email_box_imap_folder:\n            self.email_box_imap_folder = 'INBOX'\n\n        if self.socks_proxy_type:\n            if not self.socks_proxy_host:\n                self.socks_proxy_host = '127.0.0.1'\n            if not self.socks_proxy_port:\n                self.socks_proxy_port = 9150\n        else:\n            self.socks_proxy_host = None\n            self.socks_proxy_port = None\n\n        if not self.email_box_port:\n            if self.email_box_type == 'imap' and self.email_box_ssl:\n                self.email_box_port = 993\n            elif self.email_box_type == 'imap' and not self.email_box_ssl:\n                self.email_box_port = 143\n            elif self.email_box_type == 'pop3' and self.email_box_ssl:\n                self.email_box_port = 995\n            elif self.email_box_type == 'pop3' and not self.email_box_ssl:\n                self.email_box_port = 110\n\n        if not self.id:\n            # Prepare the permission codename and the permission\n            # (even if they are not needed with the current configuration)\n            basename = self.prepare_permission_name()\n\n            Permission.objects.create(\n                name=_(\"Permission for queue: \") + self.title,\n                content_type=ContentType.objects.get_for_model(self.__class__),\n                codename=basename,\n            )\n\n        super(Queue, self).save(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        permission_name = self.permission_name\n        super(Queue, self).delete(*args, **kwargs)\n\n        # once the Queue is safely deleted, remove the permission (if exists)\n        if permission_name:\n            try:\n                p = Permission.objects.get(codename=permission_name[9:])\n                p.delete()\n            except ObjectDoesNotExist:\n                pass\n\n\ndef mk_secret():\n    return str(uuid.uuid4())\n\n\nclass Ticket(models.Model):\n    \"\"\"\n    To allow a ticket to be entered as quickly as possible, only the\n    bare minimum fields are required. These basically allow us to\n    sort and manage the ticket. The user can always go back and\n    enter more information later.\n\n    A good example of this is when a customer is on the phone, and\n    you want to give them a ticket ID as quickly as possible. You can\n    enter some basic info, save the ticket, give the customer the ID\n    and get off the phone, then add in further detail at a later time\n    (once the customer is not on the line).\n\n    Note that assigned_to is optional - unassigned tickets are displayed on\n    the dashboard to prompt users to take ownership of them.\n    \"\"\"\n\n    OPEN_STATUS = 1\n    REOPENED_STATUS = 2\n    RESOLVED_STATUS = 3\n    CLOSED_STATUS = 4\n    DUPLICATE_STATUS = 5\n\n    STATUS_CHOICES = (\n        (OPEN_STATUS, _('Open')),\n        (REOPENED_STATUS, _('Reopened')),\n        (RESOLVED_STATUS, _('Resolved')),\n        (CLOSED_STATUS, _('Closed')),\n        (DUPLICATE_STATUS, _('Duplicate')),\n    )\n\n    PRIORITY_CHOICES = (\n        (1, _('1. Critical')),\n        (2, _('2. High')),\n        (3, _('3. Normal')),\n        (4, _('4. Low')),\n        (5, _('5. Very Low')),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        on_delete=models.CASCADE,\n        verbose_name=_('Queue'),\n    )\n\n    created = models.DateTimeField(\n        _('Created'),\n        blank=True,\n        help_text=_('Date this ticket was first created'),\n    )\n\n    modified = models.DateTimeField(\n        _('Modified'),\n        blank=True,\n        help_text=_('Date this ticket was most recently changed.'),\n    )\n\n    submitter_email = models.EmailField(\n        _('Submitter E-Mail'),\n        blank=True,\n        null=True,\n        help_text=_('The submitter will receive an email for all public '\n                    'follow-ups left for this task.'),\n    )\n\n    assigned_to = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='assigned_to',\n        blank=True,\n        null=True,\n        verbose_name=_('Assigned to'),\n    )\n\n    status = models.IntegerField(\n        _('Status'),\n        choices=STATUS_CHOICES,\n        default=OPEN_STATUS,\n    )\n\n    on_hold = models.BooleanField(\n        _('On Hold'),\n        blank=True,\n        default=False,\n        help_text=_('If a ticket is on hold, it will not automatically be escalated.'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n        blank=True,\n        null=True,\n        help_text=_('The content of the customers query.'),\n    )\n\n    resolution = models.TextField(\n        _('Resolution'),\n        blank=True,\n        null=True,\n        help_text=_('The resolution provided to the customer by our staff.'),\n    )\n\n    priority = models.IntegerField(\n        _('Priority'),\n        choices=PRIORITY_CHOICES,\n        default=3,\n        blank=3,\n        help_text=_('1 = Highest Priority, 5 = Low Priority'),\n    )\n\n    due_date = models.DateTimeField(\n        _('Due on'),\n        blank=True,\n        null=True,\n    )\n\n    last_escalation = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('The date this ticket was last escalated - updated '\n                    'automatically by management/commands/escalate_tickets.py.'),\n    )\n\n    secret_key = models.CharField(\n        _(\"Secret key needed for viewing/editing ticket by non-logged in users\"),\n        max_length=36,\n        default=mk_secret,\n    )\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item the user was viewing when they created this ticket.'),\n    )\n\n    merged_to = models.ForeignKey(\n        'self',\n        verbose_name=_('merged to'),\n        related_name='merged_tickets',\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True\n    )\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.followup_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def send(self, roles, dont_send_to=None, **kwargs):\n        \"\"\"\n        Send notifications to everyone interested in this ticket.\n\n        The the roles argument is a dictionary mapping from roles to (template, context) pairs.\n        If a role is not present in the dictionary, users of that type will not receive the notification.\n\n        The following roles exist:\n\n          - 'submitter'\n          - 'new_ticket_cc'\n          - 'ticket_cc'\n          - 'assigned_to'\n\n        Here is an example roles dictionary:\n\n        {\n            'submitter': (template_name, context),\n            'assigned_to': (template_name2, context),\n        }\n\n        **kwargs are passed to send_templated_mail defined in templated_email.py\n\n        returns the set of email addresses the notification was delivered to.\n\n        \"\"\"\n        recipients = set()\n\n        if dont_send_to is not None:\n            recipients.update(dont_send_to)\n\n        recipients.add(self.queue.email_address)\n\n        def should_receive(email):\n            return email and email not in recipients\n\n        def send(role, recipient):\n            if recipient and recipient not in recipients and role in roles:\n                template, context = roles[role]\n                send_templated_mail(template, context, recipient, sender=self.queue.from_address, **kwargs)\n                recipients.add(recipient)\n\n        send('submitter', self.submitter_email)\n        send('ticket_cc', self.queue.updated_ticket_cc)\n        send('new_ticket_cc', self.queue.new_ticket_cc)\n        if self.assigned_to:\n            send('assigned_to', self.assigned_to.email)\n        if self.queue.enable_notifications_on_email_events:\n            for cc in self.ticketcc_set.all():\n                send('ticket_cc', cc.email_address)\n        return recipients\n\n    def _get_assigned_to(self):\n        \"\"\" Custom property to allow us to easily print 'Unassigned' if a\n        ticket has no owner, or the users name if it's assigned. If the user\n        has a full name configured, we use that, otherwise their username. \"\"\"\n        if not self.assigned_to:\n            return _('Unassigned')\n        else:\n            if self.assigned_to.get_full_name():\n                return self.assigned_to.get_full_name()\n            else:\n                return self.assigned_to.get_username()\n    get_assigned_to = property(_get_assigned_to)\n\n    def _get_ticket(self):\n        \"\"\" A user-friendly ticket ID, which is a combination of ticket ID\n        and queue slug. This is generally used in e-mail subjects. \"\"\"\n\n        return u\"[%s]\" % self.ticket_for_url\n    ticket = property(_get_ticket)\n\n    def _get_ticket_for_url(self):\n        \"\"\" A URL-friendly ticket ID, used in links. \"\"\"\n        return u\"%s-%s\" % (self.queue.slug, self.id)\n    ticket_for_url = property(_get_ticket_for_url)\n\n    def _get_priority_css_class(self):\n        \"\"\"\n        Return the boostrap class corresponding to the priority.\n        \"\"\"\n        if self.priority == 2:\n            return \"warning\"\n        elif self.priority == 1:\n            return \"danger\"\n        elif self.priority == 5:\n            return \"success\"\n        else:\n            return \"\"\n    get_priority_css_class = property(_get_priority_css_class)\n\n    def _get_status(self):\n        \"\"\"\n        Displays the ticket status, with an \"On Hold\" message if needed.\n        \"\"\"\n        held_msg = ''\n        if self.on_hold:\n            held_msg = _(' - On Hold')\n        dep_msg = ''\n        if not self.can_be_resolved:\n            dep_msg = _(' - Open dependencies')\n        return u'%s%s%s' % (self.get_status_display(), held_msg, dep_msg)\n    get_status = property(_get_status)\n\n    def _get_ticket_url(self):\n        \"\"\"\n        Returns a publicly-viewable URL for this ticket, used when giving\n        a URL to the submitter of a ticket.\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s?ticket=%s&email=%s&key=%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:public_view'),\n            self.ticket_for_url,\n            self.submitter_email,\n            self.secret_key\n        )\n    ticket_url = property(_get_ticket_url)\n\n    def _get_staff_url(self):\n        \"\"\"\n        Returns a staff-only URL for this ticket, used when giving a URL to\n        a staff member (in emails etc)\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:view',\n                    args=[self.id])\n        )\n    staff_url = property(_get_staff_url)\n\n    def _can_be_resolved(self):\n        \"\"\"\n        Returns a boolean.\n        True = any dependencies are resolved\n        False = There are non-resolved dependencies\n        \"\"\"\n        OPEN_STATUSES = (Ticket.OPEN_STATUS, Ticket.REOPENED_STATUS)\n        return TicketDependency.objects.filter(ticket=self).filter(\n            depends_on__status__in=OPEN_STATUSES).count() == 0\n    can_be_resolved = property(_can_be_resolved)\n\n    def get_submitter_userprofile(self):\n        User = get_user_model()\n        try:\n            return User.objects.get(email=self.submitter_email)\n        except (User.DoesNotExist, User.MultipleObjectsReturned):\n            return None\n\n    class Meta:\n        get_latest_by = \"created\"\n        ordering = ('id',)\n        verbose_name = _('Ticket')\n        verbose_name_plural = _('Tickets')\n\n    def __str__(self):\n        return '%s %s' % (self.id, self.title)\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:view', args=(self.id,))\n\n    def save(self, *args, **kwargs):\n        if not self.id:\n            # This is a new ticket as no ID yet exists.\n            self.created = timezone.now()\n\n        if not self.priority:\n            self.priority = 3\n\n        self.modified = timezone.now()\n\n        if len(self.title) > 200:\n            self.title = self.title[:197] + \"...\"\n\n        super(Ticket, self).save(*args, **kwargs)\n\n    @staticmethod\n    def queue_and_id_from_query(query):\n        # Apply the opposite logic here compared to self._get_ticket_for_url\n        # Ensure that queues with '-' in them will work\n        parts = query.split('-')\n        queue = '-'.join(parts[0:-1])\n        return queue, parts[-1]\n\n    def get_markdown(self):\n        return get_markdown(self.description)\n\n    @property\n    def get_resolution_markdown(self):\n        return get_markdown(self.resolution)\n\n    def add_email_to_ticketcc_if_not_in(self, email=None, user=None, ticketcc=None):\n        \"\"\"\n        Check that given email/user_email/ticketcc_email is not already present on the ticket\n        (submitter email, assigned to, or in ticket CCs) and add it to a new ticket CC,\n        or move the given one\n\n        :param str email:\n        :param User user:\n        :param TicketCC ticketcc:\n        :rtype: TicketCC|None\n        \"\"\"\n        if ticketcc:\n            email = ticketcc.display\n        elif user:\n            if user.email:\n                email = user.email\n            else:\n                # Ignore if user has no email address\n                return\n        elif not email:\n            raise ValueError('You must provide at least one parameter to get the email from')\n\n        # Prepare all emails already into the ticket\n        ticket_emails = [x.display for x in self.ticketcc_set.all()]\n        if self.submitter_email:\n            ticket_emails.append(self.submitter_email)\n        if self.assigned_to and self.assigned_to.email:\n            ticket_emails.append(self.assigned_to.email)\n\n        # Check that email is not already part of the ticket\n        if email not in ticket_emails:\n            if ticketcc:\n                ticketcc.ticket = self\n                ticketcc.save(update_fields=['ticket'])\n            elif user:\n                ticketcc = self.ticketcc_set.create(user=user)\n            else:\n                ticketcc = self.ticketcc_set.create(email=email)\n            return ticketcc\n\n\nclass FollowUpManager(models.Manager):\n\n    def private_followups(self):\n        return self.filter(public=False)\n\n    def public_followups(self):\n        return self.filter(public=True)\n\n\nclass FollowUp(models.Model):\n    \"\"\"\n    A FollowUp is a comment and/or change to a ticket. We keep a simple\n    title, the comment entered by the user, and the new status of a ticket\n    to enable easy flagging of details on the view-ticket page.\n\n    The title is automatically generated at save-time, based on what action\n    the user took.\n\n    Tickets that aren't public are never shown to or e-mailed to the submitter,\n    although all staff can see them.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    date = models.DateTimeField(\n        _('Date'),\n        default=timezone.now\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n        blank=True,\n        null=True,\n    )\n\n    comment = models.TextField(\n        _('Comment'),\n        blank=True,\n        null=True,\n    )\n\n    public = models.BooleanField(\n        _('Public'),\n        blank=True,\n        default=False,\n        help_text=_(\n            'Public tickets are viewable by the submitter and all '\n            'staff, but non-public tickets can only be seen by staff.'\n        ),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        verbose_name=_('User'),\n    )\n\n    new_status = models.IntegerField(\n        _('New Status'),\n        choices=Ticket.STATUS_CHOICES,\n        blank=True,\n        null=True,\n        help_text=_('If the status was changed, what was it changed to?'),\n    )\n\n    message_id = models.CharField(\n        _('E-Mail ID'),\n        max_length=256,\n        blank=True,\n        null=True,\n        help_text=_(\"The Message ID of the submitter's email.\"),\n        editable=False,\n    )\n\n    objects = FollowUpManager()\n\n    time_spent = models.DurationField(\n        help_text=_(\"Time spent on this follow up\"),\n        blank=True, null=True\n    )\n\n    class Meta:\n        ordering = ('date',)\n        verbose_name = _('Follow-up')\n        verbose_name_plural = _('Follow-ups')\n\n    def __str__(self):\n        return '%s' % self.title\n\n    def get_absolute_url(self):\n        return u\"%s#followup%s\" % (self.ticket.get_absolute_url(), self.id)\n\n    def save(self, *args, **kwargs):\n        t = self.ticket\n        t.modified = timezone.now()\n        t.save()\n        super(FollowUp, self).save(*args, **kwargs)\n\n    def get_markdown(self):\n        return get_markdown(self.comment)\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n\nclass TicketChange(models.Model):\n    \"\"\"\n    For each FollowUp, any changes to the parent ticket (eg Title, Priority,\n    etc) are tracked here for display purposes.\n    \"\"\"\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    field = models.CharField(\n        _('Field'),\n        max_length=100,\n    )\n\n    old_value = models.TextField(\n        _('Old Value'),\n        blank=True,\n        null=True,\n    )\n\n    new_value = models.TextField(\n        _('New Value'),\n        blank=True,\n        null=True,\n    )\n\n    def __str__(self):\n        out = '%s ' % self.field\n        if not self.new_value:\n            out += ugettext('removed')\n        elif not self.old_value:\n            out += ugettext('set to %s') % self.new_value\n        else:\n            out += ugettext('changed from \"%(old_value)s\" to \"%(new_value)s\"') % {\n                'old_value': self.old_value,\n                'new_value': self.new_value\n            }\n        return out\n\n    class Meta:\n        verbose_name = _('Ticket change')\n        verbose_name_plural = _('Ticket changes')\n\n\ndef attachment_path(instance, filename):\n    \"\"\"Just bridge\"\"\"\n    return instance.attachment_path(filename)\n\n\nclass Attachment(models.Model):\n    \"\"\"\n    Represents a file attached to a follow-up. This could come from an e-mail\n    attachment, or it could be uploaded via the web interface.\n    \"\"\"\n\n    file = models.FileField(\n        _('File'),\n        upload_to=attachment_path,\n        max_length=1000,\n        validators=[validate_file_extension]\n    )\n\n    filename = models.CharField(\n        _('Filename'),\n        blank=True,\n        max_length=1000,\n    )\n\n    mime_type = models.CharField(\n        _('MIME Type'),\n        blank=True,\n        max_length=255,\n    )\n\n    size = models.IntegerField(\n        _('Size'),\n        blank=True,\n        help_text=_('Size of this file in bytes'),\n    )\n\n    def __str__(self):\n        return '%s' % self.filename\n\n    def save(self, *args, **kwargs):\n\n        if not self.size:\n            self.size = self.get_size()\n\n        if not self.filename:\n            self.filename = self.get_filename()\n\n        if not self.mime_type:\n            self.mime_type = \\\n                mimetypes.guess_type(self.filename, strict=False)[0] or \\\n                'application/octet-stream'\n\n        return super(Attachment, self).save(*args, **kwargs)\n\n    def get_filename(self):\n        return str(self.file)\n\n    def get_size(self):\n        return self.file.file.size\n\n    def attachment_path(self, filename):\n        \"\"\"Provide a file path that will help prevent files being overwritten, by\n        putting attachments in a folder off attachments for ticket/followup_id/.\n        \"\"\"\n        assert NotImplementedError(\n            \"This method is to be implemented by Attachment classes\"\n        )\n\n    class Meta:\n        ordering = ('filename',)\n        verbose_name = _('Attachment')\n        verbose_name_plural = _('Attachments')\n        abstract = True\n\n\nclass FollowUpAttachment(Attachment):\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/{ticket_for_url}-{secret_key}/{id_}'.format(\n            ticket_for_url=self.followup.ticket.ticket_for_url,\n            secret_key=self.followup.ticket.secret_key,\n            id_=self.followup.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)\n\n\nclass KBIAttachment(Attachment):\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/kb/{category}/{kbi}'.format(\n            category=self.kbitem.category,\n            kbi=self.kbitem.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)\n\n\nclass PreSetReply(models.Model):\n    \"\"\"\n    We can allow the admin to define a number of pre-set replies, used to\n    simplify the sending of updates and resolutions. These are basically Django\n    templates with a limited context - however if you wanted to get crafy it would\n    be easy to write a reply that displays ALL updates in hierarchical order etc\n    with use of for loops over {{ ticket.followup_set.all }} and friends.\n\n    When replying to a ticket, the user can select any reply set for the current\n    queue, and the body text is fetched via AJAX.\n    \"\"\"\n    class Meta:\n        ordering = ('name',)\n        verbose_name = _('Pre-set reply')\n        verbose_name_plural = _('Pre-set replies')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank to allow this reply to be used for all '\n                    'queues, or select those queues you wish to limit this reply to.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n        help_text=_('Only used to assist users with selecting a reply - not '\n                    'shown to the user.'),\n    )\n\n    body = models.TextField(\n        _('Body'),\n        help_text=_('Context available: {{ ticket }} - ticket object (eg '\n                    '{{ ticket.title }}); {{ queue }} - The queue; and {{ user }} '\n                    '- the current user.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n\nclass EscalationExclusion(models.Model):\n    \"\"\"\n    An 'EscalationExclusion' lets us define a date on which escalation should\n    not happen, for example a weekend or public holiday.\n\n    You may also have a queue that is only used on one day per week.\n\n    To create these on a regular basis, check out the README file for an\n    example cronjob that runs 'create_escalation_exclusions.py'.\n    \"\"\"\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this exclusion to be applied to all queues, '\n                    'or select those queues you wish to exclude with this entry.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which escalation should not happen'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Escalation exclusion')\n        verbose_name_plural = _('Escalation exclusions')\n\n\nclass EmailTemplate(models.Model):\n    \"\"\"\n    Since these are more likely to be changed than other templates, we store\n    them in the database.\n\n    This means that an admin can change email templates without having to have\n    access to the filesystem.\n    \"\"\"\n\n    template_name = models.CharField(\n        _('Template Name'),\n        max_length=100,\n    )\n\n    subject = models.CharField(\n        _('Subject'),\n        max_length=100,\n        help_text=_('This will be prefixed with \"[ticket.ticket] ticket.title\"'\n                    '. We recommend something simple such as \"(Updated\") or \"(Closed)\"'\n                    ' - the same context is available as in plain_text, below.'),\n    )\n\n    heading = models.CharField(\n        _('Heading'),\n        max_length=100,\n        help_text=_('In HTML e-mails, this will be the heading at the top of '\n                    'the email - the same context is available as in plain_text, '\n                    'below.'),\n    )\n\n    plain_text = models.TextField(\n        _('Plain Text'),\n        help_text=_('The context available to you includes {{ ticket }}, '\n                    '{{ queue }}, and depending on the time of the call: '\n                    '{{ resolution }} or {{ comment }}.'),\n    )\n\n    html = models.TextField(\n        _('HTML'),\n        help_text=_('The same context is available here as in plain_text, above.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this template.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.template_name\n\n    class Meta:\n        ordering = ('template_name', 'locale')\n        verbose_name = _('e-mail template')\n        verbose_name_plural = _('e-mail templates')\n\n\nclass KBCategory(models.Model):\n    \"\"\"\n    Lets help users help themselves: the Knowledge Base is a categorised\n    listing of questions & answers.\n    \"\"\"\n\n    name = models.CharField(\n        _('Name of the category'),\n        max_length=100,\n    )\n\n    title = models.CharField(\n        _('Title on knowledgebase page'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Default queue when creating a ticket after viewing this category.'),\n    )\n\n    public = models.BooleanField(\n        default=True,\n        verbose_name=_(\"Is KBCategory publicly visible?\")\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Knowledge base category')\n        verbose_name_plural = _('Knowledge base categories')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:kb_category', kwargs={'slug': self.slug})\n\n\nclass KBItem(models.Model):\n    \"\"\"\n    An item within the knowledgebase. Very straightforward question/answer\n    style system.\n    \"\"\"\n    voted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='votes',\n    )\n    downvoted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='downvotes',\n    )\n    category = models.ForeignKey(\n        KBCategory,\n        on_delete=models.CASCADE,\n        verbose_name=_('Category'),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    question = models.TextField(\n        _('Question'),\n    )\n\n    answer = models.TextField(\n        _('Answer'),\n    )\n\n    votes = models.IntegerField(\n        _('Votes'),\n        help_text=_('Total number of votes cast for this item'),\n        default=0,\n    )\n\n    recommendations = models.IntegerField(\n        _('Positive Votes'),\n        help_text=_('Number of votes for this item which were POSITIVE.'),\n        default=0,\n    )\n\n    last_updated = models.DateTimeField(\n        _('Last Updated'),\n        help_text=_('The date on which this question was most recently changed.'),\n        blank=True,\n    )\n\n    team = models.ForeignKey(\n        helpdesk_settings.HELPDESK_TEAMS_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('Team'),\n        blank=True,\n        null=True,\n    )\n\n    order = models.PositiveIntegerField(\n        _('Order'),\n        blank=True,\n        null=True,\n    )\n\n    enabled = models.BooleanField(\n        _('Enabled to display to users'),\n        default=True,\n    )\n\n    def save(self, *args, **kwargs):\n        if not self.last_updated:\n            self.last_updated = timezone.now()\n        return super(KBItem, self).save(*args, **kwargs)\n\n    def get_team(self):\n        return helpdesk_settings.HELPDESK_KBITEM_TEAM_GETTER(self)\n\n    def _score(self):\n        \"\"\" Return a score out of 10 or Unrated if no votes \"\"\"\n        if self.votes > 0:\n            return (self.recommendations / self.votes) * 10\n        else:\n            return _('Unrated')\n    score = property(_score)\n\n    def __str__(self):\n        return '%s: %s' % (self.category.title, self.title)\n\n    class Meta:\n        ordering = ('order', 'title',)\n        verbose_name = _('Knowledge base item')\n        verbose_name_plural = _('Knowledge base items')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:kb_category', args=(self.category.slug,))) + \"?kbitem=\" + str(self.pk)\n\n    def query_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:list')) + \"?kbitem=\" + str(self.pk)\n\n    def num_open_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2)).count()\n\n    def unassigned_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2), assigned_to__isnull=True)\n\n    def get_markdown(self):\n        return get_markdown(self.answer)\n\n\nclass SavedSearch(models.Model):\n    \"\"\"\n    Allow a user to save a ticket search, eg their filtering and sorting\n    options, and optionally share it with other users. This lets people\n    easily create a set of commonly-used filters, such as:\n        * My tickets waiting on me\n        * My tickets waiting on submitter\n        * My tickets in 'Priority Support' queue with priority of 1\n        * All tickets containing the word 'billing'.\n         etc...\n    \"\"\"\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('User'),\n    )\n\n    title = models.CharField(\n        _('Query Name'),\n        max_length=100,\n        help_text=_('User-provided name for this query'),\n    )\n\n    shared = models.BooleanField(\n        _('Shared With Other Users?'),\n        blank=True,\n        default=False,\n        help_text=_('Should other users see this query?'),\n    )\n\n    query = models.TextField(\n        _('Search Query'),\n        help_text=_('Pickled query object. Be wary changing this.'),\n    )\n\n    def __str__(self):\n        if self.shared:\n            return '%s (*)' % self.title\n        else:\n            return '%s' % self.title\n\n    class Meta:\n        verbose_name = _('Saved search')\n        verbose_name_plural = _('Saved searches')\n\n\ndef get_default_setting(setting):\n    from helpdesk.settings import DEFAULT_USER_SETTINGS\n    return DEFAULT_USER_SETTINGS[setting]\n\n\ndef login_view_ticketlist_default():\n    return get_default_setting('login_view_ticketlist')\n\n\ndef email_on_ticket_change_default():\n    return get_default_setting('email_on_ticket_change')\n\n\ndef email_on_ticket_assign_default():\n    return get_default_setting('email_on_ticket_assign')\n\n\ndef tickets_per_page_default():\n    return get_default_setting('tickets_per_page')\n\n\ndef use_email_as_submitter_default():\n    return get_default_setting('use_email_as_submitter')\n\n\nclass UserSettings(models.Model):\n    \"\"\"\n    A bunch of user-specific settings that we want to be able to define, such\n    as notification preferences and other things that should probably be\n    configurable.\n    \"\"\"\n    PAGE_SIZES = ((10, '10'), (25, '25'), (50, '50'), (100, '100'))\n\n    user = models.OneToOneField(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name=\"usersettings_helpdesk\")\n\n    settings_pickled = models.TextField(\n        _('DEPRECATED! Settings Dictionary DEPRECATED!'),\n        help_text=_('DEPRECATED! This is a base64-encoded representation of a pickled Python dictionary. '\n                    'Do not change this field via the admin.'),\n        blank=True,\n        null=True,\n    )\n\n    login_view_ticketlist = models.BooleanField(\n        verbose_name=_('Show Ticket List on Login?'),\n        help_text=_('Display the ticket list upon login? Otherwise, the dashboard is shown.'),\n        default=login_view_ticketlist_default,\n    )\n\n    email_on_ticket_change = models.BooleanField(\n        verbose_name=_('E-mail me on ticket change?'),\n        help_text=_(\n            'If you\\'re the ticket owner and the ticket is changed via the web by somebody else,'\n            'do you want to receive an e-mail?'\n        ),\n        default=email_on_ticket_change_default,\n    )\n\n    email_on_ticket_assign = models.BooleanField(\n        verbose_name=_('E-mail me when assigned a ticket?'),\n        help_text=_('If you are assigned a ticket via the web, do you want to receive an e-mail?'),\n        default=email_on_ticket_assign_default,\n    )\n\n    tickets_per_page = models.IntegerField(\n        verbose_name=_('Number of tickets to show per page'),\n        help_text=_('How many tickets do you want to see on the Ticket List page?'),\n        default=tickets_per_page_default,\n        choices=PAGE_SIZES,\n    )\n\n    use_email_as_submitter = models.BooleanField(\n        verbose_name=_('Use my e-mail address when submitting tickets?'),\n        help_text=_('When you submit a ticket, do you want to automatically '\n                    'use your e-mail address as the submitter address? You '\n                    'can type a different e-mail address when entering the '\n                    'ticket if needed, this option only changes the default.'),\n        default=use_email_as_submitter_default,\n    )\n\n    def __str__(self):\n        return 'Preferences for %s' % self.user\n\n    class Meta:\n        verbose_name = _('User Setting')\n        verbose_name_plural = _('User Settings')\n\n\ndef create_usersettings(sender, instance, created, **kwargs):\n    \"\"\"\n    Helper function to create UserSettings instances as\n    required, eg when we first create the UserSettings database\n    table via 'syncdb' or when we save a new user.\n\n    If we end up with users with no UserSettings, then we get horrible\n    'DoesNotExist: UserSettings matching query does not exist.' errors.\n    \"\"\"\n    if created:\n        UserSettings.objects.create(user=instance)\n\n\nmodels.signals.post_save.connect(create_usersettings, sender=settings.AUTH_USER_MODEL)\n\n\nclass IgnoreEmail(models.Model):\n    \"\"\"\n    This model lets us easily ignore e-mails from certain senders when\n    processing IMAP and POP3 mailboxes, eg mails from postmaster or from\n    known trouble-makers.\n    \"\"\"\n    class Meta:\n        verbose_name = _('Ignored e-mail address')\n        verbose_name_plural = _('Ignored e-mail addresses')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this e-mail to be ignored on all queues, '\n                    'or select those queues you wish to ignore this e-mail for.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which this e-mail address was added'),\n        blank=True,\n        editable=False\n    )\n\n    email_address = models.CharField(\n        _('E-Mail Address'),\n        max_length=150,\n        help_text=_('Enter a full e-mail address, or portions with '\n                    'wildcards, eg *@domain.com or postmaster@*.'),\n    )\n\n    keep_in_mailbox = models.BooleanField(\n        _('Save Emails in Mailbox?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to save emails from this address in the mailbox? '\n                    'If this is unticked, emails from this address will be deleted.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    def save(self, *args, **kwargs):\n        if not self.date:\n            self.date = timezone.now()\n        return super(IgnoreEmail, self).save(*args, **kwargs)\n\n    def queue_list(self):\n        \"\"\"Return a list of the queues this IgnoreEmail applies to.\n        If this IgnoreEmail applies to ALL queues, return '*'.\n        \"\"\"\n        queues = self.queues.all().order_by('title')\n        if len(queues) == 0:\n            return '*'\n        else:\n            return ', '.join([str(q) for q in queues])\n\n    def test(self, email):\n        \"\"\"\n        Possible situations:\n            1. Username & Domain both match\n            2. Username is wildcard, domain matches\n            3. Username matches, domain is wildcard\n            4. username & domain are both wildcards\n            5. Other (no match)\n\n            1-4 return True, 5 returns False.\n        \"\"\"\n\n        own_parts = self.email_address.split(\"@\")\n        email_parts = email.split(\"@\")\n\n        if self.email_address == email or \\\n                own_parts[0] == \"*\" and own_parts[1] == email_parts[1] or \\\n                own_parts[1] == \"*\" and own_parts[0] == email_parts[0] or \\\n                own_parts[0] == \"*\" and own_parts[1] == \"*\":\n            return True\n        else:\n            return False\n\n\nclass TicketCC(models.Model):\n    \"\"\"\n    Often, there are people who wish to follow a ticket who aren't the\n    person who originally submitted it. This model provides a way for those\n    people to follow a ticket.\n\n    In this circumstance, a 'person' could be either an e-mail address or\n    an existing system user.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        help_text=_('User who wishes to receive updates for this ticket.'),\n        verbose_name=_('User'),\n    )\n\n    email = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('For non-user followers, enter their e-mail address'),\n    )\n\n    can_view = models.BooleanField(\n        _('Can View Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login to view the ticket details?'),\n    )\n\n    can_update = models.BooleanField(\n        _('Can Update Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login and update the ticket?'),\n    )\n\n    def _email_address(self):\n        if self.user and self.user.email is not None:\n            return self.user.email\n        else:\n            return self.email\n    email_address = property(_email_address)\n\n    def _display(self):\n        if self.user:\n            return self.user\n        else:\n            return self.email\n    display = property(_display)\n\n    def __str__(self):\n        return '%s for %s' % (self.display, self.ticket.title)\n\n    def clean(self):\n        if self.user and not self.user.email:\n            raise ValidationError('User has no email address')\n\n\nclass CustomFieldManager(models.Manager):\n\n    def get_queryset(self):\n        return super(CustomFieldManager, self).get_queryset().order_by('ordering')\n\n\nclass CustomField(models.Model):\n    \"\"\"\n    Definitions for custom fields that are glued onto each ticket.\n    \"\"\"\n\n    name = models.SlugField(\n        _('Field Name'),\n        help_text=_('As used in the database and behind the scenes. '\n                    'Must be unique and consist of only lowercase letters with no punctuation.'),\n        unique=True,\n    )\n\n    label = models.CharField(\n        _('Label'),\n        max_length=30,\n        help_text=_('The display label for this field'),\n    )\n\n    help_text = models.TextField(\n        _('Help Text'),\n        help_text=_('Shown to the user when editing the ticket'),\n        blank=True,\n        null=True\n    )\n\n    DATA_TYPE_CHOICES = (\n        ('varchar', _('Character (single line)')),\n        ('text', _('Text (multi-line)')),\n        ('integer', _('Integer')),\n        ('decimal', _('Decimal')),\n        ('list', _('List')),\n        ('boolean', _('Boolean (checkbox yes/no)')),\n        ('date', _('Date')),\n        ('time', _('Time')),\n        ('datetime', _('Date & Time')),\n        ('email', _('E-Mail Address')),\n        ('url', _('URL')),\n        ('ipaddress', _('IP Address')),\n        ('slug', _('Slug')),\n    )\n\n    data_type = models.CharField(\n        _('Data Type'),\n        max_length=100,\n        help_text=_('Allows you to restrict the data entered into this field'),\n        choices=DATA_TYPE_CHOICES,\n    )\n\n    max_length = models.IntegerField(\n        _('Maximum Length (characters)'),\n        blank=True,\n        null=True,\n    )\n\n    decimal_places = models.IntegerField(\n        _('Decimal Places'),\n        help_text=_('Only used for decimal fields'),\n        blank=True,\n        null=True,\n    )\n\n    empty_selection_list = models.BooleanField(\n        _('Add empty first choice to List?'),\n        default=False,\n        help_text=_('Only for List: adds an empty first entry to the choices list, '\n                    'which enforces that the user makes an active choice.'),\n    )\n\n    list_values = models.TextField(\n        _('List Values'),\n        help_text=_('For list fields only. Enter one option per line.'),\n        blank=True,\n        null=True,\n    )\n\n    ordering = models.IntegerField(\n        _('Ordering'),\n        help_text=_('Lower numbers are displayed first; higher numbers are listed later'),\n        blank=True,\n        null=True,\n    )\n\n    def _choices_as_array(self):\n        valuebuffer = StringIO(self.list_values)\n        choices = [[item.strip(), item.strip()] for item in valuebuffer.readlines()]\n        valuebuffer.close()\n        return choices\n    choices_as_array = property(_choices_as_array)\n\n    required = models.BooleanField(\n        _('Required?'),\n        help_text=_('Does the user have to enter a value for this field?'),\n        default=False,\n    )\n\n    staff_only = models.BooleanField(\n        _('Staff Only?'),\n        help_text=_('If this is ticked, then the public submission form '\n                    'will NOT show this field'),\n        default=False,\n    )\n\n    objects = CustomFieldManager()\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Custom field')\n        verbose_name_plural = _('Custom fields')\n\n\nclass TicketCustomFieldValue(models.Model):\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    field = models.ForeignKey(\n        CustomField,\n        on_delete=models.CASCADE,\n        verbose_name=_('Field'),\n    )\n\n    value = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.field)\n\n    class Meta:\n        unique_together = (('ticket', 'field'),)\n        verbose_name = _('Ticket custom field value')\n        verbose_name_plural = _('Ticket custom field values')\n\n\nclass TicketDependency(models.Model):\n    \"\"\"\n    The ticket identified by `ticket` cannot be resolved until the ticket in `depends_on` has been resolved.\n    To help enforce this, a helper function `can_be_resolved` on each Ticket instance checks that\n    these have all been resolved.\n    \"\"\"\n    class Meta:\n        unique_together = (('ticket', 'depends_on'),)\n        verbose_name = _('Ticket dependency')\n        verbose_name_plural = _('Ticket dependencies')\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n        related_name='ticketdependency',\n    )\n\n    depends_on = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Depends On Ticket'),\n        related_name='depends_on',\n    )\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.depends_on)\n", "code_before": "\"\"\"\ndjango-helpdesk - A Django powered ticket tracker for small enterprise.\n\n(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.\n\nmodels.py - Model (and hence database) definitions. This is the core of the\n            helpdesk structure.\n\"\"\"\n\nfrom django.contrib.auth.models import Permission\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\nfrom django.db import models\nfrom django.conf import settings\nfrom django.utils import timezone\nfrom django.utils.translation import ugettext_lazy as _, ugettext\nfrom io import StringIO\nimport re\nimport os\nimport mimetypes\nimport datetime\n\nfrom django.utils.safestring import mark_safe\nfrom markdown import markdown\nfrom markdown.extensions import Extension\n\n\nimport uuid\n\nfrom helpdesk import settings as helpdesk_settings\n\nfrom .validators import validate_file_extension\n\nfrom .templated_email import send_templated_mail\n\n\ndef format_time_spent(time_spent):\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds % 3600 // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent\n\n\nclass EscapeHtml(Extension):\n    def extendMarkdown(self, md, md_globals):\n        del md.preprocessors['html_block']\n        del md.inlinePatterns['html']\n\n\ndef get_markdown(text):\n    if not text:\n        return \"\"\n\n    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'\n    # Regex check\n    if re.match(pattern, text):\n        # get get value of group regex\n        scheme = re.search(pattern, text, re.IGNORECASE).group(2)\n        # scheme check\n        if scheme in helpdesk_settings.ALLOWED_URL_SCHEMES:\n            replacement = '\\\\1(\\\\2:\\\\3)'\n        else:\n            replacement = '\\\\1(\\\\3)'\n\n        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)\n\n    return mark_safe(\n        markdown(\n            text,\n            extensions=[\n                EscapeHtml(), 'markdown.extensions.nl2br',\n                'markdown.extensions.fenced_code'\n            ]\n        )\n    )\n\n\nclass Queue(models.Model):\n    \"\"\"\n    A queue is a collection of tickets into what would generally be business\n    areas or departments.\n\n    For example, a company may have a queue for each Product they provide, or\n    a queue for each of Accounts, Pre-Sales, and Support.\n\n    \"\"\"\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n        max_length=50,\n        unique=True,\n        help_text=_('This slug is used when building ticket ID\\'s. Once set, '\n                    'try not to change it or e-mailing may get messy.'),\n    )\n\n    email_address = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('All outgoing e-mails for this queue will use this e-mail '\n                    'address. If you use IMAP or POP3, this should be the e-mail '\n                    'address for that mailbox.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this queue. All correspondence in this '\n                    'queue will be in this language.'),\n    )\n\n    allow_public_submission = models.BooleanField(\n        _('Allow Public Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Should this queue be listed on the public submission form?'),\n    )\n\n    allow_email_submission = models.BooleanField(\n        _('Allow E-Mail Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to poll the e-mail box below for new '\n                    'tickets?'),\n    )\n\n    escalate_days = models.IntegerField(\n        _('Escalation Days'),\n        blank=True,\n        null=True,\n        help_text=_('For tickets which are not held, how often do you wish to '\n                    'increase their priority? Set to 0 for no escalation.'),\n    )\n\n    new_ticket_cc = models.CharField(\n        _('New Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all new tickets created for this queue. '\n                    'Enter a comma between multiple e-mail addresses.'),\n    )\n\n    updated_ticket_cc = models.CharField(\n        _('Updated Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all activity (new tickets, closed '\n                    'tickets, updates, reassignments, etc) for this queue. Separate '\n                    'multiple addresses with a comma.'),\n    )\n\n    enable_notifications_on_email_events = models.BooleanField(\n        _('Notify contacts when email updates arrive'),\n        blank=True,\n        default=False,\n        help_text=_('When an email arrives to either create a ticket or to '\n                    'interact with an existing discussion. Should email notifications be sent ? '\n                    'Note: the new_ticket_cc and updated_ticket_cc work independently of this feature'),\n    )\n\n    email_box_type = models.CharField(\n        _('E-Mail Box Type'),\n        max_length=5,\n        choices=(('pop3', _('POP 3')), ('imap', _('IMAP')), ('local', _('Local Directory'))),\n        blank=True,\n        null=True,\n        help_text=_('E-Mail server type for creating tickets automatically '\n                    'from a mailbox - both POP3 and IMAP are supported, as well as '\n                    'reading from a local directory.'),\n    )\n\n    email_box_host = models.CharField(\n        _('E-Mail Hostname'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Your e-mail server address - either the domain name or '\n                    'IP address. May be \"localhost\".'),\n    )\n\n    email_box_port = models.IntegerField(\n        _('E-Mail Port'),\n        blank=True,\n        null=True,\n        help_text=_('Port number to use for accessing e-mail. Default for '\n                    'POP3 is \"110\", and for IMAP is \"143\". This may differ on some '\n                    'servers. Leave it blank to use the defaults.'),\n    )\n\n    email_box_ssl = models.BooleanField(\n        _('Use SSL for E-Mail?'),\n        blank=True,\n        default=False,\n        help_text=_('Whether to use SSL for IMAP or POP3 - the default ports '\n                    'when using SSL are 993 for IMAP and 995 for POP3.'),\n    )\n\n    email_box_user = models.CharField(\n        _('E-Mail Username'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Username for accessing this mailbox.'),\n    )\n\n    email_box_pass = models.CharField(\n        _('E-Mail Password'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Password for the above username'),\n    )\n\n    email_box_imap_folder = models.CharField(\n        _('IMAP Folder'),\n        max_length=100,\n        blank=True,\n        null=True,\n        help_text=_('If using IMAP, what folder do you wish to fetch messages '\n                    'from? This allows you to use one IMAP account for multiple '\n                    'queues, by filtering messages on your IMAP server into separate '\n                    'folders. Default: INBOX.'),\n    )\n\n    email_box_local_dir = models.CharField(\n        _('E-Mail Local Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If using a local directory, what directory path do you '\n                    'wish to poll for new email? '\n                    'Example: /var/lib/mail/helpdesk/'),\n    )\n\n    permission_name = models.CharField(\n        _('Django auth permission name'),\n        max_length=72,  # based on prepare_permission_name() pre-pending chars to slug\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('Name used in the django.contrib.auth permission system'),\n    )\n\n    email_box_interval = models.IntegerField(\n        _('E-Mail Check Interval'),\n        help_text=_('How often do you wish to check this mailbox? (in Minutes)'),\n        blank=True,\n        null=True,\n        default='5',\n    )\n\n    email_box_last_check = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        # This is updated by management/commands/get_mail.py.\n    )\n\n    socks_proxy_type = models.CharField(\n        _('Socks Proxy Type'),\n        max_length=8,\n        choices=(('socks4', _('SOCKS4')), ('socks5', _('SOCKS5'))),\n        blank=True,\n        null=True,\n        help_text=_('SOCKS4 or SOCKS5 allows you to proxy your connections through a SOCKS server.'),\n    )\n\n    socks_proxy_host = models.GenericIPAddressField(\n        _('Socks Proxy Host'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy IP address. Default: 127.0.0.1'),\n    )\n\n    socks_proxy_port = models.IntegerField(\n        _('Socks Proxy Port'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy port number. Default: 9150 (default TOR port)'),\n    )\n\n    logging_type = models.CharField(\n        _('Logging Type'),\n        max_length=5,\n        choices=(\n            ('none', _('None')),\n            ('debug', _('Debug')),\n            ('info', _('Information')),\n            ('warn', _('Warning')),\n            ('error', _('Error')),\n            ('crit', _('Critical'))\n        ),\n        blank=True,\n        null=True,\n        help_text=_('Set the default logging level. All messages at that '\n                    'level or above will be logged to the directory set '\n                    'below. If no level is set, logging will be disabled.'),\n    )\n\n    logging_dir = models.CharField(\n        _('Logging Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If logging is enabled, what directory should we use to '\n                    'store log files for this queue? '\n                    'The standard logging mechanims are used if no directory is set'),\n    )\n\n    default_owner = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.SET_NULL,\n        related_name='default_owner',\n        blank=True,\n        null=True,\n        verbose_name=_('Default owner'),\n    )\n\n    dedicated_time = models.DurationField(\n        help_text=_(\"Time to be spent on this Queue in total\"),\n        blank=True, null=True\n    )\n\n    def __str__(self):\n        return \"%s\" % self.title\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Queue')\n        verbose_name_plural = _('Queues')\n\n    def _from_address(self):\n        \"\"\"\n        Short property to provide a sender address in SMTP format,\n        eg 'Name <email>'. We do this so we can put a simple error message\n        in the sender name field, so hopefully the admin can see and fix it.\n        \"\"\"\n        if not self.email_address:\n            # must check if given in format \"Foo <foo@example.com>\"\n            default_email = re.match(\".*<(?P<email>.*@*.)>\", settings.DEFAULT_FROM_EMAIL)\n            if default_email is not None:\n                # already in the right format, so just include it here\n                return u'NO QUEUE EMAIL ADDRESS DEFINED %s' % settings.DEFAULT_FROM_EMAIL\n            else:\n                return u'NO QUEUE EMAIL ADDRESS DEFINED <%s>' % settings.DEFAULT_FROM_EMAIL\n        else:\n            return u'%s <%s>' % (self.title, self.email_address)\n    from_address = property(_from_address)\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.ticket_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def prepare_permission_name(self):\n        \"\"\"Prepare internally the codename for the permission and store it in permission_name.\n        :return: The codename that can be used to create a new Permission object.\n        \"\"\"\n        # Prepare the permission associated to this Queue\n        basename = \"queue_access_%s\" % self.slug\n        self.permission_name = \"helpdesk.%s\" % basename\n        return basename\n\n    def save(self, *args, **kwargs):\n        if self.email_box_type == 'imap' and not self.email_box_imap_folder:\n            self.email_box_imap_folder = 'INBOX'\n\n        if self.socks_proxy_type:\n            if not self.socks_proxy_host:\n                self.socks_proxy_host = '127.0.0.1'\n            if not self.socks_proxy_port:\n                self.socks_proxy_port = 9150\n        else:\n            self.socks_proxy_host = None\n            self.socks_proxy_port = None\n\n        if not self.email_box_port:\n            if self.email_box_type == 'imap' and self.email_box_ssl:\n                self.email_box_port = 993\n            elif self.email_box_type == 'imap' and not self.email_box_ssl:\n                self.email_box_port = 143\n            elif self.email_box_type == 'pop3' and self.email_box_ssl:\n                self.email_box_port = 995\n            elif self.email_box_type == 'pop3' and not self.email_box_ssl:\n                self.email_box_port = 110\n\n        if not self.id:\n            # Prepare the permission codename and the permission\n            # (even if they are not needed with the current configuration)\n            basename = self.prepare_permission_name()\n\n            Permission.objects.create(\n                name=_(\"Permission for queue: \") + self.title,\n                content_type=ContentType.objects.get_for_model(self.__class__),\n                codename=basename,\n            )\n\n        super(Queue, self).save(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        permission_name = self.permission_name\n        super(Queue, self).delete(*args, **kwargs)\n\n        # once the Queue is safely deleted, remove the permission (if exists)\n        if permission_name:\n            try:\n                p = Permission.objects.get(codename=permission_name[9:])\n                p.delete()\n            except ObjectDoesNotExist:\n                pass\n\n\ndef mk_secret():\n    return str(uuid.uuid4())\n\n\nclass Ticket(models.Model):\n    \"\"\"\n    To allow a ticket to be entered as quickly as possible, only the\n    bare minimum fields are required. These basically allow us to\n    sort and manage the ticket. The user can always go back and\n    enter more information later.\n\n    A good example of this is when a customer is on the phone, and\n    you want to give them a ticket ID as quickly as possible. You can\n    enter some basic info, save the ticket, give the customer the ID\n    and get off the phone, then add in further detail at a later time\n    (once the customer is not on the line).\n\n    Note that assigned_to is optional - unassigned tickets are displayed on\n    the dashboard to prompt users to take ownership of them.\n    \"\"\"\n\n    OPEN_STATUS = 1\n    REOPENED_STATUS = 2\n    RESOLVED_STATUS = 3\n    CLOSED_STATUS = 4\n    DUPLICATE_STATUS = 5\n\n    STATUS_CHOICES = (\n        (OPEN_STATUS, _('Open')),\n        (REOPENED_STATUS, _('Reopened')),\n        (RESOLVED_STATUS, _('Resolved')),\n        (CLOSED_STATUS, _('Closed')),\n        (DUPLICATE_STATUS, _('Duplicate')),\n    )\n\n    PRIORITY_CHOICES = (\n        (1, _('1. Critical')),\n        (2, _('2. High')),\n        (3, _('3. Normal')),\n        (4, _('4. Low')),\n        (5, _('5. Very Low')),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        on_delete=models.CASCADE,\n        verbose_name=_('Queue'),\n    )\n\n    created = models.DateTimeField(\n        _('Created'),\n        blank=True,\n        help_text=_('Date this ticket was first created'),\n    )\n\n    modified = models.DateTimeField(\n        _('Modified'),\n        blank=True,\n        help_text=_('Date this ticket was most recently changed.'),\n    )\n\n    submitter_email = models.EmailField(\n        _('Submitter E-Mail'),\n        blank=True,\n        null=True,\n        help_text=_('The submitter will receive an email for all public '\n                    'follow-ups left for this task.'),\n    )\n\n    assigned_to = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='assigned_to',\n        blank=True,\n        null=True,\n        verbose_name=_('Assigned to'),\n    )\n\n    status = models.IntegerField(\n        _('Status'),\n        choices=STATUS_CHOICES,\n        default=OPEN_STATUS,\n    )\n\n    on_hold = models.BooleanField(\n        _('On Hold'),\n        blank=True,\n        default=False,\n        help_text=_('If a ticket is on hold, it will not automatically be escalated.'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n        blank=True,\n        null=True,\n        help_text=_('The content of the customers query.'),\n    )\n\n    resolution = models.TextField(\n        _('Resolution'),\n        blank=True,\n        null=True,\n        help_text=_('The resolution provided to the customer by our staff.'),\n    )\n\n    priority = models.IntegerField(\n        _('Priority'),\n        choices=PRIORITY_CHOICES,\n        default=3,\n        blank=3,\n        help_text=_('1 = Highest Priority, 5 = Low Priority'),\n    )\n\n    due_date = models.DateTimeField(\n        _('Due on'),\n        blank=True,\n        null=True,\n    )\n\n    last_escalation = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('The date this ticket was last escalated - updated '\n                    'automatically by management/commands/escalate_tickets.py.'),\n    )\n\n    secret_key = models.CharField(\n        _(\"Secret key needed for viewing/editing ticket by non-logged in users\"),\n        max_length=36,\n        default=mk_secret,\n    )\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item the user was viewing when they created this ticket.'),\n    )\n\n    merged_to = models.ForeignKey(\n        'self',\n        verbose_name=_('merged to'),\n        related_name='merged_tickets',\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True\n    )\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.followup_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def send(self, roles, dont_send_to=None, **kwargs):\n        \"\"\"\n        Send notifications to everyone interested in this ticket.\n\n        The the roles argument is a dictionary mapping from roles to (template, context) pairs.\n        If a role is not present in the dictionary, users of that type will not receive the notification.\n\n        The following roles exist:\n\n          - 'submitter'\n          - 'new_ticket_cc'\n          - 'ticket_cc'\n          - 'assigned_to'\n\n        Here is an example roles dictionary:\n\n        {\n            'submitter': (template_name, context),\n            'assigned_to': (template_name2, context),\n        }\n\n        **kwargs are passed to send_templated_mail defined in templated_email.py\n\n        returns the set of email addresses the notification was delivered to.\n\n        \"\"\"\n        recipients = set()\n\n        if dont_send_to is not None:\n            recipients.update(dont_send_to)\n\n        recipients.add(self.queue.email_address)\n\n        def should_receive(email):\n            return email and email not in recipients\n\n        def send(role, recipient):\n            if recipient and recipient not in recipients and role in roles:\n                template, context = roles[role]\n                send_templated_mail(template, context, recipient, sender=self.queue.from_address, **kwargs)\n                recipients.add(recipient)\n\n        send('submitter', self.submitter_email)\n        send('ticket_cc', self.queue.updated_ticket_cc)\n        send('new_ticket_cc', self.queue.new_ticket_cc)\n        if self.assigned_to:\n            send('assigned_to', self.assigned_to.email)\n        if self.queue.enable_notifications_on_email_events:\n            for cc in self.ticketcc_set.all():\n                send('ticket_cc', cc.email_address)\n        return recipients\n\n    def _get_assigned_to(self):\n        \"\"\" Custom property to allow us to easily print 'Unassigned' if a\n        ticket has no owner, or the users name if it's assigned. If the user\n        has a full name configured, we use that, otherwise their username. \"\"\"\n        if not self.assigned_to:\n            return _('Unassigned')\n        else:\n            if self.assigned_to.get_full_name():\n                return self.assigned_to.get_full_name()\n            else:\n                return self.assigned_to.get_username()\n    get_assigned_to = property(_get_assigned_to)\n\n    def _get_ticket(self):\n        \"\"\" A user-friendly ticket ID, which is a combination of ticket ID\n        and queue slug. This is generally used in e-mail subjects. \"\"\"\n\n        return u\"[%s]\" % self.ticket_for_url\n    ticket = property(_get_ticket)\n\n    def _get_ticket_for_url(self):\n        \"\"\" A URL-friendly ticket ID, used in links. \"\"\"\n        return u\"%s-%s\" % (self.queue.slug, self.id)\n    ticket_for_url = property(_get_ticket_for_url)\n\n    def _get_priority_css_class(self):\n        \"\"\"\n        Return the boostrap class corresponding to the priority.\n        \"\"\"\n        if self.priority == 2:\n            return \"warning\"\n        elif self.priority == 1:\n            return \"danger\"\n        elif self.priority == 5:\n            return \"success\"\n        else:\n            return \"\"\n    get_priority_css_class = property(_get_priority_css_class)\n\n    def _get_status(self):\n        \"\"\"\n        Displays the ticket status, with an \"On Hold\" message if needed.\n        \"\"\"\n        held_msg = ''\n        if self.on_hold:\n            held_msg = _(' - On Hold')\n        dep_msg = ''\n        if not self.can_be_resolved:\n            dep_msg = _(' - Open dependencies')\n        return u'%s%s%s' % (self.get_status_display(), held_msg, dep_msg)\n    get_status = property(_get_status)\n\n    def _get_ticket_url(self):\n        \"\"\"\n        Returns a publicly-viewable URL for this ticket, used when giving\n        a URL to the submitter of a ticket.\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s?ticket=%s&email=%s&key=%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:public_view'),\n            self.ticket_for_url,\n            self.submitter_email,\n            self.secret_key\n        )\n    ticket_url = property(_get_ticket_url)\n\n    def _get_staff_url(self):\n        \"\"\"\n        Returns a staff-only URL for this ticket, used when giving a URL to\n        a staff member (in emails etc)\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:view',\n                    args=[self.id])\n        )\n    staff_url = property(_get_staff_url)\n\n    def _can_be_resolved(self):\n        \"\"\"\n        Returns a boolean.\n        True = any dependencies are resolved\n        False = There are non-resolved dependencies\n        \"\"\"\n        OPEN_STATUSES = (Ticket.OPEN_STATUS, Ticket.REOPENED_STATUS)\n        return TicketDependency.objects.filter(ticket=self).filter(\n            depends_on__status__in=OPEN_STATUSES).count() == 0\n    can_be_resolved = property(_can_be_resolved)\n\n    def get_submitter_userprofile(self):\n        User = get_user_model()\n        try:\n            return User.objects.get(email=self.submitter_email)\n        except (User.DoesNotExist, User.MultipleObjectsReturned):\n            return None\n\n    class Meta:\n        get_latest_by = \"created\"\n        ordering = ('id',)\n        verbose_name = _('Ticket')\n        verbose_name_plural = _('Tickets')\n\n    def __str__(self):\n        return '%s %s' % (self.id, self.title)\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:view', args=(self.id,))\n\n    def save(self, *args, **kwargs):\n        if not self.id:\n            # This is a new ticket as no ID yet exists.\n            self.created = timezone.now()\n\n        if not self.priority:\n            self.priority = 3\n\n        self.modified = timezone.now()\n\n        if len(self.title) > 200:\n            self.title = self.title[:197] + \"...\"\n\n        super(Ticket, self).save(*args, **kwargs)\n\n    @staticmethod\n    def queue_and_id_from_query(query):\n        # Apply the opposite logic here compared to self._get_ticket_for_url\n        # Ensure that queues with '-' in them will work\n        parts = query.split('-')\n        queue = '-'.join(parts[0:-1])\n        return queue, parts[-1]\n\n    def get_markdown(self):\n        return get_markdown(self.description)\n\n    @property\n    def get_resolution_markdown(self):\n        return get_markdown(self.resolution)\n\n    def add_email_to_ticketcc_if_not_in(self, email=None, user=None, ticketcc=None):\n        \"\"\"\n        Check that given email/user_email/ticketcc_email is not already present on the ticket\n        (submitter email, assigned to, or in ticket CCs) and add it to a new ticket CC,\n        or move the given one\n\n        :param str email:\n        :param User user:\n        :param TicketCC ticketcc:\n        :rtype: TicketCC|None\n        \"\"\"\n        if ticketcc:\n            email = ticketcc.display\n        elif user:\n            if user.email:\n                email = user.email\n            else:\n                # Ignore if user has no email address\n                return\n        elif not email:\n            raise ValueError('You must provide at least one parameter to get the email from')\n\n        # Prepare all emails already into the ticket\n        ticket_emails = [x.display for x in self.ticketcc_set.all()]\n        if self.submitter_email:\n            ticket_emails.append(self.submitter_email)\n        if self.assigned_to and self.assigned_to.email:\n            ticket_emails.append(self.assigned_to.email)\n\n        # Check that email is not already part of the ticket\n        if email not in ticket_emails:\n            if ticketcc:\n                ticketcc.ticket = self\n                ticketcc.save(update_fields=['ticket'])\n            elif user:\n                ticketcc = self.ticketcc_set.create(user=user)\n            else:\n                ticketcc = self.ticketcc_set.create(email=email)\n            return ticketcc\n\n\nclass FollowUpManager(models.Manager):\n\n    def private_followups(self):\n        return self.filter(public=False)\n\n    def public_followups(self):\n        return self.filter(public=True)\n\n\nclass FollowUp(models.Model):\n    \"\"\"\n    A FollowUp is a comment and/or change to a ticket. We keep a simple\n    title, the comment entered by the user, and the new status of a ticket\n    to enable easy flagging of details on the view-ticket page.\n\n    The title is automatically generated at save-time, based on what action\n    the user took.\n\n    Tickets that aren't public are never shown to or e-mailed to the submitter,\n    although all staff can see them.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    date = models.DateTimeField(\n        _('Date'),\n        default=timezone.now\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n        blank=True,\n        null=True,\n    )\n\n    comment = models.TextField(\n        _('Comment'),\n        blank=True,\n        null=True,\n    )\n\n    public = models.BooleanField(\n        _('Public'),\n        blank=True,\n        default=False,\n        help_text=_(\n            'Public tickets are viewable by the submitter and all '\n            'staff, but non-public tickets can only be seen by staff.'\n        ),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        verbose_name=_('User'),\n    )\n\n    new_status = models.IntegerField(\n        _('New Status'),\n        choices=Ticket.STATUS_CHOICES,\n        blank=True,\n        null=True,\n        help_text=_('If the status was changed, what was it changed to?'),\n    )\n\n    message_id = models.CharField(\n        _('E-Mail ID'),\n        max_length=256,\n        blank=True,\n        null=True,\n        help_text=_(\"The Message ID of the submitter's email.\"),\n        editable=False,\n    )\n\n    objects = FollowUpManager()\n\n    time_spent = models.DurationField(\n        help_text=_(\"Time spent on this follow up\"),\n        blank=True, null=True\n    )\n\n    class Meta:\n        ordering = ('date',)\n        verbose_name = _('Follow-up')\n        verbose_name_plural = _('Follow-ups')\n\n    def __str__(self):\n        return '%s' % self.title\n\n    def get_absolute_url(self):\n        return u\"%s#followup%s\" % (self.ticket.get_absolute_url(), self.id)\n\n    def save(self, *args, **kwargs):\n        t = self.ticket\n        t.modified = timezone.now()\n        t.save()\n        super(FollowUp, self).save(*args, **kwargs)\n\n    def get_markdown(self):\n        return get_markdown(self.comment)\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n\nclass TicketChange(models.Model):\n    \"\"\"\n    For each FollowUp, any changes to the parent ticket (eg Title, Priority,\n    etc) are tracked here for display purposes.\n    \"\"\"\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    field = models.CharField(\n        _('Field'),\n        max_length=100,\n    )\n\n    old_value = models.TextField(\n        _('Old Value'),\n        blank=True,\n        null=True,\n    )\n\n    new_value = models.TextField(\n        _('New Value'),\n        blank=True,\n        null=True,\n    )\n\n    def __str__(self):\n        out = '%s ' % self.field\n        if not self.new_value:\n            out += ugettext('removed')\n        elif not self.old_value:\n            out += ugettext('set to %s') % self.new_value\n        else:\n            out += ugettext('changed from \"%(old_value)s\" to \"%(new_value)s\"') % {\n                'old_value': self.old_value,\n                'new_value': self.new_value\n            }\n        return out\n\n    class Meta:\n        verbose_name = _('Ticket change')\n        verbose_name_plural = _('Ticket changes')\n\n\ndef attachment_path(instance, filename):\n    \"\"\"Just bridge\"\"\"\n    return instance.attachment_path(filename)\n\n\nclass Attachment(models.Model):\n    \"\"\"\n    Represents a file attached to a follow-up. This could come from an e-mail\n    attachment, or it could be uploaded via the web interface.\n    \"\"\"\n\n    file = models.FileField(\n        _('File'),\n        upload_to=attachment_path,\n        max_length=1000,\n        validators=[validate_file_extension]\n    )\n\n    filename = models.CharField(\n        _('Filename'),\n        blank=True,\n        max_length=1000,\n    )\n\n    mime_type = models.CharField(\n        _('MIME Type'),\n        blank=True,\n        max_length=255,\n    )\n\n    size = models.IntegerField(\n        _('Size'),\n        blank=True,\n        help_text=_('Size of this file in bytes'),\n    )\n\n    def __str__(self):\n        return '%s' % self.filename\n\n    def save(self, *args, **kwargs):\n\n        if not self.size:\n            self.size = self.get_size()\n\n        if not self.filename:\n            self.filename = self.get_filename()\n\n        if not self.mime_type:\n            self.mime_type = \\\n                mimetypes.guess_type(self.filename, strict=False)[0] or \\\n                'application/octet-stream'\n\n        return super(Attachment, self).save(*args, **kwargs)\n\n    def get_filename(self):\n        return str(self.file)\n\n    def get_size(self):\n        return self.file.file.size\n\n    def attachment_path(self, filename):\n        \"\"\"Provide a file path that will help prevent files being overwritten, by\n        putting attachments in a folder off attachments for ticket/followup_id/.\n        \"\"\"\n        assert NotImplementedError(\n            \"This method is to be implemented by Attachment classes\"\n        )\n\n    class Meta:\n        ordering = ('filename',)\n        verbose_name = _('Attachment')\n        verbose_name_plural = _('Attachments')\n        abstract = True\n\n\nclass FollowUpAttachment(Attachment):\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/{ticket_for_url}-{secret_key}/{id_}'.format(\n            ticket_for_url=self.followup.ticket.ticket_for_url,\n            secret_key=self.followup.ticket.secret_key,\n            id_=self.followup.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)\n\n\nclass KBIAttachment(Attachment):\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/kb/{category}/{kbi}'.format(\n            category=self.kbitem.category,\n            kbi=self.kbitem.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)\n\n\nclass PreSetReply(models.Model):\n    \"\"\"\n    We can allow the admin to define a number of pre-set replies, used to\n    simplify the sending of updates and resolutions. These are basically Django\n    templates with a limited context - however if you wanted to get crafy it would\n    be easy to write a reply that displays ALL updates in hierarchical order etc\n    with use of for loops over {{ ticket.followup_set.all }} and friends.\n\n    When replying to a ticket, the user can select any reply set for the current\n    queue, and the body text is fetched via AJAX.\n    \"\"\"\n    class Meta:\n        ordering = ('name',)\n        verbose_name = _('Pre-set reply')\n        verbose_name_plural = _('Pre-set replies')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank to allow this reply to be used for all '\n                    'queues, or select those queues you wish to limit this reply to.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n        help_text=_('Only used to assist users with selecting a reply - not '\n                    'shown to the user.'),\n    )\n\n    body = models.TextField(\n        _('Body'),\n        help_text=_('Context available: {{ ticket }} - ticket object (eg '\n                    '{{ ticket.title }}); {{ queue }} - The queue; and {{ user }} '\n                    '- the current user.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n\nclass EscalationExclusion(models.Model):\n    \"\"\"\n    An 'EscalationExclusion' lets us define a date on which escalation should\n    not happen, for example a weekend or public holiday.\n\n    You may also have a queue that is only used on one day per week.\n\n    To create these on a regular basis, check out the README file for an\n    example cronjob that runs 'create_escalation_exclusions.py'.\n    \"\"\"\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this exclusion to be applied to all queues, '\n                    'or select those queues you wish to exclude with this entry.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which escalation should not happen'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Escalation exclusion')\n        verbose_name_plural = _('Escalation exclusions')\n\n\nclass EmailTemplate(models.Model):\n    \"\"\"\n    Since these are more likely to be changed than other templates, we store\n    them in the database.\n\n    This means that an admin can change email templates without having to have\n    access to the filesystem.\n    \"\"\"\n\n    template_name = models.CharField(\n        _('Template Name'),\n        max_length=100,\n    )\n\n    subject = models.CharField(\n        _('Subject'),\n        max_length=100,\n        help_text=_('This will be prefixed with \"[ticket.ticket] ticket.title\"'\n                    '. We recommend something simple such as \"(Updated\") or \"(Closed)\"'\n                    ' - the same context is available as in plain_text, below.'),\n    )\n\n    heading = models.CharField(\n        _('Heading'),\n        max_length=100,\n        help_text=_('In HTML e-mails, this will be the heading at the top of '\n                    'the email - the same context is available as in plain_text, '\n                    'below.'),\n    )\n\n    plain_text = models.TextField(\n        _('Plain Text'),\n        help_text=_('The context available to you includes {{ ticket }}, '\n                    '{{ queue }}, and depending on the time of the call: '\n                    '{{ resolution }} or {{ comment }}.'),\n    )\n\n    html = models.TextField(\n        _('HTML'),\n        help_text=_('The same context is available here as in plain_text, above.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this template.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.template_name\n\n    class Meta:\n        ordering = ('template_name', 'locale')\n        verbose_name = _('e-mail template')\n        verbose_name_plural = _('e-mail templates')\n\n\nclass KBCategory(models.Model):\n    \"\"\"\n    Lets help users help themselves: the Knowledge Base is a categorised\n    listing of questions & answers.\n    \"\"\"\n\n    name = models.CharField(\n        _('Name of the category'),\n        max_length=100,\n    )\n\n    title = models.CharField(\n        _('Title on knowledgebase page'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Default queue when creating a ticket after viewing this category.'),\n    )\n\n    public = models.BooleanField(\n        default=True,\n        verbose_name=_(\"Is KBCategory publicly visible?\")\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Knowledge base category')\n        verbose_name_plural = _('Knowledge base categories')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:kb_category', kwargs={'slug': self.slug})\n\n\nclass KBItem(models.Model):\n    \"\"\"\n    An item within the knowledgebase. Very straightforward question/answer\n    style system.\n    \"\"\"\n    voted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='votes',\n    )\n    downvoted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='downvotes',\n    )\n    category = models.ForeignKey(\n        KBCategory,\n        on_delete=models.CASCADE,\n        verbose_name=_('Category'),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    question = models.TextField(\n        _('Question'),\n    )\n\n    answer = models.TextField(\n        _('Answer'),\n    )\n\n    votes = models.IntegerField(\n        _('Votes'),\n        help_text=_('Total number of votes cast for this item'),\n        default=0,\n    )\n\n    recommendations = models.IntegerField(\n        _('Positive Votes'),\n        help_text=_('Number of votes for this item which were POSITIVE.'),\n        default=0,\n    )\n\n    last_updated = models.DateTimeField(\n        _('Last Updated'),\n        help_text=_('The date on which this question was most recently changed.'),\n        blank=True,\n    )\n\n    team = models.ForeignKey(\n        helpdesk_settings.HELPDESK_TEAMS_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('Team'),\n        blank=True,\n        null=True,\n    )\n\n    order = models.PositiveIntegerField(\n        _('Order'),\n        blank=True,\n        null=True,\n    )\n\n    enabled = models.BooleanField(\n        _('Enabled to display to users'),\n        default=True,\n    )\n\n    def save(self, *args, **kwargs):\n        if not self.last_updated:\n            self.last_updated = timezone.now()\n        return super(KBItem, self).save(*args, **kwargs)\n\n    def get_team(self):\n        return helpdesk_settings.HELPDESK_KBITEM_TEAM_GETTER(self)\n\n    def _score(self):\n        \"\"\" Return a score out of 10 or Unrated if no votes \"\"\"\n        if self.votes > 0:\n            return (self.recommendations / self.votes) * 10\n        else:\n            return _('Unrated')\n    score = property(_score)\n\n    def __str__(self):\n        return '%s: %s' % (self.category.title, self.title)\n\n    class Meta:\n        ordering = ('order', 'title',)\n        verbose_name = _('Knowledge base item')\n        verbose_name_plural = _('Knowledge base items')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:kb_category', args=(self.category.slug,))) + \"?kbitem=\" + str(self.pk)\n\n    def query_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:list')) + \"?kbitem=\" + str(self.pk)\n\n    def num_open_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2)).count()\n\n    def unassigned_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2), assigned_to__isnull=True)\n\n    def get_markdown(self):\n        return get_markdown(self.answer)\n\n\nclass SavedSearch(models.Model):\n    \"\"\"\n    Allow a user to save a ticket search, eg their filtering and sorting\n    options, and optionally share it with other users. This lets people\n    easily create a set of commonly-used filters, such as:\n        * My tickets waiting on me\n        * My tickets waiting on submitter\n        * My tickets in 'Priority Support' queue with priority of 1\n        * All tickets containing the word 'billing'.\n         etc...\n    \"\"\"\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('User'),\n    )\n\n    title = models.CharField(\n        _('Query Name'),\n        max_length=100,\n        help_text=_('User-provided name for this query'),\n    )\n\n    shared = models.BooleanField(\n        _('Shared With Other Users?'),\n        blank=True,\n        default=False,\n        help_text=_('Should other users see this query?'),\n    )\n\n    query = models.TextField(\n        _('Search Query'),\n        help_text=_('Pickled query object. Be wary changing this.'),\n    )\n\n    def __str__(self):\n        if self.shared:\n            return '%s (*)' % self.title\n        else:\n            return '%s' % self.title\n\n    class Meta:\n        verbose_name = _('Saved search')\n        verbose_name_plural = _('Saved searches')\n\n\ndef get_default_setting(setting):\n    from helpdesk.settings import DEFAULT_USER_SETTINGS\n    return DEFAULT_USER_SETTINGS[setting]\n\n\ndef login_view_ticketlist_default():\n    return get_default_setting('login_view_ticketlist')\n\n\ndef email_on_ticket_change_default():\n    return get_default_setting('email_on_ticket_change')\n\n\ndef email_on_ticket_assign_default():\n    return get_default_setting('email_on_ticket_assign')\n\n\ndef tickets_per_page_default():\n    return get_default_setting('tickets_per_page')\n\n\ndef use_email_as_submitter_default():\n    return get_default_setting('use_email_as_submitter')\n\n\nclass UserSettings(models.Model):\n    \"\"\"\n    A bunch of user-specific settings that we want to be able to define, such\n    as notification preferences and other things that should probably be\n    configurable.\n    \"\"\"\n    PAGE_SIZES = ((10, '10'), (25, '25'), (50, '50'), (100, '100'))\n\n    user = models.OneToOneField(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name=\"usersettings_helpdesk\")\n\n    settings_pickled = models.TextField(\n        _('DEPRECATED! Settings Dictionary DEPRECATED!'),\n        help_text=_('DEPRECATED! This is a base64-encoded representation of a pickled Python dictionary. '\n                    'Do not change this field via the admin.'),\n        blank=True,\n        null=True,\n    )\n\n    login_view_ticketlist = models.BooleanField(\n        verbose_name=_('Show Ticket List on Login?'),\n        help_text=_('Display the ticket list upon login? Otherwise, the dashboard is shown.'),\n        default=login_view_ticketlist_default,\n    )\n\n    email_on_ticket_change = models.BooleanField(\n        verbose_name=_('E-mail me on ticket change?'),\n        help_text=_(\n            'If you\\'re the ticket owner and the ticket is changed via the web by somebody else,'\n            'do you want to receive an e-mail?'\n        ),\n        default=email_on_ticket_change_default,\n    )\n\n    email_on_ticket_assign = models.BooleanField(\n        verbose_name=_('E-mail me when assigned a ticket?'),\n        help_text=_('If you are assigned a ticket via the web, do you want to receive an e-mail?'),\n        default=email_on_ticket_assign_default,\n    )\n\n    tickets_per_page = models.IntegerField(\n        verbose_name=_('Number of tickets to show per page'),\n        help_text=_('How many tickets do you want to see on the Ticket List page?'),\n        default=tickets_per_page_default,\n        choices=PAGE_SIZES,\n    )\n\n    use_email_as_submitter = models.BooleanField(\n        verbose_name=_('Use my e-mail address when submitting tickets?'),\n        help_text=_('When you submit a ticket, do you want to automatically '\n                    'use your e-mail address as the submitter address? You '\n                    'can type a different e-mail address when entering the '\n                    'ticket if needed, this option only changes the default.'),\n        default=use_email_as_submitter_default,\n    )\n\n    def __str__(self):\n        return 'Preferences for %s' % self.user\n\n    class Meta:\n        verbose_name = _('User Setting')\n        verbose_name_plural = _('User Settings')\n\n\ndef create_usersettings(sender, instance, created, **kwargs):\n    \"\"\"\n    Helper function to create UserSettings instances as\n    required, eg when we first create the UserSettings database\n    table via 'syncdb' or when we save a new user.\n\n    If we end up with users with no UserSettings, then we get horrible\n    'DoesNotExist: UserSettings matching query does not exist.' errors.\n    \"\"\"\n    if created:\n        UserSettings.objects.create(user=instance)\n\n\nmodels.signals.post_save.connect(create_usersettings, sender=settings.AUTH_USER_MODEL)\n\n\nclass IgnoreEmail(models.Model):\n    \"\"\"\n    This model lets us easily ignore e-mails from certain senders when\n    processing IMAP and POP3 mailboxes, eg mails from postmaster or from\n    known trouble-makers.\n    \"\"\"\n    class Meta:\n        verbose_name = _('Ignored e-mail address')\n        verbose_name_plural = _('Ignored e-mail addresses')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this e-mail to be ignored on all queues, '\n                    'or select those queues you wish to ignore this e-mail for.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which this e-mail address was added'),\n        blank=True,\n        editable=False\n    )\n\n    email_address = models.CharField(\n        _('E-Mail Address'),\n        max_length=150,\n        help_text=_('Enter a full e-mail address, or portions with '\n                    'wildcards, eg *@domain.com or postmaster@*.'),\n    )\n\n    keep_in_mailbox = models.BooleanField(\n        _('Save Emails in Mailbox?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to save emails from this address in the mailbox? '\n                    'If this is unticked, emails from this address will be deleted.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    def save(self, *args, **kwargs):\n        if not self.date:\n            self.date = timezone.now()\n        return super(IgnoreEmail, self).save(*args, **kwargs)\n\n    def queue_list(self):\n        \"\"\"Return a list of the queues this IgnoreEmail applies to.\n        If this IgnoreEmail applies to ALL queues, return '*'.\n        \"\"\"\n        queues = self.queues.all().order_by('title')\n        if len(queues) == 0:\n            return '*'\n        else:\n            return ', '.join([str(q) for q in queues])\n\n    def test(self, email):\n        \"\"\"\n        Possible situations:\n            1. Username & Domain both match\n            2. Username is wildcard, domain matches\n            3. Username matches, domain is wildcard\n            4. username & domain are both wildcards\n            5. Other (no match)\n\n            1-4 return True, 5 returns False.\n        \"\"\"\n\n        own_parts = self.email_address.split(\"@\")\n        email_parts = email.split(\"@\")\n\n        if self.email_address == email or \\\n                own_parts[0] == \"*\" and own_parts[1] == email_parts[1] or \\\n                own_parts[1] == \"*\" and own_parts[0] == email_parts[0] or \\\n                own_parts[0] == \"*\" and own_parts[1] == \"*\":\n            return True\n        else:\n            return False\n\n\nclass TicketCC(models.Model):\n    \"\"\"\n    Often, there are people who wish to follow a ticket who aren't the\n    person who originally submitted it. This model provides a way for those\n    people to follow a ticket.\n\n    In this circumstance, a 'person' could be either an e-mail address or\n    an existing system user.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        help_text=_('User who wishes to receive updates for this ticket.'),\n        verbose_name=_('User'),\n    )\n\n    email = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('For non-user followers, enter their e-mail address'),\n    )\n\n    can_view = models.BooleanField(\n        _('Can View Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login to view the ticket details?'),\n    )\n\n    can_update = models.BooleanField(\n        _('Can Update Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login and update the ticket?'),\n    )\n\n    def _email_address(self):\n        if self.user and self.user.email is not None:\n            return self.user.email\n        else:\n            return self.email\n    email_address = property(_email_address)\n\n    def _display(self):\n        if self.user:\n            return self.user\n        else:\n            return self.email\n    display = property(_display)\n\n    def __str__(self):\n        return '%s for %s' % (self.display, self.ticket.title)\n\n    def clean(self):\n        if self.user and not self.user.email:\n            raise ValidationError('User has no email address')\n\n\nclass CustomFieldManager(models.Manager):\n\n    def get_queryset(self):\n        return super(CustomFieldManager, self).get_queryset().order_by('ordering')\n\n\nclass CustomField(models.Model):\n    \"\"\"\n    Definitions for custom fields that are glued onto each ticket.\n    \"\"\"\n\n    name = models.SlugField(\n        _('Field Name'),\n        help_text=_('As used in the database and behind the scenes. '\n                    'Must be unique and consist of only lowercase letters with no punctuation.'),\n        unique=True,\n    )\n\n    label = models.CharField(\n        _('Label'),\n        max_length=30,\n        help_text=_('The display label for this field'),\n    )\n\n    help_text = models.TextField(\n        _('Help Text'),\n        help_text=_('Shown to the user when editing the ticket'),\n        blank=True,\n        null=True\n    )\n\n    DATA_TYPE_CHOICES = (\n        ('varchar', _('Character (single line)')),\n        ('text', _('Text (multi-line)')),\n        ('integer', _('Integer')),\n        ('decimal', _('Decimal')),\n        ('list', _('List')),\n        ('boolean', _('Boolean (checkbox yes/no)')),\n        ('date', _('Date')),\n        ('time', _('Time')),\n        ('datetime', _('Date & Time')),\n        ('email', _('E-Mail Address')),\n        ('url', _('URL')),\n        ('ipaddress', _('IP Address')),\n        ('slug', _('Slug')),\n    )\n\n    data_type = models.CharField(\n        _('Data Type'),\n        max_length=100,\n        help_text=_('Allows you to restrict the data entered into this field'),\n        choices=DATA_TYPE_CHOICES,\n    )\n\n    max_length = models.IntegerField(\n        _('Maximum Length (characters)'),\n        blank=True,\n        null=True,\n    )\n\n    decimal_places = models.IntegerField(\n        _('Decimal Places'),\n        help_text=_('Only used for decimal fields'),\n        blank=True,\n        null=True,\n    )\n\n    empty_selection_list = models.BooleanField(\n        _('Add empty first choice to List?'),\n        default=False,\n        help_text=_('Only for List: adds an empty first entry to the choices list, '\n                    'which enforces that the user makes an active choice.'),\n    )\n\n    list_values = models.TextField(\n        _('List Values'),\n        help_text=_('For list fields only. Enter one option per line.'),\n        blank=True,\n        null=True,\n    )\n\n    ordering = models.IntegerField(\n        _('Ordering'),\n        help_text=_('Lower numbers are displayed first; higher numbers are listed later'),\n        blank=True,\n        null=True,\n    )\n\n    def _choices_as_array(self):\n        valuebuffer = StringIO(self.list_values)\n        choices = [[item.strip(), item.strip()] for item in valuebuffer.readlines()]\n        valuebuffer.close()\n        return choices\n    choices_as_array = property(_choices_as_array)\n\n    required = models.BooleanField(\n        _('Required?'),\n        help_text=_('Does the user have to enter a value for this field?'),\n        default=False,\n    )\n\n    staff_only = models.BooleanField(\n        _('Staff Only?'),\n        help_text=_('If this is ticked, then the public submission form '\n                    'will NOT show this field'),\n        default=False,\n    )\n\n    objects = CustomFieldManager()\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Custom field')\n        verbose_name_plural = _('Custom fields')\n\n\nclass TicketCustomFieldValue(models.Model):\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    field = models.ForeignKey(\n        CustomField,\n        on_delete=models.CASCADE,\n        verbose_name=_('Field'),\n    )\n\n    value = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.field)\n\n    class Meta:\n        unique_together = (('ticket', 'field'),)\n        verbose_name = _('Ticket custom field value')\n        verbose_name_plural = _('Ticket custom field values')\n\n\nclass TicketDependency(models.Model):\n    \"\"\"\n    The ticket identified by `ticket` cannot be resolved until the ticket in `depends_on` has been resolved.\n    To help enforce this, a helper function `can_be_resolved` on each Ticket instance checks that\n    these have all been resolved.\n    \"\"\"\n    class Meta:\n        unique_together = (('ticket', 'depends_on'),)\n        verbose_name = _('Ticket dependency')\n        verbose_name_plural = _('Ticket dependencies')\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n        related_name='ticketdependency',\n    )\n\n    depends_on = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Depends On Ticket'),\n        related_name='depends_on',\n    )\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.depends_on)\n", "patch": "@@ -56,7 +56,7 @@ def get_markdown(text):\n     if not text:\n         return \"\"\n \n-    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'\n+    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\s\\S]*?)\\)'\n     # Regex check\n     if re.match(pattern, text):\n         # get get value of group regex", "file_path": "files/2021_12/940", "file_language": "py", "file_name": "helpdesk/models.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 1, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def format_time_spent(time_spent):\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds % 3600 // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent", "target": 0}, {"function": "class EscapeHtml(Extension):\n    def extendMarkdown(self, md, md_globals):\n        del md.preprocessors['html_block']\n        del md.inlinePatterns['html']", "target": 0}, {"function": "def get_markdown(text):\n    if not text:\n        return \"\"\n\n    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\[\\s\\S\\]]*?)\\)'\n    # Regex check\n    if re.match(pattern, text):\n        # get get value of group regex\n        scheme = re.search(pattern, text, re.IGNORECASE).group(2)\n        # scheme check\n        if scheme in helpdesk_settings.ALLOWED_URL_SCHEMES:\n            replacement = '\\\\1(\\\\2:\\\\3)'\n        else:\n            replacement = '\\\\1(\\\\3)'\n\n        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)\n\n    return mark_safe(\n        markdown(\n            text,\n            extensions=[\n                EscapeHtml(), 'markdown.extensions.nl2br',\n                'markdown.extensions.fenced_code'\n            ]\n        )\n    )", "target": 0}, {"function": "class Queue(models.Model):\n    \"\"\"\n    A queue is a collection of tickets into what would generally be business\n    areas or departments.\n\n    For example, a company may have a queue for each Product they provide, or\n    a queue for each of Accounts, Pre-Sales, and Support.\n\n    \"\"\"\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n        max_length=50,\n        unique=True,\n        help_text=_('This slug is used when building ticket ID\\'s. Once set, '\n                    'try not to change it or e-mailing may get messy.'),\n    )\n\n    email_address = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('All outgoing e-mails for this queue will use this e-mail '\n                    'address. If you use IMAP or POP3, this should be the e-mail '\n                    'address for that mailbox.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this queue. All correspondence in this '\n                    'queue will be in this language.'),\n    )\n\n    allow_public_submission = models.BooleanField(\n        _('Allow Public Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Should this queue be listed on the public submission form?'),\n    )\n\n    allow_email_submission = models.BooleanField(\n        _('Allow E-Mail Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to poll the e-mail box below for new '\n                    'tickets?'),\n    )\n\n    escalate_days = models.IntegerField(\n        _('Escalation Days'),\n        blank=True,\n        null=True,\n        help_text=_('For tickets which are not held, how often do you wish to '\n                    'increase their priority? Set to 0 for no escalation.'),\n    )\n\n    new_ticket_cc = models.CharField(\n        _('New Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all new tickets created for this queue. '\n                    'Enter a comma between multiple e-mail addresses.'),\n    )\n\n    updated_ticket_cc = models.CharField(\n        _('Updated Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all activity (new tickets, closed '\n                    'tickets, updates, reassignments, etc) for this queue. Separate '\n                    'multiple addresses with a comma.'),\n    )\n\n    enable_notifications_on_email_events = models.BooleanField(\n        _('Notify contacts when email updates arrive'),\n        blank=True,\n        default=False,\n        help_text=_('When an email arrives to either create a ticket or to '\n                    'interact with an existing discussion. Should email notifications be sent ? '\n                    'Note: the new_ticket_cc and updated_ticket_cc work independently of this feature'),\n    )\n\n    email_box_type = models.CharField(\n        _('E-Mail Box Type'),\n        max_length=5,\n        choices=(('pop3', _('POP 3')), ('imap', _('IMAP')), ('local', _('Local Directory'))),\n        blank=True,\n        null=True,\n        help_text=_('E-Mail server type for creating tickets automatically '\n                    'from a mailbox - both POP3 and IMAP are supported, as well as '\n                    'reading from a local directory.'),\n    )\n\n    email_box_host = models.CharField(\n        _('E-Mail Hostname'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Your e-mail server address - either the domain name or '\n                    'IP address. May be \"localhost\".'),\n    )\n\n    email_box_port = models.IntegerField(\n        _('E-Mail Port'),\n        blank=True,\n        null=True,\n        help_text=_('Port number to use for accessing e-mail. Default for '\n                    'POP3 is \"110\", and for IMAP is \"143\". This may differ on some '\n                    'servers. Leave it blank to use the defaults.'),\n    )\n\n    email_box_ssl = models.BooleanField(\n        _('Use SSL for E-Mail?'),\n        blank=True,\n        default=False,\n        help_text=_('Whether to use SSL for IMAP or POP3 - the default ports '\n                    'when using SSL are 993 for IMAP and 995 for POP3.'),\n    )\n\n    email_box_user = models.CharField(\n        _('E-Mail Username'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Username for accessing this mailbox.'),\n    )\n\n    email_box_pass = models.CharField(\n        _('E-Mail Password'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Password for the above username'),\n    )\n\n    email_box_imap_folder = models.CharField(\n        _('IMAP Folder'),\n        max_length=100,\n        blank=True,\n        null=True,\n        help_text=_('If using IMAP, what folder do you wish to fetch messages '\n                    'from? This allows you to use one IMAP account for multiple '\n                    'queues, by filtering messages on your IMAP server into separate '\n                    'folders. Default: INBOX.'),\n    )\n\n    email_box_local_dir = models.CharField(\n        _('E-Mail Local Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If using a local directory, what directory path do you '\n                    'wish to poll for new email? '\n                    'Example: /var/lib/mail/helpdesk/'),\n    )\n\n    permission_name = models.CharField(\n        _('Django auth permission name'),\n        max_length=72,  # based on prepare_permission_name() pre-pending chars to slug\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('Name used in the django.contrib.auth permission system'),\n    )\n\n    email_box_interval = models.IntegerField(\n        _('E-Mail Check Interval'),\n        help_text=_('How often do you wish to check this mailbox? (in Minutes)'),\n        blank=True,\n        null=True,\n        default='5',\n    )\n\n    email_box_last_check = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        # This is updated by management/commands/get_mail.py.\n    )\n\n    socks_proxy_type = models.CharField(\n        _('Socks Proxy Type'),\n        max_length=8,\n        choices=(('socks4', _('SOCKS4')), ('socks5', _('SOCKS5'))),\n        blank=True,\n        null=True,\n        help_text=_('SOCKS4 or SOCKS5 allows you to proxy your connections through a SOCKS server.'),\n    )\n\n    socks_proxy_host = models.GenericIPAddressField(\n        _('Socks Proxy Host'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy IP address. Default: 127.0.0.1'),\n    )\n\n    socks_proxy_port = models.IntegerField(\n        _('Socks Proxy Port'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy port number. Default: 9150 (default TOR port)'),\n    )\n\n    logging_type = models.CharField(\n        _('Logging Type'),\n        max_length=5,\n        choices=(\n            ('none', _('None')),\n            ('debug', _('Debug')),\n            ('info', _('Information')),\n            ('warn', _('Warning')),\n            ('error', _('Error')),\n            ('crit', _('Critical'))\n        ),\n        blank=True,\n        null=True,\n        help_text=_('Set the default logging level. All messages at that '\n                    'level or above will be logged to the directory set '\n                    'below. If no level is set, logging will be disabled.'),\n    )\n\n    logging_dir = models.CharField(\n        _('Logging Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If logging is enabled, what directory should we use to '\n                    'store log files for this queue? '\n                    'The standard logging mechanims are used if no directory is set'),\n    )\n\n    default_owner = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.SET_NULL,\n        related_name='default_owner',\n        blank=True,\n        null=True,\n        verbose_name=_('Default owner'),\n    )\n\n    dedicated_time = models.DurationField(\n        help_text=_(\"Time to be spent on this Queue in total\"),\n        blank=True, null=True\n    )\n\n    def __str__(self):\n        return \"%s\" % self.title\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Queue')\n        verbose_name_plural = _('Queues')\n\n    def _from_address(self):\n        \"\"\"\n        Short property to provide a sender address in SMTP format,\n        eg 'Name <email>'. We do this so we can put a simple error message\n        in the sender name field, so hopefully the admin can see and fix it.\n        \"\"\"\n        if not self.email_address:\n            # must check if given in format \"Foo <foo@example.com>\"\n            default_email = re.match(\".*<(?P<email>.*@*.)>\", settings.DEFAULT_FROM_EMAIL)\n            if default_email is not None:\n                # already in the right format, so just include it here\n                return u'NO QUEUE EMAIL ADDRESS DEFINED %s' % settings.DEFAULT_FROM_EMAIL\n            else:\n                return u'NO QUEUE EMAIL ADDRESS DEFINED <%s>' % settings.DEFAULT_FROM_EMAIL\n        else:\n            return u'%s <%s>' % (self.title, self.email_address)\n    from_address = property(_from_address)\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.ticket_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def prepare_permission_name(self):\n        \"\"\"Prepare internally the codename for the permission and store it in permission_name.\n        :return: The codename that can be used to create a new Permission object.\n        \"\"\"\n        # Prepare the permission associated to this Queue\n        basename = \"queue_access_%s\" % self.slug\n        self.permission_name = \"helpdesk.%s\" % basename\n        return basename\n\n    def save(self, *args, **kwargs):\n        if self.email_box_type == 'imap' and not self.email_box_imap_folder:\n            self.email_box_imap_folder = 'INBOX'\n\n        if self.socks_proxy_type:\n            if not self.socks_proxy_host:\n                self.socks_proxy_host = '127.0.0.1'\n            if not self.socks_proxy_port:\n                self.socks_proxy_port = 9150\n        else:\n            self.socks_proxy_host = None\n            self.socks_proxy_port = None\n\n        if not self.email_box_port:\n            if self.email_box_type == 'imap' and self.email_box_ssl:\n                self.email_box_port = 993\n            elif self.email_box_type == 'imap' and not self.email_box_ssl:\n                self.email_box_port = 143\n            elif self.email_box_type == 'pop3' and self.email_box_ssl:\n                self.email_box_port = 995\n            elif self.email_box_type == 'pop3' and not self.email_box_ssl:\n                self.email_box_port = 110\n\n        if not self.id:\n            # Prepare the permission codename and the permission\n            # (even if they are not needed with the current configuration)\n            basename = self.prepare_permission_name()\n\n            Permission.objects.create(\n                name=_(\"Permission for queue: \") + self.title,\n                content_type=ContentType.objects.get_for_model(self.__class__),\n                codename=basename,\n            )\n\n        super(Queue, self).save(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        permission_name = self.permission_name\n        super(Queue, self).delete(*args, **kwargs)\n\n        # once the Queue is safely deleted, remove the permission (if exists)\n        if permission_name:\n            try:\n                p = Permission.objects.get(codename=permission_name[9:])\n                p.delete()\n            except ObjectDoesNotExist:\n                pass", "target": 0}, {"function": "def mk_secret():\n    return str(uuid.uuid4())", "target": 0}, {"function": "class Ticket(models.Model):\n    \"\"\"\n    To allow a ticket to be entered as quickly as possible, only the\n    bare minimum fields are required. These basically allow us to\n    sort and manage the ticket. The user can always go back and\n    enter more information later.\n\n    A good example of this is when a customer is on the phone, and\n    you want to give them a ticket ID as quickly as possible. You can\n    enter some basic info, save the ticket, give the customer the ID\n    and get off the phone, then add in further detail at a later time\n    (once the customer is not on the line).\n\n    Note that assigned_to is optional - unassigned tickets are displayed on\n    the dashboard to prompt users to take ownership of them.\n    \"\"\"\n\n    OPEN_STATUS = 1\n    REOPENED_STATUS = 2\n    RESOLVED_STATUS = 3\n    CLOSED_STATUS = 4\n    DUPLICATE_STATUS = 5\n\n    STATUS_CHOICES = (\n        (OPEN_STATUS, _('Open')),\n        (REOPENED_STATUS, _('Reopened')),\n        (RESOLVED_STATUS, _('Resolved')),\n        (CLOSED_STATUS, _('Closed')),\n        (DUPLICATE_STATUS, _('Duplicate')),\n    )\n\n    PRIORITY_CHOICES = (\n        (1, _('1. Critical')),\n        (2, _('2. High')),\n        (3, _('3. Normal')),\n        (4, _('4. Low')),\n        (5, _('5. Very Low')),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        on_delete=models.CASCADE,\n        verbose_name=_('Queue'),\n    )\n\n    created = models.DateTimeField(\n        _('Created'),\n        blank=True,\n        help_text=_('Date this ticket was first created'),\n    )\n\n    modified = models.DateTimeField(\n        _('Modified'),\n        blank=True,\n        help_text=_('Date this ticket was most recently changed.'),\n    )\n\n    submitter_email = models.EmailField(\n        _('Submitter E-Mail'),\n        blank=True,\n        null=True,\n        help_text=_('The submitter will receive an email for all public '\n                    'follow-ups left for this task.'),\n    )\n\n    assigned_to = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='assigned_to',\n        blank=True,\n        null=True,\n        verbose_name=_('Assigned to'),\n    )\n\n    status = models.IntegerField(\n        _('Status'),\n        choices=STATUS_CHOICES,\n        default=OPEN_STATUS,\n    )\n\n    on_hold = models.BooleanField(\n        _('On Hold'),\n        blank=True,\n        default=False,\n        help_text=_('If a ticket is on hold, it will not automatically be escalated.'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n        blank=True,\n        null=True,\n        help_text=_('The content of the customers query.'),\n    )\n\n    resolution = models.TextField(\n        _('Resolution'),\n        blank=True,\n        null=True,\n        help_text=_('The resolution provided to the customer by our staff.'),\n    )\n\n    priority = models.IntegerField(\n        _('Priority'),\n        choices=PRIORITY_CHOICES,\n        default=3,\n        blank=3,\n        help_text=_('1 = Highest Priority, 5 = Low Priority'),\n    )\n\n    due_date = models.DateTimeField(\n        _('Due on'),\n        blank=True,\n        null=True,\n    )\n\n    last_escalation = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('The date this ticket was last escalated - updated '\n                    'automatically by management/commands/escalate_tickets.py.'),\n    )\n\n    secret_key = models.CharField(\n        _(\"Secret key needed for viewing/editing ticket by non-logged in users\"),\n        max_length=36,\n        default=mk_secret,\n    )\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item the user was viewing when they created this ticket.'),\n    )\n\n    merged_to = models.ForeignKey(\n        'self',\n        verbose_name=_('merged to'),\n        related_name='merged_tickets',\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True\n    )\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.followup_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def send(self, roles, dont_send_to=None, **kwargs):\n        \"\"\"\n        Send notifications to everyone interested in this ticket.\n\n        The the roles argument is a dictionary mapping from roles to (template, context) pairs.\n        If a role is not present in the dictionary, users of that type will not receive the notification.\n\n        The following roles exist:\n\n          - 'submitter'\n          - 'new_ticket_cc'\n          - 'ticket_cc'\n          - 'assigned_to'\n\n        Here is an example roles dictionary:\n\n        {\n            'submitter': (template_name, context),\n            'assigned_to': (template_name2, context),\n        }\n\n        **kwargs are passed to send_templated_mail defined in templated_email.py\n\n        returns the set of email addresses the notification was delivered to.\n\n        \"\"\"\n        recipients = set()\n\n        if dont_send_to is not None:\n            recipients.update(dont_send_to)\n\n        recipients.add(self.queue.email_address)\n\n        def should_receive(email):\n            return email and email not in recipients\n\n        def send(role, recipient):\n            if recipient and recipient not in recipients and role in roles:\n                template, context = roles[role]\n                send_templated_mail(template, context, recipient, sender=self.queue.from_address, **kwargs)\n                recipients.add(recipient)\n\n        send('submitter', self.submitter_email)\n        send('ticket_cc', self.queue.updated_ticket_cc)\n        send('new_ticket_cc', self.queue.new_ticket_cc)\n        if self.assigned_to:\n            send('assigned_to', self.assigned_to.email)\n        if self.queue.enable_notifications_on_email_events:\n            for cc in self.ticketcc_set.all():\n                send('ticket_cc', cc.email_address)\n        return recipients\n\n    def _get_assigned_to(self):\n        \"\"\" Custom property to allow us to easily print 'Unassigned' if a\n        ticket has no owner, or the users name if it's assigned. If the user\n        has a full name configured, we use that, otherwise their username. \"\"\"\n        if not self.assigned_to:\n            return _('Unassigned')\n        else:\n            if self.assigned_to.get_full_name():\n                return self.assigned_to.get_full_name()\n            else:\n                return self.assigned_to.get_username()\n    get_assigned_to = property(_get_assigned_to)\n\n    def _get_ticket(self):\n        \"\"\" A user-friendly ticket ID, which is a combination of ticket ID\n        and queue slug. This is generally used in e-mail subjects. \"\"\"\n\n        return u\"[%s]\" % self.ticket_for_url\n    ticket = property(_get_ticket)\n\n    def _get_ticket_for_url(self):\n        \"\"\" A URL-friendly ticket ID, used in links. \"\"\"\n        return u\"%s-%s\" % (self.queue.slug, self.id)\n    ticket_for_url = property(_get_ticket_for_url)\n\n    def _get_priority_css_class(self):\n        \"\"\"\n        Return the boostrap class corresponding to the priority.\n        \"\"\"\n        if self.priority == 2:\n            return \"warning\"\n        elif self.priority == 1:\n            return \"danger\"\n        elif self.priority == 5:\n            return \"success\"\n        else:\n            return \"\"\n    get_priority_css_class = property(_get_priority_css_class)\n\n    def _get_status(self):\n        \"\"\"\n        Displays the ticket status, with an \"On Hold\" message if needed.\n        \"\"\"\n        held_msg = ''\n        if self.on_hold:\n            held_msg = _(' - On Hold')\n        dep_msg = ''\n        if not self.can_be_resolved:\n            dep_msg = _(' - Open dependencies')\n        return u'%s%s%s' % (self.get_status_display(), held_msg, dep_msg)\n    get_status = property(_get_status)\n\n    def _get_ticket_url(self):\n        \"\"\"\n        Returns a publicly-viewable URL for this ticket, used when giving\n        a URL to the submitter of a ticket.\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s?ticket=%s&email=%s&key=%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:public_view'),\n            self.ticket_for_url,\n            self.submitter_email,\n            self.secret_key\n        )\n    ticket_url = property(_get_ticket_url)\n\n    def _get_staff_url(self):\n        \"\"\"\n        Returns a staff-only URL for this ticket, used when giving a URL to\n        a staff member (in emails etc)\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:view',\n                    args=[self.id])\n        )\n    staff_url = property(_get_staff_url)\n\n    def _can_be_resolved(self):\n        \"\"\"\n        Returns a boolean.\n        True = any dependencies are resolved\n        False = There are non-resolved dependencies\n        \"\"\"\n        OPEN_STATUSES = (Ticket.OPEN_STATUS, Ticket.REOPENED_STATUS)\n        return TicketDependency.objects.filter(ticket=self).filter(\n            depends_on__status__in=OPEN_STATUSES).count() == 0\n    can_be_resolved = property(_can_be_resolved)\n\n    def get_submitter_userprofile(self):\n        User = get_user_model()\n        try:\n            return User.objects.get(email=self.submitter_email)\n        except (User.DoesNotExist, User.MultipleObjectsReturned):\n            return None\n\n    class Meta:\n        get_latest_by = \"created\"\n        ordering = ('id',)\n        verbose_name = _('Ticket')\n        verbose_name_plural = _('Tickets')\n\n    def __str__(self):\n        return '%s %s' % (self.id, self.title)\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:view', args=(self.id,))\n\n    def save(self, *args, **kwargs):\n        if not self.id:\n            # This is a new ticket as no ID yet exists.\n            self.created = timezone.now()\n\n        if not self.priority:\n            self.priority = 3\n\n        self.modified = timezone.now()\n\n        if len(self.title) > 200:\n            self.title = self.title[:197] + \"...\"\n\n        super(Ticket, self).save(*args, **kwargs)\n\n    @staticmethod\n    def queue_and_id_from_query(query):\n        # Apply the opposite logic here compared to self._get_ticket_for_url\n        # Ensure that queues with '-' in them will work\n        parts = query.split('-')\n        queue = '-'.join(parts[0:-1])\n        return queue, parts[-1]\n\n    def get_markdown(self):\n        return get_markdown(self.description)\n\n    @property\n    def get_resolution_markdown(self):\n        return get_markdown(self.resolution)\n\n    def add_email_to_ticketcc_if_not_in(self, email=None, user=None, ticketcc=None):\n        \"\"\"\n        Check that given email/user_email/ticketcc_email is not already present on the ticket\n        (submitter email, assigned to, or in ticket CCs) and add it to a new ticket CC,\n        or move the given one\n\n        :param str email:\n        :param User user:\n        :param TicketCC ticketcc:\n        :rtype: TicketCC|None\n        \"\"\"\n        if ticketcc:\n            email = ticketcc.display\n        elif user:\n            if user.email:\n                email = user.email\n            else:\n                # Ignore if user has no email address\n                return\n        elif not email:\n            raise ValueError('You must provide at least one parameter to get the email from')\n\n        # Prepare all emails already into the ticket\n        ticket_emails = [x.display for x in self.ticketcc_set.all()]\n        if self.submitter_email:\n            ticket_emails.append(self.submitter_email)\n        if self.assigned_to and self.assigned_to.email:\n            ticket_emails.append(self.assigned_to.email)\n\n        # Check that email is not already part of the ticket\n        if email not in ticket_emails:\n            if ticketcc:\n                ticketcc.ticket = self\n                ticketcc.save(update_fields=['ticket'])\n            elif user:\n                ticketcc = self.ticketcc_set.create(user=user)\n            else:\n                ticketcc = self.ticketcc_set.create(email=email)\n            return ticketcc", "target": 0}, {"function": "class FollowUpManager(models.Manager):\n\n    def private_followups(self):\n        return self.filter(public=False)\n\n    def public_followups(self):\n        return self.filter(public=True)", "target": 0}, {"function": "class FollowUp(models.Model):\n    \"\"\"\n    A FollowUp is a comment and/or change to a ticket. We keep a simple\n    title, the comment entered by the user, and the new status of a ticket\n    to enable easy flagging of details on the view-ticket page.\n\n    The title is automatically generated at save-time, based on what action\n    the user took.\n\n    Tickets that aren't public are never shown to or e-mailed to the submitter,\n    although all staff can see them.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    date = models.DateTimeField(\n        _('Date'),\n        default=timezone.now\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n        blank=True,\n        null=True,\n    )\n\n    comment = models.TextField(\n        _('Comment'),\n        blank=True,\n        null=True,\n    )\n\n    public = models.BooleanField(\n        _('Public'),\n        blank=True,\n        default=False,\n        help_text=_(\n            'Public tickets are viewable by the submitter and all '\n            'staff, but non-public tickets can only be seen by staff.'\n        ),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        verbose_name=_('User'),\n    )\n\n    new_status = models.IntegerField(\n        _('New Status'),\n        choices=Ticket.STATUS_CHOICES,\n        blank=True,\n        null=True,\n        help_text=_('If the status was changed, what was it changed to?'),\n    )\n\n    message_id = models.CharField(\n        _('E-Mail ID'),\n        max_length=256,\n        blank=True,\n        null=True,\n        help_text=_(\"The Message ID of the submitter's email.\"),\n        editable=False,\n    )\n\n    objects = FollowUpManager()\n\n    time_spent = models.DurationField(\n        help_text=_(\"Time spent on this follow up\"),\n        blank=True, null=True\n    )\n\n    class Meta:\n        ordering = ('date',)\n        verbose_name = _('Follow-up')\n        verbose_name_plural = _('Follow-ups')\n\n    def __str__(self):\n        return '%s' % self.title\n\n    def get_absolute_url(self):\n        return u\"%s#followup%s\" % (self.ticket.get_absolute_url(), self.id)\n\n    def save(self, *args, **kwargs):\n        t = self.ticket\n        t.modified = timezone.now()\n        t.save()\n        super(FollowUp, self).save(*args, **kwargs)\n\n    def get_markdown(self):\n        return get_markdown(self.comment)\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)", "target": 0}, {"function": "class TicketChange(models.Model):\n    \"\"\"\n    For each FollowUp, any changes to the parent ticket (eg Title, Priority,\n    etc) are tracked here for display purposes.\n    \"\"\"\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    field = models.CharField(\n        _('Field'),\n        max_length=100,\n    )\n\n    old_value = models.TextField(\n        _('Old Value'),\n        blank=True,\n        null=True,\n    )\n\n    new_value = models.TextField(\n        _('New Value'),\n        blank=True,\n        null=True,\n    )\n\n    def __str__(self):\n        out = '%s ' % self.field\n        if not self.new_value:\n            out += ugettext('removed')\n        elif not self.old_value:\n            out += ugettext('set to %s') % self.new_value\n        else:\n            out += ugettext('changed from \"%(old_value)s\" to \"%(new_value)s\"') % {\n                'old_value': self.old_value,\n                'new_value': self.new_value\n            }\n        return out\n\n    class Meta:\n        verbose_name = _('Ticket change')\n        verbose_name_plural = _('Ticket changes')", "target": 0}, {"function": "def attachment_path(instance, filename):\n    \"\"\"Just bridge\"\"\"\n    return instance.attachment_path(filename)", "target": 0}, {"function": "class Attachment(models.Model):\n    \"\"\"\n    Represents a file attached to a follow-up. This could come from an e-mail\n    attachment, or it could be uploaded via the web interface.\n    \"\"\"\n\n    file = models.FileField(\n        _('File'),\n        upload_to=attachment_path,\n        max_length=1000,\n        validators=[validate_file_extension]\n    )\n\n    filename = models.CharField(\n        _('Filename'),\n        blank=True,\n        max_length=1000,\n    )\n\n    mime_type = models.CharField(\n        _('MIME Type'),\n        blank=True,\n        max_length=255,\n    )\n\n    size = models.IntegerField(\n        _('Size'),\n        blank=True,\n        help_text=_('Size of this file in bytes'),\n    )\n\n    def __str__(self):\n        return '%s' % self.filename\n\n    def save(self, *args, **kwargs):\n\n        if not self.size:\n            self.size = self.get_size()\n\n        if not self.filename:\n            self.filename = self.get_filename()\n\n        if not self.mime_type:\n            self.mime_type = \\\n                mimetypes.guess_type(self.filename, strict=False)[0] or \\\n                'application/octet-stream'\n\n        return super(Attachment, self).save(*args, **kwargs)\n\n    def get_filename(self):\n        return str(self.file)\n\n    def get_size(self):\n        return self.file.file.size\n\n    def attachment_path(self, filename):\n        \"\"\"Provide a file path that will help prevent files being overwritten, by\n        putting attachments in a folder off attachments for ticket/followup_id/.\n        \"\"\"\n        assert NotImplementedError(\n            \"This method is to be implemented by Attachment classes\"\n        )\n\n    class Meta:\n        ordering = ('filename',)\n        verbose_name = _('Attachment')\n        verbose_name_plural = _('Attachments')\n        abstract = True", "target": 0}, {"function": "class FollowUpAttachment(Attachment):\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/{ticket_for_url}-{secret_key}/{id_}'.format(\n            ticket_for_url=self.followup.ticket.ticket_for_url,\n            secret_key=self.followup.ticket.secret_key,\n            id_=self.followup.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)", "target": 0}, {"function": "class KBIAttachment(Attachment):\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/kb/{category}/{kbi}'.format(\n            category=self.kbitem.category,\n            kbi=self.kbitem.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)", "target": 0}, {"function": "class PreSetReply(models.Model):\n    \"\"\"\n    We can allow the admin to define a number of pre-set replies, used to\n    simplify the sending of updates and resolutions. These are basically Django\n    templates with a limited context - however if you wanted to get crafy it would\n    be easy to write a reply that displays ALL updates in hierarchical order etc\n    with use of for loops over {{ ticket.followup_set.all }} and friends.\n\n    When replying to a ticket, the user can select any reply set for the current\n    queue, and the body text is fetched via AJAX.\n    \"\"\"\n    class Meta:\n        ordering = ('name',)\n        verbose_name = _('Pre-set reply')\n        verbose_name_plural = _('Pre-set replies')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank to allow this reply to be used for all '\n                    'queues, or select those queues you wish to limit this reply to.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n        help_text=_('Only used to assist users with selecting a reply - not '\n                    'shown to the user.'),\n    )\n\n    body = models.TextField(\n        _('Body'),\n        help_text=_('Context available: {{ ticket }} - ticket object (eg '\n                    '{{ ticket.title }}); {{ queue }} - The queue; and {{ user }} '\n                    '- the current user.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name", "target": 0}, {"function": "class EscalationExclusion(models.Model):\n    \"\"\"\n    An 'EscalationExclusion' lets us define a date on which escalation should\n    not happen, for example a weekend or public holiday.\n\n    You may also have a queue that is only used on one day per week.\n\n    To create these on a regular basis, check out the README file for an\n    example cronjob that runs 'create_escalation_exclusions.py'.\n    \"\"\"\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this exclusion to be applied to all queues, '\n                    'or select those queues you wish to exclude with this entry.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which escalation should not happen'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Escalation exclusion')\n        verbose_name_plural = _('Escalation exclusions')", "target": 0}, {"function": "class EmailTemplate(models.Model):\n    \"\"\"\n    Since these are more likely to be changed than other templates, we store\n    them in the database.\n\n    This means that an admin can change email templates without having to have\n    access to the filesystem.\n    \"\"\"\n\n    template_name = models.CharField(\n        _('Template Name'),\n        max_length=100,\n    )\n\n    subject = models.CharField(\n        _('Subject'),\n        max_length=100,\n        help_text=_('This will be prefixed with \"[ticket.ticket] ticket.title\"'\n                    '. We recommend something simple such as \"(Updated\") or \"(Closed)\"'\n                    ' - the same context is available as in plain_text, below.'),\n    )\n\n    heading = models.CharField(\n        _('Heading'),\n        max_length=100,\n        help_text=_('In HTML e-mails, this will be the heading at the top of '\n                    'the email - the same context is available as in plain_text, '\n                    'below.'),\n    )\n\n    plain_text = models.TextField(\n        _('Plain Text'),\n        help_text=_('The context available to you includes {{ ticket }}, '\n                    '{{ queue }}, and depending on the time of the call: '\n                    '{{ resolution }} or {{ comment }}.'),\n    )\n\n    html = models.TextField(\n        _('HTML'),\n        help_text=_('The same context is available here as in plain_text, above.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this template.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.template_name\n\n    class Meta:\n        ordering = ('template_name', 'locale')\n        verbose_name = _('e-mail template')\n        verbose_name_plural = _('e-mail templates')", "target": 0}, {"function": "class KBCategory(models.Model):\n    \"\"\"\n    Lets help users help themselves: the Knowledge Base is a categorised\n    listing of questions & answers.\n    \"\"\"\n\n    name = models.CharField(\n        _('Name of the category'),\n        max_length=100,\n    )\n\n    title = models.CharField(\n        _('Title on knowledgebase page'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Default queue when creating a ticket after viewing this category.'),\n    )\n\n    public = models.BooleanField(\n        default=True,\n        verbose_name=_(\"Is KBCategory publicly visible?\")\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Knowledge base category')\n        verbose_name_plural = _('Knowledge base categories')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:kb_category', kwargs={'slug': self.slug})", "target": 0}, {"function": "class KBItem(models.Model):\n    \"\"\"\n    An item within the knowledgebase. Very straightforward question/answer\n    style system.\n    \"\"\"\n    voted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='votes',\n    )\n    downvoted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='downvotes',\n    )\n    category = models.ForeignKey(\n        KBCategory,\n        on_delete=models.CASCADE,\n        verbose_name=_('Category'),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    question = models.TextField(\n        _('Question'),\n    )\n\n    answer = models.TextField(\n        _('Answer'),\n    )\n\n    votes = models.IntegerField(\n        _('Votes'),\n        help_text=_('Total number of votes cast for this item'),\n        default=0,\n    )\n\n    recommendations = models.IntegerField(\n        _('Positive Votes'),\n        help_text=_('Number of votes for this item which were POSITIVE.'),\n        default=0,\n    )\n\n    last_updated = models.DateTimeField(\n        _('Last Updated'),\n        help_text=_('The date on which this question was most recently changed.'),\n        blank=True,\n    )\n\n    team = models.ForeignKey(\n        helpdesk_settings.HELPDESK_TEAMS_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('Team'),\n        blank=True,\n        null=True,\n    )\n\n    order = models.PositiveIntegerField(\n        _('Order'),\n        blank=True,\n        null=True,\n    )\n\n    enabled = models.BooleanField(\n        _('Enabled to display to users'),\n        default=True,\n    )\n\n    def save(self, *args, **kwargs):\n        if not self.last_updated:\n            self.last_updated = timezone.now()\n        return super(KBItem, self).save(*args, **kwargs)\n\n    def get_team(self):\n        return helpdesk_settings.HELPDESK_KBITEM_TEAM_GETTER(self)\n\n    def _score(self):\n        \"\"\" Return a score out of 10 or Unrated if no votes \"\"\"\n        if self.votes > 0:\n            return (self.recommendations / self.votes) * 10\n        else:\n            return _('Unrated')\n    score = property(_score)\n\n    def __str__(self):\n        return '%s: %s' % (self.category.title, self.title)\n\n    class Meta:\n        ordering = ('order', 'title',)\n        verbose_name = _('Knowledge base item')\n        verbose_name_plural = _('Knowledge base items')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:kb_category', args=(self.category.slug,))) + \"?kbitem=\" + str(self.pk)\n\n    def query_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:list')) + \"?kbitem=\" + str(self.pk)\n\n    def num_open_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2)).count()\n\n    def unassigned_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2), assigned_to__isnull=True)\n\n    def get_markdown(self):\n        return get_markdown(self.answer)", "target": 0}, {"function": "class SavedSearch(models.Model):\n    \"\"\"\n    Allow a user to save a ticket search, eg their filtering and sorting\n    options, and optionally share it with other users. This lets people\n    easily create a set of commonly-used filters, such as:\n        * My tickets waiting on me\n        * My tickets waiting on submitter\n        * My tickets in 'Priority Support' queue with priority of 1\n        * All tickets containing the word 'billing'.\n         etc...\n    \"\"\"\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('User'),\n    )\n\n    title = models.CharField(\n        _('Query Name'),\n        max_length=100,\n        help_text=_('User-provided name for this query'),\n    )\n\n    shared = models.BooleanField(\n        _('Shared With Other Users?'),\n        blank=True,\n        default=False,\n        help_text=_('Should other users see this query?'),\n    )\n\n    query = models.TextField(\n        _('Search Query'),\n        help_text=_('Pickled query object. Be wary changing this.'),\n    )\n\n    def __str__(self):\n        if self.shared:\n            return '%s (*)' % self.title\n        else:\n            return '%s' % self.title\n\n    class Meta:\n        verbose_name = _('Saved search')\n        verbose_name_plural = _('Saved searches')", "target": 0}, {"function": "def get_default_setting(setting):\n    from helpdesk.settings import DEFAULT_USER_SETTINGS\n    return DEFAULT_USER_SETTINGS[setting]", "target": 0}, {"function": "def login_view_ticketlist_default():\n    return get_default_setting('login_view_ticketlist')", "target": 0}, {"function": "def email_on_ticket_change_default():\n    return get_default_setting('email_on_ticket_change')", "target": 0}, {"function": "def email_on_ticket_assign_default():\n    return get_default_setting('email_on_ticket_assign')", "target": 0}, {"function": "def tickets_per_page_default():\n    return get_default_setting('tickets_per_page')", "target": 0}, {"function": "def use_email_as_submitter_default():\n    return get_default_setting('use_email_as_submitter')", "target": 0}, {"function": "class UserSettings(models.Model):\n    \"\"\"\n    A bunch of user-specific settings that we want to be able to define, such\n    as notification preferences and other things that should probably be\n    configurable.\n    \"\"\"\n    PAGE_SIZES = ((10, '10'), (25, '25'), (50, '50'), (100, '100'))\n\n    user = models.OneToOneField(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name=\"usersettings_helpdesk\")\n\n    settings_pickled = models.TextField(\n        _('DEPRECATED! Settings Dictionary DEPRECATED!'),\n        help_text=_('DEPRECATED! This is a base64-encoded representation of a pickled Python dictionary. '\n                    'Do not change this field via the admin.'),\n        blank=True,\n        null=True,\n    )\n\n    login_view_ticketlist = models.BooleanField(\n        verbose_name=_('Show Ticket List on Login?'),\n        help_text=_('Display the ticket list upon login? Otherwise, the dashboard is shown.'),\n        default=login_view_ticketlist_default,\n    )\n\n    email_on_ticket_change = models.BooleanField(\n        verbose_name=_('E-mail me on ticket change?'),\n        help_text=_(\n            'If you\\'re the ticket owner and the ticket is changed via the web by somebody else,'\n            'do you want to receive an e-mail?'\n        ),\n        default=email_on_ticket_change_default,\n    )\n\n    email_on_ticket_assign = models.BooleanField(\n        verbose_name=_('E-mail me when assigned a ticket?'),\n        help_text=_('If you are assigned a ticket via the web, do you want to receive an e-mail?'),\n        default=email_on_ticket_assign_default,\n    )\n\n    tickets_per_page = models.IntegerField(\n        verbose_name=_('Number of tickets to show per page'),\n        help_text=_('How many tickets do you want to see on the Ticket List page?'),\n        default=tickets_per_page_default,\n        choices=PAGE_SIZES,\n    )\n\n    use_email_as_submitter = models.BooleanField(\n        verbose_name=_('Use my e-mail address when submitting tickets?'),\n        help_text=_('When you submit a ticket, do you want to automatically '\n                    'use your e-mail address as the submitter address? You '\n                    'can type a different e-mail address when entering the '\n                    'ticket if needed, this option only changes the default.'),\n        default=use_email_as_submitter_default,\n    )\n\n    def __str__(self):\n        return 'Preferences for %s' % self.user\n\n    class Meta:\n        verbose_name = _('User Setting')\n        verbose_name_plural = _('User Settings')", "target": 0}, {"function": "def create_usersettings(sender, instance, created, **kwargs):\n    \"\"\"\n    Helper function to create UserSettings instances as\n    required, eg when we first create the UserSettings database\n    table via 'syncdb' or when we save a new user.\n\n    If we end up with users with no UserSettings, then we get horrible\n    'DoesNotExist: UserSettings matching query does not exist.' errors.\n    \"\"\"\n    if created:\n        UserSettings.objects.create(user=instance)", "target": 0}, {"function": "class IgnoreEmail(models.Model):\n    \"\"\"\n    This model lets us easily ignore e-mails from certain senders when\n    processing IMAP and POP3 mailboxes, eg mails from postmaster or from\n    known trouble-makers.\n    \"\"\"\n    class Meta:\n        verbose_name = _('Ignored e-mail address')\n        verbose_name_plural = _('Ignored e-mail addresses')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this e-mail to be ignored on all queues, '\n                    'or select those queues you wish to ignore this e-mail for.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which this e-mail address was added'),\n        blank=True,\n        editable=False\n    )\n\n    email_address = models.CharField(\n        _('E-Mail Address'),\n        max_length=150,\n        help_text=_('Enter a full e-mail address, or portions with '\n                    'wildcards, eg *@domain.com or postmaster@*.'),\n    )\n\n    keep_in_mailbox = models.BooleanField(\n        _('Save Emails in Mailbox?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to save emails from this address in the mailbox? '\n                    'If this is unticked, emails from this address will be deleted.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    def save(self, *args, **kwargs):\n        if not self.date:\n            self.date = timezone.now()\n        return super(IgnoreEmail, self).save(*args, **kwargs)\n\n    def queue_list(self):\n        \"\"\"Return a list of the queues this IgnoreEmail applies to.\n        If this IgnoreEmail applies to ALL queues, return '*'.\n        \"\"\"\n        queues = self.queues.all().order_by('title')\n        if len(queues) == 0:\n            return '*'\n        else:\n            return ', '.join([str(q) for q in queues])\n\n    def test(self, email):\n        \"\"\"\n        Possible situations:\n            1. Username & Domain both match\n            2. Username is wildcard, domain matches\n            3. Username matches, domain is wildcard\n            4. username & domain are both wildcards\n            5. Other (no match)\n\n            1-4 return True, 5 returns False.\n        \"\"\"\n\n        own_parts = self.email_address.split(\"@\")\n        email_parts = email.split(\"@\")\n\n        if self.email_address == email or \\\n                own_parts[0] == \"*\" and own_parts[1] == email_parts[1] or \\\n                own_parts[1] == \"*\" and own_parts[0] == email_parts[0] or \\\n                own_parts[0] == \"*\" and own_parts[1] == \"*\":\n            return True\n        else:\n            return False", "target": 0}, {"function": "class TicketCC(models.Model):\n    \"\"\"\n    Often, there are people who wish to follow a ticket who aren't the\n    person who originally submitted it. This model provides a way for those\n    people to follow a ticket.\n\n    In this circumstance, a 'person' could be either an e-mail address or\n    an existing system user.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        help_text=_('User who wishes to receive updates for this ticket.'),\n        verbose_name=_('User'),\n    )\n\n    email = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('For non-user followers, enter their e-mail address'),\n    )\n\n    can_view = models.BooleanField(\n        _('Can View Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login to view the ticket details?'),\n    )\n\n    can_update = models.BooleanField(\n        _('Can Update Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login and update the ticket?'),\n    )\n\n    def _email_address(self):\n        if self.user and self.user.email is not None:\n            return self.user.email\n        else:\n            return self.email\n    email_address = property(_email_address)\n\n    def _display(self):\n        if self.user:\n            return self.user\n        else:\n            return self.email\n    display = property(_display)\n\n    def __str__(self):\n        return '%s for %s' % (self.display, self.ticket.title)\n\n    def clean(self):\n        if self.user and not self.user.email:\n            raise ValidationError('User has no email address')", "target": 0}, {"function": "class CustomFieldManager(models.Manager):\n\n    def get_queryset(self):\n        return super(CustomFieldManager, self).get_queryset().order_by('ordering')", "target": 0}, {"function": "class CustomField(models.Model):\n    \"\"\"\n    Definitions for custom fields that are glued onto each ticket.\n    \"\"\"\n\n    name = models.SlugField(\n        _('Field Name'),\n        help_text=_('As used in the database and behind the scenes. '\n                    'Must be unique and consist of only lowercase letters with no punctuation.'),\n        unique=True,\n    )\n\n    label = models.CharField(\n        _('Label'),\n        max_length=30,\n        help_text=_('The display label for this field'),\n    )\n\n    help_text = models.TextField(\n        _('Help Text'),\n        help_text=_('Shown to the user when editing the ticket'),\n        blank=True,\n        null=True\n    )\n\n    DATA_TYPE_CHOICES = (\n        ('varchar', _('Character (single line)')),\n        ('text', _('Text (multi-line)')),\n        ('integer', _('Integer')),\n        ('decimal', _('Decimal')),\n        ('list', _('List')),\n        ('boolean', _('Boolean (checkbox yes/no)')),\n        ('date', _('Date')),\n        ('time', _('Time')),\n        ('datetime', _('Date & Time')),\n        ('email', _('E-Mail Address')),\n        ('url', _('URL')),\n        ('ipaddress', _('IP Address')),\n        ('slug', _('Slug')),\n    )\n\n    data_type = models.CharField(\n        _('Data Type'),\n        max_length=100,\n        help_text=_('Allows you to restrict the data entered into this field'),\n        choices=DATA_TYPE_CHOICES,\n    )\n\n    max_length = models.IntegerField(\n        _('Maximum Length (characters)'),\n        blank=True,\n        null=True,\n    )\n\n    decimal_places = models.IntegerField(\n        _('Decimal Places'),\n        help_text=_('Only used for decimal fields'),\n        blank=True,\n        null=True,\n    )\n\n    empty_selection_list = models.BooleanField(\n        _('Add empty first choice to List?'),\n        default=False,\n        help_text=_('Only for List: adds an empty first entry to the choices list, '\n                    'which enforces that the user makes an active choice.'),\n    )\n\n    list_values = models.TextField(\n        _('List Values'),\n        help_text=_('For list fields only. Enter one option per line.'),\n        blank=True,\n        null=True,\n    )\n\n    ordering = models.IntegerField(\n        _('Ordering'),\n        help_text=_('Lower numbers are displayed first; higher numbers are listed later'),\n        blank=True,\n        null=True,\n    )\n\n    def _choices_as_array(self):\n        valuebuffer = StringIO(self.list_values)\n        choices = [[item.strip(), item.strip()] for item in valuebuffer.readlines()]\n        valuebuffer.close()\n        return choices\n    choices_as_array = property(_choices_as_array)\n\n    required = models.BooleanField(\n        _('Required?'),\n        help_text=_('Does the user have to enter a value for this field?'),\n        default=False,\n    )\n\n    staff_only = models.BooleanField(\n        _('Staff Only?'),\n        help_text=_('If this is ticked, then the public submission form '\n                    'will NOT show this field'),\n        default=False,\n    )\n\n    objects = CustomFieldManager()\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Custom field')\n        verbose_name_plural = _('Custom fields')", "target": 0}, {"function": "class TicketCustomFieldValue(models.Model):\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    field = models.ForeignKey(\n        CustomField,\n        on_delete=models.CASCADE,\n        verbose_name=_('Field'),\n    )\n\n    value = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.field)\n\n    class Meta:\n        unique_together = (('ticket', 'field'),)\n        verbose_name = _('Ticket custom field value')\n        verbose_name_plural = _('Ticket custom field values')", "target": 0}, {"function": "class TicketDependency(models.Model):\n    \"\"\"\n    The ticket identified by `ticket` cannot be resolved until the ticket in `depends_on` has been resolved.\n    To help enforce this, a helper function `can_be_resolved` on each Ticket instance checks that\n    these have all been resolved.\n    \"\"\"\n    class Meta:\n        unique_together = (('ticket', 'depends_on'),)\n        verbose_name = _('Ticket dependency')\n        verbose_name_plural = _('Ticket dependencies')\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n        related_name='ticketdependency',\n    )\n\n    depends_on = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Depends On Ticket'),\n        related_name='depends_on',\n    )\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.depends_on)", "target": 0}], "function_after": [{"function": "def format_time_spent(time_spent):\n    if time_spent:\n        time_spent = \"{0:02d}h:{1:02d}m\".format(\n            time_spent.seconds // 3600,\n            time_spent.seconds % 3600 // 60\n        )\n    else:\n        time_spent = \"\"\n    return time_spent", "target": 0}, {"function": "class EscapeHtml(Extension):\n    def extendMarkdown(self, md, md_globals):\n        del md.preprocessors['html_block']\n        del md.inlinePatterns['html']", "target": 0}, {"function": "def get_markdown(text):\n    if not text:\n        return \"\"\n\n    pattern = fr'([\\[\\s\\S\\]]*?)\\(([\\s\\S]*?):([\\s\\S]*?)\\)'\n    # Regex check\n    if re.match(pattern, text):\n        # get get value of group regex\n        scheme = re.search(pattern, text, re.IGNORECASE).group(2)\n        # scheme check\n        if scheme in helpdesk_settings.ALLOWED_URL_SCHEMES:\n            replacement = '\\\\1(\\\\2:\\\\3)'\n        else:\n            replacement = '\\\\1(\\\\3)'\n\n        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)\n\n    return mark_safe(\n        markdown(\n            text,\n            extensions=[\n                EscapeHtml(), 'markdown.extensions.nl2br',\n                'markdown.extensions.fenced_code'\n            ]\n        )\n    )", "target": 0}, {"function": "class Queue(models.Model):\n    \"\"\"\n    A queue is a collection of tickets into what would generally be business\n    areas or departments.\n\n    For example, a company may have a queue for each Product they provide, or\n    a queue for each of Accounts, Pre-Sales, and Support.\n\n    \"\"\"\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n        max_length=50,\n        unique=True,\n        help_text=_('This slug is used when building ticket ID\\'s. Once set, '\n                    'try not to change it or e-mailing may get messy.'),\n    )\n\n    email_address = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('All outgoing e-mails for this queue will use this e-mail '\n                    'address. If you use IMAP or POP3, this should be the e-mail '\n                    'address for that mailbox.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this queue. All correspondence in this '\n                    'queue will be in this language.'),\n    )\n\n    allow_public_submission = models.BooleanField(\n        _('Allow Public Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Should this queue be listed on the public submission form?'),\n    )\n\n    allow_email_submission = models.BooleanField(\n        _('Allow E-Mail Submission?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to poll the e-mail box below for new '\n                    'tickets?'),\n    )\n\n    escalate_days = models.IntegerField(\n        _('Escalation Days'),\n        blank=True,\n        null=True,\n        help_text=_('For tickets which are not held, how often do you wish to '\n                    'increase their priority? Set to 0 for no escalation.'),\n    )\n\n    new_ticket_cc = models.CharField(\n        _('New Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all new tickets created for this queue. '\n                    'Enter a comma between multiple e-mail addresses.'),\n    )\n\n    updated_ticket_cc = models.CharField(\n        _('Updated Ticket CC Address'),\n        blank=True,\n        null=True,\n        max_length=200,\n        help_text=_('If an e-mail address is entered here, then it will '\n                    'receive notification of all activity (new tickets, closed '\n                    'tickets, updates, reassignments, etc) for this queue. Separate '\n                    'multiple addresses with a comma.'),\n    )\n\n    enable_notifications_on_email_events = models.BooleanField(\n        _('Notify contacts when email updates arrive'),\n        blank=True,\n        default=False,\n        help_text=_('When an email arrives to either create a ticket or to '\n                    'interact with an existing discussion. Should email notifications be sent ? '\n                    'Note: the new_ticket_cc and updated_ticket_cc work independently of this feature'),\n    )\n\n    email_box_type = models.CharField(\n        _('E-Mail Box Type'),\n        max_length=5,\n        choices=(('pop3', _('POP 3')), ('imap', _('IMAP')), ('local', _('Local Directory'))),\n        blank=True,\n        null=True,\n        help_text=_('E-Mail server type for creating tickets automatically '\n                    'from a mailbox - both POP3 and IMAP are supported, as well as '\n                    'reading from a local directory.'),\n    )\n\n    email_box_host = models.CharField(\n        _('E-Mail Hostname'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Your e-mail server address - either the domain name or '\n                    'IP address. May be \"localhost\".'),\n    )\n\n    email_box_port = models.IntegerField(\n        _('E-Mail Port'),\n        blank=True,\n        null=True,\n        help_text=_('Port number to use for accessing e-mail. Default for '\n                    'POP3 is \"110\", and for IMAP is \"143\". This may differ on some '\n                    'servers. Leave it blank to use the defaults.'),\n    )\n\n    email_box_ssl = models.BooleanField(\n        _('Use SSL for E-Mail?'),\n        blank=True,\n        default=False,\n        help_text=_('Whether to use SSL for IMAP or POP3 - the default ports '\n                    'when using SSL are 993 for IMAP and 995 for POP3.'),\n    )\n\n    email_box_user = models.CharField(\n        _('E-Mail Username'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Username for accessing this mailbox.'),\n    )\n\n    email_box_pass = models.CharField(\n        _('E-Mail Password'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('Password for the above username'),\n    )\n\n    email_box_imap_folder = models.CharField(\n        _('IMAP Folder'),\n        max_length=100,\n        blank=True,\n        null=True,\n        help_text=_('If using IMAP, what folder do you wish to fetch messages '\n                    'from? This allows you to use one IMAP account for multiple '\n                    'queues, by filtering messages on your IMAP server into separate '\n                    'folders. Default: INBOX.'),\n    )\n\n    email_box_local_dir = models.CharField(\n        _('E-Mail Local Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If using a local directory, what directory path do you '\n                    'wish to poll for new email? '\n                    'Example: /var/lib/mail/helpdesk/'),\n    )\n\n    permission_name = models.CharField(\n        _('Django auth permission name'),\n        max_length=72,  # based on prepare_permission_name() pre-pending chars to slug\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('Name used in the django.contrib.auth permission system'),\n    )\n\n    email_box_interval = models.IntegerField(\n        _('E-Mail Check Interval'),\n        help_text=_('How often do you wish to check this mailbox? (in Minutes)'),\n        blank=True,\n        null=True,\n        default='5',\n    )\n\n    email_box_last_check = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        # This is updated by management/commands/get_mail.py.\n    )\n\n    socks_proxy_type = models.CharField(\n        _('Socks Proxy Type'),\n        max_length=8,\n        choices=(('socks4', _('SOCKS4')), ('socks5', _('SOCKS5'))),\n        blank=True,\n        null=True,\n        help_text=_('SOCKS4 or SOCKS5 allows you to proxy your connections through a SOCKS server.'),\n    )\n\n    socks_proxy_host = models.GenericIPAddressField(\n        _('Socks Proxy Host'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy IP address. Default: 127.0.0.1'),\n    )\n\n    socks_proxy_port = models.IntegerField(\n        _('Socks Proxy Port'),\n        blank=True,\n        null=True,\n        help_text=_('Socks proxy port number. Default: 9150 (default TOR port)'),\n    )\n\n    logging_type = models.CharField(\n        _('Logging Type'),\n        max_length=5,\n        choices=(\n            ('none', _('None')),\n            ('debug', _('Debug')),\n            ('info', _('Information')),\n            ('warn', _('Warning')),\n            ('error', _('Error')),\n            ('crit', _('Critical'))\n        ),\n        blank=True,\n        null=True,\n        help_text=_('Set the default logging level. All messages at that '\n                    'level or above will be logged to the directory set '\n                    'below. If no level is set, logging will be disabled.'),\n    )\n\n    logging_dir = models.CharField(\n        _('Logging Directory'),\n        max_length=200,\n        blank=True,\n        null=True,\n        help_text=_('If logging is enabled, what directory should we use to '\n                    'store log files for this queue? '\n                    'The standard logging mechanims are used if no directory is set'),\n    )\n\n    default_owner = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.SET_NULL,\n        related_name='default_owner',\n        blank=True,\n        null=True,\n        verbose_name=_('Default owner'),\n    )\n\n    dedicated_time = models.DurationField(\n        help_text=_(\"Time to be spent on this Queue in total\"),\n        blank=True, null=True\n    )\n\n    def __str__(self):\n        return \"%s\" % self.title\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Queue')\n        verbose_name_plural = _('Queues')\n\n    def _from_address(self):\n        \"\"\"\n        Short property to provide a sender address in SMTP format,\n        eg 'Name <email>'. We do this so we can put a simple error message\n        in the sender name field, so hopefully the admin can see and fix it.\n        \"\"\"\n        if not self.email_address:\n            # must check if given in format \"Foo <foo@example.com>\"\n            default_email = re.match(\".*<(?P<email>.*@*.)>\", settings.DEFAULT_FROM_EMAIL)\n            if default_email is not None:\n                # already in the right format, so just include it here\n                return u'NO QUEUE EMAIL ADDRESS DEFINED %s' % settings.DEFAULT_FROM_EMAIL\n            else:\n                return u'NO QUEUE EMAIL ADDRESS DEFINED <%s>' % settings.DEFAULT_FROM_EMAIL\n        else:\n            return u'%s <%s>' % (self.title, self.email_address)\n    from_address = property(_from_address)\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.ticket_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def prepare_permission_name(self):\n        \"\"\"Prepare internally the codename for the permission and store it in permission_name.\n        :return: The codename that can be used to create a new Permission object.\n        \"\"\"\n        # Prepare the permission associated to this Queue\n        basename = \"queue_access_%s\" % self.slug\n        self.permission_name = \"helpdesk.%s\" % basename\n        return basename\n\n    def save(self, *args, **kwargs):\n        if self.email_box_type == 'imap' and not self.email_box_imap_folder:\n            self.email_box_imap_folder = 'INBOX'\n\n        if self.socks_proxy_type:\n            if not self.socks_proxy_host:\n                self.socks_proxy_host = '127.0.0.1'\n            if not self.socks_proxy_port:\n                self.socks_proxy_port = 9150\n        else:\n            self.socks_proxy_host = None\n            self.socks_proxy_port = None\n\n        if not self.email_box_port:\n            if self.email_box_type == 'imap' and self.email_box_ssl:\n                self.email_box_port = 993\n            elif self.email_box_type == 'imap' and not self.email_box_ssl:\n                self.email_box_port = 143\n            elif self.email_box_type == 'pop3' and self.email_box_ssl:\n                self.email_box_port = 995\n            elif self.email_box_type == 'pop3' and not self.email_box_ssl:\n                self.email_box_port = 110\n\n        if not self.id:\n            # Prepare the permission codename and the permission\n            # (even if they are not needed with the current configuration)\n            basename = self.prepare_permission_name()\n\n            Permission.objects.create(\n                name=_(\"Permission for queue: \") + self.title,\n                content_type=ContentType.objects.get_for_model(self.__class__),\n                codename=basename,\n            )\n\n        super(Queue, self).save(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        permission_name = self.permission_name\n        super(Queue, self).delete(*args, **kwargs)\n\n        # once the Queue is safely deleted, remove the permission (if exists)\n        if permission_name:\n            try:\n                p = Permission.objects.get(codename=permission_name[9:])\n                p.delete()\n            except ObjectDoesNotExist:\n                pass", "target": 0}, {"function": "def mk_secret():\n    return str(uuid.uuid4())", "target": 0}, {"function": "class Ticket(models.Model):\n    \"\"\"\n    To allow a ticket to be entered as quickly as possible, only the\n    bare minimum fields are required. These basically allow us to\n    sort and manage the ticket. The user can always go back and\n    enter more information later.\n\n    A good example of this is when a customer is on the phone, and\n    you want to give them a ticket ID as quickly as possible. You can\n    enter some basic info, save the ticket, give the customer the ID\n    and get off the phone, then add in further detail at a later time\n    (once the customer is not on the line).\n\n    Note that assigned_to is optional - unassigned tickets are displayed on\n    the dashboard to prompt users to take ownership of them.\n    \"\"\"\n\n    OPEN_STATUS = 1\n    REOPENED_STATUS = 2\n    RESOLVED_STATUS = 3\n    CLOSED_STATUS = 4\n    DUPLICATE_STATUS = 5\n\n    STATUS_CHOICES = (\n        (OPEN_STATUS, _('Open')),\n        (REOPENED_STATUS, _('Reopened')),\n        (RESOLVED_STATUS, _('Resolved')),\n        (CLOSED_STATUS, _('Closed')),\n        (DUPLICATE_STATUS, _('Duplicate')),\n    )\n\n    PRIORITY_CHOICES = (\n        (1, _('1. Critical')),\n        (2, _('2. High')),\n        (3, _('3. Normal')),\n        (4, _('4. Low')),\n        (5, _('5. Very Low')),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        on_delete=models.CASCADE,\n        verbose_name=_('Queue'),\n    )\n\n    created = models.DateTimeField(\n        _('Created'),\n        blank=True,\n        help_text=_('Date this ticket was first created'),\n    )\n\n    modified = models.DateTimeField(\n        _('Modified'),\n        blank=True,\n        help_text=_('Date this ticket was most recently changed.'),\n    )\n\n    submitter_email = models.EmailField(\n        _('Submitter E-Mail'),\n        blank=True,\n        null=True,\n        help_text=_('The submitter will receive an email for all public '\n                    'follow-ups left for this task.'),\n    )\n\n    assigned_to = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name='assigned_to',\n        blank=True,\n        null=True,\n        verbose_name=_('Assigned to'),\n    )\n\n    status = models.IntegerField(\n        _('Status'),\n        choices=STATUS_CHOICES,\n        default=OPEN_STATUS,\n    )\n\n    on_hold = models.BooleanField(\n        _('On Hold'),\n        blank=True,\n        default=False,\n        help_text=_('If a ticket is on hold, it will not automatically be escalated.'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n        blank=True,\n        null=True,\n        help_text=_('The content of the customers query.'),\n    )\n\n    resolution = models.TextField(\n        _('Resolution'),\n        blank=True,\n        null=True,\n        help_text=_('The resolution provided to the customer by our staff.'),\n    )\n\n    priority = models.IntegerField(\n        _('Priority'),\n        choices=PRIORITY_CHOICES,\n        default=3,\n        blank=3,\n        help_text=_('1 = Highest Priority, 5 = Low Priority'),\n    )\n\n    due_date = models.DateTimeField(\n        _('Due on'),\n        blank=True,\n        null=True,\n    )\n\n    last_escalation = models.DateTimeField(\n        blank=True,\n        null=True,\n        editable=False,\n        help_text=_('The date this ticket was last escalated - updated '\n                    'automatically by management/commands/escalate_tickets.py.'),\n    )\n\n    secret_key = models.CharField(\n        _(\"Secret key needed for viewing/editing ticket by non-logged in users\"),\n        max_length=36,\n        default=mk_secret,\n    )\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item the user was viewing when they created this ticket.'),\n    )\n\n    merged_to = models.ForeignKey(\n        'self',\n        verbose_name=_('merged to'),\n        related_name='merged_tickets',\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True\n    )\n\n    @property\n    def time_spent(self):\n        \"\"\"Return back total time spent on the ticket. This is calculated value\n        based on total sum from all FollowUps\n        \"\"\"\n        total = datetime.timedelta(0)\n        for val in self.followup_set.all():\n            if val.time_spent:\n                total = total + val.time_spent\n        return total\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)\n\n    def send(self, roles, dont_send_to=None, **kwargs):\n        \"\"\"\n        Send notifications to everyone interested in this ticket.\n\n        The the roles argument is a dictionary mapping from roles to (template, context) pairs.\n        If a role is not present in the dictionary, users of that type will not receive the notification.\n\n        The following roles exist:\n\n          - 'submitter'\n          - 'new_ticket_cc'\n          - 'ticket_cc'\n          - 'assigned_to'\n\n        Here is an example roles dictionary:\n\n        {\n            'submitter': (template_name, context),\n            'assigned_to': (template_name2, context),\n        }\n\n        **kwargs are passed to send_templated_mail defined in templated_email.py\n\n        returns the set of email addresses the notification was delivered to.\n\n        \"\"\"\n        recipients = set()\n\n        if dont_send_to is not None:\n            recipients.update(dont_send_to)\n\n        recipients.add(self.queue.email_address)\n\n        def should_receive(email):\n            return email and email not in recipients\n\n        def send(role, recipient):\n            if recipient and recipient not in recipients and role in roles:\n                template, context = roles[role]\n                send_templated_mail(template, context, recipient, sender=self.queue.from_address, **kwargs)\n                recipients.add(recipient)\n\n        send('submitter', self.submitter_email)\n        send('ticket_cc', self.queue.updated_ticket_cc)\n        send('new_ticket_cc', self.queue.new_ticket_cc)\n        if self.assigned_to:\n            send('assigned_to', self.assigned_to.email)\n        if self.queue.enable_notifications_on_email_events:\n            for cc in self.ticketcc_set.all():\n                send('ticket_cc', cc.email_address)\n        return recipients\n\n    def _get_assigned_to(self):\n        \"\"\" Custom property to allow us to easily print 'Unassigned' if a\n        ticket has no owner, or the users name if it's assigned. If the user\n        has a full name configured, we use that, otherwise their username. \"\"\"\n        if not self.assigned_to:\n            return _('Unassigned')\n        else:\n            if self.assigned_to.get_full_name():\n                return self.assigned_to.get_full_name()\n            else:\n                return self.assigned_to.get_username()\n    get_assigned_to = property(_get_assigned_to)\n\n    def _get_ticket(self):\n        \"\"\" A user-friendly ticket ID, which is a combination of ticket ID\n        and queue slug. This is generally used in e-mail subjects. \"\"\"\n\n        return u\"[%s]\" % self.ticket_for_url\n    ticket = property(_get_ticket)\n\n    def _get_ticket_for_url(self):\n        \"\"\" A URL-friendly ticket ID, used in links. \"\"\"\n        return u\"%s-%s\" % (self.queue.slug, self.id)\n    ticket_for_url = property(_get_ticket_for_url)\n\n    def _get_priority_css_class(self):\n        \"\"\"\n        Return the boostrap class corresponding to the priority.\n        \"\"\"\n        if self.priority == 2:\n            return \"warning\"\n        elif self.priority == 1:\n            return \"danger\"\n        elif self.priority == 5:\n            return \"success\"\n        else:\n            return \"\"\n    get_priority_css_class = property(_get_priority_css_class)\n\n    def _get_status(self):\n        \"\"\"\n        Displays the ticket status, with an \"On Hold\" message if needed.\n        \"\"\"\n        held_msg = ''\n        if self.on_hold:\n            held_msg = _(' - On Hold')\n        dep_msg = ''\n        if not self.can_be_resolved:\n            dep_msg = _(' - Open dependencies')\n        return u'%s%s%s' % (self.get_status_display(), held_msg, dep_msg)\n    get_status = property(_get_status)\n\n    def _get_ticket_url(self):\n        \"\"\"\n        Returns a publicly-viewable URL for this ticket, used when giving\n        a URL to the submitter of a ticket.\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s?ticket=%s&email=%s&key=%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:public_view'),\n            self.ticket_for_url,\n            self.submitter_email,\n            self.secret_key\n        )\n    ticket_url = property(_get_ticket_url)\n\n    def _get_staff_url(self):\n        \"\"\"\n        Returns a staff-only URL for this ticket, used when giving a URL to\n        a staff member (in emails etc)\n        \"\"\"\n        from django.contrib.sites.models import Site\n        from django.core.exceptions import ImproperlyConfigured\n        from django.urls import reverse\n        try:\n            site = Site.objects.get_current()\n        except ImproperlyConfigured:\n            site = Site(domain='configure-django-sites.com')\n        if helpdesk_settings.HELPDESK_USE_HTTPS_IN_EMAIL_LINK:\n            protocol = 'https'\n        else:\n            protocol = 'http'\n        return u\"%s://%s%s\" % (\n            protocol,\n            site.domain,\n            reverse('helpdesk:view',\n                    args=[self.id])\n        )\n    staff_url = property(_get_staff_url)\n\n    def _can_be_resolved(self):\n        \"\"\"\n        Returns a boolean.\n        True = any dependencies are resolved\n        False = There are non-resolved dependencies\n        \"\"\"\n        OPEN_STATUSES = (Ticket.OPEN_STATUS, Ticket.REOPENED_STATUS)\n        return TicketDependency.objects.filter(ticket=self).filter(\n            depends_on__status__in=OPEN_STATUSES).count() == 0\n    can_be_resolved = property(_can_be_resolved)\n\n    def get_submitter_userprofile(self):\n        User = get_user_model()\n        try:\n            return User.objects.get(email=self.submitter_email)\n        except (User.DoesNotExist, User.MultipleObjectsReturned):\n            return None\n\n    class Meta:\n        get_latest_by = \"created\"\n        ordering = ('id',)\n        verbose_name = _('Ticket')\n        verbose_name_plural = _('Tickets')\n\n    def __str__(self):\n        return '%s %s' % (self.id, self.title)\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:view', args=(self.id,))\n\n    def save(self, *args, **kwargs):\n        if not self.id:\n            # This is a new ticket as no ID yet exists.\n            self.created = timezone.now()\n\n        if not self.priority:\n            self.priority = 3\n\n        self.modified = timezone.now()\n\n        if len(self.title) > 200:\n            self.title = self.title[:197] + \"...\"\n\n        super(Ticket, self).save(*args, **kwargs)\n\n    @staticmethod\n    def queue_and_id_from_query(query):\n        # Apply the opposite logic here compared to self._get_ticket_for_url\n        # Ensure that queues with '-' in them will work\n        parts = query.split('-')\n        queue = '-'.join(parts[0:-1])\n        return queue, parts[-1]\n\n    def get_markdown(self):\n        return get_markdown(self.description)\n\n    @property\n    def get_resolution_markdown(self):\n        return get_markdown(self.resolution)\n\n    def add_email_to_ticketcc_if_not_in(self, email=None, user=None, ticketcc=None):\n        \"\"\"\n        Check that given email/user_email/ticketcc_email is not already present on the ticket\n        (submitter email, assigned to, or in ticket CCs) and add it to a new ticket CC,\n        or move the given one\n\n        :param str email:\n        :param User user:\n        :param TicketCC ticketcc:\n        :rtype: TicketCC|None\n        \"\"\"\n        if ticketcc:\n            email = ticketcc.display\n        elif user:\n            if user.email:\n                email = user.email\n            else:\n                # Ignore if user has no email address\n                return\n        elif not email:\n            raise ValueError('You must provide at least one parameter to get the email from')\n\n        # Prepare all emails already into the ticket\n        ticket_emails = [x.display for x in self.ticketcc_set.all()]\n        if self.submitter_email:\n            ticket_emails.append(self.submitter_email)\n        if self.assigned_to and self.assigned_to.email:\n            ticket_emails.append(self.assigned_to.email)\n\n        # Check that email is not already part of the ticket\n        if email not in ticket_emails:\n            if ticketcc:\n                ticketcc.ticket = self\n                ticketcc.save(update_fields=['ticket'])\n            elif user:\n                ticketcc = self.ticketcc_set.create(user=user)\n            else:\n                ticketcc = self.ticketcc_set.create(email=email)\n            return ticketcc", "target": 0}, {"function": "class FollowUpManager(models.Manager):\n\n    def private_followups(self):\n        return self.filter(public=False)\n\n    def public_followups(self):\n        return self.filter(public=True)", "target": 0}, {"function": "class FollowUp(models.Model):\n    \"\"\"\n    A FollowUp is a comment and/or change to a ticket. We keep a simple\n    title, the comment entered by the user, and the new status of a ticket\n    to enable easy flagging of details on the view-ticket page.\n\n    The title is automatically generated at save-time, based on what action\n    the user took.\n\n    Tickets that aren't public are never shown to or e-mailed to the submitter,\n    although all staff can see them.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    date = models.DateTimeField(\n        _('Date'),\n        default=timezone.now\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=200,\n        blank=True,\n        null=True,\n    )\n\n    comment = models.TextField(\n        _('Comment'),\n        blank=True,\n        null=True,\n    )\n\n    public = models.BooleanField(\n        _('Public'),\n        blank=True,\n        default=False,\n        help_text=_(\n            'Public tickets are viewable by the submitter and all '\n            'staff, but non-public tickets can only be seen by staff.'\n        ),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        verbose_name=_('User'),\n    )\n\n    new_status = models.IntegerField(\n        _('New Status'),\n        choices=Ticket.STATUS_CHOICES,\n        blank=True,\n        null=True,\n        help_text=_('If the status was changed, what was it changed to?'),\n    )\n\n    message_id = models.CharField(\n        _('E-Mail ID'),\n        max_length=256,\n        blank=True,\n        null=True,\n        help_text=_(\"The Message ID of the submitter's email.\"),\n        editable=False,\n    )\n\n    objects = FollowUpManager()\n\n    time_spent = models.DurationField(\n        help_text=_(\"Time spent on this follow up\"),\n        blank=True, null=True\n    )\n\n    class Meta:\n        ordering = ('date',)\n        verbose_name = _('Follow-up')\n        verbose_name_plural = _('Follow-ups')\n\n    def __str__(self):\n        return '%s' % self.title\n\n    def get_absolute_url(self):\n        return u\"%s#followup%s\" % (self.ticket.get_absolute_url(), self.id)\n\n    def save(self, *args, **kwargs):\n        t = self.ticket\n        t.modified = timezone.now()\n        t.save()\n        super(FollowUp, self).save(*args, **kwargs)\n\n    def get_markdown(self):\n        return get_markdown(self.comment)\n\n    @property\n    def time_spent_formated(self):\n        return format_time_spent(self.time_spent)", "target": 0}, {"function": "class TicketChange(models.Model):\n    \"\"\"\n    For each FollowUp, any changes to the parent ticket (eg Title, Priority,\n    etc) are tracked here for display purposes.\n    \"\"\"\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    field = models.CharField(\n        _('Field'),\n        max_length=100,\n    )\n\n    old_value = models.TextField(\n        _('Old Value'),\n        blank=True,\n        null=True,\n    )\n\n    new_value = models.TextField(\n        _('New Value'),\n        blank=True,\n        null=True,\n    )\n\n    def __str__(self):\n        out = '%s ' % self.field\n        if not self.new_value:\n            out += ugettext('removed')\n        elif not self.old_value:\n            out += ugettext('set to %s') % self.new_value\n        else:\n            out += ugettext('changed from \"%(old_value)s\" to \"%(new_value)s\"') % {\n                'old_value': self.old_value,\n                'new_value': self.new_value\n            }\n        return out\n\n    class Meta:\n        verbose_name = _('Ticket change')\n        verbose_name_plural = _('Ticket changes')", "target": 0}, {"function": "def attachment_path(instance, filename):\n    \"\"\"Just bridge\"\"\"\n    return instance.attachment_path(filename)", "target": 0}, {"function": "class Attachment(models.Model):\n    \"\"\"\n    Represents a file attached to a follow-up. This could come from an e-mail\n    attachment, or it could be uploaded via the web interface.\n    \"\"\"\n\n    file = models.FileField(\n        _('File'),\n        upload_to=attachment_path,\n        max_length=1000,\n        validators=[validate_file_extension]\n    )\n\n    filename = models.CharField(\n        _('Filename'),\n        blank=True,\n        max_length=1000,\n    )\n\n    mime_type = models.CharField(\n        _('MIME Type'),\n        blank=True,\n        max_length=255,\n    )\n\n    size = models.IntegerField(\n        _('Size'),\n        blank=True,\n        help_text=_('Size of this file in bytes'),\n    )\n\n    def __str__(self):\n        return '%s' % self.filename\n\n    def save(self, *args, **kwargs):\n\n        if not self.size:\n            self.size = self.get_size()\n\n        if not self.filename:\n            self.filename = self.get_filename()\n\n        if not self.mime_type:\n            self.mime_type = \\\n                mimetypes.guess_type(self.filename, strict=False)[0] or \\\n                'application/octet-stream'\n\n        return super(Attachment, self).save(*args, **kwargs)\n\n    def get_filename(self):\n        return str(self.file)\n\n    def get_size(self):\n        return self.file.file.size\n\n    def attachment_path(self, filename):\n        \"\"\"Provide a file path that will help prevent files being overwritten, by\n        putting attachments in a folder off attachments for ticket/followup_id/.\n        \"\"\"\n        assert NotImplementedError(\n            \"This method is to be implemented by Attachment classes\"\n        )\n\n    class Meta:\n        ordering = ('filename',)\n        verbose_name = _('Attachment')\n        verbose_name_plural = _('Attachments')\n        abstract = True", "target": 0}, {"function": "class FollowUpAttachment(Attachment):\n\n    followup = models.ForeignKey(\n        FollowUp,\n        on_delete=models.CASCADE,\n        verbose_name=_('Follow-up'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/{ticket_for_url}-{secret_key}/{id_}'.format(\n            ticket_for_url=self.followup.ticket.ticket_for_url,\n            secret_key=self.followup.ticket.secret_key,\n            id_=self.followup.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)", "target": 0}, {"function": "class KBIAttachment(Attachment):\n\n    kbitem = models.ForeignKey(\n        \"KBItem\",\n        on_delete=models.CASCADE,\n        verbose_name=_('Knowledge base item'),\n    )\n\n    def attachment_path(self, filename):\n\n        os.umask(0)\n        path = 'helpdesk/attachments/kb/{category}/{kbi}'.format(\n            category=self.kbitem.category,\n            kbi=self.kbitem.id)\n        att_path = os.path.join(settings.MEDIA_ROOT, path)\n        if settings.DEFAULT_FILE_STORAGE == \"django.core.files.storage.FileSystemStorage\":\n            if not os.path.exists(att_path):\n                os.makedirs(att_path, 0o777)\n        return os.path.join(path, filename)", "target": 0}, {"function": "class PreSetReply(models.Model):\n    \"\"\"\n    We can allow the admin to define a number of pre-set replies, used to\n    simplify the sending of updates and resolutions. These are basically Django\n    templates with a limited context - however if you wanted to get crafy it would\n    be easy to write a reply that displays ALL updates in hierarchical order etc\n    with use of for loops over {{ ticket.followup_set.all }} and friends.\n\n    When replying to a ticket, the user can select any reply set for the current\n    queue, and the body text is fetched via AJAX.\n    \"\"\"\n    class Meta:\n        ordering = ('name',)\n        verbose_name = _('Pre-set reply')\n        verbose_name_plural = _('Pre-set replies')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank to allow this reply to be used for all '\n                    'queues, or select those queues you wish to limit this reply to.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n        help_text=_('Only used to assist users with selecting a reply - not '\n                    'shown to the user.'),\n    )\n\n    body = models.TextField(\n        _('Body'),\n        help_text=_('Context available: {{ ticket }} - ticket object (eg '\n                    '{{ ticket.title }}); {{ queue }} - The queue; and {{ user }} '\n                    '- the current user.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name", "target": 0}, {"function": "class EscalationExclusion(models.Model):\n    \"\"\"\n    An 'EscalationExclusion' lets us define a date on which escalation should\n    not happen, for example a weekend or public holiday.\n\n    You may also have a queue that is only used on one day per week.\n\n    To create these on a regular basis, check out the README file for an\n    example cronjob that runs 'create_escalation_exclusions.py'.\n    \"\"\"\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this exclusion to be applied to all queues, '\n                    'or select those queues you wish to exclude with this entry.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which escalation should not happen'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Escalation exclusion')\n        verbose_name_plural = _('Escalation exclusions')", "target": 0}, {"function": "class EmailTemplate(models.Model):\n    \"\"\"\n    Since these are more likely to be changed than other templates, we store\n    them in the database.\n\n    This means that an admin can change email templates without having to have\n    access to the filesystem.\n    \"\"\"\n\n    template_name = models.CharField(\n        _('Template Name'),\n        max_length=100,\n    )\n\n    subject = models.CharField(\n        _('Subject'),\n        max_length=100,\n        help_text=_('This will be prefixed with \"[ticket.ticket] ticket.title\"'\n                    '. We recommend something simple such as \"(Updated\") or \"(Closed)\"'\n                    ' - the same context is available as in plain_text, below.'),\n    )\n\n    heading = models.CharField(\n        _('Heading'),\n        max_length=100,\n        help_text=_('In HTML e-mails, this will be the heading at the top of '\n                    'the email - the same context is available as in plain_text, '\n                    'below.'),\n    )\n\n    plain_text = models.TextField(\n        _('Plain Text'),\n        help_text=_('The context available to you includes {{ ticket }}, '\n                    '{{ queue }}, and depending on the time of the call: '\n                    '{{ resolution }} or {{ comment }}.'),\n    )\n\n    html = models.TextField(\n        _('HTML'),\n        help_text=_('The same context is available here as in plain_text, above.'),\n    )\n\n    locale = models.CharField(\n        _('Locale'),\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('Locale of this template.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.template_name\n\n    class Meta:\n        ordering = ('template_name', 'locale')\n        verbose_name = _('e-mail template')\n        verbose_name_plural = _('e-mail templates')", "target": 0}, {"function": "class KBCategory(models.Model):\n    \"\"\"\n    Lets help users help themselves: the Knowledge Base is a categorised\n    listing of questions & answers.\n    \"\"\"\n\n    name = models.CharField(\n        _('Name of the category'),\n        max_length=100,\n    )\n\n    title = models.CharField(\n        _('Title on knowledgebase page'),\n        max_length=100,\n    )\n\n    slug = models.SlugField(\n        _('Slug'),\n    )\n\n    description = models.TextField(\n        _('Description'),\n    )\n\n    queue = models.ForeignKey(\n        Queue,\n        blank=True,\n        null=True,\n        on_delete=models.CASCADE,\n        verbose_name=_('Default queue when creating a ticket after viewing this category.'),\n    )\n\n    public = models.BooleanField(\n        default=True,\n        verbose_name=_(\"Is KBCategory publicly visible?\")\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        ordering = ('title',)\n        verbose_name = _('Knowledge base category')\n        verbose_name_plural = _('Knowledge base categories')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return reverse('helpdesk:kb_category', kwargs={'slug': self.slug})", "target": 0}, {"function": "class KBItem(models.Model):\n    \"\"\"\n    An item within the knowledgebase. Very straightforward question/answer\n    style system.\n    \"\"\"\n    voted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='votes',\n    )\n    downvoted_by = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='downvotes',\n    )\n    category = models.ForeignKey(\n        KBCategory,\n        on_delete=models.CASCADE,\n        verbose_name=_('Category'),\n    )\n\n    title = models.CharField(\n        _('Title'),\n        max_length=100,\n    )\n\n    question = models.TextField(\n        _('Question'),\n    )\n\n    answer = models.TextField(\n        _('Answer'),\n    )\n\n    votes = models.IntegerField(\n        _('Votes'),\n        help_text=_('Total number of votes cast for this item'),\n        default=0,\n    )\n\n    recommendations = models.IntegerField(\n        _('Positive Votes'),\n        help_text=_('Number of votes for this item which were POSITIVE.'),\n        default=0,\n    )\n\n    last_updated = models.DateTimeField(\n        _('Last Updated'),\n        help_text=_('The date on which this question was most recently changed.'),\n        blank=True,\n    )\n\n    team = models.ForeignKey(\n        helpdesk_settings.HELPDESK_TEAMS_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('Team'),\n        blank=True,\n        null=True,\n    )\n\n    order = models.PositiveIntegerField(\n        _('Order'),\n        blank=True,\n        null=True,\n    )\n\n    enabled = models.BooleanField(\n        _('Enabled to display to users'),\n        default=True,\n    )\n\n    def save(self, *args, **kwargs):\n        if not self.last_updated:\n            self.last_updated = timezone.now()\n        return super(KBItem, self).save(*args, **kwargs)\n\n    def get_team(self):\n        return helpdesk_settings.HELPDESK_KBITEM_TEAM_GETTER(self)\n\n    def _score(self):\n        \"\"\" Return a score out of 10 or Unrated if no votes \"\"\"\n        if self.votes > 0:\n            return (self.recommendations / self.votes) * 10\n        else:\n            return _('Unrated')\n    score = property(_score)\n\n    def __str__(self):\n        return '%s: %s' % (self.category.title, self.title)\n\n    class Meta:\n        ordering = ('order', 'title',)\n        verbose_name = _('Knowledge base item')\n        verbose_name_plural = _('Knowledge base items')\n\n    def get_absolute_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:kb_category', args=(self.category.slug,))) + \"?kbitem=\" + str(self.pk)\n\n    def query_url(self):\n        from django.urls import reverse\n        return str(reverse('helpdesk:list')) + \"?kbitem=\" + str(self.pk)\n\n    def num_open_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2)).count()\n\n    def unassigned_tickets(self):\n        return Ticket.objects.filter(kbitem=self, status__in=(1, 2), assigned_to__isnull=True)\n\n    def get_markdown(self):\n        return get_markdown(self.answer)", "target": 0}, {"function": "class SavedSearch(models.Model):\n    \"\"\"\n    Allow a user to save a ticket search, eg their filtering and sorting\n    options, and optionally share it with other users. This lets people\n    easily create a set of commonly-used filters, such as:\n        * My tickets waiting on me\n        * My tickets waiting on submitter\n        * My tickets in 'Priority Support' queue with priority of 1\n        * All tickets containing the word 'billing'.\n         etc...\n    \"\"\"\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        verbose_name=_('User'),\n    )\n\n    title = models.CharField(\n        _('Query Name'),\n        max_length=100,\n        help_text=_('User-provided name for this query'),\n    )\n\n    shared = models.BooleanField(\n        _('Shared With Other Users?'),\n        blank=True,\n        default=False,\n        help_text=_('Should other users see this query?'),\n    )\n\n    query = models.TextField(\n        _('Search Query'),\n        help_text=_('Pickled query object. Be wary changing this.'),\n    )\n\n    def __str__(self):\n        if self.shared:\n            return '%s (*)' % self.title\n        else:\n            return '%s' % self.title\n\n    class Meta:\n        verbose_name = _('Saved search')\n        verbose_name_plural = _('Saved searches')", "target": 0}, {"function": "def get_default_setting(setting):\n    from helpdesk.settings import DEFAULT_USER_SETTINGS\n    return DEFAULT_USER_SETTINGS[setting]", "target": 0}, {"function": "def login_view_ticketlist_default():\n    return get_default_setting('login_view_ticketlist')", "target": 0}, {"function": "def email_on_ticket_change_default():\n    return get_default_setting('email_on_ticket_change')", "target": 0}, {"function": "def email_on_ticket_assign_default():\n    return get_default_setting('email_on_ticket_assign')", "target": 0}, {"function": "def tickets_per_page_default():\n    return get_default_setting('tickets_per_page')", "target": 0}, {"function": "def use_email_as_submitter_default():\n    return get_default_setting('use_email_as_submitter')", "target": 0}, {"function": "class UserSettings(models.Model):\n    \"\"\"\n    A bunch of user-specific settings that we want to be able to define, such\n    as notification preferences and other things that should probably be\n    configurable.\n    \"\"\"\n    PAGE_SIZES = ((10, '10'), (25, '25'), (50, '50'), (100, '100'))\n\n    user = models.OneToOneField(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        related_name=\"usersettings_helpdesk\")\n\n    settings_pickled = models.TextField(\n        _('DEPRECATED! Settings Dictionary DEPRECATED!'),\n        help_text=_('DEPRECATED! This is a base64-encoded representation of a pickled Python dictionary. '\n                    'Do not change this field via the admin.'),\n        blank=True,\n        null=True,\n    )\n\n    login_view_ticketlist = models.BooleanField(\n        verbose_name=_('Show Ticket List on Login?'),\n        help_text=_('Display the ticket list upon login? Otherwise, the dashboard is shown.'),\n        default=login_view_ticketlist_default,\n    )\n\n    email_on_ticket_change = models.BooleanField(\n        verbose_name=_('E-mail me on ticket change?'),\n        help_text=_(\n            'If you\\'re the ticket owner and the ticket is changed via the web by somebody else,'\n            'do you want to receive an e-mail?'\n        ),\n        default=email_on_ticket_change_default,\n    )\n\n    email_on_ticket_assign = models.BooleanField(\n        verbose_name=_('E-mail me when assigned a ticket?'),\n        help_text=_('If you are assigned a ticket via the web, do you want to receive an e-mail?'),\n        default=email_on_ticket_assign_default,\n    )\n\n    tickets_per_page = models.IntegerField(\n        verbose_name=_('Number of tickets to show per page'),\n        help_text=_('How many tickets do you want to see on the Ticket List page?'),\n        default=tickets_per_page_default,\n        choices=PAGE_SIZES,\n    )\n\n    use_email_as_submitter = models.BooleanField(\n        verbose_name=_('Use my e-mail address when submitting tickets?'),\n        help_text=_('When you submit a ticket, do you want to automatically '\n                    'use your e-mail address as the submitter address? You '\n                    'can type a different e-mail address when entering the '\n                    'ticket if needed, this option only changes the default.'),\n        default=use_email_as_submitter_default,\n    )\n\n    def __str__(self):\n        return 'Preferences for %s' % self.user\n\n    class Meta:\n        verbose_name = _('User Setting')\n        verbose_name_plural = _('User Settings')", "target": 0}, {"function": "def create_usersettings(sender, instance, created, **kwargs):\n    \"\"\"\n    Helper function to create UserSettings instances as\n    required, eg when we first create the UserSettings database\n    table via 'syncdb' or when we save a new user.\n\n    If we end up with users with no UserSettings, then we get horrible\n    'DoesNotExist: UserSettings matching query does not exist.' errors.\n    \"\"\"\n    if created:\n        UserSettings.objects.create(user=instance)", "target": 0}, {"function": "class IgnoreEmail(models.Model):\n    \"\"\"\n    This model lets us easily ignore e-mails from certain senders when\n    processing IMAP and POP3 mailboxes, eg mails from postmaster or from\n    known trouble-makers.\n    \"\"\"\n    class Meta:\n        verbose_name = _('Ignored e-mail address')\n        verbose_name_plural = _('Ignored e-mail addresses')\n\n    queues = models.ManyToManyField(\n        Queue,\n        blank=True,\n        help_text=_('Leave blank for this e-mail to be ignored on all queues, '\n                    'or select those queues you wish to ignore this e-mail for.'),\n    )\n\n    name = models.CharField(\n        _('Name'),\n        max_length=100,\n    )\n\n    date = models.DateField(\n        _('Date'),\n        help_text=_('Date on which this e-mail address was added'),\n        blank=True,\n        editable=False\n    )\n\n    email_address = models.CharField(\n        _('E-Mail Address'),\n        max_length=150,\n        help_text=_('Enter a full e-mail address, or portions with '\n                    'wildcards, eg *@domain.com or postmaster@*.'),\n    )\n\n    keep_in_mailbox = models.BooleanField(\n        _('Save Emails in Mailbox?'),\n        blank=True,\n        default=False,\n        help_text=_('Do you want to save emails from this address in the mailbox? '\n                    'If this is unticked, emails from this address will be deleted.'),\n    )\n\n    def __str__(self):\n        return '%s' % self.name\n\n    def save(self, *args, **kwargs):\n        if not self.date:\n            self.date = timezone.now()\n        return super(IgnoreEmail, self).save(*args, **kwargs)\n\n    def queue_list(self):\n        \"\"\"Return a list of the queues this IgnoreEmail applies to.\n        If this IgnoreEmail applies to ALL queues, return '*'.\n        \"\"\"\n        queues = self.queues.all().order_by('title')\n        if len(queues) == 0:\n            return '*'\n        else:\n            return ', '.join([str(q) for q in queues])\n\n    def test(self, email):\n        \"\"\"\n        Possible situations:\n            1. Username & Domain both match\n            2. Username is wildcard, domain matches\n            3. Username matches, domain is wildcard\n            4. username & domain are both wildcards\n            5. Other (no match)\n\n            1-4 return True, 5 returns False.\n        \"\"\"\n\n        own_parts = self.email_address.split(\"@\")\n        email_parts = email.split(\"@\")\n\n        if self.email_address == email or \\\n                own_parts[0] == \"*\" and own_parts[1] == email_parts[1] or \\\n                own_parts[1] == \"*\" and own_parts[0] == email_parts[0] or \\\n                own_parts[0] == \"*\" and own_parts[1] == \"*\":\n            return True\n        else:\n            return False", "target": 0}, {"function": "class TicketCC(models.Model):\n    \"\"\"\n    Often, there are people who wish to follow a ticket who aren't the\n    person who originally submitted it. This model provides a way for those\n    people to follow a ticket.\n\n    In this circumstance, a 'person' could be either an e-mail address or\n    an existing system user.\n    \"\"\"\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        on_delete=models.CASCADE,\n        blank=True,\n        null=True,\n        help_text=_('User who wishes to receive updates for this ticket.'),\n        verbose_name=_('User'),\n    )\n\n    email = models.EmailField(\n        _('E-Mail Address'),\n        blank=True,\n        null=True,\n        help_text=_('For non-user followers, enter their e-mail address'),\n    )\n\n    can_view = models.BooleanField(\n        _('Can View Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login to view the ticket details?'),\n    )\n\n    can_update = models.BooleanField(\n        _('Can Update Ticket?'),\n        blank=True,\n        default=False,\n        help_text=_('Can this CC login and update the ticket?'),\n    )\n\n    def _email_address(self):\n        if self.user and self.user.email is not None:\n            return self.user.email\n        else:\n            return self.email\n    email_address = property(_email_address)\n\n    def _display(self):\n        if self.user:\n            return self.user\n        else:\n            return self.email\n    display = property(_display)\n\n    def __str__(self):\n        return '%s for %s' % (self.display, self.ticket.title)\n\n    def clean(self):\n        if self.user and not self.user.email:\n            raise ValidationError('User has no email address')", "target": 0}, {"function": "class CustomFieldManager(models.Manager):\n\n    def get_queryset(self):\n        return super(CustomFieldManager, self).get_queryset().order_by('ordering')", "target": 0}, {"function": "class CustomField(models.Model):\n    \"\"\"\n    Definitions for custom fields that are glued onto each ticket.\n    \"\"\"\n\n    name = models.SlugField(\n        _('Field Name'),\n        help_text=_('As used in the database and behind the scenes. '\n                    'Must be unique and consist of only lowercase letters with no punctuation.'),\n        unique=True,\n    )\n\n    label = models.CharField(\n        _('Label'),\n        max_length=30,\n        help_text=_('The display label for this field'),\n    )\n\n    help_text = models.TextField(\n        _('Help Text'),\n        help_text=_('Shown to the user when editing the ticket'),\n        blank=True,\n        null=True\n    )\n\n    DATA_TYPE_CHOICES = (\n        ('varchar', _('Character (single line)')),\n        ('text', _('Text (multi-line)')),\n        ('integer', _('Integer')),\n        ('decimal', _('Decimal')),\n        ('list', _('List')),\n        ('boolean', _('Boolean (checkbox yes/no)')),\n        ('date', _('Date')),\n        ('time', _('Time')),\n        ('datetime', _('Date & Time')),\n        ('email', _('E-Mail Address')),\n        ('url', _('URL')),\n        ('ipaddress', _('IP Address')),\n        ('slug', _('Slug')),\n    )\n\n    data_type = models.CharField(\n        _('Data Type'),\n        max_length=100,\n        help_text=_('Allows you to restrict the data entered into this field'),\n        choices=DATA_TYPE_CHOICES,\n    )\n\n    max_length = models.IntegerField(\n        _('Maximum Length (characters)'),\n        blank=True,\n        null=True,\n    )\n\n    decimal_places = models.IntegerField(\n        _('Decimal Places'),\n        help_text=_('Only used for decimal fields'),\n        blank=True,\n        null=True,\n    )\n\n    empty_selection_list = models.BooleanField(\n        _('Add empty first choice to List?'),\n        default=False,\n        help_text=_('Only for List: adds an empty first entry to the choices list, '\n                    'which enforces that the user makes an active choice.'),\n    )\n\n    list_values = models.TextField(\n        _('List Values'),\n        help_text=_('For list fields only. Enter one option per line.'),\n        blank=True,\n        null=True,\n    )\n\n    ordering = models.IntegerField(\n        _('Ordering'),\n        help_text=_('Lower numbers are displayed first; higher numbers are listed later'),\n        blank=True,\n        null=True,\n    )\n\n    def _choices_as_array(self):\n        valuebuffer = StringIO(self.list_values)\n        choices = [[item.strip(), item.strip()] for item in valuebuffer.readlines()]\n        valuebuffer.close()\n        return choices\n    choices_as_array = property(_choices_as_array)\n\n    required = models.BooleanField(\n        _('Required?'),\n        help_text=_('Does the user have to enter a value for this field?'),\n        default=False,\n    )\n\n    staff_only = models.BooleanField(\n        _('Staff Only?'),\n        help_text=_('If this is ticked, then the public submission form '\n                    'will NOT show this field'),\n        default=False,\n    )\n\n    objects = CustomFieldManager()\n\n    def __str__(self):\n        return '%s' % self.name\n\n    class Meta:\n        verbose_name = _('Custom field')\n        verbose_name_plural = _('Custom fields')", "target": 0}, {"function": "class TicketCustomFieldValue(models.Model):\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n    )\n\n    field = models.ForeignKey(\n        CustomField,\n        on_delete=models.CASCADE,\n        verbose_name=_('Field'),\n    )\n\n    value = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.field)\n\n    class Meta:\n        unique_together = (('ticket', 'field'),)\n        verbose_name = _('Ticket custom field value')\n        verbose_name_plural = _('Ticket custom field values')", "target": 0}, {"function": "class TicketDependency(models.Model):\n    \"\"\"\n    The ticket identified by `ticket` cannot be resolved until the ticket in `depends_on` has been resolved.\n    To help enforce this, a helper function `can_be_resolved` on each Ticket instance checks that\n    these have all been resolved.\n    \"\"\"\n    class Meta:\n        unique_together = (('ticket', 'depends_on'),)\n        verbose_name = _('Ticket dependency')\n        verbose_name_plural = _('Ticket dependencies')\n\n    ticket = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Ticket'),\n        related_name='ticketdependency',\n    )\n\n    depends_on = models.ForeignKey(\n        Ticket,\n        on_delete=models.CASCADE,\n        verbose_name=_('Depends On Ticket'),\n        related_name='depends_on',\n    )\n\n    def __str__(self):\n        return '%s / %s' % (self.ticket, self.depends_on)", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
