{"index": 12288, "cve_id": "CVE-2023-42458", "cwe_id": ["CWE-79", "CWE-80"], "cve_language": "Python", "cve_description": "Zope is an open-source web application server. Prior to versions 4.8.10 and 5.8.5, there is a stored cross site scripting vulnerability for SVG images. Note that an image tag with an SVG image as source is never vulnerable, even when the SVG image contains malicious code. To exploit the vulnerability, an attacker would first need to upload an image, and then trick a user into following a specially crafted link. Patches are available in Zope 4.8.10 and 5.8.5. As a workaround, make sure the \"Add Documents, Images, and Files\" permission is only assigned to trusted roles. By default, only the Manager has this permission.", "cvss": "5.4", "publish_date": "September 21, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "REQUIRED", "S": "CHANGED", "C": "LOW", "I": "LOW", "A": "NONE", "commit_id": "603b0a12881c90a072a7a65e32d47ed898ce37cb", "commit_message": "Merge pull request from GHSA-wm8q-9975-xh5v\n\n* Allow only some image types to be displayed inline.\n\nForce download for others, especially SVG images.  By default we use a list of allowed types.\nYou can switch a to a list of denied types by setting OS environment variable\n``OFS_IMAGE_USE_DENYLIST=1``.  This change only affects direct URL access.\n``<img src=\"image.svg\" />`` works the same as before.\n\nSee security advisory:\nhttps://github.com/zopefoundation/Zope/security/advisories/GHSA-wm8q-9975-xh5v\n\n* Use guess_extension as first guess for the extension of an image.\n\n* Support overriding ALLOWED_INLINE_MIMETYPES and DISALLOWED_INLINE_MIMETYPES.\n\n* Test that filename of attachment gets encoded correctly.\n\n* Add CVE\n\n---------\n\nCo-authored-by: Michael Howitz <icemac@gmx.net>", "commit_date": "2023-09-21T08:01:18Z", "project": "zopefoundation/zope", "url": "https://api.github.com/repos/zopefoundation/Zope/commits/603b0a12881c90a072a7a65e32d47ed898ce37cb", "html_url": "https://github.com/zopefoundation/Zope/commit/603b0a12881c90a072a7a65e32d47ed898ce37cb", "windows_before": [{"commit_id": "05f81d908629a76819d69a8e3dd1e412f5722444", "commit_date": "Thu Sep 21 09:36:38 2023 +0200", "commit_message": "SVG-File: avoid attr error on missing dimensions (#1157)", "files_name": ["src/OFS/Image.py"]}, {"commit_id": "4b714a2863bb96891a8179adb72e0404fb3a6895", "commit_date": "Thu Sep 21 09:35:36 2023 +0200", "commit_message": "Fix RTD build. (#1163)", "files_name": [".readthedocs.yaml"]}, {"commit_id": "440c476c5a7f7f73c6293e98c95681af6f88e568", "commit_date": "Thu Sep 21 09:34:05 2023 +0200", "commit_message": "Fix version pins for Python 3.7 and 3.8. (#1159)", "files_name": [".github/workflows/tests.yml", ".meta.toml", "CHANGES.rst", "buildout.cfg", "constraints.txt", "requirements-full.txt", "tox.ini", "util.py", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "09cd2a3ad3ee1e0ee3f6ff0a14564594e222b24a", "commit_date": "Wed Sep 20 10:27:47 2023 +0200", "commit_message": "Credit Miguel Segovia Gil for reporting a problem. (#1162)", "files_name": ["CHANGES.rst"]}, {"commit_id": "89134b30ad309c3d32a29afe2a118abbd8b53864", "commit_date": "Tue Sep 19 15:19:51 2023 +0900", "commit_message": "WSGIPublisher: set REMOTE_USER even in case of error (#1156)", "files_name": ["CHANGES.rst", "src/ZPublisher/WSGIPublisher.py", "src/ZPublisher/tests/test_WSGIPublisher.py"]}, {"commit_id": "a0f70b6806272523f4d9fafb11ab3ffac1638638", "commit_date": "Tue Sep 19 15:14:18 2023 +0900", "commit_message": "CHANGES.rst: fix new changes added to previous release (#1158)", "files_name": ["CHANGES.rst"]}, {"commit_id": "a9b1e5bd4c6e564cbee82d33b13caa534718511b", "commit_date": "Sat Sep 16 18:34:43 2023 +0200", "commit_message": "Added Image Info for SVG files (#1146)", "files_name": ["CHANGES.rst", "src/OFS/Image.py"]}, {"commit_id": "59f68703c249a0a0f5b3b092395709820f221108", "commit_date": "Thu Sep 14 22:49:05 2023 +0200", "commit_message": "- adding Paste again to the minimum buildout configuration [ci skip]", "files_name": ["docs/INSTALL.rst"]}, {"commit_id": "a8fc9944e6c862f1a010045181e56c688388fbf0", "commit_date": "Mon Sep 11 23:21:25 2023 +0200", "commit_message": "getZMIMainFrameTarget: do not accept a 'tainted' came_from parameter. (#1152)", "files_name": ["src/OFS/Application.py", "src/OFS/tests/testApplication.py"]}, {"commit_id": "9bc495949a88119929c7e16a6bd008c2d84657d5", "commit_date": "Mon Sep 11 06:26:48 2023 +0000", "commit_message": "Tighten down the ZMI frame source logic to only allow site-local sources (#1151)", "files_name": ["CHANGES.rst", "setup.py", "src/App/dtml/manage.dtml", "src/OFS/Application.py", "src/OFS/tests/testApplication.py"]}, {"commit_id": "00bc207ca2a0757f336793c3027b9220aeadddd4", "commit_date": "Mon Sep 11 08:13:54 2023 +0200", "commit_message": "- add note to be more diligent about bugfix vs. feature releases", "files_name": ["docs/maintenance.rst"]}, {"commit_id": "a0cbc57ad3fd3d6e78706dbab449867a2c3a46ab", "commit_date": "Thu Sep 7 08:13:45 2023 +0200", "commit_message": "Use the extra which requires `Paste`.", "files_name": ["docs/INSTALL.rst"]}, {"commit_id": "98c94dcaaeff1ef1f8090f3c08754a769d585973", "commit_date": "Thu Sep 7 07:33:20 2023 +0200", "commit_message": "Change next version to be a minor one as updating dependencies is a feature not a bugfix.", "files_name": ["CHANGES.rst", "setup.py"]}, {"commit_id": "42f4a581f57d3dc97449f91be726369ecb9b39f4", "commit_date": "Wed Sep 6 15:17:27 2023 +0200", "commit_message": "- tell people not to use the default buildout config in production [ci skip]", "files_name": ["docs/INSTALL.rst"]}, {"commit_id": "294a4241b57c2e1ad6a44d3be7806273adc610f7", "commit_date": "Wed Sep 6 13:01:10 2023 +0200", "commit_message": "- fix change log glitch [ci skip]", "files_name": ["CHANGES.rst"]}, {"commit_id": "243f2f6166bb813f319d5e2c3bfad2ebe264aac8", "commit_date": "Wed Sep 6 12:54:10 2023 +0200", "commit_message": "- vb and update to the latest dependencies", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "setup.py", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "4e63a8c3bed8c195cf9e3d5472129836f1cab96b", "commit_date": "Wed Sep 6 12:27:40 2023 +0200", "commit_message": "- prepare release 5.8.4", "files_name": ["CHANGES.rst", "buildout.cfg", "docs/conf.py", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}, {"commit_id": "bc378097446ad638980f7d24de626f46b25d6f02", "commit_date": "Wed Sep 6 08:31:12 2023 +0200", "commit_message": "Add preliminary support for Python 3.12rc1. (#1129)", "files_name": [".github/workflows/tests.yml", ".meta.toml", "CHANGES.rst", "src/Zope2/Startup/tests/test_schema.py", "tox.ini", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "49ec18f06033c9af285f957463c3b9123789bead", "commit_date": "Mon Sep 4 08:12:58 2023 +0200", "commit_message": "Update `AccessControl` to version 6.2 to mitigate a security problem. (#1148)", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "c31b1c635e85a1766f2666cb0bd117337ae5fa67", "commit_date": "Wed Aug 30 08:34:44 2023 +0200", "commit_message": "Update ``RestrictedPython`` to 6.2 to mitigate a security problem.", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "28f834bba98479e61de4bbe41e37f9b794344d53", "commit_date": "Wed Aug 23 08:22:09 2023 +0200", "commit_message": "Make linter happy: E721 do not compare types.", "files_name": ["src/OFS/PropertyManager.py", "src/OFS/PropertySheets.py", "src/ZPublisher/tests/test_utils.py"]}, {"commit_id": "18a1748c5547e5208ea674f4c91a8e54a6403a52", "commit_date": "Fri Jul 14 13:57:53 2023 +0200", "commit_message": "fix (and test) limit for  `request.BODY` (#1143)", "files_name": ["src/ZPublisher/HTTPRequest.py", "src/ZPublisher/tests/testHTTPRequest.py"]}, {"commit_id": "f62d0c913d4f6ba8408c52255f82ce8cf8e80325", "commit_date": "Thu Jul 13 18:26:37 2023 +0200", "commit_message": "make Zope's parameters for denial of service protection configurable (#1142)", "files_name": ["CHANGES.rst", "src/ZPublisher/HTTPRequest.py", "src/Zope2/Startup/handlers.py", "src/Zope2/Startup/tests/test_schema.py", "src/Zope2/Startup/wsgischema.xml", "src/Zope2/utilities/skel/etc/zope.conf.in"]}, {"commit_id": "345d656557bfc414f70b92637fef33dde747a97d", "commit_date": "Sat Jul 8 09:41:13 2023 +0200", "commit_message": "- update RestrictedPython", "files_name": ["constraints.txt", "requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "f9ca2d1d75ce66a7647d329e1ce619cac47a98ca", "commit_date": "Mon Jun 26 08:36:53 2023 +0200", "commit_message": "Pin RestrictedPython for Python 3.12.", "files_name": ["versions-prod.cfg"]}, {"commit_id": "409d8a95ec3d6a7cd1f3a6ad915bc91817d56872", "commit_date": "Tue Jun 20 08:26:39 2023 +0200", "commit_message": "Make `mapply`  `__signature__` aware (#1135)", "files_name": ["CHANGES.rst", "src/ZPublisher/mapply.py", "src/ZPublisher/tests/test_mapply.py"]}, {"commit_id": "b0bb1084379c5c693f9277b3d0ce044cea849dda", "commit_date": "Mon Jun 19 15:31:07 2023 +0200", "commit_message": "Restore filename on code objects: `App.Extensions.getObject()`. (#1138)", "files_name": ["CHANGES.rst", "src/App/Extensions.py", "src/App/tests/fixtures/error.py", "src/App/tests/fixtures/getObject.py", "src/App/tests/test_Extensions.py"]}, {"commit_id": "1f2a5a67b490c51a6a26be2ace90d749450573ae", "commit_date": "Mon Jun 19 10:47:12 2023 +0200", "commit_message": "Disable `ZCatalog`  performance test (#1137)", "files_name": [".meta.toml", "CHANGES.rst", "tox.ini"]}, {"commit_id": "10c1eb4f1001e8a7dca83357b578c116ee32be61", "commit_date": "Thu Jun 15 11:01:31 2023 -0500", "commit_message": "- vb and update to newest compatible versions of dependencies.", "files_name": ["CHANGES.rst", "buildout.cfg", "constraints.txt", "docs/maintenance.rst", "requirements-full.txt", "setup.py", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "bd390a2a16098ceda3b5fea82355e388c2120e90", "commit_date": "Thu Jun 15 10:43:18 2023 -0500", "commit_message": "- prepare release 5.8.3", "files_name": ["CHANGES.rst", "buildout.cfg", "docs/conf.py", "docs/maintenance.rst", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}, {"commit_id": "bb95e60d393894135b609c0f1e821319618a7432", "commit_date": "Thu Jun 15 17:25:47 2023 +0200", "commit_message": "fix handling of a request parameter of type `file` if no file has been selected (#1133)", "files_name": ["CHANGES.rst", "src/Products/PageTemplates/tests/testZopePageTemplate.py", "src/ZPublisher/HTTPRequest.py", "src/ZPublisher/tests/testHTTPRequest.py"]}, {"commit_id": "893e695dcd38ba829765a89c3743a47e3eb566a5", "commit_date": "Thu Jun 15 13:10:20 2023 +0000", "commit_message": "- Fix adding Page Templates without valid file input from the ZMI (#1131)", "files_name": ["CHANGES.rst", "src/Products/PageTemplates/ZopePageTemplate.py", "src/Products/PageTemplates/tests/testZopePageTemplate.py"]}, {"commit_id": "5128b943df76d5fb557245eedd841c85ad7ba1c0", "commit_date": "Thu May 25 07:08:39 2023 +0200", "commit_message": "- downgrade z3c.checkversions which requires pinning setuptools", "files_name": ["constraints.txt", "requirements-full.txt", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "fcf8c4a2230974d61e218df5ce84ecdb8765b871", "commit_date": "Mon May 22 14:12:11 2023 +0200", "commit_message": "- vb and update to latest package versions", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "57fcd10469e19f7cfb411a63d38357c42ce43df5", "commit_date": "Mon May 22 13:54:18 2023 +0200", "commit_message": "- vb [ci skip]", "files_name": ["CHANGES.rst", "buildout.cfg", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}, {"commit_id": "d71a092cb6581e6c3ae5c3825a7dad764e2a4b54", "commit_date": "Mon May 22 13:42:45 2023 +0200", "commit_message": "- prepare release 5.8.2", "files_name": ["CHANGES.rst"]}], "windows_after": [{"commit_id": "da90fbbf46934761af040f64f1428b7c6d689399", "commit_date": "Thu Sep 21 11:28:32 2023 +0200", "commit_message": "Garden change log and buildout.cfg.", "files_name": ["CHANGES.rst", "buildout.cfg"]}, {"commit_id": "fb6535a54719c5fabb8e0ff67e17324a7e691eb7", "commit_date": "Thu Sep 21 11:29:16 2023 +0200", "commit_message": "Preparing release 5.8.5", "files_name": ["CHANGES.rst", "setup.py"]}, {"commit_id": "13596dfeb44456dd144126c9b4da1ac442f759a7", "commit_date": "Thu Sep 21 11:33:37 2023 +0200", "commit_message": "Pin version.", "files_name": ["docs/conf.py", "requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "1af5fe73f65a175b5f7e3d3f72208f0d3b38f66a", "commit_date": "Thu Sep 21 11:34:46 2023 +0200", "commit_message": "Back to development: 5.8.6", "files_name": ["CHANGES.rst", "setup.py"]}, {"commit_id": "4e23d47c6a5113f8dc2168205ba3195d1c863b72", "commit_date": "Thu Sep 21 11:35:30 2023 +0200", "commit_message": "Post release bump.", "files_name": ["requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "e3b8fdbd64f24e69abdf36dc504b416f2505795b", "commit_date": "Thu Sep 21 11:40:01 2023 +0200", "commit_message": "requires.io was shut down in September 2022.", "files_name": ["docs/maintenance.rst"]}, {"commit_id": "f64e3f9950ad70c680cd88e5946aa1baf4d3a54a", "commit_date": "Thu Sep 21 11:52:52 2023 +0200", "commit_message": "Fix URL.", "files_name": ["docs/maintenance.rst"]}, {"commit_id": "b163766fb5150e432770b4e5ea6f4119c0c771b9", "commit_date": "Thu Sep 21 11:49:21 2023 +0200", "commit_message": "Update to newest compatible versions of dependencies.", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "1aa25a1a4549b4544ce2ec06dc0b5e4955a7c604", "commit_date": "Thu Sep 21 11:49:32 2023 +0200", "commit_message": "Fix news.", "files_name": ["docs/news.rst"]}, {"commit_id": "7eed9298099c920627337568f17d47570ccb99e1", "commit_date": "Wed Sep 27 08:33:57 2023 +0200", "commit_message": "Integrate .readthedocs.yaml (#1165)", "files_name": [".meta.toml", ".readthedocs.yaml", "docs/conf.py", "docs/requirements.txt"]}, {"commit_id": "efadec226467923a53feab116907a04ff8eef4a2", "commit_date": "Wed Sep 27 08:43:11 2023 +0200", "commit_message": "tempstorage is really needed", "files_name": ["docs/requirements.txt"]}, {"commit_id": "9b52f66a3b89f450fb53fc43463b7943c8f0cfb5", "commit_date": "Wed Sep 27 11:31:24 2023 +0200", "commit_message": "Base logic for CVE-2023-42458 on the media type proper (#1167)", "files_name": ["CHANGES.rst", "src/OFS/Image.py", "src/OFS/tests/testFileAndImage.py"]}, {"commit_id": "ca04df1b61536abcef96f006459f84691b08a723", "commit_date": "Tue Oct 3 10:51:53 2023 +0200", "commit_message": "zmi: whitespace-cleanup, minor html fixes (#1169)", "files_name": ["src/App/dtml/manage_tabs.dtml", "src/OFS/dtml/cmassoc.dtml", "src/OFS/dtml/fileEdit.dtml", "src/OFS/dtml/findForm.dtml"]}, {"commit_id": "aeaf2cdc80dff60815e3706af448f086ddc3b98d", "commit_date": "Wed Oct 4 11:40:29 2023 +0000", "commit_message": "Merge pull request from GHSA-m755-gxxg-r5qh", "files_name": ["src/App/dtml/manage_tabs.dtml"]}, {"commit_id": "a1d8261b5fbfec74550711eadfcfdfa166833fcd", "commit_date": "Wed Oct 4 14:06:47 2023 +0200", "commit_message": "- prepare release 5.8.6", "files_name": ["CHANGES.rst", "docs/conf.py", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}, {"commit_id": "5b822e1ae0f5888f9bb86ddd218000abdc7f078a", "commit_date": "Wed Oct 4 14:11:54 2023 +0200", "commit_message": "- fix RTD", "files_name": ["docs/requirements.txt"]}, {"commit_id": "773c12cb9ea1b4f374e146976a60d6662c8f92cc", "commit_date": "Wed Oct 4 14:13:07 2023 +0200", "commit_message": "- fix typo [ci skip]", "files_name": ["docs/requirements.txt"]}, {"commit_id": "d359e08ad7eb6ae7dc32915a31508241f3ce517f", "commit_date": "Wed Oct 4 14:33:09 2023 +0200", "commit_message": "- vb and update to newest compatible versions of dependencies", "files_name": ["CHANGES.rst", "constraints.txt", "requirements-full.txt", "setup.py", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "ca78fee2748d8d49f49374df9a0d6381fa61e1b2", "commit_date": "Thu Oct 5 11:29:40 2023 +0200", "commit_message": "Update .readthedocs.yaml", "files_name": [".readthedocs.yaml"]}, {"commit_id": "be2331f666beac5204884345a32bc8233ff3d421", "commit_date": "Thu Oct 5 11:30:52 2023 +0200", "commit_message": "Revert \"Update .readthedocs.yaml\"", "files_name": [".readthedocs.yaml"]}, {"commit_id": "dcff18189418f1234b8941b13c19f7e72d6c2975", "commit_date": "Fri Oct 6 07:55:40 2023 +0200", "commit_message": "- use final Python 3.12 release for tests and use new binary package releases", "files_name": [".github/workflows/tests.yml", ".meta.toml", "constraints.txt", "requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "ce5288a1b4b3dad6a0a10ce44cbfa89d0c22ef4a", "commit_date": "Wed Oct 11 08:14:10 2023 +0200", "commit_message": "Update ACE editor 1.4.4 to 1.5.0 (#1166)", "files_name": ["src/OFS/Application.py", "src/zmi/styles/configure.zcml", "src/zmi/styles/resources/ace.ajax.org/ace.js", "src/zmi/styles/resources/ace.ajax.org/ext-searchbox.js", "src/zmi/styles/resources/ace.ajax.org/mode-css.js", "src/zmi/styles/resources/ace.ajax.org/mode-html.js", "src/zmi/styles/resources/ace.ajax.org/mode-javascript.js", "src/zmi/styles/resources/ace.ajax.org/mode-json.js", "src/zmi/styles/resources/ace.ajax.org/mode-less.js", "src/zmi/styles/resources/ace.ajax.org/mode-markdown.js", "src/zmi/styles/resources/ace.ajax.org/mode-python.js", "src/zmi/styles/resources/ace.ajax.org/mode-sql.js", "src/zmi/styles/resources/ace.ajax.org/mode-svg.js", "src/zmi/styles/resources/ace.ajax.org/theme-chrome.js", "src/zmi/styles/resources/ace.ajax.org/theme-clouds.js", "src/zmi/styles/resources/ace.ajax.org/theme-eclipse.js", "src/zmi/styles/resources/ace.ajax.org/theme-mono_industrial.js", "src/zmi/styles/resources/ace.ajax.org/worker-base.js", "src/zmi/styles/resources/ace.ajax.org/worker-css.js", "src/zmi/styles/resources/ace.ajax.org/worker-html.js", "src/zmi/styles/resources/ace.ajax.org/worker-javascript.js", "src/zmi/styles/resources/ace.ajax.org/worker-json.js", "src/zmi/styles/resources/ace.ajax.org/worker-xml.js", "src/zmi/styles/resources/logo/default.css"]}, {"commit_id": "cc55f2f9426187acabc79832c30181e6ec5ba8f4", "commit_date": "Wed Oct 11 08:15:55 2023 +0200", "commit_message": "- add change log entry [ci skip]", "files_name": ["CHANGES.rst"]}, {"commit_id": "c070668ea18c585c55784e40c1ef68851cfbd011", "commit_date": "Wed Oct 11 14:18:26 2023 +0200", "commit_message": "- fix long lines [ci skip]", "files_name": ["src/OFS/Application.py"]}, {"commit_id": "d87e9184cb66e0361ff02aa55b0bd7d036786a9b", "commit_date": "Fri Oct 13 09:59:05 2023 +0200", "commit_message": "honor a request's `Content-Length` (#1172)", "files_name": ["CHANGES.rst", "src/ZPublisher/HTTPRequest.py", "src/ZPublisher/tests/testHTTPRequest.py"]}, {"commit_id": "533df7304e78021c0827b3d31e93d20d61b8fafd", "commit_date": "Sat Oct 14 08:29:15 2023 +0200", "commit_message": "SVG-File: avoid attr error on missing dimensions (2) (#1170)", "files_name": ["src/OFS/Image.py"]}, {"commit_id": "4268cb13a4ba62ec90ff941c2aececbf21c2970b", "commit_date": "Sat Oct 14 09:25:25 2023 +0000", "commit_message": "- apply https://github.com/zopefoundation/meta/pull/216 (#1174)", "files_name": [".meta.toml", "src/ZPublisher/HTTPRequest.py", "tox.ini"]}, {"commit_id": "29e088e04db9feb9f5d3bc6bea8950d98f8283a1", "commit_date": "Wed Oct 18 09:13:08 2023 +0200", "commit_message": "Wsgi content length (#1175)", "files_name": ["CHANGES.rst", "setup.py", "src/ZPublisher/HTTPRequest.py", "src/ZPublisher/pastefilter.py", "src/ZPublisher/tests/testHTTPRequest.py", "src/ZPublisher/tests/test_pastefilter.py", "src/Zope2/utilities/skel/etc/zope.ini.in"]}, {"commit_id": "8fdd567347ab0f3973d3f987e55da7a8644d1a82", "commit_date": "Thu Oct 26 17:27:54 2023 +0200", "commit_message": "Separate ZODB connection information into new ZODB Connections view (#1178)", "files_name": ["CHANGES.rst", "src/App/ApplicationManager.py", "src/App/DavLockManager.py", "src/App/ZODBConnectionDebugger.py", "src/App/dtml/dbMain.dtml", "src/App/dtml/debug.dtml", "src/App/dtml/zodbConnections.dtml", "src/zmi/styles/resources/zmi_base.css"]}, {"commit_id": "f2099257984a6b3523ed44fee204dc09836be46a", "commit_date": "Thu Nov 2 14:59:07 2023 +0100", "commit_message": "Improved/corrected documentation for the DOS protection options (#1180)", "files_name": ["src/Zope2/Startup/wsgischema.xml"]}, {"commit_id": "fe08bae876f13dc1dbc333730eaeb51f264f46a3", "commit_date": "Mon Nov 6 08:53:05 2023 +0100", "commit_message": "Update to a RestrictedPython version which can be installed on Python 3.13. (#1181)", "files_name": [".github/workflows/tests.yml", ".meta.toml", "constraints.txt", "requirements-full.txt", "versions-prod.cfg"]}, {"commit_id": "5105b5336e2874fd5e293b7621312a0af2ee4589", "commit_date": "Tue Nov 7 08:07:54 2023 +0100", "commit_message": "support form data in PUT requests (#1183)", "files_name": ["CHANGES.rst", "src/ZPublisher/HTTPRequest.py", "src/ZPublisher/tests/testHTTPRequest.py"]}, {"commit_id": "415d49e2d77c7900c27be74eb8132cdb2d7d99a0", "commit_date": "Fri Nov 24 09:49:02 2023 +0100", "commit_message": "Officially support Python 3.12. (#1184)", "files_name": [".meta.toml", "CHANGES.rst", "constraints.txt", "requirements-full.txt", "setup.py", "versions-prod.cfg", "versions.cfg"]}, {"commit_id": "f28f0a8574c10e74511c5345fc06acdf3f7415b7", "commit_date": "Fri Nov 24 10:52:03 2023 +0100", "commit_message": "- prepare release 5.9", "files_name": ["CHANGES.rst", "docs/conf.py", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}, {"commit_id": "f6441eec6c3131529f703c4e124579f069a03d8b", "commit_date": "Fri Nov 24 10:58:13 2023 +0100", "commit_message": "- vb [ci skip]", "files_name": ["CHANGES.rst", "requirements-full.txt", "setup.py", "versions-prod.cfg"]}], "parents": [{"commit_id_before": "05f81d908629a76819d69a8e3dd1e412f5722444", "url_before": "https://api.github.com/repos/zopefoundation/Zope/commits/05f81d908629a76819d69a8e3dd1e412f5722444", "html_url_before": "https://github.com/zopefoundation/Zope/commit/05f81d908629a76819d69a8e3dd1e412f5722444"}], "details": [{"raw_url": "https://github.com/zopefoundation/Zope/raw/603b0a12881c90a072a7a65e32d47ed898ce37cb/CHANGES.rst", "code": "Change log\n==========\n\nThese are all the changes for Zope 5, starting with the alpha releases,\nsince the branch point at Zope 4.1.2.\n\nThe change log for the previous version, Zope 4, is at\nhttps://github.com/zopefoundation/Zope/blob/4.x/CHANGES.rst\n\n\n5.8.5 (unreleased)\n------------------\n\n- Allow only some image types to be displayed inline. Force download for\n  others, especially SVG images.  By default we use a list of allowed types.\n  You can switch a to a list of denied types by setting OS environment variable\n  ``OFS_IMAGE_USE_DENYLIST=1``.  You can override the allowed list with\n  environment variable ``ALLOWED_INLINE_MIMETYPES`` and the disallowed list\n  with ``DISALLOWED_INLINE_MIMETYPES``.  Separate multiple entries by either\n  comma or space.  This change only affects direct URL access.\n  ``<img src=\"image.svg\" />`` works the same as before. (CVE-2023-42458)\n  See `security advisory <https://github.com/zopefoundation/Zope/security/advisories/GHSA-wm8q-9975-xh5v>`_.\n\n- Tighten down the ZMI frame source logic to only allow site-local sources.\n  Problem reported by Miguel Segovia Gil.\n\n- Update to newest compatible versions of dependencies.\n\n- Added image dimensions to SVG file properties\n  `#1146 <https://github.com/zopefoundation/Zope/pull/1146>`_.\n\n- Fix username not in access log for error requests, see issue\n  `#1155 <https://github.com/zopefoundation/Zope/issues/1155>`_.\n\n- Add preliminary support for Python 3.12rc3.\n\n5.8.4 (2023-09-06)\n------------------\n\n- Disable a ``ZCatalog`` (more precisly: ``Products.PluginIndexes``)\n  performance test which occasionally fails on GitHub.\n  For details, see\n  `#1136 <https://github.com/zopefoundation/Zope/issues/1136>`_.\n\n- Restore filename on code objects of objects returned from\n  ``App.Extensions.getObject()``. This got lost in 4.0a6.\n\n- Update to newest compatible versions of dependencies.\n\n- Add preliminary support for Python 3.12rc1.\n\n- Make ``mapply`` ``__signature__`` aware.\n  This allows to publish methods decorated via a decorator\n  which sets ``__signature__`` on the wrapper to specify\n  the signature to use.\n  For details, see\n  `#1134 <https://github.com/zopefoundation/Zope/issues/1134>`_.\n  Note: ``mapply`` still does not support keyword only, var positional\n  and var keyword parameters.\n\n- Make Zope's parameters for denial of service protection configurable\n  `#1141 <https://github.com/zopefoundation/Zope/issues/1141>`_.\n\n- Update ``RestrictedPython`` to version 6.2 to mitigate a security problem.\n  (CVE-2023-41039)\n\n- Update ``AccessControl`` to version 6.2 to mitigate a security problem.\n  (CVE-2023-41050)\n\n\n5.8.3 (2023-06-15)\n------------------\n\n- Fix handling of a request parameter of type ``file`` if no value\n  has been specified;\n  fixes `#1132 <https://github.com/zopefoundation/Zope/issues/1132>`_.\n\n- Fix adding Page Templates without valid file input from the ZMI\n  (`#1130 <https://github.com/zopefoundation/Zope/issues/1130>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.8.2 (2023-05-22)\n------------------\n\n- Allow ``ZPublisher`` to handle both a query string and a request body;\n  the request parameters from the query string are made available\n  in the request attribute ``form`` (a ``dict``),\n  the request body can be accessed via the request keys ``BODY``\n  (a ``bytes`` object) or ``BODYFILE`` (a file like object).\n  Fixes `#1122 <https://github.com/zopefoundation/Zope/issues/1122>`_.\n\n- Support access to the request's ``BODY`` key for WSGI servers\n  which hand over an unseekable request body (such as e.g.\n  ``Gunicorn``).\n  Fixes `#1125 <https://github.com/zopefoundation/Zope/issues/1125>`_.\n\n- Do not break on GET requests that pass a query string\n  and a `Content-Type` header.\n  For details see `#1117 <https://github.com/zopefoundation/Zope/pull/1117>`_.\n\n- Implement code change suggestions from CodeQL scanning.\n\n- Added Japanese translations for some Sphinx docs\n  (`#1109 <https://github.com/zopefoundation/Zope/issues/1109>`_)\n\n- Update to newest compatible versions of dependencies.\n\n- Update zope.ini.in skel to support log paths that use backslashes.\n  (`#1106 <https://github.com/zopefoundation/Zope/issues/1106>`_)\n\n\n5.8.1 (2023-03-17)\n------------------\n\n- Sanitize tainting fixing\n  `#1095 <https://github.com/zopefoundation/Zope/issues/1095>`_\n\n- Replace ``cgi.FieldStorage`` by ``multipart`` avoiding\n  the ``cgi`` module deprecated by Python 3.11.\n\n  Mark binary converters with a true ``binary`` attribute.\n\n  Fix encoding handling and ``:bytes`` converter.\n\n  See `#1094 <https://github.com/zopefoundation/Zope/pull/1094>`_.\n\n- Clean out and refactor dependency configuration files.\n\n- Update to newest compatible versions of dependencies.\n\n- Support the (non standard) ``charset`` parameter for\n  content type ``application/x-www-form-urlencoded``.\n  This is required (e.g. for ``Plone``) because\n  ``jquery`` constructs content types of the form\n  ```application/x-www-form-urlencoded; charset=utf-8``.\n  For details see\n  `plone/buildout.coredev#844\n  <https://github.com/plone/buildout.coredev/pull/844>`_.\n\n\n5.8 (2023-01-10)\n----------------\n\n- Only set response header Content-Type as text/html on exception views when\n  the response has content.\n  (`#1089 <https://github.com/zopefoundation/Zope/issues/1089>`_)\n\n- Drop support for Python 3.6, it has been in end-of-life status for a while.\n\n- Update to newest compatible versions of dependencies.\n\n- Fix history page for classes modifying instances in ``__setstate__``,\n  such as ``Products.PythonScripts.PythonScript`` instances.\n  See `launchpad issue 735999\n  <https://bugs.launchpad.net/zope2/+bug/735999>`_.\n\n\n5.7.3 (2022-12-19)\n------------------\n\n- Explicitly serve ``App.Dialogs.MessageDialog`` and exception views as HTML\n  due to the changed default content type from `#1075\n  <https://github.com/zopefoundation/Zope/pull/1075>`_.\n\n\n5.7.2 (2022-12-17)\n------------------\n\n- Fix some broken ZMI pages due to the changed default content type\n  from PR https://github.com/zopefoundation/Zope/pull/1075\n  (`#1078 <https://github.com/zopefoundation/Zope/issues/1078>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.7.1 (2022-12-16)\n------------------\n\n- Set the published default ``Content-Type`` header to ``text/plain``\n  if none has been set explicitly to prevent a cross-site scripting attack.\n  Also remove the old behavior of constructing an HTML page for published\n  methods returning a two-item tuple.\n\n- Update to newest compatible versions of dependencies.\n\n\n5.7 (2022-11-17)\n----------------\n\n- Script `addzopeuser` accepts now parameter '-c' or '--configuration'.\n  This allows passing in a custom location for the `zope.conf` file to use.\n  If not specified, behavior is not altered.\n\n- Update to newest compatible versions of dependencies.\n\n- Change functional testing utilities to support percent encoded and unicode\n  paths (`#1058 <https://github.com/zopefoundation/Zope/issues/1058>`_).\n\n- Decode basic authentication header as utf-8, not latin1 anymore\n  (`#1061 <https://github.com/zopefoundation/Zope/issues/1061>`_).\n\n- Use UTF-8 charset for WWW-Authenticate headers in challenge responses,\n  as described in `RFC7617 <https://datatracker.ietf.org/doc/html/draft-ietf-httpauth-basicauth-update-07#section-2.1>`_\n  ( `#1065 <https://github.com/zopefoundation/Zope/pull/1065>`_).\n\n- Added `:json` converter in `ZPublisher.Converters`.\n  (`#957 <https://github.com/zopefoundation/Zope/issues/957>`_)\n\n- Support Python 3.11.\n\n\n5.6 (2022-09-09)\n----------------\n\n- Make Products.PageTemplate engine compatible with Chameleon 3.10.\n\n- Update to newest compatible versions of dependencies.\n\n- Start work on Python 3.11 support, which will arrive in a later release.\n\n- Fix cookie path parameter handling:\n  If the cookie path value contains ``%`` it is assumed to be\n  fully quoted and used as is;\n  if it contains only characters allowed (unquoted)\n  in an URL path (with the exception of ``;``),\n  it is used as is; otherwise, it is quoted using Python's\n  ``urllib.parse.quote``\n  (`#1052 <https://github.com/zopefoundation/Zope/issues/1052>`_).\n\n\n5.5.2 (2022-06-28)\n------------------\n\n- Update ``waitress`` to version 2.1.2.\n\n- Improvements on find_bad_templates(): check Filesystem Page\n  Templates too and show html tags in web report\n  (`#1042 <https://github.com/zopefoundation/Zope/issues/1042>`_)\n\n- Fix version pin specifications for Python 3.6 compatibility.\n  (`#1036 <https://github.com/zopefoundation/Zope/issues/1036>`_)\n\n- Quote all components of a redirect URL (not only the path component)\n  (`#1027 <https://github.com/zopefoundation/Zope/issues/1027>`_)\n\n- Drop the convenience script generation from the buildout configuration\n  in order to get rid of a lot of dependency version pins.\n  These were only needed for maintainers who can install them manually.\n  (`#1019 <https://github.com/zopefoundation/Zope/issues/1019>`_)\n\n- Update to newest compatible versions of dependencies.\n\n- Modify \"manage_access\" to allow users to switch from the compact view\n  to the complete matrix view when more than 30 roles are defined.\n  (`#1039 <https://github.com/zopefoundation/Zope/pull/1039>`_)\n\n- Strip leading ``.`` in cookie domain names.\n  (`#1041 <https://github.com/zopefoundation/Zope/pull/1041>`_)\n\n\n5.5.1 (2022-04-05)\n------------------\n\n- Update to newest compatible versions of dependencies.\n\n- Update ``waitress`` to version 2.1.1 to mitigate a vulnerability in that\n  package. As ``waitress`` no longer supports Python 3.6 it is not advised\n  to run Zope on Python 3.6 any longer even though it still supports Python\n  3.6. **Due to this security issue support for Python 3.6 is now officially\n  deprecated. It will be removed with Zope version 5.7.**\n\n- To run ``bin/buildout`` inside the Zope project now ``zc.buildout >= 2.13.7``\n  or ``zc.buildout >= 3.0.0b1`` is required.\n\n\n5.5 (2022-03-10)\n----------------\n\n- Fix several exceptions when calling ``ZPublisher.utils.fix_properties``.\n\n- Update to newest compatible versions of dependencies.\n\n- Enhance cookie support. For details, see\n  `#1010 <https://github.com/zopefoundation/Zope/issues/1010>`_\n\n- Use intermediate ``str`` representation for non-bytelike response data unless\n  indicated differently by the content type.\n  (`#1006 <https://github.com/zopefoundation/Zope/issues/1006>`_)\n\n- Use ``zc.buildout 3.0rc2`` to install Zope to run its tests.\n\n\n5.4 (2022-01-09)\n----------------\n\n- Audit and fix all hyperlinks in code and documentation\n\n  - Change zope.org references to zope.dev due to ongoing domain ownership\n    issues. zope.dev is owned by the Plone Foundation and thus safe from\n    interference. XML/ZCML namespace URLs remain unchanged.\n  - Remove all links that are completely dead, such as the old zope.org\n    Collectors issue trackers.\n  - Update all other miscellaneous links to make them work again or remove if\n    the information is gone.\n\n- Improve type guessing for the default WebDAV PUT factory\n  (`#997 <https://github.com/zopefoundation/Zope/issues/997>`_)\n\n- Enable WebDAV PUT factories to change a newly created object's ID\n  (`#997 <https://github.com/zopefoundation/Zope/issues/997>`_)\n\n- Fix potential race condition in ``App.version_txt.getZopeVersion``\n  (`#999 <https://github.com/zopefoundation/Zope/issues/999>`_)\n\n- Don't coerce file upload fields for adding DTML Documents/Methods to string.\n  This makes the Add forms work again with the ZPublisher converter code\n  changes.\n\n- Remove deprecated ulines, utext, utokens, ustring from more code.\n  In the properties form, show a deprecation warning.\n\n- Add function ``ZPublisher.utils.fix_properties``.\n  You can call this to fix lines properties to only contain strings, not bytes.\n  It also replaces the deprecated property types ulines, utext, utoken, and\n  ustring with their non-unicode variants.\n  (`#987 <https://github.com/zopefoundation/Zope/issues/987>`_)\n\n- Add support for Python 3.10.\n\n- Update to newest compatible versions of dependencies.\n\n\n5.3 (2021-07-31)\n----------------\n\n- Reinstate simple sessioning with ``Products.TemporaryFolder``\n  because the underlying issues with ``tempstorage`` have been fixed.\n  (`#985 <https://github.com/zopefoundation/Zope/issues/985>`_)\n\n- Update the ``AccessControl`` version pin to fix a remote code execution issue\n  (see `AccessControl security advisory GHSA-qcx9-j53g-ccgf\n  <https://github.com/zopefoundation/AccessControl/security/advisories/GHSA-qcx9-j53g-ccgf>`_)\n\n- Prevent ``DeprecationWarnings`` from moved imports in ``AccessControl``\n\n- make sure \"Manager\" users can always modify proxy roles\n  (`see Products.PythonScripts#50\n  <https://github.com/zopefoundation/Products.PythonScripts/issues/50>`_)\n\n- Deprecate usage of \"unicode\" converters. Also, the behavior of\n  ``field2lines`` is now aligned to the other converters and returns a list of\n  strings instead of a list of bytes.\n  (`#962 <https://github.com/zopefoundation/Zope/issues/962>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.2.1 (2021-06-08)\n------------------\n\n- Prevent unauthorized traversal through authorized Python modules in\n  TAL expressions\n\n- Facelift the Zope logo.\n  (`#973 <https://github.com/zopefoundation/Zope/issues/973>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.2 (2021-05-21)\n----------------\n\n- Prevent traversal to names starting with ``_`` in TAL expressions\n  and fix path expressions for the ``chameleon.tales`` expression engine.\n\n- Provide friendlier ZMI error message for the Transaction Undo form\n  (`#964 <https://github.com/zopefoundation/Zope/issues/964>`_)\n\n- Updated/fixed the poll application tutorial in the Zope Developers Guide\n  (`#958 <https://github.com/zopefoundation/Zope/issues/958>`_)\n\n- Update to newest versions of dependencies.\n\n- Depend on ``zope.datetime`` for the functions ``iso8601_date``,\n  ``rfc850_date``, and ``rfc1123_date`` which used to be in ``App.Common``\n  keeping backwards-compatibility imports in place.\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- With the exception of ``field2bytes``, field converters do no longer try to\n  read file like objects\n  (`#558 <https://github.com/zopefoundation/Zope/issues/558>`_)\n\n\n5.1.2 (2021-03-02)\n------------------\n\n- Enforce Zope permissions during recursive XML-RPC data dumps\n  (`#954 <https://github.com/zopefoundation/Zope/issues/954>`_)\n\n- The ``compute_size`` method properly returns None if the content does not\n  have a ``get_size`` method but the parent has.\n  (`#948 <https://github.com/zopefoundation/Zope/issues/948>`_)\n\n- Fix control panel tab links on all control panel pages\n\n- Update to newest versions of dependencies.\n\n\n5.1.1 (2021-02-10)\n------------------\n\n- Replace (in ``OFS``) the deprecated direct ``id`` access by\n  ``getId`` calls.\n  (`#903 <https://github.com/zopefoundation/Zope/issues/903>`_)\n\n- Update ZMI dependencies for Font Awesome, jQuery and bootstrap.\n\n- Revise debug info GUI\n  (`#937 <https://github.com/zopefoundation/Zope/pull/937>`_)\n\n- Convert ``bytes`` ``HTTPResponse`` header value to ``str``\n  via ``ISO-8859-1`` (the default encoding of ``HTTP/1.1``).\n\n- Fix rendering of not found resources.\n  (`#933 <https://github.com/zopefoundation/Zope/pull/933>`_)\n\n- Update to newest versions of dependencies.\n\n\n5.1 (2020-11-12)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Exclude characters special for ``chameleon``'s interpolation syntax\n  (i.e. ``${}``) from use in TALES path expressions to reduce the failure risk\n  for the ``chameleon`` interpolation heuristics\n  (`#925 <https://github.com/zopefoundation/Zope/issues/925>`_)\n\nFeatures\n++++++++\n\n- Restore the ZMI `Debug Information` control panel page\n  (`#898 <https://github.com/zopefoundation/Zope/issues/898>`_)\n\nFixes\n+++++\n\n- Fix ZMI visibility of pre elements in error log\n  (`Products.SiteErrorLog#26\n  <https://github.com/zopefoundation/Products.SiteErrorLog/issues/26>`_)\n\n- Fix ``length`` for page template repeat variables\n  (`#913 <https://github.com/zopefoundation/Zope/issues/913>`_)\n\n- Update `isort` to version 5.\n  (`#892 <https://github.com/zopefoundation/Zope/pull/892>`_)\n\n- Update to newest versions of dependencies.\n\n\n5.0 (2020-10-08)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 3.5 as it will run out of support soon.\n  (`#841 <https://github.com/zopefoundation/Zope/issues/841>`_)\n\n\nFeatures\n++++++++\n\n- HTTP header encoding support\n  (`#905 <https://github.com/zopefoundation/Zope/pull/905>`_)\n\n- Add support for Python 3.9.\n\n- New interface ``Products.PageTemplates.interfaces.IZopeAwareEngine``.\n  It can be used as the \"provides\" of an adapter registration\n  to adapt a non ``Zope`` tales engine to an engine to be used\n  by ``Zope`` page templates\n  (`#864 <https://github.com/zopefoundation/Zope/issues/864>`_).\n  Currently, the adaptation is used only when the\n  template is rendered with ``chameleon``;\n  with ``zope.pagetemplate``, the engine is used\n  as is - this may change in the future.\n\n- Allow (some) builtins as first element of a (TALES) path expression:\n  in an untrusted context, the builtins from\n  ``AccessControl.safe_builtins`` are allowed;\n  in a trusted context, all Python builtins are allowed in addition\n  (and take precedence)\n  (`zope.tales#23 <https://github.com/zopefoundation/zope.tales/issues/23>`_).\n\n- Support the ``attrs`` predefined template variable again (as\n  far as ``chameleon`` allows it)\n  (`#860 <https://github.com/zopefoundation/Zope/issues/860>`_).\n\n- Use ``Chameleon`` (>= 3.7.2) configuration to get better\n  information for errors detected during template execution\n  (`#837 <https://github.com/zopefoundation/Zope/issues/837>`_).\n\nFixes\n+++++\n\n- Provide a more senseful ``OFS.SimpleItem.Item_w__name__.id``\n  to avoid bugs by use of deprecated direct ``id`` access\n  (as e.g. (`#903 <https://github.com/zopefoundation/Zope/issues/903>`_).\n\n- Update to ``zope.interface > 5.1.0`` to fix a memory leak.\n\n- Fix export of files with non-latin-1 compatible names\n  (`#890 <https://github.com/zopefoundation/Zope/issues/890>`_)\n\n- Avoid unsolicited translations\n  (`#876 <https://github.com/zopefoundation/Zope/issues/876>`_)\n\n- Make \"chameleon-zope context wrapping\" more faithful.\n  (`#873 <https://github.com/zopefoundation/Zope/pull/873/files>`_)\n\n- Let \"unicode conflict resolution\" work for all templates (not just\n  ``ZopePageTemplate``).\n  (`#872 <https://github.com/zopefoundation/Zope/pull/872/files>`_)\n\n- Make \"Unicode Conflict Resolution\" available for templates\n  rendered with ``chameleon``\n  (`Products.CMFPlone#3145\n  <https://github.com/plone/Products.CMFPlone/issues/3145>`_).\n\n- Improve documentation of ``CONTEXTS`` in the \"Zope Book\".\n\n- Decrease cookie size for copy/paste clipboard cookie\n  (`#854 <https://github.com/zopefoundation/Zope/issues/854>`_)\n\n- Fix ``default`` keyword handling in page templates\n  (`#846 <https://github.com/zopefoundation/Zope/issues/846>`_)\n\n- Fix parsing of package version and show correct major version in the ZMI\n\n- Improve solidity of the ``debugError`` method.\n  (`#829 <https://github.com/zopefoundation/Zope/issues/829>`_)\n\n- Fix that ``ZTUtils.LazyFilter`` could not be imported inside a restricted\n  Python script.\n  (`#901 <https://github.com/zopefoundation/Zope/pull/901>`_)\n\nOther changes\n+++++++++++++\n\n- Add ``pyupgrade`` via ``pre-commit``\n  (`#859 <https://github.com/zopefoundation/Zope/issues/859>`_)\n\n- Add ``tal:switch`` test\n\n\n5.0a2 (2020-04-24)\n------------------\n\nBug fixes\n+++++++++\n\n- Pin ``AccessControl`` 4.2 for the `Manage WebDAV Locks` permission\n\n- Fix ``HEAD`` requests on registered views\n  (`#816 <https://github.com/zopefoundation/Zope/issues/816>`_)\n\n- Improve ``chameleon`` --> ``zope.tales`` context wrapper\n  (support for template variable injection)\n  (`#812 <https://github.com/zopefoundation/Zope/pull/812>`_).\n\n- Require ``zope.tales>=5.0.2``\n\n- Fix issue 717 by fully honoring the engine returned by\n  ``PageTemplate.pt_getEngine``\n  (`#717 <https://github.com/zopefoundation/Zope/issues/717>`_).\n  The engine also decides about the use of ``zope.tales``\n  (engine is an instance of ``zope.pagetemplate.engine.ZopeBaseEngine``)\n  or ``chameleon.tales`` (otherwise) TALES expressions.\n\n- Fixed encoding issue of `displayname` WebDAV property\n  (`#797 <https://github.com/zopefoundation/Zope/issues/797>`_)\n\n- Fixed fallback implementation of ``manage_DAVget``\n  (`#799 <https://github.com/zopefoundation/Zope/issues/799>`_)\n\nOther changes\n+++++++++++++\n\n- Update to newest versions of dependencies.\n\n\n5.0a1 (2020-02-28)\n------------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 2.7 aka Zope 5 cannot be run on Python 2 any more.\n  If you are still running on Python 2.7 upgrade to the latest Zope 4 version\n  first, migrate to Python 3 and than switch to Zope 5.\n  (`#692 <https://github.com/zopefoundation/Zope/issues/692>`_)\n\n- Remove all backwards-compatibility code marked to go away in Zope 5\n  (`#478 <https://github.com/zopefoundation/Zope/issues/478>`_)\n\n- Drop support for running Zope with ZServer as it is Python 2 only.\n  (`#592 <https://github.com/zopefoundation/Zope/issues/592>`_)\n\n- Remove deprecated ``postProcessInputs`` request method.\n  (`#782 <https://github.com/zopefoundation/Zope/issues/782>`_)\n\n- Remove deprecated module ``ZPublisher.maybe_lock``.\n  (`#758 <https://github.com/zopefoundation/Zope/issues/758>`_)\n\n- Remove Help System methods from the product context.\n  (`#756 <https://github.com/zopefoundation/Zope/issues/756>`_)\n\n- Remove more deprecated code.\n  (`#757 <https://github.com/zopefoundation/Zope/issues/757>`_)\n\n- Updated Zope documentation sources for Zope 5.\n  (`#659 <https://github.com/zopefoundation/Zope/issues/659>`_)\n\nNew features\n++++++++++++\n\n- Restore WebDAV support in Zope.\n  (`#744 <https://github.com/zopefoundation/Zope/issues/744>`_)\n\n- Enable WebDAV support independent of ``ZServer``.\n  (`#787 <https://github.com/zopefoundation/Zope/pull/787>`_)\n\n- Clean up and sanitize permissions used for WebDAV-related methods.\n\n- Add ``wsgi.file_wrapper`` implementation\n  https://www.python.org/dev/peps/pep-0333/#optional-platform-specific-file-handling\n  (`#719 <https://github.com/zopefoundation/Zope/pull/719>`_)\n\nBug fixes\n+++++++++\n\n- Only use ``wsgi.file_wrapper`` for response bodies with a ``read`` method.\n  (`#763 <https://github.com/zopefoundation/Zope/issues/763>`_)\n\n- Improve detection of HTTPS requests.\n  (`#680 <https://github.com/zopefoundation/Zope/issues/680>`_)\n\n- Fix several ZMI links so they respect virtual hosting.\n  (`#788 <https://github.com/zopefoundation/Zope/issues/788>`_)\n\n- Fix sort link URLs on ``manage_main``\n  (`#748 <https://github.com/zopefoundation/Zope/issues/748>`_)\n\n- More tests to make sure all ``__str__`` implementations return native\n  strings.\n  (`#692 <https://github.com/zopefoundation/Zope/issues/692>`_)\n\n- Fix longstanding test bug by forcing the page template engine.\n  Many tests in ``Products.PageTemplates`` used the old Zope page template\n  engine because the correct one was not registered during setup.\n\n- Close opened db during shutdown (as ZServer is already doing).\n  (`#740 <https://github.com/zopefoundation/Zope/issues/740>`_)\n\n- The method ``unrestrictedTraverse`` raises an error when\n  the argument ``path`` is not something it can work with.\n  (`#674 <https://github.com/zopefoundation/Zope/issues/674>`_)\n\n- Improve ZMI Security Tab usability for high numbers of roles.\n  (`#730 <https://github.com/zopefoundation/Zope/issues/730>`_)\n\n- Some small ZMI rendering fixes.\n  (`#729 <https://github.com/zopefoundation/Zope/issues/729>`_)\n\n- Fix error when using database minimize in the ZMI.\n  (`#726 <https://github.com/zopefoundation/Zope/issues/726>`_)\n\n- Fix ``__getattr__`` signature in ``UnauthorizedBinding``.\n  (`#703 <https://github.com/zopefoundation/Zope/issues/703>`_)\n\n- Fix VirtualHostMonster not being able to set mappings under Python 3.\n  (`#708 <https://github.com/zopefoundation/Zope/issues/708>`_)\n\n- Reduce the danger of acquiring built-in names on the ZMI Find tab.\n  (`#712 <https://github.com/zopefoundation/Zope/issues/712>`_)\n\n- Restore the mistakenly removed Properties ZMI tab on Image objects\n  (`#706 <https://github.com/zopefoundation/Zope/issues/706>`_)\n\n- Fix ``OFS.Image.File.__str__`` for ``Pdata`` contents\n  (`#711 <https://github.com/zopefoundation/Zope/issues/711>`_)\n\n- Set ``REMOTE_USER`` in wsgi environ using Zope user authentication\n  (`#713 <https://github.com/zopefoundation/Zope/pull/713>`_)\n\n- Add ``Paste`` as ``extras_require`` dependency to pull in ``Paste`` when\n  installing with `pip` and `constraints.txt` to prevent startup errors.\n  This requires adding the ``[wsgi]`` extra in the egg specification.\n  (`#734 <https://github.com/zopefoundation/Zope/issues/734>`_)\n\nOther changes\n+++++++++++++\n\n- Move retried request delay handling out of ``supports_retry``\n  (`#474 <https://github.com/zopefoundation/Zope/issues/474>`_)\n\n- Improve documentation for Zope's error logging services.\n", "code_before": "Change log\n==========\n\nThese are all the changes for Zope 5, starting with the alpha releases,\nsince the branch point at Zope 4.1.2.\n\nThe change log for the previous version, Zope 4, is at\nhttps://github.com/zopefoundation/Zope/blob/4.x/CHANGES.rst\n\n\n5.8.5 (unreleased)\n------------------\n\n- Tighten down the ZMI frame source logic to only allow site-local sources.\n  Problem reported by Miguel Segovia Gil.\n\n- Update to newest compatible versions of dependencies.\n\n- Added image dimensions to SVG file properties\n  `#1146 <https://github.com/zopefoundation/Zope/pull/1146>`_.\n\n- Fix username not in access log for error requests, see issue\n  `#1155 <https://github.com/zopefoundation/Zope/issues/1155>`_.\n\n- Add preliminary support for Python 3.12rc3.\n\n5.8.4 (2023-09-06)\n------------------\n\n- Disable a ``ZCatalog`` (more precisly: ``Products.PluginIndexes``)\n  performance test which occasionally fails on GitHub.\n  For details, see\n  `#1136 <https://github.com/zopefoundation/Zope/issues/1136>`_.\n\n- Restore filename on code objects of objects returned from\n  ``App.Extensions.getObject()``. This got lost in 4.0a6.\n\n- Update to newest compatible versions of dependencies.\n\n- Add preliminary support for Python 3.12rc1.\n\n- Make ``mapply`` ``__signature__`` aware.\n  This allows to publish methods decorated via a decorator\n  which sets ``__signature__`` on the wrapper to specify\n  the signature to use.\n  For details, see\n  `#1134 <https://github.com/zopefoundation/Zope/issues/1134>`_.\n  Note: ``mapply`` still does not support keyword only, var positional\n  and var keyword parameters.\n\n- Make Zope's parameters for denial of service protection configurable\n  `#1141 <https://github.com/zopefoundation/Zope/issues/1141>`_.\n\n- Update ``RestrictedPython`` to version 6.2 to mitigate a security problem.\n  (CVE-2023-41039)\n\n- Update ``AccessControl`` to version 6.2 to mitigate a security problem.\n  (CVE-2023-41050)\n\n\n5.8.3 (2023-06-15)\n------------------\n\n- Fix handling of a request parameter of type ``file`` if no value\n  has been specified;\n  fixes `#1132 <https://github.com/zopefoundation/Zope/issues/1132>`_.\n\n- Fix adding Page Templates without valid file input from the ZMI\n  (`#1130 <https://github.com/zopefoundation/Zope/issues/1130>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.8.2 (2023-05-22)\n------------------\n\n- Allow ``ZPublisher`` to handle both a query string and a request body;\n  the request parameters from the query string are made available\n  in the request attribute ``form`` (a ``dict``),\n  the request body can be accessed via the request keys ``BODY``\n  (a ``bytes`` object) or ``BODYFILE`` (a file like object).\n  Fixes `#1122 <https://github.com/zopefoundation/Zope/issues/1122>`_.\n\n- Support access to the request's ``BODY`` key for WSGI servers\n  which hand over an unseekable request body (such as e.g.\n  ``Gunicorn``).\n  Fixes `#1125 <https://github.com/zopefoundation/Zope/issues/1125>`_.\n\n- Do not break on GET requests that pass a query string\n  and a `Content-Type` header.\n  For details see `#1117 <https://github.com/zopefoundation/Zope/pull/1117>`_.\n\n- Implement code change suggestions from CodeQL scanning.\n\n- Added Japanese translations for some Sphinx docs\n  (`#1109 <https://github.com/zopefoundation/Zope/issues/1109>`_)\n\n- Update to newest compatible versions of dependencies.\n\n- Update zope.ini.in skel to support log paths that use backslashes.\n  (`#1106 <https://github.com/zopefoundation/Zope/issues/1106>`_)\n\n\n5.8.1 (2023-03-17)\n------------------\n\n- Sanitize tainting fixing\n  `#1095 <https://github.com/zopefoundation/Zope/issues/1095>`_\n\n- Replace ``cgi.FieldStorage`` by ``multipart`` avoiding\n  the ``cgi`` module deprecated by Python 3.11.\n\n  Mark binary converters with a true ``binary`` attribute.\n\n  Fix encoding handling and ``:bytes`` converter.\n\n  See `#1094 <https://github.com/zopefoundation/Zope/pull/1094>`_.\n\n- Clean out and refactor dependency configuration files.\n\n- Update to newest compatible versions of dependencies.\n\n- Support the (non standard) ``charset`` parameter for\n  content type ``application/x-www-form-urlencoded``.\n  This is required (e.g. for ``Plone``) because\n  ``jquery`` constructs content types of the form\n  ```application/x-www-form-urlencoded; charset=utf-8``.\n  For details see\n  `plone/buildout.coredev#844\n  <https://github.com/plone/buildout.coredev/pull/844>`_.\n\n\n5.8 (2023-01-10)\n----------------\n\n- Only set response header Content-Type as text/html on exception views when\n  the response has content.\n  (`#1089 <https://github.com/zopefoundation/Zope/issues/1089>`_)\n\n- Drop support for Python 3.6, it has been in end-of-life status for a while.\n\n- Update to newest compatible versions of dependencies.\n\n- Fix history page for classes modifying instances in ``__setstate__``,\n  such as ``Products.PythonScripts.PythonScript`` instances.\n  See `launchpad issue 735999\n  <https://bugs.launchpad.net/zope2/+bug/735999>`_.\n\n\n5.7.3 (2022-12-19)\n------------------\n\n- Explicitly serve ``App.Dialogs.MessageDialog`` and exception views as HTML\n  due to the changed default content type from `#1075\n  <https://github.com/zopefoundation/Zope/pull/1075>`_.\n\n\n5.7.2 (2022-12-17)\n------------------\n\n- Fix some broken ZMI pages due to the changed default content type\n  from PR https://github.com/zopefoundation/Zope/pull/1075\n  (`#1078 <https://github.com/zopefoundation/Zope/issues/1078>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.7.1 (2022-12-16)\n------------------\n\n- Set the published default ``Content-Type`` header to ``text/plain``\n  if none has been set explicitly to prevent a cross-site scripting attack.\n  Also remove the old behavior of constructing an HTML page for published\n  methods returning a two-item tuple.\n\n- Update to newest compatible versions of dependencies.\n\n\n5.7 (2022-11-17)\n----------------\n\n- Script `addzopeuser` accepts now parameter '-c' or '--configuration'.\n  This allows passing in a custom location for the `zope.conf` file to use.\n  If not specified, behavior is not altered.\n\n- Update to newest compatible versions of dependencies.\n\n- Change functional testing utilities to support percent encoded and unicode\n  paths (`#1058 <https://github.com/zopefoundation/Zope/issues/1058>`_).\n\n- Decode basic authentication header as utf-8, not latin1 anymore\n  (`#1061 <https://github.com/zopefoundation/Zope/issues/1061>`_).\n\n- Use UTF-8 charset for WWW-Authenticate headers in challenge responses,\n  as described in `RFC7617 <https://datatracker.ietf.org/doc/html/draft-ietf-httpauth-basicauth-update-07#section-2.1>`_\n  ( `#1065 <https://github.com/zopefoundation/Zope/pull/1065>`_).\n\n- Added `:json` converter in `ZPublisher.Converters`.\n  (`#957 <https://github.com/zopefoundation/Zope/issues/957>`_)\n\n- Support Python 3.11.\n\n\n5.6 (2022-09-09)\n----------------\n\n- Make Products.PageTemplate engine compatible with Chameleon 3.10.\n\n- Update to newest compatible versions of dependencies.\n\n- Start work on Python 3.11 support, which will arrive in a later release.\n\n- Fix cookie path parameter handling:\n  If the cookie path value contains ``%`` it is assumed to be\n  fully quoted and used as is;\n  if it contains only characters allowed (unquoted)\n  in an URL path (with the exception of ``;``),\n  it is used as is; otherwise, it is quoted using Python's\n  ``urllib.parse.quote``\n  (`#1052 <https://github.com/zopefoundation/Zope/issues/1052>`_).\n\n\n5.5.2 (2022-06-28)\n------------------\n\n- Update ``waitress`` to version 2.1.2.\n\n- Improvements on find_bad_templates(): check Filesystem Page\n  Templates too and show html tags in web report\n  (`#1042 <https://github.com/zopefoundation/Zope/issues/1042>`_)\n\n- Fix version pin specifications for Python 3.6 compatibility.\n  (`#1036 <https://github.com/zopefoundation/Zope/issues/1036>`_)\n\n- Quote all components of a redirect URL (not only the path component)\n  (`#1027 <https://github.com/zopefoundation/Zope/issues/1027>`_)\n\n- Drop the convenience script generation from the buildout configuration\n  in order to get rid of a lot of dependency version pins.\n  These were only needed for maintainers who can install them manually.\n  (`#1019 <https://github.com/zopefoundation/Zope/issues/1019>`_)\n\n- Update to newest compatible versions of dependencies.\n\n- Modify \"manage_access\" to allow users to switch from the compact view\n  to the complete matrix view when more than 30 roles are defined.\n  (`#1039 <https://github.com/zopefoundation/Zope/pull/1039>`_)\n\n- Strip leading ``.`` in cookie domain names.\n  (`#1041 <https://github.com/zopefoundation/Zope/pull/1041>`_)\n\n\n5.5.1 (2022-04-05)\n------------------\n\n- Update to newest compatible versions of dependencies.\n\n- Update ``waitress`` to version 2.1.1 to mitigate a vulnerability in that\n  package. As ``waitress`` no longer supports Python 3.6 it is not advised\n  to run Zope on Python 3.6 any longer even though it still supports Python\n  3.6. **Due to this security issue support for Python 3.6 is now officially\n  deprecated. It will be removed with Zope version 5.7.**\n\n- To run ``bin/buildout`` inside the Zope project now ``zc.buildout >= 2.13.7``\n  or ``zc.buildout >= 3.0.0b1`` is required.\n\n\n5.5 (2022-03-10)\n----------------\n\n- Fix several exceptions when calling ``ZPublisher.utils.fix_properties``.\n\n- Update to newest compatible versions of dependencies.\n\n- Enhance cookie support. For details, see\n  `#1010 <https://github.com/zopefoundation/Zope/issues/1010>`_\n\n- Use intermediate ``str`` representation for non-bytelike response data unless\n  indicated differently by the content type.\n  (`#1006 <https://github.com/zopefoundation/Zope/issues/1006>`_)\n\n- Use ``zc.buildout 3.0rc2`` to install Zope to run its tests.\n\n\n5.4 (2022-01-09)\n----------------\n\n- Audit and fix all hyperlinks in code and documentation\n\n  - Change zope.org references to zope.dev due to ongoing domain ownership\n    issues. zope.dev is owned by the Plone Foundation and thus safe from\n    interference. XML/ZCML namespace URLs remain unchanged.\n  - Remove all links that are completely dead, such as the old zope.org\n    Collectors issue trackers.\n  - Update all other miscellaneous links to make them work again or remove if\n    the information is gone.\n\n- Improve type guessing for the default WebDAV PUT factory\n  (`#997 <https://github.com/zopefoundation/Zope/issues/997>`_)\n\n- Enable WebDAV PUT factories to change a newly created object's ID\n  (`#997 <https://github.com/zopefoundation/Zope/issues/997>`_)\n\n- Fix potential race condition in ``App.version_txt.getZopeVersion``\n  (`#999 <https://github.com/zopefoundation/Zope/issues/999>`_)\n\n- Don't coerce file upload fields for adding DTML Documents/Methods to string.\n  This makes the Add forms work again with the ZPublisher converter code\n  changes.\n\n- Remove deprecated ulines, utext, utokens, ustring from more code.\n  In the properties form, show a deprecation warning.\n\n- Add function ``ZPublisher.utils.fix_properties``.\n  You can call this to fix lines properties to only contain strings, not bytes.\n  It also replaces the deprecated property types ulines, utext, utoken, and\n  ustring with their non-unicode variants.\n  (`#987 <https://github.com/zopefoundation/Zope/issues/987>`_)\n\n- Add support for Python 3.10.\n\n- Update to newest compatible versions of dependencies.\n\n\n5.3 (2021-07-31)\n----------------\n\n- Reinstate simple sessioning with ``Products.TemporaryFolder``\n  because the underlying issues with ``tempstorage`` have been fixed.\n  (`#985 <https://github.com/zopefoundation/Zope/issues/985>`_)\n\n- Update the ``AccessControl`` version pin to fix a remote code execution issue\n  (see `AccessControl security advisory GHSA-qcx9-j53g-ccgf\n  <https://github.com/zopefoundation/AccessControl/security/advisories/GHSA-qcx9-j53g-ccgf>`_)\n\n- Prevent ``DeprecationWarnings`` from moved imports in ``AccessControl``\n\n- make sure \"Manager\" users can always modify proxy roles\n  (`see Products.PythonScripts#50\n  <https://github.com/zopefoundation/Products.PythonScripts/issues/50>`_)\n\n- Deprecate usage of \"unicode\" converters. Also, the behavior of\n  ``field2lines`` is now aligned to the other converters and returns a list of\n  strings instead of a list of bytes.\n  (`#962 <https://github.com/zopefoundation/Zope/issues/962>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.2.1 (2021-06-08)\n------------------\n\n- Prevent unauthorized traversal through authorized Python modules in\n  TAL expressions\n\n- Facelift the Zope logo.\n  (`#973 <https://github.com/zopefoundation/Zope/issues/973>`_)\n\n- Update to newest compatible versions of dependencies.\n\n\n5.2 (2021-05-21)\n----------------\n\n- Prevent traversal to names starting with ``_`` in TAL expressions\n  and fix path expressions for the ``chameleon.tales`` expression engine.\n\n- Provide friendlier ZMI error message for the Transaction Undo form\n  (`#964 <https://github.com/zopefoundation/Zope/issues/964>`_)\n\n- Updated/fixed the poll application tutorial in the Zope Developers Guide\n  (`#958 <https://github.com/zopefoundation/Zope/issues/958>`_)\n\n- Update to newest versions of dependencies.\n\n- Depend on ``zope.datetime`` for the functions ``iso8601_date``,\n  ``rfc850_date``, and ``rfc1123_date`` which used to be in ``App.Common``\n  keeping backwards-compatibility imports in place.\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- With the exception of ``field2bytes``, field converters do no longer try to\n  read file like objects\n  (`#558 <https://github.com/zopefoundation/Zope/issues/558>`_)\n\n\n5.1.2 (2021-03-02)\n------------------\n\n- Enforce Zope permissions during recursive XML-RPC data dumps\n  (`#954 <https://github.com/zopefoundation/Zope/issues/954>`_)\n\n- The ``compute_size`` method properly returns None if the content does not\n  have a ``get_size`` method but the parent has.\n  (`#948 <https://github.com/zopefoundation/Zope/issues/948>`_)\n\n- Fix control panel tab links on all control panel pages\n\n- Update to newest versions of dependencies.\n\n\n5.1.1 (2021-02-10)\n------------------\n\n- Replace (in ``OFS``) the deprecated direct ``id`` access by\n  ``getId`` calls.\n  (`#903 <https://github.com/zopefoundation/Zope/issues/903>`_)\n\n- Update ZMI dependencies for Font Awesome, jQuery and bootstrap.\n\n- Revise debug info GUI\n  (`#937 <https://github.com/zopefoundation/Zope/pull/937>`_)\n\n- Convert ``bytes`` ``HTTPResponse`` header value to ``str``\n  via ``ISO-8859-1`` (the default encoding of ``HTTP/1.1``).\n\n- Fix rendering of not found resources.\n  (`#933 <https://github.com/zopefoundation/Zope/pull/933>`_)\n\n- Update to newest versions of dependencies.\n\n\n5.1 (2020-11-12)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Exclude characters special for ``chameleon``'s interpolation syntax\n  (i.e. ``${}``) from use in TALES path expressions to reduce the failure risk\n  for the ``chameleon`` interpolation heuristics\n  (`#925 <https://github.com/zopefoundation/Zope/issues/925>`_)\n\nFeatures\n++++++++\n\n- Restore the ZMI `Debug Information` control panel page\n  (`#898 <https://github.com/zopefoundation/Zope/issues/898>`_)\n\nFixes\n+++++\n\n- Fix ZMI visibility of pre elements in error log\n  (`Products.SiteErrorLog#26\n  <https://github.com/zopefoundation/Products.SiteErrorLog/issues/26>`_)\n\n- Fix ``length`` for page template repeat variables\n  (`#913 <https://github.com/zopefoundation/Zope/issues/913>`_)\n\n- Update `isort` to version 5.\n  (`#892 <https://github.com/zopefoundation/Zope/pull/892>`_)\n\n- Update to newest versions of dependencies.\n\n\n5.0 (2020-10-08)\n----------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 3.5 as it will run out of support soon.\n  (`#841 <https://github.com/zopefoundation/Zope/issues/841>`_)\n\n\nFeatures\n++++++++\n\n- HTTP header encoding support\n  (`#905 <https://github.com/zopefoundation/Zope/pull/905>`_)\n\n- Add support for Python 3.9.\n\n- New interface ``Products.PageTemplates.interfaces.IZopeAwareEngine``.\n  It can be used as the \"provides\" of an adapter registration\n  to adapt a non ``Zope`` tales engine to an engine to be used\n  by ``Zope`` page templates\n  (`#864 <https://github.com/zopefoundation/Zope/issues/864>`_).\n  Currently, the adaptation is used only when the\n  template is rendered with ``chameleon``;\n  with ``zope.pagetemplate``, the engine is used\n  as is - this may change in the future.\n\n- Allow (some) builtins as first element of a (TALES) path expression:\n  in an untrusted context, the builtins from\n  ``AccessControl.safe_builtins`` are allowed;\n  in a trusted context, all Python builtins are allowed in addition\n  (and take precedence)\n  (`zope.tales#23 <https://github.com/zopefoundation/zope.tales/issues/23>`_).\n\n- Support the ``attrs`` predefined template variable again (as\n  far as ``chameleon`` allows it)\n  (`#860 <https://github.com/zopefoundation/Zope/issues/860>`_).\n\n- Use ``Chameleon`` (>= 3.7.2) configuration to get better\n  information for errors detected during template execution\n  (`#837 <https://github.com/zopefoundation/Zope/issues/837>`_).\n\nFixes\n+++++\n\n- Provide a more senseful ``OFS.SimpleItem.Item_w__name__.id``\n  to avoid bugs by use of deprecated direct ``id`` access\n  (as e.g. (`#903 <https://github.com/zopefoundation/Zope/issues/903>`_).\n\n- Update to ``zope.interface > 5.1.0`` to fix a memory leak.\n\n- Fix export of files with non-latin-1 compatible names\n  (`#890 <https://github.com/zopefoundation/Zope/issues/890>`_)\n\n- Avoid unsolicited translations\n  (`#876 <https://github.com/zopefoundation/Zope/issues/876>`_)\n\n- Make \"chameleon-zope context wrapping\" more faithful.\n  (`#873 <https://github.com/zopefoundation/Zope/pull/873/files>`_)\n\n- Let \"unicode conflict resolution\" work for all templates (not just\n  ``ZopePageTemplate``).\n  (`#872 <https://github.com/zopefoundation/Zope/pull/872/files>`_)\n\n- Make \"Unicode Conflict Resolution\" available for templates\n  rendered with ``chameleon``\n  (`Products.CMFPlone#3145\n  <https://github.com/plone/Products.CMFPlone/issues/3145>`_).\n\n- Improve documentation of ``CONTEXTS`` in the \"Zope Book\".\n\n- Decrease cookie size for copy/paste clipboard cookie\n  (`#854 <https://github.com/zopefoundation/Zope/issues/854>`_)\n\n- Fix ``default`` keyword handling in page templates\n  (`#846 <https://github.com/zopefoundation/Zope/issues/846>`_)\n\n- Fix parsing of package version and show correct major version in the ZMI\n\n- Improve solidity of the ``debugError`` method.\n  (`#829 <https://github.com/zopefoundation/Zope/issues/829>`_)\n\n- Fix that ``ZTUtils.LazyFilter`` could not be imported inside a restricted\n  Python script.\n  (`#901 <https://github.com/zopefoundation/Zope/pull/901>`_)\n\nOther changes\n+++++++++++++\n\n- Add ``pyupgrade`` via ``pre-commit``\n  (`#859 <https://github.com/zopefoundation/Zope/issues/859>`_)\n\n- Add ``tal:switch`` test\n\n\n5.0a2 (2020-04-24)\n------------------\n\nBug fixes\n+++++++++\n\n- Pin ``AccessControl`` 4.2 for the `Manage WebDAV Locks` permission\n\n- Fix ``HEAD`` requests on registered views\n  (`#816 <https://github.com/zopefoundation/Zope/issues/816>`_)\n\n- Improve ``chameleon`` --> ``zope.tales`` context wrapper\n  (support for template variable injection)\n  (`#812 <https://github.com/zopefoundation/Zope/pull/812>`_).\n\n- Require ``zope.tales>=5.0.2``\n\n- Fix issue 717 by fully honoring the engine returned by\n  ``PageTemplate.pt_getEngine``\n  (`#717 <https://github.com/zopefoundation/Zope/issues/717>`_).\n  The engine also decides about the use of ``zope.tales``\n  (engine is an instance of ``zope.pagetemplate.engine.ZopeBaseEngine``)\n  or ``chameleon.tales`` (otherwise) TALES expressions.\n\n- Fixed encoding issue of `displayname` WebDAV property\n  (`#797 <https://github.com/zopefoundation/Zope/issues/797>`_)\n\n- Fixed fallback implementation of ``manage_DAVget``\n  (`#799 <https://github.com/zopefoundation/Zope/issues/799>`_)\n\nOther changes\n+++++++++++++\n\n- Update to newest versions of dependencies.\n\n\n5.0a1 (2020-02-28)\n------------------\n\nBackwards incompatible changes\n++++++++++++++++++++++++++++++\n\n- Drop support for Python 2.7 aka Zope 5 cannot be run on Python 2 any more.\n  If you are still running on Python 2.7 upgrade to the latest Zope 4 version\n  first, migrate to Python 3 and than switch to Zope 5.\n  (`#692 <https://github.com/zopefoundation/Zope/issues/692>`_)\n\n- Remove all backwards-compatibility code marked to go away in Zope 5\n  (`#478 <https://github.com/zopefoundation/Zope/issues/478>`_)\n\n- Drop support for running Zope with ZServer as it is Python 2 only.\n  (`#592 <https://github.com/zopefoundation/Zope/issues/592>`_)\n\n- Remove deprecated ``postProcessInputs`` request method.\n  (`#782 <https://github.com/zopefoundation/Zope/issues/782>`_)\n\n- Remove deprecated module ``ZPublisher.maybe_lock``.\n  (`#758 <https://github.com/zopefoundation/Zope/issues/758>`_)\n\n- Remove Help System methods from the product context.\n  (`#756 <https://github.com/zopefoundation/Zope/issues/756>`_)\n\n- Remove more deprecated code.\n  (`#757 <https://github.com/zopefoundation/Zope/issues/757>`_)\n\n- Updated Zope documentation sources for Zope 5.\n  (`#659 <https://github.com/zopefoundation/Zope/issues/659>`_)\n\nNew features\n++++++++++++\n\n- Restore WebDAV support in Zope.\n  (`#744 <https://github.com/zopefoundation/Zope/issues/744>`_)\n\n- Enable WebDAV support independent of ``ZServer``.\n  (`#787 <https://github.com/zopefoundation/Zope/pull/787>`_)\n\n- Clean up and sanitize permissions used for WebDAV-related methods.\n\n- Add ``wsgi.file_wrapper`` implementation\n  https://www.python.org/dev/peps/pep-0333/#optional-platform-specific-file-handling\n  (`#719 <https://github.com/zopefoundation/Zope/pull/719>`_)\n\nBug fixes\n+++++++++\n\n- Only use ``wsgi.file_wrapper`` for response bodies with a ``read`` method.\n  (`#763 <https://github.com/zopefoundation/Zope/issues/763>`_)\n\n- Improve detection of HTTPS requests.\n  (`#680 <https://github.com/zopefoundation/Zope/issues/680>`_)\n\n- Fix several ZMI links so they respect virtual hosting.\n  (`#788 <https://github.com/zopefoundation/Zope/issues/788>`_)\n\n- Fix sort link URLs on ``manage_main``\n  (`#748 <https://github.com/zopefoundation/Zope/issues/748>`_)\n\n- More tests to make sure all ``__str__`` implementations return native\n  strings.\n  (`#692 <https://github.com/zopefoundation/Zope/issues/692>`_)\n\n- Fix longstanding test bug by forcing the page template engine.\n  Many tests in ``Products.PageTemplates`` used the old Zope page template\n  engine because the correct one was not registered during setup.\n\n- Close opened db during shutdown (as ZServer is already doing).\n  (`#740 <https://github.com/zopefoundation/Zope/issues/740>`_)\n\n- The method ``unrestrictedTraverse`` raises an error when\n  the argument ``path`` is not something it can work with.\n  (`#674 <https://github.com/zopefoundation/Zope/issues/674>`_)\n\n- Improve ZMI Security Tab usability for high numbers of roles.\n  (`#730 <https://github.com/zopefoundation/Zope/issues/730>`_)\n\n- Some small ZMI rendering fixes.\n  (`#729 <https://github.com/zopefoundation/Zope/issues/729>`_)\n\n- Fix error when using database minimize in the ZMI.\n  (`#726 <https://github.com/zopefoundation/Zope/issues/726>`_)\n\n- Fix ``__getattr__`` signature in ``UnauthorizedBinding``.\n  (`#703 <https://github.com/zopefoundation/Zope/issues/703>`_)\n\n- Fix VirtualHostMonster not being able to set mappings under Python 3.\n  (`#708 <https://github.com/zopefoundation/Zope/issues/708>`_)\n\n- Reduce the danger of acquiring built-in names on the ZMI Find tab.\n  (`#712 <https://github.com/zopefoundation/Zope/issues/712>`_)\n\n- Restore the mistakenly removed Properties ZMI tab on Image objects\n  (`#706 <https://github.com/zopefoundation/Zope/issues/706>`_)\n\n- Fix ``OFS.Image.File.__str__`` for ``Pdata`` contents\n  (`#711 <https://github.com/zopefoundation/Zope/issues/711>`_)\n\n- Set ``REMOTE_USER`` in wsgi environ using Zope user authentication\n  (`#713 <https://github.com/zopefoundation/Zope/pull/713>`_)\n\n- Add ``Paste`` as ``extras_require`` dependency to pull in ``Paste`` when\n  installing with `pip` and `constraints.txt` to prevent startup errors.\n  This requires adding the ``[wsgi]`` extra in the egg specification.\n  (`#734 <https://github.com/zopefoundation/Zope/issues/734>`_)\n\nOther changes\n+++++++++++++\n\n- Move retried request delay handling out of ``supports_retry``\n  (`#474 <https://github.com/zopefoundation/Zope/issues/474>`_)\n\n- Improve documentation for Zope's error logging services.\n", "patch": "@@ -11,6 +11,16 @@ https://github.com/zopefoundation/Zope/blob/4.x/CHANGES.rst\n 5.8.5 (unreleased)\n ------------------\n \n+- Allow only some image types to be displayed inline. Force download for\n+  others, especially SVG images.  By default we use a list of allowed types.\n+  You can switch a to a list of denied types by setting OS environment variable\n+  ``OFS_IMAGE_USE_DENYLIST=1``.  You can override the allowed list with\n+  environment variable ``ALLOWED_INLINE_MIMETYPES`` and the disallowed list\n+  with ``DISALLOWED_INLINE_MIMETYPES``.  Separate multiple entries by either\n+  comma or space.  This change only affects direct URL access.\n+  ``<img src=\"image.svg\" />`` works the same as before. (CVE-2023-42458)\n+  See `security advisory <https://github.com/zopefoundation/Zope/security/advisories/GHSA-wm8q-9975-xh5v>`_.\n+\n - Tighten down the ZMI frame source logic to only allow site-local sources.\n   Problem reported by Miguel Segovia Gil.\n ", "file_path": "files/2023_9/161", "file_language": "rst", "file_name": "CHANGES.rst", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 1}, {"raw_url": "https://github.com/zopefoundation/Zope/raw/603b0a12881c90a072a7a65e32d47ed898ce37cb/src%2FOFS%2FImage.py", "code": "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\"\"\"Image object\n\"\"\"\n\nimport html\nimport os\nimport struct\nfrom email.generator import _make_boundary\nfrom io import BytesIO\nfrom mimetypes import guess_extension\nfrom urllib.parse import quote\nfrom xml.dom import minidom\n\nimport ZPublisher.HTTPRequest\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.Permissions import change_images_and_files  # NOQA\nfrom AccessControl.Permissions import view as View\nfrom AccessControl.Permissions import view_management_screens\nfrom AccessControl.Permissions import webdav_access\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom Acquisition import Implicit\nfrom App.special_dtml import DTMLFile\nfrom DateTime.DateTime import DateTime\nfrom OFS.Cache import Cacheable\nfrom OFS.interfaces import IWriteLock\nfrom OFS.PropertyManager import PropertyManager\nfrom OFS.role import RoleManager\nfrom OFS.SimpleItem import Item_w__name__\nfrom OFS.SimpleItem import PathReprProvider\nfrom Persistence import Persistent\nfrom zExceptions import Redirect\nfrom zExceptions import ResourceLockedError\nfrom zope.contenttype import guess_content_type\nfrom zope.datetime import rfc1123_date\nfrom zope.event import notify\nfrom zope.interface import implementer\nfrom zope.lifecycleevent import ObjectCreatedEvent\nfrom zope.lifecycleevent import ObjectModifiedEvent\nfrom ZPublisher import HTTPRangeSupport\nfrom ZPublisher.HTTPRequest import FileUpload\n\n\ndef _get_list_from_env(name, default=None):\n    \"\"\"Get list from environment variable.\n\n    Supports splitting on comma or white space.\n    Use the default as fallback only when the variable is not set.\n    So if the env variable is set to an empty string, this will ignore the\n    default and return an empty list.\n    \"\"\"\n    value = os.environ.get(name)\n    if value is None:\n        return default or []\n    value = value.strip()\n    if \",\" in value:\n        return value.split(\",\")\n    return value.split()\n\n\n# We have one list for allowed, and one for disallowed inline mimetypes.\n# This is for security purposes.\n# By default we use the allowlist.  We give integrators the option to choose\n# the denylist via an environment variable.\nALLOWED_INLINE_MIMETYPES = _get_list_from_env(\n    \"ALLOWED_INLINE_MIMETYPES\",\n    default=[\n        \"image/gif\",\n        # The mimetypes registry lists several for jpeg 2000:\n        \"image/jp2\",\n        \"image/jpeg\",\n        \"image/jpeg2000-image\",\n        \"image/jpeg2000\",\n        \"image/jpx\",\n        \"image/png\",\n        \"image/webp\",\n        \"image/x-icon\",\n        \"image/x-jpeg2000-image\",\n        \"text/plain\",\n        # By popular request we allow PDF:\n        \"application/pdf\",\n    ]\n)\nDISALLOWED_INLINE_MIMETYPES = _get_list_from_env(\n    \"DISALLOWED_INLINE_MIMETYPES\",\n    default=[\n        \"application/javascript\",\n        \"application/x-javascript\",\n        \"text/javascript\",\n        \"text/html\",\n        \"image/svg+xml\",\n        \"image/svg+xml-compressed\",\n    ]\n)\ntry:\n    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")\n    USE_DENYLIST = bool(int(USE_DENYLIST))\nexcept (ValueError, TypeError, AttributeError):\n    USE_DENYLIST = False\n\n\nmanage_addFileForm = DTMLFile(\n    'dtml/imageAdd',\n    globals(),\n    Kind='File',\n    kind='file',\n)\n\n\ndef manage_addFile(\n    self,\n    id,\n    file=b'',\n    title='',\n    precondition='',\n    content_type='',\n    REQUEST=None\n):\n    \"\"\"Add a new File object.\n\n    Creates a new File object 'id' with the contents of 'file'\"\"\"\n\n    id = str(id)\n    title = str(title)\n    content_type = str(content_type)\n    precondition = str(precondition)\n\n    id, title = cookId(id, title, file)\n\n    self = self.this()\n\n    # First, we create the file without data:\n    self._setObject(id, File(id, title, b'', content_type, precondition))\n\n    newFile = self._getOb(id)\n\n    # Now we \"upload\" the data.  By doing this in two steps, we\n    # can use a database trick to make the upload more efficient.\n    if file:\n        newFile.manage_upload(file)\n    if content_type:\n        newFile.content_type = content_type\n\n    notify(ObjectCreatedEvent(newFile))\n\n    if REQUEST is not None:\n        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')\n\n\n@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)\nclass File(\n    PathReprProvider,\n    Persistent,\n    Implicit,\n    PropertyManager,\n    RoleManager,\n    Item_w__name__,\n    Cacheable\n):\n    \"\"\"A File object is a content object for arbitrary files.\"\"\"\n    # You can control which mimetypes may be shown inline\n    # and which must always be downloaded, for security reasons.\n    # Make the configuration available on the class.\n    # Then subclasses can override this.\n    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n    use_denylist = USE_DENYLIST\n\n    meta_type = 'File'\n    zmi_icon = 'far fa-file-archive'\n\n    security = ClassSecurityInfo()\n    security.declareObjectProtected(View)\n\n    precondition = ''\n    size = None\n\n    manage_editForm = DTMLFile('dtml/fileEdit', globals(),\n                               Kind='File', kind='file')\n    manage_editForm._setName('manage_editForm')\n\n    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001\n    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501\n    manage = manage_main = manage_editForm\n    manage_uploadForm = manage_editForm\n\n    manage_options = (({'label': 'Edit', 'action': 'manage_main'},\n                       {'label': 'View', 'action': ''})\n                      + PropertyManager.manage_options\n                      + RoleManager.manage_options\n                      + Item_w__name__.manage_options\n                      + Cacheable.manage_options)\n\n    _properties = (\n        {'id': 'title', 'type': 'string'},\n        {'id': 'content_type', 'type': 'string'},\n    )\n\n    def __init__(self, id, title, file, content_type='', precondition=''):\n        self.__name__ = id\n        self.title = title\n        self.precondition = precondition\n\n        data, size = self._read_data(file)\n        content_type = self._get_content_type(file, data, id, content_type)\n        self.update_data(data, content_type, size)\n\n    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):\n        # HTTP If-Modified-Since header handling: return True if\n        # we can handle this request by returning a 304 response\n        header = REQUEST.get_header('If-Modified-Since', None)\n        if header is not None:\n            header = header.split(';')[0]\n            # Some proxies seem to send invalid date strings for this\n            # header. If the date string is not valid, we ignore it\n            # rather than raise an error to be generally consistent\n            # with common servers such as Apache (which can usually\n            # understand the screwy date string as a lucky side effect\n            # of the way they parse it).\n            # This happens to be what RFC2616 tells us to do in the face of an\n            # invalid date.\n            try:\n                mod_since = int(DateTime(header).timeTime())\n            except Exception:\n                mod_since = None\n            if mod_since is not None:\n                if self._p_mtime:\n                    last_mod = int(self._p_mtime)\n                else:\n                    last_mod = 0\n                if last_mod > 0 and last_mod <= mod_since:\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setStatus(304)\n                    return True\n\n    def _range_request_handler(self, REQUEST, RESPONSE):\n        # HTTP Range header handling: return True if we've served a range\n        # chunk out of our data.\n        range = REQUEST.get_header('Range', None)\n        request_range = REQUEST.get_header('Request-Range', None)\n        if request_range is not None:\n            # Netscape 2 through 4 and MSIE 3 implement a draft version\n            # Later on, we need to serve a different mime-type as well.\n            range = request_range\n        if_range = REQUEST.get_header('If-Range', None)\n        if range is not None:\n            ranges = HTTPRangeSupport.parseRange(range)\n\n            if if_range is not None:\n                # Only send ranges if the data isn't modified, otherwise send\n                # the whole object. Support both ETags and Last-Modified dates!\n                if len(if_range) > 1 and if_range[:2] == 'ts':\n                    # ETag:\n                    if if_range != self.http__etag():\n                        # Modified, so send a normal response. We delete\n                        # the ranges, which causes us to skip to the 200\n                        # response.\n                        ranges = None\n                else:\n                    # Date\n                    date = if_range.split(';')[0]\n                    try:\n                        mod_since = int(DateTime(date).timeTime())\n                    except Exception:\n                        mod_since = None\n                    if mod_since is not None:\n                        if self._p_mtime:\n                            last_mod = int(self._p_mtime)\n                        else:\n                            last_mod = 0\n                        if last_mod > mod_since:\n                            # Modified, so send a normal response. We delete\n                            # the ranges, which causes us to skip to the 200\n                            # response.\n                            ranges = None\n\n            if ranges:\n                # Search for satisfiable ranges.\n                satisfiable = 0\n                for start, end in ranges:\n                    if start < self.size:\n                        satisfiable = 1\n                        break\n\n                if not satisfiable:\n                    RESPONSE.setHeader(\n                        'Content-Range', 'bytes */%d' % self.size\n                    )\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Content-Length', self.size)\n                    RESPONSE.setStatus(416)\n                    return True\n\n                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)\n\n                if len(ranges) == 1:\n                    # Easy case, set extra header and return partial set.\n                    start, end = ranges[0]\n                    size = end - start\n\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Content-Length', size)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Content-Range',\n                        'bytes %d-%d/%d' % (start, end - 1, self.size)\n                    )\n                    RESPONSE.setStatus(206)  # Partial content\n\n                    data = self.data\n                    if isinstance(data, bytes):\n                        RESPONSE.write(data[start:end])\n                        return True\n\n                    # Linked Pdata objects. Urgh.\n                    pos = 0\n                    while data is not None:\n                        length = len(data.data)\n                        pos = pos + length\n                        if pos > start:\n                            # We are within the range\n                            lstart = length - (pos - start)\n\n                            if lstart < 0:\n                                lstart = 0\n\n                            # find the endpoint\n                            if end <= pos:\n                                lend = length - (pos - end)\n\n                                # Send and end transmission\n                                RESPONSE.write(data[lstart:lend])\n                                break\n\n                            # Not yet at the end, transmit what we have.\n                            RESPONSE.write(data[lstart:])\n\n                        data = data.next\n\n                    return True\n\n                else:\n                    boundary = _make_boundary()\n\n                    # Calculate the content length\n                    size = (8 + len(boundary)  # End marker length\n                            + len(ranges) * (  # Constant lenght per set\n                                49 + len(boundary)\n                                + len(self.content_type)\n                                + len('%d' % self.size)))\n                    for start, end in ranges:\n                        # Variable length per set\n                        size = (size + len('%d%d' % (start, end - 1))\n                                + end - start)\n\n                    # Some clients implement an earlier draft of the spec, they\n                    # will only accept x-byteranges.\n                    draftprefix = (request_range is not None) and 'x-' or ''\n\n                    RESPONSE.setHeader('Content-Length', size)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader(\n                        'Content-Type',\n                        f'multipart/{draftprefix}byteranges;'\n                        f' boundary={boundary}'\n                    )\n                    RESPONSE.setStatus(206)  # Partial content\n\n                    data = self.data\n                    # The Pdata map allows us to jump into the Pdata chain\n                    # arbitrarily during out-of-order range searching.\n                    pdata_map = {}\n                    pdata_map[0] = data\n\n                    for start, end in ranges:\n                        RESPONSE.write(\n                            b'\\r\\n--'\n                            + boundary.encode('ascii')\n                            + b'\\r\\n'\n                        )\n                        RESPONSE.write(\n                            b'Content-Type: '\n                            + self.content_type.encode('ascii')\n                            + b'\\r\\n'\n                        )\n                        RESPONSE.write(\n                            b'Content-Range: bytes '\n                            + str(start).encode('ascii')\n                            + b'-'\n                            + str(end - 1).encode('ascii')\n                            + b'/'\n                            + str(self.size).encode('ascii')\n                            + b'\\r\\n\\r\\n'\n                        )\n\n                        if isinstance(data, bytes):\n                            RESPONSE.write(data[start:end])\n\n                        else:\n                            # Yippee. Linked Pdata objects. The following\n                            # calculations allow us to fast-forward through the\n                            # Pdata chain without a lot of dereferencing if we\n                            # did the work already.\n                            first_size = len(pdata_map[0].data)\n                            if start < first_size:\n                                closest_pos = 0\n                            else:\n                                closest_pos = (\n                                    ((start - first_size) >> 16 << 16)\n                                    + first_size\n                                )\n                            pos = min(closest_pos, max(pdata_map.keys()))\n                            data = pdata_map[pos]\n\n                            while data is not None:\n                                length = len(data.data)\n                                pos = pos + length\n                                if pos > start:\n                                    # We are within the range\n                                    lstart = length - (pos - start)\n\n                                    if lstart < 0:\n                                        lstart = 0\n\n                                    # find the endpoint\n                                    if end <= pos:\n                                        lend = length - (pos - end)\n\n                                        # Send and loop to next range\n                                        RESPONSE.write(data[lstart:lend])\n                                        break\n\n                                    # Not yet at the end,\n                                    # transmit what we have.\n                                    RESPONSE.write(data[lstart:])\n\n                                data = data.next\n                                # Store a reference to a Pdata chain link\n                                # so we don't have to deref during\n                                # this request again.\n                                pdata_map[pos] = data\n\n                    # Do not keep the link references around.\n                    del pdata_map\n\n                    RESPONSE.write(\n                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')\n                    return True\n\n    def _should_force_download(self):\n        # If this returns True, the caller should set a\n        # Content-Disposition header with filename.\n        mimetype = self.content_type\n        if not mimetype:\n            return False\n        if self.use_denylist:\n            # We explicitly deny a few mimetypes, and allow the rest.\n            return mimetype in self.disallowed_inline_mimetypes\n        # Use the allowlist.\n        # We only explicitly allow a few mimetypes, and deny the rest.\n        return mimetype not in self.allowed_inline_mimetypes\n\n    @security.protected(View)\n    def index_html(self, REQUEST, RESPONSE):\n        \"\"\"\n        The default view of the contents of a File or Image.\n\n        Returns the contents of the file or image.  Also, sets the\n        Content-Type HTTP header to the objects content type.\n        \"\"\"\n\n        if self._if_modified_since_request_handler(REQUEST, RESPONSE):\n            # we were able to handle this by returning a 304\n            # unfortunately, because the HTTP cache manager uses the cache\n            # API, and because 304 responses are required to carry the Expires\n            # header for HTTP/1.1, we need to call ZCacheable_set here.\n            # This is nonsensical for caches other than the HTTP cache manager\n            # unfortunately.\n            self.ZCacheable_set(None)\n            return b''\n\n        if self.precondition and hasattr(self, str(self.precondition)):\n            # Grab whatever precondition was defined and then\n            # execute it.  The precondition will raise an exception\n            # if something violates its terms.\n            c = getattr(self, str(self.precondition))\n            if hasattr(c, 'isDocTemp') and c.isDocTemp:\n                c(REQUEST['PARENTS'][1], REQUEST)\n            else:\n                c()\n\n        if self._range_request_handler(REQUEST, RESPONSE):\n            # we served a chunk of content in response to a range request.\n            return b''\n\n        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))\n        RESPONSE.setHeader('Content-Type', self.content_type)\n        RESPONSE.setHeader('Content-Length', self.size)\n        RESPONSE.setHeader('Accept-Ranges', 'bytes')\n\n        if self._should_force_download():\n            # We need a filename, even a dummy one if needed.\n            filename = self.getId()\n            if \".\" not in filename:\n                # This either returns None or \".some_extension\"\n                ext = guess_extension(self.content_type, strict=False)\n                if not ext:\n                    # image/svg+xml -> svg\n                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]\n                filename += f\"{ext}\"\n            filename = quote(filename.encode(\"utf8\"))\n            RESPONSE.setHeader(\n                \"Content-Disposition\",\n                f\"attachment; filename*=UTF-8''{filename}\",\n            )\n\n        if self.ZCacheable_isCachingEnabled():\n            result = self.ZCacheable_get(default=None)\n            if result is not None:\n                # We will always get None from RAMCacheManager and HTTP\n                # Accelerated Cache Manager but we will get\n                # something implementing the IStreamIterator interface\n                # from a \"FileCacheManager\"\n                return result\n\n        self.ZCacheable_set(None)\n\n        data = self.data\n        if isinstance(data, bytes):\n            RESPONSE.setBase(None)\n            return data\n\n        while data is not None:\n            RESPONSE.write(data.data)\n            data = data.next\n\n        return b''\n\n    @security.protected(View)\n    def view_image_or_file(self, URL1):\n        \"\"\"The default view of the contents of the File or Image.\"\"\"\n        raise Redirect(URL1)\n\n    @security.protected(View)\n    def PrincipiaSearchSource(self):\n        \"\"\"Allow file objects to be searched.\"\"\"\n        if self.content_type.startswith('text/'):\n            return bytes(self.data)\n        return b''\n\n    @security.private\n    def update_data(self, data, content_type=None, size=None):\n        if isinstance(data, str):\n            raise TypeError('Data can only be bytes or file-like. '\n                            'Unicode objects are expressly forbidden.')\n\n        if content_type is not None:\n            self.content_type = content_type\n        if size is None:\n            size = len(data)\n        self.size = size\n        self.data = data\n        self.ZCacheable_invalidate()\n        self.ZCacheable_set(None)\n        self.http__refreshEtag()\n\n    def _get_encoding(self):\n        \"\"\"Get the canonical encoding for ZMI.\"\"\"\n        return ZPublisher.HTTPRequest.default_encoding\n\n    @security.protected(change_images_and_files)\n    def manage_edit(\n        self,\n        title,\n        content_type,\n        precondition='',\n        filedata=None,\n        REQUEST=None\n    ):\n        \"\"\"\n        Changes the title and content type attributes of the File or Image.\n        \"\"\"\n        if self.wl_isLocked():\n            raise ResourceLockedError(\"File is locked.\")\n\n        self.title = str(title)\n        self.content_type = str(content_type)\n        if precondition:\n            self.precondition = str(precondition)\n        elif self.precondition:\n            del self.precondition\n        if filedata is not None:\n            if isinstance(filedata, str):\n                filedata = filedata.encode(self._get_encoding())\n            self.update_data(filedata, content_type, len(filedata))\n        else:\n            self.ZCacheable_invalidate()\n\n        notify(ObjectModifiedEvent(self))\n\n        if REQUEST:\n            message = \"Saved changes.\"\n            return self.manage_main(\n                self, REQUEST, manage_tabs_message=message)\n\n    @security.protected(change_images_and_files)\n    def manage_upload(self, file='', REQUEST=None):\n        \"\"\"\n        Replaces the current contents of the File or Image object with file.\n\n        The file or images contents are replaced with the contents of 'file'.\n        \"\"\"\n        if self.wl_isLocked():\n            raise ResourceLockedError(\"File is locked.\")\n\n        if file:\n            data, size = self._read_data(file)\n            content_type = self._get_content_type(file, data, self.__name__,\n                                                  'application/octet-stream')\n            self.update_data(data, content_type, size)\n            notify(ObjectModifiedEvent(self))\n            msg = 'Saved changes.'\n        else:\n            msg = 'Please select a file to upload.'\n\n        if REQUEST:\n            return self.manage_main(\n                self, REQUEST, manage_tabs_message=msg)\n\n    def _get_content_type(self, file, body, id, content_type=None):\n        headers = getattr(file, 'headers', None)\n        if headers and 'content-type' in headers:\n            content_type = headers['content-type']\n        else:\n            if not isinstance(body, bytes):\n                body = body.data\n            content_type, enc = guess_content_type(\n                getattr(file, 'filename', id), body, content_type)\n        return content_type\n\n    def _read_data(self, file):\n        import transaction\n\n        n = 1 << 16\n\n        if isinstance(file, str):\n            raise ValueError(\"Must be bytes\")\n\n        if isinstance(file, bytes):\n            size = len(file)\n            if size < n:\n                return (file, size)\n            # Big string: cut it into smaller chunks\n            file = BytesIO(file)\n\n        if isinstance(file, FileUpload) and not file:\n            raise ValueError('File not specified')\n\n        if hasattr(file, '__class__') and file.__class__ is Pdata:\n            size = len(file)\n            return (file, size)\n\n        seek = file.seek\n        read = file.read\n\n        seek(0, 2)\n        size = end = file.tell()\n\n        if size <= 2 * n:\n            seek(0)\n            if size < n:\n                return read(size), size\n            return Pdata(read(size)), size\n\n        # Make sure we have an _p_jar, even if we are a new object, by\n        # doing a sub-transaction commit.\n        transaction.savepoint(optimistic=True)\n\n        if self._p_jar is None:\n            # Ugh\n            seek(0)\n            return Pdata(read(size)), size\n\n        # Now we're going to build a linked list from back\n        # to front to minimize the number of database updates\n        # and to allow us to get things out of memory as soon as\n        # possible.\n        _next = None\n        while end > 0:\n            pos = end - n\n            if pos < n:\n                pos = 0  # we always want at least n bytes\n            seek(pos)\n\n            # Create the object and assign it a next pointer\n            # in the same transaction, so that there is only\n            # a single database update for it.\n            data = Pdata(read(end - pos))\n            self._p_jar.add(data)\n            data.next = _next\n\n            # Save the object so that we can release its memory.\n            transaction.savepoint(optimistic=True)\n            data._p_deactivate()\n            # The object should be assigned an oid and be a ghost.\n            assert data._p_oid is not None\n            assert data._p_state == -1\n\n            _next = data\n            end = pos\n\n        return (_next, size)\n\n    @security.protected(change_images_and_files)\n    def PUT(self, REQUEST, RESPONSE):\n        \"\"\"Handle HTTP PUT requests\"\"\"\n        self.dav__init(REQUEST, RESPONSE)\n        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)\n        type = REQUEST.get_header('content-type', None)\n\n        file = REQUEST['BODYFILE']\n\n        data, size = self._read_data(file)\n        if isinstance(data, str):\n            data = data.encode('UTF-8')\n        content_type = self._get_content_type(file, data, self.__name__,\n                                              type or self.content_type)\n        self.update_data(data, content_type, size)\n\n        RESPONSE.setStatus(204)\n        return RESPONSE\n\n    @security.protected(View)\n    def get_size(self):\n        # Get the size of a file or image.\n        # Returns the size of the file or image.\n        size = self.size\n        if size is None:\n            size = len(self.data)\n        return size\n\n    # deprecated; use get_size!\n    getSize = get_size\n\n    @security.protected(View)\n    def getContentType(self):\n        # Get the content type of a file or image.\n        # Returns the content type (MIME type) of a file or image.\n        return self.content_type\n\n    def __bytes__(self):\n        return bytes(self.data)\n\n    def __str__(self):\n        \"\"\"In most cases, this is probably not what you want. Use ``bytes``.\"\"\"\n        if isinstance(self.data, Pdata):\n            return bytes(self.data).decode(self._get_encoding())\n        else:\n            return self.data.decode(self._get_encoding())\n\n    def __bool__(self):\n        return True\n\n    __nonzero__ = __bool__\n\n    def __len__(self):\n        data = bytes(self.data)\n        return len(data)\n\n    @security.protected(webdav_access)\n    def manage_DAVget(self):\n        \"\"\"Return body for WebDAV.\"\"\"\n        RESPONSE = self.REQUEST.RESPONSE\n\n        if self.ZCacheable_isCachingEnabled():\n            result = self.ZCacheable_get(default=None)\n            if result is not None:\n                # We will always get None from RAMCacheManager but we will\n                # get something implementing the IStreamIterator interface\n                # from FileCacheManager.\n                # the content-length is required here by HTTPResponse.\n                RESPONSE.setHeader('Content-Length', self.size)\n                return result\n\n        data = self.data\n        if isinstance(data, bytes):\n            RESPONSE.setBase(None)\n            return data\n\n        while data is not None:\n            RESPONSE.write(data.data)\n            data = data.next\n\n        return b''\n\n\nInitializeClass(File)\n\n\nmanage_addImageForm = DTMLFile(\n    'dtml/imageAdd',\n    globals(),\n    Kind='Image',\n    kind='image',\n)\n\n\ndef manage_addImage(\n    self,\n    id,\n    file,\n    title='',\n    precondition='',\n    content_type='',\n    REQUEST=None\n):\n    \"\"\"\n    Add a new Image object.\n\n    Creates a new Image object 'id' with the contents of 'file'.\n    \"\"\"\n    id = str(id)\n    title = str(title)\n    content_type = str(content_type)\n    precondition = str(precondition)\n\n    id, title = cookId(id, title, file)\n\n    self = self.this()\n\n    # First, we create the image without data:\n    self._setObject(id, Image(id, title, b'', content_type, precondition))\n\n    newFile = self._getOb(id)\n\n    # Now we \"upload\" the data.  By doing this in two steps, we\n    # can use a database trick to make the upload more efficient.\n    if file:\n        newFile.manage_upload(file)\n    if content_type:\n        newFile.content_type = content_type\n\n    notify(ObjectCreatedEvent(newFile))\n\n    if REQUEST is not None:\n        try:\n            url = self.DestinationURL()\n        except Exception:\n            url = REQUEST['URL1']\n        REQUEST.RESPONSE.redirect('%s/manage_main' % url)\n    return id\n\n\ndef getImageInfo(data):\n    data = bytes(data)\n    size = len(data)\n    height = -1\n    width = -1\n    content_type = ''\n\n    # handle GIFs\n    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):\n        # Check to see if content_type is correct\n        content_type = 'image/gif'\n        w, h = struct.unpack(\"<HH\", data[6:10])\n        width = int(w)\n        height = int(h)\n\n    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)\n    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'\n    # and finally the 4-byte width, height\n    elif (size >= 24\n          and data[:8] == b'\\211PNG\\r\\n\\032\\n'\n          and data[12:16] == b'IHDR'):\n        content_type = 'image/png'\n        w, h = struct.unpack(\">LL\", data[16:24])\n        width = int(w)\n        height = int(h)\n\n    # Maybe this is for an older PNG version.\n    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):\n        # Check to see if we have the right content type\n        content_type = 'image/png'\n        w, h = struct.unpack(\">LL\", data[8:16])\n        width = int(w)\n        height = int(h)\n\n    # handle JPEGs\n    elif (size >= 2) and (data[:2] == b'\\377\\330'):\n        content_type = 'image/jpeg'\n        jpeg = BytesIO(data)\n        jpeg.read(2)\n        b = jpeg.read(1)\n        try:\n            while (b and ord(b) != 0xDA):\n                while (ord(b) != 0xFF):\n                    b = jpeg.read(1)\n                while (ord(b) == 0xFF):\n                    b = jpeg.read(1)\n                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):\n                    jpeg.read(3)\n                    h, w = struct.unpack(\">HH\", jpeg.read(4))\n                    break\n                else:\n                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)\n                b = jpeg.read(1)\n            width = int(w)\n            height = int(h)\n        except Exception:\n            pass\n\n    # handle SVGs\n    elif (size >= 16) and ((b'<?xml' in data[:16]) or (b'<svg' in data[:16])):\n        try:\n            xmldoc = minidom.parseString(data)\n        except Exception:\n            return content_type, width, height\n        for svg in xmldoc.getElementsByTagName('svg'):\n            w = width\n            h = height\n            content_type = 'image/svg+xml'\n            if 'height' in svg.attributes and 'width' in svg.attributes:\n                w = svg.attributes['width'].value\n                h = svg.attributes['height'].value\n                try:\n                    w = int(float(w))\n                    h = int(float(h))\n                except Exception:\n                    if str(w).endswith('px'):\n                        w = int(float(w[:-2]))\n                        h = int(float(h[:-2]))\n                    elif str(w).endswith('mm'):\n                        w = int(float(w[:-2]) * 3.7795)\n                        h = int(float(h[:-2]) * 3.7795)\n                    elif str(w).endswith('cm'):\n                        w = int(float(w[:-2]) * 37.795)\n                        h = int(float(h[:-2]) * 37.795)\n                break\n            elif 'viewBox' in svg.attributes:\n                viewBox = svg.attributes['viewBox'].value\n                viewBox = [int(float(x)) for x in viewBox.split(' ')]\n                w = viewBox[2] - viewBox[0]\n                h = viewBox[3] - viewBox[1]\n            width = int(w)\n            height = int(h)\n\n    return content_type, width, height\n\n\nclass Image(File):\n    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods\n    as File objects.  Images also have a string representation that\n    renders an HTML 'IMG' tag.\n    \"\"\"\n\n    meta_type = 'Image'\n    zmi_icon = 'far fa-file-image'\n\n    security = ClassSecurityInfo()\n    security.declareObjectProtected(View)\n\n    alt = ''\n    height = ''\n    width = ''\n\n    # FIXME: Redundant, already in base class\n    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501\n    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501\n    security.declareProtected(View, 'index_html')  # NOQA: D001\n    security.declareProtected(View, 'get_size')  # NOQA: D001\n    security.declareProtected(View, 'getContentType')  # NOQA: D001\n\n    _properties = (\n        {'id': 'title', 'type': 'string'},\n        {'id': 'alt', 'type': 'string'},\n        {'id': 'content_type', 'type': 'string', 'mode': 'w'},\n        {'id': 'height', 'type': 'string'},\n        {'id': 'width', 'type': 'string'},\n    )\n\n    manage_options = (\n        ({'label': 'Edit', 'action': 'manage_main'},\n         {'label': 'View', 'action': 'view_image_or_file'})\n        + PropertyManager.manage_options\n        + RoleManager.manage_options\n        + Item_w__name__.manage_options\n        + Cacheable.manage_options\n    )\n\n    manage_editForm = DTMLFile(\n        'dtml/imageEdit',\n        globals(),\n        Kind='Image',\n        kind='image',\n    )\n    manage_editForm._setName('manage_editForm')\n\n    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001\n    view_image_or_file = DTMLFile('dtml/imageView', globals())\n\n    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001\n    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501\n    manage = manage_main = manage_editForm\n    manage_uploadForm = manage_editForm\n\n    @security.private\n    def update_data(self, data, content_type=None, size=None):\n        if isinstance(data, str):\n            raise TypeError('Data can only be bytes or file-like.  '\n                            'Unicode objects are expressly forbidden.')\n\n        if size is None:\n            size = len(data)\n\n        self.size = size\n        self.data = data\n\n        ct, width, height = getImageInfo(data)\n        if ct:\n            content_type = ct\n        if width >= 0 and height >= 0:\n            self.width = width\n            self.height = height\n\n        # Now we should have the correct content type, or still None\n        if content_type is not None:\n            self.content_type = content_type\n\n        self.ZCacheable_invalidate()\n        self.ZCacheable_set(None)\n        self.http__refreshEtag()\n\n    def __bytes__(self):\n        return self.tag().encode('utf-8')\n\n    def __str__(self):\n        return self.tag()\n\n    @security.protected(View)\n    def tag(\n        self,\n        height=None,\n        width=None,\n        alt=None,\n        scale=0,\n        xscale=0,\n        yscale=0,\n        css_class=None,\n        title=None,\n        **args\n    ):\n        \"\"\"Generate an HTML IMG tag for this image, with customization.\n\n        Arguments to self.tag() can be any valid attributes of an IMG tag.\n        'src' will always be an absolute pathname, to prevent redundant\n        downloading of images. Defaults are applied intelligently for\n        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',\n        and 'yscale' keyword arguments will be used to automatically adjust\n        the output height and width values of the image tag.\n        #\n        Since 'class' is a Python reserved word, it cannot be passed in\n        directly in keyword arguments which is a problem if you are\n        trying to use 'tag()' to include a CSS class. The tag() method\n        will accept a 'css_class' argument that will be converted to\n        'class' in the output tag to work around this.\n        \"\"\"\n        if height is None:\n            height = self.height\n        if width is None:\n            width = self.width\n\n        # Auto-scaling support\n        xdelta = xscale or scale\n        ydelta = yscale or scale\n\n        if xdelta and width:\n            width = str(int(round(int(width) * xdelta)))\n        if ydelta and height:\n            height = str(int(round(int(height) * ydelta)))\n\n        result = '<img src=\"%s\"' % (self.absolute_url())\n\n        if alt is None:\n            alt = getattr(self, 'alt', '')\n        result = f'{result} alt=\"{html.escape(alt, True)}\"'\n\n        if title is None:\n            title = getattr(self, 'title', '')\n        result = f'{result} title=\"{html.escape(title, True)}\"'\n\n        if height:\n            result = f'{result} height=\"{height}\"'\n\n        if width:\n            result = f'{result} width=\"{width}\"'\n\n        if css_class is not None:\n            result = f'{result} class=\"{css_class}\"'\n\n        for key in list(args.keys()):\n            value = args.get(key)\n            if value:\n                result = f'{result} {key}=\"{value}\"'\n\n        return '%s />' % result\n\n\nInitializeClass(Image)\n\n\ndef cookId(id, title, file):\n    if not id and hasattr(file, 'filename'):\n        filename = file.filename\n        title = title or filename\n        id = filename[max(filename.rfind('/'),\n                          filename.rfind('\\\\'),\n                          filename.rfind(':'),\n                          ) + 1:]\n    return id, title\n\n\nclass Pdata(Persistent, Implicit):\n    # Wrapper for possibly large data\n\n    next = None\n\n    def __init__(self, data):\n        self.data = data\n\n    def __getitem__(self, key):\n        return self.data[key]\n\n    def __len__(self):\n        data = bytes(self)\n        return len(data)\n\n    def __bytes__(self):\n        _next = self.next\n        if _next is None:\n            return self.data\n\n        r = [self.data]\n        while _next is not None:\n            self = _next\n            r.append(self.data)\n            _next = self.next\n\n        return b''.join(r)\n", "code_before": "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\"\"\"Image object\n\"\"\"\n\nimport html\nimport struct\nfrom email.generator import _make_boundary\nfrom io import BytesIO\nfrom xml.dom import minidom\n\nimport ZPublisher.HTTPRequest\nfrom AccessControl.class_init import InitializeClass\nfrom AccessControl.Permissions import change_images_and_files  # NOQA\nfrom AccessControl.Permissions import view as View\nfrom AccessControl.Permissions import view_management_screens\nfrom AccessControl.Permissions import webdav_access\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom Acquisition import Implicit\nfrom App.special_dtml import DTMLFile\nfrom DateTime.DateTime import DateTime\nfrom OFS.Cache import Cacheable\nfrom OFS.interfaces import IWriteLock\nfrom OFS.PropertyManager import PropertyManager\nfrom OFS.role import RoleManager\nfrom OFS.SimpleItem import Item_w__name__\nfrom OFS.SimpleItem import PathReprProvider\nfrom Persistence import Persistent\nfrom zExceptions import Redirect\nfrom zExceptions import ResourceLockedError\nfrom zope.contenttype import guess_content_type\nfrom zope.datetime import rfc1123_date\nfrom zope.event import notify\nfrom zope.interface import implementer\nfrom zope.lifecycleevent import ObjectCreatedEvent\nfrom zope.lifecycleevent import ObjectModifiedEvent\nfrom ZPublisher import HTTPRangeSupport\nfrom ZPublisher.HTTPRequest import FileUpload\n\n\nmanage_addFileForm = DTMLFile(\n    'dtml/imageAdd',\n    globals(),\n    Kind='File',\n    kind='file',\n)\n\n\ndef manage_addFile(\n    self,\n    id,\n    file=b'',\n    title='',\n    precondition='',\n    content_type='',\n    REQUEST=None\n):\n    \"\"\"Add a new File object.\n\n    Creates a new File object 'id' with the contents of 'file'\"\"\"\n\n    id = str(id)\n    title = str(title)\n    content_type = str(content_type)\n    precondition = str(precondition)\n\n    id, title = cookId(id, title, file)\n\n    self = self.this()\n\n    # First, we create the file without data:\n    self._setObject(id, File(id, title, b'', content_type, precondition))\n\n    newFile = self._getOb(id)\n\n    # Now we \"upload\" the data.  By doing this in two steps, we\n    # can use a database trick to make the upload more efficient.\n    if file:\n        newFile.manage_upload(file)\n    if content_type:\n        newFile.content_type = content_type\n\n    notify(ObjectCreatedEvent(newFile))\n\n    if REQUEST is not None:\n        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')\n\n\n@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)\nclass File(\n    PathReprProvider,\n    Persistent,\n    Implicit,\n    PropertyManager,\n    RoleManager,\n    Item_w__name__,\n    Cacheable\n):\n    \"\"\"A File object is a content object for arbitrary files.\"\"\"\n\n    meta_type = 'File'\n    zmi_icon = 'far fa-file-archive'\n\n    security = ClassSecurityInfo()\n    security.declareObjectProtected(View)\n\n    precondition = ''\n    size = None\n\n    manage_editForm = DTMLFile('dtml/fileEdit', globals(),\n                               Kind='File', kind='file')\n    manage_editForm._setName('manage_editForm')\n\n    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001\n    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501\n    manage = manage_main = manage_editForm\n    manage_uploadForm = manage_editForm\n\n    manage_options = (({'label': 'Edit', 'action': 'manage_main'},\n                       {'label': 'View', 'action': ''})\n                      + PropertyManager.manage_options\n                      + RoleManager.manage_options\n                      + Item_w__name__.manage_options\n                      + Cacheable.manage_options)\n\n    _properties = (\n        {'id': 'title', 'type': 'string'},\n        {'id': 'content_type', 'type': 'string'},\n    )\n\n    def __init__(self, id, title, file, content_type='', precondition=''):\n        self.__name__ = id\n        self.title = title\n        self.precondition = precondition\n\n        data, size = self._read_data(file)\n        content_type = self._get_content_type(file, data, id, content_type)\n        self.update_data(data, content_type, size)\n\n    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):\n        # HTTP If-Modified-Since header handling: return True if\n        # we can handle this request by returning a 304 response\n        header = REQUEST.get_header('If-Modified-Since', None)\n        if header is not None:\n            header = header.split(';')[0]\n            # Some proxies seem to send invalid date strings for this\n            # header. If the date string is not valid, we ignore it\n            # rather than raise an error to be generally consistent\n            # with common servers such as Apache (which can usually\n            # understand the screwy date string as a lucky side effect\n            # of the way they parse it).\n            # This happens to be what RFC2616 tells us to do in the face of an\n            # invalid date.\n            try:\n                mod_since = int(DateTime(header).timeTime())\n            except Exception:\n                mod_since = None\n            if mod_since is not None:\n                if self._p_mtime:\n                    last_mod = int(self._p_mtime)\n                else:\n                    last_mod = 0\n                if last_mod > 0 and last_mod <= mod_since:\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setStatus(304)\n                    return True\n\n    def _range_request_handler(self, REQUEST, RESPONSE):\n        # HTTP Range header handling: return True if we've served a range\n        # chunk out of our data.\n        range = REQUEST.get_header('Range', None)\n        request_range = REQUEST.get_header('Request-Range', None)\n        if request_range is not None:\n            # Netscape 2 through 4 and MSIE 3 implement a draft version\n            # Later on, we need to serve a different mime-type as well.\n            range = request_range\n        if_range = REQUEST.get_header('If-Range', None)\n        if range is not None:\n            ranges = HTTPRangeSupport.parseRange(range)\n\n            if if_range is not None:\n                # Only send ranges if the data isn't modified, otherwise send\n                # the whole object. Support both ETags and Last-Modified dates!\n                if len(if_range) > 1 and if_range[:2] == 'ts':\n                    # ETag:\n                    if if_range != self.http__etag():\n                        # Modified, so send a normal response. We delete\n                        # the ranges, which causes us to skip to the 200\n                        # response.\n                        ranges = None\n                else:\n                    # Date\n                    date = if_range.split(';')[0]\n                    try:\n                        mod_since = int(DateTime(date).timeTime())\n                    except Exception:\n                        mod_since = None\n                    if mod_since is not None:\n                        if self._p_mtime:\n                            last_mod = int(self._p_mtime)\n                        else:\n                            last_mod = 0\n                        if last_mod > mod_since:\n                            # Modified, so send a normal response. We delete\n                            # the ranges, which causes us to skip to the 200\n                            # response.\n                            ranges = None\n\n            if ranges:\n                # Search for satisfiable ranges.\n                satisfiable = 0\n                for start, end in ranges:\n                    if start < self.size:\n                        satisfiable = 1\n                        break\n\n                if not satisfiable:\n                    RESPONSE.setHeader(\n                        'Content-Range', 'bytes */%d' % self.size\n                    )\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Content-Length', self.size)\n                    RESPONSE.setStatus(416)\n                    return True\n\n                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)\n\n                if len(ranges) == 1:\n                    # Easy case, set extra header and return partial set.\n                    start, end = ranges[0]\n                    size = end - start\n\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader('Content-Type', self.content_type)\n                    RESPONSE.setHeader('Content-Length', size)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Content-Range',\n                        'bytes %d-%d/%d' % (start, end - 1, self.size)\n                    )\n                    RESPONSE.setStatus(206)  # Partial content\n\n                    data = self.data\n                    if isinstance(data, bytes):\n                        RESPONSE.write(data[start:end])\n                        return True\n\n                    # Linked Pdata objects. Urgh.\n                    pos = 0\n                    while data is not None:\n                        length = len(data.data)\n                        pos = pos + length\n                        if pos > start:\n                            # We are within the range\n                            lstart = length - (pos - start)\n\n                            if lstart < 0:\n                                lstart = 0\n\n                            # find the endpoint\n                            if end <= pos:\n                                lend = length - (pos - end)\n\n                                # Send and end transmission\n                                RESPONSE.write(data[lstart:lend])\n                                break\n\n                            # Not yet at the end, transmit what we have.\n                            RESPONSE.write(data[lstart:])\n\n                        data = data.next\n\n                    return True\n\n                else:\n                    boundary = _make_boundary()\n\n                    # Calculate the content length\n                    size = (8 + len(boundary)  # End marker length\n                            + len(ranges) * (  # Constant lenght per set\n                                49 + len(boundary)\n                                + len(self.content_type)\n                                + len('%d' % self.size)))\n                    for start, end in ranges:\n                        # Variable length per set\n                        size = (size + len('%d%d' % (start, end - 1))\n                                + end - start)\n\n                    # Some clients implement an earlier draft of the spec, they\n                    # will only accept x-byteranges.\n                    draftprefix = (request_range is not None) and 'x-' or ''\n\n                    RESPONSE.setHeader('Content-Length', size)\n                    RESPONSE.setHeader('Accept-Ranges', 'bytes')\n                    RESPONSE.setHeader(\n                        'Last-Modified', rfc1123_date(self._p_mtime)\n                    )\n                    RESPONSE.setHeader(\n                        'Content-Type',\n                        f'multipart/{draftprefix}byteranges;'\n                        f' boundary={boundary}'\n                    )\n                    RESPONSE.setStatus(206)  # Partial content\n\n                    data = self.data\n                    # The Pdata map allows us to jump into the Pdata chain\n                    # arbitrarily during out-of-order range searching.\n                    pdata_map = {}\n                    pdata_map[0] = data\n\n                    for start, end in ranges:\n                        RESPONSE.write(\n                            b'\\r\\n--'\n                            + boundary.encode('ascii')\n                            + b'\\r\\n'\n                        )\n                        RESPONSE.write(\n                            b'Content-Type: '\n                            + self.content_type.encode('ascii')\n                            + b'\\r\\n'\n                        )\n                        RESPONSE.write(\n                            b'Content-Range: bytes '\n                            + str(start).encode('ascii')\n                            + b'-'\n                            + str(end - 1).encode('ascii')\n                            + b'/'\n                            + str(self.size).encode('ascii')\n                            + b'\\r\\n\\r\\n'\n                        )\n\n                        if isinstance(data, bytes):\n                            RESPONSE.write(data[start:end])\n\n                        else:\n                            # Yippee. Linked Pdata objects. The following\n                            # calculations allow us to fast-forward through the\n                            # Pdata chain without a lot of dereferencing if we\n                            # did the work already.\n                            first_size = len(pdata_map[0].data)\n                            if start < first_size:\n                                closest_pos = 0\n                            else:\n                                closest_pos = (\n                                    ((start - first_size) >> 16 << 16)\n                                    + first_size\n                                )\n                            pos = min(closest_pos, max(pdata_map.keys()))\n                            data = pdata_map[pos]\n\n                            while data is not None:\n                                length = len(data.data)\n                                pos = pos + length\n                                if pos > start:\n                                    # We are within the range\n                                    lstart = length - (pos - start)\n\n                                    if lstart < 0:\n                                        lstart = 0\n\n                                    # find the endpoint\n                                    if end <= pos:\n                                        lend = length - (pos - end)\n\n                                        # Send and loop to next range\n                                        RESPONSE.write(data[lstart:lend])\n                                        break\n\n                                    # Not yet at the end,\n                                    # transmit what we have.\n                                    RESPONSE.write(data[lstart:])\n\n                                data = data.next\n                                # Store a reference to a Pdata chain link\n                                # so we don't have to deref during\n                                # this request again.\n                                pdata_map[pos] = data\n\n                    # Do not keep the link references around.\n                    del pdata_map\n\n                    RESPONSE.write(\n                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')\n                    return True\n\n    @security.protected(View)\n    def index_html(self, REQUEST, RESPONSE):\n        \"\"\"\n        The default view of the contents of a File or Image.\n\n        Returns the contents of the file or image.  Also, sets the\n        Content-Type HTTP header to the objects content type.\n        \"\"\"\n\n        if self._if_modified_since_request_handler(REQUEST, RESPONSE):\n            # we were able to handle this by returning a 304\n            # unfortunately, because the HTTP cache manager uses the cache\n            # API, and because 304 responses are required to carry the Expires\n            # header for HTTP/1.1, we need to call ZCacheable_set here.\n            # This is nonsensical for caches other than the HTTP cache manager\n            # unfortunately.\n            self.ZCacheable_set(None)\n            return b''\n\n        if self.precondition and hasattr(self, str(self.precondition)):\n            # Grab whatever precondition was defined and then\n            # execute it.  The precondition will raise an exception\n            # if something violates its terms.\n            c = getattr(self, str(self.precondition))\n            if hasattr(c, 'isDocTemp') and c.isDocTemp:\n                c(REQUEST['PARENTS'][1], REQUEST)\n            else:\n                c()\n\n        if self._range_request_handler(REQUEST, RESPONSE):\n            # we served a chunk of content in response to a range request.\n            return b''\n\n        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))\n        RESPONSE.setHeader('Content-Type', self.content_type)\n        RESPONSE.setHeader('Content-Length', self.size)\n        RESPONSE.setHeader('Accept-Ranges', 'bytes')\n\n        if self.ZCacheable_isCachingEnabled():\n            result = self.ZCacheable_get(default=None)\n            if result is not None:\n                # We will always get None from RAMCacheManager and HTTP\n                # Accelerated Cache Manager but we will get\n                # something implementing the IStreamIterator interface\n                # from a \"FileCacheManager\"\n                return result\n\n        self.ZCacheable_set(None)\n\n        data = self.data\n        if isinstance(data, bytes):\n            RESPONSE.setBase(None)\n            return data\n\n        while data is not None:\n            RESPONSE.write(data.data)\n            data = data.next\n\n        return b''\n\n    @security.protected(View)\n    def view_image_or_file(self, URL1):\n        \"\"\"The default view of the contents of the File or Image.\"\"\"\n        raise Redirect(URL1)\n\n    @security.protected(View)\n    def PrincipiaSearchSource(self):\n        \"\"\"Allow file objects to be searched.\"\"\"\n        if self.content_type.startswith('text/'):\n            return bytes(self.data)\n        return b''\n\n    @security.private\n    def update_data(self, data, content_type=None, size=None):\n        if isinstance(data, str):\n            raise TypeError('Data can only be bytes or file-like. '\n                            'Unicode objects are expressly forbidden.')\n\n        if content_type is not None:\n            self.content_type = content_type\n        if size is None:\n            size = len(data)\n        self.size = size\n        self.data = data\n        self.ZCacheable_invalidate()\n        self.ZCacheable_set(None)\n        self.http__refreshEtag()\n\n    def _get_encoding(self):\n        \"\"\"Get the canonical encoding for ZMI.\"\"\"\n        return ZPublisher.HTTPRequest.default_encoding\n\n    @security.protected(change_images_and_files)\n    def manage_edit(\n        self,\n        title,\n        content_type,\n        precondition='',\n        filedata=None,\n        REQUEST=None\n    ):\n        \"\"\"\n        Changes the title and content type attributes of the File or Image.\n        \"\"\"\n        if self.wl_isLocked():\n            raise ResourceLockedError(\"File is locked.\")\n\n        self.title = str(title)\n        self.content_type = str(content_type)\n        if precondition:\n            self.precondition = str(precondition)\n        elif self.precondition:\n            del self.precondition\n        if filedata is not None:\n            if isinstance(filedata, str):\n                filedata = filedata.encode(self._get_encoding())\n            self.update_data(filedata, content_type, len(filedata))\n        else:\n            self.ZCacheable_invalidate()\n\n        notify(ObjectModifiedEvent(self))\n\n        if REQUEST:\n            message = \"Saved changes.\"\n            return self.manage_main(\n                self, REQUEST, manage_tabs_message=message)\n\n    @security.protected(change_images_and_files)\n    def manage_upload(self, file='', REQUEST=None):\n        \"\"\"\n        Replaces the current contents of the File or Image object with file.\n\n        The file or images contents are replaced with the contents of 'file'.\n        \"\"\"\n        if self.wl_isLocked():\n            raise ResourceLockedError(\"File is locked.\")\n\n        if file:\n            data, size = self._read_data(file)\n            content_type = self._get_content_type(file, data, self.__name__,\n                                                  'application/octet-stream')\n            self.update_data(data, content_type, size)\n            notify(ObjectModifiedEvent(self))\n            msg = 'Saved changes.'\n        else:\n            msg = 'Please select a file to upload.'\n\n        if REQUEST:\n            return self.manage_main(\n                self, REQUEST, manage_tabs_message=msg)\n\n    def _get_content_type(self, file, body, id, content_type=None):\n        headers = getattr(file, 'headers', None)\n        if headers and 'content-type' in headers:\n            content_type = headers['content-type']\n        else:\n            if not isinstance(body, bytes):\n                body = body.data\n            content_type, enc = guess_content_type(\n                getattr(file, 'filename', id), body, content_type)\n        return content_type\n\n    def _read_data(self, file):\n        import transaction\n\n        n = 1 << 16\n\n        if isinstance(file, str):\n            raise ValueError(\"Must be bytes\")\n\n        if isinstance(file, bytes):\n            size = len(file)\n            if size < n:\n                return (file, size)\n            # Big string: cut it into smaller chunks\n            file = BytesIO(file)\n\n        if isinstance(file, FileUpload) and not file:\n            raise ValueError('File not specified')\n\n        if hasattr(file, '__class__') and file.__class__ is Pdata:\n            size = len(file)\n            return (file, size)\n\n        seek = file.seek\n        read = file.read\n\n        seek(0, 2)\n        size = end = file.tell()\n\n        if size <= 2 * n:\n            seek(0)\n            if size < n:\n                return read(size), size\n            return Pdata(read(size)), size\n\n        # Make sure we have an _p_jar, even if we are a new object, by\n        # doing a sub-transaction commit.\n        transaction.savepoint(optimistic=True)\n\n        if self._p_jar is None:\n            # Ugh\n            seek(0)\n            return Pdata(read(size)), size\n\n        # Now we're going to build a linked list from back\n        # to front to minimize the number of database updates\n        # and to allow us to get things out of memory as soon as\n        # possible.\n        _next = None\n        while end > 0:\n            pos = end - n\n            if pos < n:\n                pos = 0  # we always want at least n bytes\n            seek(pos)\n\n            # Create the object and assign it a next pointer\n            # in the same transaction, so that there is only\n            # a single database update for it.\n            data = Pdata(read(end - pos))\n            self._p_jar.add(data)\n            data.next = _next\n\n            # Save the object so that we can release its memory.\n            transaction.savepoint(optimistic=True)\n            data._p_deactivate()\n            # The object should be assigned an oid and be a ghost.\n            assert data._p_oid is not None\n            assert data._p_state == -1\n\n            _next = data\n            end = pos\n\n        return (_next, size)\n\n    @security.protected(change_images_and_files)\n    def PUT(self, REQUEST, RESPONSE):\n        \"\"\"Handle HTTP PUT requests\"\"\"\n        self.dav__init(REQUEST, RESPONSE)\n        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)\n        type = REQUEST.get_header('content-type', None)\n\n        file = REQUEST['BODYFILE']\n\n        data, size = self._read_data(file)\n        if isinstance(data, str):\n            data = data.encode('UTF-8')\n        content_type = self._get_content_type(file, data, self.__name__,\n                                              type or self.content_type)\n        self.update_data(data, content_type, size)\n\n        RESPONSE.setStatus(204)\n        return RESPONSE\n\n    @security.protected(View)\n    def get_size(self):\n        # Get the size of a file or image.\n        # Returns the size of the file or image.\n        size = self.size\n        if size is None:\n            size = len(self.data)\n        return size\n\n    # deprecated; use get_size!\n    getSize = get_size\n\n    @security.protected(View)\n    def getContentType(self):\n        # Get the content type of a file or image.\n        # Returns the content type (MIME type) of a file or image.\n        return self.content_type\n\n    def __bytes__(self):\n        return bytes(self.data)\n\n    def __str__(self):\n        \"\"\"In most cases, this is probably not what you want. Use ``bytes``.\"\"\"\n        if isinstance(self.data, Pdata):\n            return bytes(self.data).decode(self._get_encoding())\n        else:\n            return self.data.decode(self._get_encoding())\n\n    def __bool__(self):\n        return True\n\n    __nonzero__ = __bool__\n\n    def __len__(self):\n        data = bytes(self.data)\n        return len(data)\n\n    @security.protected(webdav_access)\n    def manage_DAVget(self):\n        \"\"\"Return body for WebDAV.\"\"\"\n        RESPONSE = self.REQUEST.RESPONSE\n\n        if self.ZCacheable_isCachingEnabled():\n            result = self.ZCacheable_get(default=None)\n            if result is not None:\n                # We will always get None from RAMCacheManager but we will\n                # get something implementing the IStreamIterator interface\n                # from FileCacheManager.\n                # the content-length is required here by HTTPResponse.\n                RESPONSE.setHeader('Content-Length', self.size)\n                return result\n\n        data = self.data\n        if isinstance(data, bytes):\n            RESPONSE.setBase(None)\n            return data\n\n        while data is not None:\n            RESPONSE.write(data.data)\n            data = data.next\n\n        return b''\n\n\nInitializeClass(File)\n\n\nmanage_addImageForm = DTMLFile(\n    'dtml/imageAdd',\n    globals(),\n    Kind='Image',\n    kind='image',\n)\n\n\ndef manage_addImage(\n    self,\n    id,\n    file,\n    title='',\n    precondition='',\n    content_type='',\n    REQUEST=None\n):\n    \"\"\"\n    Add a new Image object.\n\n    Creates a new Image object 'id' with the contents of 'file'.\n    \"\"\"\n    id = str(id)\n    title = str(title)\n    content_type = str(content_type)\n    precondition = str(precondition)\n\n    id, title = cookId(id, title, file)\n\n    self = self.this()\n\n    # First, we create the image without data:\n    self._setObject(id, Image(id, title, b'', content_type, precondition))\n\n    newFile = self._getOb(id)\n\n    # Now we \"upload\" the data.  By doing this in two steps, we\n    # can use a database trick to make the upload more efficient.\n    if file:\n        newFile.manage_upload(file)\n    if content_type:\n        newFile.content_type = content_type\n\n    notify(ObjectCreatedEvent(newFile))\n\n    if REQUEST is not None:\n        try:\n            url = self.DestinationURL()\n        except Exception:\n            url = REQUEST['URL1']\n        REQUEST.RESPONSE.redirect('%s/manage_main' % url)\n    return id\n\n\ndef getImageInfo(data):\n    data = bytes(data)\n    size = len(data)\n    height = -1\n    width = -1\n    content_type = ''\n\n    # handle GIFs\n    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):\n        # Check to see if content_type is correct\n        content_type = 'image/gif'\n        w, h = struct.unpack(\"<HH\", data[6:10])\n        width = int(w)\n        height = int(h)\n\n    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)\n    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'\n    # and finally the 4-byte width, height\n    elif (size >= 24\n          and data[:8] == b'\\211PNG\\r\\n\\032\\n'\n          and data[12:16] == b'IHDR'):\n        content_type = 'image/png'\n        w, h = struct.unpack(\">LL\", data[16:24])\n        width = int(w)\n        height = int(h)\n\n    # Maybe this is for an older PNG version.\n    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):\n        # Check to see if we have the right content type\n        content_type = 'image/png'\n        w, h = struct.unpack(\">LL\", data[8:16])\n        width = int(w)\n        height = int(h)\n\n    # handle JPEGs\n    elif (size >= 2) and (data[:2] == b'\\377\\330'):\n        content_type = 'image/jpeg'\n        jpeg = BytesIO(data)\n        jpeg.read(2)\n        b = jpeg.read(1)\n        try:\n            while (b and ord(b) != 0xDA):\n                while (ord(b) != 0xFF):\n                    b = jpeg.read(1)\n                while (ord(b) == 0xFF):\n                    b = jpeg.read(1)\n                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):\n                    jpeg.read(3)\n                    h, w = struct.unpack(\">HH\", jpeg.read(4))\n                    break\n                else:\n                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)\n                b = jpeg.read(1)\n            width = int(w)\n            height = int(h)\n        except Exception:\n            pass\n\n    # handle SVGs\n    elif (size >= 16) and ((b'<?xml' in data[:16]) or (b'<svg' in data[:16])):\n        try:\n            xmldoc = minidom.parseString(data)\n        except Exception:\n            return content_type, width, height\n        for svg in xmldoc.getElementsByTagName('svg'):\n            w = width\n            h = height\n            content_type = 'image/svg+xml'\n            if 'height' in svg.attributes and 'width' in svg.attributes:\n                w = svg.attributes['width'].value\n                h = svg.attributes['height'].value\n                try:\n                    w = int(float(w))\n                    h = int(float(h))\n                except Exception:\n                    if str(w).endswith('px'):\n                        w = int(float(w[:-2]))\n                        h = int(float(h[:-2]))\n                    elif str(w).endswith('mm'):\n                        w = int(float(w[:-2]) * 3.7795)\n                        h = int(float(h[:-2]) * 3.7795)\n                    elif str(w).endswith('cm'):\n                        w = int(float(w[:-2]) * 37.795)\n                        h = int(float(h[:-2]) * 37.795)\n                break\n            elif 'viewBox' in svg.attributes:\n                viewBox = svg.attributes['viewBox'].value\n                viewBox = [int(float(x)) for x in viewBox.split(' ')]\n                w = viewBox[2] - viewBox[0]\n                h = viewBox[3] - viewBox[1]\n            width = int(w)\n            height = int(h)\n\n    return content_type, width, height\n\n\nclass Image(File):\n    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods\n    as File objects.  Images also have a string representation that\n    renders an HTML 'IMG' tag.\n    \"\"\"\n\n    meta_type = 'Image'\n    zmi_icon = 'far fa-file-image'\n\n    security = ClassSecurityInfo()\n    security.declareObjectProtected(View)\n\n    alt = ''\n    height = ''\n    width = ''\n\n    # FIXME: Redundant, already in base class\n    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501\n    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501\n    security.declareProtected(View, 'index_html')  # NOQA: D001\n    security.declareProtected(View, 'get_size')  # NOQA: D001\n    security.declareProtected(View, 'getContentType')  # NOQA: D001\n\n    _properties = (\n        {'id': 'title', 'type': 'string'},\n        {'id': 'alt', 'type': 'string'},\n        {'id': 'content_type', 'type': 'string', 'mode': 'w'},\n        {'id': 'height', 'type': 'string'},\n        {'id': 'width', 'type': 'string'},\n    )\n\n    manage_options = (\n        ({'label': 'Edit', 'action': 'manage_main'},\n         {'label': 'View', 'action': 'view_image_or_file'})\n        + PropertyManager.manage_options\n        + RoleManager.manage_options\n        + Item_w__name__.manage_options\n        + Cacheable.manage_options\n    )\n\n    manage_editForm = DTMLFile(\n        'dtml/imageEdit',\n        globals(),\n        Kind='Image',\n        kind='image',\n    )\n    manage_editForm._setName('manage_editForm')\n\n    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001\n    view_image_or_file = DTMLFile('dtml/imageView', globals())\n\n    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001\n    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501\n    manage = manage_main = manage_editForm\n    manage_uploadForm = manage_editForm\n\n    @security.private\n    def update_data(self, data, content_type=None, size=None):\n        if isinstance(data, str):\n            raise TypeError('Data can only be bytes or file-like.  '\n                            'Unicode objects are expressly forbidden.')\n\n        if size is None:\n            size = len(data)\n\n        self.size = size\n        self.data = data\n\n        ct, width, height = getImageInfo(data)\n        if ct:\n            content_type = ct\n        if width >= 0 and height >= 0:\n            self.width = width\n            self.height = height\n\n        # Now we should have the correct content type, or still None\n        if content_type is not None:\n            self.content_type = content_type\n\n        self.ZCacheable_invalidate()\n        self.ZCacheable_set(None)\n        self.http__refreshEtag()\n\n    def __bytes__(self):\n        return self.tag().encode('utf-8')\n\n    def __str__(self):\n        return self.tag()\n\n    @security.protected(View)\n    def tag(\n        self,\n        height=None,\n        width=None,\n        alt=None,\n        scale=0,\n        xscale=0,\n        yscale=0,\n        css_class=None,\n        title=None,\n        **args\n    ):\n        \"\"\"Generate an HTML IMG tag for this image, with customization.\n\n        Arguments to self.tag() can be any valid attributes of an IMG tag.\n        'src' will always be an absolute pathname, to prevent redundant\n        downloading of images. Defaults are applied intelligently for\n        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',\n        and 'yscale' keyword arguments will be used to automatically adjust\n        the output height and width values of the image tag.\n        #\n        Since 'class' is a Python reserved word, it cannot be passed in\n        directly in keyword arguments which is a problem if you are\n        trying to use 'tag()' to include a CSS class. The tag() method\n        will accept a 'css_class' argument that will be converted to\n        'class' in the output tag to work around this.\n        \"\"\"\n        if height is None:\n            height = self.height\n        if width is None:\n            width = self.width\n\n        # Auto-scaling support\n        xdelta = xscale or scale\n        ydelta = yscale or scale\n\n        if xdelta and width:\n            width = str(int(round(int(width) * xdelta)))\n        if ydelta and height:\n            height = str(int(round(int(height) * ydelta)))\n\n        result = '<img src=\"%s\"' % (self.absolute_url())\n\n        if alt is None:\n            alt = getattr(self, 'alt', '')\n        result = f'{result} alt=\"{html.escape(alt, True)}\"'\n\n        if title is None:\n            title = getattr(self, 'title', '')\n        result = f'{result} title=\"{html.escape(title, True)}\"'\n\n        if height:\n            result = f'{result} height=\"{height}\"'\n\n        if width:\n            result = f'{result} width=\"{width}\"'\n\n        if css_class is not None:\n            result = f'{result} class=\"{css_class}\"'\n\n        for key in list(args.keys()):\n            value = args.get(key)\n            if value:\n                result = f'{result} {key}=\"{value}\"'\n\n        return '%s />' % result\n\n\nInitializeClass(Image)\n\n\ndef cookId(id, title, file):\n    if not id and hasattr(file, 'filename'):\n        filename = file.filename\n        title = title or filename\n        id = filename[max(filename.rfind('/'),\n                          filename.rfind('\\\\'),\n                          filename.rfind(':'),\n                          ) + 1:]\n    return id, title\n\n\nclass Pdata(Persistent, Implicit):\n    # Wrapper for possibly large data\n\n    next = None\n\n    def __init__(self, data):\n        self.data = data\n\n    def __getitem__(self, key):\n        return self.data[key]\n\n    def __len__(self):\n        data = bytes(self)\n        return len(data)\n\n    def __bytes__(self):\n        _next = self.next\n        if _next is None:\n            return self.data\n\n        r = [self.data]\n        while _next is not None:\n            self = _next\n            r.append(self.data)\n            _next = self.next\n\n        return b''.join(r)\n", "patch": "@@ -14,9 +14,12 @@\n \"\"\"\n \n import html\n+import os\n import struct\n from email.generator import _make_boundary\n from io import BytesIO\n+from mimetypes import guess_extension\n+from urllib.parse import quote\n from xml.dom import minidom\n \n import ZPublisher.HTTPRequest\n@@ -48,6 +51,64 @@\n from ZPublisher.HTTPRequest import FileUpload\n \n \n+def _get_list_from_env(name, default=None):\n+    \"\"\"Get list from environment variable.\n+\n+    Supports splitting on comma or white space.\n+    Use the default as fallback only when the variable is not set.\n+    So if the env variable is set to an empty string, this will ignore the\n+    default and return an empty list.\n+    \"\"\"\n+    value = os.environ.get(name)\n+    if value is None:\n+        return default or []\n+    value = value.strip()\n+    if \",\" in value:\n+        return value.split(\",\")\n+    return value.split()\n+\n+\n+# We have one list for allowed, and one for disallowed inline mimetypes.\n+# This is for security purposes.\n+# By default we use the allowlist.  We give integrators the option to choose\n+# the denylist via an environment variable.\n+ALLOWED_INLINE_MIMETYPES = _get_list_from_env(\n+    \"ALLOWED_INLINE_MIMETYPES\",\n+    default=[\n+        \"image/gif\",\n+        # The mimetypes registry lists several for jpeg 2000:\n+        \"image/jp2\",\n+        \"image/jpeg\",\n+        \"image/jpeg2000-image\",\n+        \"image/jpeg2000\",\n+        \"image/jpx\",\n+        \"image/png\",\n+        \"image/webp\",\n+        \"image/x-icon\",\n+        \"image/x-jpeg2000-image\",\n+        \"text/plain\",\n+        # By popular request we allow PDF:\n+        \"application/pdf\",\n+    ]\n+)\n+DISALLOWED_INLINE_MIMETYPES = _get_list_from_env(\n+    \"DISALLOWED_INLINE_MIMETYPES\",\n+    default=[\n+        \"application/javascript\",\n+        \"application/x-javascript\",\n+        \"text/javascript\",\n+        \"text/html\",\n+        \"image/svg+xml\",\n+        \"image/svg+xml-compressed\",\n+    ]\n+)\n+try:\n+    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")\n+    USE_DENYLIST = bool(int(USE_DENYLIST))\n+except (ValueError, TypeError, AttributeError):\n+    USE_DENYLIST = False\n+\n+\n manage_addFileForm = DTMLFile(\n     'dtml/imageAdd',\n     globals(),\n@@ -107,6 +168,13 @@ class File(\n     Cacheable\n ):\n     \"\"\"A File object is a content object for arbitrary files.\"\"\"\n+    # You can control which mimetypes may be shown inline\n+    # and which must always be downloaded, for security reasons.\n+    # Make the configuration available on the class.\n+    # Then subclasses can override this.\n+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n+    use_denylist = USE_DENYLIST\n \n     meta_type = 'File'\n     zmi_icon = 'far fa-file-archive'\n@@ -403,6 +471,19 @@ def _range_request_handler(self, REQUEST, RESPONSE):\n                         b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')\n                     return True\n \n+    def _should_force_download(self):\n+        # If this returns True, the caller should set a\n+        # Content-Disposition header with filename.\n+        mimetype = self.content_type\n+        if not mimetype:\n+            return False\n+        if self.use_denylist:\n+            # We explicitly deny a few mimetypes, and allow the rest.\n+            return mimetype in self.disallowed_inline_mimetypes\n+        # Use the allowlist.\n+        # We only explicitly allow a few mimetypes, and deny the rest.\n+        return mimetype not in self.allowed_inline_mimetypes\n+\n     @security.protected(View)\n     def index_html(self, REQUEST, RESPONSE):\n         \"\"\"\n@@ -441,6 +522,22 @@ def index_html(self, REQUEST, RESPONSE):\n         RESPONSE.setHeader('Content-Length', self.size)\n         RESPONSE.setHeader('Accept-Ranges', 'bytes')\n \n+        if self._should_force_download():\n+            # We need a filename, even a dummy one if needed.\n+            filename = self.getId()\n+            if \".\" not in filename:\n+                # This either returns None or \".some_extension\"\n+                ext = guess_extension(self.content_type, strict=False)\n+                if not ext:\n+                    # image/svg+xml -> svg\n+                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]\n+                filename += f\"{ext}\"\n+            filename = quote(filename.encode(\"utf8\"))\n+            RESPONSE.setHeader(\n+                \"Content-Disposition\",\n+                f\"attachment; filename*=UTF-8''{filename}\",\n+            )\n+\n         if self.ZCacheable_isCachingEnabled():\n             result = self.ZCacheable_get(default=None)\n             if result is not None:", "file_path": "files/2023_9/162", "file_language": "py", "file_name": "src/OFS/Image.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/zopefoundation/Zope/raw/603b0a12881c90a072a7a65e32d47ed898ce37cb/src%2FOFS%2Ftests%2FtestFileAndImage.py", "code": "import os\nimport sys\nimport time\nimport unittest\nfrom io import BytesIO\n\nimport OFS.Image\nimport Testing.testbrowser\nimport Testing.ZopeTestCase\nimport transaction\nimport Zope2\nfrom Acquisition import aq_base\nfrom OFS.Application import Application\nfrom OFS.Cache import ZCM_MANAGERS\nfrom OFS.Image import Pdata\nfrom OFS.SimpleItem import SimpleItem\nfrom Testing.makerequest import makerequest\nfrom zExceptions import Redirect\nfrom zope.component import adapter\nfrom zope.datetime import rfc1123_date\nfrom zope.lifecycleevent.interfaces import IObjectCreatedEvent\nfrom zope.lifecycleevent.interfaces import IObjectModifiedEvent\nfrom ZPublisher.HTTPRequest import HTTPRequest\nfrom ZPublisher.HTTPResponse import HTTPResponse\n\n\nhere = os.path.dirname(os.path.abspath(__file__))\nfiledata = os.path.join(here, 'test.gif')\n\nZope2.startup_wsgi()\n\n\ndef makeConnection():\n    import ZODB\n    from ZODB.DemoStorage import DemoStorage\n\n    s = DemoStorage()\n    return ZODB.DB(s).open()\n\n\ndef aputrequest(file, content_type):\n    resp = HTTPResponse(stdout=sys.stdout)\n    environ = {}\n    environ['SERVER_NAME'] = 'foo'\n    environ['SERVER_PORT'] = '80'\n    environ['REQUEST_METHOD'] = 'PUT'\n    environ['CONTENT_TYPE'] = content_type\n    req = HTTPRequest(stdin=file, environ=environ, response=resp)\n    return req\n\n\nclass DummyCache:\n\n    def __init__(self):\n        self.clear()\n\n    def ZCache_set(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.set = (ob, data)\n\n    def ZCache_get(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.get = ob\n        if self.si:\n            return self.si\n\n    def ZCache_invalidate(self, ob):\n        self.invalidated = ob\n\n    def clear(self):\n        self.set = None\n        self.get = None\n        self.invalidated = None\n        self.si = None\n\n    def setStreamIterator(self, si):\n        self.si = si\n\n\nADummyCache = DummyCache()\n\n\nclass DummyCacheManager(SimpleItem):\n    def ZCacheManager_getCache(self):\n        return ADummyCache\n\n\nclass EventCatcher:\n\n    def __init__(self):\n        self.created = []\n        self.modified = []\n        self.setUp()\n\n    def setUp(self):\n        from zope.component import provideHandler\n        provideHandler(self.handleCreated)\n        provideHandler(self.handleModified)\n\n    def tearDown(self):\n        from zope.component import getSiteManager\n        getSiteManager().unregisterHandler(self.handleCreated)\n        getSiteManager().unregisterHandler(self.handleModified)\n\n    def reset(self):\n        self.created = []\n        self.modified = []\n\n    @adapter(IObjectCreatedEvent)\n    def handleCreated(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.created.append(event)\n\n    @adapter(IObjectModifiedEvent)\n    def handleModified(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.modified.append(event)\n\n\nclass FileTests(unittest.TestCase):\n    content_type = 'application/octet-stream'\n    factory = 'manage_addFile'\n\n    def setUp(self):\n        with open(filedata, 'rb') as fd:\n            self.data = fd.read()\n        self.connection = makeConnection()\n        self.eventCatcher = EventCatcher()\n        try:\n            r = self.connection.root()\n            a = Application()\n            r['Application'] = a\n            self.root = a\n            responseOut = self.responseOut = BytesIO()\n            self.app = makerequest(self.root, stdout=responseOut)\n            self.app.dcm = DummyCacheManager()\n            factory = getattr(self.app, self.factory)\n            factory('file',\n                    file=self.data, content_type=self.content_type)\n            self.app.file.ZCacheable_setManagerId('dcm')\n            self.app.file.ZCacheable_setEnabled(enabled=1)\n            setattr(self.app, ZCM_MANAGERS, ('dcm',))\n            # Hack, we need a _p_mtime for the file, so we make sure that it\n            # has one.\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        self.file = getattr(self.app, 'file')\n\n        # Since we do the create here, let's test the events here too\n        self.assertEqual(1, len(self.eventCatcher.created))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.eventCatcher.reset()\n\n    def tearDown(self):\n        del self.file\n        transaction.abort()\n        self.connection.close()\n        del self.app\n        del self.responseOut\n        del self.root\n        del self.connection\n        ADummyCache.clear()\n        self.eventCatcher.tearDown()\n\n    def testViewImageOrFile(self):\n        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')\n\n    def testUpdateData(self):\n        self.file.update_data(b'foo')\n        self.assertEqual(self.file.size, 3)\n        self.assertEqual(self.file.data, b'foo')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testReadData(self):\n        s = b'a' * (2 << 16)\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertIsInstance(data, Pdata)\n        self.assertEqual(bytes(data), s)\n        self.assertEqual(len(s), len(bytes(data)))\n        self.assertEqual(len(s), size)\n\n    def testBigPdata(self):\n        # Test that a big enough string is split into several Pdata\n        # From a file\n        s = b'a' * (1 << 16) * 3\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertNotEqual(data.next, None)\n        # From a string\n        data, size = self.file._read_data(s)\n        self.assertNotEqual(data.next, None)\n\n    def testManageEditWithFileData(self):\n        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageEditWithoutFileData(self):\n        self.file.manage_edit('foobar', 'text/plain')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUpload(self):\n        f = BytesIO(b'jammyjohnson')\n        self.file.manage_upload(f)\n        self.assertEqual(self.file.data, b'jammyjohnson')\n        self.assertEqual(self.file.content_type, 'application/octet-stream')\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUploadWithoutFileData(self):\n        self.file.manage_upload()\n        self.assertEqual(0, len(self.eventCatcher.modified))\n\n    def testIfModSince(self):\n        now = time.time()\n        e = {'SERVER_NAME': 'foo',\n             'SERVER_PORT': '80',\n             'REQUEST_METHOD': 'GET'}\n\n        # not modified since\n        t_notmod = rfc1123_date(now)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 304)\n        self.assertEqual(data, b'')\n\n        # modified since\n        t_mod = rfc1123_date(now - 100)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_mod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 200)\n        self.assertEqual(data, bytes(self.file.data))\n\n    def testPUT(self):\n        s = b'# some python\\n'\n\n        # with content type\n        data = BytesIO(s)\n        req = aputrequest(data, 'text/x-python')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n        # without content type\n        data.seek(0)\n        req = aputrequest(data, '')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n    def testIndexHtmlWithPdata(self):\n        self.file.manage_upload(b'a' * (2 << 16))  # 128K\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)\n\n    def testIndexHtmlWithString(self):\n        self.file.manage_upload(b'a' * 100)  # 100 bytes\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)\n\n    def testPrincipiaSearchSource_not_text(self):\n        data = ''.join([chr(x) for x in range(256)])\n        data = data.encode('utf-8')\n        self.file.manage_edit('foobar', 'application/octet-stream',\n                              filedata=data)\n        self.assertEqual(self.file.PrincipiaSearchSource(), b'')\n\n    def testPrincipiaSearchSource_text(self):\n        self.file.manage_edit('foobar', 'text/plain',\n                              filedata=b'Now is the time for all good men to '\n                                       b'come to the aid of the Party.')\n        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())\n\n    def test_manage_DAVget_binary(self):\n        self.assertEqual(self.file.manage_DAVget(), self.data)\n\n    def test_manage_DAVget_text(self):\n        text = (b'Now is the time for all good men to '\n                b'come to the aid of the Party.')\n        self.file.manage_edit('foobar', 'text/plain', filedata=text)\n        self.assertEqual(self.file.manage_DAVget(), text)\n\n    def test_interfaces(self):\n        from OFS.Image import File\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface\n\n        verifyClass(HTTPRangeInterface, File)\n        verifyClass(IWriteLock, File)\n\n    def testUnicode(self):\n        val = 'some unicode string here'\n\n        self.assertRaises(TypeError, self.file.update_data,\n                          data=val, content_type='text/plain')\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertEqual(str(self.file), small_data.decode())\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertEqual(str(self.file), big_data.decode())\n\n\nclass ImageTests(FileTests):\n    content_type = 'image/gif'\n    factory = 'manage_addImage'\n\n    def testUpdateData(self):\n        self.file.update_data(self.data)\n        self.assertEqual(self.file.size, len(self.data))\n        self.assertEqual(self.file.data, self.data)\n        self.assertEqual(self.file.width, 16)\n        self.assertEqual(self.file.height, 16)\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testTag(self):\n        tag_fmt = ('<img src=\"http://nohost/file\" '\n                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))\n        self.file.manage_changeProperties(title='foo')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))\n        self.file.manage_changeProperties(alt='bar')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))\n\n    testStr = testTag\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertIsInstance(str(self.file), str)\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertIsInstance(str(self.file), str)\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertIsNone(response.getHeader(\"Content-Disposition\"))\n\n    def test_interfaces(self):\n        from OFS.Image import Image\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n\n        verifyClass(IWriteLock, Image)\n\n    def test_text_representation_is_tag(self):\n        self.assertEqual(str(self.file),\n                         '<img src=\"http://nohost/file\"'\n                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')\n\n\nclass SVGTests(ImageTests):\n    content_type = 'image/svg+xml'\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''file.svg\",\n        )\n\n    def testViewImageOrFileNonAscii(self):\n        try:\n            factory = getattr(self.app, self.factory)\n            factory('h\u00e4llo',\n                    file=self.data, content_type=self.content_type)\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        image = getattr(self.app, 'h\u00e4llo')\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = image.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\",\n        )\n\n    def testViewImageOrFile_with_denylist(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        self.file.use_denylist = True\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''file.svg\",\n        )\n\n    def testViewImageOrFile_with_empty_denylist(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        self.file.use_denylist = True\n        self.file.disallowed_inline_mimetypes = []\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertIsNone(response.getHeader(\"Content-Disposition\"))\n\n\nclass FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):\n    \"\"\"Browser testing ..Image.File\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        uf = self.app.acl_users\n        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])\n        self.app.manage_addFile('file')\n\n        transaction.commit()\n        self.browser = Testing.testbrowser.Browser()\n        self.browser.login('manager', 'manager_pass')\n\n    def test_Image__manage_main__1(self):\n        \"\"\"It shows the content of text files as text.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode())\n        self.browser.open('http://localhost/file/manage_main')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'h\u00e4llo')\n\n    def test_Image__manage_main__3(self):\n        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))\n        self.browser.open('http://localhost/file/manage_main')\n        self.assertIn(\n            \"The file could not be decoded with 'utf-8'.\",\n            self.browser.contents)\n\n    def test_Image__manage_upload__1(self):\n        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        self.browser.getControl(name='file').add_file(\n            b'test text file', 'text/plain', 'TestFile.txt')\n        self.browser.getControl('Upload File').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        self.assertEqual(\n            self.browser.getControl('Content Type').value, 'text/plain')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'test text file')\n\n    def test_Image__manage_edit__1(self):\n        \"\"\"It it possible to change the file's content via browser.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        text_1 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_1, '')\n        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'\n        self.browser.getControl('Save Changes').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        text_2 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_2, 'h\u00e4llo')\n", "code_before": "import os\nimport sys\nimport time\nimport unittest\nfrom io import BytesIO\n\nimport OFS.Image\nimport Testing.testbrowser\nimport Testing.ZopeTestCase\nimport transaction\nimport Zope2\nfrom Acquisition import aq_base\nfrom OFS.Application import Application\nfrom OFS.Cache import ZCM_MANAGERS\nfrom OFS.Image import Pdata\nfrom OFS.SimpleItem import SimpleItem\nfrom Testing.makerequest import makerequest\nfrom zExceptions import Redirect\nfrom zope.component import adapter\nfrom zope.datetime import rfc1123_date\nfrom zope.lifecycleevent.interfaces import IObjectCreatedEvent\nfrom zope.lifecycleevent.interfaces import IObjectModifiedEvent\nfrom ZPublisher.HTTPRequest import HTTPRequest\nfrom ZPublisher.HTTPResponse import HTTPResponse\n\n\nhere = os.path.dirname(os.path.abspath(__file__))\nfiledata = os.path.join(here, 'test.gif')\n\nZope2.startup_wsgi()\n\n\ndef makeConnection():\n    import ZODB\n    from ZODB.DemoStorage import DemoStorage\n\n    s = DemoStorage()\n    return ZODB.DB(s).open()\n\n\ndef aputrequest(file, content_type):\n    resp = HTTPResponse(stdout=sys.stdout)\n    environ = {}\n    environ['SERVER_NAME'] = 'foo'\n    environ['SERVER_PORT'] = '80'\n    environ['REQUEST_METHOD'] = 'PUT'\n    environ['CONTENT_TYPE'] = content_type\n    req = HTTPRequest(stdin=file, environ=environ, response=resp)\n    return req\n\n\nclass DummyCache:\n\n    def __init__(self):\n        self.clear()\n\n    def ZCache_set(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.set = (ob, data)\n\n    def ZCache_get(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.get = ob\n        if self.si:\n            return self.si\n\n    def ZCache_invalidate(self, ob):\n        self.invalidated = ob\n\n    def clear(self):\n        self.set = None\n        self.get = None\n        self.invalidated = None\n        self.si = None\n\n    def setStreamIterator(self, si):\n        self.si = si\n\n\nADummyCache = DummyCache()\n\n\nclass DummyCacheManager(SimpleItem):\n    def ZCacheManager_getCache(self):\n        return ADummyCache\n\n\nclass EventCatcher:\n\n    def __init__(self):\n        self.created = []\n        self.modified = []\n        self.setUp()\n\n    def setUp(self):\n        from zope.component import provideHandler\n        provideHandler(self.handleCreated)\n        provideHandler(self.handleModified)\n\n    def tearDown(self):\n        from zope.component import getSiteManager\n        getSiteManager().unregisterHandler(self.handleCreated)\n        getSiteManager().unregisterHandler(self.handleModified)\n\n    def reset(self):\n        self.created = []\n        self.modified = []\n\n    @adapter(IObjectCreatedEvent)\n    def handleCreated(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.created.append(event)\n\n    @adapter(IObjectModifiedEvent)\n    def handleModified(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.modified.append(event)\n\n\nclass FileTests(unittest.TestCase):\n    content_type = 'application/octet-stream'\n    factory = 'manage_addFile'\n\n    def setUp(self):\n        with open(filedata, 'rb') as fd:\n            self.data = fd.read()\n        self.connection = makeConnection()\n        self.eventCatcher = EventCatcher()\n        try:\n            r = self.connection.root()\n            a = Application()\n            r['Application'] = a\n            self.root = a\n            responseOut = self.responseOut = BytesIO()\n            self.app = makerequest(self.root, stdout=responseOut)\n            self.app.dcm = DummyCacheManager()\n            factory = getattr(self.app, self.factory)\n            factory('file',\n                    file=self.data, content_type=self.content_type)\n            self.app.file.ZCacheable_setManagerId('dcm')\n            self.app.file.ZCacheable_setEnabled(enabled=1)\n            setattr(self.app, ZCM_MANAGERS, ('dcm',))\n            # Hack, we need a _p_mtime for the file, so we make sure that it\n            # has one.\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        self.file = getattr(self.app, 'file')\n\n        # Since we do the create here, let's test the events here too\n        self.assertEqual(1, len(self.eventCatcher.created))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.eventCatcher.reset()\n\n    def tearDown(self):\n        del self.file\n        transaction.abort()\n        self.connection.close()\n        del self.app\n        del self.responseOut\n        del self.root\n        del self.connection\n        ADummyCache.clear()\n        self.eventCatcher.tearDown()\n\n    def testViewImageOrFile(self):\n        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')\n\n    def testUpdateData(self):\n        self.file.update_data(b'foo')\n        self.assertEqual(self.file.size, 3)\n        self.assertEqual(self.file.data, b'foo')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testReadData(self):\n        s = b'a' * (2 << 16)\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertIsInstance(data, Pdata)\n        self.assertEqual(bytes(data), s)\n        self.assertEqual(len(s), len(bytes(data)))\n        self.assertEqual(len(s), size)\n\n    def testBigPdata(self):\n        # Test that a big enough string is split into several Pdata\n        # From a file\n        s = b'a' * (1 << 16) * 3\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertNotEqual(data.next, None)\n        # From a string\n        data, size = self.file._read_data(s)\n        self.assertNotEqual(data.next, None)\n\n    def testManageEditWithFileData(self):\n        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageEditWithoutFileData(self):\n        self.file.manage_edit('foobar', 'text/plain')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUpload(self):\n        f = BytesIO(b'jammyjohnson')\n        self.file.manage_upload(f)\n        self.assertEqual(self.file.data, b'jammyjohnson')\n        self.assertEqual(self.file.content_type, 'application/octet-stream')\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUploadWithoutFileData(self):\n        self.file.manage_upload()\n        self.assertEqual(0, len(self.eventCatcher.modified))\n\n    def testIfModSince(self):\n        now = time.time()\n        e = {'SERVER_NAME': 'foo',\n             'SERVER_PORT': '80',\n             'REQUEST_METHOD': 'GET'}\n\n        # not modified since\n        t_notmod = rfc1123_date(now)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 304)\n        self.assertEqual(data, b'')\n\n        # modified since\n        t_mod = rfc1123_date(now - 100)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_mod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 200)\n        self.assertEqual(data, bytes(self.file.data))\n\n    def testPUT(self):\n        s = b'# some python\\n'\n\n        # with content type\n        data = BytesIO(s)\n        req = aputrequest(data, 'text/x-python')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n        # without content type\n        data.seek(0)\n        req = aputrequest(data, '')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n    def testIndexHtmlWithPdata(self):\n        self.file.manage_upload(b'a' * (2 << 16))  # 128K\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)\n\n    def testIndexHtmlWithString(self):\n        self.file.manage_upload(b'a' * 100)  # 100 bytes\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)\n\n    def testPrincipiaSearchSource_not_text(self):\n        data = ''.join([chr(x) for x in range(256)])\n        data = data.encode('utf-8')\n        self.file.manage_edit('foobar', 'application/octet-stream',\n                              filedata=data)\n        self.assertEqual(self.file.PrincipiaSearchSource(), b'')\n\n    def testPrincipiaSearchSource_text(self):\n        self.file.manage_edit('foobar', 'text/plain',\n                              filedata=b'Now is the time for all good men to '\n                                       b'come to the aid of the Party.')\n        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())\n\n    def test_manage_DAVget_binary(self):\n        self.assertEqual(self.file.manage_DAVget(), self.data)\n\n    def test_manage_DAVget_text(self):\n        text = (b'Now is the time for all good men to '\n                b'come to the aid of the Party.')\n        self.file.manage_edit('foobar', 'text/plain', filedata=text)\n        self.assertEqual(self.file.manage_DAVget(), text)\n\n    def test_interfaces(self):\n        from OFS.Image import File\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface\n\n        verifyClass(HTTPRangeInterface, File)\n        verifyClass(IWriteLock, File)\n\n    def testUnicode(self):\n        val = 'some unicode string here'\n\n        self.assertRaises(TypeError, self.file.update_data,\n                          data=val, content_type='text/plain')\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertEqual(str(self.file), small_data.decode())\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertEqual(str(self.file), big_data.decode())\n\n\nclass ImageTests(FileTests):\n    content_type = 'image/gif'\n    factory = 'manage_addImage'\n\n    def testUpdateData(self):\n        self.file.update_data(self.data)\n        self.assertEqual(self.file.size, len(self.data))\n        self.assertEqual(self.file.data, self.data)\n        self.assertEqual(self.file.width, 16)\n        self.assertEqual(self.file.height, 16)\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testTag(self):\n        tag_fmt = ('<img src=\"http://nohost/file\" '\n                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))\n        self.file.manage_changeProperties(title='foo')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))\n        self.file.manage_changeProperties(alt='bar')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))\n\n    testStr = testTag\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertIsInstance(str(self.file), str)\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertIsInstance(str(self.file), str)\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n\n    def test_interfaces(self):\n        from OFS.Image import Image\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n\n        verifyClass(IWriteLock, Image)\n\n    def test_text_representation_is_tag(self):\n        self.assertEqual(str(self.file),\n                         '<img src=\"http://nohost/file\"'\n                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')\n\n\nclass FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):\n    \"\"\"Browser testing ..Image.File\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        uf = self.app.acl_users\n        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])\n        self.app.manage_addFile('file')\n\n        transaction.commit()\n        self.browser = Testing.testbrowser.Browser()\n        self.browser.login('manager', 'manager_pass')\n\n    def test_Image__manage_main__1(self):\n        \"\"\"It shows the content of text files as text.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode())\n        self.browser.open('http://localhost/file/manage_main')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'h\u00e4llo')\n\n    def test_Image__manage_main__3(self):\n        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))\n        self.browser.open('http://localhost/file/manage_main')\n        self.assertIn(\n            \"The file could not be decoded with 'utf-8'.\",\n            self.browser.contents)\n\n    def test_Image__manage_upload__1(self):\n        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        self.browser.getControl(name='file').add_file(\n            b'test text file', 'text/plain', 'TestFile.txt')\n        self.browser.getControl('Upload File').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        self.assertEqual(\n            self.browser.getControl('Content Type').value, 'text/plain')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'test text file')\n\n    def test_Image__manage_edit__1(self):\n        \"\"\"It it possible to change the file's content via browser.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        text_1 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_1, '')\n        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'\n        self.browser.getControl('Save Changes').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        text_2 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_2, 'h\u00e4llo')\n", "patch": "@@ -373,6 +373,7 @@ def testViewImageOrFile(self):\n         response = request.RESPONSE\n         result = self.file.index_html(request, response)\n         self.assertEqual(result, self.data)\n+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))\n \n     def test_interfaces(self):\n         from OFS.Image import Image\n@@ -387,6 +388,61 @@ def test_text_representation_is_tag(self):\n                          ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')\n \n \n+class SVGTests(ImageTests):\n+    content_type = 'image/svg+xml'\n+\n+    def testViewImageOrFile(self):\n+        request = self.app.REQUEST\n+        response = request.RESPONSE\n+        result = self.file.index_html(request, response)\n+        self.assertEqual(result, self.data)\n+        self.assertEqual(\n+            response.getHeader(\"Content-Disposition\"),\n+            \"attachment; filename*=UTF-8''file.svg\",\n+        )\n+\n+    def testViewImageOrFileNonAscii(self):\n+        try:\n+            factory = getattr(self.app, self.factory)\n+            factory('h\u00e4llo',\n+                    file=self.data, content_type=self.content_type)\n+            transaction.commit()\n+        except Exception:\n+            transaction.abort()\n+            self.connection.close()\n+            raise\n+        transaction.begin()\n+        image = getattr(self.app, 'h\u00e4llo')\n+        request = self.app.REQUEST\n+        response = request.RESPONSE\n+        result = image.index_html(request, response)\n+        self.assertEqual(result, self.data)\n+        self.assertEqual(\n+            response.getHeader(\"Content-Disposition\"),\n+            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\",\n+        )\n+\n+    def testViewImageOrFile_with_denylist(self):\n+        request = self.app.REQUEST\n+        response = request.RESPONSE\n+        self.file.use_denylist = True\n+        result = self.file.index_html(request, response)\n+        self.assertEqual(result, self.data)\n+        self.assertEqual(\n+            response.getHeader(\"Content-Disposition\"),\n+            \"attachment; filename*=UTF-8''file.svg\",\n+        )\n+\n+    def testViewImageOrFile_with_empty_denylist(self):\n+        request = self.app.REQUEST\n+        response = request.RESPONSE\n+        self.file.use_denylist = True\n+        self.file.disallowed_inline_mimetypes = []\n+        result = self.file.index_html(request, response)\n+        self.assertEqual(result, self.data)\n+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))\n+\n+\n class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):\n     \"\"\"Browser testing ..Image.File\"\"\"\n ", "file_path": "files/2023_9/163", "file_language": "py", "file_name": "src/OFS/tests/testFileAndImage.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def makeConnection():\n    import ZODB\n    from ZODB.DemoStorage import DemoStorage\n\n    s = DemoStorage()\n    return ZODB.DB(s).open()", "target": 0}, {"function": "def aputrequest(file, content_type):\n    resp = HTTPResponse(stdout=sys.stdout)\n    environ = {}\n    environ['SERVER_NAME'] = 'foo'\n    environ['SERVER_PORT'] = '80'\n    environ['REQUEST_METHOD'] = 'PUT'\n    environ['CONTENT_TYPE'] = content_type\n    req = HTTPRequest(stdin=file, environ=environ, response=resp)\n    return req", "target": 0}, {"function": "class DummyCache:\n\n    def __init__(self):\n        self.clear()\n\n    def ZCache_set(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.set = (ob, data)\n\n    def ZCache_get(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.get = ob\n        if self.si:\n            return self.si\n\n    def ZCache_invalidate(self, ob):\n        self.invalidated = ob\n\n    def clear(self):\n        self.set = None\n        self.get = None\n        self.invalidated = None\n        self.si = None\n\n    def setStreamIterator(self, si):\n        self.si = si", "target": 0}, {"function": "class DummyCacheManager(SimpleItem):\n    def ZCacheManager_getCache(self):\n        return ADummyCache", "target": 0}, {"function": "class EventCatcher:\n\n    def __init__(self):\n        self.created = []\n        self.modified = []\n        self.setUp()\n\n    def setUp(self):\n        from zope.component import provideHandler\n        provideHandler(self.handleCreated)\n        provideHandler(self.handleModified)\n\n    def tearDown(self):\n        from zope.component import getSiteManager\n        getSiteManager().unregisterHandler(self.handleCreated)\n        getSiteManager().unregisterHandler(self.handleModified)\n\n    def reset(self):\n        self.created = []\n        self.modified = []\n\n    @adapter(IObjectCreatedEvent)\n    def handleCreated(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.created.append(event)\n\n    @adapter(IObjectModifiedEvent)\n    def handleModified(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.modified.append(event)", "target": 0}, {"function": "class FileTests(unittest.TestCase):\n    content_type = 'application/octet-stream'\n    factory = 'manage_addFile'\n\n    def setUp(self):\n        with open(filedata, 'rb') as fd:\n            self.data = fd.read()\n        self.connection = makeConnection()\n        self.eventCatcher = EventCatcher()\n        try:\n            r = self.connection.root()\n            a = Application()\n            r['Application'] = a\n            self.root = a\n            responseOut = self.responseOut = BytesIO()\n            self.app = makerequest(self.root, stdout=responseOut)\n            self.app.dcm = DummyCacheManager()\n            factory = getattr(self.app, self.factory)\n            factory('file',\n                    file=self.data, content_type=self.content_type)\n            self.app.file.ZCacheable_setManagerId('dcm')\n            self.app.file.ZCacheable_setEnabled(enabled=1)\n            setattr(self.app, ZCM_MANAGERS, ('dcm',))\n            # Hack, we need a _p_mtime for the file, so we make sure that it\n            # has one.\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        self.file = getattr(self.app, 'file')\n\n        # Since we do the create here, let's test the events here too\n        self.assertEqual(1, len(self.eventCatcher.created))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.eventCatcher.reset()\n\n    def tearDown(self):\n        del self.file\n        transaction.abort()\n        self.connection.close()\n        del self.app\n        del self.responseOut\n        del self.root\n        del self.connection\n        ADummyCache.clear()\n        self.eventCatcher.tearDown()\n\n    def testViewImageOrFile(self):\n        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')\n\n    def testUpdateData(self):\n        self.file.update_data(b'foo')\n        self.assertEqual(self.file.size, 3)\n        self.assertEqual(self.file.data, b'foo')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testReadData(self):\n        s = b'a' * (2 << 16)\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertIsInstance(data, Pdata)\n        self.assertEqual(bytes(data), s)\n        self.assertEqual(len(s), len(bytes(data)))\n        self.assertEqual(len(s), size)\n\n    def testBigPdata(self):\n        # Test that a big enough string is split into several Pdata\n        # From a file\n        s = b'a' * (1 << 16) * 3\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertNotEqual(data.next, None)\n        # From a string\n        data, size = self.file._read_data(s)\n        self.assertNotEqual(data.next, None)\n\n    def testManageEditWithFileData(self):\n        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageEditWithoutFileData(self):\n        self.file.manage_edit('foobar', 'text/plain')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUpload(self):\n        f = BytesIO(b'jammyjohnson')\n        self.file.manage_upload(f)\n        self.assertEqual(self.file.data, b'jammyjohnson')\n        self.assertEqual(self.file.content_type, 'application/octet-stream')\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUploadWithoutFileData(self):\n        self.file.manage_upload()\n        self.assertEqual(0, len(self.eventCatcher.modified))\n\n    def testIfModSince(self):\n        now = time.time()\n        e = {'SERVER_NAME': 'foo',\n             'SERVER_PORT': '80',\n             'REQUEST_METHOD': 'GET'}\n\n        # not modified since\n        t_notmod = rfc1123_date(now)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 304)\n        self.assertEqual(data, b'')\n\n        # modified since\n        t_mod = rfc1123_date(now - 100)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_mod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 200)\n        self.assertEqual(data, bytes(self.file.data))\n\n    def testPUT(self):\n        s = b'# some python\\n'\n\n        # with content type\n        data = BytesIO(s)\n        req = aputrequest(data, 'text/x-python')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n        # without content type\n        data.seek(0)\n        req = aputrequest(data, '')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n    def testIndexHtmlWithPdata(self):\n        self.file.manage_upload(b'a' * (2 << 16))  # 128K\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)\n\n    def testIndexHtmlWithString(self):\n        self.file.manage_upload(b'a' * 100)  # 100 bytes\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)\n\n    def testPrincipiaSearchSource_not_text(self):\n        data = ''.join([chr(x) for x in range(256)])\n        data = data.encode('utf-8')\n        self.file.manage_edit('foobar', 'application/octet-stream',\n                              filedata=data)\n        self.assertEqual(self.file.PrincipiaSearchSource(), b'')\n\n    def testPrincipiaSearchSource_text(self):\n        self.file.manage_edit('foobar', 'text/plain',\n                              filedata=b'Now is the time for all good men to '\n                                       b'come to the aid of the Party.')\n        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())\n\n    def test_manage_DAVget_binary(self):\n        self.assertEqual(self.file.manage_DAVget(), self.data)\n\n    def test_manage_DAVget_text(self):\n        text = (b'Now is the time for all good men to '\n                b'come to the aid of the Party.')\n        self.file.manage_edit('foobar', 'text/plain', filedata=text)\n        self.assertEqual(self.file.manage_DAVget(), text)\n\n    def test_interfaces(self):\n        from OFS.Image import File\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface\n\n        verifyClass(HTTPRangeInterface, File)\n        verifyClass(IWriteLock, File)\n\n    def testUnicode(self):\n        val = 'some unicode string here'\n\n        self.assertRaises(TypeError, self.file.update_data,\n                          data=val, content_type='text/plain')\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertEqual(str(self.file), small_data.decode())\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertEqual(str(self.file), big_data.decode())", "target": 0}, {"function": "class ImageTests(FileTests):\n    content_type = 'image/gif'\n    factory = 'manage_addImage'\n\n    def testUpdateData(self):\n        self.file.update_data(self.data)\n        self.assertEqual(self.file.size, len(self.data))\n        self.assertEqual(self.file.data, self.data)\n        self.assertEqual(self.file.width, 16)\n        self.assertEqual(self.file.height, 16)\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testTag(self):\n        tag_fmt = ('<img src=\"http://nohost/file\" '\n                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))\n        self.file.manage_changeProperties(title='foo')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))\n        self.file.manage_changeProperties(alt='bar')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))\n\n    testStr = testTag\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertIsInstance(str(self.file), str)\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertIsInstance(str(self.file), str)\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n\n    def test_interfaces(self):\n        from OFS.Image import Image\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n\n        verifyClass(IWriteLock, Image)\n\n    def test_text_representation_is_tag(self):\n        self.assertEqual(str(self.file),\n                         '<img src=\"http://nohost/file\"'\n                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')", "target": 0}, {"function": "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):\n    \"\"\"Browser testing ..Image.File\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        uf = self.app.acl_users\n        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])\n        self.app.manage_addFile('file')\n\n        transaction.commit()\n        self.browser = Testing.testbrowser.Browser()\n        self.browser.login('manager', 'manager_pass')\n\n    def test_Image__manage_main__1(self):\n        \"\"\"It shows the content of text files as text.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode())\n        self.browser.open('http://localhost/file/manage_main')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'h\u00e4llo')\n\n    def test_Image__manage_main__3(self):\n        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))\n        self.browser.open('http://localhost/file/manage_main')\n        self.assertIn(\n            \"The file could not be decoded with 'utf-8'.\",\n            self.browser.contents)\n\n    def test_Image__manage_upload__1(self):\n        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        self.browser.getControl(name='file').add_file(\n            b'test text file', 'text/plain', 'TestFile.txt')\n        self.browser.getControl('Upload File').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        self.assertEqual(\n            self.browser.getControl('Content Type').value, 'text/plain')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'test text file')\n\n    def test_Image__manage_edit__1(self):\n        \"\"\"It it possible to change the file's content via browser.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        text_1 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_1, '')\n        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'\n        self.browser.getControl('Save Changes').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        text_2 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_2, 'h\u00e4llo')", "target": 0}], "function_after": [{"function": "def makeConnection():\n    import ZODB\n    from ZODB.DemoStorage import DemoStorage\n\n    s = DemoStorage()\n    return ZODB.DB(s).open()", "target": 0}, {"function": "def aputrequest(file, content_type):\n    resp = HTTPResponse(stdout=sys.stdout)\n    environ = {}\n    environ['SERVER_NAME'] = 'foo'\n    environ['SERVER_PORT'] = '80'\n    environ['REQUEST_METHOD'] = 'PUT'\n    environ['CONTENT_TYPE'] = content_type\n    req = HTTPRequest(stdin=file, environ=environ, response=resp)\n    return req", "target": 0}, {"function": "class DummyCache:\n\n    def __init__(self):\n        self.clear()\n\n    def ZCache_set(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.set = (ob, data)\n\n    def ZCache_get(self, ob, data, view_name='', keywords=None,\n                   mtime_func=None):\n        self.get = ob\n        if self.si:\n            return self.si\n\n    def ZCache_invalidate(self, ob):\n        self.invalidated = ob\n\n    def clear(self):\n        self.set = None\n        self.get = None\n        self.invalidated = None\n        self.si = None\n\n    def setStreamIterator(self, si):\n        self.si = si", "target": 0}, {"function": "class DummyCacheManager(SimpleItem):\n    def ZCacheManager_getCache(self):\n        return ADummyCache", "target": 0}, {"function": "class EventCatcher:\n\n    def __init__(self):\n        self.created = []\n        self.modified = []\n        self.setUp()\n\n    def setUp(self):\n        from zope.component import provideHandler\n        provideHandler(self.handleCreated)\n        provideHandler(self.handleModified)\n\n    def tearDown(self):\n        from zope.component import getSiteManager\n        getSiteManager().unregisterHandler(self.handleCreated)\n        getSiteManager().unregisterHandler(self.handleModified)\n\n    def reset(self):\n        self.created = []\n        self.modified = []\n\n    @adapter(IObjectCreatedEvent)\n    def handleCreated(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.created.append(event)\n\n    @adapter(IObjectModifiedEvent)\n    def handleModified(self, event):\n        if isinstance(event.object, OFS.Image.File):\n            self.modified.append(event)", "target": 0}, {"function": "class FileTests(unittest.TestCase):\n    content_type = 'application/octet-stream'\n    factory = 'manage_addFile'\n\n    def setUp(self):\n        with open(filedata, 'rb') as fd:\n            self.data = fd.read()\n        self.connection = makeConnection()\n        self.eventCatcher = EventCatcher()\n        try:\n            r = self.connection.root()\n            a = Application()\n            r['Application'] = a\n            self.root = a\n            responseOut = self.responseOut = BytesIO()\n            self.app = makerequest(self.root, stdout=responseOut)\n            self.app.dcm = DummyCacheManager()\n            factory = getattr(self.app, self.factory)\n            factory('file',\n                    file=self.data, content_type=self.content_type)\n            self.app.file.ZCacheable_setManagerId('dcm')\n            self.app.file.ZCacheable_setEnabled(enabled=1)\n            setattr(self.app, ZCM_MANAGERS, ('dcm',))\n            # Hack, we need a _p_mtime for the file, so we make sure that it\n            # has one.\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        self.file = getattr(self.app, 'file')\n\n        # Since we do the create here, let's test the events here too\n        self.assertEqual(1, len(self.eventCatcher.created))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(\n            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))\n\n        self.eventCatcher.reset()\n\n    def tearDown(self):\n        del self.file\n        transaction.abort()\n        self.connection.close()\n        del self.app\n        del self.responseOut\n        del self.root\n        del self.connection\n        ADummyCache.clear()\n        self.eventCatcher.tearDown()\n\n    def testViewImageOrFile(self):\n        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')\n\n    def testUpdateData(self):\n        self.file.update_data(b'foo')\n        self.assertEqual(self.file.size, 3)\n        self.assertEqual(self.file.data, b'foo')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testReadData(self):\n        s = b'a' * (2 << 16)\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertIsInstance(data, Pdata)\n        self.assertEqual(bytes(data), s)\n        self.assertEqual(len(s), len(bytes(data)))\n        self.assertEqual(len(s), size)\n\n    def testBigPdata(self):\n        # Test that a big enough string is split into several Pdata\n        # From a file\n        s = b'a' * (1 << 16) * 3\n        data, size = self.file._read_data(BytesIO(s))\n        self.assertNotEqual(data.next, None)\n        # From a string\n        data, size = self.file._read_data(s)\n        self.assertNotEqual(data.next, None)\n\n    def testManageEditWithFileData(self):\n        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageEditWithoutFileData(self):\n        self.file.manage_edit('foobar', 'text/plain')\n        self.assertEqual(self.file.title, 'foobar')\n        self.assertEqual(self.file.content_type, 'text/plain')\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUpload(self):\n        f = BytesIO(b'jammyjohnson')\n        self.file.manage_upload(f)\n        self.assertEqual(self.file.data, b'jammyjohnson')\n        self.assertEqual(self.file.content_type, 'application/octet-stream')\n        self.assertEqual(1, len(self.eventCatcher.modified))\n        self.assertTrue(self.eventCatcher.modified[0].object is self.file)\n\n    def testManageUploadWithoutFileData(self):\n        self.file.manage_upload()\n        self.assertEqual(0, len(self.eventCatcher.modified))\n\n    def testIfModSince(self):\n        now = time.time()\n        e = {'SERVER_NAME': 'foo',\n             'SERVER_PORT': '80',\n             'REQUEST_METHOD': 'GET'}\n\n        # not modified since\n        t_notmod = rfc1123_date(now)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 304)\n        self.assertEqual(data, b'')\n\n        # modified since\n        t_mod = rfc1123_date(now - 100)\n        e['HTTP_IF_MODIFIED_SINCE'] = t_mod\n        out = BytesIO()\n        resp = HTTPResponse(stdout=out)\n        req = HTTPRequest(sys.stdin, e, resp)\n        data = self.file.index_html(req, resp)\n        self.assertEqual(resp.getStatus(), 200)\n        self.assertEqual(data, bytes(self.file.data))\n\n    def testPUT(self):\n        s = b'# some python\\n'\n\n        # with content type\n        data = BytesIO(s)\n        req = aputrequest(data, 'text/x-python')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n        # without content type\n        data.seek(0)\n        req = aputrequest(data, '')\n        req.processInputs()\n        self.file.PUT(req, req.RESPONSE)\n\n        self.assertEqual(self.file.content_type, 'text/x-python')\n        self.assertEqual(self.file.data, s)\n\n    def testIndexHtmlWithPdata(self):\n        self.file.manage_upload(b'a' * (2 << 16))  # 128K\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)\n\n    def testIndexHtmlWithString(self):\n        self.file.manage_upload(b'a' * 100)  # 100 bytes\n        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)\n        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)\n\n    def testPrincipiaSearchSource_not_text(self):\n        data = ''.join([chr(x) for x in range(256)])\n        data = data.encode('utf-8')\n        self.file.manage_edit('foobar', 'application/octet-stream',\n                              filedata=data)\n        self.assertEqual(self.file.PrincipiaSearchSource(), b'')\n\n    def testPrincipiaSearchSource_text(self):\n        self.file.manage_edit('foobar', 'text/plain',\n                              filedata=b'Now is the time for all good men to '\n                                       b'come to the aid of the Party.')\n        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())\n\n    def test_manage_DAVget_binary(self):\n        self.assertEqual(self.file.manage_DAVget(), self.data)\n\n    def test_manage_DAVget_text(self):\n        text = (b'Now is the time for all good men to '\n                b'come to the aid of the Party.')\n        self.file.manage_edit('foobar', 'text/plain', filedata=text)\n        self.assertEqual(self.file.manage_DAVget(), text)\n\n    def test_interfaces(self):\n        from OFS.Image import File\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface\n\n        verifyClass(HTTPRangeInterface, File)\n        verifyClass(IWriteLock, File)\n\n    def testUnicode(self):\n        val = 'some unicode string here'\n\n        self.assertRaises(TypeError, self.file.update_data,\n                          data=val, content_type='text/plain')\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertEqual(str(self.file), small_data.decode())\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertEqual(str(self.file), big_data.decode())", "target": 0}, {"function": "class ImageTests(FileTests):\n    content_type = 'image/gif'\n    factory = 'manage_addImage'\n\n    def testUpdateData(self):\n        self.file.update_data(self.data)\n        self.assertEqual(self.file.size, len(self.data))\n        self.assertEqual(self.file.data, self.data)\n        self.assertEqual(self.file.width, 16)\n        self.assertEqual(self.file.height, 16)\n        self.assertTrue(ADummyCache.invalidated)\n        self.assertTrue(ADummyCache.set)\n\n    def testTag(self):\n        tag_fmt = ('<img src=\"http://nohost/file\" '\n                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))\n        self.file.manage_changeProperties(title='foo')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))\n        self.file.manage_changeProperties(alt='bar')\n        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))\n\n    testStr = testTag\n\n    def test__str__returns_native_string(self):\n        small_data = b'small data'\n        self.file.manage_upload(file=small_data)\n        self.assertIsInstance(str(self.file), str)\n\n        # Make sure Pdata contents are handled correctly\n        big_data = b'a' * (2 << 16)\n        self.file.manage_upload(file=big_data)\n        self.assertIsInstance(str(self.file), str)\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertIsNone(response.getHeader(\"Content-Disposition\"))\n\n    def test_interfaces(self):\n        from OFS.Image import Image\n        from OFS.interfaces import IWriteLock\n        from zope.interface.verify import verifyClass\n\n        verifyClass(IWriteLock, Image)\n\n    def test_text_representation_is_tag(self):\n        self.assertEqual(str(self.file),\n                         '<img src=\"http://nohost/file\"'\n                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')", "target": 0}, {"function": "class SVGTests(ImageTests):\n    content_type = 'image/svg+xml'\n\n    def testViewImageOrFile(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''file.svg\",\n        )\n\n    def testViewImageOrFileNonAscii(self):\n        try:\n            factory = getattr(self.app, self.factory)\n            factory('h\u00e4llo',\n                    file=self.data, content_type=self.content_type)\n            transaction.commit()\n        except Exception:\n            transaction.abort()\n            self.connection.close()\n            raise\n        transaction.begin()\n        image = getattr(self.app, 'h\u00e4llo')\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        result = image.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\",\n        )\n\n    def testViewImageOrFile_with_denylist(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        self.file.use_denylist = True\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertEqual(\n            response.getHeader(\"Content-Disposition\"),\n            \"attachment; filename*=UTF-8''file.svg\",\n        )\n\n    def testViewImageOrFile_with_empty_denylist(self):\n        request = self.app.REQUEST\n        response = request.RESPONSE\n        self.file.use_denylist = True\n        self.file.disallowed_inline_mimetypes = []\n        result = self.file.index_html(request, response)\n        self.assertEqual(result, self.data)\n        self.assertIsNone(response.getHeader(\"Content-Disposition\"))", "target": 0}, {"function": "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):\n    \"\"\"Browser testing ..Image.File\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        uf = self.app.acl_users\n        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])\n        self.app.manage_addFile('file')\n\n        transaction.commit()\n        self.browser = Testing.testbrowser.Browser()\n        self.browser.login('manager', 'manager_pass')\n\n    def test_Image__manage_main__1(self):\n        \"\"\"It shows the content of text files as text.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode())\n        self.browser.open('http://localhost/file/manage_main')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'h\u00e4llo')\n\n    def test_Image__manage_main__3(self):\n        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"\n        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))\n        self.browser.open('http://localhost/file/manage_main')\n        self.assertIn(\n            \"The file could not be decoded with 'utf-8'.\",\n            self.browser.contents)\n\n    def test_Image__manage_upload__1(self):\n        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        self.browser.getControl(name='file').add_file(\n            b'test text file', 'text/plain', 'TestFile.txt')\n        self.browser.getControl('Upload File').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        self.assertEqual(\n            self.browser.getControl('Content Type').value, 'text/plain')\n        text = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text, 'test text file')\n\n    def test_Image__manage_edit__1(self):\n        \"\"\"It it possible to change the file's content via browser.\"\"\"\n        self.browser.open('http://localhost/file/manage_main')\n        text_1 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_1, '')\n        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'\n        self.browser.getControl('Save Changes').click()\n        self.assertIn('Saved changes', self.browser.contents)\n        text_2 = self.browser.getControl(name='filedata:text').value\n        self.assertEqual(text_2, 'h\u00e4llo')", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
