{"index": 571, "cve_id": "CVE-2014-2236", "cwe_id": ["CWE-79"], "cve_language": "Python", "cve_description": "Multiple cross-site scripting (XSS) vulnerabilities in Askbot before 0.7.49 allow remote attackers to inject arbitrary web script or HTML via vectors related to the (1) tag or (2) user search forms.", "cvss": "3.7", "publish_date": "March 5, 2014", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "a676a86b6b7a5737d4da4f59f71e037406f88d29", "commit_message": "fixed some xss issues", "commit_date": "2013-05-08T03:59:42Z", "project": "askbot/askbot-devel", "url": "https://api.github.com/repos/ASKBOT/askbot-devel/commits/a676a86b6b7a5737d4da4f59f71e037406f88d29", "html_url": "https://github.com/ASKBOT/askbot-devel/commit/a676a86b6b7a5737d4da4f59f71e037406f88d29", "windows_before": [{"commit_id": "ce48471aacfbc8bc84e698b1eb6eedb5010e9eb3", "commit_date": "Tue May 7 11:30:49 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["8ac806f3fd19e2cc08643560432b8bc2f99f6497 - Mon May 6 23:20:29 2013 -0400 : fixed iframe IE8 issues", "askbot/media/js/post.js", "askbot/media/js/wmd/wmd.js"]}, {"commit_id": "9da5a59401ba850ea0fdb4a6c116dbdb0a183a5c", "commit_date": "Mon May 6 21:56:21 2013 -0400", "commit_message": "fixed IE8 issues in the editor and on the question page", "files_name": ["askbot/media/js/wmd/wmd.js", "askbot/templates/question.html"]}, {"commit_id": "a26bca9638a5fe77f5e833738386e6805a177744", "commit_date": "Mon May 6 20:54:07 2013 -0400", "commit_message": "restricted comment edits only to post owners and mods/admins", "files_name": ["askbot/media/js/post.js", "askbot/templates/question.html"]}, {"commit_id": "2b0ac640d004f54fa2993c2085a7b0fa727ef533", "commit_date": "Mon May 6 10:10:00 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["cf3605b7c0a86e799077f440e97645b22a69b8a0 - Sun May 5 23:57:15 2013 -0400 : fixed a bug where twitter sharing button was shown, when twitter keys were not set up", "askbot/conf/social_sharing.py", "askbot/templates/user_profile/user_info.html"]}, {"commit_id": "ad61b074b6f03c9b4c9d7f3f0fd195705c7366f2", "commit_date": "Sun May 5 23:51:13 2013 -0400", "commit_message": "edited changelog", "files_name": ["askbot/doc/source/changelog.rst"]}, {"commit_id": "00a6757866c433f90edb3bc9667dc41406fa1f65", "commit_date": "Sun May 5 22:34:29 2013 -0400", "commit_message": "ported livesettings app to askbot templates", "files_name": ["askbot/conf/site_settings.py", "askbot/deps/livesettings/templates/livesettings/group_settings.html", "askbot/media/style/style.css", "askbot/media/style/style.less", "askbot/templates/livesettings/_admin_site_views.html", "askbot/templates/livesettings/group_settings.html", "askbot/templates/livesettings/site_settings.html", "askbot/templates/livesettings/text.txt"]}, {"commit_id": "d0988dc33088b8aedb6e4b3ae2636b13c0d744f5", "commit_date": "Sun May 5 18:42:28 2013 -0400", "commit_message": "added auto-focus to the registration page", "files_name": ["askbot/templates/authopenid/complete.html", "askbot/utils/forms.py"]}, {"commit_id": "9c56383cd0525d0e6e5463e1c8a70d2e9d66fd99", "commit_date": "Sun May 5 02:10:45 2013 -0400", "commit_message": "hopefully fixed the askbot site mounted at a sub-url", "files_name": ["askbot/context.py", "askbot/deps/django_authopenid/util.py", "askbot/deps/django_authopenid/views.py", "askbot/feed.py", "askbot/mail/lamson_handlers.py", "askbot/management/commands/send_accept_answer_reminders.py", "askbot/management/commands/send_email_alerts.py", "askbot/management/commands/send_unanswered_question_reminders.py", "askbot/models/__init__.py", "askbot/models/post.py", "askbot/templates/base.html", "askbot/templates/question.html", "askbot/templates/question/sidebar.html", "askbot/templatetags/extra_filters_jinja.py", "askbot/utils/decorators.py", "askbot/utils/html.py", "askbot/views/writers.py"]}, {"commit_id": "54891e1576a3b8ad96fcfa159c5eaf5ab9cd2446", "commit_date": "Sat May 4 23:08:48 2013 -0400", "commit_message": "small change in the PostAsSomeone form", "files_name": ["askbot/forms.py"]}, {"commit_id": "1daf6385d622eb73201eb8e0f2485ebfce254918", "commit_date": "Sat May 4 22:54:55 2013 -0400", "commit_message": "made Askbot more iframe-friendly", "files_name": ["askbot/media/js/wmd/showdown.js", "askbot/media/js/wmd/wmd.js"]}, {"commit_id": "904ffeae62089d76e86425377f2b8fe034409e68", "commit_date": "Sat May 4 22:18:31 2013 -0400", "commit_message": "pulled new .po files from transifex", "files_name": ["askbot/locale/de/LC_MESSAGES/django.po", "askbot/locale/de/LC_MESSAGES/djangojs.po", "askbot/locale/es/LC_MESSAGES/django.po", "askbot/locale/hu/LC_MESSAGES/django.po", "askbot/locale/hu/LC_MESSAGES/djangojs.po", "askbot/locale/it/LC_MESSAGES/django.po", "askbot/locale/ru/LC_MESSAGES/django.po", "askbot/locale/ru/LC_MESSAGES/djangojs.po"]}, {"commit_id": "8e2957aa78ddfa10b941c313e55771fcf4b36d6f", "commit_date": "Sat May 4 00:09:42 2013 -0400", "commit_message": "fixed the dummy tag issue", "files_name": ["askbot/migrations/0127_save_category_tree_as_json.py", "askbot/templates/main_page/questions_loop.html", "askbot/views/commands.py"]}, {"commit_id": "ae888776f39839328a3b728bbca59831dbe6184c", "commit_date": "Thu May 2 23:18:28 2013 -0400", "commit_message": "fixed logging messages", "files_name": ["askbot/deps/django_authopenid/views.py"]}, {"commit_id": "55f05b9287a5f65bd5a2253b774e71c262d1f947", "commit_date": "Thu May 2 10:01:52 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["967ee98f404fc78eeb0428b9099d48ca44372670 - Thu May 2 04:28:31 2013 -0400 : added extra context to the edit answer page", "askbot/models/signals.py", "askbot/views/writers.py"]}, {"commit_id": "2c7ef628f6632c9f395d5ef3933a5b6b84430947", "commit_date": "Thu May 2 00:07:06 2013 -0400", "commit_message": "added option to auto-follow asked question", "files_name": ["askbot/conf/forum_data_rules.py", "askbot/doc/source/changelog.rst", "askbot/models/__init__.py"]}, {"commit_id": "a0e24ca83fbadd5f4d7a065f76f0df8f638ac7b4", "commit_date": "Wed May 1 22:52:26 2013 -0400", "commit_message": "removed livesettings url from urls.py setup template", "files_name": ["askbot/setup_templates/urls.py"]}, {"commit_id": "16afbbcad1e5db4896a434e1ff57a1c3ba540fd1", "commit_date": "Wed May 1 21:20:55 2013 -0400", "commit_message": "Merge branch 'github'", "files_name": ["cb01a8d0fc658821a9fcf313007da00a528c2008 - Wed May 1 21:09:24 2013 -0400 : removed possibility to have >1 account with the same email address", "askbot/conf/email.py", "askbot/deps/django_authopenid/forms.py", "askbot/forms.py", "askbot/media/js/post.js", "askbot/tests/email_alert_tests.py", "askbot/utils/forms.py"]}, {"commit_id": "12994f9a796433b048fd1fd0b1b9582bba7c0fa5", "commit_date": "Wed May 1 13:09:08 2013 -0700", "commit_message": "Merge pull request #124 from jetfix/master", "files_name": ["d2561b16f77d794ddb93e85bd3e35e21fcd6a5dc - Thu May 2 02:34:28 2013 +0700 : fix: UnicodeDecodeError at /askbot/settings/EMAIL/ (askbot/deps/livesettings/values.py in _default_text, line 252)", "askbot/deps/livesettings/values.py"]}, {"commit_id": "f79c5aaa2e61cad7dd4b21319761544cf7bcba68", "commit_date": "Wed May 1 12:28:10 2013 -0700", "commit_message": "Merge pull request #123 from jetfix/master", "files_name": ["7dd06189a24bcfd4c189034b4fc317b6080a4ff8 - Thu May 2 02:17:46 2013 +0700 : added a route to askbot.urls. Without this route admin user was not able to login and received error message:'Exception Type:NoReverseMatch'", "askbot/urls.py"]}, {"commit_id": "51b04a3f256b7bda9906dc8aafedfa0b9cdc2e10", "commit_date": "Tue Apr 30 14:23:56 2013 -0700", "commit_message": "Merge pull request #122 from fitoria/mathjax-fix", "files_name": ["a1e991b44958eccb12792faa71f440a850f104e2 - Tue Apr 30 15:13:21 2013 -0600 : taking mathjax out of compress", "askbot/templates/meta/bottom_scripts.html"]}, {"commit_id": "20ad12f13506435175ee55afa43181be55dfa93b", "commit_date": "Mon Apr 29 09:26:22 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["db853927d7c6adf8f89e1b0ac7d6c9f9691e0592 - Sun Apr 28 05:45:45 2013 -0400 : fixed settings urls to work with django 1.3-1.5", "askbot/deps/livesettings/templates/livesettings/group_settings.html", "askbot/deps/livesettings/templates/livesettings/site_settings.html"]}, {"commit_id": "e012884a17614548f4b45e46f77b2a17a4693b4d", "commit_date": "Sun Apr 28 05:24:27 2013 -0400", "commit_message": "removed deprecated template tag from settings", "files_name": ["askbot/deps/livesettings/templates/livesettings/group_settings.html", "askbot/deps/livesettings/templates/livesettings/site_settings.html"]}, {"commit_id": "2f88b0438ebe4ba35857c4b9a37061c033272060", "commit_date": "Sun Apr 28 05:01:18 2013 -0400", "commit_message": "added parser explicitly to the asset compressor", "files_name": ["askbot/setup_templates/settings.py", "askbot/setup_templates/settings.py.mustache"]}, {"commit_id": "5a9fd5de6ee2b0292c3c4d65aba7bdb53282e848", "commit_date": "Fri Apr 26 18:46:12 2013 -0400", "commit_message": "fixed the answer posting bug where wiki is always true", "files_name": ["askbot/forms.py"]}, {"commit_id": "fb41261f6add8ee7cc5a3c2e256491f4d65706e9", "commit_date": "Fri Apr 26 18:34:04 2013 -0400", "commit_message": "added missing import to template", "files_name": ["askbot/templates/email/notify_author_about_approved_post.html"]}, {"commit_id": "2ce7b2d3a2313b5be3e765dd7507d14d0062f1c8", "commit_date": "Fri Apr 26 05:39:02 2013 -0400", "commit_message": "seems to work on django 1.5", "files_name": ["askbot/doc/source/changelog.rst", "askbot/models/post.py", "askbot/startup_procedures.py", "askbot/tests/page_load_tests.py", "askbot/utils/functions.py", "askbot/views/meta.py", "askbot/views/readers.py", "askbot/views/users.py"]}, {"commit_id": "e3640e5dde07a736d50f3712c8874c90a87cb50a", "commit_date": "Thu Apr 25 06:07:43 2013 -0400", "commit_message": "removed get_host import", "files_name": ["askbot/deps/django_authopenid/views.py"]}, {"commit_id": "246dbab915d0f0d3c4007307f4fa26fbe5e20680", "commit_date": "Thu Apr 25 05:57:13 2013 -0400", "commit_message": "added default value to the category tree", "files_name": ["askbot/conf/flatpages.py"]}, {"commit_id": "a1a8228edf9495eb48d058b7fbd4c8aa8c9ddb08", "commit_date": "Thu Apr 25 05:15:45 2013 -0400", "commit_message": "inlined a function missing in django1.5", "files_name": ["askbot/utils/forms.py"]}, {"commit_id": "440b947708bbfda7ad179b79b5c1916731576f36", "commit_date": "Thu Apr 25 02:12:38 2013 -0400", "commit_message": "added a class to template", "files_name": ["askbot/templates/widgets/edit_post.html"]}, {"commit_id": "bac77a32025a61928110eab85267e96a2c859b15", "commit_date": "Thu Apr 25 02:08:52 2013 -0400", "commit_message": "made a setting to make question body optional", "files_name": ["askbot/conf/forum_data_rules.py", "askbot/media/js/post.js", "askbot/media/style/style.css", "askbot/media/style/style.less", "askbot/templates/ask.html", "askbot/templates/ask_by_widget.html", "askbot/templates/widgets/ask_form.html", "askbot/templatetags/extra_filters_jinja.py", "askbot/utils/html.py"]}, {"commit_id": "4ad89216ff38c4d616b6821e69e5a889a6a59b2a", "commit_date": "Wed Apr 24 22:15:39 2013 -0400", "commit_message": "fixed css for the faces box", "files_name": ["askbot/media/style/style.css", "askbot/media/style/style.less"]}, {"commit_id": "9f986b792878bdb56108d07cd93d41bc6c85aab1", "commit_date": "Wed Apr 24 09:07:43 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["a5aab75193defa455444111bd1011451059aa446 - Wed Apr 24 04:49:35 2013 -0400 : recompiled style.css", "askbot/media/style/style.css"]}, {"commit_id": "9dfb2a91512fa2890a842faf2b49392c680c03f5", "commit_date": "Wed Apr 24 04:49:06 2013 -0400", "commit_message": "adjusted style", "files_name": ["askbot/media/style/style.less"]}, {"commit_id": "8327fbc945c0abe099a2c9280a01e5267a719baa", "commit_date": "Wed Apr 24 04:37:16 2013 -0400", "commit_message": "changed a string in settings", "files_name": ["askbot/conf/minimum_reputation.py"]}, {"commit_id": "40fbca07eddde96af55325afab329f354a94a7ea", "commit_date": "Wed Apr 24 04:17:20 2013 -0400", "commit_message": "corrected signature change detection", "files_name": ["askbot/mail/__init__.py"]}, {"commit_id": "75050366da87747b7f7ec6a0c3213966c3bc8059", "commit_date": "Wed Apr 24 03:58:34 2013 -0400", "commit_message": "improved handling of user signature extraction", "files_name": ["askbot/mail/__init__.py", "askbot/mail/lamson_handlers.py"]}, {"commit_id": "ef2d4fc774f986e99d4443b651ae68961710e65c", "commit_date": "Wed Apr 24 03:27:17 2013 -0400", "commit_message": "fixed error in email routing", "files_name": ["askbot/mail/__init__.py"]}, {"commit_id": "987e571c04ef4501e0b3422c8fd47ab31b0d4ab2", "commit_date": "Wed Apr 24 03:21:52 2013 -0400", "commit_message": "made a change in the email routing", "files_name": ["askbot/mail/__init__.py"]}, {"commit_id": "cef6a23e58cb81e28be2dc2f77fd35eac89c3060", "commit_date": "Wed Apr 24 03:08:35 2013 -0400", "commit_message": "a change in posting by email", "files_name": ["askbot/mail/__init__.py", "askbot/mail/lamson_handlers.py"]}], "windows_after": [{"commit_id": "fddc1d8831955bd8a399dcb18bfafe52738824bb", "commit_date": "Wed May 8 15:03:27 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["675118869f07a78ffe380b2b925ca30ab050fc98 - Wed May 8 23:19:42 2013 -0400 : require html5lib for bs4 for better compatibility with apache", "askbot/mail/__init__.py", "askbot/templatetags/extra_filters_jinja.py", "askbot/utils/html.py", "askbot/views/commands.py"]}, {"commit_id": "dcf3be48f284a156f8b33d32c782b81fe37f9810", "commit_date": "Thu May 9 11:43:24 2013 -0600", "commit_message": "added search indexes templates", "files_name": ["askbot/templates/search/indexes/auth/user_text.txt"]}, {"commit_id": "dec57d30c7778c73fe039fbbe7231f42c475c7ed", "commit_date": "Thu May 9 15:35:07 2013 -0600", "commit_message": "fixed bugs in haystack search, now works well with solr, there is still produced by import error", "files_name": ["askbot/models/question.py", "askbot/search/haystack/__init__.py", "askbot/templates/search/indexes/askbot/post_text.txt", "askbot/templates/search/indexes/askbot/thread_text.txt"]}, {"commit_id": "2cae82870db05b0e30f7b2768476a530aabb6f50", "commit_date": "Thu May 9 23:15:36 2013 -0400", "commit_message": "hid the \"private\" post feature from users who do not belong to custom groups", "files_name": ["askbot/models/__init__.py"]}, {"commit_id": "846a70e20c5f7ef585e29e6514bf38990c60b1ad", "commit_date": "Fri May 10 02:06:03 2013 -0400", "commit_message": "small refactor of css files", "files_name": ["askbot/media/bootstrap/css/bootstrap.css", "askbot/media/style/lib_style.less", "askbot/media/style/style.css", "askbot/media/style/style.less"]}, {"commit_id": "e30a0b45be08cae65fc4d92e1ecd0955502773d0", "commit_date": "Fri May 10 09:37:11 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel into solr", "files_name": ["5a5aa5d65135f04114b6235ec823bb2a924367d1 - Fri May 10 10:36:13 2013 -0600 : solved import error issue with circular imports", "askbot/search/haystack/__init__.py", "askbot/setup_templates/settings.py", "askbot/setup_templates/settings.py.mustache"]}, {"commit_id": "1be659e693528e0d738f70a6be29bfebc058b2f8", "commit_date": "Fri May 10 10:58:24 2013 -0600", "commit_message": "fixed haystack tests", "files_name": ["askbot/tests/haystack_search_tests.py"]}, {"commit_id": "01613f470dc3e902bfc638621c53ad8f8025ef5a", "commit_date": "Fri May 10 11:01:23 2013 -0600", "commit_message": "missing comma", "files_name": ["askbot/tests/haystack_search_tests.py"]}, {"commit_id": "413e49b5435370f4c8102d3e4e348eb1b957f629", "commit_date": "Fri May 10 12:27:50 2013 -0600", "commit_message": "modified startup procedures", "files_name": ["askbot/startup_procedures.py"]}, {"commit_id": "94d41167885a31f5f15fd506a650b5354c192aa4", "commit_date": "Fri May 10 20:32:46 2013 -0400", "commit_message": "fixed some more IE8 issues", "files_name": ["askbot/media/js/utils.js", "askbot/templates/base.html", "askbot/templates/question.html"]}, {"commit_id": "ac6ca46090c778a80ec269557910d2ce3b772216", "commit_date": "Fri May 10 22:05:57 2013 -0400", "commit_message": "fixed a bug in the user network page", "files_name": ["askbot/templates/user_profile/user_network.html", "askbot/tests/page_load_tests.py"]}, {"commit_id": "032fb82af97c5fd949addd8cb1c1241311c96108", "commit_date": "Sun May 12 01:00:30 2013 -0400", "commit_message": "small css fixes", "files_name": ["askbot/media/style/style.css", "askbot/media/style/style.less"]}, {"commit_id": "b02b847ae95e71b2b5e406788e49973178ca803b", "commit_date": "Mon May 13 16:01:53 2013 -0600", "commit_message": "added import haystack in models to avoid circular import issue and enable search index registration", "files_name": ["askbot/models/__init__.py"]}, {"commit_id": "d22fa72fb0bc078c5b14aa0bc1110d10458cdf91", "commit_date": "Mon May 13 17:33:55 2013 -0600", "commit_message": "title search works with haystack", "files_name": ["askbot/models/question.py"]}, {"commit_id": "8f04fb32fcf53cdba74b254ad5b11aba22faa289", "commit_date": "Tue May 14 09:54:31 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["994c92a2e4351603dbeda71452a1493186878d21 - Tue May 14 11:58:11 2013 -0600 : search lang code is taken into account with haystack", "askbot/search/haystack/__init__.py"]}, {"commit_id": "f3e2b009aa0079d5300a9da1e082893e909886d8", "commit_date": "Tue May 14 15:23:39 2013 -0400", "commit_message": "fixed tag search UI", "files_name": ["askbot/media/js/live_search.js"]}, {"commit_id": "a8584758d83f779bef5c891c5095864dcfa7c95e", "commit_date": "Tue May 14 22:32:48 2013 -0400", "commit_message": "minor css change", "files_name": ["askbot/media/style/style.css", "askbot/media/style/style.less"]}, {"commit_id": "68883de9a3f294d3dfa7e59e6a8765c341d710a5", "commit_date": "Tue May 14 22:43:14 2013 -0400", "commit_message": "put border styling for inputs and textareas into one place", "files_name": ["askbot/media/style/style.css", "askbot/media/style/style.less"]}, {"commit_id": "367412143dbe4132709b5eaa34edab27e204295f", "commit_date": "Wed May 15 09:47:38 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel", "files_name": ["f2c43c3fd41aa6fdc01f99c9075825e236e15159 - Wed May 15 11:04:28 2013 -0600 : Fixes code that could produce KeyError in sorting methods", "askbot/models/question.py"]}, {"commit_id": "8e3cc56cd9297535085425da2103721c687fd366", "commit_date": "Wed May 15 11:37:21 2013 -0600", "commit_message": "Merge branch 'master' of github.com:ASKBOT/askbot-devel into solr", "files_name": ["c98bb3ca39afb6797a79d40ea76a8524f5da3d5d - Wed May 15 16:45:44 2013 -0600 : adding solr + tomcat docs", "askbot/doc/source/solr.rst"]}, {"commit_id": "f44de3d77708d86c46428dc2b6e05aaa9c0597a0", "commit_date": "Wed May 15 18:34:19 2013 -0700", "commit_message": "Merge pull request #125 from fitoria/keyerrorissue", "files_name": ["d43de82ff1167bef372933dafebd8c19b47acf06 - Thu May 16 01:20:05 2013 -0400 : added another signal - new_comment_posted, in hindsight maybe we should have had just one \"new_post_created\" instead of the three separate ones", "askbot/models/signals.py", "askbot/views/writers.py"]}, {"commit_id": "9ab32169cc98e9d03c244cb8c150df33c45bb7a1", "commit_date": "Fri May 17 16:49:45 2013 -0400", "commit_message": "pulled translations from transifex", "files_name": ["askbot/locale/de/LC_MESSAGES/django.po", "askbot/locale/de/LC_MESSAGES/djangojs.po", "askbot/locale/fr/LC_MESSAGES/django.po", "askbot/locale/junk", "askbot/locale/pt/LC_MESSAGES/django.po", "askbot/locale/zh_TW/LC_MESSAGES/django.po"]}, {"commit_id": "ec01ef0d3b0637d5b32a94ff7e554b38497c1d29", "commit_date": "Fri May 17 16:52:02 2013 -0400", "commit_message": "Merge branch 'github'", "files_name": ["44390ea008e225a33b3c15e90172d0c3e44efe7f - Fri May 17 16:57:51 2013 -0400 : recompiled messages", "askbot/locale/de/LC_MESSAGES/django.mo", "askbot/locale/de/LC_MESSAGES/djangojs.mo", "askbot/locale/es/LC_MESSAGES/django.mo", "askbot/locale/fr/LC_MESSAGES/django.mo", "askbot/locale/hu/LC_MESSAGES/django.mo", "askbot/locale/hu/LC_MESSAGES/djangojs.mo", "askbot/locale/it/LC_MESSAGES/django.mo", "askbot/locale/pt/LC_MESSAGES/django.mo", "askbot/locale/ru/LC_MESSAGES/django.mo", "askbot/locale/ru/LC_MESSAGES/djangojs.mo", "askbot/locale/zh_TW/LC_MESSAGES/django.mo"]}, {"commit_id": "21357dc29f475ec80e503ad43785e26c8fdb2e3e", "commit_date": "Thu May 16 21:28:27 2013 -0600", "commit_message": "fixed docs typos", "files_name": ["askbot/doc/source/solr.rst"]}, {"commit_id": "db956af1b0dc6cdd428ad4099314486c55339770", "commit_date": "Sat May 18 11:17:04 2013 -0400", "commit_message": "rebuilt the english locale messages", "files_name": ["askbot/locale/en/LC_MESSAGES/django.po", "askbot/locale/en/LC_MESSAGES/djangojs.po"]}, {"commit_id": "316d58a3d2303833550e06b2d16f11563fbf511b", "commit_date": "Sat May 18 13:52:35 2013 -0400", "commit_message": "fixed some messages for the translation", "files_name": ["askbot/deps/django_authopenid/views.py", "askbot/templates/ask.html", "askbot/templates/authopenid/changeemail.html"]}, {"commit_id": "34f6bb67e99e6d76da86c12dbe326586c26efd7c", "commit_date": "Sat May 18 15:55:34 2013 -0400", "commit_message": "pulled strings from transifex again", "files_name": ["askbot/locale/ca/LC_MESSAGES/django.po", "askbot/locale/ca/LC_MESSAGES/djangojs.po", "askbot/locale/cs_CZ/LC_MESSAGES/django.po", "askbot/locale/cs_CZ/LC_MESSAGES/djangojs.po", "askbot/locale/de/LC_MESSAGES/django.po", "askbot/locale/de/LC_MESSAGES/djangojs.po", "askbot/locale/el/LC_MESSAGES/django.po", "askbot/locale/el/LC_MESSAGES/djangojs.po", "askbot/locale/es/LC_MESSAGES/django.po", "askbot/locale/es/LC_MESSAGES/djangojs.po", "askbot/locale/fi/LC_MESSAGES/django.po", "askbot/locale/fi/LC_MESSAGES/djangojs.po", "askbot/locale/fr/LC_MESSAGES/django.po", "askbot/locale/fr/LC_MESSAGES/djangojs.po", "askbot/locale/hi/LC_MESSAGES/django.po", "askbot/locale/hi/LC_MESSAGES/djangojs.po", "askbot/locale/hr/LC_MESSAGES/django.po", "askbot/locale/hr/LC_MESSAGES/djangojs.po", "askbot/locale/hu/LC_MESSAGES/django.po", "askbot/locale/hu/LC_MESSAGES/djangojs.po", "askbot/locale/it/LC_MESSAGES/django.po", "askbot/locale/it/LC_MESSAGES/djangojs.po", "askbot/locale/ja/LC_MESSAGES/django.po", "askbot/locale/ja/LC_MESSAGES/djangojs.po", "askbot/locale/ko/LC_MESSAGES/django.po", "askbot/locale/ko/LC_MESSAGES/djangojs.po", "askbot/locale/pt/LC_MESSAGES/django.po", "askbot/locale/pt/LC_MESSAGES/djangojs.po", "askbot/locale/pt_BR/LC_MESSAGES/django.po", "askbot/locale/pt_BR/LC_MESSAGES/djangojs.po", "askbot/locale/ro/LC_MESSAGES/django.po", "askbot/locale/ru/LC_MESSAGES/django.po", "askbot/locale/ru/LC_MESSAGES/djangojs.po", "askbot/locale/sr/LC_MESSAGES/django.po", "askbot/locale/tr/LC_MESSAGES/django.po", "askbot/locale/tr/LC_MESSAGES/djangojs.po", "askbot/locale/vi/LC_MESSAGES/django.po", "askbot/locale/zh_CN/LC_MESSAGES/django.po", "askbot/locale/zh_CN/LC_MESSAGES/djangojs.po", "askbot/locale/zh_TW/LC_MESSAGES/django.po", "askbot/locale/zh_TW/LC_MESSAGES/djangojs.po"]}, {"commit_id": "cb393b3beaab60e7cc1d5d2c555ef5b4f2eb117b", "commit_date": "Sat May 18 16:00:22 2013 -0400", "commit_message": "pulled all new translations from tx even the very incomplete ones", "files_name": ["askbot/locale/ar/LC_MESSAGES/django.po", "askbot/locale/ar/LC_MESSAGES/djangojs.po", "askbot/locale/bn_IN/LC_MESSAGES/django.po", "askbot/locale/bn_IN/LC_MESSAGES/djangojs.po", "askbot/locale/cs/LC_MESSAGES/django.po", "askbot/locale/cs/LC_MESSAGES/djangojs.po", "askbot/locale/fa_IR/LC_MESSAGES/django.po", "askbot/locale/fa_IR/LC_MESSAGES/djangojs.po", "askbot/locale/gl/LC_MESSAGES/django.po", "askbot/locale/gl/LC_MESSAGES/djangojs.po", "askbot/locale/he_IL/LC_MESSAGES/django.po", "askbot/locale/he_IL/LC_MESSAGES/djangojs.po", "askbot/locale/id_ID/LC_MESSAGES/django.po", "askbot/locale/id_ID/LC_MESSAGES/djangojs.po", "askbot/locale/ms_MY/LC_MESSAGES/django.po", "askbot/locale/ms_MY/LC_MESSAGES/djangojs.po", "askbot/locale/pl/LC_MESSAGES/django.po", "askbot/locale/pl/LC_MESSAGES/djangojs.po", "askbot/locale/sl/LC_MESSAGES/django.po", "askbot/locale/sl/LC_MESSAGES/djangojs.po", "askbot/locale/sv_SE/LC_MESSAGES/django.po", "askbot/locale/sv_SE/LC_MESSAGES/djangojs.po", "askbot/locale/tr_TR/LC_MESSAGES/django.po", "askbot/locale/tr_TR/LC_MESSAGES/djangojs.po"]}, {"commit_id": "e0e223ea31a522974407efd8d95e127dc3a9a714", "commit_date": "Sat May 18 12:59:21 2013 -0400", "commit_message": "Merge branch 'master' of github.com:/ASKBOT/askbot-devel", "files_name": ["966cb23c8bcba1b9b54c2380ae83d762a4d55590 - Sat May 18 13:01:04 2013 -0400 : recompiled all localizations", "askbot/locale/ar/LC_MESSAGES/django.mo", "askbot/locale/ar/LC_MESSAGES/djangojs.mo", "askbot/locale/bn_IN/LC_MESSAGES/django.mo"]}], "parents": [{"commit_id_before": "8ac806f3fd19e2cc08643560432b8bc2f99f6497", "url_before": "https://api.github.com/repos/ASKBOT/askbot-devel/commits/8ac806f3fd19e2cc08643560432b8bc2f99f6497", "html_url_before": "https://github.com/ASKBOT/askbot-devel/commit/8ac806f3fd19e2cc08643560432b8bc2f99f6497"}], "details": [{"raw_url": "https://github.com/ASKBOT/askbot-devel/raw/a676a86b6b7a5737d4da4f59f71e037406f88d29/askbot%2Ftemplates%2Fusers.html", "code": "{% if settings.GROUPS_ENABLED %}\n    {% extends \"two_column_body.html\" %}\n{% else %}\n    {% extends \"one_column_body.html\" %}\n{% endif %}\n{% import \"macros.html\" as macros %}\n<!-- users.html -->\n{% block title %}{% spaceless %}{% trans %}Users{% endtrans %}{% endspaceless %}{% endblock %}\n{% block forestyle %}\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{\"/js/wmd/wmd.css\"|media}}\" />\n{% endblock %}\n{% block content %}\n<div id=\"content-header\">\n    <h1 class=\"section-title\">\n    {% if group %}\n        {% trans name = group.name|replace('-', ' ')|escape %}Users in group {{name}}{% endtrans %}\n    {% else %}\n        {% trans %}Users{% endtrans %}\n    {% endif %}\n    </h1>\n    <div class=\"tabBar\">\n        <div class=\"tabsA\">\n        {#% if settings.GROUPS_ENABLED and user_groups %}\n            <span class=\"label\">{% trans %}Select/Sort by &raquo;{% endtrans %}</span>\n            {% for a_group in user_groups %}\n                <a \n                    href=\"{% url users_by_group group_id=a_group.id, group_slug=a_group.name|slugify %}\"\n                    {% if group.name == a_group.name  %}class=\"on\"{% endif %}\n                    title=\"{% trans name=a_group.name|escape %}people in group {{name}}{% endtrans %}\"\n                ><span>{{ a_group.name|replace('-',' ')|escape }}</span></a>\n            {% endfor %}\n        {% else %#}\n            <span class=\"label\">{% trans %}Sort by &raquo;{% endtrans %}</span>\n        {#% endif %#}\n            {% if settings.KARMA_MODE == 'public' %}\n            <a \n                id=\"sort_reputation\"\n                href=\"{{ request.path|escape }}?sort=reputation\"\n                {% if tab_id == 'reputation' %}class=\"on\"{% endif %}\n                title=\"{% trans %}see people with the highest reputation{% endtrans %}\"\n            ><span>{% trans %}karma{% endtrans %}</span></a>\n            {% endif %}\n            <a \n                id=\"sort_newest\"\n                href=\"{{ request.path|escape }}?sort=newest\"\n                {% if tab_id == 'newest' %}class=\"on\"{% endif %}\n                class=\"off\" title=\"{% trans %}see people who joined most recently{% endtrans %}\"\n            ><span>{% trans %}recent{% endtrans %}</span></a>\n            <a \n                id=\"sort_last\"\n                href=\"{{ request.path|escape }}?sort=last\"\n                {% if tab_id == 'last' %}class=\"on\"{% endif %}\n                class=\"off\" title=\"{% trans %}see people who joined the site first{% endtrans %}\"\n            ><span>{% trans %}oldest{% endtrans %}<span></a>\n            <a \n                id=\"sort_user\"\n                href=\"{{ request.path|escape }}?sort=user\"\n                {% if tab_id == 'user' %}class=\"on\"{% endif %}\n                title=\"{% trans %}see people sorted by name{% endtrans %}\"\n            ><span>{% trans %}by username{% endtrans %}</span></a>\n        </div>\n    </div>\n    <div class=\"clearfix\"></div>\n</div>\n{% if search_query %}\n    <p>{% trans search_query=search_query|escape %}users matching query {{search_query}}:{% endtrans %}</p>\n{% endif %}\n{% if not users.object_list %}\n    <p><span>{% trans %}Nothing found.{% endtrans %}</span></p>\n{% endif %}\n{{ macros.user_list(\n        users.object_list, \n        karma_mode = settings.KARMA_MODE, badges_mode = settings.BADGES_MODE\n    )\n}}\n<div class=\"pager\">\n    {{ macros.paginator(paginator_context) }}\n</div>              \n{% endblock %}\n{% block sidebar %}\n    {% if group %}\n        {# this widget takes variables: group, user_can_join_group, user_is_group_member #}\n        {% include \"widgets/group_info.html\" %}\n    {% endif %}\n{% endblock %}\n{% block endjs %}\n    <script type='text/javascript'>\n        var Attacklab = Attacklab || {};\n        Attacklab.wmd = 1;{# a trick to launch wmd manually #}\n        askbot['urls']['upload'] = '{% url upload %}';\n        askbot['urls']['load_object_description'] = '{% url load_object_description %}';\n        askbot['urls']['save_object_description'] = '{% url save_object_description %}';\n        askbot['urls']['save_group_logo_url'] = '{% url save_group_logo_url %}';\n        askbot['urls']['delete_group_logo_url'] = '{% url delete_group_logo %}';\n        askbot['urls']['join_or_leave_group'] = '{% url join_or_leave_group %}';\n    </script>\n    <script type='text/javascript' src='{{\"/js/editor.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/wmd/showdown.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/wmd/wmd.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/jquery.validate.min.js\"|media}}'></script>\n    <script src='{{\"/js/post.js\"|media}}' type='text/javascript'></script>\n    <script type=\"text/javascript\">\n        //todo move javascript out\n        {% if settings.ENABLE_MATHJAX or settings.MARKUP_CODE_FRIENDLY %}\n            var codeFriendlyMarkdown = true;\n        {% else %}\n            var codeFriendlyMarkdown = false;\n        {% endif %}\n        {% if group and request.user.is_authenticated() %}\n            $().ready(function(){\n                var group_join_btn = new GroupJoinButton();\n                group_join_btn.decorate($('.group-join-btn'));\n                //setup WMD editor\n                if (askbot['data']['userIsAdminOrMod'] === true){\n                    //todo: this is kind of Attacklab.init ... should not be here\n                    Attacklab.wmd = function(){\n                        Attacklab.loadEnv = function(){\n                            var mergeEnv = function(env){\n                                if(!env){\n                                    return;\n                                }\n                            \n                                for(var key in env){\n                                    Attacklab.wmd_env[key] = env[key];\n                                }\n                            };\n                            \n                            mergeEnv(Attacklab.wmd_defaults);\n                            mergeEnv(Attacklab.account_options);\n                            mergeEnv(top[\"wmd_options\"]);\n                            Attacklab.full = true;\n                            \n                            var defaultButtons = \"bold italic link blockquote code image ol ul heading hr\";\n                            Attacklab.wmd_env.buttons = Attacklab.wmd_env.buttons || defaultButtons;\n                        };\n                        Attacklab.loadEnv();\n                    };\n                    Attacklab.wmd();\n                    Attacklab.wmdBase();\n                    var group_editor = new UserGroupProfileEditor();\n                    group_editor.decorate($('#group-wiki-{{group.id}}'));\n                }\n                Hilite.exact = false;\n                Hilite.elementid = \"main-body\";\n                Hilite.debug_referrer = location.href;\n            });\n        {% endif %}\n    </script>\n{% endblock %}\n<!-- end users.html -->\n", "code_before": "{% if settings.GROUPS_ENABLED %}\n    {% extends \"two_column_body.html\" %}\n{% else %}\n    {% extends \"one_column_body.html\" %}\n{% endif %}\n{% import \"macros.html\" as macros %}\n<!-- users.html -->\n{% block title %}{% spaceless %}{% trans %}Users{% endtrans %}{% endspaceless %}{% endblock %}\n{% block forestyle %}\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{\"/js/wmd/wmd.css\"|media}}\" />\n{% endblock %}\n{% block content %}\n<div id=\"content-header\">\n    <h1 class=\"section-title\">\n    {% if group %}\n        {% trans name = group.name|replace('-', ' ')|escape %}Users in group {{name}}{% endtrans %}\n    {% else %}\n        {% trans %}Users{% endtrans %}\n    {% endif %}\n    </h1>\n    <div class=\"tabBar\">\n        <div class=\"tabsA\">\n        {#% if settings.GROUPS_ENABLED and user_groups %}\n            <span class=\"label\">{% trans %}Select/Sort by &raquo;{% endtrans %}</span>\n            {% for a_group in user_groups %}\n                <a \n                    href=\"{% url users_by_group group_id=a_group.id, group_slug=a_group.name|slugify %}\"\n                    {% if group.name == a_group.name  %}class=\"on\"{% endif %}\n                    title=\"{% trans name=a_group.name|escape %}people in group {{name}}{% endtrans %}\"\n                ><span>{{ a_group.name|replace('-',' ')|escape }}</span></a>\n            {% endfor %}\n        {% else %#}\n            <span class=\"label\">{% trans %}Sort by &raquo;{% endtrans %}</span>\n        {#% endif %#}\n            {% if settings.KARMA_MODE == 'public' %}\n            <a \n                id=\"sort_reputation\"\n                href=\"{{ request.path|escape }}?sort=reputation\"\n                {% if tab_id == 'reputation' %}class=\"on\"{% endif %}\n                title=\"{% trans %}see people with the highest reputation{% endtrans %}\"\n            ><span>{% trans %}karma{% endtrans %}</span></a>\n            {% endif %}\n            <a \n                id=\"sort_newest\"\n                href=\"{{ request.path|escape }}?sort=newest\"\n                {% if tab_id == 'newest' %}class=\"on\"{% endif %}\n                class=\"off\" title=\"{% trans %}see people who joined most recently{% endtrans %}\"\n            ><span>{% trans %}recent{% endtrans %}</span></a>\n            <a \n                id=\"sort_last\"\n                href=\"{{ request.path|escape }}?sort=last\"\n                {% if tab_id == 'last' %}class=\"on\"{% endif %}\n                class=\"off\" title=\"{% trans %}see people who joined the site first{% endtrans %}\"\n            ><span>{% trans %}oldest{% endtrans %}<span></a>\n            <a \n                id=\"sort_user\"\n                href=\"{{ request.path|escape }}?sort=user\"\n                {% if tab_id == 'user' %}class=\"on\"{% endif %}\n                title=\"{% trans %}see people sorted by name{% endtrans %}\"\n            ><span>{% trans %}by username{% endtrans %}</span></a>\n        </div>\n    </div>\n    <div class=\"clearfix\"></div>\n</div>\n{% if search_query %}\n    <p>{% trans %}users matching query {{search_query}}:{% endtrans %}</p>\n{% endif %}\n{% if not users.object_list %}\n    <p><span>{% trans %}Nothing found.{% endtrans %}</span></p>\n{% endif %}\n{{ macros.user_list(\n        users.object_list, \n        karma_mode = settings.KARMA_MODE, badges_mode = settings.BADGES_MODE\n    )\n}}\n<div class=\"pager\">\n    {{ macros.paginator(paginator_context) }}\n</div>              \n{% endblock %}\n{% block sidebar %}\n    {% if group %}\n        {# this widget takes variables: group, user_can_join_group, user_is_group_member #}\n        {% include \"widgets/group_info.html\" %}\n    {% endif %}\n{% endblock %}\n{% block endjs %}\n    <script type='text/javascript'>\n        var Attacklab = Attacklab || {};\n        Attacklab.wmd = 1;{# a trick to launch wmd manually #}\n        askbot['urls']['upload'] = '{% url upload %}';\n        askbot['urls']['load_object_description'] = '{% url load_object_description %}';\n        askbot['urls']['save_object_description'] = '{% url save_object_description %}';\n        askbot['urls']['save_group_logo_url'] = '{% url save_group_logo_url %}';\n        askbot['urls']['delete_group_logo_url'] = '{% url delete_group_logo %}';\n        askbot['urls']['join_or_leave_group'] = '{% url join_or_leave_group %}';\n    </script>\n    <script type='text/javascript' src='{{\"/js/editor.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/wmd/showdown.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/wmd/wmd.js\"|media}}'></script>\n    <script type='text/javascript' src='{{\"/js/jquery.validate.min.js\"|media}}'></script>\n    <script src='{{\"/js/post.js\"|media}}' type='text/javascript'></script>\n    <script type=\"text/javascript\">\n        //todo move javascript out\n        {% if settings.ENABLE_MATHJAX or settings.MARKUP_CODE_FRIENDLY %}\n            var codeFriendlyMarkdown = true;\n        {% else %}\n            var codeFriendlyMarkdown = false;\n        {% endif %}\n        {% if group and request.user.is_authenticated() %}\n            $().ready(function(){\n                var group_join_btn = new GroupJoinButton();\n                group_join_btn.decorate($('.group-join-btn'));\n                //setup WMD editor\n                if (askbot['data']['userIsAdminOrMod'] === true){\n                    //todo: this is kind of Attacklab.init ... should not be here\n                    Attacklab.wmd = function(){\n                        Attacklab.loadEnv = function(){\n                            var mergeEnv = function(env){\n                                if(!env){\n                                    return;\n                                }\n                            \n                                for(var key in env){\n                                    Attacklab.wmd_env[key] = env[key];\n                                }\n                            };\n                            \n                            mergeEnv(Attacklab.wmd_defaults);\n                            mergeEnv(Attacklab.account_options);\n                            mergeEnv(top[\"wmd_options\"]);\n                            Attacklab.full = true;\n                            \n                            var defaultButtons = \"bold italic link blockquote code image ol ul heading hr\";\n                            Attacklab.wmd_env.buttons = Attacklab.wmd_env.buttons || defaultButtons;\n                        };\n                        Attacklab.loadEnv();\n                    };\n                    Attacklab.wmd();\n                    Attacklab.wmdBase();\n                    var group_editor = new UserGroupProfileEditor();\n                    group_editor.decorate($('#group-wiki-{{group.id}}'));\n                }\n                Hilite.exact = false;\n                Hilite.elementid = \"main-body\";\n                Hilite.debug_referrer = location.href;\n            });\n        {% endif %}\n    </script>\n{% endblock %}\n<!-- end users.html -->\n", "patch": "@@ -63,7 +63,7 @@ <h1 class=\"section-title\">\n     <div class=\"clearfix\"></div>\n </div>\n {% if search_query %}\n-    <p>{% trans %}users matching query {{search_query}}:{% endtrans %}</p>\n+    <p>{% trans search_query=search_query|escape %}users matching query {{search_query}}:{% endtrans %}</p>\n {% endif %}\n {% if not users.object_list %}\n     <p><span>{% trans %}Nothing found.{% endtrans %}</span></p>", "file_path": "files/2014_3/113", "file_language": "html", "file_name": "askbot/templates/users.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ASKBOT/askbot-devel/raw/a676a86b6b7a5737d4da4f59f71e037406f88d29/askbot%2Futils%2Ffunctions.py", "code": "import re\nimport random\nimport datetime\nfrom django.utils.translation import ugettext as _\nfrom django.utils.translation import ungettext\nfrom django.utils.html import escape\n\ndef get_from_dict_or_object(source, key):\n    try:\n        return source[key]\n    except:\n        return getattr(source, key)\n\n\ndef enumerate_string_list(strings):\n    \"\"\"for a list or a tuple ('one', 'two',) return\n    a list formatted as ['1) one', '2) two',]\n    \"\"\"\n    numbered_strings = enumerate(strings, start = 1)\n    return [ '%d) %s' % item for item in numbered_strings ]\n\ndef pad_string(text):\n    \"\"\"Inserts one space between words,\n    including one space before the first word\n    and after the last word.\n    String without words is collapsed to ''\n    \"\"\"\n    words = text.strip().split()\n    if len(words) > 0:\n        return ' ' + ' '.join(words) + ' '\n    else:\n        return ''\n\ndef split_list(text):\n    \"\"\"Takes text, representing a loosely formatted\n    list (comma, semicolon, empty space separated\n    words) and returns a list() of words.\n    \"\"\"\n    text = text.replace(',', ' ').replace(';', ' ')\n    return text.strip().split()\n\ndef is_iterable(thing):\n    if hasattr(thing, '__iter__'):\n        return True\n    else:\n        return isinstance(thing, basestring)\n\nBOT_REGEX = re.compile(\n    r'bot|http|\\.com|crawl|spider|python|curl|yandex'\n)\nBROWSER_REGEX = re.compile(\n    r'^(Mozilla.*(Gecko|KHTML|MSIE|Presto|Trident)|Opera).*$'\n)\nMOBILE_REGEX = re.compile(\n    r'(BlackBerry|HTC|LG|MOT|Nokia|NOKIAN|PLAYSTATION|PSP|SAMSUNG|SonyEricsson)'\n)\n\n\ndef strip_plus(text):\n    \"\"\"returns text with redundant spaces replaced with just one,\n    and stripped leading and the trailing spaces\"\"\"\n    return re.sub('\\s+', ' ', text).strip()\n\n\ndef not_a_robot_request(request):\n\n    if 'HTTP_ACCEPT_LANGUAGE' not in request.META:\n        return False\n\n    user_agent = request.META.get('HTTP_USER_AGENT', None)\n    if user_agent is None:\n        return False\n\n    if BOT_REGEX.match(user_agent, re.IGNORECASE):\n        return False\n\n    if MOBILE_REGEX.match(user_agent):\n        return True\n\n    if BROWSER_REGEX.search(user_agent):\n        return True\n\n    return False\n\ndef diff_date(date, use_on_prefix = False):\n    now = datetime.datetime.now()#datetime(*time.localtime()[0:6])#???\n    diff = now - date\n    days = diff.days\n    hours = int(diff.seconds/3600)\n    minutes = int(diff.seconds/60)\n\n    if days > 2:\n        if date.year == now.year:\n            date_token = date.strftime(\"%b %d\")\n        else:\n            date_token = date.strftime(\"%b %d '%y\")\n        if use_on_prefix:\n            return _('on %(date)s') % { 'date': date_token }\n        else:\n            return date_token\n    elif days == 2:\n        return _('2 days ago')\n    elif days == 1:\n        return _('yesterday')\n    elif minutes >= 60:\n        return ungettext(\n            '%(hr)d hour ago',\n            '%(hr)d hours ago',\n            hours\n        ) % {'hr':hours}\n    else:\n        return ungettext(\n            '%(min)d min ago',\n            '%(min)d mins ago',\n            minutes\n        ) % {'min':minutes}\n\n#todo: this function may need to be removed to simplify the paginator functionality\nLEADING_PAGE_RANGE_DISPLAYED = TRAILING_PAGE_RANGE_DISPLAYED = 5\nLEADING_PAGE_RANGE = TRAILING_PAGE_RANGE = 4\nNUM_PAGES_OUTSIDE_RANGE = 1\nADJACENT_PAGES = 2\ndef setup_paginator(context):\n    \"\"\"\n    custom paginator tag\n    Inspired from http://blog.localkinegrinds.com/2007/09/06/digg-style-pagination-in-django/\n    \"\"\"\n    if (context[\"is_paginated\"]):\n        \" Initialize variables \"\n        in_leading_range = in_trailing_range = False\n        pages_outside_leading_range = pages_outside_trailing_range = range(0)\n\n        if (context[\"pages\"] <= LEADING_PAGE_RANGE_DISPLAYED):\n            in_leading_range = in_trailing_range = True\n            page_numbers = [n for n in range(1, context[\"pages\"] + 1) if n > 0 and n <= context[\"pages\"]]\n        elif (context[\"current_page_number\"] <= LEADING_PAGE_RANGE):\n            in_leading_range = True\n            page_numbers = [n for n in range(1, LEADING_PAGE_RANGE_DISPLAYED + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_leading_range = [n + context[\"pages\"] for n in range(0, -NUM_PAGES_OUTSIDE_RANGE, -1)]\n        elif (context[\"current_page_number\"] > context[\"pages\"] - TRAILING_PAGE_RANGE):\n            in_trailing_range = True\n            page_numbers = [n for n in range(context[\"pages\"] - TRAILING_PAGE_RANGE_DISPLAYED + 1, context[\"pages\"] + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_trailing_range = [n + 1 for n in range(0, NUM_PAGES_OUTSIDE_RANGE)]\n        else:\n            page_numbers = [n for n in range(context[\"current_page_number\"] - ADJACENT_PAGES, context[\"current_page_number\"] + ADJACENT_PAGES + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_leading_range = [n + context[\"pages\"] for n in range(0, -NUM_PAGES_OUTSIDE_RANGE, -1)]\n            pages_outside_trailing_range = [n + 1 for n in range(0, NUM_PAGES_OUTSIDE_RANGE)]\n\n        page_object = context['page_object']\n        #patch for change in django 1.5\n        if page_object.has_previous():\n            previous_page_number = page_object.previous_page_number()\n        else:\n            previous_page_number = None\n\n        if page_object.has_next():\n            next_page_number = page_object.next_page_number()\n        else:\n            next_page_number = None\n\n        return {\n            \"base_url\": escape(context[\"base_url\"]),\n            \"is_paginated\": context[\"is_paginated\"],\n            \"previous\": previous_page_number,\n            \"has_previous\": page_object.has_previous(),\n            \"next\": next_page_number,\n            \"has_next\": page_object.has_next(),\n            \"page\": context[\"current_page_number\"],\n            \"pages\": context[\"pages\"],\n            \"page_numbers\": page_numbers,\n            \"in_leading_range\" : in_leading_range,\n            \"in_trailing_range\" : in_trailing_range,\n            \"pages_outside_leading_range\": pages_outside_leading_range,\n            \"pages_outside_trailing_range\": pages_outside_trailing_range,\n        }\n\ndef get_admin():\n    \"\"\"Returns an admin users, usefull for raising flags\"\"\"\n    try:\n        from django.contrib.auth.models import User\n        return User.objects.filter(is_superuser=True)[0]\n    except:\n        raise Exception('there is no admin users')\n\ndef generate_random_key(length=16):\n    \"\"\"return random string, length is number of characters\"\"\"\n    random.seed()\n    assert(isinstance(length, int))\n    format_string = '%0' + str(2*length) + 'x'\n    return format_string % random.getrandbits(length*8)\n", "code_before": "import re\nimport random\nimport datetime\nfrom django.utils.translation import ugettext as _\nfrom django.utils.translation import ungettext\n\ndef get_from_dict_or_object(source, key):\n    try:\n        return source[key]\n    except:\n        return getattr(source, key)\n\n\ndef enumerate_string_list(strings):\n    \"\"\"for a list or a tuple ('one', 'two',) return\n    a list formatted as ['1) one', '2) two',]\n    \"\"\"\n    numbered_strings = enumerate(strings, start = 1)\n    return [ '%d) %s' % item for item in numbered_strings ]\n\ndef pad_string(text):\n    \"\"\"Inserts one space between words,\n    including one space before the first word\n    and after the last word.\n    String without words is collapsed to ''\n    \"\"\"\n    words = text.strip().split()\n    if len(words) > 0:\n        return ' ' + ' '.join(words) + ' '\n    else:\n        return ''\n\ndef split_list(text):\n    \"\"\"Takes text, representing a loosely formatted\n    list (comma, semicolon, empty space separated\n    words) and returns a list() of words.\n    \"\"\"\n    text = text.replace(',', ' ').replace(';', ' ')\n    return text.strip().split()\n\ndef is_iterable(thing):\n    if hasattr(thing, '__iter__'):\n        return True\n    else:\n        return isinstance(thing, basestring)\n\nBOT_REGEX = re.compile(\n    r'bot|http|\\.com|crawl|spider|python|curl|yandex'\n)\nBROWSER_REGEX = re.compile(\n    r'^(Mozilla.*(Gecko|KHTML|MSIE|Presto|Trident)|Opera).*$'\n)\nMOBILE_REGEX = re.compile(\n    r'(BlackBerry|HTC|LG|MOT|Nokia|NOKIAN|PLAYSTATION|PSP|SAMSUNG|SonyEricsson)'\n)\n\n\ndef strip_plus(text):\n    \"\"\"returns text with redundant spaces replaced with just one,\n    and stripped leading and the trailing spaces\"\"\"\n    return re.sub('\\s+', ' ', text).strip()\n\n\ndef not_a_robot_request(request):\n\n    if 'HTTP_ACCEPT_LANGUAGE' not in request.META:\n        return False\n\n    user_agent = request.META.get('HTTP_USER_AGENT', None)\n    if user_agent is None:\n        return False\n\n    if BOT_REGEX.match(user_agent, re.IGNORECASE):\n        return False\n\n    if MOBILE_REGEX.match(user_agent):\n        return True\n\n    if BROWSER_REGEX.search(user_agent):\n        return True\n\n    return False\n\ndef diff_date(date, use_on_prefix = False):\n    now = datetime.datetime.now()#datetime(*time.localtime()[0:6])#???\n    diff = now - date\n    days = diff.days\n    hours = int(diff.seconds/3600)\n    minutes = int(diff.seconds/60)\n\n    if days > 2:\n        if date.year == now.year:\n            date_token = date.strftime(\"%b %d\")\n        else:\n            date_token = date.strftime(\"%b %d '%y\")\n        if use_on_prefix:\n            return _('on %(date)s') % { 'date': date_token }\n        else:\n            return date_token\n    elif days == 2:\n        return _('2 days ago')\n    elif days == 1:\n        return _('yesterday')\n    elif minutes >= 60:\n        return ungettext(\n            '%(hr)d hour ago',\n            '%(hr)d hours ago',\n            hours\n        ) % {'hr':hours}\n    else:\n        return ungettext(\n            '%(min)d min ago',\n            '%(min)d mins ago',\n            minutes\n        ) % {'min':minutes}\n\n#todo: this function may need to be removed to simplify the paginator functionality\nLEADING_PAGE_RANGE_DISPLAYED = TRAILING_PAGE_RANGE_DISPLAYED = 5\nLEADING_PAGE_RANGE = TRAILING_PAGE_RANGE = 4\nNUM_PAGES_OUTSIDE_RANGE = 1\nADJACENT_PAGES = 2\ndef setup_paginator(context):\n    \"\"\"\n    custom paginator tag\n    Inspired from http://blog.localkinegrinds.com/2007/09/06/digg-style-pagination-in-django/\n    \"\"\"\n    if (context[\"is_paginated\"]):\n        \" Initialize variables \"\n        in_leading_range = in_trailing_range = False\n        pages_outside_leading_range = pages_outside_trailing_range = range(0)\n\n        if (context[\"pages\"] <= LEADING_PAGE_RANGE_DISPLAYED):\n            in_leading_range = in_trailing_range = True\n            page_numbers = [n for n in range(1, context[\"pages\"] + 1) if n > 0 and n <= context[\"pages\"]]\n        elif (context[\"current_page_number\"] <= LEADING_PAGE_RANGE):\n            in_leading_range = True\n            page_numbers = [n for n in range(1, LEADING_PAGE_RANGE_DISPLAYED + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_leading_range = [n + context[\"pages\"] for n in range(0, -NUM_PAGES_OUTSIDE_RANGE, -1)]\n        elif (context[\"current_page_number\"] > context[\"pages\"] - TRAILING_PAGE_RANGE):\n            in_trailing_range = True\n            page_numbers = [n for n in range(context[\"pages\"] - TRAILING_PAGE_RANGE_DISPLAYED + 1, context[\"pages\"] + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_trailing_range = [n + 1 for n in range(0, NUM_PAGES_OUTSIDE_RANGE)]\n        else:\n            page_numbers = [n for n in range(context[\"current_page_number\"] - ADJACENT_PAGES, context[\"current_page_number\"] + ADJACENT_PAGES + 1) if n > 0 and n <= context[\"pages\"]]\n            pages_outside_leading_range = [n + context[\"pages\"] for n in range(0, -NUM_PAGES_OUTSIDE_RANGE, -1)]\n            pages_outside_trailing_range = [n + 1 for n in range(0, NUM_PAGES_OUTSIDE_RANGE)]\n\n        page_object = context['page_object']\n        #patch for change in django 1.5\n        if page_object.has_previous():\n            previous_page_number = page_object.previous_page_number()\n        else:\n            previous_page_number = None\n\n        if page_object.has_next():\n            next_page_number = page_object.next_page_number()\n        else:\n            next_page_number = None\n\n        return {\n            \"base_url\": context[\"base_url\"],\n            \"is_paginated\": context[\"is_paginated\"],\n            \"previous\": previous_page_number,\n            \"has_previous\": page_object.has_previous(),\n            \"next\": next_page_number,\n            \"has_next\": page_object.has_next(),\n            \"page\": context[\"current_page_number\"],\n            \"pages\": context[\"pages\"],\n            \"page_numbers\": page_numbers,\n            \"in_leading_range\" : in_leading_range,\n            \"in_trailing_range\" : in_trailing_range,\n            \"pages_outside_leading_range\": pages_outside_leading_range,\n            \"pages_outside_trailing_range\": pages_outside_trailing_range,\n        }\n\ndef get_admin():\n    \"\"\"Returns an admin users, usefull for raising flags\"\"\"\n    try:\n        from django.contrib.auth.models import User\n        return User.objects.filter(is_superuser=True)[0]\n    except:\n        raise Exception('there is no admin users')\n\ndef generate_random_key(length=16):\n    \"\"\"return random string, length is number of characters\"\"\"\n    random.seed()\n    assert(isinstance(length, int))\n    format_string = '%0' + str(2*length) + 'x'\n    return format_string % random.getrandbits(length*8)\n", "patch": "@@ -3,6 +3,7 @@\n import datetime\n from django.utils.translation import ugettext as _\n from django.utils.translation import ungettext\n+from django.utils.html import escape\n \n def get_from_dict_or_object(source, key):\n     try:\n@@ -158,7 +159,7 @@ def setup_paginator(context):\n             next_page_number = None\n \n         return {\n-            \"base_url\": context[\"base_url\"],\n+            \"base_url\": escape(context[\"base_url\"]),\n             \"is_paginated\": context[\"is_paginated\"],\n             \"previous\": previous_page_number,\n             \"has_previous\": page_object.has_previous(),", "file_path": "files/2014_3/114", "file_language": "py", "file_name": "askbot/utils/functions.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/ASKBOT/askbot-devel/raw/a676a86b6b7a5737d4da4f59f71e037406f88d29/askbot%2Fviews%2Fcommands.py", "code": "\"\"\"\n:synopsis: most ajax processors for askbot\n\nThis module contains most (but not all) processors for Ajax requests.\nNot so clear if this subdivision was necessary as separation of Ajax and non-ajax views\nis not always very clean.\n\"\"\"\nimport datetime\nimport logging\nfrom bs4 import BeautifulSoup\nfrom django.conf import settings as django_settings\nfrom django.core import exceptions\n#from django.core.management import call_command\nfrom django.core.urlresolvers import reverse\nfrom django.contrib.auth.decorators import login_required\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseBadRequest\nfrom django.http import HttpResponseRedirect\nfrom django.http import HttpResponseForbidden\nfrom django.forms import ValidationError, IntegerField, CharField\nfrom django.shortcuts import get_object_or_404\nfrom django.shortcuts import render\nfrom django.template.loader import get_template\nfrom django.views.decorators import csrf\nfrom django.utils import simplejson\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\nfrom django.utils.translation import string_concat\nfrom askbot.utils.slug import slugify\nfrom askbot import models\nfrom askbot import forms\nfrom askbot import conf\nfrom askbot import const\nfrom askbot import mail\nfrom askbot.conf import settings as askbot_settings\nfrom askbot.utils import category_tree\nfrom askbot.utils import decorators\nfrom askbot.utils import url_utils\nfrom askbot.utils.forms import get_db_object_or_404\nfrom django.template import RequestContext\nfrom askbot.skins.loaders import render_into_skin_as_string\nfrom askbot.skins.loaders import render_text_into_skin\nfrom askbot.models.tag import get_tags_by_names\n\n\n\n@csrf.csrf_exempt\ndef manage_inbox(request):\n    \"\"\"delete, mark as new or seen user's\n    response memo objects, excluding flags\n    request data is memo_list  - list of integer id's of the ActivityAuditStatus items\n    and action_type - string - one of delete|mark_new|mark_seen\n    \"\"\"\n\n    response_data = dict()\n    try:\n        if request.is_ajax():\n            if request.method == 'POST':\n                post_data = simplejson.loads(request.raw_post_data)\n                if request.user.is_authenticated():\n                    activity_types = const.RESPONSE_ACTIVITY_TYPES_FOR_DISPLAY\n                    activity_types += (\n                        const.TYPE_ACTIVITY_MENTION,\n                        const.TYPE_ACTIVITY_MARK_OFFENSIVE,\n                        const.TYPE_ACTIVITY_MODERATED_NEW_POST,\n                        const.TYPE_ACTIVITY_MODERATED_POST_EDIT\n                    )\n                    user = request.user\n                    memo_set = models.ActivityAuditStatus.objects.filter(\n                        id__in = post_data['memo_list'],\n                        activity__activity_type__in = activity_types,\n                        user = user\n                    )\n\n                    action_type = post_data['action_type']\n                    if action_type == 'delete':\n                        memo_set.delete()\n                    elif action_type == 'mark_new':\n                        memo_set.update(status = models.ActivityAuditStatus.STATUS_NEW)\n                    elif action_type == 'mark_seen':\n                        memo_set.update(status = models.ActivityAuditStatus.STATUS_SEEN)\n                    elif action_type == 'remove_flag':\n                        for memo in memo_set:\n                            activity_type = memo.activity.activity_type\n                            if activity_type == const.TYPE_ACTIVITY_MARK_OFFENSIVE:\n                                request.user.flag_post(\n                                    post = memo.activity.content_object,\n                                    cancel_all = True\n                                )\n                            elif activity_type in \\\n                                (\n                                    const.TYPE_ACTIVITY_MODERATED_NEW_POST,\n                                    const.TYPE_ACTIVITY_MODERATED_POST_EDIT\n                                ):\n                                post_revision = memo.activity.content_object\n                                request.user.approve_post_revision(post_revision)\n                                memo.delete()\n\n                    #elif action_type == 'close':\n                    #    for memo in memo_set:\n                    #        if memo.activity.content_object.post_type == \"question\":\n                    #            request.user.close_question(question = memo.activity.content_object, reason = 7)\n                    #            memo.delete()\n                    elif action_type == 'delete_post':\n                        for memo in memo_set:\n                            content_object = memo.activity.content_object\n                            if isinstance(content_object, models.PostRevision):\n                                post = content_object.post\n                            else:\n                                post = content_object\n                            request.user.delete_post(post)\n                            reject_reason = models.PostFlagReason.objects.get(\n                                                    id = post_data['reject_reason_id']\n                                                )\n                            template = get_template('email/rejected_post.html')\n                            data = {\n                                    'post': post.html,\n                                    'reject_reason': reject_reason.details.html\n                                   }\n                            body_text = template.render(RequestContext(request, data))\n                            mail.send_mail(\n                                subject_line = _('your post was not accepted'),\n                                body_text = unicode(body_text),\n                                recipient_list = [post.author.email,]\n                            )\n                            memo.delete()\n\n                    user.update_response_counts()\n\n                    response_data['success'] = True\n                    data = simplejson.dumps(response_data)\n                    return HttpResponse(data, mimetype=\"application/json\")\n                else:\n                    raise exceptions.PermissionDenied(\n                        _('Sorry, but anonymous users cannot access the inbox')\n                    )\n            else:\n                raise exceptions.PermissionDenied('must use POST request')\n        else:\n            #todo: show error page but no-one is likely to get here\n            return HttpResponseRedirect(reverse('index'))\n    except Exception, e:\n        message = unicode(e)\n        if message == '':\n            message = _('Oops, apologies - there was some error')\n        response_data['message'] = message\n        response_data['success'] = False\n        data = simplejson.dumps(response_data)\n        return HttpResponse(data, mimetype=\"application/json\")\n\n\ndef process_vote(user = None, vote_direction = None, post = None):\n    \"\"\"function (non-view) that actually processes user votes\n    - i.e. up- or down- votes\n\n    in the future this needs to be converted into a real view function\n    for that url and javascript will need to be adjusted\n\n    also in the future make keys in response data be more meaningful\n    right now they are kind of cryptic - \"status\", \"count\"\n    \"\"\"\n    if user.is_anonymous():\n        raise exceptions.PermissionDenied(_(\n            'Sorry, anonymous users cannot vote'\n        ))\n\n    user.assert_can_vote_for_post(post = post, direction = vote_direction)\n    vote = user.get_old_vote_for_post(post)\n    response_data = {}\n    if vote != None:\n        user.assert_can_revoke_old_vote(vote)\n        score_delta = vote.cancel()\n        response_data['count'] = post.points+ score_delta\n        response_data['status'] = 1 #this means \"cancel\"\n\n    else:\n        #this is a new vote\n        votes_left = user.get_unused_votes_today()\n        if votes_left <= 0:\n            raise exceptions.PermissionDenied(\n                            _('Sorry you ran out of votes for today')\n                        )\n\n        votes_left -= 1\n        if votes_left <= \\\n            askbot_settings.VOTES_LEFT_WARNING_THRESHOLD:\n            msg = _('You have %(votes_left)s votes left for today') \\\n                    % {'votes_left': votes_left }\n            response_data['message'] = msg\n\n        if vote_direction == 'up':\n            vote = user.upvote(post = post)\n        else:\n            vote = user.downvote(post = post)\n\n        response_data['count'] = post.points\n        response_data['status'] = 0 #this means \"not cancel\", normal operation\n\n    response_data['success'] = 1\n\n    return response_data\n\n\n@csrf.csrf_exempt\ndef vote(request):\n    \"\"\"\n    todo: this subroutine needs serious refactoring it's too long and is hard to understand\n\n    vote_type:\n        acceptAnswer : 0,\n        questionUpVote : 1,\n        questionDownVote : 2,\n        favorite : 4,\n        answerUpVote: 5,\n        answerDownVote:6,\n        offensiveQuestion : 7,\n        remove offensiveQuestion flag : 7.5,\n        remove all offensiveQuestion flag : 7.6,\n        offensiveAnswer:8,\n        remove offensiveAnswer flag : 8.5,\n        remove all offensiveAnswer flag : 8.6,\n        removeQuestion: 9,\n        removeAnswer:10\n        questionSubscribeUpdates:11\n        questionUnSubscribeUpdates:12\n\n    accept answer code:\n        response_data['allowed'] = -1, Accept his own answer   0, no allowed - Anonymous    1, Allowed - by default\n        response_data['success'] =  0, failed                                               1, Success - by default\n        response_data['status']  =  0, By default                       1, Answer has been accepted already(Cancel)\n\n    vote code:\n        allowed = -3, Don't have enough votes left\n                  -2, Don't have enough reputation score\n                  -1, Vote his own post\n                   0, no allowed - Anonymous\n                   1, Allowed - by default\n        status  =  0, By default\n                   1, Cancel\n                   2, Vote is too old to be canceled\n\n    offensive code:\n        allowed = -3, Don't have enough flags left\n                  -2, Don't have enough reputation score to do this\n                   0, not allowed\n                   1, allowed\n        status  =  0, by default\n                   1, can't do it again\n    \"\"\"\n    response_data = {\n        \"allowed\": 1,\n        \"success\": 1,\n        \"status\" : 0,\n        \"count\"  : 0,\n        \"message\" : ''\n    }\n\n    try:\n        if request.is_ajax() and request.method == 'POST':\n            vote_type = request.POST.get('type')\n        else:\n            raise Exception(_('Sorry, something is not right here...'))\n\n        id = request.POST.get('postId')\n\n        if vote_type == '0':\n            if askbot_settings.ACCEPTING_ANSWERS_ENABLED is False:\n                return\n            if request.user.is_authenticated():\n                answer_id = request.POST.get('postId')\n                answer = get_object_or_404(models.Post, post_type='answer', id = answer_id)\n                # make sure question author is current user\n                if answer.accepted():\n                    request.user.unaccept_best_answer(answer)\n                    response_data['status'] = 1 #cancelation\n                else:\n                    request.user.accept_best_answer(answer)\n\n                ####################################################################\n                answer.thread.update_summary_html() # regenerate question/thread summary html\n                ####################################################################\n\n            else:\n                raise exceptions.PermissionDenied(\n                        _('Sorry, but anonymous users cannot accept answers')\n                    )\n\n        elif vote_type in ('1', '2', '5', '6'):#Q&A up/down votes\n\n            ###############################\n            # all this can be avoided with\n            # better query parameters\n            vote_direction = 'up'\n            if vote_type in ('2','6'):\n                vote_direction = 'down'\n\n            if vote_type in ('5', '6'):\n                #todo: fix this weirdness - why postId here\n                #and not with question?\n                post_id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=post_id)\n            else:\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            #\n            ######################\n\n            response_data = process_vote(\n                                        user = request.user,\n                                        vote_direction = vote_direction,\n                                        post = post\n                                    )\n\n            ####################################################################\n            if vote_type in ('1', '2'): # up/down-vote question\n                post.thread.update_summary_html() # regenerate question/thread summary html\n            ####################################################################\n\n        elif vote_type in ['7', '8']:\n            #flag question or answer\n            if vote_type == '7':\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '8':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            request.user.flag_post(post)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['7.5', '8.5']:\n            #flag question or answer\n            if vote_type == '7.5':\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '8.5':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            request.user.flag_post(post, cancel = True)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['7.6', '8.6']:\n            #flag question or answer\n            if vote_type == '7.6':\n                post = get_object_or_404(models.Post, id=id)\n            if vote_type == '8.6':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, id=id)\n\n            request.user.flag_post(post, cancel_all = True)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['9', '10']:\n            #delete question or answer\n            post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '10':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            if post.deleted == True:\n                request.user.restore_post(post = post)\n            else:\n                request.user.delete_post(post = post)\n\n        elif request.is_ajax() and request.method == 'POST':\n\n            if not request.user.is_authenticated():\n                response_data['allowed'] = 0\n                response_data['success'] = 0\n\n            question = get_object_or_404(models.Post, post_type='question', id=id)\n            vote_type = request.POST.get('type')\n\n            #accept answer\n            if vote_type == '4':\n                fave = request.user.toggle_favorite_question(question)\n                response_data['count'] = models.FavoriteQuestion.objects.filter(thread = question.thread).count()\n                if fave == False:\n                    response_data['status'] = 1\n\n            elif vote_type == '11':#subscribe q updates\n                user = request.user\n                if user.is_authenticated():\n                    if user not in question.thread.followed_by.all():\n                        user.follow_question(question)\n                        if askbot_settings.EMAIL_VALIDATION == True \\\n                            and user.email_isvalid == False:\n\n                            response_data['message'] = \\\n                                    _(\n                                        'Your subscription is saved, but email address '\n                                        '%(email)s needs to be validated, please see '\n                                        '<a href=\"%(details_url)s\">more details here</a>'\n                                    ) % {'email':user.email,'details_url':reverse('faq') + '#validate'}\n\n                    subscribed = user.subscribe_for_followed_question_alerts()\n                    if subscribed:\n                        if 'message' in response_data:\n                            response_data['message'] += '<br/>'\n                        response_data['message'] += _('email update frequency has been set to daily')\n                    #response_data['status'] = 1\n                    #responst_data['allowed'] = 1\n                else:\n                    pass\n                    #response_data['status'] = 0\n                    #response_data['allowed'] = 0\n            elif vote_type == '12':#unsubscribe q updates\n                user = request.user\n                if user.is_authenticated():\n                    user.unfollow_question(question)\n        else:\n            response_data['success'] = 0\n            response_data['message'] = u'Request mode is not supported. Please try again.'\n\n        if vote_type not in (1, 2, 4, 5, 6, 11, 12):\n            #favorite or subscribe/unsubscribe\n            #upvote or downvote question or answer - those\n            #are handled within user.upvote and user.downvote\n            post = models.Post.objects.get(id = id)\n            post.thread.invalidate_cached_data()\n\n        data = simplejson.dumps(response_data)\n\n    except Exception, e:\n        response_data['message'] = unicode(e)\n        response_data['success'] = 0\n        data = simplejson.dumps(response_data)\n    return HttpResponse(data, mimetype=\"application/json\")\n\n#internally grouped views - used by the tagging system\n@csrf.csrf_exempt\n@decorators.post_only\n@decorators.ajax_login_required\ndef mark_tag(request, **kwargs):#tagging system\n    action = kwargs['action']\n    post_data = simplejson.loads(request.raw_post_data)\n    raw_tagnames = post_data['tagnames']\n    reason = post_data['reason']\n    assert reason in ('good', 'bad', 'subscribed')\n    #separate plain tag names and wildcard tags\n    tagnames, wildcards = forms.clean_marked_tagnames(raw_tagnames)\n\n    if request.user.is_administrator() and 'user' in post_data:\n        user = get_object_or_404(models.User, pk=post_data['user'])\n    else:\n        user = request.user\n\n    cleaned_tagnames, cleaned_wildcards = user.mark_tags(\n                                                         tagnames,\n                                                         wildcards,\n                                                         reason = reason,\n                                                         action = action\n                                                        )\n\n    #lastly - calculate tag usage counts\n    tag_usage_counts = dict()\n    for name in tagnames:\n        if name in cleaned_tagnames:\n            tag_usage_counts[name] = 1\n        else:\n            tag_usage_counts[name] = 0\n\n    for name in wildcards:\n        if name in cleaned_wildcards:\n            tag_usage_counts[name] = models.Tag.objects.filter(\n                                        name__startswith = name[:-1]\n                                    ).count()\n        else:\n            tag_usage_counts[name] = 0\n\n    return HttpResponse(simplejson.dumps(tag_usage_counts), mimetype=\"application/json\")\n\n#@decorators.ajax_only\n@decorators.get_only\ndef get_tags_by_wildcard(request):\n    \"\"\"returns an json encoded array of tag names\n    in the response to a wildcard tag name\n    \"\"\"\n    wildcard = request.GET.get('wildcard', None)\n    if wildcard is None:\n        return HttpResponseForbidden()\n\n    matching_tags = models.Tag.objects.get_by_wildcards( [wildcard,] )\n    count = matching_tags.count()\n    names = matching_tags.values_list('name', flat = True)[:20]\n    re_data = simplejson.dumps({'tag_count': count, 'tag_names': list(names)})\n    return HttpResponse(re_data, mimetype = 'application/json')\n\n@decorators.get_only\ndef get_thread_shared_users(request):\n    \"\"\"returns snippet of html with users\"\"\"\n    thread_id = request.GET['thread_id']\n    thread_id = IntegerField().clean(thread_id)\n    thread = models.Thread.objects.get(id=thread_id)\n    users = thread.get_users_shared_with()\n    data = {\n        'users': users,\n    }\n    html = render_into_skin_as_string('widgets/user_list.html', data, request)\n    re_data = simplejson.dumps({\n        'html': html,\n        'users_count': users.count(),\n        'success': True\n    })\n    return HttpResponse(re_data, mimetype='application/json')\n\n@decorators.get_only\ndef get_thread_shared_groups(request):\n    \"\"\"returns snippet of html with groups\"\"\"\n    thread_id = request.GET['thread_id']\n    thread_id = IntegerField().clean(thread_id)\n    thread = models.Thread.objects.get(id=thread_id)\n    groups = thread.get_groups_shared_with()\n    data = {'groups': groups}\n    html = render_into_skin_as_string('widgets/groups_list.html', data, request)\n    re_data = simplejson.dumps({\n        'html': html,\n        'groups_count': groups.count(),\n        'success': True\n    })\n    return HttpResponse(re_data, mimetype='application/json')\n\n@decorators.ajax_only\ndef get_html_template(request):\n    \"\"\"returns rendered template\"\"\"\n    template_name = request.REQUEST.get('template_name', None)\n    allowed_templates = (\n        'widgets/tag_category_selector.html',\n    )\n    #have allow simple context for the templates\n    if template_name not in allowed_templates:\n        raise Http404\n    return {\n        'html': get_template(template_name).render()\n    }\n\n@decorators.get_only\ndef get_tag_list(request):\n    \"\"\"returns tags to use in the autocomplete\n    function\n    \"\"\"\n    tags = models.Tag.objects.filter(\n                        deleted = False,\n                        status = models.Tag.STATUS_ACCEPTED\n                    )\n\n    tag_names = tags.values_list(\n                        'name', flat = True\n                    )\n\n    output = '\\n'.join(map(escape, tag_names))\n    return HttpResponse(output, mimetype = 'text/plain')\n\n@decorators.get_only\ndef load_object_description(request):\n    \"\"\"returns text of the object description in text\"\"\"\n    obj = get_db_object_or_404(request.GET)#askbot forms utility\n    text = getattr(obj.description, 'text', '').strip()\n    return HttpResponse(text, mimetype = 'text/plain')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_object_description(request):\n    \"\"\"if object description does not exist,\n    creates a new record, otherwise edits an existing\n    one\"\"\"\n    obj = get_db_object_or_404(request.POST)\n    text = request.POST['text']\n    if obj.description:\n        request.user.edit_post(obj.description, body_text=text)\n    else:\n        request.user.post_object_description(obj, body_text=text)\n    return {'html': obj.description.html}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef rename_tag(request):\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n    post_data = simplejson.loads(request.raw_post_data)\n    to_name = forms.clean_tag(post_data['to_name'])\n    from_name = forms.clean_tag(post_data['from_name'])\n    path = post_data['path']\n\n    #kwargs = {'from': old_name, 'to': new_name}\n    #call_command('rename_tags', **kwargs)\n\n    tree = category_tree.get_data()\n    category_tree.rename_category(\n        tree,\n        from_name = from_name,\n        to_name = to_name,\n        path = path\n    )\n    category_tree.save_data(tree)\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef delete_tag(request):\n    \"\"\"todo: actually delete tags\n    now it is only deletion of category from the tree\"\"\"\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n\n    try:\n        post_data = simplejson.loads(request.raw_post_data)\n        tag_name = post_data['tag_name']\n        path = post_data['path']\n        tree = category_tree.get_data()\n        category_tree.delete_category(tree, tag_name, path)\n        category_tree.save_data(tree)\n    except Exception:\n        if 'tag_name' in locals():\n            logging.critical('could not delete tag %s' % tag_name)\n        else:\n            logging.critical('failed to parse post data %s' % request.raw_post_data)\n        raise exceptions.PermissionDenied(_('Sorry, could not delete tag'))\n    return {'tree_data': tree}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef add_tag_category(request):\n    \"\"\"adds a category at the tip of a given path expects\n    the following keys in the ``request.POST``\n    * path - array starting with zero giving path to\n      the category page where to add the category\n    * new_category_name - string that must satisfy the\n      same requiremets as a tag\n\n    return json with the category tree data\n    todo: switch to json stored in the live settings\n    now we have indented input\n    \"\"\"\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n\n    post_data = simplejson.loads(request.raw_post_data)\n    category_name = forms.clean_tag(post_data['new_category_name'])\n    path = post_data['path']\n\n    tree = category_tree.get_data()\n\n    if category_tree.path_is_valid(tree, path) == False:\n        raise ValueError('category insertion path is invalid')\n\n    new_path = category_tree.add_category(tree, category_name, path)\n    category_tree.save_data(tree)\n    return {\n        'tree_data': tree,\n        'new_path': new_path\n    }\n\n\n@decorators.get_only\ndef get_groups_list(request):\n    \"\"\"returns names of group tags\n    for the autocomplete function\"\"\"\n    global_group = models.Group.objects.get_global_group()\n    groups = models.Group.objects.exclude_personal()\n    group_names = groups.exclude(\n                        name=global_group.name\n                    ).values_list(\n                        'name', flat = True\n                    )\n    output = '\\n'.join(group_names)\n    return HttpResponse(output, mimetype = 'text/plain')\n\n@csrf.csrf_protect\ndef subscribe_for_tags(request):\n    \"\"\"process subscription of users by tags\"\"\"\n    #todo - use special separator to split tags\n    tag_names = request.REQUEST.get('tags','').strip().split()\n    pure_tag_names, wildcards = forms.clean_marked_tagnames(tag_names)\n    if request.user.is_authenticated():\n        if request.method == 'POST':\n            if 'ok' in request.POST:\n                request.user.mark_tags(\n                            pure_tag_names,\n                            wildcards,\n                            reason = 'good',\n                            action = 'add'\n                        )\n                request.user.message_set.create(\n                    message = _('Your tag subscription was saved, thanks!')\n                )\n            else:\n                message = _(\n                    'Tag subscription was canceled (<a href=\"%(url)s\">undo</a>).'\n                ) % {'url': escape(request.path) + '?tags=' + request.REQUEST['tags']}\n                request.user.message_set.create(message = message)\n            return HttpResponseRedirect(reverse('index'))\n        else:\n            data = {'tags': tag_names}\n            return render(request, 'subscribe_for_tags.html', data)\n    else:\n        all_tag_names = pure_tag_names + wildcards\n        message = _('Please sign in to subscribe for: %(tags)s') \\\n                    % {'tags': ', '.join(all_tag_names)}\n        request.user.message_set.create(message = message)\n        request.session['subscribe_for_tags'] = (pure_tag_names, wildcards)\n        return HttpResponseRedirect(url_utils.get_login_url())\n\n@decorators.admins_only\ndef list_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n    object_list = models.BulkTagSubscription.objects.all()\n    data = {'object_list': object_list}\n    return render(request, 'tags/list_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\ndef create_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    data = {'action': _('Create')}\n    if request.method == \"POST\":\n        form = forms.BulkTagSubscriptionForm(request.POST)\n        if form.is_valid():\n            tag_names = form.cleaned_data['tags'].split(' ')\n            user_list = form.cleaned_data.get('users')\n            group_list = form.cleaned_data.get('groups')\n\n            bulk_subscription = models.BulkTagSubscription.objects.create(\n                                                            tag_names=tag_names,\n                                                            tag_author=request.user,\n                                                            user_list=user_list,\n                                                            group_list=group_list\n                                                        )\n\n            return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n        else:\n            data['form'] = form\n    else:\n        data['form'] = forms.BulkTagSubscriptionForm()\n\n    return render(request, 'tags/form_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\ndef edit_bulk_tag_subscription(request, pk):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    bulk_subscription = get_object_or_404(models.BulkTagSubscription,\n                                          pk=pk)\n    data = {'action': _('Edit')}\n    if request.method == \"POST\":\n        form = forms.BulkTagSubscriptionForm(request.POST)\n        if form.is_valid():\n            bulk_subscription.tags.clear()\n            bulk_subscription.users.clear()\n            bulk_subscription.groups.clear()\n\n            if 'groups' in form.cleaned_data:\n                group_ids = [user.id for user in form.cleaned_data['groups']]\n                bulk_subscription.groups.add(*group_ids)\n\n            tags, new_tag_names = get_tags_by_names(form.cleaned_data['tags'].split(' '))\n            tag_id_list = [tag.id for tag in tags]\n\n            for new_tag_name in new_tag_names:\n                new_tag = models.Tag.objects.create(name=new_tag_name,\n                                             created_by=request.user)\n                tag_id_list.append(new_tag.id)\n\n            bulk_subscription.tags.add(*tag_id_list)\n\n            user_ids = []\n            for user in form.cleaned_data['users']:\n                user_ids.append(user)\n                user.mark_tags(bulk_subscription.tag_list(),\n                               reason='subscribed', action='add')\n\n            bulk_subscription.users.add(*user_ids)\n\n            return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n    else:\n        form_initial = {\n                        'users': bulk_subscription.users.all(),\n                        'groups': bulk_subscription.groups.all(),\n                        'tags': ' '.join([tag.name for tag in bulk_subscription.tags.all()]),\n                       }\n        data.update({\n                    'bulk_subscription': bulk_subscription,\n                    'form': forms.BulkTagSubscriptionForm(initial=form_initial),\n                   })\n\n    return render(request, 'tags/form_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\n@decorators.post_only\ndef delete_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    pk = request.POST.get('pk')\n    if pk:\n        bulk_subscription = get_object_or_404(models.BulkTagSubscription, pk=pk)\n        bulk_subscription.delete()\n        return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n    else:\n        return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n\n@decorators.get_only\ndef api_get_questions(request):\n    \"\"\"json api for retrieving questions by title match\"\"\"\n    query = request.GET.get('query_text', '').strip()\n    tag_name = request.GET.get('tag_name', None)\n\n    if askbot_settings.GROUPS_ENABLED:\n        threads = models.Thread.objects.get_visible(user=request.user)\n    else:\n        threads = models.Thread.objects.all()\n\n    if tag_name:\n        threads = threads.filter(tags__name=tag_name)\n\n    if query:\n        threads = threads.get_for_title_query(query)\n\n    #todo: filter out deleted threads, for now there is no way\n    threads = threads.distinct()[:30]\n\n    thread_list = list()\n    for thread in threads:#todo: this is a temp hack until thread model is fixed\n        try:\n            thread_list.append({\n                    'title': escape(thread.title),\n                    'url': thread.get_absolute_url(),\n                    'answer_count': thread.get_answer_count(request.user)\n                })\n        except:\n            continue\n\n    json_data = simplejson.dumps(thread_list)\n    return HttpResponse(json_data, mimetype = \"application/json\")\n\n\n@csrf.csrf_exempt\n@decorators.post_only\n@decorators.ajax_login_required\ndef set_tag_filter_strategy(request):\n    \"\"\"saves data in the ``User.[email/display]_tag_filter_strategy``\n    for the current user\n    \"\"\"\n    filter_type = request.POST['filter_type']\n    filter_value = int(request.POST['filter_value'])\n    assert(filter_type in ('display', 'email'))\n    if filter_type == 'display':\n        allowed_values_dict = dict(conf.get_tag_display_filter_strategy_choices())\n        assert(filter_value in allowed_values_dict)\n        request.user.display_tag_filter_strategy = filter_value\n    else:\n        allowed_values_dict = dict(conf.get_tag_email_filter_strategy_choices())\n        assert(filter_value in allowed_values_dict)\n        request.user.email_tag_filter_strategy = filter_value\n    request.user.save()\n    return HttpResponse('', mimetype = \"application/json\")\n\n\n@login_required\n@csrf.csrf_protect\ndef close(request, id):#close question\n    \"\"\"view to initiate and process\n    question close\n    \"\"\"\n    question = get_object_or_404(models.Post, post_type='question', id=id)\n    try:\n        if request.method == 'POST':\n            form = forms.CloseForm(request.POST)\n            if form.is_valid():\n                reason = form.cleaned_data['reason']\n\n                request.user.close_question(\n                                        question = question,\n                                        reason = reason\n                                    )\n            return HttpResponseRedirect(question.get_absolute_url())\n        else:\n            request.user.assert_can_close_question(question)\n            form = forms.CloseForm()\n            data = {\n                'question': question,\n                'form': form,\n            }\n            return render(request, 'close.html', data)\n    except exceptions.PermissionDenied, e:\n        request.user.message_set.create(message = unicode(e))\n        return HttpResponseRedirect(question.get_absolute_url())\n\n@login_required\n@csrf.csrf_protect\ndef reopen(request, id):#re-open question\n    \"\"\"view to initiate and process\n    question close\n\n    this is not an ajax view\n    \"\"\"\n\n    question = get_object_or_404(models.Post, post_type='question', id=id)\n    # open question\n    try:\n        if request.method == 'POST' :\n            request.user.reopen_question(question)\n            return HttpResponseRedirect(question.get_absolute_url())\n        else:\n            request.user.assert_can_reopen_question(question)\n            closed_by_profile_url = question.thread.closed_by.get_profile_url()\n            closed_by_username = question.thread.closed_by.username\n            data = {\n                'question' : question,\n                'closed_by_profile_url': closed_by_profile_url,\n                'closed_by_username': closed_by_username,\n            }\n            return render(request, 'reopen.html', data)\n\n    except exceptions.PermissionDenied, e:\n        request.user.message_set.create(message = unicode(e))\n        return HttpResponseRedirect(question.get_absolute_url())\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\ndef swap_question_with_answer(request):\n    \"\"\"receives two json parameters - answer id\n    and new question title\n    the view is made to be used only by the site administrator\n    or moderators\n    \"\"\"\n    if request.user.is_authenticated():\n        if request.user.is_administrator() or request.user.is_moderator():\n            answer = models.Post.objects.get_answers(\n                                                request.user\n                                            ).get(\n                                                id=request.POST['answer_id']\n                                            )\n            new_question = answer.swap_with_question(new_title = request.POST['new_title'])\n            return {'question_url': new_question.get_absolute_url() }\n    raise Http404\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef upvote_comment(request):\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied(_('Please sign in to vote'))\n    form = forms.VoteForm(request.POST)\n    if form.is_valid():\n        comment_id = form.cleaned_data['post_id']\n        cancel_vote = form.cleaned_data['cancel_vote']\n        comment = get_object_or_404(models.Post, post_type='comment', id=comment_id)\n        process_vote(\n            post = comment,\n            vote_direction = 'up',\n            user = request.user\n        )\n    else:\n        raise ValueError\n    #FIXME: rename js\n    return {'score': comment.points}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef delete_post(request):\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied(_('Please sign in to delete/restore posts'))\n    form = forms.VoteForm(request.POST)\n    if form.is_valid():\n        post_id = form.cleaned_data['post_id']\n        post = get_object_or_404(\n            models.Post,\n            post_type__in = ('question', 'answer'),\n            id = post_id\n        )\n        if form.cleaned_data['cancel_vote']:\n            request.user.restore_post(post)\n        else:\n            request.user.delete_post(post)\n    else:\n        raise ValueError\n    return {'is_deleted': post.deleted}\n\n#askbot-user communication system\n@csrf.csrf_exempt\ndef read_message(request):#marks message a read\n    if request.method == \"POST\":\n        if request.POST['formdata'] == 'required':\n            request.session['message_silent'] = 1\n            if request.user.is_authenticated():\n                request.user.delete_messages()\n    return HttpResponse('')\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef edit_group_membership(request):\n    #todo: this call may need to go.\n    #it used to be the one creating groups\n    #from the user profile page\n    #we have a separate method\n    form = forms.EditGroupMembershipForm(request.POST)\n    if form.is_valid():\n        group_name = form.cleaned_data['group_name']\n        user_id = form.cleaned_data['user_id']\n        try:\n            user = models.User.objects.get(id=user_id)\n        except models.User.DoesNotExist:\n            raise exceptions.PermissionDenied(\n                'user with id %d not found' % user_id\n            )\n\n        action = form.cleaned_data['action']\n        #warning: possible race condition\n        if action == 'add':\n            group_params = {'name': group_name, 'user': user}\n            group = models.Group.objects.get_or_create(**group_params)\n            request.user.edit_group_membership(user, group, 'add')\n            template = get_template('widgets/group_snippet.html')\n            return {\n                'name': group.name,\n                'description': getattr(group.tag_wiki, 'text', ''),\n                'html': template.render({'group': group})\n            }\n        elif action == 'remove':\n            try:\n                group = models.Group.objects.get(group_name = group_name)\n                request.user.edit_group_membership(user, group, 'remove')\n            except models.Group.DoesNotExist:\n                raise exceptions.PermissionDenied()\n        else:\n            raise exceptions.PermissionDenied()\n    else:\n        raise exceptions.PermissionDenied()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_group_logo_url(request):\n    \"\"\"saves urls for the group logo\"\"\"\n    form = forms.GroupLogoURLForm(request.POST)\n    if form.is_valid():\n        group_id = form.cleaned_data['group_id']\n        image_url = form.cleaned_data['image_url']\n        group = models.Group.objects.get(id = group_id)\n        group.logo_url = image_url\n        group.save()\n    else:\n        raise ValueError('invalid data found when saving group logo')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef add_group(request):\n    group_name = request.POST.get('group')\n    if group_name:\n        group = models.Group.objects.get_or_create(\n                            name=group_name,\n                            openness=models.Group.OPEN,\n                            user=request.user,\n                        )\n\n        url = reverse('users_by_group', kwargs={'group_id': group.id,\n                   'group_slug': slugify(group_name)})\n        response_dict = dict(group_name = group_name,\n                             url = url )\n        return response_dict\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef delete_group_logo(request):\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    group = models.Group.objects.get(id = group_id)\n    group.logo_url = None\n    group.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef delete_post_reject_reason(request):\n    reason_id = IntegerField().clean(int(request.POST['reason_id']))\n    reason = models.PostFlagReason.objects.get(id = reason_id)\n    reason.delete()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef toggle_group_profile_property(request):\n    #todo: this might be changed to more general \"toggle object property\"\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    property_name = CharField().clean(request.POST['property_name'])\n    assert property_name in (\n                        'moderate_email',\n                        'moderate_answers_to_enquirers',\n                        'is_vip'\n                    )\n    group = models.Group.objects.get(id = group_id)\n    new_value = not getattr(group, property_name)\n    setattr(group, property_name, new_value)\n    group.save()\n    return {'is_enabled': new_value}\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef set_group_openness(request):\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    value = IntegerField().clean(int(request.POST['value']))\n    group = models.Group.objects.get(id=group_id)\n    group.openness = value\n    group.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.admins_only\ndef edit_object_property_text(request):\n    model_name = CharField().clean(request.REQUEST['model_name'])\n    object_id = IntegerField().clean(request.REQUEST['object_id'])\n    property_name = CharField().clean(request.REQUEST['property_name'])\n\n    accessible_fields = (\n        ('Group', 'preapproved_emails'),\n        ('Group', 'preapproved_email_domains')\n    )\n\n    if (model_name, property_name) not in accessible_fields:\n        raise exceptions.PermissionDenied()\n\n    obj = models.get_model(model_name).objects.get(id=object_id)\n    if request.method == 'POST':\n        text = CharField().clean(request.POST['text'])\n        setattr(obj, property_name, text)\n        obj.save()\n    elif request.method == 'GET':\n        return {'text': getattr(obj, property_name)}\n    else:\n        raise exceptions.PermissionDenied()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef join_or_leave_group(request):\n    \"\"\"called when user wants to join/leave\n    ask to join/cancel join request, depending\n    on the groups acceptance level for the given user\n\n    returns resulting \"membership_level\"\n    \"\"\"\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied()\n\n    Group = models.Group\n    Membership = models.GroupMembership\n\n    group_id = IntegerField().clean(request.POST['group_id'])\n    group = Group.objects.get(id=group_id)\n\n    membership = request.user.get_group_membership(group)\n    if membership is None:\n        membership = request.user.join_group(group)\n        new_level = membership.get_level_display()\n    else:\n        membership.delete()\n        new_level = Membership.get_level_value_display(Membership.NONE)\n\n    return {'membership_level': new_level}\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_post_reject_reason(request):\n    \"\"\"saves post reject reason and returns the reason id\n    if reason_id is not given in the input - a new reason is created,\n    otherwise a reason with the given id is edited and saved\n    \"\"\"\n    form = forms.EditRejectReasonForm(request.POST)\n    if form.is_valid():\n        title = form.cleaned_data['title']\n        details = form.cleaned_data['details']\n        if form.cleaned_data['reason_id'] is None:\n            reason = request.user.create_post_reject_reason(\n                title = title, details = details\n            )\n        else:\n            reason_id = form.cleaned_data['reason_id']\n            reason = models.PostFlagReason.objects.get(id = reason_id)\n            request.user.edit_post_reject_reason(\n                reason, title = title, details = details\n            )\n        return {\n            'reason_id': reason.id,\n            'title': title,\n            'details': details\n        }\n    else:\n        raise Exception(forms.format_form_errors(form))\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef moderate_suggested_tag(request):\n    \"\"\"accepts or rejects a suggested tag\n    if thread id is given, then tag is\n    applied to or removed from only one thread,\n    otherwise the decision applies to all threads\n    \"\"\"\n    form = forms.ModerateTagForm(request.POST)\n    if form.is_valid():\n        tag_id = form.cleaned_data['tag_id']\n        thread_id = form.cleaned_data.get('thread_id', None)\n\n        try:\n            tag = models.Tag.objects.get(id=tag_id)#can tag not exist?\n        except models.Tag.DoesNotExist:\n            return\n\n        if thread_id:\n            threads = models.Thread.objects.filter(id=thread_id)\n        else:\n            threads = tag.threads.none()\n\n        if form.cleaned_data['action'] == 'accept':\n            #todo: here we lose ability to come back\n            #to the tag moderation and approve tag to\n            #other threads later for the case where tag.used_count > 1\n            tag.status = models.Tag.STATUS_ACCEPTED\n            tag.save()\n            for thread in threads:\n                thread.add_tag(\n                    tag_name = tag.name,\n                    user = tag.created_by,\n                    timestamp = datetime.datetime.now(),\n                    silent = True\n                )\n        else:\n            if tag.threads.count() > len(threads):\n                for thread in threads:\n                    thread.tags.remove(tag)\n                tag.used_count = tag.threads.count()\n                tag.save()\n            elif tag.status == models.Tag.STATUS_SUGGESTED:\n                tag.delete()\n    else:\n        raise Exception(forms.format_form_errors(form))\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef save_draft_question(request):\n    \"\"\"saves draft questions\"\"\"\n    #todo: allow drafts for anonymous users\n    if request.user.is_anonymous():\n        return\n\n    form = forms.DraftQuestionForm(request.POST)\n    if form.is_valid():\n        title = form.cleaned_data.get('title', '')\n        text = form.cleaned_data.get('text', '')\n        tagnames = form.cleaned_data.get('tagnames', '')\n        if title or text or tagnames:\n            try:\n                draft = models.DraftQuestion.objects.get(author=request.user)\n            except models.DraftQuestion.DoesNotExist:\n                draft = models.DraftQuestion()\n\n            draft.title = title\n            draft.text = text\n            draft.tagnames = tagnames\n            draft.author = request.user\n            draft.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef save_draft_answer(request):\n    \"\"\"saves draft answers\"\"\"\n    #todo: allow drafts for anonymous users\n    if request.user.is_anonymous():\n        return\n\n    form = forms.DraftAnswerForm(request.POST)\n    if form.is_valid():\n        thread_id = form.cleaned_data['thread_id']\n        try:\n            thread = models.Thread.objects.get(id=thread_id)\n        except models.Thread.DoesNotExist:\n            return\n        try:\n            draft = models.DraftAnswer.objects.get(\n                                            thread=thread,\n                                            author=request.user\n                                    )\n        except models.DraftAnswer.DoesNotExist:\n            draft = models.DraftAnswer()\n\n        draft.author = request.user\n        draft.thread = thread\n        draft.text = form.cleaned_data.get('text', '')\n        draft.save()\n\n@decorators.get_only\ndef get_users_info(request):\n    \"\"\"retuns list of user names and email addresses\n    of \"fake\" users - so that admins can post on their\n    behalf\"\"\"\n    if request.user.is_anonymous():\n        return HttpResponseForbidden()\n\n    query = request.GET['q']\n    limit = IntegerField().clean(request.GET['limit'])\n\n    users = models.User.objects\n    user_info_list = users.filter(username__istartswith=query)\n\n    if request.user.is_administrator_or_moderator():\n        user_info_list = user_info_list.values_list('username', 'email')\n    else:\n        user_info_list = user_info_list.values_list('username')\n\n    result_list = ['|'.join(info) for info in user_info_list[:limit]]\n    return HttpResponse('\\n'.join(result_list), mimetype = 'text/plain')\n\n@csrf.csrf_protect\ndef share_question_with_group(request):\n    form = forms.ShareQuestionForm(request.POST)\n    try:\n        if form.is_valid():\n\n            thread_id = form.cleaned_data['thread_id']\n            group_name = form.cleaned_data['recipient_name']\n\n            thread = models.Thread.objects.get(id=thread_id)\n            question_post = thread._question_post()\n\n            #get notif set before\n            sets1 = question_post.get_notify_sets(\n                                    mentioned_users=list(),\n                                    exclude_list=[request.user,]\n                                )\n\n            #share the post\n            if group_name == askbot_settings.GLOBAL_GROUP_NAME:\n                thread.make_public(recursive=True)\n            else:\n                group = models.Group.objects.get(name=group_name)\n                thread.add_to_groups((group,), recursive=True)\n\n            #get notif sets after\n            sets2 = question_post.get_notify_sets(\n                                    mentioned_users=list(),\n                                    exclude_list=[request.user,]\n                                )\n\n            notify_sets = {\n                'for_mentions': sets2['for_mentions'] - sets1['for_mentions'],\n                'for_email': sets2['for_email'] - sets1['for_email'],\n                'for_inbox': sets2['for_inbox'] - sets1['for_inbox']\n            }\n\n            question_post.issue_update_notifications(\n                updated_by=request.user,\n                notify_sets=notify_sets,\n                activity_type=const.TYPE_ACTIVITY_POST_SHARED,\n                timestamp=datetime.datetime.now()\n            )\n\n            return HttpResponseRedirect(thread.get_absolute_url())\n    except Exception:\n        error_message = _('Sorry, looks like sharing request was invalid')\n        request.user.message_set.create(message=error_message)\n        return HttpResponseRedirect(thread.get_absolute_url())\n\n@csrf.csrf_protect\ndef share_question_with_user(request):\n    form = forms.ShareQuestionForm(request.POST)\n    try:\n        if form.is_valid():\n\n            thread_id = form.cleaned_data['thread_id']\n            username = form.cleaned_data['recipient_name']\n\n            thread = models.Thread.objects.get(id=thread_id)\n            user = models.User.objects.get(username=username)\n            group = user.get_personal_group()\n            thread.add_to_groups([group], recursive=True)\n            #notify the person\n            #todo: see if user could already see the post - b/f the sharing\n            notify_sets = {\n                'for_inbox': set([user]),\n                'for_mentions': set([user]),\n                'for_email': set([user])\n            }\n            thread._question_post().issue_update_notifications(\n                updated_by=request.user,\n                notify_sets=notify_sets,\n                activity_type=const.TYPE_ACTIVITY_POST_SHARED,\n                timestamp=datetime.datetime.now()\n            )\n\n            return HttpResponseRedirect(thread.get_absolute_url())\n    except Exception:\n        error_message = _('Sorry, looks like sharing request was invalid')\n        request.user.message_set.create(message=error_message)\n        return HttpResponseRedirect(thread.get_absolute_url())\n\n@csrf.csrf_protect\ndef moderate_group_join_request(request):\n    \"\"\"moderator of the group can accept or reject a new user\"\"\"\n    request_id = IntegerField().clean(request.POST['request_id'])\n    action = request.POST['action']\n    assert(action in ('approve', 'deny'))\n\n    activity = get_object_or_404(models.Activity, pk=request_id)\n    group = activity.content_object\n    applicant = activity.user\n\n    if group.has_moderator(request.user):\n        group_membership = models.GroupMembership.objects.get(\n                                            user=applicant, group=group\n                                        )\n        if action == 'approve':\n            group_membership.level = models.GroupMembership.FULL\n            group_membership.save()\n            msg_data = {'user': applicant.username, 'group': group.name}\n            message = _('%(user)s, welcome to group %(group)s!') % msg_data\n            applicant.message_set.create(message=message)\n        else:\n            group_membership.delete()\n\n        activity.delete()\n        url = request.user.get_absolute_url() + '?sort=inbox&section=join_requests'\n        return HttpResponseRedirect(url)\n    else:\n        raise Http404\n\n@decorators.get_only\ndef get_editor(request):\n    \"\"\"returns bits of html for the tinymce editor in a dictionary with keys:\n    * html - the editor element\n    * scripts - an array of script tags\n    * success - True\n    \"\"\"\n    if 'config' not in request.GET:\n        return HttpResponseForbidden()\n    config = simplejson.loads(request.GET['config'])\n    element_id = request.GET.get('id', 'editor')\n    form = forms.EditorForm(\n                attrs={'id': element_id},\n                editor_attrs=config,\n                user=request.user\n            )\n    editor_html = render_text_into_skin(\n        '{{ form.media }} {{ form.editor }}',\n        {'form': form},\n        request\n    )\n    #parse out javascript and dom, and return them separately\n    #we need that, because js needs to be added in a special way\n    html_soup = BeautifulSoup(editor_html)\n\n    parsed_scripts = list()\n    for script in html_soup.find_all('script'):\n        parsed_scripts.append({\n            'contents': script.string,\n            'src': script.get('src', None)\n        })\n\n    data = {\n        'html': str(html_soup.textarea),\n        'scripts': parsed_scripts,\n        'success': True\n    }\n    return HttpResponse(simplejson.dumps(data), mimetype='application/json')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef publish_answer(request):\n    \"\"\"will publish or unpublish answer, if\n    current thread is moderated\n    \"\"\"\n    denied_msg = _('Sorry, only thread moderators can use this function')\n    if request.user.is_authenticated():\n        if request.user.is_administrator_or_moderator() is False:\n            raise exceptions.PermissionDenied(denied_msg)\n    #todo: assert permission\n    answer_id = IntegerField().clean(request.POST['answer_id'])\n    answer = models.Post.objects.get(id=answer_id, post_type='answer')\n\n    if answer.thread.has_moderator(request.user) is False:\n        raise exceptions.PermissionDenied(denied_msg)\n\n    enquirer = answer.thread._question_post().author\n    enquirer_group = enquirer.get_personal_group()\n\n    if answer.has_group(enquirer_group):\n        message = _('The answer is now unpublished')\n        answer.remove_from_groups([enquirer_group])\n    else:\n        answer.add_to_groups([enquirer_group])\n        message = _('The answer is now published')\n        #todo: notify enquirer by email about the post\n    request.user.message_set.create(message=message)\n    return {'redirect_url': answer.get_absolute_url()}\n", "code_before": "\"\"\"\n:synopsis: most ajax processors for askbot\n\nThis module contains most (but not all) processors for Ajax requests.\nNot so clear if this subdivision was necessary as separation of Ajax and non-ajax views\nis not always very clean.\n\"\"\"\nimport datetime\nimport logging\nfrom bs4 import BeautifulSoup\nfrom django.conf import settings as django_settings\nfrom django.core import exceptions\n#from django.core.management import call_command\nfrom django.core.urlresolvers import reverse\nfrom django.contrib.auth.decorators import login_required\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseBadRequest\nfrom django.http import HttpResponseRedirect\nfrom django.http import HttpResponseForbidden\nfrom django.forms import ValidationError, IntegerField, CharField\nfrom django.shortcuts import get_object_or_404\nfrom django.shortcuts import render\nfrom django.template.loader import get_template\nfrom django.views.decorators import csrf\nfrom django.utils import simplejson\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\nfrom django.utils.translation import string_concat\nfrom askbot.utils.slug import slugify\nfrom askbot import models\nfrom askbot import forms\nfrom askbot import conf\nfrom askbot import const\nfrom askbot import mail\nfrom askbot.conf import settings as askbot_settings\nfrom askbot.utils import category_tree\nfrom askbot.utils import decorators\nfrom askbot.utils import url_utils\nfrom askbot.utils.forms import get_db_object_or_404\nfrom django.template import RequestContext\nfrom askbot.skins.loaders import render_into_skin_as_string\nfrom askbot.skins.loaders import render_text_into_skin\nfrom askbot.models.tag import get_tags_by_names\n\n\n\n@csrf.csrf_exempt\ndef manage_inbox(request):\n    \"\"\"delete, mark as new or seen user's\n    response memo objects, excluding flags\n    request data is memo_list  - list of integer id's of the ActivityAuditStatus items\n    and action_type - string - one of delete|mark_new|mark_seen\n    \"\"\"\n\n    response_data = dict()\n    try:\n        if request.is_ajax():\n            if request.method == 'POST':\n                post_data = simplejson.loads(request.raw_post_data)\n                if request.user.is_authenticated():\n                    activity_types = const.RESPONSE_ACTIVITY_TYPES_FOR_DISPLAY\n                    activity_types += (\n                        const.TYPE_ACTIVITY_MENTION,\n                        const.TYPE_ACTIVITY_MARK_OFFENSIVE,\n                        const.TYPE_ACTIVITY_MODERATED_NEW_POST,\n                        const.TYPE_ACTIVITY_MODERATED_POST_EDIT\n                    )\n                    user = request.user\n                    memo_set = models.ActivityAuditStatus.objects.filter(\n                        id__in = post_data['memo_list'],\n                        activity__activity_type__in = activity_types,\n                        user = user\n                    )\n\n                    action_type = post_data['action_type']\n                    if action_type == 'delete':\n                        memo_set.delete()\n                    elif action_type == 'mark_new':\n                        memo_set.update(status = models.ActivityAuditStatus.STATUS_NEW)\n                    elif action_type == 'mark_seen':\n                        memo_set.update(status = models.ActivityAuditStatus.STATUS_SEEN)\n                    elif action_type == 'remove_flag':\n                        for memo in memo_set:\n                            activity_type = memo.activity.activity_type\n                            if activity_type == const.TYPE_ACTIVITY_MARK_OFFENSIVE:\n                                request.user.flag_post(\n                                    post = memo.activity.content_object,\n                                    cancel_all = True\n                                )\n                            elif activity_type in \\\n                                (\n                                    const.TYPE_ACTIVITY_MODERATED_NEW_POST,\n                                    const.TYPE_ACTIVITY_MODERATED_POST_EDIT\n                                ):\n                                post_revision = memo.activity.content_object\n                                request.user.approve_post_revision(post_revision)\n                                memo.delete()\n\n                    #elif action_type == 'close':\n                    #    for memo in memo_set:\n                    #        if memo.activity.content_object.post_type == \"question\":\n                    #            request.user.close_question(question = memo.activity.content_object, reason = 7)\n                    #            memo.delete()\n                    elif action_type == 'delete_post':\n                        for memo in memo_set:\n                            content_object = memo.activity.content_object\n                            if isinstance(content_object, models.PostRevision):\n                                post = content_object.post\n                            else:\n                                post = content_object\n                            request.user.delete_post(post)\n                            reject_reason = models.PostFlagReason.objects.get(\n                                                    id = post_data['reject_reason_id']\n                                                )\n                            template = get_template('email/rejected_post.html')\n                            data = {\n                                    'post': post.html,\n                                    'reject_reason': reject_reason.details.html\n                                   }\n                            body_text = template.render(RequestContext(request, data))\n                            mail.send_mail(\n                                subject_line = _('your post was not accepted'),\n                                body_text = unicode(body_text),\n                                recipient_list = [post.author.email,]\n                            )\n                            memo.delete()\n\n                    user.update_response_counts()\n\n                    response_data['success'] = True\n                    data = simplejson.dumps(response_data)\n                    return HttpResponse(data, mimetype=\"application/json\")\n                else:\n                    raise exceptions.PermissionDenied(\n                        _('Sorry, but anonymous users cannot access the inbox')\n                    )\n            else:\n                raise exceptions.PermissionDenied('must use POST request')\n        else:\n            #todo: show error page but no-one is likely to get here\n            return HttpResponseRedirect(reverse('index'))\n    except Exception, e:\n        message = unicode(e)\n        if message == '':\n            message = _('Oops, apologies - there was some error')\n        response_data['message'] = message\n        response_data['success'] = False\n        data = simplejson.dumps(response_data)\n        return HttpResponse(data, mimetype=\"application/json\")\n\n\ndef process_vote(user = None, vote_direction = None, post = None):\n    \"\"\"function (non-view) that actually processes user votes\n    - i.e. up- or down- votes\n\n    in the future this needs to be converted into a real view function\n    for that url and javascript will need to be adjusted\n\n    also in the future make keys in response data be more meaningful\n    right now they are kind of cryptic - \"status\", \"count\"\n    \"\"\"\n    if user.is_anonymous():\n        raise exceptions.PermissionDenied(_(\n            'Sorry, anonymous users cannot vote'\n        ))\n\n    user.assert_can_vote_for_post(post = post, direction = vote_direction)\n    vote = user.get_old_vote_for_post(post)\n    response_data = {}\n    if vote != None:\n        user.assert_can_revoke_old_vote(vote)\n        score_delta = vote.cancel()\n        response_data['count'] = post.points+ score_delta\n        response_data['status'] = 1 #this means \"cancel\"\n\n    else:\n        #this is a new vote\n        votes_left = user.get_unused_votes_today()\n        if votes_left <= 0:\n            raise exceptions.PermissionDenied(\n                            _('Sorry you ran out of votes for today')\n                        )\n\n        votes_left -= 1\n        if votes_left <= \\\n            askbot_settings.VOTES_LEFT_WARNING_THRESHOLD:\n            msg = _('You have %(votes_left)s votes left for today') \\\n                    % {'votes_left': votes_left }\n            response_data['message'] = msg\n\n        if vote_direction == 'up':\n            vote = user.upvote(post = post)\n        else:\n            vote = user.downvote(post = post)\n\n        response_data['count'] = post.points\n        response_data['status'] = 0 #this means \"not cancel\", normal operation\n\n    response_data['success'] = 1\n\n    return response_data\n\n\n@csrf.csrf_exempt\ndef vote(request):\n    \"\"\"\n    todo: this subroutine needs serious refactoring it's too long and is hard to understand\n\n    vote_type:\n        acceptAnswer : 0,\n        questionUpVote : 1,\n        questionDownVote : 2,\n        favorite : 4,\n        answerUpVote: 5,\n        answerDownVote:6,\n        offensiveQuestion : 7,\n        remove offensiveQuestion flag : 7.5,\n        remove all offensiveQuestion flag : 7.6,\n        offensiveAnswer:8,\n        remove offensiveAnswer flag : 8.5,\n        remove all offensiveAnswer flag : 8.6,\n        removeQuestion: 9,\n        removeAnswer:10\n        questionSubscribeUpdates:11\n        questionUnSubscribeUpdates:12\n\n    accept answer code:\n        response_data['allowed'] = -1, Accept his own answer   0, no allowed - Anonymous    1, Allowed - by default\n        response_data['success'] =  0, failed                                               1, Success - by default\n        response_data['status']  =  0, By default                       1, Answer has been accepted already(Cancel)\n\n    vote code:\n        allowed = -3, Don't have enough votes left\n                  -2, Don't have enough reputation score\n                  -1, Vote his own post\n                   0, no allowed - Anonymous\n                   1, Allowed - by default\n        status  =  0, By default\n                   1, Cancel\n                   2, Vote is too old to be canceled\n\n    offensive code:\n        allowed = -3, Don't have enough flags left\n                  -2, Don't have enough reputation score to do this\n                   0, not allowed\n                   1, allowed\n        status  =  0, by default\n                   1, can't do it again\n    \"\"\"\n    response_data = {\n        \"allowed\": 1,\n        \"success\": 1,\n        \"status\" : 0,\n        \"count\"  : 0,\n        \"message\" : ''\n    }\n\n    try:\n        if request.is_ajax() and request.method == 'POST':\n            vote_type = request.POST.get('type')\n        else:\n            raise Exception(_('Sorry, something is not right here...'))\n\n        id = request.POST.get('postId')\n\n        if vote_type == '0':\n            if askbot_settings.ACCEPTING_ANSWERS_ENABLED is False:\n                return\n            if request.user.is_authenticated():\n                answer_id = request.POST.get('postId')\n                answer = get_object_or_404(models.Post, post_type='answer', id = answer_id)\n                # make sure question author is current user\n                if answer.accepted():\n                    request.user.unaccept_best_answer(answer)\n                    response_data['status'] = 1 #cancelation\n                else:\n                    request.user.accept_best_answer(answer)\n\n                ####################################################################\n                answer.thread.update_summary_html() # regenerate question/thread summary html\n                ####################################################################\n\n            else:\n                raise exceptions.PermissionDenied(\n                        _('Sorry, but anonymous users cannot accept answers')\n                    )\n\n        elif vote_type in ('1', '2', '5', '6'):#Q&A up/down votes\n\n            ###############################\n            # all this can be avoided with\n            # better query parameters\n            vote_direction = 'up'\n            if vote_type in ('2','6'):\n                vote_direction = 'down'\n\n            if vote_type in ('5', '6'):\n                #todo: fix this weirdness - why postId here\n                #and not with question?\n                post_id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=post_id)\n            else:\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            #\n            ######################\n\n            response_data = process_vote(\n                                        user = request.user,\n                                        vote_direction = vote_direction,\n                                        post = post\n                                    )\n\n            ####################################################################\n            if vote_type in ('1', '2'): # up/down-vote question\n                post.thread.update_summary_html() # regenerate question/thread summary html\n            ####################################################################\n\n        elif vote_type in ['7', '8']:\n            #flag question or answer\n            if vote_type == '7':\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '8':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            request.user.flag_post(post)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['7.5', '8.5']:\n            #flag question or answer\n            if vote_type == '7.5':\n                post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '8.5':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            request.user.flag_post(post, cancel = True)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['7.6', '8.6']:\n            #flag question or answer\n            if vote_type == '7.6':\n                post = get_object_or_404(models.Post, id=id)\n            if vote_type == '8.6':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, id=id)\n\n            request.user.flag_post(post, cancel_all = True)\n\n            response_data['count'] = post.offensive_flag_count\n            response_data['success'] = 1\n\n        elif vote_type in ['9', '10']:\n            #delete question or answer\n            post = get_object_or_404(models.Post, post_type='question', id=id)\n            if vote_type == '10':\n                id = request.POST.get('postId')\n                post = get_object_or_404(models.Post, post_type='answer', id=id)\n\n            if post.deleted == True:\n                request.user.restore_post(post = post)\n            else:\n                request.user.delete_post(post = post)\n\n        elif request.is_ajax() and request.method == 'POST':\n\n            if not request.user.is_authenticated():\n                response_data['allowed'] = 0\n                response_data['success'] = 0\n\n            question = get_object_or_404(models.Post, post_type='question', id=id)\n            vote_type = request.POST.get('type')\n\n            #accept answer\n            if vote_type == '4':\n                fave = request.user.toggle_favorite_question(question)\n                response_data['count'] = models.FavoriteQuestion.objects.filter(thread = question.thread).count()\n                if fave == False:\n                    response_data['status'] = 1\n\n            elif vote_type == '11':#subscribe q updates\n                user = request.user\n                if user.is_authenticated():\n                    if user not in question.thread.followed_by.all():\n                        user.follow_question(question)\n                        if askbot_settings.EMAIL_VALIDATION == True \\\n                            and user.email_isvalid == False:\n\n                            response_data['message'] = \\\n                                    _(\n                                        'Your subscription is saved, but email address '\n                                        '%(email)s needs to be validated, please see '\n                                        '<a href=\"%(details_url)s\">more details here</a>'\n                                    ) % {'email':user.email,'details_url':reverse('faq') + '#validate'}\n\n                    subscribed = user.subscribe_for_followed_question_alerts()\n                    if subscribed:\n                        if 'message' in response_data:\n                            response_data['message'] += '<br/>'\n                        response_data['message'] += _('email update frequency has been set to daily')\n                    #response_data['status'] = 1\n                    #responst_data['allowed'] = 1\n                else:\n                    pass\n                    #response_data['status'] = 0\n                    #response_data['allowed'] = 0\n            elif vote_type == '12':#unsubscribe q updates\n                user = request.user\n                if user.is_authenticated():\n                    user.unfollow_question(question)\n        else:\n            response_data['success'] = 0\n            response_data['message'] = u'Request mode is not supported. Please try again.'\n\n        if vote_type not in (1, 2, 4, 5, 6, 11, 12):\n            #favorite or subscribe/unsubscribe\n            #upvote or downvote question or answer - those\n            #are handled within user.upvote and user.downvote\n            post = models.Post.objects.get(id = id)\n            post.thread.invalidate_cached_data()\n\n        data = simplejson.dumps(response_data)\n\n    except Exception, e:\n        response_data['message'] = unicode(e)\n        response_data['success'] = 0\n        data = simplejson.dumps(response_data)\n    return HttpResponse(data, mimetype=\"application/json\")\n\n#internally grouped views - used by the tagging system\n@csrf.csrf_exempt\n@decorators.post_only\n@decorators.ajax_login_required\ndef mark_tag(request, **kwargs):#tagging system\n    action = kwargs['action']\n    post_data = simplejson.loads(request.raw_post_data)\n    raw_tagnames = post_data['tagnames']\n    reason = post_data['reason']\n    assert reason in ('good', 'bad', 'subscribed')\n    #separate plain tag names and wildcard tags\n    tagnames, wildcards = forms.clean_marked_tagnames(raw_tagnames)\n\n    if request.user.is_administrator() and 'user' in post_data:\n        user = get_object_or_404(models.User, pk=post_data['user'])\n    else:\n        user = request.user\n\n    cleaned_tagnames, cleaned_wildcards = user.mark_tags(\n                                                         tagnames,\n                                                         wildcards,\n                                                         reason = reason,\n                                                         action = action\n                                                        )\n\n    #lastly - calculate tag usage counts\n    tag_usage_counts = dict()\n    for name in tagnames:\n        if name in cleaned_tagnames:\n            tag_usage_counts[name] = 1\n        else:\n            tag_usage_counts[name] = 0\n\n    for name in wildcards:\n        if name in cleaned_wildcards:\n            tag_usage_counts[name] = models.Tag.objects.filter(\n                                        name__startswith = name[:-1]\n                                    ).count()\n        else:\n            tag_usage_counts[name] = 0\n\n    return HttpResponse(simplejson.dumps(tag_usage_counts), mimetype=\"application/json\")\n\n#@decorators.ajax_only\n@decorators.get_only\ndef get_tags_by_wildcard(request):\n    \"\"\"returns an json encoded array of tag names\n    in the response to a wildcard tag name\n    \"\"\"\n    wildcard = request.GET.get('wildcard', None)\n    if wildcard is None:\n        return HttpResponseForbidden()\n\n    matching_tags = models.Tag.objects.get_by_wildcards( [wildcard,] )\n    count = matching_tags.count()\n    names = matching_tags.values_list('name', flat = True)[:20]\n    re_data = simplejson.dumps({'tag_count': count, 'tag_names': list(names)})\n    return HttpResponse(re_data, mimetype = 'application/json')\n\n@decorators.get_only\ndef get_thread_shared_users(request):\n    \"\"\"returns snippet of html with users\"\"\"\n    thread_id = request.GET['thread_id']\n    thread_id = IntegerField().clean(thread_id)\n    thread = models.Thread.objects.get(id=thread_id)\n    users = thread.get_users_shared_with()\n    data = {\n        'users': users,\n    }\n    html = render_into_skin_as_string('widgets/user_list.html', data, request)\n    re_data = simplejson.dumps({\n        'html': html,\n        'users_count': users.count(),\n        'success': True\n    })\n    return HttpResponse(re_data, mimetype='application/json')\n\n@decorators.get_only\ndef get_thread_shared_groups(request):\n    \"\"\"returns snippet of html with groups\"\"\"\n    thread_id = request.GET['thread_id']\n    thread_id = IntegerField().clean(thread_id)\n    thread = models.Thread.objects.get(id=thread_id)\n    groups = thread.get_groups_shared_with()\n    data = {'groups': groups}\n    html = render_into_skin_as_string('widgets/groups_list.html', data, request)\n    re_data = simplejson.dumps({\n        'html': html,\n        'groups_count': groups.count(),\n        'success': True\n    })\n    return HttpResponse(re_data, mimetype='application/json')\n\n@decorators.ajax_only\ndef get_html_template(request):\n    \"\"\"returns rendered template\"\"\"\n    template_name = request.REQUEST.get('template_name', None)\n    allowed_templates = (\n        'widgets/tag_category_selector.html',\n    )\n    #have allow simple context for the templates\n    if template_name not in allowed_templates:\n        raise Http404\n    return {\n        'html': get_template(template_name).render()\n    }\n\n@decorators.get_only\ndef get_tag_list(request):\n    \"\"\"returns tags to use in the autocomplete\n    function\n    \"\"\"\n    tags = models.Tag.objects.filter(\n                        deleted = False,\n                        status = models.Tag.STATUS_ACCEPTED\n                    )\n\n    tag_names = tags.values_list(\n                        'name', flat = True\n                    )\n\n    output = '\\n'.join(map(escape, tag_names))\n    return HttpResponse(output, mimetype = 'text/plain')\n\n@decorators.get_only\ndef load_object_description(request):\n    \"\"\"returns text of the object description in text\"\"\"\n    obj = get_db_object_or_404(request.GET)#askbot forms utility\n    text = getattr(obj.description, 'text', '').strip()\n    return HttpResponse(text, mimetype = 'text/plain')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_object_description(request):\n    \"\"\"if object description does not exist,\n    creates a new record, otherwise edits an existing\n    one\"\"\"\n    obj = get_db_object_or_404(request.POST)\n    text = request.POST['text']\n    if obj.description:\n        request.user.edit_post(obj.description, body_text=text)\n    else:\n        request.user.post_object_description(obj, body_text=text)\n    return {'html': obj.description.html}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef rename_tag(request):\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n    post_data = simplejson.loads(request.raw_post_data)\n    to_name = forms.clean_tag(post_data['to_name'])\n    from_name = forms.clean_tag(post_data['from_name'])\n    path = post_data['path']\n\n    #kwargs = {'from': old_name, 'to': new_name}\n    #call_command('rename_tags', **kwargs)\n\n    tree = category_tree.get_data()\n    category_tree.rename_category(\n        tree,\n        from_name = from_name,\n        to_name = to_name,\n        path = path\n    )\n    category_tree.save_data(tree)\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef delete_tag(request):\n    \"\"\"todo: actually delete tags\n    now it is only deletion of category from the tree\"\"\"\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n\n    try:\n        post_data = simplejson.loads(request.raw_post_data)\n        tag_name = post_data['tag_name']\n        path = post_data['path']\n        tree = category_tree.get_data()\n        category_tree.delete_category(tree, tag_name, path)\n        category_tree.save_data(tree)\n    except Exception:\n        if 'tag_name' in locals():\n            logging.critical('could not delete tag %s' % tag_name)\n        else:\n            logging.critical('failed to parse post data %s' % request.raw_post_data)\n        raise exceptions.PermissionDenied(_('Sorry, could not delete tag'))\n    return {'tree_data': tree}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef add_tag_category(request):\n    \"\"\"adds a category at the tip of a given path expects\n    the following keys in the ``request.POST``\n    * path - array starting with zero giving path to\n      the category page where to add the category\n    * new_category_name - string that must satisfy the\n      same requiremets as a tag\n\n    return json with the category tree data\n    todo: switch to json stored in the live settings\n    now we have indented input\n    \"\"\"\n    if request.user.is_anonymous() \\\n        or not request.user.is_administrator_or_moderator():\n        raise exceptions.PermissionDenied()\n\n    post_data = simplejson.loads(request.raw_post_data)\n    category_name = forms.clean_tag(post_data['new_category_name'])\n    path = post_data['path']\n\n    tree = category_tree.get_data()\n\n    if category_tree.path_is_valid(tree, path) == False:\n        raise ValueError('category insertion path is invalid')\n\n    new_path = category_tree.add_category(tree, category_name, path)\n    category_tree.save_data(tree)\n    return {\n        'tree_data': tree,\n        'new_path': new_path\n    }\n\n\n@decorators.get_only\ndef get_groups_list(request):\n    \"\"\"returns names of group tags\n    for the autocomplete function\"\"\"\n    global_group = models.Group.objects.get_global_group()\n    groups = models.Group.objects.exclude_personal()\n    group_names = groups.exclude(\n                        name=global_group.name\n                    ).values_list(\n                        'name', flat = True\n                    )\n    output = '\\n'.join(group_names)\n    return HttpResponse(output, mimetype = 'text/plain')\n\n@csrf.csrf_protect\ndef subscribe_for_tags(request):\n    \"\"\"process subscription of users by tags\"\"\"\n    #todo - use special separator to split tags\n    tag_names = request.REQUEST.get('tags','').strip().split()\n    pure_tag_names, wildcards = forms.clean_marked_tagnames(tag_names)\n    if request.user.is_authenticated():\n        if request.method == 'POST':\n            if 'ok' in request.POST:\n                request.user.mark_tags(\n                            pure_tag_names,\n                            wildcards,\n                            reason = 'good',\n                            action = 'add'\n                        )\n                request.user.message_set.create(\n                    message = _('Your tag subscription was saved, thanks!')\n                )\n            else:\n                message = _(\n                    'Tag subscription was canceled (<a href=\"%(url)s\">undo</a>).'\n                ) % {'url': request.path + '?tags=' + request.REQUEST['tags']}\n                request.user.message_set.create(message = message)\n            return HttpResponseRedirect(reverse('index'))\n        else:\n            data = {'tags': tag_names}\n            return render(request, 'subscribe_for_tags.html', data)\n    else:\n        all_tag_names = pure_tag_names + wildcards\n        message = _('Please sign in to subscribe for: %(tags)s') \\\n                    % {'tags': ', '.join(all_tag_names)}\n        request.user.message_set.create(message = message)\n        request.session['subscribe_for_tags'] = (pure_tag_names, wildcards)\n        return HttpResponseRedirect(url_utils.get_login_url())\n\n@decorators.admins_only\ndef list_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n    object_list = models.BulkTagSubscription.objects.all()\n    data = {'object_list': object_list}\n    return render(request, 'tags/list_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\ndef create_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    data = {'action': _('Create')}\n    if request.method == \"POST\":\n        form = forms.BulkTagSubscriptionForm(request.POST)\n        if form.is_valid():\n            tag_names = form.cleaned_data['tags'].split(' ')\n            user_list = form.cleaned_data.get('users')\n            group_list = form.cleaned_data.get('groups')\n\n            bulk_subscription = models.BulkTagSubscription.objects.create(\n                                                            tag_names=tag_names,\n                                                            tag_author=request.user,\n                                                            user_list=user_list,\n                                                            group_list=group_list\n                                                        )\n\n            return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n        else:\n            data['form'] = form\n    else:\n        data['form'] = forms.BulkTagSubscriptionForm()\n\n    return render(request, 'tags/form_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\ndef edit_bulk_tag_subscription(request, pk):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    bulk_subscription = get_object_or_404(models.BulkTagSubscription,\n                                          pk=pk)\n    data = {'action': _('Edit')}\n    if request.method == \"POST\":\n        form = forms.BulkTagSubscriptionForm(request.POST)\n        if form.is_valid():\n            bulk_subscription.tags.clear()\n            bulk_subscription.users.clear()\n            bulk_subscription.groups.clear()\n\n            if 'groups' in form.cleaned_data:\n                group_ids = [user.id for user in form.cleaned_data['groups']]\n                bulk_subscription.groups.add(*group_ids)\n\n            tags, new_tag_names = get_tags_by_names(form.cleaned_data['tags'].split(' '))\n            tag_id_list = [tag.id for tag in tags]\n\n            for new_tag_name in new_tag_names:\n                new_tag = models.Tag.objects.create(name=new_tag_name,\n                                             created_by=request.user)\n                tag_id_list.append(new_tag.id)\n\n            bulk_subscription.tags.add(*tag_id_list)\n\n            user_ids = []\n            for user in form.cleaned_data['users']:\n                user_ids.append(user)\n                user.mark_tags(bulk_subscription.tag_list(),\n                               reason='subscribed', action='add')\n\n            bulk_subscription.users.add(*user_ids)\n\n            return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n    else:\n        form_initial = {\n                        'users': bulk_subscription.users.all(),\n                        'groups': bulk_subscription.groups.all(),\n                        'tags': ' '.join([tag.name for tag in bulk_subscription.tags.all()]),\n                       }\n        data.update({\n                    'bulk_subscription': bulk_subscription,\n                    'form': forms.BulkTagSubscriptionForm(initial=form_initial),\n                   })\n\n    return render(request, 'tags/form_bulk_tag_subscription.html', data)\n\n@decorators.admins_only\n@decorators.post_only\ndef delete_bulk_tag_subscription(request):\n    if askbot_settings.SUBSCRIBED_TAG_SELECTOR_ENABLED is False:\n        raise Http404\n\n    pk = request.POST.get('pk')\n    if pk:\n        bulk_subscription = get_object_or_404(models.BulkTagSubscription, pk=pk)\n        bulk_subscription.delete()\n        return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n    else:\n        return HttpResponseRedirect(reverse('list_bulk_tag_subscription'))\n\n@decorators.get_only\ndef api_get_questions(request):\n    \"\"\"json api for retrieving questions by title match\"\"\"\n    query = request.GET.get('query_text', '').strip()\n    tag_name = request.GET.get('tag_name', None)\n\n    if askbot_settings.GROUPS_ENABLED:\n        threads = models.Thread.objects.get_visible(user=request.user)\n    else:\n        threads = models.Thread.objects.all()\n\n    if tag_name:\n        threads = threads.filter(tags__name=tag_name)\n\n    if query:\n        threads = threads.get_for_title_query(query)\n\n    #todo: filter out deleted threads, for now there is no way\n    threads = threads.distinct()[:30]\n\n    thread_list = list()\n    for thread in threads:#todo: this is a temp hack until thread model is fixed\n        try:\n            thread_list.append({\n                    'title': escape(thread.title),\n                    'url': thread.get_absolute_url(),\n                    'answer_count': thread.get_answer_count(request.user)\n                })\n        except:\n            continue\n\n    json_data = simplejson.dumps(thread_list)\n    return HttpResponse(json_data, mimetype = \"application/json\")\n\n\n@csrf.csrf_exempt\n@decorators.post_only\n@decorators.ajax_login_required\ndef set_tag_filter_strategy(request):\n    \"\"\"saves data in the ``User.[email/display]_tag_filter_strategy``\n    for the current user\n    \"\"\"\n    filter_type = request.POST['filter_type']\n    filter_value = int(request.POST['filter_value'])\n    assert(filter_type in ('display', 'email'))\n    if filter_type == 'display':\n        allowed_values_dict = dict(conf.get_tag_display_filter_strategy_choices())\n        assert(filter_value in allowed_values_dict)\n        request.user.display_tag_filter_strategy = filter_value\n    else:\n        allowed_values_dict = dict(conf.get_tag_email_filter_strategy_choices())\n        assert(filter_value in allowed_values_dict)\n        request.user.email_tag_filter_strategy = filter_value\n    request.user.save()\n    return HttpResponse('', mimetype = \"application/json\")\n\n\n@login_required\n@csrf.csrf_protect\ndef close(request, id):#close question\n    \"\"\"view to initiate and process\n    question close\n    \"\"\"\n    question = get_object_or_404(models.Post, post_type='question', id=id)\n    try:\n        if request.method == 'POST':\n            form = forms.CloseForm(request.POST)\n            if form.is_valid():\n                reason = form.cleaned_data['reason']\n\n                request.user.close_question(\n                                        question = question,\n                                        reason = reason\n                                    )\n            return HttpResponseRedirect(question.get_absolute_url())\n        else:\n            request.user.assert_can_close_question(question)\n            form = forms.CloseForm()\n            data = {\n                'question': question,\n                'form': form,\n            }\n            return render(request, 'close.html', data)\n    except exceptions.PermissionDenied, e:\n        request.user.message_set.create(message = unicode(e))\n        return HttpResponseRedirect(question.get_absolute_url())\n\n@login_required\n@csrf.csrf_protect\ndef reopen(request, id):#re-open question\n    \"\"\"view to initiate and process\n    question close\n\n    this is not an ajax view\n    \"\"\"\n\n    question = get_object_or_404(models.Post, post_type='question', id=id)\n    # open question\n    try:\n        if request.method == 'POST' :\n            request.user.reopen_question(question)\n            return HttpResponseRedirect(question.get_absolute_url())\n        else:\n            request.user.assert_can_reopen_question(question)\n            closed_by_profile_url = question.thread.closed_by.get_profile_url()\n            closed_by_username = question.thread.closed_by.username\n            data = {\n                'question' : question,\n                'closed_by_profile_url': closed_by_profile_url,\n                'closed_by_username': closed_by_username,\n            }\n            return render(request, 'reopen.html', data)\n\n    except exceptions.PermissionDenied, e:\n        request.user.message_set.create(message = unicode(e))\n        return HttpResponseRedirect(question.get_absolute_url())\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\ndef swap_question_with_answer(request):\n    \"\"\"receives two json parameters - answer id\n    and new question title\n    the view is made to be used only by the site administrator\n    or moderators\n    \"\"\"\n    if request.user.is_authenticated():\n        if request.user.is_administrator() or request.user.is_moderator():\n            answer = models.Post.objects.get_answers(\n                                                request.user\n                                            ).get(\n                                                id=request.POST['answer_id']\n                                            )\n            new_question = answer.swap_with_question(new_title = request.POST['new_title'])\n            return {'question_url': new_question.get_absolute_url() }\n    raise Http404\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef upvote_comment(request):\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied(_('Please sign in to vote'))\n    form = forms.VoteForm(request.POST)\n    if form.is_valid():\n        comment_id = form.cleaned_data['post_id']\n        cancel_vote = form.cleaned_data['cancel_vote']\n        comment = get_object_or_404(models.Post, post_type='comment', id=comment_id)\n        process_vote(\n            post = comment,\n            vote_direction = 'up',\n            user = request.user\n        )\n    else:\n        raise ValueError\n    #FIXME: rename js\n    return {'score': comment.points}\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef delete_post(request):\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied(_('Please sign in to delete/restore posts'))\n    form = forms.VoteForm(request.POST)\n    if form.is_valid():\n        post_id = form.cleaned_data['post_id']\n        post = get_object_or_404(\n            models.Post,\n            post_type__in = ('question', 'answer'),\n            id = post_id\n        )\n        if form.cleaned_data['cancel_vote']:\n            request.user.restore_post(post)\n        else:\n            request.user.delete_post(post)\n    else:\n        raise ValueError\n    return {'is_deleted': post.deleted}\n\n#askbot-user communication system\n@csrf.csrf_exempt\ndef read_message(request):#marks message a read\n    if request.method == \"POST\":\n        if request.POST['formdata'] == 'required':\n            request.session['message_silent'] = 1\n            if request.user.is_authenticated():\n                request.user.delete_messages()\n    return HttpResponse('')\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef edit_group_membership(request):\n    #todo: this call may need to go.\n    #it used to be the one creating groups\n    #from the user profile page\n    #we have a separate method\n    form = forms.EditGroupMembershipForm(request.POST)\n    if form.is_valid():\n        group_name = form.cleaned_data['group_name']\n        user_id = form.cleaned_data['user_id']\n        try:\n            user = models.User.objects.get(id=user_id)\n        except models.User.DoesNotExist:\n            raise exceptions.PermissionDenied(\n                'user with id %d not found' % user_id\n            )\n\n        action = form.cleaned_data['action']\n        #warning: possible race condition\n        if action == 'add':\n            group_params = {'name': group_name, 'user': user}\n            group = models.Group.objects.get_or_create(**group_params)\n            request.user.edit_group_membership(user, group, 'add')\n            template = get_template('widgets/group_snippet.html')\n            return {\n                'name': group.name,\n                'description': getattr(group.tag_wiki, 'text', ''),\n                'html': template.render({'group': group})\n            }\n        elif action == 'remove':\n            try:\n                group = models.Group.objects.get(group_name = group_name)\n                request.user.edit_group_membership(user, group, 'remove')\n            except models.Group.DoesNotExist:\n                raise exceptions.PermissionDenied()\n        else:\n            raise exceptions.PermissionDenied()\n    else:\n        raise exceptions.PermissionDenied()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_group_logo_url(request):\n    \"\"\"saves urls for the group logo\"\"\"\n    form = forms.GroupLogoURLForm(request.POST)\n    if form.is_valid():\n        group_id = form.cleaned_data['group_id']\n        image_url = form.cleaned_data['image_url']\n        group = models.Group.objects.get(id = group_id)\n        group.logo_url = image_url\n        group.save()\n    else:\n        raise ValueError('invalid data found when saving group logo')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef add_group(request):\n    group_name = request.POST.get('group')\n    if group_name:\n        group = models.Group.objects.get_or_create(\n                            name=group_name,\n                            openness=models.Group.OPEN,\n                            user=request.user,\n                        )\n\n        url = reverse('users_by_group', kwargs={'group_id': group.id,\n                   'group_slug': slugify(group_name)})\n        response_dict = dict(group_name = group_name,\n                             url = url )\n        return response_dict\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef delete_group_logo(request):\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    group = models.Group.objects.get(id = group_id)\n    group.logo_url = None\n    group.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef delete_post_reject_reason(request):\n    reason_id = IntegerField().clean(int(request.POST['reason_id']))\n    reason = models.PostFlagReason.objects.get(id = reason_id)\n    reason.delete()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef toggle_group_profile_property(request):\n    #todo: this might be changed to more general \"toggle object property\"\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    property_name = CharField().clean(request.POST['property_name'])\n    assert property_name in (\n                        'moderate_email',\n                        'moderate_answers_to_enquirers',\n                        'is_vip'\n                    )\n    group = models.Group.objects.get(id = group_id)\n    new_value = not getattr(group, property_name)\n    setattr(group, property_name, new_value)\n    group.save()\n    return {'is_enabled': new_value}\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef set_group_openness(request):\n    group_id = IntegerField().clean(int(request.POST['group_id']))\n    value = IntegerField().clean(int(request.POST['value']))\n    group = models.Group.objects.get(id=group_id)\n    group.openness = value\n    group.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.admins_only\ndef edit_object_property_text(request):\n    model_name = CharField().clean(request.REQUEST['model_name'])\n    object_id = IntegerField().clean(request.REQUEST['object_id'])\n    property_name = CharField().clean(request.REQUEST['property_name'])\n\n    accessible_fields = (\n        ('Group', 'preapproved_emails'),\n        ('Group', 'preapproved_email_domains')\n    )\n\n    if (model_name, property_name) not in accessible_fields:\n        raise exceptions.PermissionDenied()\n\n    obj = models.get_model(model_name).objects.get(id=object_id)\n    if request.method == 'POST':\n        text = CharField().clean(request.POST['text'])\n        setattr(obj, property_name, text)\n        obj.save()\n    elif request.method == 'GET':\n        return {'text': getattr(obj, property_name)}\n    else:\n        raise exceptions.PermissionDenied()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef join_or_leave_group(request):\n    \"\"\"called when user wants to join/leave\n    ask to join/cancel join request, depending\n    on the groups acceptance level for the given user\n\n    returns resulting \"membership_level\"\n    \"\"\"\n    if request.user.is_anonymous():\n        raise exceptions.PermissionDenied()\n\n    Group = models.Group\n    Membership = models.GroupMembership\n\n    group_id = IntegerField().clean(request.POST['group_id'])\n    group = Group.objects.get(id=group_id)\n\n    membership = request.user.get_group_membership(group)\n    if membership is None:\n        membership = request.user.join_group(group)\n        new_level = membership.get_level_display()\n    else:\n        membership.delete()\n        new_level = Membership.get_level_value_display(Membership.NONE)\n\n    return {'membership_level': new_level}\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef save_post_reject_reason(request):\n    \"\"\"saves post reject reason and returns the reason id\n    if reason_id is not given in the input - a new reason is created,\n    otherwise a reason with the given id is edited and saved\n    \"\"\"\n    form = forms.EditRejectReasonForm(request.POST)\n    if form.is_valid():\n        title = form.cleaned_data['title']\n        details = form.cleaned_data['details']\n        if form.cleaned_data['reason_id'] is None:\n            reason = request.user.create_post_reject_reason(\n                title = title, details = details\n            )\n        else:\n            reason_id = form.cleaned_data['reason_id']\n            reason = models.PostFlagReason.objects.get(id = reason_id)\n            request.user.edit_post_reject_reason(\n                reason, title = title, details = details\n            )\n        return {\n            'reason_id': reason.id,\n            'title': title,\n            'details': details\n        }\n    else:\n        raise Exception(forms.format_form_errors(form))\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\n@decorators.admins_only\ndef moderate_suggested_tag(request):\n    \"\"\"accepts or rejects a suggested tag\n    if thread id is given, then tag is\n    applied to or removed from only one thread,\n    otherwise the decision applies to all threads\n    \"\"\"\n    form = forms.ModerateTagForm(request.POST)\n    if form.is_valid():\n        tag_id = form.cleaned_data['tag_id']\n        thread_id = form.cleaned_data.get('thread_id', None)\n\n        try:\n            tag = models.Tag.objects.get(id=tag_id)#can tag not exist?\n        except models.Tag.DoesNotExist:\n            return\n\n        if thread_id:\n            threads = models.Thread.objects.filter(id=thread_id)\n        else:\n            threads = tag.threads.none()\n\n        if form.cleaned_data['action'] == 'accept':\n            #todo: here we lose ability to come back\n            #to the tag moderation and approve tag to\n            #other threads later for the case where tag.used_count > 1\n            tag.status = models.Tag.STATUS_ACCEPTED\n            tag.save()\n            for thread in threads:\n                thread.add_tag(\n                    tag_name = tag.name,\n                    user = tag.created_by,\n                    timestamp = datetime.datetime.now(),\n                    silent = True\n                )\n        else:\n            if tag.threads.count() > len(threads):\n                for thread in threads:\n                    thread.tags.remove(tag)\n                tag.used_count = tag.threads.count()\n                tag.save()\n            elif tag.status == models.Tag.STATUS_SUGGESTED:\n                tag.delete()\n    else:\n        raise Exception(forms.format_form_errors(form))\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef save_draft_question(request):\n    \"\"\"saves draft questions\"\"\"\n    #todo: allow drafts for anonymous users\n    if request.user.is_anonymous():\n        return\n\n    form = forms.DraftQuestionForm(request.POST)\n    if form.is_valid():\n        title = form.cleaned_data.get('title', '')\n        text = form.cleaned_data.get('text', '')\n        tagnames = form.cleaned_data.get('tagnames', '')\n        if title or text or tagnames:\n            try:\n                draft = models.DraftQuestion.objects.get(author=request.user)\n            except models.DraftQuestion.DoesNotExist:\n                draft = models.DraftQuestion()\n\n            draft.title = title\n            draft.text = text\n            draft.tagnames = tagnames\n            draft.author = request.user\n            draft.save()\n\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef save_draft_answer(request):\n    \"\"\"saves draft answers\"\"\"\n    #todo: allow drafts for anonymous users\n    if request.user.is_anonymous():\n        return\n\n    form = forms.DraftAnswerForm(request.POST)\n    if form.is_valid():\n        thread_id = form.cleaned_data['thread_id']\n        try:\n            thread = models.Thread.objects.get(id=thread_id)\n        except models.Thread.DoesNotExist:\n            return\n        try:\n            draft = models.DraftAnswer.objects.get(\n                                            thread=thread,\n                                            author=request.user\n                                    )\n        except models.DraftAnswer.DoesNotExist:\n            draft = models.DraftAnswer()\n\n        draft.author = request.user\n        draft.thread = thread\n        draft.text = form.cleaned_data.get('text', '')\n        draft.save()\n\n@decorators.get_only\ndef get_users_info(request):\n    \"\"\"retuns list of user names and email addresses\n    of \"fake\" users - so that admins can post on their\n    behalf\"\"\"\n    if request.user.is_anonymous():\n        return HttpResponseForbidden()\n\n    query = request.GET['q']\n    limit = IntegerField().clean(request.GET['limit'])\n\n    users = models.User.objects\n    user_info_list = users.filter(username__istartswith=query)\n\n    if request.user.is_administrator_or_moderator():\n        user_info_list = user_info_list.values_list('username', 'email')\n    else:\n        user_info_list = user_info_list.values_list('username')\n\n    result_list = ['|'.join(info) for info in user_info_list[:limit]]\n    return HttpResponse('\\n'.join(result_list), mimetype = 'text/plain')\n\n@csrf.csrf_protect\ndef share_question_with_group(request):\n    form = forms.ShareQuestionForm(request.POST)\n    try:\n        if form.is_valid():\n\n            thread_id = form.cleaned_data['thread_id']\n            group_name = form.cleaned_data['recipient_name']\n\n            thread = models.Thread.objects.get(id=thread_id)\n            question_post = thread._question_post()\n\n            #get notif set before\n            sets1 = question_post.get_notify_sets(\n                                    mentioned_users=list(),\n                                    exclude_list=[request.user,]\n                                )\n\n            #share the post\n            if group_name == askbot_settings.GLOBAL_GROUP_NAME:\n                thread.make_public(recursive=True)\n            else:\n                group = models.Group.objects.get(name=group_name)\n                thread.add_to_groups((group,), recursive=True)\n\n            #get notif sets after\n            sets2 = question_post.get_notify_sets(\n                                    mentioned_users=list(),\n                                    exclude_list=[request.user,]\n                                )\n\n            notify_sets = {\n                'for_mentions': sets2['for_mentions'] - sets1['for_mentions'],\n                'for_email': sets2['for_email'] - sets1['for_email'],\n                'for_inbox': sets2['for_inbox'] - sets1['for_inbox']\n            }\n\n            question_post.issue_update_notifications(\n                updated_by=request.user,\n                notify_sets=notify_sets,\n                activity_type=const.TYPE_ACTIVITY_POST_SHARED,\n                timestamp=datetime.datetime.now()\n            )\n\n            return HttpResponseRedirect(thread.get_absolute_url())\n    except Exception:\n        error_message = _('Sorry, looks like sharing request was invalid')\n        request.user.message_set.create(message=error_message)\n        return HttpResponseRedirect(thread.get_absolute_url())\n\n@csrf.csrf_protect\ndef share_question_with_user(request):\n    form = forms.ShareQuestionForm(request.POST)\n    try:\n        if form.is_valid():\n\n            thread_id = form.cleaned_data['thread_id']\n            username = form.cleaned_data['recipient_name']\n\n            thread = models.Thread.objects.get(id=thread_id)\n            user = models.User.objects.get(username=username)\n            group = user.get_personal_group()\n            thread.add_to_groups([group], recursive=True)\n            #notify the person\n            #todo: see if user could already see the post - b/f the sharing\n            notify_sets = {\n                'for_inbox': set([user]),\n                'for_mentions': set([user]),\n                'for_email': set([user])\n            }\n            thread._question_post().issue_update_notifications(\n                updated_by=request.user,\n                notify_sets=notify_sets,\n                activity_type=const.TYPE_ACTIVITY_POST_SHARED,\n                timestamp=datetime.datetime.now()\n            )\n\n            return HttpResponseRedirect(thread.get_absolute_url())\n    except Exception:\n        error_message = _('Sorry, looks like sharing request was invalid')\n        request.user.message_set.create(message=error_message)\n        return HttpResponseRedirect(thread.get_absolute_url())\n\n@csrf.csrf_protect\ndef moderate_group_join_request(request):\n    \"\"\"moderator of the group can accept or reject a new user\"\"\"\n    request_id = IntegerField().clean(request.POST['request_id'])\n    action = request.POST['action']\n    assert(action in ('approve', 'deny'))\n\n    activity = get_object_or_404(models.Activity, pk=request_id)\n    group = activity.content_object\n    applicant = activity.user\n\n    if group.has_moderator(request.user):\n        group_membership = models.GroupMembership.objects.get(\n                                            user=applicant, group=group\n                                        )\n        if action == 'approve':\n            group_membership.level = models.GroupMembership.FULL\n            group_membership.save()\n            msg_data = {'user': applicant.username, 'group': group.name}\n            message = _('%(user)s, welcome to group %(group)s!') % msg_data\n            applicant.message_set.create(message=message)\n        else:\n            group_membership.delete()\n\n        activity.delete()\n        url = request.user.get_absolute_url() + '?sort=inbox&section=join_requests'\n        return HttpResponseRedirect(url)\n    else:\n        raise Http404\n\n@decorators.get_only\ndef get_editor(request):\n    \"\"\"returns bits of html for the tinymce editor in a dictionary with keys:\n    * html - the editor element\n    * scripts - an array of script tags\n    * success - True\n    \"\"\"\n    if 'config' not in request.GET:\n        return HttpResponseForbidden()\n    config = simplejson.loads(request.GET['config'])\n    element_id = request.GET.get('id', 'editor')\n    form = forms.EditorForm(\n                attrs={'id': element_id},\n                editor_attrs=config,\n                user=request.user\n            )\n    editor_html = render_text_into_skin(\n        '{{ form.media }} {{ form.editor }}',\n        {'form': form},\n        request\n    )\n    #parse out javascript and dom, and return them separately\n    #we need that, because js needs to be added in a special way\n    html_soup = BeautifulSoup(editor_html)\n\n    parsed_scripts = list()\n    for script in html_soup.find_all('script'):\n        parsed_scripts.append({\n            'contents': script.string,\n            'src': script.get('src', None)\n        })\n\n    data = {\n        'html': str(html_soup.textarea),\n        'scripts': parsed_scripts,\n        'success': True\n    }\n    return HttpResponse(simplejson.dumps(data), mimetype='application/json')\n\n@csrf.csrf_exempt\n@decorators.ajax_only\n@decorators.post_only\ndef publish_answer(request):\n    \"\"\"will publish or unpublish answer, if\n    current thread is moderated\n    \"\"\"\n    denied_msg = _('Sorry, only thread moderators can use this function')\n    if request.user.is_authenticated():\n        if request.user.is_administrator_or_moderator() is False:\n            raise exceptions.PermissionDenied(denied_msg)\n    #todo: assert permission\n    answer_id = IntegerField().clean(request.POST['answer_id'])\n    answer = models.Post.objects.get(id=answer_id, post_type='answer')\n\n    if answer.thread.has_moderator(request.user) is False:\n        raise exceptions.PermissionDenied(denied_msg)\n\n    enquirer = answer.thread._question_post().author\n    enquirer_group = enquirer.get_personal_group()\n\n    if answer.has_group(enquirer_group):\n        message = _('The answer is now unpublished')\n        answer.remove_from_groups([enquirer_group])\n    else:\n        answer.add_to_groups([enquirer_group])\n        message = _('The answer is now published')\n        #todo: notify enquirer by email about the post\n    request.user.message_set.create(message=message)\n    return {'redirect_url': answer.get_absolute_url()}\n", "patch": "@@ -699,7 +699,7 @@ def subscribe_for_tags(request):\n             else:\n                 message = _(\n                     'Tag subscription was canceled (<a href=\"%(url)s\">undo</a>).'\n-                ) % {'url': request.path + '?tags=' + request.REQUEST['tags']}\n+                ) % {'url': escape(request.path) + '?tags=' + request.REQUEST['tags']}\n                 request.user.message_set.create(message = message)\n             return HttpResponseRedirect(reverse('index'))\n         else:", "file_path": "files/2014_3/115", "file_language": "py", "file_name": "askbot/views/commands.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
