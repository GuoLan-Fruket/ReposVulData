{"index": 6450, "cve_id": "CVE-2021-3583", "cwe_id": ["CWE-94", "CWE-77", "CWE-20"], "cve_language": "Python", "cve_description": "A flaw was found in Ansible, where a user's controller is vulnerable to template injection. This issue can occur through facts used in the template if the user is trying to put templates in multi-line YAML strings and the facts being handled do not routinely include special template characters. This flaw allows attackers to perform command injection, which discloses sensitive information. The highest threat from this vulnerability is to confidentiality and integrity.", "cvss": "7.1", "publish_date": "September 22, 2021", "AV": "LOCAL", "AC": "LOCAL", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "NONE", "commit_id": "4c8c40fd3d4a58defdc80e7d22aa8d26b731353e", "commit_message": "fix unsafe preservation across newlines (#74960)\n\n* fix unsafe preservation across newlines\r\n\r\n  CVE-2021-3583\r\n  ensure we always have unsafe\r\n\r\nCo-authored-by: Rick Elrod <rick@elrod.me>", "commit_date": "2021-06-11T13:33:40Z", "project": "ansible/ansible", "url": "https://api.github.com/repos/ansible/ansible/commits/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e", "html_url": "https://github.com/ansible/ansible/commit/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e", "windows_before": [{"commit_id": "473df5c13f8fe1b2b7efb4a65b0a0b3887e85b39", "commit_date": "Fri Jun 11 06:58:00 2021 +0200", "commit_message": "fix doc: add possible state 'inactive' (#74928)", "files_name": ["lib/ansible/modules/service_facts.py"]}, {"commit_id": "576e0f64046f944fb803d7c126beddf6e72d068d", "commit_date": "Thu Jun 10 17:45:52 2021 -0700", "commit_message": "Update the porting guide for ansible 4.1.0 (#74965)", "files_name": ["docs/docsite/rst/porting_guides/porting_guide_4.rst"]}, {"commit_id": "675df166c27bc82a4d9a7cba45e11aec0300ae2c", "commit_date": "Thu Jun 10 16:22:41 2021 -0400", "commit_message": "fix ssh_transfer_method/scp_if_ssh defaults (#74925)", "files_name": ["changelogs/fragments/fix_scp_ssh_settings.yml", "lib/ansible/plugins/connection/ssh.py"]}, {"commit_id": "50e998e30362c02d89115e5933ee2b3af2d05edd", "commit_date": "Thu Jun 10 21:47:59 2021 +0200", "commit_message": "apt_key: add --recv argument as last one (#74949)", "files_name": ["changelogs/fragments/74949-apt_key_recv_last_arg.yml", "lib/ansible/modules/apt_key.py", "test/units/modules/test_apt_key.py"]}, {"commit_id": "81ad125aa65ef6c1c1c4137f49c2f1c91bca7d2b", "commit_date": "Thu Jun 10 21:34:04 2021 +0200", "commit_message": "Fix name of subkey. (#74939)", "files_name": ["docs/docsite/rst/user_guide/playbooks_reuse_roles.rst"]}, {"commit_id": "6539c598579f960c16745b3e35c8e841b23fb1a5", "commit_date": "Thu Jun 10 15:31:17 2021 -0400", "commit_message": "ansible-pull - update help info for --directory option (#74936)", "files_name": ["changelogs/fragments/ansible-pull-doc-update.yml", "lib/ansible/cli/pull.py"]}, {"commit_id": "5ac1b04929aae38e4a4cfd199051f76c7aa187a0", "commit_date": "Thu Jun 10 21:07:55 2021 +0200", "commit_message": "Add support for unicode in ansible-inventory CLI (#74912)", "files_name": ["changelogs/fragments/57378-inventory-cli-unicode.yml", "lib/ansible/cli/inventory.py", "test/integration/targets/ansible-inventory/files/unicode.yml", "test/integration/targets/ansible-inventory/tasks/main.yml"]}, {"commit_id": "0a5cc80ce22debfe9879ab95e3d332522b3ea6ec", "commit_date": "Thu Jun 10 00:55:48 2021 -0400", "commit_message": "slurp - handle error when path is a directory (#74930)", "files_name": ["changelogs/fragments/slurp-handle-error-with-dir.yml", "lib/ansible/modules/slurp.py", "test/integration/targets/slurp/tasks/main.yml", "test/integration/targets/slurp/tasks/test_unreadable.yml"]}, {"commit_id": "36287e98108b2d53f4813770bfe93630026c86b9", "commit_date": "Wed Jun 9 10:22:05 2021 -0700", "commit_message": "Remove ignores that are resolved on devel", "files_name": ["test/sanity/ignore.txt"]}, {"commit_id": "3f694e9f022b92c32486a148d695686b2f9833be", "commit_date": "Wed Jun 9 07:58:00 2021 -0700", "commit_message": "Ignore smart quotes in the dev guide translation.", "files_name": ["test/sanity/ignore.txt"]}, {"commit_id": "d45c2cec5530a916c2b16dae1ade6c0bdf04b38f", "commit_date": "Wed Jun 9 11:50:13 2021 +0200", "commit_message": "Localization: Import first set of translated files", "files_name": ["docs/docsite/rst/locales/ja/LC_MESSAGES/404.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/api.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/cli.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/collections.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/community.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/dev_guide.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/galaxy.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/index.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/installation_guide.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/inventory.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/network.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/plugins.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/porting_guides.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/reference_appendices.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/roadmap.po", "docs/docsite/rst/locales/ja/LC_MESSAGES/scenario_guides.po"]}, {"commit_id": "1c4ca154fabffb706f8227054ddaa59e744001ef", "commit_date": "Wed Jun 9 12:13:56 2021 -0400", "commit_message": "improve inv plugin selectino for snippets (#74933)", "files_name": ["changelogs/fragments/snippets_inv_select.yml", "lib/ansible/cli/doc.py"]}, {"commit_id": "346c7a765df924ca3ee479093b7817e0c00825ac", "commit_date": "Tue Jun 8 21:38:23 2021 +0200", "commit_message": "Use `sphinx_ansible_theme` Sphinx theme in docs (#74318)", "files_name": ["docs/docsite/.templates/banner.html", "docs/docsite/.templates/breadcrumbs.html", "docs/docsite/.templates/version_chooser.html", "docs/docsite/_extensions/pygments_lexer.py", "docs/docsite/_static/ansible.css", "docs/docsite/_static/css/core-color-scheme.css", "docs/docsite/_static/pygments.css", "docs/docsite/_themes/sphinx_rtd_theme/__init__.py", "docs/docsite/_themes/sphinx_rtd_theme/ansible_banner.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_eol_banner.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_extrabody.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_extrafooter.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_extrahead.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_extranav.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_searchbox.html", "docs/docsite/_themes/sphinx_rtd_theme/ansible_versions.html", "docs/docsite/_themes/sphinx_rtd_theme/breadcrumbs.html", "docs/docsite/_themes/sphinx_rtd_theme/footer.html", "docs/docsite/_themes/sphinx_rtd_theme/layout.html", "docs/docsite/_themes/sphinx_rtd_theme/search.html", "docs/docsite/_themes/sphinx_rtd_theme/searchbox.html", "docs/docsite/_themes/sphinx_rtd_theme/static/css/badge_only.css", "docs/docsite/_themes/sphinx_rtd_theme/static/css/theme.css", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/FontAwesome.otf", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.svg", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff", "docs/docsite/_themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff2", "docs/docsite/_themes/sphinx_rtd_theme/static/images/logo_invert.png", "docs/docsite/_themes/sphinx_rtd_theme/static/js/modernizr.min.js", "docs/docsite/_themes/sphinx_rtd_theme/static/js/theme.js", "docs/docsite/_themes/sphinx_rtd_theme/theme.conf", "docs/docsite/_themes/sphinx_rtd_theme/versions.html", "docs/docsite/js/ansible/application.js", "docs/docsite/requirements.txt", "docs/docsite/sphinx_conf/2.10_conf.py", "docs/docsite/sphinx_conf/all_conf.py", "docs/docsite/sphinx_conf/ansible_conf.py", "docs/docsite/sphinx_conf/core_conf.py", "test/sanity/code-smell/docs-build.requirements.txt"]}, {"commit_id": "d9001f8fd0525a3f96a6164669dfb596e3a91cf8", "commit_date": "Tue Jun 8 09:27:21 2021 +0530", "commit_message": "Fix intro docs (#74843)", "files_name": ["docs/docsite/rst/installation_guide/intro_installation.rst"]}, {"commit_id": "6d2398db280f145eed70a6618282c9db630a380a", "commit_date": "Mon Jun 7 16:21:25 2021 -0400", "commit_message": "expand doc snippets to lookups and other plugins (#74403)", "files_name": ["changelogs/fragments/snippets.yml", "lib/ansible/cli/doc.py"]}, {"commit_id": "004c33d9c5fdb20a46b9ef8fb0e203dd34bed3b3", "commit_date": "Mon Jun 7 12:59:06 2021 -0400", "commit_message": "unarchive - do not fail in init when trying to find required binary (#74892)", "files_name": ["changelogs/fragments/unarchive-fix-bin-checking.yml", "lib/ansible/modules/unarchive.py", "test/integration/targets/unarchive/handlers/main.yml", "test/integration/targets/unarchive/tasks/main.yml", "test/integration/targets/unarchive/tasks/prepare_tests.yml", "test/integration/targets/unarchive/tasks/test_missing_binaries.yml", "test/integration/targets/unarchive/vars/Darwin.yml", "test/integration/targets/unarchive/vars/FreeBSD.yml", "test/integration/targets/unarchive/vars/Linux.yml", "test/units/modules/test_unarchive.py"]}, {"commit_id": "acf09e56a257d8b0548226cb9ab5ae9450df0d3d", "commit_date": "Mon Jun 7 18:37:39 2021 +0200", "commit_message": "Update inventory script references from c.g to ansible-community/contrib-scripts. (#74905)", "files_name": ["docs/docsite/rst/scenario_guides/guide_azure.rst", "docs/docsite/rst/scenario_guides/guide_docker.rst", "docs/docsite/rst/scenario_guides/guide_infoblox.rst", "docs/docsite/rst/scenario_guides/guide_packet.rst", "docs/docsite/rst/user_guide/intro_dynamic_inventory.rst"]}, {"commit_id": "5dd8dc8fd089e609d2a14c7ddaf1b11c4f396a0f", "commit_date": "Fri Jun 4 15:28:41 2021 -0400", "commit_message": "minor service_mgr facts fixes (#74894)", "files_name": ["changelogs/fragments/service_mgr_facts_fix.yml", "lib/ansible/module_utils/facts/system/service_mgr.py", "test/units/module_utils/facts/test_collectors.py"]}, {"commit_id": "6840b79e560b627b26fc5e6e646510ec478988a2", "commit_date": "Fri Jun 4 13:01:26 2021 -0400", "commit_message": "bring back async_status module for direct callers", "files_name": ["changelogs/fragments/async_unremove_redeprecate.yml", "lib/ansible/modules/async_status.py", "test/sanity/ignore.txt"]}, {"commit_id": "e2658801f6caa22399dd3aea33eb642a1e62b75a", "commit_date": "Fri Jun 4 16:20:44 2021 +0000", "commit_message": "Add seed parameter to password lookup (#69775)", "files_name": ["changelogs/fragments/password_seed.yml", "lib/ansible/plugins/lookup/password.py", "lib/ansible/utils/encrypt.py", "test/units/plugins/lookup/test_password.py"]}, {"commit_id": "ffa548503d311a37194c7528e5d6026816c2ae58", "commit_date": "Fri Jun 4 09:40:53 2021 -0500", "commit_message": "Wrap all results, regardless of register, except for actions with clean facts (#73161)", "files_name": ["changelogs/fragments/21088-no-auto-unsafe-set-fact-include-vars-with-register.yml", "lib/ansible/executor/task_executor.py", "test/integration/targets/include_vars/tasks/main.yml", "test/integration/targets/include_vars/vars/no_auto_unsafe.yml", "test/integration/targets/set_fact/runme.sh", "test/integration/targets/set_fact/set_fact_auto_unsafe.yml"]}, {"commit_id": "e70fc88656dbb04c4d3c2cda25942fa754da3b7e", "commit_date": "Fri Jun 4 23:38:23 2021 +0900", "commit_message": "slurp - better error handling for unreadable files and directories (#68608)", "files_name": ["changelogs/fragments/67340-slurp_error_message.yml", "lib/ansible/modules/slurp.py", "test/integration/targets/slurp/defaults/main.yml", "test/integration/targets/slurp/handlers/main.yml", "test/integration/targets/slurp/tasks/main.yml", "test/integration/targets/slurp/tasks/test_unreadable.yml"]}, {"commit_id": "26827f50393b21a87b8640387cb77ee0801155ea", "commit_date": "Fri Jun 4 10:22:39 2021 -0400", "commit_message": "ansible-doc fix displaying 'CLI' options for plugin docs", "files_name": ["changelogs/fragments/doc_knows_cli.yml", "lib/ansible/cli/doc.py", "lib/ansible/plugins/connection/ssh.py"]}, {"commit_id": "6a883f1cd62c989dc26b765a56ecab77f2dfbca9", "commit_date": "Fri Jun 4 10:21:12 2021 -0400", "commit_message": "better message and timeout warning when timeout (#74885)", "files_name": ["changelogs/fragments/better_timeout_msg.yml", "lib/ansible/module_utils/facts/hardware/linux.py"]}, {"commit_id": "3d8feed2cfd1d3c3fa4d4dd0ecf2f64870cbd3d0", "commit_date": "Fri Jun 4 13:20:19 2021 +0100", "commit_message": "Update playbooks_filters.rst (#74911)", "files_name": ["docs/docsite/rst/user_guide/playbooks_filters.rst"]}, {"commit_id": "33924d7e8dac0736342032c79136bd75d8dc11bf", "commit_date": "Thu Jun 3 15:51:31 2021 -0500", "commit_message": "gives each banner a unique div ID (#74907)", "files_name": ["docs/docsite/_themes/sphinx_rtd_theme/ansible_banner.html"]}, {"commit_id": "4f3ee4624e8d393576da8bc17d258d9e416b9ffb", "commit_date": "Thu Jun 3 21:17:19 2021 +0200", "commit_message": "Add end_batch meta task (#74899)", "files_name": ["changelogs/fragments/end_batch-meta-task.yml", "lib/ansible/modules/meta.py", "lib/ansible/plugins/strategy/__init__.py", "test/integration/targets/meta_tasks/runme.sh", "test/integration/targets/meta_tasks/test_end_batch.yml"]}, {"commit_id": "ac779114911ec72d4d61478b7091889fa8a01cc9", "commit_date": "Thu Jun 3 14:11:01 2021 -0500", "commit_message": "Prevent conditional templating errors from masking task output. Fixes #37187 (#74891)", "files_name": ["changelogs/fragments/37187-catch-cond-tmpl-errors.yml", "lib/ansible/executor/task_executor.py", "test/integration/targets/changed_when/tasks/main.yml", "test/integration/targets/failed_when/tasks/main.yml"]}, {"commit_id": "8f82e6327f57d351a0016f44ef47b651393148d3", "commit_date": "Fri Jun 4 00:37:54 2021 +0530", "commit_message": "ansible-cli: Remove unnessary trailing space (#74880)", "files_name": ["changelogs/fragments/74875_ansible_version.yml", "lib/ansible/cli/arguments/option_helpers.py"]}], "windows_after": [{"commit_id": "9a21e247786ebd294dafafca1105fcd770ff46c6", "commit_date": "Fri Jun 11 10:22:18 2021 -0400", "commit_message": "get_distribution - Return distribution for all platforms (#71641)", "files_name": ["changelogs/fragments/17587-get-distribution-more-distros.yml", "lib/ansible/module_utils/common/sys_info.py", "test/units/module_utils/basic/test_platform_distribution.py", "test/units/module_utils/common/test_sys_info.py", "test/units/modules/test_service.py"]}, {"commit_id": "a8cf0196f743650876f4ada4db00f91147535614", "commit_date": "Fri Jun 11 10:23:42 2021 -0400", "commit_message": "subversion - fix stack trace when getting repository information (#74405)", "files_name": ["changelogs/fragments/36498-subversion-fix-info-parsing.yml", "lib/ansible/modules/subversion.py"]}, {"commit_id": "cf3a304ce1711ed9a19549fbf58c004acd47c06a", "commit_date": "Sat Jun 12 12:01:23 2021 +1000", "commit_message": "psrp - Fix reset connection on failed scenarios (#74967)", "files_name": ["changelogs/fragments/psrp-reset.yml", "lib/ansible/plugins/connection/psrp.py"]}, {"commit_id": "d2d45900edc7f52cf3e3685d65f824a445cc8c41", "commit_date": "Mon Jun 14 09:32:28 2021 -0400", "commit_message": "setup module, filter compensate for prefixes (#74924)", "files_name": ["changelogs/fragments/setup_filter_smarter.yml", "changelogs/fragments/ssh_conn_fixes.yml", "lib/ansible/module_utils/facts/ansible_collector.py", "test/integration/targets/gathering_facts/inventory", "test/integration/targets/gathering_facts/test_gathering_facts.yml"]}, {"commit_id": "97acb0f470471c9dcf1e357f1672127f146240a8", "commit_date": "Mon Jun 14 13:28:56 2021 -0400", "commit_message": "role argspec - tag role argspec validation task with 'always' (#74994)", "files_name": ["changelogs/fragments/role_argspec_tagged_always.yml", "docs/docsite/rst/user_guide/playbooks_tags.rst", "lib/ansible/playbook/role/__init__.py", "test/integration/targets/roles_arg_spec/runme.sh", "test/integration/targets/roles_arg_spec/test_tags.yml"]}, {"commit_id": "77e936bd509a179cbb168b9fd0b318f0e27295ce", "commit_date": "Mon Jun 14 16:39:59 2021 -0400", "commit_message": "async_status revert most changes, keep some fixes, undep module (#74931)", "files_name": ["changelogs/fragments/async_status.yml", "changelogs/fragments/async_status_fixes.yml", "lib/ansible/modules/async_status.py", "lib/ansible/plugins/action/async_status.py", "test/integration/targets/async/tasks/main.yml"]}, {"commit_id": "58450f041a6ffc343e5d19569580f5189e09200c", "commit_date": "Mon Jun 14 23:26:40 2021 +0200", "commit_message": "Do not show empty version_added_collection values in ansible-doc text output. (#74999)", "files_name": ["changelogs/fragments/74999-ansible-doc-version_added_collection.yml", "lib/ansible/cli/doc.py"]}, {"commit_id": "58d83977718363c15fb5954a7d5e05e81548b590", "commit_date": "Tue Jun 15 07:33:56 2021 +1000", "commit_message": "psrp - cleanup command (#74985)", "files_name": ["changelogs/fragments/psrp-cleanup.yml", "lib/ansible/plugins/connection/psrp.py"]}, {"commit_id": "7f6edd78f968a1811aebf8578fe785a353399601", "commit_date": "Tue Jun 15 17:12:49 2021 +0200", "commit_message": "Move Docker scenario guide to community.docker. (#74736)", "files_name": ["docs/docsite/rst/scenario_guides/guide_docker.rst", "docs/docsite/rst/scenario_guides/guides.rst"]}, {"commit_id": "e6a7bc854cabc99eff1b46109fcde7eb28aaac23", "commit_date": "Tue Jun 15 21:35:34 2021 +0200", "commit_message": "Only consider directories which do have .deps files other than ancestor.deps. (#74987)", "files_name": ["hacking/build_library/build_ansible/command_plugins/docs_build.py"]}, {"commit_id": "79a0799082c5a1d5c04ba4dd560475f97dea4ab5", "commit_date": "Tue Jun 15 18:03:01 2021 -0400", "commit_message": "fix typo in host_group_vars config (#75012)", "files_name": ["changelogs/fragments/host_group_vars_cfg_fix.yaml", "lib/ansible/plugins/vars/host_group_vars.py"]}, {"commit_id": "4cb20f577ba81867564856645cb7e463104cf585", "commit_date": "Wed Jun 16 16:00:15 2021 +0200", "commit_message": "Fix env lookup docs typo (#75022)", "files_name": ["lib/ansible/plugins/lookup/env.py"]}, {"commit_id": "5df82415b553a96c50b335b3480385e5701a9033", "commit_date": "Wed Jun 16 17:32:12 2021 +0300", "commit_message": "collections_using.rst: add note that manual upgrade is required when installing collections from Galaxy (#75024)", "files_name": ["docs/docsite/rst/user_guide/collections_using.rst"]}, {"commit_id": "2387ce311f26ca34bf6974d1231d470db22fdd42", "commit_date": "Wed Jun 16 10:47:26 2021 -0400", "commit_message": "remove reference to container ML (#75014)", "files_name": ["docs/docsite/rst/community/communication.rst"]}, {"commit_id": "7d38bb05e41d7c4fe8046625794c6e3eb9b4b52f", "commit_date": "Wed Jun 16 11:13:11 2021 -0400", "commit_message": "small note about add_hosts/limit interaction (#74978)", "files_name": ["lib/ansible/modules/add_host.py"]}, {"commit_id": "b0f62062d3af793b4f789aba08f124c862e75f0f", "commit_date": "Wed Jun 16 22:16:30 2021 +0700", "commit_message": "Async task change handling (#75020)", "files_name": ["docs/docsite/rst/user_guide/playbooks_async.rst"]}, {"commit_id": "3fa6e6d038d5895eb915e614427f3a51061c3c20", "commit_date": "Wed Jun 16 11:18:44 2021 -0400", "commit_message": "example hosts should match play (#74959)", "files_name": ["docs/docsite/rst/user_guide/playbooks_strategies.rst"]}, {"commit_id": "2e2a5829a26095857696051809639d0fe4c533a8", "commit_date": "Wed Jun 16 17:22:26 2021 +0200", "commit_message": "Update FreeBSD Python version in intro_bsd.rst (#74938)", "files_name": ["docs/docsite/rst/user_guide/intro_bsd.rst"]}, {"commit_id": "6fd61bb19f17a3cbeda8b5c120daaf4ad5a561e1", "commit_date": "Wed Jun 16 12:44:02 2021 -0400", "commit_message": "add option def/handling to lookup (#74495)", "files_name": ["docs/docsite/rst/dev_guide/developing_plugins.rst"]}, {"commit_id": "08fc43f3eaf180ddaa43d86e3dec3e6712c94bf6", "commit_date": "Wed Jun 16 12:46:21 2021 -0400", "commit_message": "document keywords (#74046)", "files_name": ["docs/docsite/rst/reference_appendices/glossary.rst"]}, {"commit_id": "5b8fb4dcd3d84aad77330644a7326bc16dd02a3b", "commit_date": "Mon Jun 14 13:46:26 2021 -0400", "commit_message": "ansible-test: exposes tiny_prefix variable", "files_name": ["changelogs/fragments/aws_tiny_prefix.yaml", "test/lib/ansible_test/_internal/commands/integration/cloud/aws.py"]}, {"commit_id": "0467b1d477b863568a00006cedf652712492bd6e", "commit_date": "Tue Jun 15 15:20:31 2021 -0400", "commit_message": "file integration test - cleanup testing users and group", "files_name": ["test/integration/targets/file/handlers/main.yml", "test/integration/targets/file/tasks/main.yml", "test/integration/targets/file/tasks/state_link.yml"]}, {"commit_id": "5a5a1882d471f9b5eec94ca582422225d68c869c", "commit_date": "Wed Jun 16 13:43:01 2021 -0400", "commit_message": "Added FAQ entry for complex validation needs (#74707)", "files_name": ["docs/docsite/rst/reference_appendices/faq.rst", "lib/ansible/plugins/doc_fragments/validate.py"]}, {"commit_id": "be0cdc0ea28cdfd0ba4fb448fe66b4dde2aedcb6", "commit_date": "Wed Jun 16 13:51:07 2021 -0400", "commit_message": "deprecate `_remote_checksum()` and remove use in fetch (#74848)", "files_name": ["lib/ansible/plugins/action/__init__.py", "lib/ansible/plugins/action/fetch.py", "test/integration/targets/fetch/cleanup.yml", "test/integration/targets/fetch/hosts.yml", "test/integration/targets/fetch/roles/fetch_tests/defaults/main.yml", "test/integration/targets/fetch/roles/fetch_tests/handlers/main.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/fail_on_missing.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/failures.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/main.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/normal.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/setup.yml", "test/integration/targets/fetch/roles/fetch_tests/tasks/symlink.yml", "test/integration/targets/fetch/roles/fetch_tests/vars/Darwin.yml", "test/integration/targets/fetch/roles/fetch_tests/vars/default.yml", "test/integration/targets/fetch/runme.sh", "test/integration/targets/fetch/setup_unreadable_test.yml", "test/integration/targets/fetch/test_unreadable_with_stat.yml", "test/integration/targets/setup_remote_tmp_dir/defaults/main.yml", "test/integration/targets/setup_remote_tmp_dir/handlers/main.yml", "test/integration/targets/setup_remote_tmp_dir/tasks/default.yml"]}, {"commit_id": "4e608c02fb79b37a078ec970b0dc65db7d0d69b6", "commit_date": "Wed Jun 16 16:58:02 2021 -0400", "commit_message": "Add changelog and porting guide for _remote_checksum() deprecation (#75035)", "files_name": ["changelogs/fragments/29457-deprecate-remote_checksum.yml", "docs/docsite/rst/porting_guides/porting_guide_core_2.12.rst"]}, {"commit_id": "4ab791d501771d34fef6edb8f2f7932ed3885687", "commit_date": "Wed Jun 16 18:06:18 2021 -0400", "commit_message": "command - remove unreachable code and achieve full test coverage (#75036)", "files_name": ["changelogs/fragments/command-remove-unreachable-code.yml", "lib/ansible/modules/command.py", "test/integration/targets/command_shell/tasks/main.yml"]}, {"commit_id": "afe6eb574ef8e53e805cc1ff2b25dd9108b29e1c", "commit_date": "Wed Jun 16 18:08:34 2021 -0400", "commit_message": "slurp - improve error code and test coverage (#75038)", "files_name": ["changelogs/fragments/slurp-improve-error-handling-readability.yml", "lib/ansible/modules/slurp.py", "test/integration/targets/slurp/tasks/main.yml", "test/integration/targets/slurp/tasks/test_unreadable.yml"]}, {"commit_id": "5e65d9834ba5852f1915c360a24f843b46d2d8bc", "commit_date": "Thu Jun 17 06:41:09 2021 -0700", "commit_message": "tempfile - Remove unnecessary conditional. (#75039)", "files_name": ["changelogs/fragments/tempfile.yml", "lib/ansible/modules/tempfile.py", "test/integration/targets/tempfile/aliases", "test/integration/targets/tempfile/meta/main.yml", "test/integration/targets/tempfile/tasks/main.yml"]}, {"commit_id": "ce17498ec5e7da9c25ebd73b04da8842e7ec894f", "commit_date": "Thu Jun 17 07:32:42 2021 -0700", "commit_message": "blockinfile - Remove unused code for Ansible 1.x. (#75040)", "files_name": ["changelogs/fragments/blockinfile-unused-code.yml", "lib/ansible/modules/blockinfile.py"]}, {"commit_id": "e8ae7211dabbd07093f50d6dfb383da3bb14f13d", "commit_date": "Thu Jun 17 15:14:41 2021 -0400", "commit_message": "deprecate FileLock (#75032)", "files_name": ["changelogs/fragments/filelock_bye.yml", "lib/ansible/module_utils/common/file.py"]}, {"commit_id": "cd473dfb2fdbc97acf3293c134b21cbbcfa89ec3", "commit_date": "Thu Jun 17 15:32:56 2021 -0400", "commit_message": "play - validate hosts entries (#74147)", "files_name": ["changelogs/fragments/65386-validate-hosts.yml", "lib/ansible/playbook/play.py", "test/integration/targets/playbook/runme.sh", "test/units/playbook/test_play.py"]}, {"commit_id": "38a11c3240b90562527d024450090b6214500476", "commit_date": "Fri Jun 18 13:31:11 2021 +0900", "commit_message": "Fix typo in default_callback.py (#75051)", "files_name": ["lib/ansible/plugins/doc_fragments/default_callback.py"]}, {"commit_id": "ec408a69f19052190f1766a357c882fc86cfeada", "commit_date": "Sat Jun 19 09:10:14 2021 +0200", "commit_message": "\ud83d\udd25 Drop unused `core.css` file", "files_name": ["docs/docsite/_static/core.css"]}, {"commit_id": "ad203a7dbdbcab9af0b89a577433af860b542e01", "commit_date": "Mon Jun 21 10:47:42 2021 -0400", "commit_message": "Add page describing terminal plugins to docsite (#75066)", "files_name": ["changelogs/fragments/terminal-documentation.yaml", "docs/docsite/rst/plugins/plugins.rst", "docs/docsite/rst/plugins/terminal.rst"]}, {"commit_id": "a7be495b7b434990e129070213d09e726f3684af", "commit_date": "Mon Jun 21 15:07:18 2021 -0500", "commit_message": "Update plugin docs (#75050)", "files_name": ["docs/docsite/rst/plugins/action.rst", "docs/docsite/rst/plugins/become.rst", "docs/docsite/rst/plugins/cache.rst", "docs/docsite/rst/plugins/callback.rst", "docs/docsite/rst/plugins/cliconf.rst", "docs/docsite/rst/plugins/connection.rst", "docs/docsite/rst/plugins/docs_fragment.rst", "docs/docsite/rst/plugins/filter.rst", "docs/docsite/rst/plugins/httpapi.rst", "docs/docsite/rst/plugins/inventory.rst", "docs/docsite/rst/plugins/lookup.rst", "docs/docsite/rst/plugins/module.rst", "docs/docsite/rst/plugins/module_util.rst", "docs/docsite/rst/plugins/netconf.rst", "docs/docsite/rst/plugins/plugins.rst", "docs/docsite/rst/plugins/shell.rst", "docs/docsite/rst/plugins/strategy.rst", "docs/docsite/rst/plugins/terminal.rst", "docs/docsite/rst/plugins/test.rst", "docs/docsite/rst/plugins/vars.rst"]}, {"commit_id": "c404a9003fbfc56785d32e3f6e6ab005d0467927", "commit_date": "Mon Jun 21 22:27:00 2021 +0200", "commit_message": "ansible-doc: improve version_added handling (#73602)", "files_name": ["changelogs/fragments/73602-ansible-doc-version-added.yml", "lib/ansible/cli/doc.py", "test/integration/targets/ansible-doc/fakemodule.output", "test/integration/targets/ansible-doc/randommodule-text.output", "test/integration/targets/ansible-doc/runme.sh"]}, {"commit_id": "8e755707b9fd418ca2a097ce52ba8849c0181c14", "commit_date": "Tue Jun 22 12:59:53 2021 +0900", "commit_message": "Add 'hash_behaviour' option to include_vars module (#72944)", "files_name": []}], "parents": [{"commit_id_before": "473df5c13f8fe1b2b7efb4a65b0a0b3887e85b39", "url_before": "https://api.github.com/repos/ansible/ansible/commits/473df5c13f8fe1b2b7efb4a65b0a0b3887e85b39", "html_url_before": "https://github.com/ansible/ansible/commit/473df5c13f8fe1b2b7efb4a65b0a0b3887e85b39"}], "details": [{"raw_url": "https://github.com/ansible/ansible/raw/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e/changelogs%2Ffragments%2Ffix_unsafe_newline.yml", "code": "security_fixes:\n  - templating engine fix for not preserving usnafe status when trying to preserve newlines. CVE-2021-3583\n", "code_before": "", "patch": "@@ -0,0 +1,2 @@\n+security_fixes:\n+  - templating engine fix for not preserving usnafe status when trying to preserve newlines. CVE-2021-3583", "file_path": "files/2021_9/81", "file_language": "yml", "file_name": "changelogs/fragments/fix_unsafe_newline.yml", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ansible/ansible/raw/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e/lib%2Fansible%2Ftemplate%2F__init__.py", "code": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport ast\nimport datetime\nimport os\nimport pkgutil\nimport pwd\nimport re\nimport time\n\nfrom contextlib import contextmanager\nfrom ansible.module_utils.compat.version import LooseVersion\nfrom numbers import Number\nfrom traceback import format_exc\n\ntry:\n    from hashlib import sha1\nexcept ImportError:\n    from sha import sha as sha1\n\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\nfrom jinja2.loaders import FileSystemLoader\nfrom jinja2.runtime import Context, StrictUndefined\n\nfrom ansible import constants as C\nfrom ansible.errors import (\n    AnsibleAssertionError,\n    AnsibleError,\n    AnsibleFilterError,\n    AnsibleLookupError,\n    AnsibleOptionsError,\n    AnsiblePluginRemovedError,\n    AnsibleUndefinedVariable,\n)\nfrom ansible.module_utils.six import iteritems, string_types, text_type\nfrom ansible.module_utils.six.moves import range\nfrom ansible.module_utils._text import to_native, to_text, to_bytes\nfrom ansible.module_utils.common._collections_compat import Iterator, Sequence, Mapping, MappingView, MutableMapping\nfrom ansible.module_utils.common.collections import is_sequence\nfrom ansible.module_utils.compat.importlib import import_module\nfrom ansible.plugins.loader import filter_loader, lookup_loader, test_loader\nfrom ansible.template.safe_eval import safe_eval\nfrom ansible.template.template import AnsibleJ2Template\nfrom ansible.template.vars import AnsibleJ2Vars\nfrom ansible.utils.collection_loader import AnsibleCollectionRef\nfrom ansible.utils.display import Display\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_metadata\nfrom ansible.utils.listify import listify_lookup_plugin_terms\nfrom ansible.utils.unsafe_proxy import wrap_var\n\ndisplay = Display()\n\n\n__all__ = ['Templar', 'generate_ansible_template_vars']\n\n# A regex for checking to see if a variable we're trying to\n# expand is just a single variable name.\n\n# Primitive Types which we don't want Jinja to convert to strings.\nNON_TEMPLATED_TYPES = (bool, Number)\n\nJINJA2_OVERRIDE = '#jinja2:'\n\nfrom jinja2 import __version__ as j2_version\nfrom jinja2 import Environment\nfrom jinja2.utils import concat as j2_concat\n\n\nUSE_JINJA2_NATIVE = False\nif C.DEFAULT_JINJA2_NATIVE:\n    try:\n        from jinja2.nativetypes import NativeEnvironment\n        from ansible.template.native_helpers import ansible_native_concat\n        from ansible.utils.native_jinja import NativeJinjaText\n        USE_JINJA2_NATIVE = True\n    except ImportError:\n        from jinja2 import Environment\n        from jinja2.utils import concat as j2_concat\n        display.warning(\n            'jinja2_native requires Jinja 2.10 and above. '\n            'Version detected: %s. Falling back to default.' % j2_version\n        )\n\n\nJINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))\nJINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))\n\n\nRANGE_TYPE = type(range(0))\n\n\ndef generate_ansible_template_vars(path, fullpath=None, dest_path=None):\n\n    if fullpath is None:\n        b_path = to_bytes(path)\n    else:\n        b_path = to_bytes(fullpath)\n\n    try:\n        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name\n    except (KeyError, TypeError):\n        template_uid = os.stat(b_path).st_uid\n\n    temp_vars = {\n        'template_host': to_text(os.uname()[1]),\n        'template_path': path,\n        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),\n        'template_uid': to_text(template_uid),\n        'template_run_date': datetime.datetime.now(),\n        'template_destpath': to_native(dest_path) if dest_path else None,\n    }\n\n    if fullpath is None:\n        temp_vars['template_fullpath'] = os.path.abspath(path)\n    else:\n        temp_vars['template_fullpath'] = fullpath\n\n    managed_default = C.DEFAULT_MANAGED_STR\n    managed_str = managed_default.format(\n        host=temp_vars['template_host'],\n        uid=temp_vars['template_uid'],\n        file=temp_vars['template_path'],\n    )\n    temp_vars['ansible_managed'] = to_text(time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path))))\n\n    return temp_vars\n\n\ndef _escape_backslashes(data, jinja_env):\n    \"\"\"Double backslashes within jinja2 expressions\n\n    A user may enter something like this in a playbook::\n\n      debug:\n        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"\n\n    The string inside of the {{ gets interpreted multiple times First by yaml.\n    Then by python.  And finally by jinja2 as part of it's variable.  Because\n    it is processed by both python and jinja2, the backslash escaped\n    characters get unescaped twice.  This means that we'd normally have to use\n    four backslashes to escape that.  This is painful for playbook authors as\n    they have to remember different rules for inside vs outside of a jinja2\n    expression (The backslashes outside of the \"{{ }}\" only get processed by\n    yaml and python.  So they only need to be escaped once).  The following\n    code fixes this by automatically performing the extra quoting of\n    backslashes inside of a jinja2 expression.\n\n    \"\"\"\n    if '\\\\' in data and '{{' in data:\n        new_data = []\n        d2 = jinja_env.preprocess(data)\n        in_var = False\n\n        for token in jinja_env.lex(d2):\n            if token[1] == 'variable_begin':\n                in_var = True\n                new_data.append(token[2])\n            elif token[1] == 'variable_end':\n                in_var = False\n                new_data.append(token[2])\n            elif in_var and token[1] == 'string':\n                # Double backslashes only if we're inside of a jinja2 variable\n                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))\n            else:\n                new_data.append(token[2])\n\n        data = ''.join(new_data)\n\n    return data\n\n\ndef is_template(data, jinja_env):\n    \"\"\"This function attempts to quickly detect whether a value is a jinja2\n    template. To do so, we look for the first 2 matching jinja2 tokens for\n    start and end delimiters.\n    \"\"\"\n    found = None\n    start = True\n    comment = False\n    d2 = jinja_env.preprocess(data)\n\n    # This wraps a lot of code, but this is due to lex returning a generator\n    # so we may get an exception at any part of the loop\n    try:\n        for token in jinja_env.lex(d2):\n            if token[1] in JINJA2_BEGIN_TOKENS:\n                if start and token[1] == 'comment_begin':\n                    # Comments can wrap other token types\n                    comment = True\n                start = False\n                # Example: variable_end -> variable\n                found = token[1].split('_')[0]\n            elif token[1] in JINJA2_END_TOKENS:\n                if token[1].split('_')[0] == found:\n                    return True\n                elif comment:\n                    continue\n                return False\n    except TemplateSyntaxError:\n        return False\n\n    return False\n\n\ndef _count_newlines_from_end(in_str):\n    '''\n    Counts the number of newlines at the end of a string. This is used during\n    the jinja2 templating to ensure the count matches the input, since some newlines\n    may be thrown away during the templating.\n    '''\n\n    try:\n        i = len(in_str)\n        j = i - 1\n        while in_str[j] == '\\n':\n            j -= 1\n        return i - 1 - j\n    except IndexError:\n        # Uncommon cases: zero length string and string containing only newlines\n        return i\n\n\ndef recursive_check_defined(item):\n    from jinja2.runtime import Undefined\n\n    if isinstance(item, MutableMapping):\n        for key in item:\n            recursive_check_defined(item[key])\n    elif isinstance(item, list):\n        for i in item:\n            recursive_check_defined(i)\n    else:\n        if isinstance(item, Undefined):\n            raise AnsibleFilterError(\"{0} is undefined\".format(item))\n\n\ndef _is_rolled(value):\n    \"\"\"Helper method to determine if something is an unrolled generator,\n    iterator, or similar object\n    \"\"\"\n    return (\n        isinstance(value, Iterator) or\n        isinstance(value, MappingView) or\n        isinstance(value, RANGE_TYPE)\n    )\n\n\ndef _unroll_iterator(func):\n    \"\"\"Wrapper function, that intercepts the result of a filter\n    and auto unrolls a generator, so that users are not required to\n    explicitly use ``|list`` to unroll.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if _is_rolled(ret):\n            return list(ret)\n        return ret\n\n    return _update_wrapper(wrapper, func)\n\n\ndef _update_wrapper(wrapper, func):\n    # This code is duplicated from ``functools.update_wrapper`` from Py3.7.\n    # ``functools.update_wrapper`` was failing when the func was ``functools.partial``\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(func, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in ('__dict__',):\n        getattr(wrapper, attr).update(getattr(func, attr, {}))\n    wrapper.__wrapped__ = func\n    return wrapper\n\n\ndef _wrap_native_text(func):\n    \"\"\"Wrapper function, that intercepts the result of a filter\n    and wraps it into NativeJinjaText which is then used\n    in ``ansible_native_concat`` to indicate that it is a text\n    which should not be passed into ``literal_eval``.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        return NativeJinjaText(ret)\n\n    return _update_wrapper(wrapper, func)\n\n\nclass AnsibleUndefined(StrictUndefined):\n    '''\n    A custom Undefined class, which returns further Undefined objects on access,\n    rather than throwing an exception.\n    '''\n    def __getattr__(self, name):\n        if name == '__UNSAFE__':\n            # AnsibleUndefined should never be assumed to be unsafe\n            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``\n            raise AttributeError(name)\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n    def __getitem__(self, key):\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n    def __repr__(self):\n        return 'AnsibleUndefined'\n\n    def __contains__(self, item):\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n\nclass AnsibleContext(Context):\n    '''\n    A custom context, which intercepts resolve() calls and sets a flag\n    internally if any variable lookup returns an AnsibleUnsafe value. This\n    flag is checked post-templating, and (when set) will result in the\n    final templated result being wrapped in AnsibleUnsafe.\n    '''\n    def __init__(self, *args, **kwargs):\n        super(AnsibleContext, self).__init__(*args, **kwargs)\n        self.unsafe = False\n\n    def _is_unsafe(self, val):\n        '''\n        Our helper function, which will also recursively check dict and\n        list entries due to the fact that they may be repr'd and contain\n        a key or value which contains jinja2 syntax and would otherwise\n        lose the AnsibleUnsafe value.\n        '''\n        if isinstance(val, dict):\n            for key in val.keys():\n                if self._is_unsafe(val[key]):\n                    return True\n        elif isinstance(val, list):\n            for item in val:\n                if self._is_unsafe(item):\n                    return True\n        elif getattr(val, '__UNSAFE__', False) is True:\n            return True\n        return False\n\n    def _update_unsafe(self, val):\n        if val is not None and not self.unsafe and self._is_unsafe(val):\n            self.unsafe = True\n\n    def resolve(self, key):\n        '''\n        The intercepted resolve(), which uses the helper above to set the\n        internal flag whenever an unsafe variable value is returned.\n        '''\n        val = super(AnsibleContext, self).resolve(key)\n        self._update_unsafe(val)\n        return val\n\n    def resolve_or_missing(self, key):\n        val = super(AnsibleContext, self).resolve_or_missing(key)\n        self._update_unsafe(val)\n        return val\n\n    def get_all(self):\n        \"\"\"Return the complete context as a dict including the exported\n        variables. For optimizations reasons this might not return an\n        actual copy so be careful with using it.\n\n        This is to prevent from running ``AnsibleJ2Vars`` through dict():\n\n            ``dict(self.parent, **self.vars)``\n\n        In Ansible this means that ALL variables would be templated in the\n        process of re-creating the parent because ``AnsibleJ2Vars`` templates\n        each variable in its ``__getitem__`` method. Instead we re-create the\n        parent via ``AnsibleJ2Vars.add_locals`` that creates a new\n        ``AnsibleJ2Vars`` copy without templating each variable.\n\n        This will prevent unnecessarily templating unused variables in cases\n        like setting a local variable and passing it to {% include %}\n        in a template.\n\n        Also see ``AnsibleJ2Template``and\n        https://github.com/pallets/jinja/commit/d67f0fd4cc2a4af08f51f4466150d49da7798729\n        \"\"\"\n        if LooseVersion(j2_version) >= LooseVersion('2.9'):\n            if not self.vars:\n                return self.parent\n            if not self.parent:\n                return self.vars\n\n        if isinstance(self.parent, AnsibleJ2Vars):\n            return self.parent.add_locals(self.vars)\n        else:\n            # can this happen in Ansible?\n            return dict(self.parent, **self.vars)\n\n\nclass JinjaPluginIntercept(MutableMapping):\n    def __init__(self, delegatee, pluginloader, jinja2_native, *args, **kwargs):\n        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)\n        self._delegatee = delegatee\n        self._pluginloader = pluginloader\n        self._jinja2_native = jinja2_native\n\n        if self._pluginloader.class_name == 'FilterModule':\n            self._method_map_name = 'filters'\n            self._dirname = 'filter'\n        elif self._pluginloader.class_name == 'TestModule':\n            self._method_map_name = 'tests'\n            self._dirname = 'test'\n\n        self._collection_jinja_func_cache = {}\n\n        self._ansible_plugins_loaded = False\n\n    def _load_ansible_plugins(self):\n        if self._ansible_plugins_loaded:\n            return\n\n        for plugin in self._pluginloader.all():\n            try:\n                method_map = getattr(plugin, self._method_map_name)\n                self._delegatee.update(method_map())\n            except Exception as e:\n                display.warning(\"Skipping %s plugin %s as it seems to be invalid: %r\" % (self._dirname, to_text(plugin._original_path), e))\n                continue\n\n        if self._pluginloader.class_name == 'FilterModule':\n            for plugin_name, plugin in self._delegatee.items():\n                if self._jinja2_native and plugin_name in C.STRING_TYPE_FILTERS:\n                    self._delegatee[plugin_name] = _wrap_native_text(plugin)\n                else:\n                    self._delegatee[plugin_name] = _unroll_iterator(plugin)\n\n        self._ansible_plugins_loaded = True\n\n    # FUTURE: we can cache FQ filter/test calls for the entire duration of a run, since a given collection's impl's\n    # aren't supposed to change during a run\n    def __getitem__(self, key):\n        self._load_ansible_plugins()\n\n        try:\n            if not isinstance(key, string_types):\n                raise ValueError('key must be a string')\n\n            key = to_native(key)\n\n            if '.' not in key:  # might be a built-in or legacy, check the delegatee dict first, then try for a last-chance base redirect\n                func = self._delegatee.get(key)\n\n                if func:\n                    return func\n\n                # didn't find it in the pre-built Jinja env, assume it's a former builtin and follow the normal routing path\n                leaf_key = key\n                key = 'ansible.builtin.' + key\n            else:\n                leaf_key = key.split('.')[-1]\n\n            acr = AnsibleCollectionRef.try_parse_fqcr(key, self._dirname)\n\n            if not acr:\n                raise KeyError('invalid plugin name: {0}'.format(key))\n\n            ts = _get_collection_metadata(acr.collection)\n\n            # TODO: implement support for collection-backed redirect (currently only builtin)\n            # TODO: implement cycle detection (unified across collection redir as well)\n\n            routing_entry = ts.get('plugin_routing', {}).get(self._dirname, {}).get(leaf_key, {})\n\n            deprecation_entry = routing_entry.get('deprecation')\n            if deprecation_entry:\n                warning_text = deprecation_entry.get('warning_text')\n                removal_date = deprecation_entry.get('removal_date')\n                removal_version = deprecation_entry.get('removal_version')\n\n                if not warning_text:\n                    warning_text = '{0} \"{1}\" is deprecated'.format(self._dirname, key)\n\n                display.deprecated(warning_text, version=removal_version, date=removal_date, collection_name=acr.collection)\n\n            tombstone_entry = routing_entry.get('tombstone')\n\n            if tombstone_entry:\n                warning_text = tombstone_entry.get('warning_text')\n                removal_date = tombstone_entry.get('removal_date')\n                removal_version = tombstone_entry.get('removal_version')\n\n                if not warning_text:\n                    warning_text = '{0} \"{1}\" has been removed'.format(self._dirname, key)\n\n                exc_msg = display.get_deprecation_message(warning_text, version=removal_version, date=removal_date,\n                                                          collection_name=acr.collection, removed=True)\n\n                raise AnsiblePluginRemovedError(exc_msg)\n\n            redirect_fqcr = routing_entry.get('redirect', None)\n            if redirect_fqcr:\n                acr = AnsibleCollectionRef.from_fqcr(ref=redirect_fqcr, ref_type=self._dirname)\n                display.vvv('redirecting {0} {1} to {2}.{3}'.format(self._dirname, key, acr.collection, acr.resource))\n                key = redirect_fqcr\n            # TODO: handle recursive forwarding (not necessary for builtin, but definitely for further collection redirs)\n\n            func = self._collection_jinja_func_cache.get(key)\n\n            if func:\n                return func\n\n            try:\n                pkg = import_module(acr.n_python_package_name)\n            except ImportError:\n                raise KeyError()\n\n            parent_prefix = acr.collection\n\n            if acr.subdirs:\n                parent_prefix = '{0}.{1}'.format(parent_prefix, acr.subdirs)\n\n            # TODO: implement collection-level redirect\n\n            for dummy, module_name, ispkg in pkgutil.iter_modules(pkg.__path__, prefix=parent_prefix + '.'):\n                if ispkg:\n                    continue\n\n                try:\n                    plugin_impl = self._pluginloader.get(module_name)\n                except Exception as e:\n                    raise TemplateSyntaxError(to_native(e), 0)\n\n                method_map = getattr(plugin_impl, self._method_map_name)\n\n                try:\n                    func_items = iteritems(method_map())\n                except Exception as e:\n                    display.warning(\n                        \"Skipping %s plugin %s as it seems to be invalid: %r\" % (self._dirname, to_text(plugin_impl._original_path), e),\n                    )\n                    continue\n\n                for func_name, func in func_items:\n                    fq_name = '.'.join((parent_prefix, func_name))\n                    # FIXME: detect/warn on intra-collection function name collisions\n                    if self._pluginloader.class_name == 'FilterModule':\n                        if self._jinja2_native and fq_name.startswith(('ansible.builtin.', 'ansible.legacy.')) and \\\n                                func_name in C.STRING_TYPE_FILTERS:\n                            self._collection_jinja_func_cache[fq_name] = _wrap_native_text(func)\n                        else:\n                            self._collection_jinja_func_cache[fq_name] = _unroll_iterator(func)\n                    else:\n                        self._collection_jinja_func_cache[fq_name] = func\n\n            function_impl = self._collection_jinja_func_cache[key]\n            return function_impl\n        except AnsiblePluginRemovedError as apre:\n            raise TemplateSyntaxError(to_native(apre), 0)\n        except KeyError:\n            raise\n        except Exception as ex:\n            display.warning('an unexpected error occurred during Jinja2 environment setup: {0}'.format(to_native(ex)))\n            display.vvv('exception during Jinja2 environment setup: {0}'.format(format_exc()))\n            raise TemplateSyntaxError(to_native(ex), 0)\n\n    def __setitem__(self, key, value):\n        return self._delegatee.__setitem__(key, value)\n\n    def __delitem__(self, key):\n        raise NotImplementedError()\n\n    def __iter__(self):\n        # not strictly accurate since we're not counting dynamically-loaded values\n        return iter(self._delegatee)\n\n    def __len__(self):\n        # not strictly accurate since we're not counting dynamically-loaded values\n        return len(self._delegatee)\n\n\nclass AnsibleEnvironment(Environment):\n    '''\n    Our custom environment, which simply allows us to override the class-level\n    values for the Template and Context classes used by jinja2 internally.\n\n    NOTE: Any changes to this class must be reflected in\n          :class:`AnsibleNativeEnvironment` as well.\n    '''\n    context_class = AnsibleContext\n    template_class = AnsibleJ2Template\n\n    def __init__(self, *args, **kwargs):\n        super(AnsibleEnvironment, self).__init__(*args, **kwargs)\n\n        self.filters = JinjaPluginIntercept(self.filters, filter_loader, jinja2_native=False)\n        self.tests = JinjaPluginIntercept(self.tests, test_loader, jinja2_native=False)\n\n\nif USE_JINJA2_NATIVE:\n    class AnsibleNativeEnvironment(NativeEnvironment):\n        '''\n        Our custom environment, which simply allows us to override the class-level\n        values for the Template and Context classes used by jinja2 internally.\n\n        NOTE: Any changes to this class must be reflected in\n              :class:`AnsibleEnvironment` as well.\n        '''\n        context_class = AnsibleContext\n        template_class = AnsibleJ2Template\n\n        def __init__(self, *args, **kwargs):\n            super(AnsibleNativeEnvironment, self).__init__(*args, **kwargs)\n\n            self.filters = JinjaPluginIntercept(self.filters, filter_loader, jinja2_native=True)\n            self.tests = JinjaPluginIntercept(self.tests, test_loader, jinja2_native=True)\n\n\nclass Templar:\n    '''\n    The main class for templating, with the main entry-point of template().\n    '''\n\n    def __init__(self, loader, shared_loader_obj=None, variables=None):\n        # NOTE shared_loader_obj is deprecated, ansible.plugins.loader is used\n        # directly. Keeping the arg for now in case 3rd party code \"uses\" it.\n        self._loader = loader\n        self._filters = None\n        self._tests = None\n        self._available_variables = {} if variables is None else variables\n        self._cached_result = {}\n        self._basedir = loader.get_basedir() if loader else './'\n\n        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR\n\n        environment_class = AnsibleNativeEnvironment if USE_JINJA2_NATIVE else AnsibleEnvironment\n\n        self.environment = environment_class(\n            trim_blocks=True,\n            undefined=AnsibleUndefined,\n            extensions=self._get_extensions(),\n            finalize=self._finalize,\n            loader=FileSystemLoader(self._basedir),\n        )\n\n        # jinja2 global is inconsistent across versions, this normalizes them\n        self.environment.globals['dict'] = dict\n\n        # Custom globals\n        self.environment.globals['lookup'] = self._lookup\n        self.environment.globals['query'] = self.environment.globals['q'] = self._query_lookup\n        self.environment.globals['now'] = self._now_datetime\n        self.environment.globals['finalize'] = self._finalize\n\n        # the current rendering context under which the templar class is working\n        self.cur_context = None\n\n        # FIXME these regular expressions should be re-compiled each time variable_start_string and variable_end_string are changed\n        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))\n        self._no_type_regex = re.compile(r'.*?\\|\\s*(?:%s)(?:\\([^\\|]*\\))?\\s*\\)?\\s*(?:%s)' %\n                                         ('|'.join(C.STRING_TYPE_FILTERS), self.environment.variable_end_string))\n\n    @property\n    def jinja2_native(self):\n        return not isinstance(self.environment, AnsibleEnvironment)\n\n    def copy_with_new_env(self, environment_class=AnsibleEnvironment, **kwargs):\n        r\"\"\"Creates a new copy of Templar with a new environment. The new environment is based on\n        given environment class and kwargs.\n\n        :kwarg environment_class: Environment class used for creating a new environment.\n        :kwarg \\*\\*kwargs: Optional arguments for the new environment that override existing\n            environment attributes.\n\n        :returns: Copy of Templar with updated environment.\n        \"\"\"\n        # We need to use __new__ to skip __init__, mainly not to create a new\n        # environment there only to override it below\n        new_env = object.__new__(environment_class)\n        new_env.__dict__.update(self.environment.__dict__)\n\n        new_templar = object.__new__(Templar)\n        new_templar.__dict__.update(self.__dict__)\n        new_templar.environment = new_env\n\n        mapping = {\n            'available_variables': new_templar,\n            'searchpath': new_env.loader,\n        }\n\n        for key, value in kwargs.items():\n            obj = mapping.get(key, new_env)\n            try:\n                if value is not None:\n                    setattr(obj, key, value)\n            except AttributeError:\n                # Ignore invalid attrs, lstrip_blocks was added in jinja2==2.7\n                pass\n\n        return new_templar\n\n    def _get_extensions(self):\n        '''\n        Return jinja2 extensions to load.\n\n        If some extensions are set via jinja_extensions in ansible.cfg, we try\n        to load them with the jinja environment.\n        '''\n\n        jinja_exts = []\n        if C.DEFAULT_JINJA2_EXTENSIONS:\n            # make sure the configuration directive doesn't contain spaces\n            # and split extensions in an array\n            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')\n\n        return jinja_exts\n\n    @property\n    def available_variables(self):\n        return self._available_variables\n\n    @available_variables.setter\n    def available_variables(self, variables):\n        '''\n        Sets the list of template variables this Templar instance will use\n        to template things, so we don't have to pass them around between\n        internal methods. We also clear the template cache here, as the variables\n        are being changed.\n        '''\n\n        if not isinstance(variables, Mapping):\n            raise AnsibleAssertionError(\"the type of 'variables' should be a Mapping but was a %s\" % (type(variables)))\n        self._available_variables = variables\n        self._cached_result = {}\n\n    def set_available_variables(self, variables):\n        display.deprecated(\n            'set_available_variables is being deprecated. Use \"@available_variables.setter\" instead.',\n            version='2.13', collection_name='ansible.builtin'\n        )\n        self.available_variables = variables\n\n    @contextmanager\n    def set_temporary_context(self, **kwargs):\n        \"\"\"Context manager used to set temporary templating context, without having to worry about resetting\n        original values afterward\n\n        Use a keyword that maps to the attr you are setting. Applies to ``self.environment`` by default, to\n        set context on another object, it must be in ``mapping``.\n        \"\"\"\n        mapping = {\n            'available_variables': self,\n            'searchpath': self.environment.loader,\n        }\n        original = {}\n\n        for key, value in kwargs.items():\n            obj = mapping.get(key, self.environment)\n            try:\n                original[key] = getattr(obj, key)\n                if value is not None:\n                    setattr(obj, key, value)\n            except AttributeError:\n                # Ignore invalid attrs, lstrip_blocks was added in jinja2==2.7\n                pass\n\n        yield\n\n        for key in original:\n            obj = mapping.get(key, self.environment)\n            setattr(obj, key, original[key])\n\n    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,\n                 convert_data=True, static_vars=None, cache=True, disable_lookups=False):\n        '''\n        Templates (possibly recursively) any given data as input. If convert_bare is\n        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')\n        before being sent through the template engine.\n        '''\n        static_vars = [] if static_vars is None else static_vars\n\n        # Don't template unsafe variables, just return them.\n        if hasattr(variable, '__UNSAFE__'):\n            return variable\n\n        if fail_on_undefined is None:\n            fail_on_undefined = self._fail_on_undefined_errors\n\n        if convert_bare:\n            variable = self._convert_bare_variable(variable)\n\n        if isinstance(variable, string_types):\n            if not self.is_possibly_template(variable):\n                return variable\n\n            # Check to see if the string we are trying to render is just referencing a single\n            # var.  In this case we don't want to accidentally change the type of the variable\n            # to a string by using the jinja template renderer. We just want to pass it.\n            only_one = self.SINGLE_VAR.match(variable)\n            if only_one:\n                var_name = only_one.group(1)\n                if var_name in self._available_variables:\n                    resolved_val = self._available_variables[var_name]\n                    if isinstance(resolved_val, NON_TEMPLATED_TYPES):\n                        return resolved_val\n                    elif resolved_val is None:\n                        return C.DEFAULT_NULL_REPRESENTATION\n\n            # Using a cache in order to prevent template calls with already templated variables\n            sha1_hash = None\n            if cache:\n                variable_hash = sha1(text_type(variable).encode('utf-8'))\n                options_hash = sha1(\n                    (\n                        text_type(preserve_trailing_newlines) +\n                        text_type(escape_backslashes) +\n                        text_type(fail_on_undefined) +\n                        text_type(overrides)\n                    ).encode('utf-8')\n                )\n                sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()\n\n                if sha1_hash in self._cached_result:\n                    return self._cached_result[sha1_hash]\n\n            result = self.do_template(\n                variable,\n                preserve_trailing_newlines=preserve_trailing_newlines,\n                escape_backslashes=escape_backslashes,\n                fail_on_undefined=fail_on_undefined,\n                overrides=overrides,\n                disable_lookups=disable_lookups,\n            )\n\n            if not self.jinja2_native:\n                unsafe = hasattr(result, '__UNSAFE__')\n                if convert_data and not self._no_type_regex.match(variable):\n                    # if this looks like a dictionary or list, convert it to such using the safe_eval method\n                    if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\\n                            result.startswith(\"[\") or result in (\"True\", \"False\"):\n                        eval_results = safe_eval(result, include_exceptions=True)\n                        if eval_results[1] is None:\n                            result = eval_results[0]\n                            if unsafe:\n                                result = wrap_var(result)\n                        # FIXME: if the safe_eval raised an error, should we do something with it?\n\n            # we only cache in the case where we have a single variable\n            # name, to make sure we're not putting things which may otherwise\n            # be dynamic in the cache (filters, lookups, etc.)\n            if cache and only_one:\n                self._cached_result[sha1_hash] = result\n\n            return result\n\n        elif is_sequence(variable):\n            return [self.template(\n                v,\n                preserve_trailing_newlines=preserve_trailing_newlines,\n                fail_on_undefined=fail_on_undefined,\n                overrides=overrides,\n                disable_lookups=disable_lookups,\n            ) for v in variable]\n        elif isinstance(variable, Mapping):\n            d = {}\n            # we don't use iteritems() here to avoid problems if the underlying dict\n            # changes sizes due to the templating, which can happen with hostvars\n            for k in variable.keys():\n                if k not in static_vars:\n                    d[k] = self.template(\n                        variable[k],\n                        preserve_trailing_newlines=preserve_trailing_newlines,\n                        fail_on_undefined=fail_on_undefined,\n                        overrides=overrides,\n                        disable_lookups=disable_lookups,\n                    )\n                else:\n                    d[k] = variable[k]\n            return d\n        else:\n            return variable\n\n    def is_template(self, data):\n        '''lets us know if data has a template'''\n        if isinstance(data, string_types):\n            return is_template(data, self.environment)\n        elif isinstance(data, (list, tuple)):\n            for v in data:\n                if self.is_template(v):\n                    return True\n        elif isinstance(data, dict):\n            for k in data:\n                if self.is_template(k) or self.is_template(data[k]):\n                    return True\n        return False\n\n    templatable = is_template\n\n    def is_possibly_template(self, data):\n        '''Determines if a string looks like a template, by seeing if it\n        contains a jinja2 start delimiter. Does not guarantee that the string\n        is actually a template.\n\n        This is different than ``is_template`` which is more strict.\n        This method may return ``True`` on a string that is not templatable.\n\n        Useful when guarding passing a string for templating, but when\n        you want to allow the templating engine to make the final\n        assessment which may result in ``TemplateSyntaxError``.\n        '''\n        env = self.environment\n        if isinstance(data, string_types):\n            for marker in (env.block_start_string, env.variable_start_string, env.comment_start_string):\n                if marker in data:\n                    return True\n        return False\n\n    def _convert_bare_variable(self, variable):\n        '''\n        Wraps a bare string, which may have an attribute portion (ie. foo.bar)\n        in jinja2 variable braces so that it is evaluated properly.\n        '''\n\n        if isinstance(variable, string_types):\n            contains_filters = \"|\" in variable\n            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]\n            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:\n                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)\n\n        # the variable didn't meet the conditions to be converted,\n        # so just return it as-is\n        return variable\n\n    def _finalize(self, thing):\n        '''\n        A custom finalize method for jinja2, which prevents None from being returned. This\n        avoids a string of ``\"None\"`` as ``None`` has no importance in YAML.\n\n        If using ANSIBLE_JINJA2_NATIVE we bypass this and return the actual value always\n        '''\n        if _is_rolled(thing):\n            # Auto unroll a generator, so that users are not required to\n            # explicitly use ``|list`` to unroll\n            # This only affects the scenario where the final result of templating\n            # is a generator, and not where a filter creates a generator in the middle\n            # of a template. See ``_unroll_iterator`` for the other case. This is probably\n            # unncessary\n            return list(thing)\n\n        if self.jinja2_native:\n            return thing\n\n        return thing if thing is not None else ''\n\n    def _fail_lookup(self, name, *args, **kwargs):\n        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)\n\n    def _now_datetime(self, utc=False, fmt=None):\n        '''jinja2 global function to return current datetime, potentially formatted via strftime'''\n        if utc:\n            now = datetime.datetime.utcnow()\n        else:\n            now = datetime.datetime.now()\n\n        if fmt:\n            return now.strftime(fmt)\n\n        return now\n\n    def _query_lookup(self, name, *args, **kwargs):\n        ''' wrapper for lookup, force wantlist true'''\n        kwargs['wantlist'] = True\n        return self._lookup(name, *args, **kwargs)\n\n    def _lookup(self, name, *args, **kwargs):\n        instance = lookup_loader.get(name, loader=self._loader, templar=self)\n\n        if instance is None:\n            raise AnsibleError(\"lookup plugin (%s) not found\" % name)\n\n        wantlist = kwargs.pop('wantlist', False)\n        allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)\n        errors = kwargs.pop('errors', 'strict')\n\n        loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)\n        # safely catch run failures per #5059\n        try:\n            ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)\n        except (AnsibleUndefinedVariable, UndefinedError) as e:\n            raise AnsibleUndefinedVariable(e)\n        except AnsibleOptionsError as e:\n            # invalid options given to lookup, just reraise\n            raise e\n        except AnsibleLookupError as e:\n            # lookup handled error but still decided to bail\n            msg = 'Lookup failed but the error is being ignored: %s' % to_native(e)\n            if errors == 'warn':\n                display.warning(msg)\n            elif errors == 'ignore':\n                display.display(msg, log_only=True)\n            else:\n                raise e\n            return [] if wantlist else None\n        except Exception as e:\n            # errors not handled by lookup\n            msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\\n                  (name, type(e), to_text(e))\n            if errors == 'warn':\n                display.warning(msg)\n            elif errors == 'ignore':\n                display.display(msg, log_only=True)\n            else:\n                display.vvv('exception during Jinja2 execution: {0}'.format(format_exc()))\n                raise AnsibleError(to_native(msg), orig_exc=e)\n            return [] if wantlist else None\n\n        if ran and allow_unsafe is False:\n            if self.cur_context:\n                self.cur_context.unsafe = True\n\n            if wantlist:\n                return wrap_var(ran)\n\n            try:\n                if self.jinja2_native and isinstance(ran[0], NativeJinjaText):\n                    ran = wrap_var(NativeJinjaText(\",\".join(ran)))\n                else:\n                    ran = wrap_var(\",\".join(ran))\n            except TypeError:\n                # Lookup Plugins should always return lists.  Throw an error if that's not\n                # the case:\n                if not isinstance(ran, Sequence):\n                    raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"\n                                       % name)\n\n                # The TypeError we can recover from is when the value *inside* of the list\n                # is not a string\n                if len(ran) == 1:\n                    ran = wrap_var(ran[0])\n                else:\n                    ran = wrap_var(ran)\n\n        return ran\n\n    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):\n        if self.jinja2_native and not isinstance(data, string_types):\n            return data\n\n        # For preserving the number of input newlines in the output (used\n        # later in this method)\n        data_newlines = _count_newlines_from_end(data)\n\n        if fail_on_undefined is None:\n            fail_on_undefined = self._fail_on_undefined_errors\n\n        try:\n            # allows template header overrides to change jinja2 options.\n            if overrides is None:\n                myenv = self.environment\n            else:\n                myenv = self.environment.overlay(overrides)\n\n            # Get jinja env overrides from template\n            if hasattr(data, 'startswith') and data.startswith(JINJA2_OVERRIDE):\n                eol = data.find('\\n')\n                line = data[len(JINJA2_OVERRIDE):eol]\n                data = data[eol + 1:]\n                for pair in line.split(','):\n                    (key, val) = pair.split(':')\n                    key = key.strip()\n                    setattr(myenv, key, ast.literal_eval(val.strip()))\n\n            if escape_backslashes:\n                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".\n                data = _escape_backslashes(data, myenv)\n\n            try:\n                t = myenv.from_string(data)\n            except TemplateSyntaxError as e:\n                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))\n            except Exception as e:\n                if 'recursion' in to_native(e):\n                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))\n                else:\n                    return data\n\n            if disable_lookups:\n                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup\n\n            jvars = AnsibleJ2Vars(self, t.globals)\n\n            self.cur_context = new_context = t.new_context(jvars, shared=True)\n            rf = t.root_render_func(new_context)\n\n            try:\n                if self.jinja2_native:\n                    res = ansible_native_concat(rf)\n                else:\n                    res = j2_concat(rf)\n                unsafe = getattr(new_context, 'unsafe', False)\n                if unsafe:\n                    res = wrap_var(res)\n            except TypeError as te:\n                if 'AnsibleUndefined' in to_native(te):\n                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)\n                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)\n                    raise AnsibleUndefinedVariable(errmsg)\n                else:\n                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))\n                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)))\n\n            if self.jinja2_native and not isinstance(res, string_types):\n                return res\n\n            if preserve_trailing_newlines:\n                # The low level calls above do not preserve the newline\n                # characters at the end of the input data, so we use the\n                # calculate the difference in newlines and append them\n                # to the resulting output for parity\n                #\n                # jinja2 added a keep_trailing_newline option in 2.7 when\n                # creating an Environment.  That would let us make this code\n                # better (remove a single newline if\n                # preserve_trailing_newlines is False).  Once we can depend on\n                # that version being present, modify our code to set that when\n                # initializing self.environment and remove a single trailing\n                # newline here if preserve_newlines is False.\n                res_newlines = _count_newlines_from_end(res)\n                if data_newlines > res_newlines:\n                    res += self.environment.newline_sequence * (data_newlines - res_newlines)\n                    if unsafe:\n                        res = wrap_var(res)\n            return res\n        except (UndefinedError, AnsibleUndefinedVariable) as e:\n            if fail_on_undefined:\n                raise AnsibleUndefinedVariable(e)\n            else:\n                display.debug(\"Ignoring undefined failure: %s\" % to_text(e))\n                return data\n\n    # for backwards compatibility in case anyone is using old private method directly\n    _do_template = do_template\n", "code_before": "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# Make coding more python3-ish\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport ast\nimport datetime\nimport os\nimport pkgutil\nimport pwd\nimport re\nimport time\n\nfrom contextlib import contextmanager\nfrom ansible.module_utils.compat.version import LooseVersion\nfrom numbers import Number\nfrom traceback import format_exc\n\ntry:\n    from hashlib import sha1\nexcept ImportError:\n    from sha import sha as sha1\n\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\nfrom jinja2.loaders import FileSystemLoader\nfrom jinja2.runtime import Context, StrictUndefined\n\nfrom ansible import constants as C\nfrom ansible.errors import (\n    AnsibleAssertionError,\n    AnsibleError,\n    AnsibleFilterError,\n    AnsibleLookupError,\n    AnsibleOptionsError,\n    AnsiblePluginRemovedError,\n    AnsibleUndefinedVariable,\n)\nfrom ansible.module_utils.six import iteritems, string_types, text_type\nfrom ansible.module_utils.six.moves import range\nfrom ansible.module_utils._text import to_native, to_text, to_bytes\nfrom ansible.module_utils.common._collections_compat import Iterator, Sequence, Mapping, MappingView, MutableMapping\nfrom ansible.module_utils.common.collections import is_sequence\nfrom ansible.module_utils.compat.importlib import import_module\nfrom ansible.plugins.loader import filter_loader, lookup_loader, test_loader\nfrom ansible.template.safe_eval import safe_eval\nfrom ansible.template.template import AnsibleJ2Template\nfrom ansible.template.vars import AnsibleJ2Vars\nfrom ansible.utils.collection_loader import AnsibleCollectionRef\nfrom ansible.utils.display import Display\nfrom ansible.utils.collection_loader._collection_finder import _get_collection_metadata\nfrom ansible.utils.listify import listify_lookup_plugin_terms\nfrom ansible.utils.unsafe_proxy import wrap_var\n\ndisplay = Display()\n\n\n__all__ = ['Templar', 'generate_ansible_template_vars']\n\n# A regex for checking to see if a variable we're trying to\n# expand is just a single variable name.\n\n# Primitive Types which we don't want Jinja to convert to strings.\nNON_TEMPLATED_TYPES = (bool, Number)\n\nJINJA2_OVERRIDE = '#jinja2:'\n\nfrom jinja2 import __version__ as j2_version\nfrom jinja2 import Environment\nfrom jinja2.utils import concat as j2_concat\n\n\nUSE_JINJA2_NATIVE = False\nif C.DEFAULT_JINJA2_NATIVE:\n    try:\n        from jinja2.nativetypes import NativeEnvironment\n        from ansible.template.native_helpers import ansible_native_concat\n        from ansible.utils.native_jinja import NativeJinjaText\n        USE_JINJA2_NATIVE = True\n    except ImportError:\n        from jinja2 import Environment\n        from jinja2.utils import concat as j2_concat\n        display.warning(\n            'jinja2_native requires Jinja 2.10 and above. '\n            'Version detected: %s. Falling back to default.' % j2_version\n        )\n\n\nJINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))\nJINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))\n\n\nRANGE_TYPE = type(range(0))\n\n\ndef generate_ansible_template_vars(path, fullpath=None, dest_path=None):\n\n    if fullpath is None:\n        b_path = to_bytes(path)\n    else:\n        b_path = to_bytes(fullpath)\n\n    try:\n        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name\n    except (KeyError, TypeError):\n        template_uid = os.stat(b_path).st_uid\n\n    temp_vars = {\n        'template_host': to_text(os.uname()[1]),\n        'template_path': path,\n        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),\n        'template_uid': to_text(template_uid),\n        'template_run_date': datetime.datetime.now(),\n        'template_destpath': to_native(dest_path) if dest_path else None,\n    }\n\n    if fullpath is None:\n        temp_vars['template_fullpath'] = os.path.abspath(path)\n    else:\n        temp_vars['template_fullpath'] = fullpath\n\n    managed_default = C.DEFAULT_MANAGED_STR\n    managed_str = managed_default.format(\n        host=temp_vars['template_host'],\n        uid=temp_vars['template_uid'],\n        file=temp_vars['template_path'],\n    )\n    temp_vars['ansible_managed'] = to_text(time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path))))\n\n    return temp_vars\n\n\ndef _escape_backslashes(data, jinja_env):\n    \"\"\"Double backslashes within jinja2 expressions\n\n    A user may enter something like this in a playbook::\n\n      debug:\n        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"\n\n    The string inside of the {{ gets interpreted multiple times First by yaml.\n    Then by python.  And finally by jinja2 as part of it's variable.  Because\n    it is processed by both python and jinja2, the backslash escaped\n    characters get unescaped twice.  This means that we'd normally have to use\n    four backslashes to escape that.  This is painful for playbook authors as\n    they have to remember different rules for inside vs outside of a jinja2\n    expression (The backslashes outside of the \"{{ }}\" only get processed by\n    yaml and python.  So they only need to be escaped once).  The following\n    code fixes this by automatically performing the extra quoting of\n    backslashes inside of a jinja2 expression.\n\n    \"\"\"\n    if '\\\\' in data and '{{' in data:\n        new_data = []\n        d2 = jinja_env.preprocess(data)\n        in_var = False\n\n        for token in jinja_env.lex(d2):\n            if token[1] == 'variable_begin':\n                in_var = True\n                new_data.append(token[2])\n            elif token[1] == 'variable_end':\n                in_var = False\n                new_data.append(token[2])\n            elif in_var and token[1] == 'string':\n                # Double backslashes only if we're inside of a jinja2 variable\n                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))\n            else:\n                new_data.append(token[2])\n\n        data = ''.join(new_data)\n\n    return data\n\n\ndef is_template(data, jinja_env):\n    \"\"\"This function attempts to quickly detect whether a value is a jinja2\n    template. To do so, we look for the first 2 matching jinja2 tokens for\n    start and end delimiters.\n    \"\"\"\n    found = None\n    start = True\n    comment = False\n    d2 = jinja_env.preprocess(data)\n\n    # This wraps a lot of code, but this is due to lex returning a generator\n    # so we may get an exception at any part of the loop\n    try:\n        for token in jinja_env.lex(d2):\n            if token[1] in JINJA2_BEGIN_TOKENS:\n                if start and token[1] == 'comment_begin':\n                    # Comments can wrap other token types\n                    comment = True\n                start = False\n                # Example: variable_end -> variable\n                found = token[1].split('_')[0]\n            elif token[1] in JINJA2_END_TOKENS:\n                if token[1].split('_')[0] == found:\n                    return True\n                elif comment:\n                    continue\n                return False\n    except TemplateSyntaxError:\n        return False\n\n    return False\n\n\ndef _count_newlines_from_end(in_str):\n    '''\n    Counts the number of newlines at the end of a string. This is used during\n    the jinja2 templating to ensure the count matches the input, since some newlines\n    may be thrown away during the templating.\n    '''\n\n    try:\n        i = len(in_str)\n        j = i - 1\n        while in_str[j] == '\\n':\n            j -= 1\n        return i - 1 - j\n    except IndexError:\n        # Uncommon cases: zero length string and string containing only newlines\n        return i\n\n\ndef recursive_check_defined(item):\n    from jinja2.runtime import Undefined\n\n    if isinstance(item, MutableMapping):\n        for key in item:\n            recursive_check_defined(item[key])\n    elif isinstance(item, list):\n        for i in item:\n            recursive_check_defined(i)\n    else:\n        if isinstance(item, Undefined):\n            raise AnsibleFilterError(\"{0} is undefined\".format(item))\n\n\ndef _is_rolled(value):\n    \"\"\"Helper method to determine if something is an unrolled generator,\n    iterator, or similar object\n    \"\"\"\n    return (\n        isinstance(value, Iterator) or\n        isinstance(value, MappingView) or\n        isinstance(value, RANGE_TYPE)\n    )\n\n\ndef _unroll_iterator(func):\n    \"\"\"Wrapper function, that intercepts the result of a filter\n    and auto unrolls a generator, so that users are not required to\n    explicitly use ``|list`` to unroll.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if _is_rolled(ret):\n            return list(ret)\n        return ret\n\n    return _update_wrapper(wrapper, func)\n\n\ndef _update_wrapper(wrapper, func):\n    # This code is duplicated from ``functools.update_wrapper`` from Py3.7.\n    # ``functools.update_wrapper`` was failing when the func was ``functools.partial``\n    for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n        try:\n            value = getattr(func, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in ('__dict__',):\n        getattr(wrapper, attr).update(getattr(func, attr, {}))\n    wrapper.__wrapped__ = func\n    return wrapper\n\n\ndef _wrap_native_text(func):\n    \"\"\"Wrapper function, that intercepts the result of a filter\n    and wraps it into NativeJinjaText which is then used\n    in ``ansible_native_concat`` to indicate that it is a text\n    which should not be passed into ``literal_eval``.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        return NativeJinjaText(ret)\n\n    return _update_wrapper(wrapper, func)\n\n\nclass AnsibleUndefined(StrictUndefined):\n    '''\n    A custom Undefined class, which returns further Undefined objects on access,\n    rather than throwing an exception.\n    '''\n    def __getattr__(self, name):\n        if name == '__UNSAFE__':\n            # AnsibleUndefined should never be assumed to be unsafe\n            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``\n            raise AttributeError(name)\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n    def __getitem__(self, key):\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n    def __repr__(self):\n        return 'AnsibleUndefined'\n\n    def __contains__(self, item):\n        # Return original Undefined object to preserve the first failure context\n        return self\n\n\nclass AnsibleContext(Context):\n    '''\n    A custom context, which intercepts resolve() calls and sets a flag\n    internally if any variable lookup returns an AnsibleUnsafe value. This\n    flag is checked post-templating, and (when set) will result in the\n    final templated result being wrapped in AnsibleUnsafe.\n    '''\n    def __init__(self, *args, **kwargs):\n        super(AnsibleContext, self).__init__(*args, **kwargs)\n        self.unsafe = False\n\n    def _is_unsafe(self, val):\n        '''\n        Our helper function, which will also recursively check dict and\n        list entries due to the fact that they may be repr'd and contain\n        a key or value which contains jinja2 syntax and would otherwise\n        lose the AnsibleUnsafe value.\n        '''\n        if isinstance(val, dict):\n            for key in val.keys():\n                if self._is_unsafe(val[key]):\n                    return True\n        elif isinstance(val, list):\n            for item in val:\n                if self._is_unsafe(item):\n                    return True\n        elif getattr(val, '__UNSAFE__', False) is True:\n            return True\n        return False\n\n    def _update_unsafe(self, val):\n        if val is not None and not self.unsafe and self._is_unsafe(val):\n            self.unsafe = True\n\n    def resolve(self, key):\n        '''\n        The intercepted resolve(), which uses the helper above to set the\n        internal flag whenever an unsafe variable value is returned.\n        '''\n        val = super(AnsibleContext, self).resolve(key)\n        self._update_unsafe(val)\n        return val\n\n    def resolve_or_missing(self, key):\n        val = super(AnsibleContext, self).resolve_or_missing(key)\n        self._update_unsafe(val)\n        return val\n\n    def get_all(self):\n        \"\"\"Return the complete context as a dict including the exported\n        variables. For optimizations reasons this might not return an\n        actual copy so be careful with using it.\n\n        This is to prevent from running ``AnsibleJ2Vars`` through dict():\n\n            ``dict(self.parent, **self.vars)``\n\n        In Ansible this means that ALL variables would be templated in the\n        process of re-creating the parent because ``AnsibleJ2Vars`` templates\n        each variable in its ``__getitem__`` method. Instead we re-create the\n        parent via ``AnsibleJ2Vars.add_locals`` that creates a new\n        ``AnsibleJ2Vars`` copy without templating each variable.\n\n        This will prevent unnecessarily templating unused variables in cases\n        like setting a local variable and passing it to {% include %}\n        in a template.\n\n        Also see ``AnsibleJ2Template``and\n        https://github.com/pallets/jinja/commit/d67f0fd4cc2a4af08f51f4466150d49da7798729\n        \"\"\"\n        if LooseVersion(j2_version) >= LooseVersion('2.9'):\n            if not self.vars:\n                return self.parent\n            if not self.parent:\n                return self.vars\n\n        if isinstance(self.parent, AnsibleJ2Vars):\n            return self.parent.add_locals(self.vars)\n        else:\n            # can this happen in Ansible?\n            return dict(self.parent, **self.vars)\n\n\nclass JinjaPluginIntercept(MutableMapping):\n    def __init__(self, delegatee, pluginloader, jinja2_native, *args, **kwargs):\n        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)\n        self._delegatee = delegatee\n        self._pluginloader = pluginloader\n        self._jinja2_native = jinja2_native\n\n        if self._pluginloader.class_name == 'FilterModule':\n            self._method_map_name = 'filters'\n            self._dirname = 'filter'\n        elif self._pluginloader.class_name == 'TestModule':\n            self._method_map_name = 'tests'\n            self._dirname = 'test'\n\n        self._collection_jinja_func_cache = {}\n\n        self._ansible_plugins_loaded = False\n\n    def _load_ansible_plugins(self):\n        if self._ansible_plugins_loaded:\n            return\n\n        for plugin in self._pluginloader.all():\n            try:\n                method_map = getattr(plugin, self._method_map_name)\n                self._delegatee.update(method_map())\n            except Exception as e:\n                display.warning(\"Skipping %s plugin %s as it seems to be invalid: %r\" % (self._dirname, to_text(plugin._original_path), e))\n                continue\n\n        if self._pluginloader.class_name == 'FilterModule':\n            for plugin_name, plugin in self._delegatee.items():\n                if self._jinja2_native and plugin_name in C.STRING_TYPE_FILTERS:\n                    self._delegatee[plugin_name] = _wrap_native_text(plugin)\n                else:\n                    self._delegatee[plugin_name] = _unroll_iterator(plugin)\n\n        self._ansible_plugins_loaded = True\n\n    # FUTURE: we can cache FQ filter/test calls for the entire duration of a run, since a given collection's impl's\n    # aren't supposed to change during a run\n    def __getitem__(self, key):\n        self._load_ansible_plugins()\n\n        try:\n            if not isinstance(key, string_types):\n                raise ValueError('key must be a string')\n\n            key = to_native(key)\n\n            if '.' not in key:  # might be a built-in or legacy, check the delegatee dict first, then try for a last-chance base redirect\n                func = self._delegatee.get(key)\n\n                if func:\n                    return func\n\n                # didn't find it in the pre-built Jinja env, assume it's a former builtin and follow the normal routing path\n                leaf_key = key\n                key = 'ansible.builtin.' + key\n            else:\n                leaf_key = key.split('.')[-1]\n\n            acr = AnsibleCollectionRef.try_parse_fqcr(key, self._dirname)\n\n            if not acr:\n                raise KeyError('invalid plugin name: {0}'.format(key))\n\n            ts = _get_collection_metadata(acr.collection)\n\n            # TODO: implement support for collection-backed redirect (currently only builtin)\n            # TODO: implement cycle detection (unified across collection redir as well)\n\n            routing_entry = ts.get('plugin_routing', {}).get(self._dirname, {}).get(leaf_key, {})\n\n            deprecation_entry = routing_entry.get('deprecation')\n            if deprecation_entry:\n                warning_text = deprecation_entry.get('warning_text')\n                removal_date = deprecation_entry.get('removal_date')\n                removal_version = deprecation_entry.get('removal_version')\n\n                if not warning_text:\n                    warning_text = '{0} \"{1}\" is deprecated'.format(self._dirname, key)\n\n                display.deprecated(warning_text, version=removal_version, date=removal_date, collection_name=acr.collection)\n\n            tombstone_entry = routing_entry.get('tombstone')\n\n            if tombstone_entry:\n                warning_text = tombstone_entry.get('warning_text')\n                removal_date = tombstone_entry.get('removal_date')\n                removal_version = tombstone_entry.get('removal_version')\n\n                if not warning_text:\n                    warning_text = '{0} \"{1}\" has been removed'.format(self._dirname, key)\n\n                exc_msg = display.get_deprecation_message(warning_text, version=removal_version, date=removal_date,\n                                                          collection_name=acr.collection, removed=True)\n\n                raise AnsiblePluginRemovedError(exc_msg)\n\n            redirect_fqcr = routing_entry.get('redirect', None)\n            if redirect_fqcr:\n                acr = AnsibleCollectionRef.from_fqcr(ref=redirect_fqcr, ref_type=self._dirname)\n                display.vvv('redirecting {0} {1} to {2}.{3}'.format(self._dirname, key, acr.collection, acr.resource))\n                key = redirect_fqcr\n            # TODO: handle recursive forwarding (not necessary for builtin, but definitely for further collection redirs)\n\n            func = self._collection_jinja_func_cache.get(key)\n\n            if func:\n                return func\n\n            try:\n                pkg = import_module(acr.n_python_package_name)\n            except ImportError:\n                raise KeyError()\n\n            parent_prefix = acr.collection\n\n            if acr.subdirs:\n                parent_prefix = '{0}.{1}'.format(parent_prefix, acr.subdirs)\n\n            # TODO: implement collection-level redirect\n\n            for dummy, module_name, ispkg in pkgutil.iter_modules(pkg.__path__, prefix=parent_prefix + '.'):\n                if ispkg:\n                    continue\n\n                try:\n                    plugin_impl = self._pluginloader.get(module_name)\n                except Exception as e:\n                    raise TemplateSyntaxError(to_native(e), 0)\n\n                method_map = getattr(plugin_impl, self._method_map_name)\n\n                try:\n                    func_items = iteritems(method_map())\n                except Exception as e:\n                    display.warning(\n                        \"Skipping %s plugin %s as it seems to be invalid: %r\" % (self._dirname, to_text(plugin_impl._original_path), e),\n                    )\n                    continue\n\n                for func_name, func in func_items:\n                    fq_name = '.'.join((parent_prefix, func_name))\n                    # FIXME: detect/warn on intra-collection function name collisions\n                    if self._pluginloader.class_name == 'FilterModule':\n                        if self._jinja2_native and fq_name.startswith(('ansible.builtin.', 'ansible.legacy.')) and \\\n                                func_name in C.STRING_TYPE_FILTERS:\n                            self._collection_jinja_func_cache[fq_name] = _wrap_native_text(func)\n                        else:\n                            self._collection_jinja_func_cache[fq_name] = _unroll_iterator(func)\n                    else:\n                        self._collection_jinja_func_cache[fq_name] = func\n\n            function_impl = self._collection_jinja_func_cache[key]\n            return function_impl\n        except AnsiblePluginRemovedError as apre:\n            raise TemplateSyntaxError(to_native(apre), 0)\n        except KeyError:\n            raise\n        except Exception as ex:\n            display.warning('an unexpected error occurred during Jinja2 environment setup: {0}'.format(to_native(ex)))\n            display.vvv('exception during Jinja2 environment setup: {0}'.format(format_exc()))\n            raise TemplateSyntaxError(to_native(ex), 0)\n\n    def __setitem__(self, key, value):\n        return self._delegatee.__setitem__(key, value)\n\n    def __delitem__(self, key):\n        raise NotImplementedError()\n\n    def __iter__(self):\n        # not strictly accurate since we're not counting dynamically-loaded values\n        return iter(self._delegatee)\n\n    def __len__(self):\n        # not strictly accurate since we're not counting dynamically-loaded values\n        return len(self._delegatee)\n\n\nclass AnsibleEnvironment(Environment):\n    '''\n    Our custom environment, which simply allows us to override the class-level\n    values for the Template and Context classes used by jinja2 internally.\n\n    NOTE: Any changes to this class must be reflected in\n          :class:`AnsibleNativeEnvironment` as well.\n    '''\n    context_class = AnsibleContext\n    template_class = AnsibleJ2Template\n\n    def __init__(self, *args, **kwargs):\n        super(AnsibleEnvironment, self).__init__(*args, **kwargs)\n\n        self.filters = JinjaPluginIntercept(self.filters, filter_loader, jinja2_native=False)\n        self.tests = JinjaPluginIntercept(self.tests, test_loader, jinja2_native=False)\n\n\nif USE_JINJA2_NATIVE:\n    class AnsibleNativeEnvironment(NativeEnvironment):\n        '''\n        Our custom environment, which simply allows us to override the class-level\n        values for the Template and Context classes used by jinja2 internally.\n\n        NOTE: Any changes to this class must be reflected in\n              :class:`AnsibleEnvironment` as well.\n        '''\n        context_class = AnsibleContext\n        template_class = AnsibleJ2Template\n\n        def __init__(self, *args, **kwargs):\n            super(AnsibleNativeEnvironment, self).__init__(*args, **kwargs)\n\n            self.filters = JinjaPluginIntercept(self.filters, filter_loader, jinja2_native=True)\n            self.tests = JinjaPluginIntercept(self.tests, test_loader, jinja2_native=True)\n\n\nclass Templar:\n    '''\n    The main class for templating, with the main entry-point of template().\n    '''\n\n    def __init__(self, loader, shared_loader_obj=None, variables=None):\n        # NOTE shared_loader_obj is deprecated, ansible.plugins.loader is used\n        # directly. Keeping the arg for now in case 3rd party code \"uses\" it.\n        self._loader = loader\n        self._filters = None\n        self._tests = None\n        self._available_variables = {} if variables is None else variables\n        self._cached_result = {}\n        self._basedir = loader.get_basedir() if loader else './'\n\n        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR\n\n        environment_class = AnsibleNativeEnvironment if USE_JINJA2_NATIVE else AnsibleEnvironment\n\n        self.environment = environment_class(\n            trim_blocks=True,\n            undefined=AnsibleUndefined,\n            extensions=self._get_extensions(),\n            finalize=self._finalize,\n            loader=FileSystemLoader(self._basedir),\n        )\n\n        # jinja2 global is inconsistent across versions, this normalizes them\n        self.environment.globals['dict'] = dict\n\n        # Custom globals\n        self.environment.globals['lookup'] = self._lookup\n        self.environment.globals['query'] = self.environment.globals['q'] = self._query_lookup\n        self.environment.globals['now'] = self._now_datetime\n        self.environment.globals['finalize'] = self._finalize\n\n        # the current rendering context under which the templar class is working\n        self.cur_context = None\n\n        # FIXME these regular expressions should be re-compiled each time variable_start_string and variable_end_string are changed\n        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))\n        self._no_type_regex = re.compile(r'.*?\\|\\s*(?:%s)(?:\\([^\\|]*\\))?\\s*\\)?\\s*(?:%s)' %\n                                         ('|'.join(C.STRING_TYPE_FILTERS), self.environment.variable_end_string))\n\n    @property\n    def jinja2_native(self):\n        return not isinstance(self.environment, AnsibleEnvironment)\n\n    def copy_with_new_env(self, environment_class=AnsibleEnvironment, **kwargs):\n        r\"\"\"Creates a new copy of Templar with a new environment. The new environment is based on\n        given environment class and kwargs.\n\n        :kwarg environment_class: Environment class used for creating a new environment.\n        :kwarg \\*\\*kwargs: Optional arguments for the new environment that override existing\n            environment attributes.\n\n        :returns: Copy of Templar with updated environment.\n        \"\"\"\n        # We need to use __new__ to skip __init__, mainly not to create a new\n        # environment there only to override it below\n        new_env = object.__new__(environment_class)\n        new_env.__dict__.update(self.environment.__dict__)\n\n        new_templar = object.__new__(Templar)\n        new_templar.__dict__.update(self.__dict__)\n        new_templar.environment = new_env\n\n        mapping = {\n            'available_variables': new_templar,\n            'searchpath': new_env.loader,\n        }\n\n        for key, value in kwargs.items():\n            obj = mapping.get(key, new_env)\n            try:\n                if value is not None:\n                    setattr(obj, key, value)\n            except AttributeError:\n                # Ignore invalid attrs, lstrip_blocks was added in jinja2==2.7\n                pass\n\n        return new_templar\n\n    def _get_extensions(self):\n        '''\n        Return jinja2 extensions to load.\n\n        If some extensions are set via jinja_extensions in ansible.cfg, we try\n        to load them with the jinja environment.\n        '''\n\n        jinja_exts = []\n        if C.DEFAULT_JINJA2_EXTENSIONS:\n            # make sure the configuration directive doesn't contain spaces\n            # and split extensions in an array\n            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')\n\n        return jinja_exts\n\n    @property\n    def available_variables(self):\n        return self._available_variables\n\n    @available_variables.setter\n    def available_variables(self, variables):\n        '''\n        Sets the list of template variables this Templar instance will use\n        to template things, so we don't have to pass them around between\n        internal methods. We also clear the template cache here, as the variables\n        are being changed.\n        '''\n\n        if not isinstance(variables, Mapping):\n            raise AnsibleAssertionError(\"the type of 'variables' should be a Mapping but was a %s\" % (type(variables)))\n        self._available_variables = variables\n        self._cached_result = {}\n\n    def set_available_variables(self, variables):\n        display.deprecated(\n            'set_available_variables is being deprecated. Use \"@available_variables.setter\" instead.',\n            version='2.13', collection_name='ansible.builtin'\n        )\n        self.available_variables = variables\n\n    @contextmanager\n    def set_temporary_context(self, **kwargs):\n        \"\"\"Context manager used to set temporary templating context, without having to worry about resetting\n        original values afterward\n\n        Use a keyword that maps to the attr you are setting. Applies to ``self.environment`` by default, to\n        set context on another object, it must be in ``mapping``.\n        \"\"\"\n        mapping = {\n            'available_variables': self,\n            'searchpath': self.environment.loader,\n        }\n        original = {}\n\n        for key, value in kwargs.items():\n            obj = mapping.get(key, self.environment)\n            try:\n                original[key] = getattr(obj, key)\n                if value is not None:\n                    setattr(obj, key, value)\n            except AttributeError:\n                # Ignore invalid attrs, lstrip_blocks was added in jinja2==2.7\n                pass\n\n        yield\n\n        for key in original:\n            obj = mapping.get(key, self.environment)\n            setattr(obj, key, original[key])\n\n    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,\n                 convert_data=True, static_vars=None, cache=True, disable_lookups=False):\n        '''\n        Templates (possibly recursively) any given data as input. If convert_bare is\n        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')\n        before being sent through the template engine.\n        '''\n        static_vars = [] if static_vars is None else static_vars\n\n        # Don't template unsafe variables, just return them.\n        if hasattr(variable, '__UNSAFE__'):\n            return variable\n\n        if fail_on_undefined is None:\n            fail_on_undefined = self._fail_on_undefined_errors\n\n        if convert_bare:\n            variable = self._convert_bare_variable(variable)\n\n        if isinstance(variable, string_types):\n            if not self.is_possibly_template(variable):\n                return variable\n\n            # Check to see if the string we are trying to render is just referencing a single\n            # var.  In this case we don't want to accidentally change the type of the variable\n            # to a string by using the jinja template renderer. We just want to pass it.\n            only_one = self.SINGLE_VAR.match(variable)\n            if only_one:\n                var_name = only_one.group(1)\n                if var_name in self._available_variables:\n                    resolved_val = self._available_variables[var_name]\n                    if isinstance(resolved_val, NON_TEMPLATED_TYPES):\n                        return resolved_val\n                    elif resolved_val is None:\n                        return C.DEFAULT_NULL_REPRESENTATION\n\n            # Using a cache in order to prevent template calls with already templated variables\n            sha1_hash = None\n            if cache:\n                variable_hash = sha1(text_type(variable).encode('utf-8'))\n                options_hash = sha1(\n                    (\n                        text_type(preserve_trailing_newlines) +\n                        text_type(escape_backslashes) +\n                        text_type(fail_on_undefined) +\n                        text_type(overrides)\n                    ).encode('utf-8')\n                )\n                sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()\n\n                if sha1_hash in self._cached_result:\n                    return self._cached_result[sha1_hash]\n\n            result = self.do_template(\n                variable,\n                preserve_trailing_newlines=preserve_trailing_newlines,\n                escape_backslashes=escape_backslashes,\n                fail_on_undefined=fail_on_undefined,\n                overrides=overrides,\n                disable_lookups=disable_lookups,\n            )\n\n            if not self.jinja2_native:\n                unsafe = hasattr(result, '__UNSAFE__')\n                if convert_data and not self._no_type_regex.match(variable):\n                    # if this looks like a dictionary or list, convert it to such using the safe_eval method\n                    if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\\n                            result.startswith(\"[\") or result in (\"True\", \"False\"):\n                        eval_results = safe_eval(result, include_exceptions=True)\n                        if eval_results[1] is None:\n                            result = eval_results[0]\n                            if unsafe:\n                                result = wrap_var(result)\n                        # FIXME: if the safe_eval raised an error, should we do something with it?\n\n            # we only cache in the case where we have a single variable\n            # name, to make sure we're not putting things which may otherwise\n            # be dynamic in the cache (filters, lookups, etc.)\n            if cache and only_one:\n                self._cached_result[sha1_hash] = result\n\n            return result\n\n        elif is_sequence(variable):\n            return [self.template(\n                v,\n                preserve_trailing_newlines=preserve_trailing_newlines,\n                fail_on_undefined=fail_on_undefined,\n                overrides=overrides,\n                disable_lookups=disable_lookups,\n            ) for v in variable]\n        elif isinstance(variable, Mapping):\n            d = {}\n            # we don't use iteritems() here to avoid problems if the underlying dict\n            # changes sizes due to the templating, which can happen with hostvars\n            for k in variable.keys():\n                if k not in static_vars:\n                    d[k] = self.template(\n                        variable[k],\n                        preserve_trailing_newlines=preserve_trailing_newlines,\n                        fail_on_undefined=fail_on_undefined,\n                        overrides=overrides,\n                        disable_lookups=disable_lookups,\n                    )\n                else:\n                    d[k] = variable[k]\n            return d\n        else:\n            return variable\n\n    def is_template(self, data):\n        '''lets us know if data has a template'''\n        if isinstance(data, string_types):\n            return is_template(data, self.environment)\n        elif isinstance(data, (list, tuple)):\n            for v in data:\n                if self.is_template(v):\n                    return True\n        elif isinstance(data, dict):\n            for k in data:\n                if self.is_template(k) or self.is_template(data[k]):\n                    return True\n        return False\n\n    templatable = is_template\n\n    def is_possibly_template(self, data):\n        '''Determines if a string looks like a template, by seeing if it\n        contains a jinja2 start delimiter. Does not guarantee that the string\n        is actually a template.\n\n        This is different than ``is_template`` which is more strict.\n        This method may return ``True`` on a string that is not templatable.\n\n        Useful when guarding passing a string for templating, but when\n        you want to allow the templating engine to make the final\n        assessment which may result in ``TemplateSyntaxError``.\n        '''\n        env = self.environment\n        if isinstance(data, string_types):\n            for marker in (env.block_start_string, env.variable_start_string, env.comment_start_string):\n                if marker in data:\n                    return True\n        return False\n\n    def _convert_bare_variable(self, variable):\n        '''\n        Wraps a bare string, which may have an attribute portion (ie. foo.bar)\n        in jinja2 variable braces so that it is evaluated properly.\n        '''\n\n        if isinstance(variable, string_types):\n            contains_filters = \"|\" in variable\n            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]\n            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:\n                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)\n\n        # the variable didn't meet the conditions to be converted,\n        # so just return it as-is\n        return variable\n\n    def _finalize(self, thing):\n        '''\n        A custom finalize method for jinja2, which prevents None from being returned. This\n        avoids a string of ``\"None\"`` as ``None`` has no importance in YAML.\n\n        If using ANSIBLE_JINJA2_NATIVE we bypass this and return the actual value always\n        '''\n        if _is_rolled(thing):\n            # Auto unroll a generator, so that users are not required to\n            # explicitly use ``|list`` to unroll\n            # This only affects the scenario where the final result of templating\n            # is a generator, and not where a filter creates a generator in the middle\n            # of a template. See ``_unroll_iterator`` for the other case. This is probably\n            # unncessary\n            return list(thing)\n\n        if self.jinja2_native:\n            return thing\n\n        return thing if thing is not None else ''\n\n    def _fail_lookup(self, name, *args, **kwargs):\n        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)\n\n    def _now_datetime(self, utc=False, fmt=None):\n        '''jinja2 global function to return current datetime, potentially formatted via strftime'''\n        if utc:\n            now = datetime.datetime.utcnow()\n        else:\n            now = datetime.datetime.now()\n\n        if fmt:\n            return now.strftime(fmt)\n\n        return now\n\n    def _query_lookup(self, name, *args, **kwargs):\n        ''' wrapper for lookup, force wantlist true'''\n        kwargs['wantlist'] = True\n        return self._lookup(name, *args, **kwargs)\n\n    def _lookup(self, name, *args, **kwargs):\n        instance = lookup_loader.get(name, loader=self._loader, templar=self)\n\n        if instance is None:\n            raise AnsibleError(\"lookup plugin (%s) not found\" % name)\n\n        wantlist = kwargs.pop('wantlist', False)\n        allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)\n        errors = kwargs.pop('errors', 'strict')\n\n        loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)\n        # safely catch run failures per #5059\n        try:\n            ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)\n        except (AnsibleUndefinedVariable, UndefinedError) as e:\n            raise AnsibleUndefinedVariable(e)\n        except AnsibleOptionsError as e:\n            # invalid options given to lookup, just reraise\n            raise e\n        except AnsibleLookupError as e:\n            # lookup handled error but still decided to bail\n            msg = 'Lookup failed but the error is being ignored: %s' % to_native(e)\n            if errors == 'warn':\n                display.warning(msg)\n            elif errors == 'ignore':\n                display.display(msg, log_only=True)\n            else:\n                raise e\n            return [] if wantlist else None\n        except Exception as e:\n            # errors not handled by lookup\n            msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\\n                  (name, type(e), to_text(e))\n            if errors == 'warn':\n                display.warning(msg)\n            elif errors == 'ignore':\n                display.display(msg, log_only=True)\n            else:\n                display.vvv('exception during Jinja2 execution: {0}'.format(format_exc()))\n                raise AnsibleError(to_native(msg), orig_exc=e)\n            return [] if wantlist else None\n\n        if ran and allow_unsafe is False:\n            if self.cur_context:\n                self.cur_context.unsafe = True\n\n            if wantlist:\n                return wrap_var(ran)\n\n            try:\n                if self.jinja2_native and isinstance(ran[0], NativeJinjaText):\n                    ran = wrap_var(NativeJinjaText(\",\".join(ran)))\n                else:\n                    ran = wrap_var(\",\".join(ran))\n            except TypeError:\n                # Lookup Plugins should always return lists.  Throw an error if that's not\n                # the case:\n                if not isinstance(ran, Sequence):\n                    raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"\n                                       % name)\n\n                # The TypeError we can recover from is when the value *inside* of the list\n                # is not a string\n                if len(ran) == 1:\n                    ran = wrap_var(ran[0])\n                else:\n                    ran = wrap_var(ran)\n\n        return ran\n\n    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):\n        if self.jinja2_native and not isinstance(data, string_types):\n            return data\n\n        # For preserving the number of input newlines in the output (used\n        # later in this method)\n        data_newlines = _count_newlines_from_end(data)\n\n        if fail_on_undefined is None:\n            fail_on_undefined = self._fail_on_undefined_errors\n\n        try:\n            # allows template header overrides to change jinja2 options.\n            if overrides is None:\n                myenv = self.environment\n            else:\n                myenv = self.environment.overlay(overrides)\n\n            # Get jinja env overrides from template\n            if hasattr(data, 'startswith') and data.startswith(JINJA2_OVERRIDE):\n                eol = data.find('\\n')\n                line = data[len(JINJA2_OVERRIDE):eol]\n                data = data[eol + 1:]\n                for pair in line.split(','):\n                    (key, val) = pair.split(':')\n                    key = key.strip()\n                    setattr(myenv, key, ast.literal_eval(val.strip()))\n\n            if escape_backslashes:\n                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".\n                data = _escape_backslashes(data, myenv)\n\n            try:\n                t = myenv.from_string(data)\n            except TemplateSyntaxError as e:\n                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))\n            except Exception as e:\n                if 'recursion' in to_native(e):\n                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))\n                else:\n                    return data\n\n            if disable_lookups:\n                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup\n\n            jvars = AnsibleJ2Vars(self, t.globals)\n\n            self.cur_context = new_context = t.new_context(jvars, shared=True)\n            rf = t.root_render_func(new_context)\n\n            try:\n                if self.jinja2_native:\n                    res = ansible_native_concat(rf)\n                else:\n                    res = j2_concat(rf)\n                if getattr(new_context, 'unsafe', False):\n                    res = wrap_var(res)\n            except TypeError as te:\n                if 'AnsibleUndefined' in to_native(te):\n                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)\n                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)\n                    raise AnsibleUndefinedVariable(errmsg)\n                else:\n                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))\n                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)))\n\n            if self.jinja2_native and not isinstance(res, string_types):\n                return res\n\n            if preserve_trailing_newlines:\n                # The low level calls above do not preserve the newline\n                # characters at the end of the input data, so we use the\n                # calculate the difference in newlines and append them\n                # to the resulting output for parity\n                #\n                # jinja2 added a keep_trailing_newline option in 2.7 when\n                # creating an Environment.  That would let us make this code\n                # better (remove a single newline if\n                # preserve_trailing_newlines is False).  Once we can depend on\n                # that version being present, modify our code to set that when\n                # initializing self.environment and remove a single trailing\n                # newline here if preserve_newlines is False.\n                res_newlines = _count_newlines_from_end(res)\n                if data_newlines > res_newlines:\n                    res += self.environment.newline_sequence * (data_newlines - res_newlines)\n            return res\n        except (UndefinedError, AnsibleUndefinedVariable) as e:\n            if fail_on_undefined:\n                raise AnsibleUndefinedVariable(e)\n            else:\n                display.debug(\"Ignoring undefined failure: %s\" % to_text(e))\n                return data\n\n    # for backwards compatibility in case anyone is using old private method directly\n    _do_template = do_template\n", "patch": "@@ -1114,7 +1114,8 @@ def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=\n                     res = ansible_native_concat(rf)\n                 else:\n                     res = j2_concat(rf)\n-                if getattr(new_context, 'unsafe', False):\n+                unsafe = getattr(new_context, 'unsafe', False)\n+                if unsafe:\n                     res = wrap_var(res)\n             except TypeError as te:\n                 if 'AnsibleUndefined' in to_native(te):\n@@ -1144,6 +1145,8 @@ def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=\n                 res_newlines = _count_newlines_from_end(res)\n                 if data_newlines > res_newlines:\n                     res += self.environment.newline_sequence * (data_newlines - res_newlines)\n+                    if unsafe:\n+                        res = wrap_var(res)\n             return res\n         except (UndefinedError, AnsibleUndefinedVariable) as e:\n             if fail_on_undefined:", "file_path": "files/2021_9/82", "file_language": "py", "file_name": "lib/ansible/template/__init__.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/ansible/ansible/raw/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e/test%2Fintegration%2Ftargets%2Ftemplate%2Frunme.sh", "code": "#!/usr/bin/env bash\n\nset -eux\n\nANSIBLE_ROLES_PATH=../ ansible-playbook template.yml -i ../../inventory -v \"$@\"\n\n# Test for #35571\nansible testhost -i testhost, -m debug -a 'msg={{ hostvars[\"localhost\"] }}' -e \"vars1={{ undef }}\" -e \"vars2={{ vars1 }}\"\n\n# Test for https://github.com/ansible/ansible/issues/27262\nansible-playbook ansible_managed.yml -c  ansible_managed.cfg -i ../../inventory -v \"$@\"\n\n# Test for #42585\nANSIBLE_ROLES_PATH=../ ansible-playbook custom_template.yml -i ../../inventory -v \"$@\"\n\n\n# Test for several corner cases #57188\nansible-playbook corner_cases.yml -v \"$@\"\n\n# Test for #57351\nansible-playbook filter_plugins.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/68699\nansible-playbook unused_vars_include.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/55152\nansible-playbook undefined_var_info.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/72615\nansible-playbook 72615.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/6653\nansible-playbook 6653.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/72262\nansible-playbook 72262.yml -v \"$@\"\n\n# ensure unsafe is preserved, even with extra newlines\nansible-playbook unsafe.yml -v \"$@\"\n\n", "code_before": "#!/usr/bin/env bash\n\nset -eux\n\nANSIBLE_ROLES_PATH=../ ansible-playbook template.yml -i ../../inventory -v \"$@\"\n\n# Test for #35571\nansible testhost -i testhost, -m debug -a 'msg={{ hostvars[\"localhost\"] }}' -e \"vars1={{ undef }}\" -e \"vars2={{ vars1 }}\"\n\n# Test for https://github.com/ansible/ansible/issues/27262\nansible-playbook ansible_managed.yml -c  ansible_managed.cfg -i ../../inventory -v \"$@\"\n\n# Test for #42585\nANSIBLE_ROLES_PATH=../ ansible-playbook custom_template.yml -i ../../inventory -v \"$@\"\n\n\n# Test for several corner cases #57188\nansible-playbook corner_cases.yml -v \"$@\"\n\n# Test for #57351\nansible-playbook filter_plugins.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/68699\nansible-playbook unused_vars_include.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/55152\nansible-playbook undefined_var_info.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/72615\nansible-playbook 72615.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/6653\nansible-playbook 6653.yml -v \"$@\"\n\n# https://github.com/ansible/ansible/issues/72262\nansible-playbook 72262.yml -v \"$@\"\n", "patch": "@@ -34,3 +34,7 @@ ansible-playbook 6653.yml -v \"$@\"\n \n # https://github.com/ansible/ansible/issues/72262\n ansible-playbook 72262.yml -v \"$@\"\n+\n+# ensure unsafe is preserved, even with extra newlines\n+ansible-playbook unsafe.yml -v \"$@\"\n+", "file_path": "files/2021_9/83", "file_language": "sh", "file_name": "test/integration/targets/template/runme.sh", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ansible/ansible/raw/4c8c40fd3d4a58defdc80e7d22aa8d26b731353e/test%2Fintegration%2Ftargets%2Ftemplate%2Funsafe.yml", "code": "- hosts: localhost\n  gather_facts: false\n  vars:\n    nottemplated: this should not be seen\n    imunsafe: !unsafe '{{ nottemplated }}'\n  tasks:\n\n    - set_fact:\n        this_was_unsafe: >\n          {{ imunsafe }}\n\n    - set_fact:\n          this_always_safe: '{{ imunsafe }}'\n\n    - name: ensure nothing was templated\n      assert:\n        that:\n        - this_always_safe == imunsafe\n        - imunsafe == this_was_unsafe.strip()\n", "code_before": "", "patch": "@@ -0,0 +1,19 @@\n+- hosts: localhost\n+  gather_facts: false\n+  vars:\n+    nottemplated: this should not be seen\n+    imunsafe: !unsafe '{{ nottemplated }}'\n+  tasks:\n+\n+    - set_fact:\n+        this_was_unsafe: >\n+          {{ imunsafe }}\n+\n+    - set_fact:\n+          this_always_safe: '{{ imunsafe }}'\n+\n+    - name: ensure nothing was templated\n+      assert:\n+        that:\n+        - this_always_safe == imunsafe\n+        - imunsafe == this_was_unsafe.strip()", "file_path": "files/2021_9/84", "file_language": "yml", "file_name": "test/integration/targets/template/unsafe.yml", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
