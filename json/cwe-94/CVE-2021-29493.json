{"index": 6039, "cve_id": "CVE-2021-29493", "cwe_id": ["CWE-94", "NVD-CWE-noinfo"], "cve_language": "Python", "cve_description": "Kennnyshiwa-cogs contains cogs for Red Discordbot. An RCE exploit has been found in the Tickets module of kennnyshiwa-cogs. This exploit allows discord users to craft a message that can reveal sensitive and harmful information. Users can upgrade to version 5a84d60018468e5c0346f7ee74b2b4650a6dade7 to receive a patch or, as a workaround, unload tickets to render the exploit unusable.", "cvss": "8.8", "publish_date": "May 6, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "5a84d60018468e5c0346f7ee74b2b4650a6dade7", "commit_message": "fix some shit", "commit_date": "2021-05-06T01:13:11Z", "project": "kennnyshiwa/kennnyshiwa-cogs", "url": "https://api.github.com/repos/kennnyshiwa/kennnyshiwa-cogs/commits/5a84d60018468e5c0346f7ee74b2b4650a6dade7", "html_url": "https://github.com/kennnyshiwa/kennnyshiwa-cogs/commit/5a84d60018468e5c0346f7ee74b2b4650a6dade7", "windows_before": [{"commit_id": "619b89930e4ac4a0d8a9c701daf08f4400a54b05", "commit_date": "Wed Apr 14 07:31:03 2021 -0400", "commit_message": "Merge pull request #42 from issy/fix/Lastfm", "files_name": ["e0757362fb427dcb1a8eaa10534f3fe81deb0b30 - Mon Apr 12 01:32:46 2021 +0000 : feat(lastfm): Allow emotes from other guilds if bot in guild", "lastfm/lastfm.py"]}, {"commit_id": "efdca1d3e196f0319aae762ea5ea6b4485939963", "commit_date": "Mon Apr 12 01:22:00 2021 +0000", "commit_message": "fix(lastfm): set_react logic", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "93096efdeab8d3c372417598f918e383eb89f988", "commit_date": "Sat Apr 10 15:28:43 2021 -0400", "commit_message": "Merge pull request #41 from issy/fix/Lastfm", "files_name": ["b508f4bc66ecc0454fefd95ca0dd86b7381afcab - Sat Apr 10 19:15:30 2021 +0000 : feat(lastfm): Improved username logic", "lastfm/lastfm.py"]}, {"commit_id": "1a17fdda57e752be50a6c6fde38c02d9d25ba51b", "commit_date": "Sat Apr 10 19:05:48 2021 +0000", "commit_message": "default to None", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "61ca1b649f1a0d15da059596e25bafc6eb5a7574", "commit_date": "Sat Apr 10 19:00:48 2021 +0000", "commit_message": "chore(lastfm): Added typehints", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "69a06c253f3cb282bbf1413595677bf560baeb26", "commit_date": "Sat Apr 10 19:00:24 2021 +0000", "commit_message": "docs(lastfm): Added myself to authors list", "files_name": ["lastfm/info.json"]}, {"commit_id": "d6c9ba338aeeb3d29ac1bab68522f40eab43bb55", "commit_date": "Sat Apr 10 17:17:05 2021 +0000", "commit_message": "feat(lastfm): Added ability to check stats of other members", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "aeca9ce7cd98f107c11a63e5fa93328312a1e3f1", "commit_date": "Sat Apr 3 12:57:06 2021 -0400", "commit_message": "Merge pull request #40 from Kreusada/patch-1", "files_name": ["edd79f817499fd7cd762fdf8fcaece310101f296 - Sat Apr 3 16:15:51 2021 +0100 : [ListEmoji] Guild only decorator", "listemoji/listemoji.py"]}, {"commit_id": "afb064a0906e31e0e6ec73a8987d4a109bffae33", "commit_date": "Fri Feb 26 19:32:08 2021 -0500", "commit_message": "Merge pull request #37 from issy/v3-cogs", "files_name": ["3d76d4b9885d127b03d34ec07f96369bc85402f1 - Fri Feb 26 14:03:06 2021 +0000 : fix(lastfm): Added guild check in nowplaying", "lastfm/lastfm.py"]}, {"commit_id": "dbc5142669932c23cf7b74c8b5ab4921a7d6cb74", "commit_date": "Fri Feb 26 13:58:41 2021 +0000", "commit_message": "chore(lastfm): Reformatted", "files_name": ["lastfm/__init__.py", "lastfm/lastfm.py"]}, {"commit_id": "62e5e490b529fde38644300ad4578356f4dd07eb", "commit_date": "Fri Feb 26 12:36:20 2021 +0000", "commit_message": "feat(lastfm): Added Spotify reaction", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "8f27e739cf2ad30afd56c680456a4a98a5930800", "commit_date": "Fri Feb 26 11:30:30 2021 +0000", "commit_message": "chore(lastfm): Layout update", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "cdba0623f676de2b463072ffb07651d3c7cb6740", "commit_date": "Fri Feb 26 11:29:09 2021 +0000", "commit_message": "chore(lastfm): Layout", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "7ef837058afb1dac21dda64b40279172e6e78f09", "commit_date": "Fri Feb 26 11:24:08 2021 +0000", "commit_message": "feat(lastfm): Moved Spotify URI to content", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "7a709b7f171b99997a64b3242f98473f68e2f385", "commit_date": "Fri Feb 26 11:17:14 2021 +0000", "commit_message": "fix(lastfm): Func naming", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "65c8c58c471814e60f3292edc65987b374318230", "commit_date": "Fri Feb 26 11:11:48 2021 +0000", "commit_message": "feat(lastfm): Add Spotify URI fetch to nowplaying cmd", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "3bfb2fa4acb4514df84614755a3234c8e1bfb88a", "commit_date": "Fri Feb 26 10:41:38 2021 +0000", "commit_message": "chore(info.json): Add bs4 to lastfm requirements", "files_name": ["lastfm/info.json"]}, {"commit_id": "279e7e46a144dc34fc5025d0ab32e8abba33dcff", "commit_date": "Tue Feb 2 22:44:53 2021 -0500", "commit_message": "Merge pull request #36 from tigattack/patch-2", "files_name": ["c241e03486a3fce67017c26d19516ba228674b62 - Mon Feb 1 09:08:32 2021 +0000 : feat(lastfm): Move track field to own line", "lastfm/lastfm.py"]}, {"commit_id": "cc414ffa1a2e7dfd68146024e735448dfc004c5a", "commit_date": "Sun Jan 31 11:54:17 2021 -0500", "commit_message": "Merge pull request #34 from tigattack/patch-1", "files_name": ["4ecd946fab5286c66f3e9f8d3df702fe9d2efd4d - Sun Jan 31 11:53:54 2021 -0500 : Merge pull request #35 from PredaaA/space-fixes", "e5cc3c0998c0819a31c5be7c4cdc99a550fa8136 - Sun Jan 31 14:48:17 2021 +0100 : [Space] Be less spammy to the API, and a few fixes.", "space/core.py", "space/info.json", "space/space.py"]}, {"commit_id": "d89513be67aa5bfc2b5f4a00ed7b126a8a2c01d9", "commit_date": "Thu Jan 28 09:50:11 2021 +0000", "commit_message": "feat(lastfm): Remove play count.", "files_name": ["lastfm/lastfm.py"]}, {"commit_id": "3b1f5741955390c123c9e241605715542508f520", "commit_date": "Wed Dec 9 12:35:05 2020 -0500", "commit_message": "Merge pull request #33 from tigattack/patch-1", "files_name": ["a16845612379beb67c0fab3d724070469ea00cbe - Wed Dec 9 12:34:55 2020 -0500 : Merge pull request #32 from maxbooiii/v3-cogs", "31feb1c7571aa08e17c80dc39a8aa3615f198a21 - Wed Dec 9 12:34:45 2020 -0500 : Merge pull request #31 from PredaaA/patch-4", "1a3f0b6638fc1956afe2783dc6235c0ae0a21d0c - Wed Dec 9 17:33:34 2020 +0000 : fix(lastfm.py): Fix typo.", "lastfm/lastfm.py"]}, {"commit_id": "68181d245c8db3e0d494351f75c97a9a28bf04ef", "commit_date": "Sat Nov 28 19:39:17 2020 +0100", "commit_message": "Switch to `discord.com`", "files_name": ["embedinvite/invite.py"]}, {"commit_id": "c12d16f21aaa9c5fa06b576e9d16e7cd4f1bbadf", "commit_date": "Wed Nov 25 21:18:02 2020 +0100", "commit_message": "[Space] Update apod domain.", "files_name": ["space/core.py"]}, {"commit_id": "7662c95fbaa27ea6a1e60478d4728056aeef7aef", "commit_date": "Sat Oct 31 20:20:58 2020 -0400", "commit_message": "Merge remote-tracking branch 'origin/v3-cogs' into v3-cogs", "files_name": ["69f11ba16991a04187fa5988cca826863ffcdac5 - Sat Oct 31 20:20:54 2020 -0400 : [lastfm] fix trackinfo error", "lastfm/lastfm.py"]}, {"commit_id": "f45fa30560d27dee134525791144013f6203e1f1", "commit_date": "Fri Oct 23 08:43:36 2020 -0400", "commit_message": "Merge pull request #30 from PredaaA/patch-4", "files_name": ["35a1156aaa55546b8576981a1fc0d23d154a272b - Fri Oct 23 14:38:33 2020 +0200 : Remove unused imports.", "imperialtoolkit/imperialtoolkit.py"]}, {"commit_id": "acd075f87b83ecfa163aabe153f0b40680ab7324", "commit_date": "Fri Oct 23 14:35:19 2020 +0200", "commit_message": "[ImperialToolKit] Some cleanup", "files_name": ["imperialtoolkit/imperialtoolkit.py"]}, {"commit_id": "ed40d5a078bc60a50a7c5e3ee61fb4fc80fe1b90", "commit_date": "Thu Oct 15 20:43:07 2020 -0400", "commit_message": "Merge pull request #29 from PredaaA/patch-4", "files_name": ["725e16efdb480db6d5ea026ff0a5c5bb3d46c943 - Thu Oct 15 13:41:54 2020 +0200 : [Space] Actually don't disable auto APOD if channel is None", "space/core.py"]}, {"commit_id": "4e1a8f16d327f00bca36f55381960a7a02439f97", "commit_date": "Tue Aug 25 13:04:30 2020 -0400", "commit_message": "Merge pull request #27 from thisisjvgrace/patch-1", "files_name": ["323dc11032438ed1f6e965e64915eec0a4a11876 - Tue Aug 25 17:58:31 2020 +0530 : Merge pull request #1 from PredaaA/patch-4", "e6920f087c52d30266066a2bf42ff36aa0a9cf13 - Tue Aug 25 14:24:50 2020 +0200 : Use .get instead of try except", "space/core.py"]}, {"commit_id": "9272324a7b5b46b87324357b67194f0dcf4a25ce", "commit_date": "Tue Aug 25 17:30:06 2020 +0530", "commit_message": "process what Preda suggested", "files_name": ["space/core.py"]}, {"commit_id": "feaa787e18e670a96350b3985ff71acd22b6d4d4", "commit_date": "Tue Aug 25 17:12:16 2020 +0530", "commit_message": "fuck nasa", "files_name": ["space/core.py"]}, {"commit_id": "f51f754d97449043b54838d0b1a3b909aaf5b64d", "commit_date": "Mon Aug 24 10:12:59 2020 -0400", "commit_message": "Merge pull request #26 from PredaaA/patch-4", "files_name": ["d313bbc0630695dfe572c57566f566d38a61a45d - Mon Aug 24 16:07:37 2020 +0200 : [Space] Use embed description instead of field value for APOD details", "space/core.py"]}, {"commit_id": "28475cd895db3eddb0a53d5b6d3b594908bdb920", "commit_date": "Mon Aug 24 09:58:54 2020 -0400", "commit_message": "Merge pull request #25 from thisisjvgrace/patch-1", "files_name": ["be6e7e5a1b7d21139a220b6625373a552cafdeb5 - Mon Aug 24 17:48:10 2020 +0530 : fix embed title to not dupe with embed author", "space/core.py"]}, {"commit_id": "a48ba810ffc3ef16378e5c0ab1b5c64c2575b9a7", "commit_date": "Mon Aug 24 16:10:12 2020 +0530", "commit_message": "added embed author field as requested by Preda", "files_name": ["space/core.py"]}, {"commit_id": "e189e87591404e5e6b0291ec189f44ba00fed1f5", "commit_date": "Mon Aug 24 15:34:35 2020 +0530", "commit_message": "add image credits in footer for [p]apod", "files_name": ["space/core.py"]}, {"commit_id": "9b7900f292054fe1e3a2d8d6bccc52f86b90a276", "commit_date": "Wed Aug 19 12:32:59 2020 -0400", "commit_message": "Merge pull request #24 from thisisjvgrace/patch-2", "files_name": ["25d5e0cf16e8ef392d95b129822598a88c3d8f14 - Wed Aug 19 21:44:27 2020 +0530 : fetch correct cpu model info", "imperialtoolkit/imperialtoolkit.py"]}, {"commit_id": "08d46a75c8cfc3f5bda21a22a1abd3a16d331728", "commit_date": "Mon Jul 27 20:00:05 2020 -0400", "commit_message": "Data API changes", "files_name": ["ark/__init__.py", "ark/ark.py", "autogallery/__init__.py", "autogallery/autogallery.py", "embedinvite/__init__.py", "embedinvite/invite.py", "imperialtoolkit/__init__.py", "imperialtoolkit/imperialtoolkit.py", "lastfm/__init__.py", "lastfm/lastfm.py", "listemoji/__init__.py", "listemoji/listemoji.py", "pnw/__init__.py", "pnw/pnw.py", "pottermore/__init__.py", "pottermore/pottermore.py", "requestbox/__init__.py", "requestbox/core.py", "screenshare/__init__.py", "screenshare/screenshare.py", "space/__init__.py", "space/core.py", "tickets/__init__.py", "tickets/core.py", "trackerinfo/__init__.py", "trackerinfo/trackerinfo.py"]}, {"commit_id": "fb25026fd70d32dc304a305962bf2ad789d5efc2", "commit_date": "Sun Jul 19 15:03:24 2020 -0400", "commit_message": "Merge pull request #18 from PredaaA/patch-4", "files_name": ["213c12087bb071f2f79d51d6b8594783a7b60dcc - Sun Jul 19 15:03:07 2020 -0400 : [autogallery] add which channel the image came from", "autogallery/autogallery.py"]}, {"commit_id": "bddd47c6b2798d02dc886face44849f605656ea1", "commit_date": "Mon Jul 13 21:14:54 2020 -0400", "commit_message": "[autogallery] first commit", "files_name": ["autogallery/__init__.py", "autogallery/autogallery.py", "autogallery/info.json"]}, {"commit_id": "188b24b2b4e6232f584cd171f4c9aed1f3e2288e", "commit_date": "Fri Jul 10 22:18:42 2020 -0400", "commit_message": "Merge remote-tracking branch 'origin/v3-cogs' into v3-cogs", "files_name": ["64cc55ace762300ab04062920314c9385c6db34a - Fri Jul 10 22:18:41 2020 -0400 : update readme", "README.md"]}, {"commit_id": "d4ee807d64295666da941875f42f709b9f5596ee", "commit_date": "Fri Jul 10 21:51:30 2020 -0400", "commit_message": "Merge pull request #22 from PredaaA/patch-5", "files_name": ["e1afd5884bb492af2ea9013ceef4f5f8d4cec1db - Sat Jul 11 03:30:07 2020 +0200 : [Space] Less log spam", "space/core.py"]}, {"commit_id": "535c1f9139761b66fb80c46894c9b8842aba053a", "commit_date": "Fri Jul 3 16:36:05 2020 -0400", "commit_message": "Merge pull request #21 from PredaaA/patch-5", "files_name": ["2747559919fd1cc83ee94db95689f24ab5be5255 - Fri Jul 3 22:32:18 2020 +0200 : Update space.py", "space/space.py"]}, {"commit_id": "323d7f6f328ee150933d0e5180ddc08d045c015e", "commit_date": "Fri Jul 3 22:31:09 2020 +0200", "commit_message": "[Space] Stop use of NASA APOD API & a few tweaks", "files_name": ["space/core.py"]}, {"commit_id": "a337b8114b6fd15cbd2c7515655047c4195622fe", "commit_date": "Fri May 15 23:17:48 2020 +0200", "commit_message": "[ListEmoji] Show emojis ids if specified", "files_name": ["listemoji/listemoji.py"]}, {"commit_id": "45b9c4991c33db6454acab9360cf6d572301c24f", "commit_date": "Fri May 1 13:09:06 2020 -0400", "commit_message": "[imperialtoollkit] add min bot version 3.3.6", "files_name": ["imperialtoolkit/info.json"]}, {"commit_id": "98e2001183e06d429d358cfaf2af3d0f27898e51", "commit_date": "Wed Apr 29 16:53:30 2020 -0400", "commit_message": "[imperialtoolkit] fix ram finally", "files_name": ["imperialtoolkit/imperialtoolkit.py"]}, {"commit_id": "17e3336b0c88c411a7e7f481a1dbf09039f0c2b4", "commit_date": "Wed Apr 29 16:33:14 2020 -0400", "commit_message": "[imperialtoolkit] update botstat to use asnyciter for user count", "files_name": ["imperialtoolkit/imperialtoolkit.py"]}, {"commit_id": "c06c81a6483d8cb26947a27f373223c0230f6f3c", "commit_date": "Sat Apr 25 21:55:28 2020 -0400", "commit_message": "Merge pull request #17 from PredaaA/patch-4", "files_name": ["502b14b3615f19685f8312ecf8b281e3893f0f2a - Sun Apr 26 03:54:53 2020 +0200 : [Space] Fix no longer existing channels in autoapod", "space/core.py"]}, {"commit_id": "348b692fc94535cb268700bb3446231d7cc41b25", "commit_date": "Wed Apr 22 12:50:52 2020 -0400", "commit_message": "Merge pull request #16 from PredaaA/patch-3", "files_name": ["c08cda551675b621161e7b291dbb884ef1cdbd36 - Wed Apr 22 12:50:41 2020 -0400 : Merge pull request #15 from PredaaA/patch-2"]}], "windows_after": [{"commit_id": "86911bfe615fdc5832e9e7e7930637d0b6a8a9c8", "commit_date": "Wed May 5 21:13:17 2021 -0400", "commit_message": "Merge remote-tracking branch 'origin/v3-cogs' into v3-cogs", "files_name": ["c28552b440c5cbef537b2759c81d49bde155dec3 - Wed May 26 23:19:21 2021 -0400 : update for mtv api status changes", "trackerinfo/trackerinfo.py"]}], "parents": [{"commit_id_before": "7662c95fbaa27ea6a1e60478d4728056aeef7aef", "url_before": "https://api.github.com/repos/kennnyshiwa/kennnyshiwa-cogs/commits/7662c95fbaa27ea6a1e60478d4728056aeef7aef", "html_url_before": "https://github.com/kennnyshiwa/kennnyshiwa-cogs/commit/7662c95fbaa27ea6a1e60478d4728056aeef7aef"}], "details": [{"raw_url": "https://github.com/kennnyshiwa/kennnyshiwa-cogs/raw/5a84d60018468e5c0346f7ee74b2b4650a6dade7/tickets%2Fcore.py", "code": "from redbot.core import Config\nfrom datetime import datetime\nimport discord\nimport random\n\n\nclass SafeMember:\n    def __init__(self, member: discord.Member):\n        self.name = member.name\n        self.mention = member.mention\n\n    def __str__(self):\n        return self.name\n\n    def __getattr__(self, name):\n        return \"\"\n\n\nclass TicketsCore:\n    async def red_delete_data_for_user(self, **kwargs):\n        \"\"\" Nothing to delete \"\"\"\n        return\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        self.config = Config.get_conf(self, identifier=2134287593)\n        default_guild = {\n            \"category\": None,\n            \"closed_category\": None,\n            \"ticket_role\": None,\n            \"default_message_ticket_channel\": None,\n            \"sessions\": {},\n        }\n        self.config.register_guild(**default_guild)\n\n        self.ticket_info_format = \"\\n\\n**[{datetime}]** [{author}]\\n{information}\"\n\n    async def create_ticket(self, context):\n        guild = context.guild\n        author = context.author\n\n        ticket_role = [\n            role\n            for role in guild.roles\n            if await self.config.guild(guild).ticket_role() == role.id\n        ]\n\n        if ticket_role:\n            ticket_role = ticket_role[0]\n        category_channel = await self.config.guild(guild).category()\n        default_message_ticket_channel = await self.config.guild(\n            guild\n        ).default_message_ticket_channel()\n\n        if category_channel and category_channel in [\n            category.id for category in guild.categories\n        ]:\n            n1 = 10 ** 10\n            n2 = n1 * 10 - 1\n            ticket_id = int(random.randint(n1, n2))\n            ticket_channel = await guild.create_text_channel(\n                \"{}-{}\".format(author.display_name, ticket_id),\n                category=self.bot.get_channel(category_channel),\n            )\n\n            await ticket_channel.set_permissions(\n                author, read_messages=True, send_messages=True\n            )\n            await ticket_channel.set_permissions(\n                guild.me, read_messages=True, send_messages=True, manage_channels=True\n            )\n\n            await ticket_channel.edit(\n                topic=self.ticket_info_format.format(\n                    ticket=ticket_id,\n                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n                    author=author.display_name,\n                    information=\"Ticket opened\",\n                )\n            )\n\n            if default_message_ticket_channel:\n                try:\n                    await ticket_channel.send(\n                        default_message_ticket_channel.format(\n                            member=SafeMember(author),\n                            channel=ticket_channel,\n                            origin=context.channel,\n                            ticket_role=ticket_role,\n                        )\n                    )\n                except:\n                    return \"Oops there has been an unexpected error with your new ticket message. Please contact the bot owner for assistance\"\n\n            async with self.config.guild(guild).sessions() as session:\n                session.update({ticket_channel.id: author.id})\n\n        else:\n            return \"Naughty! You need to run the setup first.\"\n\n    async def update_ticket(self, context, status):\n        try:\n            await context.message.delete()\n        except discord.Forbidden:\n            pass\n\n        guild = context.guild\n        channel = context.channel\n        author = context.author\n\n        sessions = await self.config.guild(guild).sessions()\n\n        if str(channel.id) in sessions and await self.config.guild(\n            guild\n        ).ticket_role() in [role.id for role in author.roles]:\n\n            ticket_id = str(channel.name).split(\"-\")[1]\n            await channel.edit(\n                topic=channel.topic\n                + self.ticket_info_format.format(\n                    ticket=ticket_id,\n                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n                    author=author.display_name,\n                    information=status,\n                )\n            )\n\n    async def close_ticket(self, context):\n        try:\n            await context.message.delete()\n        except discord.Forbidden:\n            pass\n\n        guild = context.guild\n        channel = context.channel\n        author = context.author\n\n        sessions = await self.config.guild(guild).sessions()\n\n        if str(channel.id) not in sessions:\n            return await channel.send(\n                \"Make sure you are doing this within the ticket channel that you want to close.\"\n            )\n        if await self.config.guild(guild).ticket_role() not in [\n            role.id for role in author.roles\n        ]:\n            return await channel.send(\n                \"You do not have the proper role to manage tickets\"\n            )\n        else:\n            member = guild.get_member(sessions[str(channel.id)])\n            ticket_id = str(channel.name).split(\"-\")[1]\n\n            closed_category = await self.config.guild(guild).closed_category()\n            closed_category = self.bot.get_channel(closed_category)\n\n            await channel.set_permissions(\n                member, read_messages=True, send_messages=False\n            )\n            await channel.edit(\n                category=closed_category,\n                topic=channel.topic\n                + self.ticket_info_format.format(\n                    ticket=ticket_id,\n                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n                    author=author.display_name,\n                    information=\"Ticket closed\",\n                ),\n            )\n\n            async with self.config.guild(guild).sessions() as session:\n                session.pop(channel.id, None)\n\n    async def purge_tickets(self, context):\n        try:\n            guild = context.guild\n            closed_channels = [\n                channel\n                for channel in guild.channels\n                if channel.category_id\n                == await self.config.guild(guild).closed_category()\n            ]\n            for channel in closed_channels:\n                await channel.delete()\n\n            return \"All closed tickets removed!\"\n        except discord.Forbidden:\n            return \"I need permissions to manage channels.\"\n\n    async def set_default_message_ticket_channel(self, context, message):\n        guild = context.guild\n\n        await self.config.guild(guild).default_message_ticket_channel.set(message)\n\n        return \"Your default message has been set.\"\n\n    async def automatic_setup(self, context):\n        guild = context.guild\n\n        try:\n            overwrites = {\n                guild.default_role: discord.PermissionOverwrite(\n                    send_messages=False, read_messages=False\n                ),\n            }\n\n            category_channel = await guild.create_category(\n                \"Tickets\", overwrites=overwrites\n            )\n            closed_category_channel = await guild.create_category(\n                \"Closed Tickets\", overwrites=overwrites\n            )\n\n            ticket_role = await guild.create_role(name=\"Ticket\")\n\n            await category_channel.set_permissions(\n                ticket_role, read_messages=True, send_messages=True\n            )\n            await closed_category_channel.set_permissions(\n                ticket_role, read_messages=True, send_messages=True\n            )\n\n            await self.config.guild(guild).category.set(category_channel.id)\n            await self.config.guild(guild).closed_category.set(\n                closed_category_channel.id\n            )\n            await self.config.guild(guild).ticket_role.set(ticket_role.id)\n\n            return \":tada: Fabulous! You're all done! Now add the `Ticket` role to anyone who you deem good enough to handle tickets. And if you care, you can change the name of the role and category if you _really_ want to.\"\n        except discord.Forbidden:\n            return \"That didn't go well... I need permissions to manage channels and manage roles. :rolling_eyes:\"\n", "code_before": "from redbot.core import Config\nfrom datetime import datetime\nimport discord\nimport random\n\n\nclass TicketsCore:\n\n    async def red_delete_data_for_user(self, **kwargs):\n        \"\"\" Nothing to delete \"\"\"\n        return\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        self.config = Config.get_conf(self, identifier=2134287593)\n        default_guild = {\n            'category': None,\n            'closed_category': None,\n            'ticket_role': None,\n            'default_message_ticket_channel': None,\n            'sessions': {}\n        }\n        self.config.register_guild(**default_guild)\n\n        self.ticket_info_format = '\\n\\n**[{datetime}]** [{author}]\\n{information}'\n\n    async def create_ticket(self, context):\n        guild = context.guild\n        author = context.author\n\n        ticket_role = [role for role in guild.roles if await self.config.guild(guild).ticket_role() == role.id]\n\n        if ticket_role:\n            ticket_role = ticket_role[0]\n        category_channel = await self.config.guild(guild).category()\n        default_message_ticket_channel = await self.config.guild(guild).default_message_ticket_channel()\n\n        if category_channel and category_channel in [category.id for category in guild.categories]:\n            n1 = 10**10\n            n2 = n1 * 10 - 1\n            ticket_id = int(random.randint(n1, n2))\n            ticket_channel = await guild.create_text_channel('{}-{}'.format(author.display_name, ticket_id),\n                                                             category=self.bot.get_channel(category_channel))\n\n            await ticket_channel.set_permissions(author, read_messages=True, send_messages=True)\n            await ticket_channel.set_permissions(guild.me, read_messages=True, send_messages=True, manage_channels=True)\n\n            await ticket_channel.edit(topic=self.ticket_info_format.format(ticket=ticket_id,\n                                      datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n                                      author=author.display_name,\n                                      information='Ticket opened'))\n\n            if default_message_ticket_channel:\n                await ticket_channel.send(default_message_ticket_channel.format(member=author,\n                                                                                channel=ticket_channel,\n                                                                                origin=context.channel,\n                                                                                ticket_role=ticket_role))\n\n            async with self.config.guild(guild).sessions() as session:\n                    session.update({ticket_channel.id: author.id})\n\n        else:\n            return 'Naughty! You need to run the setup first.'\n\n    async def update_ticket(self, context, status):\n        try:\n            await context.message.delete()\n        except discord.Forbidden:\n            pass\n\n        guild = context.guild\n        channel = context.channel\n        author = context.author\n\n        sessions = await self.config.guild(guild).sessions()\n\n        if str(channel.id) in sessions and await self.config.guild(guild).ticket_role() in [role.id for role in author.roles]:\n\n            ticket_id = str(channel.name).split('-')[1]\n            await channel.edit(topic=channel.topic+self.ticket_info_format.format(\n                                ticket=ticket_id,\n                                datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n                                author=author.display_name,\n                                information=status)\n                               )\n\n    async def close_ticket(self, context):\n        try:\n            await context.message.delete()\n        except discord.Forbidden:\n            pass\n\n        guild = context.guild\n        channel = context.channel\n        author = context.author\n\n        sessions = await self.config.guild(guild).sessions()\n\n        if str(channel.id) not in sessions:\n            return await channel.send(\"Make sure you are doing this within the ticket channel that you want to close.\")\n        if await self.config.guild(guild).ticket_role() not in [role.id for role in author.roles]:\n            return await channel.send(\"You do not have the proper role to manage tickets\")\n        else:\n            member = guild.get_member(sessions[str(channel.id)])\n            ticket_id = str(channel.name).split('-')[1]\n\n            closed_category = await self.config.guild(guild).closed_category()\n            closed_category = self.bot.get_channel(closed_category)\n\n            await channel.set_permissions(member, read_messages=True, send_messages=False)\n            await channel.edit(category=closed_category,\n                               topic=channel.topic+self.ticket_info_format.format(\n                                    ticket=ticket_id,\n                                    datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n                                    author=author.display_name,\n                                    information='Ticket closed'))\n\n            async with self.config.guild(guild).sessions() as session:\n                    session.pop(channel.id, None)\n\n    async def purge_tickets(self, context):\n        try:\n            guild = context.guild\n            closed_channels = [channel for channel in guild.channels if channel.category_id == await self.config.guild(guild).closed_category()]\n            for channel in closed_channels:\n                await channel.delete()\n\n            return 'All closed tickets removed!'\n        except discord.Forbidden:\n            return 'I need permissions to manage channels.'\n\n    async def set_default_message_ticket_channel(self, context, message):\n        guild = context.guild\n\n        await self.config.guild(guild).default_message_ticket_channel.set(message)\n\n        return 'Your default message has been set.'\n\n    async def automatic_setup(self, context):\n        guild = context.guild\n\n        try:\n            overwrites = {\n                guild.default_role: discord.PermissionOverwrite(send_messages=False, read_messages=False),\n            }\n\n            category_channel = await guild.create_category('Tickets', overwrites=overwrites)\n            closed_category_channel = await guild.create_category('Closed Tickets', overwrites=overwrites)\n\n            ticket_role = await guild.create_role(name='Ticket')\n\n            await category_channel.set_permissions(ticket_role, read_messages=True, send_messages=True)\n            await closed_category_channel.set_permissions(ticket_role, read_messages=True, send_messages=True)\n\n            await self.config.guild(guild).category.set(category_channel.id)\n            await self.config.guild(guild).closed_category.set(closed_category_channel.id)\n            await self.config.guild(guild).ticket_role.set(ticket_role.id)\n\n            return ':tada: Fabulous! You\\'re all done! Now add the `Ticket` role to anyone who you deem good enough to handle tickets. And if you care, you can change the name of the role and category if you _really_ want to.'\n        except discord.Forbidden:\n            return 'That didn\\'t go well... I need permissions to manage channels and manage roles. :rolling_eyes:'\n", "patch": "@@ -4,8 +4,19 @@\n import random\n \n \n-class TicketsCore:\n+class SafeMember:\n+    def __init__(self, member: discord.Member):\n+        self.name = member.name\n+        self.mention = member.mention\n+\n+    def __str__(self):\n+        return self.name\n+\n+    def __getattr__(self, name):\n+        return \"\"\n \n+\n+class TicketsCore:\n     async def red_delete_data_for_user(self, **kwargs):\n         \"\"\" Nothing to delete \"\"\"\n         return\n@@ -15,53 +26,78 @@ def __init__(self, bot):\n \n         self.config = Config.get_conf(self, identifier=2134287593)\n         default_guild = {\n-            'category': None,\n-            'closed_category': None,\n-            'ticket_role': None,\n-            'default_message_ticket_channel': None,\n-            'sessions': {}\n+            \"category\": None,\n+            \"closed_category\": None,\n+            \"ticket_role\": None,\n+            \"default_message_ticket_channel\": None,\n+            \"sessions\": {},\n         }\n         self.config.register_guild(**default_guild)\n \n-        self.ticket_info_format = '\\n\\n**[{datetime}]** [{author}]\\n{information}'\n+        self.ticket_info_format = \"\\n\\n**[{datetime}]** [{author}]\\n{information}\"\n \n     async def create_ticket(self, context):\n         guild = context.guild\n         author = context.author\n \n-        ticket_role = [role for role in guild.roles if await self.config.guild(guild).ticket_role() == role.id]\n+        ticket_role = [\n+            role\n+            for role in guild.roles\n+            if await self.config.guild(guild).ticket_role() == role.id\n+        ]\n \n         if ticket_role:\n             ticket_role = ticket_role[0]\n         category_channel = await self.config.guild(guild).category()\n-        default_message_ticket_channel = await self.config.guild(guild).default_message_ticket_channel()\n-\n-        if category_channel and category_channel in [category.id for category in guild.categories]:\n-            n1 = 10**10\n+        default_message_ticket_channel = await self.config.guild(\n+            guild\n+        ).default_message_ticket_channel()\n+\n+        if category_channel and category_channel in [\n+            category.id for category in guild.categories\n+        ]:\n+            n1 = 10 ** 10\n             n2 = n1 * 10 - 1\n             ticket_id = int(random.randint(n1, n2))\n-            ticket_channel = await guild.create_text_channel('{}-{}'.format(author.display_name, ticket_id),\n-                                                             category=self.bot.get_channel(category_channel))\n-\n-            await ticket_channel.set_permissions(author, read_messages=True, send_messages=True)\n-            await ticket_channel.set_permissions(guild.me, read_messages=True, send_messages=True, manage_channels=True)\n-\n-            await ticket_channel.edit(topic=self.ticket_info_format.format(ticket=ticket_id,\n-                                      datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n-                                      author=author.display_name,\n-                                      information='Ticket opened'))\n+            ticket_channel = await guild.create_text_channel(\n+                \"{}-{}\".format(author.display_name, ticket_id),\n+                category=self.bot.get_channel(category_channel),\n+            )\n+\n+            await ticket_channel.set_permissions(\n+                author, read_messages=True, send_messages=True\n+            )\n+            await ticket_channel.set_permissions(\n+                guild.me, read_messages=True, send_messages=True, manage_channels=True\n+            )\n+\n+            await ticket_channel.edit(\n+                topic=self.ticket_info_format.format(\n+                    ticket=ticket_id,\n+                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n+                    author=author.display_name,\n+                    information=\"Ticket opened\",\n+                )\n+            )\n \n             if default_message_ticket_channel:\n-                await ticket_channel.send(default_message_ticket_channel.format(member=author,\n-                                                                                channel=ticket_channel,\n-                                                                                origin=context.channel,\n-                                                                                ticket_role=ticket_role))\n+                try:\n+                    await ticket_channel.send(\n+                        default_message_ticket_channel.format(\n+                            member=SafeMember(author),\n+                            channel=ticket_channel,\n+                            origin=context.channel,\n+                            ticket_role=ticket_role,\n+                        )\n+                    )\n+                except:\n+                    return \"Oops there has been an unexpected error with your new ticket message. Please contact the bot owner for assistance\"\n \n             async with self.config.guild(guild).sessions() as session:\n-                    session.update({ticket_channel.id: author.id})\n+                session.update({ticket_channel.id: author.id})\n \n         else:\n-            return 'Naughty! You need to run the setup first.'\n+            return \"Naughty! You need to run the setup first.\"\n \n     async def update_ticket(self, context, status):\n         try:\n@@ -75,15 +111,20 @@ async def update_ticket(self, context, status):\n \n         sessions = await self.config.guild(guild).sessions()\n \n-        if str(channel.id) in sessions and await self.config.guild(guild).ticket_role() in [role.id for role in author.roles]:\n-\n-            ticket_id = str(channel.name).split('-')[1]\n-            await channel.edit(topic=channel.topic+self.ticket_info_format.format(\n-                                ticket=ticket_id,\n-                                datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n-                                author=author.display_name,\n-                                information=status)\n-                               )\n+        if str(channel.id) in sessions and await self.config.guild(\n+            guild\n+        ).ticket_role() in [role.id for role in author.roles]:\n+\n+            ticket_id = str(channel.name).split(\"-\")[1]\n+            await channel.edit(\n+                topic=channel.topic\n+                + self.ticket_info_format.format(\n+                    ticket=ticket_id,\n+                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n+                    author=author.display_name,\n+                    information=status,\n+                )\n+            )\n \n     async def close_ticket(self, context):\n         try:\n@@ -98,65 +139,94 @@ async def close_ticket(self, context):\n         sessions = await self.config.guild(guild).sessions()\n \n         if str(channel.id) not in sessions:\n-            return await channel.send(\"Make sure you are doing this within the ticket channel that you want to close.\")\n-        if await self.config.guild(guild).ticket_role() not in [role.id for role in author.roles]:\n-            return await channel.send(\"You do not have the proper role to manage tickets\")\n+            return await channel.send(\n+                \"Make sure you are doing this within the ticket channel that you want to close.\"\n+            )\n+        if await self.config.guild(guild).ticket_role() not in [\n+            role.id for role in author.roles\n+        ]:\n+            return await channel.send(\n+                \"You do not have the proper role to manage tickets\"\n+            )\n         else:\n             member = guild.get_member(sessions[str(channel.id)])\n-            ticket_id = str(channel.name).split('-')[1]\n+            ticket_id = str(channel.name).split(\"-\")[1]\n \n             closed_category = await self.config.guild(guild).closed_category()\n             closed_category = self.bot.get_channel(closed_category)\n \n-            await channel.set_permissions(member, read_messages=True, send_messages=False)\n-            await channel.edit(category=closed_category,\n-                               topic=channel.topic+self.ticket_info_format.format(\n-                                    ticket=ticket_id,\n-                                    datetime=datetime.utcnow().strftime('%d/%m/%Y %H:%M:%S'),\n-                                    author=author.display_name,\n-                                    information='Ticket closed'))\n+            await channel.set_permissions(\n+                member, read_messages=True, send_messages=False\n+            )\n+            await channel.edit(\n+                category=closed_category,\n+                topic=channel.topic\n+                + self.ticket_info_format.format(\n+                    ticket=ticket_id,\n+                    datetime=datetime.utcnow().strftime(\"%d/%m/%Y %H:%M:%S\"),\n+                    author=author.display_name,\n+                    information=\"Ticket closed\",\n+                ),\n+            )\n \n             async with self.config.guild(guild).sessions() as session:\n-                    session.pop(channel.id, None)\n+                session.pop(channel.id, None)\n \n     async def purge_tickets(self, context):\n         try:\n             guild = context.guild\n-            closed_channels = [channel for channel in guild.channels if channel.category_id == await self.config.guild(guild).closed_category()]\n+            closed_channels = [\n+                channel\n+                for channel in guild.channels\n+                if channel.category_id\n+                == await self.config.guild(guild).closed_category()\n+            ]\n             for channel in closed_channels:\n                 await channel.delete()\n \n-            return 'All closed tickets removed!'\n+            return \"All closed tickets removed!\"\n         except discord.Forbidden:\n-            return 'I need permissions to manage channels.'\n+            return \"I need permissions to manage channels.\"\n \n     async def set_default_message_ticket_channel(self, context, message):\n         guild = context.guild\n \n         await self.config.guild(guild).default_message_ticket_channel.set(message)\n \n-        return 'Your default message has been set.'\n+        return \"Your default message has been set.\"\n \n     async def automatic_setup(self, context):\n         guild = context.guild\n \n         try:\n             overwrites = {\n-                guild.default_role: discord.PermissionOverwrite(send_messages=False, read_messages=False),\n+                guild.default_role: discord.PermissionOverwrite(\n+                    send_messages=False, read_messages=False\n+                ),\n             }\n \n-            category_channel = await guild.create_category('Tickets', overwrites=overwrites)\n-            closed_category_channel = await guild.create_category('Closed Tickets', overwrites=overwrites)\n+            category_channel = await guild.create_category(\n+                \"Tickets\", overwrites=overwrites\n+            )\n+            closed_category_channel = await guild.create_category(\n+                \"Closed Tickets\", overwrites=overwrites\n+            )\n \n-            ticket_role = await guild.create_role(name='Ticket')\n+            ticket_role = await guild.create_role(name=\"Ticket\")\n \n-            await category_channel.set_permissions(ticket_role, read_messages=True, send_messages=True)\n-            await closed_category_channel.set_permissions(ticket_role, read_messages=True, send_messages=True)\n+            await category_channel.set_permissions(\n+                ticket_role, read_messages=True, send_messages=True\n+            )\n+            await closed_category_channel.set_permissions(\n+                ticket_role, read_messages=True, send_messages=True\n+            )\n \n             await self.config.guild(guild).category.set(category_channel.id)\n-            await self.config.guild(guild).closed_category.set(closed_category_channel.id)\n+            await self.config.guild(guild).closed_category.set(\n+                closed_category_channel.id\n+            )\n             await self.config.guild(guild).ticket_role.set(ticket_role.id)\n \n-            return ':tada: Fabulous! You\\'re all done! Now add the `Ticket` role to anyone who you deem good enough to handle tickets. And if you care, you can change the name of the role and category if you _really_ want to.'\n+            return \":tada: Fabulous! You're all done! Now add the `Ticket` role to anyone who you deem good enough to handle tickets. And if you care, you can change the name of the role and category if you _really_ want to.\"\n         except discord.Forbidden:\n-            return 'That didn\\'t go well... I need permissions to manage channels and manage roles. :rolling_eyes:'\n+            return \"That didn't go well... I need permissions to manage channels and manage roles. :rolling_eyes:\"", "file_path": "files/2021_5/601", "file_language": "py", "file_name": "tickets/core.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [true, ["/data/rdhu/other/Static/tmp/2021_5_601.py:42: Medium: randint\n            ticket_id = int(random.randint(n1, n2))\nStandard random number generators should not be used to \ngenerate randomness used for security reasons.  For security sensitive randomness a crytographic randomness generator that provides sufficient entropy should be used."]], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/kennnyshiwa/kennnyshiwa-cogs/raw/5a84d60018468e5c0346f7ee74b2b4650a6dade7/tickets%2Ftickets.py", "code": "from redbot.core import commands\nfrom .core import TicketsCore\nimport re\n\nBaseCog = getattr(commands, \"Cog\", object)\n\n\nclass Tickets(BaseCog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.core = TicketsCore(bot)\n\n    @commands.group(name=\"ticket\")\n    async def ticket(self, context):\n        \"\"\"\n        Tickets!\n        \"\"\"\n\n    @ticket.command(name=\"new\")\n    async def ticket_new(self, context):\n        \"\"\"\n        Create a new ticket\n        \"\"\"\n        if context.invoked_subcommand is None:\n            message = await self.core.create_ticket(context)\n            if message:\n                await context.send(message)\n\n    @ticket.command(name=\"update\")\n    async def ticket_update(self, context, *, status: str):\n        \"\"\"\n        Update the status of a ticket\n        \"\"\"\n        await self.core.update_ticket(context, status)\n\n    @ticket.command(name=\"close\")\n    async def ticket_close(self, context):\n        \"\"\"\n        Close a ticket, must be run in the ticket channel you want to close\n        \"\"\"\n        await self.core.close_ticket(context)\n\n    @ticket.group(name=\"set\")\n    @commands.has_permissions(administrator=True)\n    async def ticket_set(self, context):\n        \"\"\"\n        Settings\n        \"\"\"\n\n    @ticket_set.command(name=\"purge\")\n    async def ticket_set_purge(self, context):\n        \"\"\"\n        Delete all closed tickets\n        \"\"\"\n        message = await self.core.purge_tickets(context)\n        await context.send(message)\n\n    @ticket_set.command(name=\"message\")\n    @commands.has_permissions(administrator=True)\n    async def ticket_set_message(self, context, *, message: str):\n        \"\"\"\n        Set the default message when a new ticket has been created (markdown safe)\n        \"\"\"\n        message = await self.core.set_default_message_ticket_channel(context, message)\n        await context.send(message)\n\n    @ticket_set.command(name=\"setup\")\n    async def ticket_setup(self, context):\n        \"\"\"\n        Automatic setup, will create two categories for open and closed tickets, and a ticket role for people to be able to manage tickets.\n        \"\"\"\n        message = await self.core.automatic_setup(context)\n        await context.send(message)\n", "code_before": "from redbot.core import commands\nfrom .core import TicketsCore\n\nBaseCog = getattr(commands, \"Cog\", object)\n\nclass Tickets(BaseCog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.core = TicketsCore(bot)\n\n    @commands.group(name='ticket')\n    async def ticket(self, context):\n        '''\n        Tickets!\n        '''\n\n    @ticket.command(name='new')\n    async def ticket_new(self, context):\n        '''\n        Create a new ticket\n        '''\n        if context.invoked_subcommand is None:\n            message = await self.core.create_ticket(context)\n            if message:\n                await context.send(message)\n\n    @ticket.command(name='update')\n    async def ticket_update(self, context, *, status: str):\n        '''\n        Update the status of a ticket\n        '''\n        await self.core.update_ticket(context, status)\n\n    @ticket.command(name='close')\n    async def ticket_close(self, context):\n        '''\n        Close a ticket, must be run in the ticket channel you want to close\n        '''\n        await self.core.close_ticket(context)\n\n    @ticket.group(name='set')\n    @commands.has_permissions(administrator=True)\n    async def ticket_set(self, context):\n        '''\n        Settings\n        '''\n\n    @ticket_set.command(name='purge')\n    async def ticket_set_purge(self, context):\n        '''\n        Delete all closed tickets\n        '''\n        message = await self.core.purge_tickets(context)\n        await context.send(message)\n\n    @ticket_set.command(name='message')\n    @commands.has_permissions(administrator=True)\n    async def ticket_set_message(self, context, *, message: str):\n        '''\n        Set the default message when a new ticket has been created (markdown safe)\n        '''\n        message = await self.core.set_default_message_ticket_channel(context, message)\n        await context.send(message)\n\n    @ticket_set.command(name='setup')\n    async def ticket_setup(self, context):\n        '''\n        Automatic setup, will create two categories for open and closed tickets, and a ticket role for people to be able to manage tickets.\n        '''\n        message = await self.core.automatic_setup(context)\n        await context.send(message)\n", "patch": "@@ -1,71 +1,73 @@\n from redbot.core import commands\n from .core import TicketsCore\n+import re\n \n BaseCog = getattr(commands, \"Cog\", object)\n \n+\n class Tickets(BaseCog):\n     def __init__(self, bot):\n         self.bot = bot\n         self.core = TicketsCore(bot)\n \n-    @commands.group(name='ticket')\n+    @commands.group(name=\"ticket\")\n     async def ticket(self, context):\n-        '''\n+        \"\"\"\n         Tickets!\n-        '''\n+        \"\"\"\n \n-    @ticket.command(name='new')\n+    @ticket.command(name=\"new\")\n     async def ticket_new(self, context):\n-        '''\n+        \"\"\"\n         Create a new ticket\n-        '''\n+        \"\"\"\n         if context.invoked_subcommand is None:\n             message = await self.core.create_ticket(context)\n             if message:\n                 await context.send(message)\n \n-    @ticket.command(name='update')\n+    @ticket.command(name=\"update\")\n     async def ticket_update(self, context, *, status: str):\n-        '''\n+        \"\"\"\n         Update the status of a ticket\n-        '''\n+        \"\"\"\n         await self.core.update_ticket(context, status)\n \n-    @ticket.command(name='close')\n+    @ticket.command(name=\"close\")\n     async def ticket_close(self, context):\n-        '''\n+        \"\"\"\n         Close a ticket, must be run in the ticket channel you want to close\n-        '''\n+        \"\"\"\n         await self.core.close_ticket(context)\n \n-    @ticket.group(name='set')\n+    @ticket.group(name=\"set\")\n     @commands.has_permissions(administrator=True)\n     async def ticket_set(self, context):\n-        '''\n+        \"\"\"\n         Settings\n-        '''\n+        \"\"\"\n \n-    @ticket_set.command(name='purge')\n+    @ticket_set.command(name=\"purge\")\n     async def ticket_set_purge(self, context):\n-        '''\n+        \"\"\"\n         Delete all closed tickets\n-        '''\n+        \"\"\"\n         message = await self.core.purge_tickets(context)\n         await context.send(message)\n \n-    @ticket_set.command(name='message')\n+    @ticket_set.command(name=\"message\")\n     @commands.has_permissions(administrator=True)\n     async def ticket_set_message(self, context, *, message: str):\n-        '''\n+        \"\"\"\n         Set the default message when a new ticket has been created (markdown safe)\n-        '''\n+        \"\"\"\n         message = await self.core.set_default_message_ticket_channel(context, message)\n         await context.send(message)\n \n-    @ticket_set.command(name='setup')\n+    @ticket_set.command(name=\"setup\")\n     async def ticket_setup(self, context):\n-        '''\n+        \"\"\"\n         Automatic setup, will create two categories for open and closed tickets, and a ticket role for people to be able to manage tickets.\n-        '''\n+        \"\"\"\n         message = await self.core.automatic_setup(context)\n         await context.send(message)", "file_path": "files/2021_5/602", "file_language": "py", "file_name": "tickets/tickets.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class Tickets(BaseCog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.core = TicketsCore(bot)\n\n    @commands.group(name='ticket')\n    async def ticket(self, context):\n        '''\n        Tickets!\n        '''\n\n    @ticket.command(name='new')\n    async def ticket_new(self, context):\n        '''\n        Create a new ticket\n        '''\n        if context.invoked_subcommand is None:\n            message = await self.core.create_ticket(context)\n            if message:\n                await context.send(message)\n\n    @ticket.command(name='update')\n    async def ticket_update(self, context, *, status: str):\n        '''\n        Update the status of a ticket\n        '''\n        await self.core.update_ticket(context, status)\n\n    @ticket.command(name='close')\n    async def ticket_close(self, context):\n        '''\n        Close a ticket, must be run in the ticket channel you want to close\n        '''\n        await self.core.close_ticket(context)\n\n    @ticket.group(name='set')\n    @commands.has_permissions(administrator=True)\n    async def ticket_set(self, context):\n        '''\n        Settings\n        '''\n\n    @ticket_set.command(name='purge')\n    async def ticket_set_purge(self, context):\n        '''\n        Delete all closed tickets\n        '''\n        message = await self.core.purge_tickets(context)\n        await context.send(message)\n\n    @ticket_set.command(name='message')\n    @commands.has_permissions(administrator=True)\n    async def ticket_set_message(self, context, *, message: str):\n        '''\n        Set the default message when a new ticket has been created (markdown safe)\n        '''\n        message = await self.core.set_default_message_ticket_channel(context, message)\n        await context.send(message)\n\n    @ticket_set.command(name='setup')\n    async def ticket_setup(self, context):\n        '''\n        Automatic setup, will create two categories for open and closed tickets, and a ticket role for people to be able to manage tickets.\n        '''\n        message = await self.core.automatic_setup(context)\n        await context.send(message)", "target": 0}], "function_after": [{"function": "class Tickets(BaseCog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.core = TicketsCore(bot)\n\n    @commands.group(name=\"ticket\")\n    async def ticket(self, context):\n        \"\"\"\n        Tickets!\n        \"\"\"\n\n    @ticket.command(name=\"new\")\n    async def ticket_new(self, context):\n        \"\"\"\n        Create a new ticket\n        \"\"\"\n        if context.invoked_subcommand is None:\n            message = await self.core.create_ticket(context)\n            if message:\n                await context.send(message)\n\n    @ticket.command(name=\"update\")\n    async def ticket_update(self, context, *, status: str):\n        \"\"\"\n        Update the status of a ticket\n        \"\"\"\n        await self.core.update_ticket(context, status)\n\n    @ticket.command(name=\"close\")\n    async def ticket_close(self, context):\n        \"\"\"\n        Close a ticket, must be run in the ticket channel you want to close\n        \"\"\"\n        await self.core.close_ticket(context)\n\n    @ticket.group(name=\"set\")\n    @commands.has_permissions(administrator=True)\n    async def ticket_set(self, context):\n        \"\"\"\n        Settings\n        \"\"\"\n\n    @ticket_set.command(name=\"purge\")\n    async def ticket_set_purge(self, context):\n        \"\"\"\n        Delete all closed tickets\n        \"\"\"\n        message = await self.core.purge_tickets(context)\n        await context.send(message)\n\n    @ticket_set.command(name=\"message\")\n    @commands.has_permissions(administrator=True)\n    async def ticket_set_message(self, context, *, message: str):\n        \"\"\"\n        Set the default message when a new ticket has been created (markdown safe)\n        \"\"\"\n        message = await self.core.set_default_message_ticket_channel(context, message)\n        await context.send(message)\n\n    @ticket_set.command(name=\"setup\")\n    async def ticket_setup(self, context):\n        \"\"\"\n        Automatic setup, will create two categories for open and closed tickets, and a ticket role for people to be able to manage tickets.\n        \"\"\"\n        message = await self.core.automatic_setup(context)\n        await context.send(message)", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
