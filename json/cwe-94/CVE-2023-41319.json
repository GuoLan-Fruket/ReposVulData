{"index": 12375, "cve_id": "CVE-2023-41319", "cwe_id": ["CWE-94", "CWE-693"], "cve_language": "Python", "cve_description": "Fides is an open-source privacy engineering platform for managing the fulfillment of data privacy requests in a runtime environment, and the enforcement of privacy regulations in code. The Fides webserver API allows custom integrations to be uploaded as a ZIP file. This ZIP file must contain YAML files, but Fides can be configured to also accept the inclusion of custom Python code in it. The custom code is executed in a restricted, sandboxed environment, but the sandbox can be bypassed to execute any arbitrary code. The vulnerability allows the execution of arbitrary code on the target system within the context of the webserver python process owner on the webserver container, which by default is `root`, and leverage that access to attack underlying infrastructure and integrated systems. This vulnerability affects Fides versions `2.11.0` through `2.19.0`. Exploitation is limited to API clients with the `CONNECTOR_TEMPLATE_REGISTER` authorization scope. In the Fides Admin UI this scope is restricted to highly privileged users, specifically root users and users with the owner role.  Exploitation is only possible if the security configuration parameter `allow_custom_connector_functions` is enabled by the user deploying the Fides webserver container, either in `fides.toml` or by setting the env var `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS=True`. By default this configuration parameter is disabled. The vulnerability has been patched in Fides version `2.19.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. Users unable to upgrade should ensure that `allow_custom_connector_functions` in `fides.toml` and the `FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS` are both either unset or explicit set to `False`.", "cvss": "7.2", "publish_date": "September 6, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "HIGH", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "5989b5fa744c8d8c340963b895a054883549358a", "commit_message": "Merge pull request from GHSA-p6p2-qq95-vq5h\n\n* Removing custom connector template functions\n\n* Updating connector template modal description\n\n* Adding function upload tests", "commit_date": "2023-09-05T19:51:11Z", "project": "ethyca/fides", "url": "https://api.github.com/repos/ethyca/fides/commits/5989b5fa744c8d8c340963b895a054883549358a", "html_url": "https://github.com/ethyca/fides/commit/5989b5fa744c8d8c340963b895a054883549358a", "windows_before": [{"commit_id": "993bf883acf9d1261a2eee3d1fe3871089bd4b5f", "commit_date": "Tue Sep 5 11:53:17 2023 -0700", "commit_message": "Updating labels (#3955)", "files_name": ["src/fides/api/models/messaging_template.py"]}, {"commit_id": "4ef29e605ac7d1da1c6ddc0ec1dab0b353e2ab8e", "commit_date": "Tue Sep 5 13:31:54 2023 -0400", "commit_message": "Re-enable 'cookies' field in privacy declaration form (#4025)", "files_name": ["clients/admin-ui/src/features/system/privacy-declarations/PrivacyDeclarationStep.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationForm.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormTab.tsx"]}, {"commit_id": "a316bbdb9c669e9c69097c3f16a778440568d3ba", "commit_date": "Tue Sep 5 13:08:09 2023 -0400", "commit_message": "update with docs link and tooltips (#4027)", "files_name": ["4c9206f1bcebc35bd3b2459ad6b109ff3c29abbc - Tue Sep 5 11:21:42 2023 -0400 : update with docs link and tooltips", "data/saas/config/adobe_sign_config.yml"]}, {"commit_id": "1449f5dc16a0cd57ab3282f55462e8e74a16dc1b", "commit_date": "Tue Sep 5 13:14:45 2023 +0800", "commit_message": "Add profiling/benchmarks to CI suite (#3997)", "files_name": [".github/workflows/backend_checks.yml", "CHANGELOG.md", "docs/fides/docs/development/development_tips.md", "noxfiles/ci_nox.py", "noxfiles/drill.yml", "requirements.txt", "src/fides/api/main.py"]}, {"commit_id": "06f2fe810271d256866aeb860a3ffdece336b4b6", "commit_date": "Fri Sep 1 17:54:15 2023 -0700", "commit_message": "System history UI (#4019)", "files_name": ["clients/admin-ui/src/features/common/api.slice.ts", "clients/admin-ui/src/features/plus/plus.slice.ts", "clients/admin-ui/src/features/system/SystemFormTabs.tsx", "clients/admin-ui/src/features/system/history/SystemHistoryTable.tsx", "clients/admin-ui/src/features/system/system.slice.ts", "clients/admin-ui/src/types/api/models/SystemHistory.ts", "clients/admin-ui/src/types/api/models/SystemHistoryResponse.ts", "clients/admin-ui/src/types/api/models/SystemResponse.ts", "tests/ops/api/v1/endpoints/test_system.py"]}, {"commit_id": "a33952963b8b5823f457492fbfb0b9088df4b422", "commit_date": "Fri Sep 1 16:09:08 2023 -0700", "commit_message": "Revert \"Fix Parallel Docker Platform Builds (#4013)\" (#4018)", "files_name": [".github/workflows/publish_docker.yaml", "CHANGELOG.md", "noxfiles/docker_nox.py", "noxfiles/test_docker_nox.py"]}, {"commit_id": "6a19f82acf99c0d1ae3981ca700e6c26cd91daae", "commit_date": "Fri Sep 1 17:21:14 2023 -0400", "commit_message": "publish rc images to PyPI (#4016)", "files_name": [".github/workflows/publish_package.yaml"]}, {"commit_id": "d99c45667cf0adfa9f64c736abb11d8a64a3c52a", "commit_date": "Fri Sep 1 12:00:29 2023 -0700", "commit_message": "Track and report system changes (#3990)", "files_name": [".fides/db_dataset.yml", "src/fides/api/alembic/migrations/versions/093bb28a8270_add_plus_system_history_table.py", "src/fides/api/api/v1/endpoints/system.py", "src/fides/api/db/base.py", "src/fides/api/db/system.py", "src/fides/api/models/sql_models.py", "src/fides/api/models/system_history.py", "src/fides/api/schemas/system.py", "tests/ctl/core/test_api.py", "tests/ctl/core/test_system_history.py", "tests/ops/api/v1/endpoints/test_system.py"]}, {"commit_id": "95ca9191d01d434ded31dc5a6cbe0a507be5f487", "commit_date": "Sat Sep 2 00:26:46 2023 +0800", "commit_message": "Fix Parallel Docker Platform Builds (#4013)", "files_name": [".github/workflows/publish_docker.yaml", "CHANGELOG.md", "noxfiles/docker_nox.py", "noxfiles/test_docker_nox.py"]}, {"commit_id": "fc99e09f57651b10ead58ec546c9117ab3fd5f91", "commit_date": "Fri Sep 1 12:03:24 2023 -0400", "commit_message": "Facelift for scanner forms (#4012)", "files_name": ["clients/admin-ui/src/features/config-wizard/AuthenticateAwsForm.tsx", "clients/admin-ui/src/features/config-wizard/AuthenticateOktaForm.tsx"]}, {"commit_id": "309b86686e91adff3dbee5e00125d8d78cbd23bc", "commit_date": "Fri Sep 1 18:52:55 2023 +0800", "commit_message": "Fix tests that relied on specific Pagination responses (#4015)", "files_name": ["tests/ops/api/v1/endpoints/test_messaging_endpoints.py", "tests/ops/api/v1/endpoints/test_policy_webhook_endpoints.py", "tests/ops/api/v1/endpoints/test_privacy_preference_endpoints.py", "tests/ops/api/v1/endpoints/test_privacy_request_endpoints.py", "tests/ops/api/v1/endpoints/test_storage_endpoints.py"]}, {"commit_id": "f72d0dd54d3faf160104d69624ce92d7c1b712b5", "commit_date": "Fri Sep 1 12:15:08 2023 +0800", "commit_message": "fix: pylint (#4014)", "files_name": ["src/fides/api/api/v1/endpoints/admin.py"]}, {"commit_id": "e933216a51991e2c172a4a4fd6b39e2da26e3880", "commit_date": "Fri Sep 1 11:29:44 2023 +0800", "commit_message": "feat: update the admin db endpoint to return a proper response", "files_name": ["src/fides/api/api/v1/endpoints/admin.py", "tests/ctl/api/test_admin.py"]}, {"commit_id": "d855a80c8a27ed4bd79378bae7d7c53e2fd42821", "commit_date": "Fri Sep 1 11:29:20 2023 +0800", "commit_message": "feat: bump and pin a few requirements", "files_name": ["requirements.txt"]}, {"commit_id": "633e5547000174df5384522642cd52fac8529aff", "commit_date": "Fri Sep 1 00:14:08 2023 +0200", "commit_message": "Rely on client to detect new notices for prefetched experiences (#4009)", "files_name": ["CHANGELOG.md", "clients/fides-js/src/fides.ts", "clients/fides-js/src/lib/cookie.ts", "clients/fides-js/src/services/fides/api.ts", "clients/privacy-center/pages/api/fides-js.ts"]}, {"commit_id": "194005ad86517e0578c753a57fd122329ceab241", "commit_date": "Thu Aug 31 12:54:16 2023 -0400", "commit_message": "fix issue with unsaved changes modal (#4005)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/common/hooks/useIsAnyFormDirty.tsx", "clients/admin-ui/src/features/datamap/datamap-drawer/SystemInfo.tsx", "clients/admin-ui/src/features/system/SystemFormTabs.tsx", "clients/admin-ui/src/features/system/SystemInformationForm.tsx", "clients/admin-ui/src/features/system/UnmountWarning.tsx", "clients/admin-ui/src/features/system/form.ts"]}, {"commit_id": "2879f1c2caea3fa917179272e56edc14a512fe57", "commit_date": "Thu Aug 31 11:50:13 2023 -0400", "commit_message": "Remove reset suggestions from dictionary toggle (#4007)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/plus/plus.slice.ts", "clients/admin-ui/src/features/system/SystemInformationForm.tsx", "clients/admin-ui/src/features/system/dictionary-form/DictSuggestionInputs.tsx", "clients/admin-ui/src/features/system/dictionary-form/ToggleDictSuggestions.tsx", "clients/admin-ui/src/features/system/dictionary-form/dict-suggestion.context.tsx"]}, {"commit_id": "56955c8acfa1613671ae253b13d6fb99f22db92e", "commit_date": "Wed Aug 30 15:45:07 2023 -0700", "commit_message": "Updated CHANGELOG.md for release 2.19.0 (#4002)", "files_name": ["CHANGELOG.md"]}, {"commit_id": "20a479c2ae02c9dabd355233b46f18623c07ae20", "commit_date": "Wed Aug 30 14:39:46 2023 -0700", "commit_message": "Fixing email template variables (#3973)", "files_name": ["src/fides/api/service/messaging/message_dispatch_service.py", "tests/ops/service/messaging/message_dispatch_service_test.py"]}, {"commit_id": "ff8dab95b7e95a9d54cd508e0a09af9140c43138", "commit_date": "Thu Aug 31 01:19:28 2023 +0800", "commit_message": "Update PyMSSQL (#3996)", "files_name": ["CHANGELOG.md", "Dockerfile", "MANIFEST.in", "dangerous-requirements.txt", "noxfiles/ci_nox.py", "noxfiles/utils_nox.py", "requirements.txt", "setup.py", "src/fides/api/main.py"]}, {"commit_id": "ebf326377da8aac9a1892ae4f151d1df79264984", "commit_date": "Tue Aug 29 12:32:42 2023 -0400", "commit_message": "Sfdc connector label updates (#3983)", "files_name": ["data/saas/config/salesforce_config.yml"]}, {"commit_id": "b07cf87cfb95185aed7815597f7e42a6a487dfad", "commit_date": "Tue Aug 29 10:46:14 2023 -0400", "commit_message": "fides - update system.legal_basis_for_transfers and system.legal_basis_for_profiling (#3977)", "files_name": ["requirements.txt", "src/fides/api/alembic/migrations/versions/3038667ba898_update_system_legal_basis_fields.py", "src/fides/api/models/sql_models.py", "tests/ctl/core/test_api.py"]}, {"commit_id": "1e66560d2cc5edbeeec228864f4635e9fbd40594", "commit_date": "Mon Aug 28 14:02:19 2023 -0700", "commit_message": "Add dictionary suggest select and toggle switch (#3988)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/plus/types.ts", "clients/admin-ui/src/features/system/SystemInformationForm.tsx", "clients/admin-ui/src/features/system/SystemInformationFormSelectOptions.ts", "clients/admin-ui/src/features/system/dictionary-form/DictSuggestionInputs.tsx"]}, {"commit_id": "6ca4451e9de70c5d316316cbe019fe9353f3e566", "commit_date": "Mon Aug 28 09:37:30 2023 -0700", "commit_message": "releases hotfixes (#3970)", "files_name": ["clients/admin-ui/src/features/common/form/inputs.tsx", "clients/admin-ui/src/features/system/SystemInformationForm.tsx", "clients/admin-ui/src/features/system/dictionary-form/DictSuggestionTextInput.tsx", "clients/admin-ui/src/features/system/dictionary-form/ToggleDictSuggestions.tsx"]}, {"commit_id": "9854b0dfc3f23fb886248a7640476084e9d3ef99", "commit_date": "Mon Aug 28 09:07:42 2023 -0700", "commit_message": "Privacy declaration form fixes (#3980)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/common/form/inputs.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationForm.tsx"]}, {"commit_id": "c628efc1f2841b89002d8326f53785c4c7324dd6", "commit_date": "Fri Aug 25 11:10:59 2023 -0700", "commit_message": "Fix some variables not submitting correctly in system form (#3975)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/system/form.ts"]}, {"commit_id": "e136ac60e286d02dd1cf65131ccc8b7fd5a2071e", "commit_date": "Wed Aug 23 09:12:18 2023 -0700", "commit_message": "Removing invalid characters from system name (#3971)", "files_name": ["clients/admin-ui/src/features/datastore-connections/system_portal_config/helpers.ts"]}, {"commit_id": "955ed4ddfa0787d41d2bc1ece666ed46ec9710c5", "commit_date": "Wed Aug 23 04:29:41 2023 +0800", "commit_message": "Log Server Setup/Startup Time (#3958)", "files_name": ["src/fides/api/main.py"]}, {"commit_id": "a2c147500e4bedb27410fa760af6c2dc1358efb1", "commit_date": "Tue Aug 22 12:10:24 2023 -0700", "commit_message": "Hiding unique ID field on system creation (#3969)", "files_name": ["clients/admin-ui/src/features/system/SystemInformationForm.tsx"]}, {"commit_id": "00ee35ff1425345dbfe5a1d56f582dce3b93cac2", "commit_date": "Tue Aug 22 12:03:22 2023 -0700", "commit_message": "Fixing connector field labels (#3967)", "files_name": ["data/saas/config/adobe_sign_config.yml", "data/saas/config/aircall_config.yml", "data/saas/config/amplitude_config.yml", "data/saas/config/auth0_config.yml", "data/saas/config/braintree_config.yml", "data/saas/config/datadog_config.yml", "data/saas/config/delighted_config.yml", "data/saas/config/domo_config.yml", "data/saas/config/doordash_config.yml", "data/saas/config/firebase_auth_config.yml", "data/saas/config/friendbuy_config.yml", "data/saas/config/friendbuy_nextgen_config.yml", "data/saas/config/fullstory_config.yml", "data/saas/config/google_analytics_config.yml", "data/saas/config/gorgias_config.yml", "data/saas/config/heap_config.yml", "data/saas/config/hubspot_config.yml", "data/saas/config/jira_config.yml", "data/saas/config/klaviyo_config.yml", "data/saas/config/kustomer_config.yml", "data/saas/config/mailchimp_config.yml", "data/saas/config/mailchimp_transactional_config.yml", "data/saas/config/onesignal_config.yml", "data/saas/config/outreach_config.yml", "data/saas/config/recharge_config.yml"]}], "windows_after": [{"commit_id": "0e93f5af923d034d35a2d89f17aef66cf9e3eafb", "commit_date": "Thu Sep 7 14:35:55 2023 -0400", "commit_message": "Add dictionary data use UI (#4035)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/plus/plus.slice.ts", "clients/admin-ui/src/features/plus/types.ts", "clients/admin-ui/src/features/system/dictionary-data-uses/DataUseCheckboxTable.tsx", "clients/admin-ui/src/features/system/dictionary-data-uses/EmptyTableState.tsx", "clients/admin-ui/src/features/system/dictionary-data-uses/PrivacyDeclarationDictModalComponents.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationDisplayGroup.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormModal.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormTab.tsx"]}, {"commit_id": "29c5f36c62f27667632d639013dcfaf6a6920af9", "commit_date": "Fri Sep 8 10:38:31 2023 +0800", "commit_message": "Bump gitpython from 3.1.31 to 3.1.35 (#4041)", "files_name": ["dev-requirements.txt", "requirements.txt"]}, {"commit_id": "77bc38168afeb943440a0857be972c8c19701cc3", "commit_date": "Fri Sep 8 16:10:18 2023 -0400", "commit_message": "re-enable custom fields for new data use form (#4050)", "files_name": ["clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationForm.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormTab.tsx"]}, {"commit_id": "925867353e10be247e7305fb0884bee6826a11fb", "commit_date": "Fri Sep 8 16:05:29 2023 -0500", "commit_message": "Fides: Relax Legal Basis for Transfers (#4049)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/system/SystemInformationFormSelectOptions.ts", "requirements.txt", "tests/ctl/core/test_api.py"]}, {"commit_id": "4572b0c433227510e69f7e9823a93c557ee12a65", "commit_date": "Sun Sep 10 21:40:59 2023 -0700", "commit_message": "System history UI with diff modal (#4021)", "files_name": ["clients/admin-ui/src/features/common/Icon/NextArrow.tsx", "clients/admin-ui/src/features/common/Icon/PrevArrow.tsx", "clients/admin-ui/src/features/plus/plus.slice.ts", "clients/admin-ui/src/features/system/SystemFormTabs.tsx", "clients/admin-ui/src/features/system/history/SystemHistoryTable.tsx", "clients/admin-ui/src/features/system/history/modal/SelectedHistoryContext.tsx", "clients/admin-ui/src/features/system/history/modal/SystemDataForm.tsx", "clients/admin-ui/src/features/system/history/modal/SystemDataGroup.tsx", "clients/admin-ui/src/features/system/history/modal/SystemHistoryModal.tsx", "clients/admin-ui/src/features/system/history/modal/fields/SystemDataSwitch.tsx", "clients/admin-ui/src/features/system/history/modal/fields/SystemDataTags.tsx", "clients/admin-ui/src/features/system/history/modal/fields/SystemDataTextField.tsx", "clients/admin-ui/src/types/api/models/SystemHistory.ts"]}, {"commit_id": "914161a359170172a372ab991b07f42b7d027b8a", "commit_date": "Sun Sep 10 22:45:14 2023 -0700", "commit_message": "Pinning anyio version to 3.7.1 to avoid using PEP 654 ExceptionGroups (#4061)", "files_name": ["requirements.txt"]}, {"commit_id": "755075bf83b482e825d7add7a6bdffce47d067e6", "commit_date": "Mon Sep 11 05:35:15 2023 -0700", "commit_message": "Changelog 2.19.1 (#4064)", "files_name": ["CHANGELOG.md"]}, {"commit_id": "cc8dba9141f7c269dbcb6ab5c75b7b7134b08030", "commit_date": "Mon Sep 11 22:24:39 2023 +0800", "commit_message": "Build Multiplatform Images Simultaneously (#4024)", "files_name": [".github/workflows/publish_docker.yaml", "CHANGELOG.md", "noxfiles/docker_nox.py", "noxfiles/test_docker_nox.py"]}, {"commit_id": "666983c619eafdc575325d1cd9ee83fb1f60a293", "commit_date": "Mon Sep 11 08:26:57 2023 -0700", "commit_message": "write to system.vendor_id (#4038)", "files_name": ["clients/admin-ui/cypress/e2e/systems-plus.cy.ts", "clients/admin-ui/cypress/e2e/systems.cy.ts", "clients/admin-ui/src/features/system/SystemInformationForm.tsx", "clients/admin-ui/src/features/system/dictionary-form/DictSuggestionInputs.tsx", "clients/admin-ui/src/features/system/dictionary-form/ToggleDictSuggestions.tsx", "clients/admin-ui/src/features/system/form.ts"]}, {"commit_id": "bd9d6070196451c830e48960433c1e0bee38208b", "commit_date": "Mon Sep 11 12:13:54 2023 -0400", "commit_message": "Human readable locations (#4029)", "files_name": ["CHANGELOG.md", "clients/admin-ui/cypress/e2e/privacy-experiences.cy.ts", "clients/admin-ui/cypress/e2e/privacy-notices.cy.ts", "clients/admin-ui/src/features/common/privacy-notice-regions.ts", "clients/admin-ui/src/features/common/table/cells.tsx", "clients/admin-ui/src/features/privacy-experience/cells.tsx", "clients/admin-ui/src/features/privacy-notices/PrivacyNoticeForm.tsx", "clients/admin-ui/src/features/privacy-notices/PrivacyNoticesTable.tsx", "clients/admin-ui/src/features/privacy-notices/cells.tsx"]}, {"commit_id": "53ef7391f31f2baba6b2cf330c37c0314c395476", "commit_date": "Mon Sep 11 13:59:59 2023 -0400", "commit_message": "Fix data flow saving issue (#4065)", "files_name": ["CHANGELOG.md", "clients/admin-ui/src/features/system/form.ts", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormTab.tsx"]}, {"commit_id": "c85153081733b1b3b88686aadfb3dc50d5d429d7", "commit_date": "Mon Sep 11 14:42:51 2023 -0400", "commit_message": "Update displaying privacy notices logic (#4010)", "files_name": ["CHANGELOG.md", "clients/admin-ui/cypress/e2e/privacy-notices.cy.ts", "clients/admin-ui/cypress/fixtures/privacy-notices/list.json", "clients/admin-ui/src/features/common/table/cells.tsx", "clients/admin-ui/src/features/privacy-notices/PrivacyNoticesTable.tsx", "clients/admin-ui/src/features/privacy-notices/cells.tsx", "clients/admin-ui/src/features/privacy-notices/privacy-notices.slice.ts", "clients/admin-ui/src/types/api/index.ts", "clients/admin-ui/src/types/api/models/BulkPutMessagingTemplateResponse.ts", "clients/admin-ui/src/types/api/models/CoreHealthCheck.ts", "clients/admin-ui/src/types/api/models/DatabaseHealthCheck.ts", "clients/admin-ui/src/types/api/models/LegalBasisForTransfersEnum.ts", "clients/admin-ui/src/types/api/models/MessagingTemplateRequest.ts", "clients/admin-ui/src/types/api/models/MessagingTemplateResponse.ts", "clients/admin-ui/src/types/api/models/PrivacyNoticeResponse.ts", "clients/admin-ui/src/types/api/models/PrivacyNoticeResponseWithUserPreferences.ts", "clients/admin-ui/src/types/api/models/SaaSConfig.ts", "clients/admin-ui/src/types/api/models/System.ts", "clients/admin-ui/src/types/api/models/SystemResponse.ts", "clients/admin-ui/src/types/api/models/WorkerHealthCheck.ts", "src/fides/api/models/privacy_notice.py", "src/fides/api/schemas/privacy_notice.py", "src/fides/data/privacy_notices/privacy_notice_templates.yml", "tests/ops/api/v1/endpoints/test_privacy_experience_endpoints.py", "tests/ops/api/v1/endpoints/test_privacy_notice_endpoints.py"]}, {"commit_id": "d2264b4e12a794b55ac8cf5aef6ee7460b43e5fc", "commit_date": "Mon Sep 11 14:58:34 2023 -0500", "commit_message": "Case-Insensitive Privacy Experience Region Filtering (#4058)", "files_name": ["CHANGELOG.md", "src/fides/api/api/v1/endpoints/privacy_experience_endpoints.py", "tests/ops/api/v1/endpoints/test_privacy_experience_endpoints.py"]}, {"commit_id": "929cdae33dfdff063aad9b512c0e2ef91d82b799", "commit_date": "Mon Sep 11 13:20:13 2023 -0700", "commit_message": "Fixing diff modal (#4068)", "files_name": ["clients/admin-ui/src/features/system/history/modal/SystemHistoryModal.tsx", "clients/admin-ui/src/features/system/history/modal/fields/SystemDataSwitch.tsx", "clients/admin-ui/src/features/system/system-form-declaration-tab/PrivacyDeclarationFormTab.tsx"]}, {"commit_id": "267e35b23a7ba1429d7020d8ab0d20586572fe83", "commit_date": "Tue Sep 12 13:10:46 2023 +0100", "commit_message": "docs: add security advisory (CVE-2023-41319) to 2.19.0 changelog (#4031)", "files_name": ["CHANGELOG.md"]}, {"commit_id": "2f9019256c9f38b2369bf0589bd0587c2d42dc57", "commit_date": "Tue Sep 12 09:29:58 2023 -0400", "commit_message": "Fides Cloud Configuration: DNS Record and Privacy Center URL (#4034)", "files_name": [".fides/db_dataset.yml", "CHANGELOG.md", "clients/admin-ui/src/features/common/api.slice.ts", "clients/admin-ui/src/features/common/features/features.slice.ts", "clients/admin-ui/src/features/common/nav/v2/hooks.ts", "clients/admin-ui/src/features/common/nav/v2/nav-config.test.ts", "clients/admin-ui/src/features/common/nav/v2/nav-config.ts", "clients/admin-ui/src/features/common/nav/v2/routes.ts", "clients/admin-ui/src/features/common/table/FidesTable.tsx", "clients/admin-ui/src/features/common/table/cells.tsx", "clients/admin-ui/src/features/plus/plus.slice.ts", "clients/admin-ui/src/features/privacy-experience/JavaScriptTag.tsx", "clients/admin-ui/src/features/system/history/SystemHistoryTable.tsx", "clients/admin-ui/src/features/system/history/modal/SelectedHistoryContext.tsx", "clients/admin-ui/src/features/system/history/modal/SystemHistoryModal.tsx", "clients/admin-ui/src/pages/management/dns-records.tsx", "clients/admin-ui/src/types/api/index.ts", "clients/admin-ui/src/types/api/models/CloudConfig.ts", "clients/admin-ui/src/types/api/models/FidesCloudStatus.ts", "clients/admin-ui/src/types/api/models/HealthCheck.ts", "clients/admin-ui/src/types/api/models/Page_ConnectionConfigurationResponse_.ts", "clients/admin-ui/src/types/api/models/Page_ConnectionSystemTypeMap_.ts", "clients/admin-ui/src/types/api/models/Page_ConsentReport_.ts", "clients/admin-ui/src/types/api/models/Page_ConsentReportingSchema_.ts", "clients/admin-ui/src/types/api/models/Page_CurrentPrivacyPreferenceReportingSchema_.ts", "clients/admin-ui/src/types/api/models/Page_CurrentPrivacyPreferenceSchema_.ts", "clients/admin-ui/src/types/api/models/Page_DatasetConfigSchema_.ts", "clients/admin-ui/src/types/api/models/Page_Dataset_.ts", "clients/admin-ui/src/types/api/models/Page_ExecutionLogDetailResponse_.ts", "clients/admin-ui/src/types/api/models/Page_ExperienceConfigResponse_.ts", "clients/admin-ui/src/types/api/models/Page_MessagingConfigResponse_.ts", "clients/admin-ui/src/types/api/models/Page_PolicyResponse_.ts", "clients/admin-ui/src/types/api/models/Page_PolicyWebhookResponse_.ts", "clients/admin-ui/src/types/api/models/Page_PrivacyExperienceResponse_.ts", "clients/admin-ui/src/types/api/models/Page_PrivacyNoticeResponse_.ts", "clients/admin-ui/src/types/api/models/Page_RuleResponseWithTargets_.ts", "clients/admin-ui/src/types/api/models/Page_RuleTarget_.ts", "clients/admin-ui/src/types/api/models/Page_StorageDestinationResponse_.ts", "clients/admin-ui/src/types/api/models/Page_SystemHistoryResponse_.ts", "clients/admin-ui/src/types/api/models/Page_Union_PrivacyRequestVerboseResponse__PrivacyRequestResponse__.ts", "clients/admin-ui/src/types/api/models/Page_UserResponse_.ts", "clients/admin-ui/src/types/api/models/ScopeRegistryEnum.ts", "clients/admin-ui/src/types/api/models/SystemHistoryResponse.ts", "src/fides/api/alembic/migrations/versions/192f23f4c968_add_fides_cloud_table.py", "src/fides/api/db/base.py", "src/fides/api/models/fides_cloud.py"]}, {"commit_id": "b188e564d9ccb00a214d1c77e9c4993c7076b75e", "commit_date": "Tue Sep 12 11:46:33 2023 -0400", "commit_message": "Right align and vertically center clipboard button (#4071)", "files_name": ["clients/admin-ui/src/features/privacy-experience/JavaScriptTag.tsx"]}, {"commit_id": "b324612adece70ccd18659c48d8a80455ceb7e6c", "commit_date": "Tue Sep 12 21:41:41 2023 +0200", "commit_message": "Do not load fetch polyfill if fetch is detected (#4074)", "files_name": ["CHANGELOG.md", "clients/privacy-center/pages/api/fides-js.ts"]}, {"commit_id": "7f53a75654ffadcefd3746e12797dbaf740188eb", "commit_date": "Tue Sep 12 21:41:50 2023 +0200", "commit_message": "Adds important CSS override to display fides toggles (#4075)", "files_name": ["CHANGELOG.md", "clients/fides-js/src/components/fides.css"]}, {"commit_id": "b48ed604af59b4c76862acbd91204dbb8d7e0440", "commit_date": "Wed Sep 13 14:50:21 2023 -0400", "commit_message": "Scaffold consent config page (#4069)", "files_name": ["CHANGELOG.md", "clients/admin-ui/cypress/e2e/consent-configuration.cy.ts", "clients/admin-ui/src/features/common/nav/v2/nav-config.ts", "clients/admin-ui/src/features/common/nav/v2/routes.ts", "clients/admin-ui/src/features/common/table/EmptyTableState.tsx", "clients/admin-ui/src/features/configure-consent/AddCookie.tsx", "clients/admin-ui/src/features/configure-consent/AddModal.tsx", "clients/admin-ui/src/features/configure-consent/AddVendor.tsx", "clients/admin-ui/src/features/configure-consent/ConfigureConsent.tsx", "clients/admin-ui/src/flags.json", "clients/admin-ui/src/home/HomeContent.tsx", "clients/admin-ui/src/home/constants.ts", "clients/admin-ui/src/home/tile-config.test.ts"]}], "parents": [{"commit_id_before": "993bf883acf9d1261a2eee3d1fe3871089bd4b5f", "url_before": "https://api.github.com/repos/ethyca/fides/commits/993bf883acf9d1261a2eee3d1fe3871089bd4b5f", "html_url_before": "https://github.com/ethyca/fides/commit/993bf883acf9d1261a2eee3d1fe3871089bd4b5f"}], "details": [{"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/clients%2Fadmin-ui%2Fsrc%2Ffeatures%2Fconnector-templates%2FConnectorTemplateUploadModal.tsx", "code": "import {\n  Box,\n  Button,\n  ButtonGroup,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n  Text,\n  useToast,\n} from \"@fidesui/react\";\nimport { FetchBaseQueryError } from \"@reduxjs/toolkit/dist/query/fetchBaseQuery\";\nimport React, { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useDispatch } from \"react-redux\";\n\nimport { getErrorMessage } from \"~/features/common/helpers\";\nimport { errorToastParams, successToastParams } from \"~/features/common/toast\";\nimport {\n  setConnectionOptions,\n  useGetAllConnectionTypesQuery,\n} from \"~/features/connection-type\";\n\nimport { useRegisterConnectorTemplateMutation } from \"./connector-template.slice\";\n\ntype RequestModalProps = {\n  isOpen: boolean;\n  onClose: () => void;\n  testId?: String;\n};\n\nconst ConnectorTemplateUploadModal: React.FC<RequestModalProps> = ({\n  isOpen,\n  onClose,\n  testId = \"connector-template-modal\",\n}) => {\n  const dispatch = useDispatch();\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const toast = useToast();\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: (acceptedFiles: File[]) => {\n      const file = acceptedFiles[0];\n      const fileExtension = file.name.split(\".\").pop()?.toLowerCase();\n\n      if (fileExtension !== \"zip\") {\n        toast(errorToastParams(\"Only zip files are allowed.\"));\n        return;\n      }\n\n      setUploadedFile(acceptedFiles[0]);\n    },\n  });\n\n  const [registerConnectorTemplate, { isLoading }] =\n    useRegisterConnectorTemplateMutation();\n  const { refetch: refetchConnectionTypes } = useGetAllConnectionTypesQuery(\n    {\n      search: \"\",\n    },\n    {\n      skip: false,\n    }\n  );\n\n  const handleSubmit = async () => {\n    if (uploadedFile) {\n      try {\n        await registerConnectorTemplate(uploadedFile).unwrap();\n        toast(\n          successToastParams(\"Integration template uploaded successfully.\")\n        );\n\n        // refresh the connection types\n        const { data } = await refetchConnectionTypes();\n        dispatch(setConnectionOptions(data?.items ?? []));\n        onClose();\n      } catch (error) {\n        toast(errorToastParams(getErrorMessage(error as FetchBaseQueryError)));\n      } finally {\n        setUploadedFile(null);\n      }\n    }\n  };\n\n  const renderFileText = () => {\n    if (uploadedFile) {\n      return <Text>{uploadedFile.name}</Text>;\n    }\n    if (isDragActive) {\n      return <Text>Drop the file here...</Text>;\n    }\n    return <Text>Click or drag and drop your file here.</Text>;\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} size=\"2xl\">\n      <ModalOverlay />\n      <ModalContent textAlign=\"left\" p={2} data-testid={testId}>\n        <ModalHeader>Upload integration template</ModalHeader>\n        <ModalBody>\n          <Text fontSize=\"sm\" mb={4}>\n            Drag and drop your integration template zip file here, or click to\n            browse your files.\n          </Text>\n          <Box\n            {...getRootProps()}\n            bg={isDragActive ? \"gray.100\" : \"gray.50\"}\n            border=\"2px dashed\"\n            borderColor={isDragActive ? \"gray.300\" : \"gray.200\"}\n            borderRadius=\"md\"\n            cursor=\"pointer\"\n            minHeight=\"150px\"\n            display=\"flex\"\n            alignItems=\"center\"\n            justifyContent=\"center\"\n            textAlign=\"center\"\n          >\n            <input {...getInputProps()} />\n            {renderFileText()}\n          </Box>\n          <Text fontSize=\"sm\" mt={4}>\n            An integration template zip file must include a SaaS config and\n            dataset, but may also contain an icon (.svg) as an optional file.\n          </Text>\n        </ModalBody>\n        <ModalFooter>\n          <ButtonGroup\n            size=\"sm\"\n            spacing=\"2\"\n            width=\"100%\"\n            display=\"flex\"\n            justifyContent=\"right\"\n          >\n            <Button\n              variant=\"outline\"\n              onClick={onClose}\n              data-testid=\"cancel-btn\"\n              isDisabled={isLoading}\n            >\n              Cancel\n            </Button>\n            <Button\n              colorScheme=\"primary\"\n              type=\"submit\"\n              isDisabled={!uploadedFile || isLoading}\n              onClick={handleSubmit}\n              data-testid=\"submit-btn\"\n            >\n              Submit\n            </Button>\n          </ButtonGroup>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n};\n\nexport default ConnectorTemplateUploadModal;\n", "code_before": "import {\n  Box,\n  Button,\n  ButtonGroup,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n  Text,\n  useToast,\n} from \"@fidesui/react\";\nimport { FetchBaseQueryError } from \"@reduxjs/toolkit/dist/query/fetchBaseQuery\";\nimport React, { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useDispatch } from \"react-redux\";\n\nimport { getErrorMessage } from \"~/features/common/helpers\";\nimport { errorToastParams, successToastParams } from \"~/features/common/toast\";\nimport {\n  setConnectionOptions,\n  useGetAllConnectionTypesQuery,\n} from \"~/features/connection-type\";\n\nimport { useRegisterConnectorTemplateMutation } from \"./connector-template.slice\";\n\ntype RequestModalProps = {\n  isOpen: boolean;\n  onClose: () => void;\n  testId?: String;\n};\n\nconst ConnectorTemplateUploadModal: React.FC<RequestModalProps> = ({\n  isOpen,\n  onClose,\n  testId = \"connector-template-modal\",\n}) => {\n  const dispatch = useDispatch();\n  const [uploadedFile, setUploadedFile] = useState<File | null>(null);\n  const toast = useToast();\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop: (acceptedFiles: File[]) => {\n      const file = acceptedFiles[0];\n      const fileExtension = file.name.split(\".\").pop()?.toLowerCase();\n\n      if (fileExtension !== \"zip\") {\n        toast(errorToastParams(\"Only zip files are allowed.\"));\n        return;\n      }\n\n      setUploadedFile(acceptedFiles[0]);\n    },\n  });\n\n  const [registerConnectorTemplate, { isLoading }] =\n    useRegisterConnectorTemplateMutation();\n  const { refetch: refetchConnectionTypes } = useGetAllConnectionTypesQuery(\n    {\n      search: \"\",\n    },\n    {\n      skip: false,\n    }\n  );\n\n  const handleSubmit = async () => {\n    if (uploadedFile) {\n      try {\n        await registerConnectorTemplate(uploadedFile).unwrap();\n        toast(\n          successToastParams(\"Integration template uploaded successfully.\")\n        );\n\n        // refresh the connection types\n        const { data } = await refetchConnectionTypes();\n        dispatch(setConnectionOptions(data?.items ?? []));\n        onClose();\n      } catch (error) {\n        toast(errorToastParams(getErrorMessage(error as FetchBaseQueryError)));\n      } finally {\n        setUploadedFile(null);\n      }\n    }\n  };\n\n  const renderFileText = () => {\n    if (uploadedFile) {\n      return <Text>{uploadedFile.name}</Text>;\n    }\n    if (isDragActive) {\n      return <Text>Drop the file here...</Text>;\n    }\n    return <Text>Click or drag and drop your file here.</Text>;\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} size=\"2xl\">\n      <ModalOverlay />\n      <ModalContent textAlign=\"left\" p={2} data-testid={testId}>\n        <ModalHeader>Upload integration template</ModalHeader>\n        <ModalBody>\n          <Text fontSize=\"sm\" mb={4}>\n            Drag and drop your integration template zip file here, or click to\n            browse your files.\n          </Text>\n          <Box\n            {...getRootProps()}\n            bg={isDragActive ? \"gray.100\" : \"gray.50\"}\n            border=\"2px dashed\"\n            borderColor={isDragActive ? \"gray.300\" : \"gray.200\"}\n            borderRadius=\"md\"\n            cursor=\"pointer\"\n            minHeight=\"150px\"\n            display=\"flex\"\n            alignItems=\"center\"\n            justifyContent=\"center\"\n            textAlign=\"center\"\n          >\n            <input {...getInputProps()} />\n            {renderFileText()}\n          </Box>\n          <Text fontSize=\"sm\" mt={4}>\n            An integration template zip file must include a SaaS config and\n            dataset, but may also contain an icon (.svg) and custom functions\n            (.py) as optional files.\n          </Text>\n        </ModalBody>\n        <ModalFooter>\n          <ButtonGroup\n            size=\"sm\"\n            spacing=\"2\"\n            width=\"100%\"\n            display=\"flex\"\n            justifyContent=\"right\"\n          >\n            <Button\n              variant=\"outline\"\n              onClick={onClose}\n              data-testid=\"cancel-btn\"\n              isDisabled={isLoading}\n            >\n              Cancel\n            </Button>\n            <Button\n              colorScheme=\"primary\"\n              type=\"submit\"\n              isDisabled={!uploadedFile || isLoading}\n              onClick={handleSubmit}\n              data-testid=\"submit-btn\"\n            >\n              Submit\n            </Button>\n          </ButtonGroup>\n        </ModalFooter>\n      </ModalContent>\n    </Modal>\n  );\n};\n\nexport default ConnectorTemplateUploadModal;\n", "patch": "@@ -122,8 +122,7 @@ const ConnectorTemplateUploadModal: React.FC<RequestModalProps> = ({\n           </Box>\n           <Text fontSize=\"sm\" mt={4}>\n             An integration template zip file must include a SaaS config and\n-            dataset, but may also contain an icon (.svg) and custom functions\n-            (.py) as optional files.\n+            dataset, but may also contain an icon (.svg) as an optional file.\n           </Text>\n         </ModalBody>\n         <ModalFooter>", "file_path": "files/2023_9/537", "file_language": "tsx", "file_name": "clients/admin-ui/src/features/connector-templates/ConnectorTemplateUploadModal.tsx", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/docker-compose.yml", "code": "services:\n  fides:\n    container_name: fides\n    image: ethyca/fides:local\n    command: uvicorn --host 0.0.0.0 --port 8080 --reload --reload-dir src --reload-dir data --reload-include='*.yml' fides.api.main:app\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://0.0.0.0:8080/health\"]\n      interval: 20s\n      timeout: 5s\n      retries: 10\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      fides-db:\n        condition: service_healthy\n      redis:\n        condition: service_started\n    expose:\n      - 8080\n    env_file:\n      - .env\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n      FIDES__CLI__SERVER_HOST: \"fides\"\n      FIDES__CLI__SERVER_PORT: \"8080\"\n      FIDES__DATABASE__SERVER: \"fides-db\"\n      FIDES__DEV_MODE: \"True\"\n      FIDES__LOGGING__COLORIZE: \"True\"\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n      FIDES__SECURITY__BASTION_SERVER_HOST: ${FIDES__SECURITY__BASTION_SERVER_HOST-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME: ${FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY: ${FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY-}\n      VAULT_ADDR: ${VAULT_ADDR-}\n      VAULT_NAMESPACE: ${VAULT_NAMESPACE-}\n      VAULT_TOKEN: ${VAULT_TOKEN-}\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n\n  fides-ui:\n    image: ethyca/fides:local-ui\n    command: npm run dev-admin-ui\n    expose:\n      - 3000\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/admin-ui/node_modules\n    environment:\n      - NEXT_PUBLIC_FIDESCTL_API_SERVER=http://fides:8080\n\n  fides-pc:\n    image: ethyca/fides:local-pc\n    command: npm run dev-pc\n    expose:\n      - 3000\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/privacy-center/node_modules\n\n  fides-db:\n    image: postgres:12\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 15s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - postgres:/var/lib/postgresql/data\n    expose:\n      - 5432\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: \"postgres\"\n      POSTGRES_PASSWORD: \"fides\"\n      POSTGRES_DB: \"fides\"\n    deploy:\n      placement:\n        constraints:\n          - node.labels.fides.app-db-data == true\n\n  docs:\n    build:\n      context: .\n      dockerfile: docs/fides/Dockerfile\n    volumes:\n      - ./docs/fides:/docs\n      - ./:/fides\n    expose:\n      - 8000\n    ports:\n      - \"8000:8000\"\n    environment:\n      FIDES__DEV_MODE: True\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n\n      # Required security env vars\n      FIDES__SECURITY__APP_ENCRYPTION_KEY: OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_ID: fidesadmin\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_SECRET: fidesadminsecret\n      FIDES__SECURITY__DRP_JWT_SECRET: secret\n\n  worker:\n    image: ethyca/fides:local\n    command: fides worker\n    depends_on:\n      redis:\n        condition: service_started\n    restart: always\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n    volumes:\n      - type: bind\n        source: ./\n        target: /fides\n        read_only: False\n      - /fides/src/fides.egg-info\n\n  redis:\n    image: \"redis:6.2.5-alpine\"\n    # AUTH option #1: no authentication at all\n    # command: redis-server\n    # AUTH option #2: require password\n    command: redis-server --requirepass redispassword\n    # AUTH option #3: Redis ACL defined in redis.conf\n    # command: redis-server /usr/local/etc/redis/redis.conf\n    expose:\n      - 6379\n    ports:\n      - \"0.0.0.0:6379:6379\"\n    volumes:\n      # Mount a redis.conf file for configuration\n      # NOTE: Only used by \"AUTH option #3\" above!\n      - type: bind\n        source: ./docker/redis\n        target: /usr/local/etc/redis\n        read_only: False\n\nvolumes:\n  postgres: null\n\nnetworks:\n  fides_network:\n", "code_before": "services:\n  fides:\n    container_name: fides\n    image: ethyca/fides:local\n    command: uvicorn --host 0.0.0.0 --port 8080 --reload --reload-dir src --reload-dir data --reload-include='*.yml' fides.api.main:app\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://0.0.0.0:8080/health\"]\n      interval: 20s\n      timeout: 5s\n      retries: 10\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      fides-db:\n        condition: service_healthy\n      redis:\n        condition: service_started\n    expose:\n      - 8080\n    env_file:\n      - .env\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n      FIDES__CLI__SERVER_HOST: \"fides\"\n      FIDES__CLI__SERVER_PORT: \"8080\"\n      FIDES__DATABASE__SERVER: \"fides-db\"\n      FIDES__DEV_MODE: \"True\"\n      FIDES__LOGGING__COLORIZE: \"True\"\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n      FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS: \"True\"\n      FIDES__SECURITY__BASTION_SERVER_HOST: ${FIDES__SECURITY__BASTION_SERVER_HOST-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME: ${FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME-}\n      FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY: ${FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY-}\n      VAULT_ADDR: ${VAULT_ADDR-}\n      VAULT_NAMESPACE: ${VAULT_NAMESPACE-}\n      VAULT_TOKEN: ${VAULT_TOKEN-}\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n\n  fides-ui:\n    image: ethyca/fides:local-ui\n    command: npm run dev-admin-ui\n    expose:\n      - 3000\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/admin-ui/node_modules\n    environment:\n      - NEXT_PUBLIC_FIDESCTL_API_SERVER=http://fides:8080\n\n  fides-pc:\n    image: ethyca/fides:local-pc\n    command: npm run dev-pc\n    expose:\n      - 3000\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - type: bind\n        source: .\n        target: /fides\n        read_only: False\n      # do not volume mount over the node_modules\n      - /fides/clients/node_modules\n      - /fides/clients/privacy-center/node_modules\n\n  fides-db:\n    image: postgres:12\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 15s\n      timeout: 5s\n      retries: 5\n    volumes:\n      - postgres:/var/lib/postgresql/data\n    expose:\n      - 5432\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: \"postgres\"\n      POSTGRES_PASSWORD: \"fides\"\n      POSTGRES_DB: \"fides\"\n    deploy:\n      placement:\n        constraints:\n          - node.labels.fides.app-db-data == true\n\n  docs:\n    build:\n      context: .\n      dockerfile: docs/fides/Dockerfile\n    volumes:\n      - ./docs/fides:/docs\n      - ./:/fides\n    expose:\n      - 8000\n    ports:\n      - \"8000:8000\"\n    environment:\n      FIDES__DEV_MODE: True\n      FIDES__CLI__ANALYTICS_ID: ${FIDES__CLI__ANALYTICS_ID-}\n\n      # Required security env vars\n      FIDES__SECURITY__APP_ENCRYPTION_KEY: OLMkv91j8DHiDAULnK5Lxx3kSCov30b3\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_ID: fidesadmin\n      FIDES__SECURITY__OAUTH_ROOT_CLIENT_SECRET: fidesadminsecret\n      FIDES__SECURITY__DRP_JWT_SECRET: secret\n\n  worker:\n    image: ethyca/fides:local\n    command: fides worker\n    depends_on:\n      redis:\n        condition: service_started\n    restart: always\n    environment:\n      FIDES__CONFIG_PATH: ${FIDES__CONFIG_PATH:-/fides/.fides/fides.toml}\n      FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n    volumes:\n      - type: bind\n        source: ./\n        target: /fides\n        read_only: False\n      - /fides/src/fides.egg-info\n\n  redis:\n    image: \"redis:6.2.5-alpine\"\n    # AUTH option #1: no authentication at all\n    # command: redis-server\n    # AUTH option #2: require password\n    command: redis-server --requirepass redispassword\n    # AUTH option #3: Redis ACL defined in redis.conf\n    # command: redis-server /usr/local/etc/redis/redis.conf\n    expose:\n      - 6379\n    ports:\n      - \"0.0.0.0:6379:6379\"\n    volumes:\n      # Mount a redis.conf file for configuration\n      # NOTE: Only used by \"AUTH option #3\" above!\n      - type: bind\n        source: ./docker/redis\n        target: /usr/local/etc/redis\n        read_only: False\n\nvolumes:\n  postgres: null\n\nnetworks:\n  fides_network:\n", "patch": "@@ -28,7 +28,6 @@ services:\n       FIDES__DEV_MODE: \"True\"\n       FIDES__LOGGING__COLORIZE: \"True\"\n       FIDES__USER__ANALYTICS_OPT_OUT: \"True\"\n-      FIDES__SECURITY__ALLOW_CUSTOM_CONNECTOR_FUNCTIONS: \"True\"\n       FIDES__SECURITY__BASTION_SERVER_HOST: ${FIDES__SECURITY__BASTION_SERVER_HOST-}\n       FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME: ${FIDES__SECURITY__BASTION_SERVER_SSH_USERNAME-}\n       FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY: ${FIDES__SECURITY__BASTION_SERVER_SSH_PRIVATE_KEY-}", "file_path": "files/2023_9/538", "file_language": "yml", "file_name": "docker-compose.yml", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/requirements.txt", "code": "alembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\ndefusedxml==0.7.1\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]==0.11.4\nfideslang==1.4.5\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru==0.6.0\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npyinstrument==4.5.1\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\nPyMySQL==1.0.2\npymssql==2.2.8\npython-jose[cryptography]==3.3.0\npyyaml==6.0.1\nredis==3.5.3\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml==0.10.2\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "code_before": "AccessControl==6.0\nalembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\ndefusedxml==0.7.1\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]==0.11.4\nfideslang==1.4.5\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru==0.6.0\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npyinstrument==4.5.1\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\nPyMySQL==1.0.2\npymssql==2.2.8\npython-jose[cryptography]==3.3.0\npyyaml==6.0.1\nredis==3.5.3\nRestrictedPython==6.0.0\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml==0.10.2\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "patch": "@@ -1,4 +1,3 @@\n-AccessControl==6.0\n alembic==1.8.1\n APScheduler==3.9.1.post1\n asyncpg==0.27.0\n@@ -42,7 +41,6 @@ pymssql==2.2.8\n python-jose[cryptography]==3.3.0\n pyyaml==6.0.1\n redis==3.5.3\n-RestrictedPython==6.0.0\n rich-click==1.6.1\n sendgrid==6.9.7\n slowapi==0.1.8", "file_path": "files/2023_9/539", "file_language": "txt", "file_name": "requirements.txt", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/src%2Ffides%2Fapi%2Fschemas%2Fsaas%2Fconnector_template.py", "code": "from typing import Optional\n\nfrom fideslang.models import Dataset\nfrom pydantic import BaseModel, validator\n\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (\n    OAuth2AuthorizationCodeAuthenticationStrategy,\n)\nfrom fides.api.util.saas_util import load_config_from_string, load_dataset_from_string\n\n\nclass ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide\n", "code_before": "from typing import Optional\n\nfrom fideslang.models import Dataset\nfrom pydantic import BaseModel, validator\n\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (\n    OAuth2AuthorizationCodeAuthenticationStrategy,\n)\nfrom fides.api.util.saas_util import load_config_from_string, load_dataset_from_string\n\n\nclass ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, functions, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    functions: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide\n", "patch": "@@ -13,13 +13,12 @@\n class ConnectorTemplate(BaseModel):\n     \"\"\"\n     A collection of artifacts that make up a complete\n-    SaaS connector (SaaS config, dataset, icon, functions, etc.)\n+    SaaS connector (SaaS config, dataset, icon, etc.)\n     \"\"\"\n \n     config: str\n     dataset: str\n     icon: Optional[str]\n-    functions: Optional[str]\n     human_readable: str\n \n     @validator(\"config\")", "file_path": "files/2023_9/540", "file_language": "py", "file_name": "src/fides/api/schemas/saas/connector_template.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, functions, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    functions: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide", "target": 0}], "function_after": [{"function": "class ConnectorTemplate(BaseModel):\n    \"\"\"\n    A collection of artifacts that make up a complete\n    SaaS connector (SaaS config, dataset, icon, etc.)\n    \"\"\"\n\n    config: str\n    dataset: str\n    icon: Optional[str]\n    human_readable: str\n\n    @validator(\"config\")\n    def validate_config(cls, config: str) -> str:\n        \"\"\"Validates the config at the given path\"\"\"\n        saas_config = SaaSConfig(**load_config_from_string(config))\n        if saas_config.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"\n            )\n        return config\n\n    @validator(\"dataset\")\n    def validate_dataset(cls, dataset: str) -> str:\n        \"\"\"Validates the dataset at the given path\"\"\"\n        saas_dataset = Dataset(**load_dataset_from_string(dataset))\n        if saas_dataset.fides_key != \"<instance_fides_key>\":\n            raise ValueError(\n                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"\n            )\n        return dataset\n\n    @property\n    def authorization_required(self) -> bool:\n        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"\n\n        config = SaaSConfig(**load_config_from_string(self.config))\n        authentication = config.client_config.authentication\n        return (\n            authentication.strategy\n            == OAuth2AuthorizationCodeAuthenticationStrategy.name\n            if authentication\n            else False\n        )\n\n    @property\n    def user_guide(self) -> Optional[str]:\n        config = SaaSConfig(**load_config_from_string(self.config))\n        return config.user_guide", "target": 0}]}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/src%2Ffides%2Fapi%2Fservice%2Fconnectors%2Fsaas%2Fconnector_registry_service.py", "code": "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Iterable, List, Optional, Type\nfrom zipfile import ZipFile\n\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.saas_config_template_values import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate\n        and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            human_readable=template.name,\n        )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n", "code_before": "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom ast import AST, AnnAssign\nfrom operator import getitem\nfrom typing import Any, Dict, Iterable, List, Optional, Tuple, Type\nfrom zipfile import ZipFile\n\nfrom AccessControl.ZopeGuards import safe_builtins\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom RestrictedPython import compile_restricted\nfrom RestrictedPython.transformer import RestrictingNodeTransformer\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import FidesopsException, ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.saas_config_template_values import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\nfrom fides.config import CONFIG\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        functions=None,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate,\n        registering any custom functions, and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            functions=template.functions,\n            human_readable=template.name,\n        )\n\n        # register custom functions if available\n        if template.functions:\n            register_custom_functions(template.functions)\n            logger.info(\n                f\"Loaded functions from the custom connector template '{template.key}'\"\n            )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n\n\ndef register_custom_functions(script: str) -> None:\n    \"\"\"\n    Registers custom functions by executing the given script in a restricted environment.\n\n    The script is compiled and executed with RestrictedPython, which is designed to reduce\n    the risk of executing untrusted code. It provides a set of safe builtins to prevent\n    malicious or unintended behavior.\n\n    Args:\n        script (str): The Python script containing the custom functions to be registered.\n\n    Raises:\n        FidesopsException: If allow_custom_connector_functions is disabled.\n        SyntaxError: If the script contains a syntax error or uses restricted language features.\n        Exception: If an exception occurs during the execution of the script.\n    \"\"\"\n\n    if CONFIG.security.allow_custom_connector_functions:\n        restricted_code = compile_restricted(\n            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer\n        )\n        safe_builtins[\"__import__\"] = custom_guarded_import\n        safe_builtins[\"_getitem_\"] = getitem\n        safe_builtins[\"staticmethod\"] = staticmethod\n\n        # pylint: disable=exec-used\n        exec(\n            restricted_code,\n            {\n                \"__metaclass__\": type,\n                \"__name__\": \"restricted_module\",\n                \"__builtins__\": safe_builtins,\n            },\n        )\n    else:\n        raise FidesopsException(\n            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n        )\n\n\nclass CustomRestrictingNodeTransformer(RestrictingNodeTransformer):\n    \"\"\"\n    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer\n    to allow the use of type annotations (AnnAssign) in restricted code.\n    \"\"\"\n\n    def visit_AnnAssign(self, node: AnnAssign) -> AST:\n        return self.node_contents_visit(node)\n\n\ndef custom_guarded_import(\n    name: str,\n    _globals: Optional[dict] = None,\n    _locals: Optional[dict] = None,\n    fromlist: Optional[Tuple[str, ...]] = None,\n    level: int = 0,\n) -> Any:\n    \"\"\"\n    A custom import function that prevents the import of certain potentially unsafe modules.\n    \"\"\"\n    if name in [\n        \"os\",\n        \"sys\",\n        \"subprocess\",\n        \"shutil\",\n        \"socket\",\n        \"importlib\",\n        \"tempfile\",\n        \"glob\",\n    ]:\n        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions\n        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")\n    if fromlist is None:\n        fromlist = ()\n    return __import__(name, _globals, _locals, fromlist, level)\n", "patch": "@@ -1,22 +1,17 @@\n # pylint: disable=protected-access\n import os\n from abc import ABC, abstractmethod\n-from ast import AST, AnnAssign\n-from operator import getitem\n-from typing import Any, Dict, Iterable, List, Optional, Tuple, Type\n+from typing import Dict, Iterable, List, Optional, Type\n from zipfile import ZipFile\n \n-from AccessControl.ZopeGuards import safe_builtins\n from fideslang.models import Dataset\n from loguru import logger\n from packaging.version import Version\n from packaging.version import parse as parse_version\n-from RestrictedPython import compile_restricted\n-from RestrictedPython.transformer import RestrictingNodeTransformer\n from sqlalchemy.orm import Session\n \n from fides.api.api.deps import get_api_session\n-from fides.api.common_exceptions import FidesopsException, ValidationError\n+from fides.api.common_exceptions import ValidationError\n from fides.api.cryptography.cryptographic_util import str_to_b64_str\n from fides.api.models.connectionconfig import (\n     AccessLevel,\n@@ -41,7 +36,6 @@\n     replace_version,\n )\n from fides.api.util.unsafe_file_util import verify_svg, verify_zip\n-from fides.config import CONFIG\n \n \n class ConnectorTemplateLoader(ABC):\n@@ -96,7 +90,6 @@ def _load_connector_templates(self) -> None:\n                             f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                         ),\n                         icon=icon,\n-                        functions=None,\n                         human_readable=human_readable,\n                     )\n                 except Exception:\n@@ -151,24 +144,16 @@ def _register_template(\n         template: CustomConnectorTemplate,\n     ) -> None:\n         \"\"\"\n-        Registers a custom connector template by converting it to a ConnectorTemplate,\n-        registering any custom functions, and adding it to the loader's template dictionary.\n+        Registers a custom connector template by converting it to a ConnectorTemplate\n+        and adding it to the loader's template dictionary.\n         \"\"\"\n         connector_template = ConnectorTemplate(\n             config=template.config,\n             dataset=template.dataset,\n             icon=template.icon,\n-            functions=template.functions,\n             human_readable=template.name,\n         )\n \n-        # register custom functions if available\n-        if template.functions:\n-            register_custom_functions(template.functions)\n-            logger.info(\n-                f\"Loaded functions from the custom connector template '{template.key}'\"\n-            )\n-\n         # register the template in the loader's template dictionary\n         CustomConnectorTemplateLoader.get_connector_templates()[\n             template.key\n@@ -220,13 +205,6 @@ def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n                     raise ValidationError(\n                         \"Multiple svg files found, only one is allowed.\"\n                     )\n-            elif info.filename.endswith(\".py\"):\n-                if not function_contents:\n-                    function_contents = file_contents\n-                else:\n-                    raise ValidationError(\n-                        \"Multiple Python (.py) files found, only one is allowed.\"\n-                    )\n \n         if not config_contents:\n             raise ValidationError(\"Zip file does not contain a config.yml file.\")\n@@ -266,7 +244,6 @@ def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n             config=config_contents,\n             dataset=dataset_contents,\n             icon=icon_contents,\n-            functions=function_contents,\n             replaceable=replaceable,\n         )\n \n@@ -447,80 +424,3 @@ def update_saas_instance(\n     connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n \n     upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n-\n-\n-def register_custom_functions(script: str) -> None:\n-    \"\"\"\n-    Registers custom functions by executing the given script in a restricted environment.\n-\n-    The script is compiled and executed with RestrictedPython, which is designed to reduce\n-    the risk of executing untrusted code. It provides a set of safe builtins to prevent\n-    malicious or unintended behavior.\n-\n-    Args:\n-        script (str): The Python script containing the custom functions to be registered.\n-\n-    Raises:\n-        FidesopsException: If allow_custom_connector_functions is disabled.\n-        SyntaxError: If the script contains a syntax error or uses restricted language features.\n-        Exception: If an exception occurs during the execution of the script.\n-    \"\"\"\n-\n-    if CONFIG.security.allow_custom_connector_functions:\n-        restricted_code = compile_restricted(\n-            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer\n-        )\n-        safe_builtins[\"__import__\"] = custom_guarded_import\n-        safe_builtins[\"_getitem_\"] = getitem\n-        safe_builtins[\"staticmethod\"] = staticmethod\n-\n-        # pylint: disable=exec-used\n-        exec(\n-            restricted_code,\n-            {\n-                \"__metaclass__\": type,\n-                \"__name__\": \"restricted_module\",\n-                \"__builtins__\": safe_builtins,\n-            },\n-        )\n-    else:\n-        raise FidesopsException(\n-            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n-        )\n-\n-\n-class CustomRestrictingNodeTransformer(RestrictingNodeTransformer):\n-    \"\"\"\n-    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer\n-    to allow the use of type annotations (AnnAssign) in restricted code.\n-    \"\"\"\n-\n-    def visit_AnnAssign(self, node: AnnAssign) -> AST:\n-        return self.node_contents_visit(node)\n-\n-\n-def custom_guarded_import(\n-    name: str,\n-    _globals: Optional[dict] = None,\n-    _locals: Optional[dict] = None,\n-    fromlist: Optional[Tuple[str, ...]] = None,\n-    level: int = 0,\n-) -> Any:\n-    \"\"\"\n-    A custom import function that prevents the import of certain potentially unsafe modules.\n-    \"\"\"\n-    if name in [\n-        \"os\",\n-        \"sys\",\n-        \"subprocess\",\n-        \"shutil\",\n-        \"socket\",\n-        \"importlib\",\n-        \"tempfile\",\n-        \"glob\",\n-    ]:\n-        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions\n-        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")\n-    if fromlist is None:\n-        fromlist = ()\n-    return __import__(name, _globals, _locals, fromlist, level)", "file_path": "files/2023_9/541", "file_language": "py", "file_name": "src/fides/api/service/connectors/saas/connector_registry_service.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       python.lang.security.audit.exec-detected.exec-detected                                        \n          Detected the use of exec(). exec() can be dangerous if used to evaluate dynamic content. If\n          this content can be input from outside the program, this may be a code injection           \n          vulnerability. Ensure evaluated content is not definable by external sources.              \n          Details: https://sg.run/ndRX                                                               \n\n          478\u2506 exec(\n          479\u2506     restricted_code,\n          480\u2506     {\n          481\u2506         \"__metaclass__\": type,\n          482\u2506         \"__name__\": \"restricted_module\",\n          483\u2506         \"__builtins__\": safe_builtins,\n          484\u2506     },          485\u2506 )"]]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/src%2Ffides%2Fconfig%2Fsecurity_settings.py", "code": "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"\n\n# pylint: disable=C0115,C0116, E0213\nfrom typing import Dict, List, Optional, Pattern, Tuple, Union\n\nimport validators\nfrom pydantic import Field, validator\nfrom slowapi.wrappers import parse_many  # type: ignore\n\nfrom fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt\nfrom fides.api.oauth.roles import OWNER\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY\n\nfrom .fides_settings import FidesSettings\n\nENV_PREFIX = \"FIDES__SECURITY__\"\n\n\nclass SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX\n", "code_before": "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"\n\n# pylint: disable=C0115,C0116, E0213\nfrom typing import Dict, List, Optional, Pattern, Tuple, Union\n\nimport validators\nfrom pydantic import Field, validator\nfrom slowapi.wrappers import parse_many  # type: ignore\n\nfrom fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt\nfrom fides.api.oauth.roles import OWNER\nfrom fides.common.api.scope_registry import SCOPE_REGISTRY\n\nfrom .fides_settings import FidesSettings\n\nENV_PREFIX = \"FIDES__SECURITY__\"\n\n\nclass SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    allow_custom_connector_functions: Optional[bool] = Field(\n        default=False,\n        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX\n", "patch": "@@ -118,10 +118,6 @@ class SecuritySettings(FidesSettings):\n         default=432000,\n         description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n     )\n-    allow_custom_connector_functions: Optional[bool] = Field(\n-        default=False,\n-        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\",\n-    )\n     enable_audit_log_resource_middleware: Optional[bool] = Field(\n         default=False,\n         description=\"Either enables the collection of audit log resource data or bypasses the middleware\",", "file_path": "files/2023_9/542", "file_language": "py", "file_name": "src/fides/config/security_settings.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    allow_custom_connector_functions: Optional[bool] = Field(\n        default=False,\n        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX", "target": 0}], "function_after": [{"function": "class SecuritySettings(FidesSettings):\n    \"\"\"Configuration settings for application security.\"\"\"\n\n    aes_encryption_key_length: int = Field(\n        default=16,\n        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",\n    )\n    aes_gcm_nonce_length: int = Field(\n        default=12,\n        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",\n    )\n    app_encryption_key: str = Field(\n        default=\"\", description=\"The key used to sign Fides API access tokens.\"\n    )\n    cors_origins: List[str] = Field(\n        default=[],\n        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",\n    )\n    cors_origin_regex: Optional[Pattern] = Field(\n        default=None,\n        description=\"A regex pattern used to set the CORS origin allowlist.\",\n    )\n    drp_jwt_secret: Optional[str] = Field(\n        default=None,\n        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",\n    )\n    encoding: str = Field(\n        default=\"UTF-8\", description=\"Text encoding to use for the application.\"\n    )\n    env: str = Field(\n        default=\"dev\",\n        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",\n    )\n    identity_verification_attempt_limit: int = Field(\n        default=3,\n        description=\"The number of times identity verification will be attempted before raising an error.\",\n    )\n    oauth_root_client_id: str = Field(\n        default=\"\",\n        description=\"The value used to identify the Fides application root API client.\",\n    )\n    oauth_root_client_secret: str = Field(\n        default=\"\",\n        description=\"The secret value used to authenticate the Fides application root API client.\",\n    )\n    oauth_root_client_secret_hash: Optional[Tuple] = Field(\n        default=None,\n        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",\n    )\n    oauth_access_token_expire_minutes: int = Field(\n        default=11520,\n        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",\n    )\n    oauth_client_id_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client id used for oauth.\",\n    )\n    oauth_client_secret_length_bytes: int = Field(\n        default=16,\n        description=\"Sets desired length in bytes of generated client secret used for oauth.\",\n    )\n    parent_server_password: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",\n    )\n    parent_server_username: Optional[str] = Field(\n        default=None,\n        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",\n    )\n    public_request_rate_limit: str = Field(\n        default=\"2000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",\n    )\n    rate_limit_prefix: str = Field(\n        default=\"fides-\",\n        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",\n    )\n    request_rate_limit: str = Field(\n        default=\"1000/minute\",\n        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",\n    )\n    root_user_scopes: List[str] = Field(\n        default=SCOPE_REGISTRY,\n        description=\"The list of scopes that are given to the root user.\",\n    )\n    root_user_roles: List[str] = Field(\n        default=[OWNER],\n        description=\"The list of roles that are given to the root user.\",\n    )\n    root_password: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",\n    )\n\n    root_username: Optional[str] = Field(\n        default=None,\n        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",\n    )\n    subject_request_download_link_ttl_seconds: int = Field(\n        default=432000,\n        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",\n    )\n    enable_audit_log_resource_middleware: Optional[bool] = Field(\n        default=False,\n        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",\n    )\n\n    bastion_server_host: Optional[str] = Field(\n        default=None, description=\"An optional field to store the bastion server host\"\n    )\n    bastion_server_ssh_username: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the username used to access the bastion server\",\n    )\n    bastion_server_ssh_private_key: Optional[str] = Field(\n        default=None,\n        description=\"An optional field to store the key used to SSH into the bastion server.\",\n    )\n    bastion_server_ssh_timeout: float = Field(\n        default=0.1,\n        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",\n    )\n    bastion_server_ssh_tunnel_timeout: float = Field(\n        default=10,\n        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",\n    )\n\n    @validator(\"app_encryption_key\")\n    @classmethod\n    def validate_encryption_key_length(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[str]:\n        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"\n\n        # If the value is the default value, return immediately to prevent unwanted errors\n        if v == \"\":\n            return v\n\n        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:\n            raise ValueError(\n                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"\n            )\n        return v\n\n    @validator(\"cors_origins\", pre=True)\n    @classmethod\n    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:\n        \"\"\"Return a list of valid origins for CORS requests\"\"\"\n\n        def validate(values: List[str]) -> None:\n            for value in values:\n                if value != \"*\":\n                    if not validators.url(value):\n                        raise ValueError(f\"{value} is not a valid url\")\n\n        if isinstance(v, str) and not v.startswith(\"[\"):\n            values = [i.strip() for i in v.split(\",\")]\n            validate(values)\n\n            return values\n        if isinstance(v, (list, str)):\n            validate(v)  # type: ignore\n\n            return v\n        raise ValueError(v)\n\n    @validator(\"oauth_root_client_secret_hash\")\n    @classmethod\n    def assemble_root_access_token(\n        cls, v: Optional[str], values: Dict[str, str]\n    ) -> Optional[Tuple]:\n        \"\"\"\n        Sets a hashed value of the root access key.\n        This is hashed as it is not wise to return a plaintext for of the\n        root credential anywhere in the system.\n        \"\"\"\n        value = values.get(\"oauth_root_client_secret\", \"\")\n\n        if not value:\n            return None\n\n        encoding = values.get(\"encoding\", \"UTF-8\")\n\n        salt = generate_salt()\n        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))\n        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore\n        return oauth_root_client_secret_hash\n\n    @validator(\"request_rate_limit\")\n    @classmethod\n    def validate_request_rate_limit(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        try:\n            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many\n            parse_many(v)\n        except ValueError:\n            message = \"\"\"\n            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]\n            e.g. 10 per hour\n            e.g. 10/hour\n            e.g. 10/hour;100/day;2000 per year\n            e.g. 100/day, 500/7days\n            \"\"\"\n            raise ValueError(message)\n        return v\n\n    @validator(\"env\")\n    @classmethod\n    def validate_env(\n        cls,\n        v: str,\n    ) -> str:\n        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"\n        if v not in [\"dev\", \"prod\"]:\n            message = \"Security environment must be either 'dev' or 'prod'.\"\n            raise ValueError(message)\n        return v\n\n    class Config:\n        env_prefix = ENV_PREFIX", "target": 0}]}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/tests%2Fops%2Fapi%2Fv1%2Fendpoints%2Ftest_saas_config_endpoints.py", "code": "import json\nfrom typing import Optional\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.common.api.scope_registry import (\n    CLIENT_READ,\n    CONNECTION_AUTHORIZE,\n    CONNECTOR_TEMPLATE_REGISTER,\n    SAAS_CONFIG_CREATE_OR_UPDATE,\n    SAAS_CONFIG_DELETE,\n    SAAS_CONFIG_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    AUTHORIZE,\n    REGISTER_CONNECTOR_TEMPLATE,\n    SAAS_CONFIG,\n    SAAS_CONFIG_VALIDATE,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.api.v1.endpoints.test_dataset_endpoints import _reject_key\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\n@pytest.mark.unit_saas\nclass TestValidateSaaSConfig:\n    @pytest.fixture\n    def validate_saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG_VALIDATE\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_put_validate_saas_config_not_authenticated(\n        self, saas_example_config, validate_saas_config_url: str, api_client\n    ) -> None:\n        response = api_client.put(\n            validate_saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_put_validate_dataset_wrong_scope(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.put(\n            validate_saas_config_url,\n            headers=auth_header,\n            json=saas_example_config,\n        )\n        assert response.status_code == 403\n\n    def test_put_validate_saas_config_missing_key(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"fides_key\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"fides_key\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_missing_endpoints(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"endpoints\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"endpoints\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_reference_and_identity(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"identity\"] = \"email\"\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"from\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"Must have exactly one of 'identity', 'references', or 'connector_param'\"\n        )\n\n    def test_put_validate_saas_config_wrong_reference_direction(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"to\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"References can only have a direction of 'from', found 'to'\"\n        )\n\n\n@pytest.mark.unit_saas\nclass TestPutSaaSConfig:\n    @pytest.fixture\n    def saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_patch_saas_config_not_authenticated(\n        self, saas_example_config, saas_config_url, api_client\n    ) -> None:\n        response = api_client.patch(\n            saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_patch_saas_config_wrong_scope(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 403\n\n    def test_patch_saas_config_invalid_connection_key(\n        self, saas_example_config, api_client: TestClient, generate_auth_header\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": \"nonexistent_key\"}\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 404\n\n    def test_patch_saas_config_create(\n        self,\n        saas_example_connection_config_without_saas_config,\n        saas_example_config,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\n            \"connection_key\": saas_example_connection_config_without_saas_config.key\n        }\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        updated_config = ConnectionConfig.get_by(\n            db=db,\n            field=\"key\",\n            value=saas_example_connection_config_without_saas_config.key,\n        )\n        db.expire(updated_config)\n        saas_config = updated_config.saas_config\n        assert saas_config is not None\n\n    def test_patch_saas_config_update(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        saas_example_config[\"endpoints\"].pop()\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        connection_config = ConnectionConfig.get_by(\n            db=db, field=\"key\", value=saas_example_config[\"fides_key\"]\n        )\n        saas_config = connection_config.saas_config\n        assert saas_config is not None\n        assert len(saas_config[\"endpoints\"]) == 11\n\n\ndef get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)\n\n\n@pytest.mark.unit_saas\nclass TestGetSaaSConfig:\n    def test_get_saas_config_not_authenticated(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.get(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_get_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_get_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 200\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"fides_key\"]\n            == saas_example_connection_config.get_saas_config().fides_key\n        )\n        assert len(response_body[\"endpoints\"]) == 12\n        assert response_body[\"type\"] == \"custom\"\n\n\n@pytest.mark.unit_saas\nclass TestDeleteSaaSConfig:\n    def test_delete_saas_config_not_authenticated(\n        self, saas_example_connection_config, api_client\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.delete(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_delete_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_delete_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config(\n        self,\n        db: Session,\n        saas_example_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        # Create a new connection config so we don't run into issues trying to clean up an\n        # already deleted fixture\n        fides_key = \"saas_config_for_deletion_test\"\n        saas_example_config[\"fides_key\"] = fides_key\n        config_to_delete = ConnectionConfig.create(\n            db=db,\n            data={\n                \"key\": fides_key,\n                \"name\": fides_key,\n                \"connection_type\": ConnectionType.saas,\n                \"access\": AccessLevel.read,\n                \"saas_config\": saas_example_config,\n            },\n        )\n        saas_config_url = get_saas_config_url(config_to_delete)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 204\n\n        updated_config = ConnectionConfig.get_by(db=db, field=\"key\", value=fides_key)\n        db.expire(updated_config)\n        assert updated_config.saas_config is None\n\n    def test_delete_saas_config_with_dataset_and_secrets(\n        self,\n        saas_example_connection_config,\n        saas_example_dataset_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 400\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"detail\"]\n            == f\"Must delete the dataset with fides_key '{saas_example_dataset_config.fides_key}' \"\n            \"before deleting this SaaS config. Must clear the secrets from this connection \"\n            \"config before deleting the SaaS config.\"\n        )\n\n\nclass TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'\n\n\nclass TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n", "code_before": "import json\nfrom typing import Optional\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nimport pytest\nfrom sqlalchemy.orm import Session\nfrom starlette.testclient import TestClient\n\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.common.api.scope_registry import (\n    CLIENT_READ,\n    CONNECTION_AUTHORIZE,\n    CONNECTOR_TEMPLATE_REGISTER,\n    SAAS_CONFIG_CREATE_OR_UPDATE,\n    SAAS_CONFIG_DELETE,\n    SAAS_CONFIG_READ,\n)\nfrom fides.common.api.v1.urn_registry import (\n    AUTHORIZE,\n    REGISTER_CONNECTOR_TEMPLATE,\n    SAAS_CONFIG,\n    SAAS_CONFIG_VALIDATE,\n    V1_URL_PREFIX,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.api.v1.endpoints.test_dataset_endpoints import _reject_key\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\n@pytest.mark.unit_saas\nclass TestValidateSaaSConfig:\n    @pytest.fixture\n    def validate_saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG_VALIDATE\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_put_validate_saas_config_not_authenticated(\n        self, saas_example_config, validate_saas_config_url: str, api_client\n    ) -> None:\n        response = api_client.put(\n            validate_saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_put_validate_dataset_wrong_scope(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.put(\n            validate_saas_config_url,\n            headers=auth_header,\n            json=saas_example_config,\n        )\n        assert response.status_code == 403\n\n    def test_put_validate_saas_config_missing_key(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"fides_key\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"fides_key\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_missing_endpoints(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        invalid_config = _reject_key(saas_example_config, \"endpoints\")\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=invalid_config\n        )\n        assert response.status_code == 422\n\n        details = json.loads(response.text)[\"detail\"]\n        assert [\"body\", \"endpoints\"] in [e[\"loc\"] for e in details]\n\n    def test_put_validate_saas_config_reference_and_identity(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"identity\"] = \"email\"\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"from\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"Must have exactly one of 'identity', 'references', or 'connector_param'\"\n        )\n\n    def test_put_validate_saas_config_wrong_reference_direction(\n        self,\n        saas_example_config,\n        validate_saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        saas_config = saas_example_config\n        param_values = saas_config[\"endpoints\"][0][\"requests\"][\"read\"][\"param_values\"][\n            0\n        ]\n        param_values[\"references\"] = [\n            {\n                \"dataset\": \"postgres_example_test_dataset\",\n                \"field\": \"another.field\",\n                \"direction\": \"to\",\n            }\n        ]\n        response = api_client.put(\n            validate_saas_config_url, headers=auth_header, json=saas_config\n        )\n        assert response.status_code == 422\n        details = json.loads(response.text)[\"detail\"]\n        assert (\n            details[0][\"msg\"]\n            == \"References can only have a direction of 'from', found 'to'\"\n        )\n\n\n@pytest.mark.unit_saas\nclass TestPutSaaSConfig:\n    @pytest.fixture\n    def saas_config_url(self, saas_example_connection_config) -> str:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": saas_example_connection_config.key}\n        return path.format(**path_params)\n\n    def test_patch_saas_config_not_authenticated(\n        self, saas_example_config, saas_config_url, api_client\n    ) -> None:\n        response = api_client.patch(\n            saas_config_url, headers={}, json=saas_example_config\n        )\n        assert response.status_code == 401\n\n    def test_patch_saas_config_wrong_scope(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 403\n\n    def test_patch_saas_config_invalid_connection_key(\n        self, saas_example_config, api_client: TestClient, generate_auth_header\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\"connection_key\": \"nonexistent_key\"}\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 404\n\n    def test_patch_saas_config_create(\n        self,\n        saas_example_connection_config_without_saas_config,\n        saas_example_config,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        path = V1_URL_PREFIX + SAAS_CONFIG\n        path_params = {\n            \"connection_key\": saas_example_connection_config_without_saas_config.key\n        }\n        saas_config_url = path.format(**path_params)\n\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        updated_config = ConnectionConfig.get_by(\n            db=db,\n            field=\"key\",\n            value=saas_example_connection_config_without_saas_config.key,\n        )\n        db.expire(updated_config)\n        saas_config = updated_config.saas_config\n        assert saas_config is not None\n\n    def test_patch_saas_config_update(\n        self,\n        saas_example_config,\n        saas_config_url,\n        api_client: TestClient,\n        db: Session,\n        generate_auth_header,\n    ) -> None:\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        saas_example_config[\"endpoints\"].pop()\n        response = api_client.patch(\n            saas_config_url, headers=auth_header, json=saas_example_config\n        )\n        assert response.status_code == 200\n\n        connection_config = ConnectionConfig.get_by(\n            db=db, field=\"key\", value=saas_example_config[\"fides_key\"]\n        )\n        saas_config = connection_config.saas_config\n        assert saas_config is not None\n        assert len(saas_config[\"endpoints\"]) == 11\n\n\ndef get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)\n\n\n@pytest.mark.unit_saas\nclass TestGetSaaSConfig:\n    def test_get_saas_config_not_authenticated(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.get(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_get_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_CREATE_OR_UPDATE])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_get_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_get_saas_config(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.get(saas_config_url, headers=auth_header)\n        assert response.status_code == 200\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"fides_key\"]\n            == saas_example_connection_config.get_saas_config().fides_key\n        )\n        assert len(response_body[\"endpoints\"]) == 12\n        assert response_body[\"type\"] == \"custom\"\n\n\n@pytest.mark.unit_saas\nclass TestDeleteSaaSConfig:\n    def test_delete_saas_config_not_authenticated(\n        self, saas_example_connection_config, api_client\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        response = api_client.delete(saas_config_url, headers={})\n        assert response.status_code == 401\n\n    def test_delete_saas_config_wrong_scope(\n        self,\n        saas_example_connection_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_READ])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 403\n\n    def test_delete_saas_config_does_not_exist(\n        self,\n        saas_example_connection_config_without_saas_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(\n            saas_example_connection_config_without_saas_config\n        )\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config_invalid_connection_key(\n        self,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(None)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 404\n\n    def test_delete_saas_config(\n        self,\n        db: Session,\n        saas_example_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        # Create a new connection config so we don't run into issues trying to clean up an\n        # already deleted fixture\n        fides_key = \"saas_config_for_deletion_test\"\n        saas_example_config[\"fides_key\"] = fides_key\n        config_to_delete = ConnectionConfig.create(\n            db=db,\n            data={\n                \"key\": fides_key,\n                \"name\": fides_key,\n                \"connection_type\": ConnectionType.saas,\n                \"access\": AccessLevel.read,\n                \"saas_config\": saas_example_config,\n            },\n        )\n        saas_config_url = get_saas_config_url(config_to_delete)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 204\n\n        updated_config = ConnectionConfig.get_by(db=db, field=\"key\", value=fides_key)\n        db.expire(updated_config)\n        assert updated_config.saas_config is None\n\n    def test_delete_saas_config_with_dataset_and_secrets(\n        self,\n        saas_example_connection_config,\n        saas_example_dataset_config,\n        api_client: TestClient,\n        generate_auth_header,\n    ) -> None:\n        saas_config_url = get_saas_config_url(saas_example_connection_config)\n        auth_header = generate_auth_header(scopes=[SAAS_CONFIG_DELETE])\n        response = api_client.delete(saas_config_url, headers=auth_header)\n        assert response.status_code == 400\n\n        response_body = json.loads(response.text)\n        assert (\n            response_body[\"detail\"]\n            == f\"Must delete the dataset with fides_key '{saas_example_dataset_config.fides_key}' \"\n            \"before deleting this SaaS config. Must clear the secrets from this connection \"\n            \"config before deleting the SaaS config.\"\n        )\n\n\nclass TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'\n\n\nclass TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_functions.py\": planet_express_functions,\n                \"2_functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_functions\",\n                400,\n                {\"detail\": \"Multiple Python (.py) files found, only one is allowed.\"},\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    @mock.patch(\n        \"fides.api.service.connectors.saas.connector_registry_service.register_custom_functions\"\n    )  # prevent functions from being registered to avoid test conflicts\n    def test_register_connector_template_allow_custom_connector_functions(\n        self,\n        mock_register_custom_functions: MagicMock,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                400,\n                {\n                    \"detail\": \"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template_disallow_custom_connector_functions(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n", "patch": "@@ -468,14 +468,12 @@ def complete_connector_template(\n         self,\n         planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -484,13 +482,11 @@ def complete_connector_template(\n     def connector_template_missing_config(\n         self,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -499,14 +495,12 @@ def connector_template_missing_config(\n     def connector_template_wrong_contents_config(\n         self,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": \"planet_express_config\",\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -516,14 +510,12 @@ def connector_template_invalid_config(\n         self,\n         planet_express_invalid_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_invalid_config,\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -532,13 +524,11 @@ def connector_template_invalid_config(\n     def connector_template_missing_dataset(\n         self,\n         planet_express_config,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -547,14 +537,12 @@ def connector_template_missing_dataset(\n     def connector_template_wrong_contents_dataset(\n         self,\n         planet_express_config,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"dataset.yml\": \"planet_express_dataset\",\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -564,29 +552,12 @@ def connector_template_invalid_dataset(\n         self,\n         planet_express_config,\n         planet_express_invalid_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"dataset.yml\": planet_express_invalid_dataset,\n-                \"functions.py\": planet_express_functions,\n-                \"icon.svg\": planet_express_icon,\n-            }\n-        )\n-\n-    @pytest.fixture\n-    def connector_template_no_functions(\n-        self,\n-        planet_express_config,\n-        planet_express_dataset,\n-        planet_express_icon,\n-    ):\n-        return create_zip_file(\n-            {\n-                \"config.yml\": planet_express_config,\n-                \"dataset.yml\": planet_express_dataset,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -596,13 +567,11 @@ def connector_template_no_icon(\n         self,\n         planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n             }\n         )\n \n@@ -611,15 +580,13 @@ def connector_template_duplicate_configs(\n         self,\n         planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"1_config.yml\": planet_express_config,\n                 \"2_config.yml\": planet_express_config,\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -629,33 +596,13 @@ def connector_template_duplicate_datasets(\n         self,\n         planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"1_dataset.yml\": planet_express_dataset,\n                 \"2_dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n-                \"icon.svg\": planet_express_icon,\n-            }\n-        )\n-\n-    @pytest.fixture\n-    def connector_template_duplicate_functions(\n-        self,\n-        planet_express_config,\n-        planet_express_dataset,\n-        planet_express_functions,\n-        planet_express_icon,\n-    ):\n-        return create_zip_file(\n-            {\n-                \"config.yml\": planet_express_config,\n-                \"dataset.yml\": planet_express_dataset,\n-                \"1_functions.py\": planet_express_functions,\n-                \"2_functions.py\": planet_express_functions,\n                 \"icon.svg\": planet_express_icon,\n             }\n         )\n@@ -665,14 +612,12 @@ def connector_template_duplicate_icons(\n         self,\n         planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ):\n         return create_zip_file(\n             {\n                 \"config.yml\": planet_express_config,\n                 \"dataset.yml\": planet_express_dataset,\n-                \"functions.py\": planet_express_functions,\n                 \"1_icon.svg\": planet_express_icon,\n                 \"2_icon.svg\": planet_express_icon,\n             }\n@@ -685,7 +630,6 @@ def test_register_connector_template_wrong_scope(\n         generate_auth_header,\n         complete_connector_template,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = True\n         auth_header = generate_auth_header(scopes=[CLIENT_READ])\n         response = api_client.post(\n             register_connector_template_url,\n@@ -746,11 +690,6 @@ def test_register_connector_template_wrong_scope(\n                     \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                 },\n             ),\n-            (\n-                \"connector_template_no_functions\",\n-                200,\n-                {\"message\": \"Connector template successfully registered.\"},\n-            ),\n             (\n                 \"connector_template_no_icon\",\n                 200,\n@@ -770,66 +709,14 @@ def test_register_connector_template_wrong_scope(\n                     \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                 },\n             ),\n-            (\n-                \"connector_template_duplicate_functions\",\n-                400,\n-                {\"detail\": \"Multiple Python (.py) files found, only one is allowed.\"},\n-            ),\n             (\n                 \"connector_template_duplicate_icons\",\n                 400,\n                 {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n             ),\n         ],\n     )\n-    @mock.patch(\n-        \"fides.api.service.connectors.saas.connector_registry_service.register_custom_functions\"\n-    )  # prevent functions from being registered to avoid test conflicts\n-    def test_register_connector_template_allow_custom_connector_functions(\n-        self,\n-        mock_register_custom_functions: MagicMock,\n-        api_client: TestClient,\n-        register_connector_template_url,\n-        generate_auth_header,\n-        zip_file,\n-        status_code,\n-        details,\n-        request,\n-    ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n-        response = api_client.post(\n-            register_connector_template_url,\n-            headers=auth_header,\n-            files={\n-                \"file\": (\n-                    \"template.zip\",\n-                    request.getfixturevalue(zip_file).read(),\n-                    \"application/zip\",\n-                )\n-            },\n-        )\n-        assert response.status_code == status_code\n-        assert response.json() == details\n-\n-    @pytest.mark.parametrize(\n-        \"zip_file, status_code, details\",\n-        [\n-            (\n-                \"complete_connector_template\",\n-                400,\n-                {\n-                    \"detail\": \"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n-                },\n-            ),\n-            (\n-                \"connector_template_no_functions\",\n-                200,\n-                {\"message\": \"Connector template successfully registered.\"},\n-            ),\n-        ],\n-    )\n-    def test_register_connector_template_disallow_custom_connector_functions(\n+    def test_register_connector_template(\n         self,\n         api_client: TestClient,\n         register_connector_template_url,\n@@ -839,7 +726,6 @@ def test_register_connector_template_disallow_custom_connector_functions(\n         details,\n         request,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = False\n         auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n         response = api_client.post(\n             register_connector_template_url,", "file_path": "files/2023_9/543", "file_language": "py", "file_name": "tests/ops/api/v1/endpoints/test_saas_config_endpoints.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)", "target": 0}, {"function": "class TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'", "target": 0}, {"function": "class TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_functions(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_functions.py\": planet_express_functions,\n                \"2_functions.py\": planet_express_functions,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"functions.py\": planet_express_functions,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_functions\",\n                400,\n                {\"detail\": \"Multiple Python (.py) files found, only one is allowed.\"},\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    @mock.patch(\n        \"fides.api.service.connectors.saas.connector_registry_service.register_custom_functions\"\n    )  # prevent functions from being registered to avoid test conflicts\n    def test_register_connector_template_allow_custom_connector_functions(\n        self,\n        mock_register_custom_functions: MagicMock,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                400,\n                {\n                    \"detail\": \"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n                },\n            ),\n            (\n                \"connector_template_no_functions\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template_disallow_custom_connector_functions(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details", "target": 0}], "function_after": [{"function": "def get_saas_config_url(connection_config: Optional[ConnectionConfig] = None) -> str:\n    \"\"\"Helper to construct the SAAS_CONFIG URL, substituting valid/invalid keys in the path\"\"\"\n    path = V1_URL_PREFIX + SAAS_CONFIG\n    connection_key = \"nonexistent_key\"\n    if connection_config:\n        connection_key = connection_config.key\n    path_params = {\"connection_key\": connection_key}\n    return path.format(**path_params)", "target": 0}, {"function": "class TestAuthorizeConnection:\n    @pytest.fixture\n    def authorize_url(self, oauth2_authorization_code_connection_config) -> str:\n        path = V1_URL_PREFIX + AUTHORIZE\n        path_params = {\n            \"connection_key\": oauth2_authorization_code_connection_config.key\n        }\n        return path.format(**path_params)\n\n    def test_client_not_authenticated(self, api_client: TestClient, authorize_url):\n        response = api_client.get(authorize_url)\n        assert response.status_code == 401\n\n    def test_client_wrong_scope(\n        self, api_client: TestClient, authorize_url, generate_auth_header\n    ) -> None:\n        auth_header = generate_auth_header([CLIENT_READ])\n        response = api_client.get(authorize_url, headers=auth_header)\n        assert 403 == response.status_code\n\n    @mock.patch(\n        \"fides.api.api.v1.endpoints.saas_config_endpoints.OAuth2AuthorizationCodeAuthenticationStrategy.get_authorization_url\"\n    )\n    def test_get_authorize_url(\n        self,\n        authorization_url_mock: MagicMock,\n        api_client: TestClient,\n        authorize_url,\n        generate_auth_header,\n    ):\n        authorization_url = \"https://localhost/auth/authorize\"\n        authorization_url_mock.return_value = authorization_url\n        auth_header = generate_auth_header([CONNECTION_AUTHORIZE])\n        response = api_client.get(authorize_url, headers=auth_header)\n        response.raise_for_status()\n        assert response.text == f'\"{authorization_url}\"'", "target": 0}, {"function": "class TestRegisterConnectorTemplate:\n    @pytest.fixture\n    def register_connector_template_url(self) -> str:\n        return V1_URL_PREFIX + REGISTER_CONNECTOR_TEMPLATE\n\n    @pytest.fixture\n    def complete_connector_template(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_config(\n        self,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": \"planet_express_config\",\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_config(\n        self,\n        planet_express_invalid_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_invalid_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_missing_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_wrong_contents_dataset(\n        self,\n        planet_express_config,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": \"planet_express_dataset\",\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_invalid_dataset(\n        self,\n        planet_express_config,\n        planet_express_invalid_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_invalid_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_no_icon(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_configs(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"1_config.yml\": planet_express_config,\n                \"2_config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_datasets(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"1_dataset.yml\": planet_express_dataset,\n                \"2_dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def connector_template_duplicate_icons(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        return create_zip_file(\n            {\n                \"config.yml\": planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"1_icon.svg\": planet_express_icon,\n                \"2_icon.svg\": planet_express_icon,\n            }\n        )\n\n    def test_register_connector_template_wrong_scope(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        complete_connector_template,\n    ):\n        auth_header = generate_auth_header(scopes=[CLIENT_READ])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    complete_connector_template,\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == 403\n\n    @pytest.mark.parametrize(\n        \"zip_file, status_code, details\",\n        [\n            (\n                \"complete_connector_template\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_missing_config\",\n                400,\n                {\"detail\": \"Zip file does not contain a config.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_config\",\n                400,\n                {\n                    \"detail\": \"Config contents do not contain a 'saas_config' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_config\",\n                400,\n                {\n                    \"detail\": \"1 validation error for SaaSConfig\\ntest_request\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_missing_dataset\",\n                400,\n                {\"detail\": \"Zip file does not contain a dataset.yml file.\"},\n            ),\n            (\n                \"connector_template_wrong_contents_dataset\",\n                400,\n                {\n                    \"detail\": \"Dataset contents do not contain a 'dataset' key at the root level.\"\n                },\n            ),\n            (\n                \"connector_template_invalid_dataset\",\n                400,\n                {\n                    \"detail\": \"1 validation error for Dataset\\ncollections -> 0 -> name\\n  field required (type=value_error.missing)\"\n                },\n            ),\n            (\n                \"connector_template_no_icon\",\n                200,\n                {\"message\": \"Connector template successfully registered.\"},\n            ),\n            (\n                \"connector_template_duplicate_configs\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with config.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_datasets\",\n                400,\n                {\n                    \"detail\": \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                },\n            ),\n            (\n                \"connector_template_duplicate_icons\",\n                400,\n                {\"detail\": \"Multiple svg files found, only one is allowed.\"},\n            ),\n        ],\n    )\n    def test_register_connector_template(\n        self,\n        api_client: TestClient,\n        register_connector_template_url,\n        generate_auth_header,\n        zip_file,\n        status_code,\n        details,\n        request,\n    ):\n        auth_header = generate_auth_header(scopes=[CONNECTOR_TEMPLATE_REGISTER])\n        response = api_client.post(\n            register_connector_template_url,\n            headers=auth_header,\n            files={\n                \"file\": (\n                    \"template.zip\",\n                    request.getfixturevalue(zip_file).read(),\n                    \"application/zip\",\n                )\n            },\n        )\n        assert response.status_code == status_code\n        assert response.json() == details", "target": 0}]}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/tests%2Fops%2Fmodels%2Ftest_custom_connector_template.py", "code": "from typing import Optional\n\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\n\n\nclass TestCustomConnectorTemplate:\n    def test_create_custom_connector_template(\n        self,\n        db: Session,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> None:\n        template = CustomConnectorTemplate(\n            key=\"planet_express\",\n            name=\"Planet Express\",\n            config=planet_express_config,\n            dataset=planet_express_dataset,\n            icon=planet_express_icon,\n        )\n        template.save(db=db)\n\n        # assert we can retrieve a connector template by key and\n        # that the values are the same as what we persisted\n        custom_connector: Optional[\n            CustomConnectorTemplate\n        ] = CustomConnectorTemplate.get_by_key_or_id(\n            db=db, data={\"key\": \"planet_express\"}\n        )\n        assert custom_connector\n        assert custom_connector.name == \"Planet Express\"\n        assert custom_connector.config == planet_express_config\n        assert custom_connector.dataset == planet_express_dataset\n        assert custom_connector.icon == planet_express_icon\n", "code_before": "", "patch": "@@ -12,15 +12,13 @@ def test_create_custom_connector_template(\n         planet_express_config,\n         planet_express_dataset,\n         planet_express_icon,\n-        planet_express_functions,\n     ) -> None:\n         template = CustomConnectorTemplate(\n             key=\"planet_express\",\n             name=\"Planet Express\",\n             config=planet_express_config,\n             dataset=planet_express_dataset,\n             icon=planet_express_icon,\n-            functions=planet_express_functions,\n         )\n         template.save(db=db)\n \n@@ -36,4 +34,3 @@ def test_create_custom_connector_template(\n         assert custom_connector.config == planet_express_config\n         assert custom_connector.dataset == planet_express_dataset\n         assert custom_connector.icon == planet_express_icon\n-        assert custom_connector.functions == planet_express_functions", "file_path": "files/2023_9/544", "file_language": "py", "file_name": "tests/ops/models/test_custom_connector_template.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": [{"function": "class TestCustomConnectorTemplate:\n    def test_create_custom_connector_template(\n        self,\n        db: Session,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> None:\n        template = CustomConnectorTemplate(\n            key=\"planet_express\",\n            name=\"Planet Express\",\n            config=planet_express_config,\n            dataset=planet_express_dataset,\n            icon=planet_express_icon,\n        )\n        template.save(db=db)\n\n        # assert we can retrieve a connector template by key and\n        # that the values are the same as what we persisted\n        custom_connector: Optional[\n            CustomConnectorTemplate\n        ] = CustomConnectorTemplate.get_by_key_or_id(\n            db=db, data={\"key\": \"planet_express\"}\n        )\n        assert custom_connector\n        assert custom_connector.name == \"Planet Express\"\n        assert custom_connector.config == planet_express_config\n        assert custom_connector.dataset == planet_express_dataset\n        assert custom_connector.icon == planet_express_icon", "target": 0}]}, {"raw_url": "https://github.com/ethyca/fides/raw/5989b5fa744c8d8c340963b895a054883549358a/tests%2Fops%2Fservice%2Fconnectors%2Ftest_connector_template_loaders.py", "code": "import os\nfrom io import BytesIO\nfrom unittest import mock\nfrom unittest.mock import MagicMock\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.common_exceptions import NoSuchSaaSRequestOverrideException\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.service.authentication.authentication_strategy import (\n    AuthenticationStrategy,\n)\nfrom fides.api.service.connectors.saas.connector_registry_service import (\n    ConnectorRegistry,\n    CustomConnectorTemplateLoader,\n    FileConnectorTemplateLoader,\n)\nfrom fides.api.service.saas_request.saas_request_override_factory import (\n    SaaSRequestOverrideFactory,\n    SaaSRequestType,\n)\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config_from_string,\n    load_yaml_as_string,\n    replace_version,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None\n\n\nclass TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template_with_functions(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # assert the request override was ignored\n        with pytest.raises(NoSuchSaaSRequestOverrideException) as exc:\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.UPDATE\n            )\n        assert (\n            f\"Custom SaaS override 'planet_express_user_access' does not exist.\"\n            in str(exc.value)\n        )\n\n        # assert the strategy was ignored\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"\n", "code_before": "import os\nfrom io import BytesIO\nfrom unittest import mock\nfrom unittest.mock import MagicMock\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.common_exceptions import NoSuchSaaSRequestOverrideException\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.service.authentication.authentication_strategy import (\n    AuthenticationStrategy,\n)\nfrom fides.api.service.connectors.saas.connector_registry_service import (\n    ConnectorRegistry,\n    CustomConnectorTemplateLoader,\n    FileConnectorTemplateLoader,\n    register_custom_functions,\n)\nfrom fides.api.service.saas_request.saas_request_override_factory import (\n    SaaSRequestOverrideFactory,\n    SaaSRequestType,\n)\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config_from_string,\n    load_yaml_as_string,\n    replace_version,\n)\nfrom fides.config import CONFIG\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None\n\n\nclass TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # verify the custom functions aren't loaded if the template is invalid\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=\"planet_express_functions\",\n            )\n        ]\n\n        # verify nothing is loaded if the custom functions fail to load\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled_custom_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        \"\"\"\n        A connector template with no custom functions should still be loaded\n        even if allow_custom_connector_functions is set to false\n        \"\"\"\n\n        CONFIG.security.allow_custom_connector_functions = False\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=None,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n        # assert the request override was registered\n        SaaSRequestOverrideFactory.get_override(\n            \"planet_express_user_access\", SaaSRequestType.READ\n        )\n\n        # assert the strategy was registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    def test_custom_connector_template_loader_disallowed_modules(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        with pytest.raises(SyntaxError) as exc:\n            CustomConnectorTemplateLoader.save_template(\n                MagicMock(),\n                ZipFile(\n                    create_zip_file(\n                        {\n                            \"config.yml\": planet_express_config,\n                            \"dataset.yml\": planet_express_dataset,\n                            \"functions.py\": \"import os\",\n                            \"icon.svg\": planet_express_icon,\n                        }\n                    )\n                ),\n            )\n        assert \"Import of 'os' module is not allowed.\" == str(exc.value)\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"\n\n\nclass TestRegisterCustomFunctions:\n    def test_function_loader(self):\n        \"\"\"Verify that all override implementations can be loaded by RestrictedPython\"\"\"\n\n        overrides_path = \"src/fides/api/service/saas_request/override_implementations\"\n\n        for filename in os.listdir(overrides_path):\n            if filename.endswith(\".py\") and filename != \"__init__.py\":\n                file_path = os.path.join(overrides_path, filename)\n                with open(file_path, \"r\") as file:\n                    register_custom_functions(file.read())\n", "patch": "@@ -16,7 +16,6 @@\n     ConnectorRegistry,\n     CustomConnectorTemplateLoader,\n     FileConnectorTemplateLoader,\n-    register_custom_functions,\n )\n from fides.api.service.saas_request.saas_request_override_factory import (\n     SaaSRequestOverrideFactory,\n@@ -113,15 +112,13 @@ def replaceable_planet_express_zip(\n         self,\n         replaceable_planet_express_config,\n         planet_express_dataset,\n-        planet_express_functions,\n         planet_express_icon,\n     ) -> BytesIO:\n         return create_zip_file(\n             {\n                 \"config.yml\": replaceable_planet_express_config,\n                 \"dataset.yml\": planet_express_dataset,\n                 \"icon.svg\": planet_express_icon,\n-                \"functions.py\": planet_express_functions,\n             }\n         )\n \n@@ -135,8 +132,6 @@ def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesI\n         )\n \n     def test_custom_connector_template_loader_no_templates(self):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n         connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n         assert connector_templates == {}\n \n@@ -148,143 +143,20 @@ def test_custom_connector_template_loader_invalid_template(\n         mock_all: MagicMock,\n         planet_express_dataset,\n         planet_express_icon,\n-        planet_express_functions,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n         mock_all.return_value = [\n             CustomConnectorTemplate(\n                 key=\"planet_express\",\n                 name=\"Planet Express\",\n                 config=\"planet_express_config\",\n                 dataset=planet_express_dataset,\n                 icon=planet_express_icon,\n-                functions=planet_express_functions,\n-            )\n-        ]\n-\n-        # verify the custom functions aren't loaded if the template is invalid\n-        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n-        assert connector_templates == {}\n-\n-        with pytest.raises(NoSuchSaaSRequestOverrideException):\n-            SaaSRequestOverrideFactory.get_override(\n-                \"planet_express_user_access\", SaaSRequestType.READ\n-            )\n-\n-        # assert the strategy was not registered\n-        authentication_strategies = AuthenticationStrategy.get_strategies()\n-        assert \"planet_express\" not in [\n-            strategy.name for strategy in authentication_strategies\n-        ]\n-\n-    @mock.patch(\n-        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n-    )\n-    def test_custom_connector_template_loader_invalid_functions(\n-        self,\n-        mock_all: MagicMock,\n-        planet_express_config,\n-        planet_express_dataset,\n-        planet_express_icon,\n-    ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n-        # save custom connector template to the database\n-        mock_all.return_value = [\n-            CustomConnectorTemplate(\n-                key=\"planet_express\",\n-                name=\"Planet Express\",\n-                config=planet_express_config,\n-                dataset=planet_express_dataset,\n-                icon=planet_express_icon,\n-                functions=\"planet_express_functions\",\n-            )\n-        ]\n-\n-        # verify nothing is loaded if the custom functions fail to load\n-        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n-        assert connector_templates == {}\n-\n-    @mock.patch(\n-        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n-    )\n-    def test_custom_connector_template_loader_custom_connector_functions_disabled(\n-        self,\n-        mock_all: MagicMock,\n-        planet_express_config,\n-        planet_express_dataset,\n-        planet_express_icon,\n-        planet_express_functions,\n-    ):\n-        CONFIG.security.allow_custom_connector_functions = False\n-\n-        mock_all.return_value = [\n-            CustomConnectorTemplate(\n-                key=\"planet_express\",\n-                name=\"Planet Express\",\n-                config=planet_express_config,\n-                dataset=planet_express_dataset,\n-                icon=planet_express_icon,\n-                functions=planet_express_functions,\n             )\n         ]\n \n-        # load custom connector templates from the database\n         connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n         assert connector_templates == {}\n \n-        with pytest.raises(NoSuchSaaSRequestOverrideException):\n-            SaaSRequestOverrideFactory.get_override(\n-                \"planet_express_user_access\", SaaSRequestType.READ\n-            )\n-\n-        # assert the strategy was not registered\n-        authentication_strategies = AuthenticationStrategy.get_strategies()\n-        assert \"planet_express\" not in [\n-            strategy.name for strategy in authentication_strategies\n-        ]\n-\n-    @mock.patch(\n-        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n-    )\n-    def test_custom_connector_template_loader_custom_connector_functions_disabled_custom_functions(\n-        self,\n-        mock_all: MagicMock,\n-        planet_express_config,\n-        planet_express_dataset,\n-        planet_express_icon,\n-    ):\n-        \"\"\"\n-        A connector template with no custom functions should still be loaded\n-        even if allow_custom_connector_functions is set to false\n-        \"\"\"\n-\n-        CONFIG.security.allow_custom_connector_functions = False\n-\n-        # save custom connector template to the database\n-        mock_all.return_value = [\n-            CustomConnectorTemplate(\n-                key=\"planet_express\",\n-                name=\"Planet Express\",\n-                config=planet_express_config,\n-                dataset=planet_express_dataset,\n-                icon=planet_express_icon,\n-                functions=None,\n-            )\n-        ]\n-\n-        # load custom connector templates from the database\n-        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n-        assert connector_templates == {\n-            \"planet_express\": ConnectorTemplate(\n-                config=planet_express_config,\n-                dataset=planet_express_dataset,\n-                icon=planet_express_icon,\n-                human_readable=\"Planet Express\",\n-            )\n-        }\n-\n     @mock.patch(\n         \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n     )\n@@ -294,18 +166,14 @@ def test_custom_connector_template_loader(\n         planet_express_config,\n         planet_express_dataset,\n         planet_express_icon,\n-        planet_express_functions,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n         mock_all.return_value = [\n             CustomConnectorTemplate(\n                 key=\"planet_express\",\n                 name=\"Planet Express\",\n                 config=planet_express_config,\n                 dataset=planet_express_dataset,\n                 icon=planet_express_icon,\n-                functions=planet_express_functions,\n             )\n         ]\n \n@@ -318,22 +186,10 @@ def test_custom_connector_template_loader(\n                 config=planet_express_config,\n                 dataset=planet_express_dataset,\n                 icon=planet_express_icon,\n-                functions=planet_express_functions,\n                 human_readable=\"Planet Express\",\n             )\n         }\n \n-        # assert the request override was registered\n-        SaaSRequestOverrideFactory.get_override(\n-            \"planet_express_user_access\", SaaSRequestType.READ\n-        )\n-\n-        # assert the strategy was registered\n-        authentication_strategies = AuthenticationStrategy.get_strategies()\n-        assert \"planet_express\" in [\n-            strategy.name for strategy in authentication_strategies\n-        ]\n-\n     @mock.patch(\n         \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n     )\n@@ -343,18 +199,14 @@ def test_loaders_have_separate_instances(\n         planet_express_config,\n         planet_express_dataset,\n         planet_express_icon,\n-        planet_express_functions,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n         mock_all.return_value = [\n             CustomConnectorTemplate(\n                 key=\"planet_express\",\n                 name=\"Planet Express\",\n                 config=planet_express_config,\n                 dataset=planet_express_dataset,\n                 icon=planet_express_icon,\n-                functions=planet_express_functions,\n             )\n         ]\n \n@@ -375,7 +227,6 @@ def test_custom_connector_save_template(\n         planet_express_config,\n         planet_express_dataset,\n         planet_express_icon,\n-        planet_express_functions,\n     ):\n         db = MagicMock()\n \n@@ -386,7 +237,6 @@ def test_custom_connector_save_template(\n                     {\n                         \"config.yml\": planet_express_config,\n                         \"dataset.yml\": planet_express_dataset,\n-                        \"functions.py\": planet_express_functions,\n                         \"icon.svg\": planet_express_icon,\n                     }\n                 )\n@@ -401,37 +251,55 @@ def test_custom_connector_save_template(\n                     {\n                         \"config.yml\": planet_express_config,\n                         \"dataset.yml\": planet_express_dataset,\n-                        \"functions.py\": planet_express_functions,\n                         \"icon.svg\": planet_express_icon,\n                     }\n                 )\n             ),\n         )\n         assert mock_create_or_update.call_count == 2\n \n-    def test_custom_connector_template_loader_disallowed_modules(\n+    @mock.patch(\n+        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n+    )\n+    def test_custom_connector_save_template_with_functions(\n         self,\n+        mock_create_or_update: MagicMock,\n         planet_express_config,\n         planet_express_dataset,\n+        planet_express_functions,\n         planet_express_icon,\n     ):\n-        CONFIG.security.allow_custom_connector_functions = True\n-\n-        with pytest.raises(SyntaxError) as exc:\n-            CustomConnectorTemplateLoader.save_template(\n-                MagicMock(),\n-                ZipFile(\n-                    create_zip_file(\n-                        {\n-                            \"config.yml\": planet_express_config,\n-                            \"dataset.yml\": planet_express_dataset,\n-                            \"functions.py\": \"import os\",\n-                            \"icon.svg\": planet_express_icon,\n-                        }\n-                    )\n-                ),\n+        db = MagicMock()\n+\n+        CustomConnectorTemplateLoader.save_template(\n+            db,\n+            ZipFile(\n+                create_zip_file(\n+                    {\n+                        \"config.yml\": planet_express_config,\n+                        \"dataset.yml\": planet_express_dataset,\n+                        \"functions.py\": planet_express_functions,\n+                        \"icon.svg\": planet_express_icon,\n+                    }\n+                )\n+            ),\n+        )\n+\n+        # assert the request override was ignored\n+        with pytest.raises(NoSuchSaaSRequestOverrideException) as exc:\n+            SaaSRequestOverrideFactory.get_override(\n+                \"planet_express_user_access\", SaaSRequestType.UPDATE\n             )\n-        assert \"Import of 'os' module is not allowed.\" == str(exc.value)\n+        assert (\n+            f\"Custom SaaS override 'planet_express_user_access' does not exist.\"\n+            in str(exc.value)\n+        )\n+\n+        # assert the strategy was ignored\n+        authentication_strategies = AuthenticationStrategy.get_strategies()\n+        assert \"planet_express\" not in [\n+            strategy.name for strategy in authentication_strategies\n+        ]\n \n     @mock.patch(\n         \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n@@ -614,16 +482,3 @@ def test_non_replaceable_template(\n         config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n         custom_config = load_config_from_string(config_contents)\n         assert custom_config[\"version\"] == \"0.0.0\"\n-\n-\n-class TestRegisterCustomFunctions:\n-    def test_function_loader(self):\n-        \"\"\"Verify that all override implementations can be loaded by RestrictedPython\"\"\"\n-\n-        overrides_path = \"src/fides/api/service/saas_request/override_implementations\"\n-\n-        for filename in os.listdir(overrides_path):\n-            if filename.endswith(\".py\") and filename != \"__init__.py\":\n-                file_path = os.path.join(overrides_path, filename)\n-                with open(file_path, \"r\") as file:\n-                    register_custom_functions(file.read())", "file_path": "files/2023_9/545", "file_language": "py", "file_name": "tests/ops/service/connectors/test_connector_template_loaders.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None", "target": 0}, {"function": "class TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n                \"functions.py\": planet_express_functions,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # verify the custom functions aren't loaded if the template is invalid\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=\"planet_express_functions\",\n            )\n        ]\n\n        # verify nothing is loaded if the custom functions fail to load\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = False\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n        with pytest.raises(NoSuchSaaSRequestOverrideException):\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.READ\n            )\n\n        # assert the strategy was not registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_custom_connector_functions_disabled_custom_functions(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        \"\"\"\n        A connector template with no custom functions should still be loaded\n        even if allow_custom_connector_functions is set to false\n        \"\"\"\n\n        CONFIG.security.allow_custom_connector_functions = False\n\n        # save custom connector template to the database\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=None,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n        # assert the request override was registered\n        SaaSRequestOverrideFactory.get_override(\n            \"planet_express_user_access\", SaaSRequestType.READ\n        )\n\n        # assert the strategy was registered\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                functions=planet_express_functions,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n        planet_express_functions,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    def test_custom_connector_template_loader_disallowed_modules(\n        self,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        CONFIG.security.allow_custom_connector_functions = True\n\n        with pytest.raises(SyntaxError) as exc:\n            CustomConnectorTemplateLoader.save_template(\n                MagicMock(),\n                ZipFile(\n                    create_zip_file(\n                        {\n                            \"config.yml\": planet_express_config,\n                            \"dataset.yml\": planet_express_dataset,\n                            \"functions.py\": \"import os\",\n                            \"icon.svg\": planet_express_icon,\n                        }\n                    )\n                ),\n            )\n        assert \"Import of 'os' module is not allowed.\" == str(exc.value)\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"", "target": 0}, {"function": "class TestRegisterCustomFunctions:\n    def test_function_loader(self):\n        \"\"\"Verify that all override implementations can be loaded by RestrictedPython\"\"\"\n\n        overrides_path = \"src/fides/api/service/saas_request/override_implementations\"\n\n        for filename in os.listdir(overrides_path):\n            if filename.endswith(\".py\") and filename != \"__init__.py\":\n                file_path = os.path.join(overrides_path, filename)\n                with open(file_path, \"r\") as file:\n                    register_custom_functions(file.read())", "target": 0}], "function_after": [{"function": "class TestFileConnectorTemplateLoader:\n    def test_file_connector_template_loader(self):\n        loader = FileConnectorTemplateLoader()\n        connector_templates = loader.get_connector_templates()\n\n        assert connector_templates\n\n        mailchimp_connector = connector_templates.get(\"mailchimp\")\n        assert mailchimp_connector\n\n        assert mailchimp_connector.config == load_yaml_as_string(\n            \"data/saas/config/mailchimp_config.yml\"\n        )\n        assert mailchimp_connector.dataset == load_yaml_as_string(\n            \"data/saas/dataset/mailchimp_dataset.yml\"\n        )\n        assert mailchimp_connector.icon == encode_file_contents(\n            \"data/saas/icon/mailchimp.svg\"\n        )\n        assert mailchimp_connector.human_readable == \"Mailchimp\"\n\n    def test_file_connector_template_loader_connector_not_found(self):\n        connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n\n        assert connector_templates.get(\"not_found\") is None", "target": 0}, {"function": "class TestCustomConnectorTemplateLoader:\n    @pytest.fixture(autouse=True)\n    def reset_connector_template_loaders(self):\n        \"\"\"\n        Resets the loader singleton instances before each test\n        \"\"\"\n        FileConnectorTemplateLoader._instance = None\n        CustomConnectorTemplateLoader._instance = None\n\n    @pytest.fixture\n    def zendesk_config(self) -> str:\n        return load_yaml_as_string(\"data/saas/config/zendesk_config.yml\")\n\n    @pytest.fixture\n    def zendesk_dataset(self) -> str:\n        return load_yaml_as_string(\"data/saas/dataset/zendesk_dataset.yml\")\n\n    @pytest.fixture\n    def replaceable_zendesk_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/replaceable_zendesk_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_config(self) -> str:\n        return load_yaml_as_string(\n            \"tests/fixtures/saas/test_data/planet_express/replaceable_planet_express_config.yml\"\n        )\n\n    @pytest.fixture\n    def replaceable_zendesk_zip(\n        self, replaceable_zendesk_config, zendesk_dataset\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(replaceable_zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    @pytest.fixture\n    def replaceable_planet_express_zip(\n        self,\n        replaceable_planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replaceable_planet_express_config,\n                \"dataset.yml\": planet_express_dataset,\n                \"icon.svg\": planet_express_icon,\n            }\n        )\n\n    @pytest.fixture\n    def non_replaceable_zendesk_zip(self, zendesk_config, zendesk_dataset) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": replace_version(zendesk_config, \"0.0.0\"),\n                \"dataset.yml\": zendesk_dataset,\n            }\n        )\n\n    def test_custom_connector_template_loader_no_templates(self):\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader_invalid_template(\n        self,\n        mock_all: MagicMock,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=\"planet_express_config\",\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n        assert connector_templates == {}\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_template_loader(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        connector_templates = CustomConnectorTemplateLoader.get_connector_templates()\n\n        # verify that the template in the registry is the same as the one in the database\n        assert connector_templates == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n                human_readable=\"Planet Express\",\n            )\n        }\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_loaders_have_separate_instances(\n        self,\n        mock_all: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                icon=planet_express_icon,\n            )\n        ]\n\n        # load custom connector templates from the database\n        file_connector_templates = FileConnectorTemplateLoader.get_connector_templates()\n        custom_connector_templates = (\n            CustomConnectorTemplateLoader.get_connector_templates()\n        )\n\n        assert file_connector_templates != custom_connector_templates\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # verify that a connector template can updated with no issue\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n        assert mock_create_or_update.call_count == 2\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_custom_connector_save_template_with_functions(\n        self,\n        mock_create_or_update: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n        planet_express_functions,\n        planet_express_icon,\n    ):\n        db = MagicMock()\n\n        CustomConnectorTemplateLoader.save_template(\n            db,\n            ZipFile(\n                create_zip_file(\n                    {\n                        \"config.yml\": planet_express_config,\n                        \"dataset.yml\": planet_express_dataset,\n                        \"functions.py\": planet_express_functions,\n                        \"icon.svg\": planet_express_icon,\n                    }\n                )\n            ),\n        )\n\n        # assert the request override was ignored\n        with pytest.raises(NoSuchSaaSRequestOverrideException) as exc:\n            SaaSRequestOverrideFactory.get_override(\n                \"planet_express_user_access\", SaaSRequestType.UPDATE\n            )\n        assert (\n            f\"Custom SaaS override 'planet_express_user_access' does not exist.\"\n            in str(exc.value)\n        )\n\n        # assert the strategy was ignored\n        authentication_strategies = AuthenticationStrategy.get_strategies()\n        assert \"planet_express\" not in [\n            strategy.name for strategy in authentication_strategies\n        ]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        deleted when a newer version of the connector template is found in\n        the FileConnectorTemplateLoader.\n        \"\"\"\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=replace_version(zendesk_config, \"0.0.0\"),\n                dataset=zendesk_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert (\n            saas_config[\"version\"] == load_config_from_string(zendesk_config)[\"version\"]\n        )\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {}\n        mock_delete.assert_called_once()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_replaceable_with_update_not_available(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        planet_express_config,\n        planet_express_dataset,\n    ):\n        \"\"\"\n        Verify that an existing connector template flagged as replaceable is\n        not deleted if a newer version of the connector template is not found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        planet_express_config = replace_version(planet_express_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"planet_express\",\n                name=\"Planet Express\",\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                replaceable=True,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"planet_express\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"planet_express\": ConnectorTemplate(\n                config=planet_express_config,\n                dataset=planet_express_dataset,\n                human_readable=\"Planet Express\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.delete\"\n    )\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.all\"\n    )\n    def test_custom_connector_replacement_not_replaceable(\n        self,\n        mock_all: MagicMock,\n        mock_delete: MagicMock,\n        zendesk_config,\n        zendesk_dataset,\n    ):\n        \"\"\"\n        Verify that an existing custom connector template flagged as not replaceable is\n        not deleted even if a newer version of the connector template is found\n        in the FileConnectorTemplateLoader.\n        \"\"\"\n        zendesk_config = replace_version(zendesk_config, \"0.0.0\")\n\n        mock_all.return_value = [\n            CustomConnectorTemplate(\n                key=\"zendesk\",\n                name=\"Zendesk\",\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                replaceable=False,\n            )\n        ]\n\n        template = ConnectorRegistry.get_connector_template(\"zendesk\")\n        assert template\n        saas_config = load_config_from_string(template.config)\n        assert saas_config[\"version\"] == \"0.0.0\"\n        assert CustomConnectorTemplateLoader.get_connector_templates() == {\n            \"zendesk\": ConnectorTemplate(\n                config=zendesk_config,\n                dataset=zendesk_dataset,\n                human_readable=\"Zendesk\",\n            )\n        }\n        mock_delete.assert_not_called()\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_existing_template(\n        self, mock_create_or_update: MagicMock, zendesk_config, replaceable_zendesk_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template takes on the version of the existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_zendesk_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        existing_config = load_config_from_string(zendesk_config)\n        assert custom_config[\"version\"] == existing_config[\"version\"]\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_replaceable_template_for_new_template(\n        self, mock_create_or_update: MagicMock, replaceable_planet_express_zip\n    ):\n        \"\"\"\n        Verify that a replaceable custom connector template keeps its version if there is no existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(replaceable_planet_express_zip)\n        )\n\n        assert mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.1\"\n\n    @mock.patch(\n        \"fides.api.models.custom_connector_template.CustomConnectorTemplate.create_or_update\"\n    )\n    def test_non_replaceable_template(\n        self,\n        mock_create_or_update: MagicMock,\n        non_replaceable_zendesk_zip,\n    ):\n        \"\"\"\n        Verify that a non replaceable connector template keeps its version even if there is an existing connector template.\n        \"\"\"\n        CustomConnectorTemplateLoader.save_template(\n            db=MagicMock(), zip_file=ZipFile(non_replaceable_zendesk_zip)\n        )\n        assert not mock_create_or_update.call_args.kwargs[\"data\"][\"replaceable\"]\n        config_contents = mock_create_or_update.call_args.kwargs[\"data\"][\"config\"]\n        custom_config = load_config_from_string(config_contents)\n        assert custom_config[\"version\"] == \"0.0.0\"", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
