{"index": 4126, "cve_id": "CVE-2019-19010", "cwe_id": ["CWE-94", "CWE-20"], "cve_language": "Python", "cve_description": "Eval injection in the Math plugin of Limnoria (before 2019.11.09) and Supybot (through 2018-05-09) allows remote unprivileged attackers to disclose information or possibly have unspecified other impact via the calc and icalc IRC commands.", "cvss": "9.8", "publish_date": "November 15, 2019", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "3848ae78de45b35c029cc333963d436b9d2f0a35", "commit_message": "Math: Rewrite calc functions with a proper evaluator.\n\nInstead of hacking around eval(), which everyone knows is a bad idea\neven with prior expression sanitizing.", "commit_date": "2019-11-09T14:49:31Z", "project": "progval/limnoria", "url": "https://api.github.com/repos/progval/Limnoria/commits/3848ae78de45b35c029cc333963d436b9d2f0a35", "html_url": "https://github.com/progval/Limnoria/commit/3848ae78de45b35c029cc333963d436b9d2f0a35", "windows_before": [{"commit_id": "5e2343f717d9f78bd57930ccd73491d79a0b39d7", "commit_date": "Fri Nov 8 20:53:04 2019 +0100", "commit_message": "Update doc of capabilities.default to mention 'channel capability setdefault'.", "files_name": ["src/ircdb.py"]}, {"commit_id": "04b55805b8175e0f29d0f4d77dbae2b91b96d5d1", "commit_date": "Sat Nov 2 20:52:58 2019 +0100", "commit_message": "Log SASL mechanism on failure. Closes GH-1014.", "files_name": ["src/irclib.py"]}, {"commit_id": "813f6888581c59e2f53b9c1cff86816c28f01da1", "commit_date": "Sat Nov 2 18:50:20 2019 +0100", "commit_message": "Config: Add : prefix to network-specific values listed by 'config list'.", "files_name": ["plugins/Config/plugin.py", "plugins/Config/test.py"]}, {"commit_id": "322923c9577ec0cfffaec65db5c51392d802574d", "commit_date": "Sat Nov 2 18:47:45 2019 +0100", "commit_message": "Config: make 'config list' exclude pseudo-children of network-specific variables.", "files_name": ["plugins/Config/plugin.py", "plugins/Config/test.py"]}, {"commit_id": "9e58b2c936d1a81df8eb961c95c47cfbfc38e49c", "commit_date": "Fri Nov 1 22:21:51 2019 +0100", "commit_message": "Owner: Fix @upkeep reply on recent Pypy versions.", "files_name": ["plugins/Owner/plugin.py"]}, {"commit_id": "10ccfbbf3c1fd84a22d55cde63e573cb178872b5", "commit_date": "Fri Nov 1 22:18:32 2019 +0100", "commit_message": "Remove early return in upkeep() in case sys.stdout is replaced.", "files_name": ["src/world.py"]}, {"commit_id": "57dee45734638a8638f37bf39a551ca4c61d41c3", "commit_date": "Fri Nov 1 21:39:53 2019 +0100", "commit_message": ".travis.yml: Add pypy3 to build matrix.", "files_name": [".travis.yml"]}, {"commit_id": "7466058c8f5e1fa8f29b417e385640c9a40cf752", "commit_date": "Fri Nov 1 05:06:45 2019 -0300", "commit_message": "Web: Catch more errors in getTitle.", "files_name": ["plugins/Web/plugin.py"]}, {"commit_id": "3648751911688334407566a9b905b270f61761f0", "commit_date": "Mon Oct 28 18:17:05 2019 +0100", "commit_message": "MoobotFactoids: Don't rely on unspecified order of sqlite3 results. Closes GH-1383.", "files_name": ["plugins/MoobotFactoids/test.py"]}, {"commit_id": "cf954cf5002969c4335ff72154c3514c72d152d0", "commit_date": "Mon Oct 28 18:16:04 2019 +0100", "commit_message": "MoobotFactoids: Fix test to actually detect that sqlite3 is installed.", "files_name": ["plugins/MoobotFactoids/test.py"]}, {"commit_id": "103210e6835ca9f6ffbe76f72a79f27e7810dd09", "commit_date": "Mon Oct 28 18:08:09 2019 +0100", "commit_message": "Explicitly include test/ in release tarballs. Closes GH-1384.", "files_name": ["MANIFEST.in"]}, {"commit_id": "9eecedee9327ae5e4630bd0597661fad44fc7c91", "commit_date": "Sun Oct 27 12:59:37 2019 -0700", "commit_message": "Fill in author info for plugins missing it", "files_name": ["plugins/Aka/__init__.py", "plugins/Conditional/__init__.py", "plugins/GPG/__init__.py", "plugins/MessageParser/__init__.py", "plugins/NickAuth/__init__.py"]}, {"commit_id": "9268356e973f8c0553df69027c9b8dc626d0be3e", "commit_date": "Fri Oct 25 23:07:31 2019 +0200", "commit_message": "Split 'CAP REQ' commands to not exceed 512 bytes.", "files_name": ["src/irclib.py", "test/test_irclib.py"]}, {"commit_id": "0014b206ada2cc1fbabe497a0048e2bfed608511", "commit_date": "Fri Oct 25 22:40:51 2019 +0200", "commit_message": "Reset capability set state on reconnection.", "files_name": ["src/irclib.py"]}, {"commit_id": "cfbbed3da972f0f2e63ed939e5f1bb48e5d8798a", "commit_date": "Fri Oct 25 22:31:02 2019 +0200", "commit_message": "Truncate incoming lines to 512-2, not 500.", "files_name": ["src/irclib.py"]}, {"commit_id": "71cc414ff34a3908b53f27bbc84a5f33a5453131", "commit_date": "Tue Oct 22 17:57:39 2019 +0200", "commit_message": "Fix conditional on CTCP in urlSnarfer.", "files_name": ["src/commands.py"]}, {"commit_id": "d3a2964705e5203839255c9e992860e6e6874f68", "commit_date": "Sat Oct 19 12:01:47 2019 -0700", "commit_message": "Plugin: add missing substitution, check for supybot.authors.unknown explicitly", "files_name": ["plugins/Plugin/plugin.py"]}, {"commit_id": "35a64eca380d48e0f90b37eb4083239abcad6f93", "commit_date": "Sat Oct 19 11:32:30 2019 -0700", "commit_message": "Plugin: update tests", "files_name": ["plugins/Plugin/__init__.py", "plugins/Plugin/test.py", "src/__init__.py"]}, {"commit_id": "e3d89875aeb39244ac5631fe5d2a6743a58a0458", "commit_date": "Sat Oct 19 11:27:11 2019 -0700", "commit_message": "Plugin: update plugin description in __init__.py", "files_name": ["plugins/Plugin/__init__.py"]}, {"commit_id": "75a96ffa176ca2cb07cfa7b9ae68def73ca4aa2d", "commit_date": "Sat Oct 19 11:17:35 2019 -0700", "commit_message": "Plugin: show individual contributions in 'contributors [nick]' as a list", "files_name": ["plugins/Plugin/plugin.py"]}, {"commit_id": "672652d7802042f0877b080a0da25f505542536b", "commit_date": "Sat Oct 19 11:09:55 2019 -0700", "commit_message": "Plugin: refactor the first half of 'contributors [nick]'", "files_name": ["plugins/Plugin/plugin.py"]}, {"commit_id": "65e3e18fe27f4439891a97841e366dd7a2f4a7c9", "commit_date": "Sat Oct 19 10:45:12 2019 -0700", "commit_message": "Plugin: simplify the 'contributors' command", "files_name": ["plugins/Plugin/plugin.py"]}, {"commit_id": "930da6a6bac1edb4e2dc13a750da3a1093a7b3eb", "commit_date": "Sat Oct 19 10:17:53 2019 -0700", "commit_message": "Use a real invalid email in supybot.authors.unknown", "files_name": ["src/__init__.py"]}, {"commit_id": "e7f033539b2c894dc2d973c3b3c98c019fb0afce", "commit_date": "Sat Oct 19 10:16:35 2019 -0700", "commit_message": "Don't repeat nick in supybot.Author if nick and name are the same", "files_name": ["src/__init__.py"]}, {"commit_id": "7ac2828ab2438a79fb2de2be101022f493eae850", "commit_date": "Sat Oct 19 10:12:42 2019 -0700", "commit_message": "supybot-plugin-create: CVS is dead, stop mentioning it", "files_name": ["scripts/supybot-plugin-create"]}, {"commit_id": "18f9a342b3d66b879a52aa37ca0ac91d9175ce8a", "commit_date": "Sat Oct 19 09:57:13 2019 -0700", "commit_message": "Throw out mungeEmail for supybot.Author", "files_name": ["plugins/Plugin/plugin.py", "src/__init__.py"]}, {"commit_id": "00b2e9c97aa617e407173e05cdba4882e6521e9e", "commit_date": "Fri Oct 18 15:44:33 2019 -0400", "commit_message": "Remove the /debian directory. This is not really a native Debian package and this directory hasn't been touched in years. The actual Debian packaging work is done on salsa.debian.org.", "files_name": ["debian/changelog", "debian/compat", "debian/control.py2", "debian/control.py3", "debian/copyright", "debian/postinst", "debian/prerm", "debian/rules"]}, {"commit_id": "b54d8f8073b4fca1787012b211337dc707cfea45", "commit_date": "Thu Oct 17 12:30:07 2019 -0700", "commit_message": "regexp_wrapper: return None instead of False when search times out (#1379)", "files_name": ["src/commands.py"]}, {"commit_id": "27e7d6a9acd3d39053b938612764abfb5530e81d", "commit_date": "Thu Oct 10 17:27:34 2019 +0200", "commit_message": "Aka: Add web UI (#1373)", "files_name": ["plugins/Aka/config.py", "plugins/Aka/plugin.py", "plugins/Aka/test.py", "src/httpserver.py", "src/test.py", "src/utils/web.py"]}, {"commit_id": "68539da7ab5f733ca7f3c188b76d7942e1632fcb", "commit_date": "Thu Oct 10 15:46:36 2019 +0100", "commit_message": "Format: use string.capwords() - not .title() (#1378)", "files_name": ["plugins/Format/plugin.py", "plugins/Format/test.py"]}, {"commit_id": "3c23faf1bdee4c0c707694a6645d949e3436592a", "commit_date": "Sun Oct 6 11:42:31 2019 -0700", "commit_message": "RSS: add 'announce channels' command to list channels a feed is announced to", "files_name": ["plugins/RSS/plugin.py", "plugins/RSS/test.py"]}, {"commit_id": "ba6878375bdf486caeca564db81d8d75b92c4b6e", "commit_date": "Sun Oct 6 17:21:12 2019 +0200", "commit_message": "plugins/Config: Reply with success on setdefault", "files_name": ["plugins/Config/plugin.py"]}, {"commit_id": "beb1000c7ede002642824c785b506246757a1121", "commit_date": "Sat Oct 5 16:40:37 2019 -0700", "commit_message": "Network: send whois requests using the original nick case", "files_name": ["plugins/Network/plugin.py"]}, {"commit_id": "8b2cbbc5830c425c52e29f8ba0b5519337cb8894", "commit_date": "Sat Oct 5 22:29:00 2019 +0200", "commit_message": "Use a monotonic time for registry cache.", "files_name": ["setup.py", "src/registry.py", "src/test.py"]}, {"commit_id": "702cfaaf9725a1d6bbb5bcd535b3d22a4d8ae255", "commit_date": "Sat Oct 5 15:57:28 2019 +0200", "commit_message": "RSS: Fix __repr__ formatter.", "files_name": ["plugins/RSS/plugin.py"]}, {"commit_id": "dcf55cf6deb90f2498e53068175562aa36d315cc", "commit_date": "Sat Oct 5 15:57:01 2019 +0200", "commit_message": "RSS: Use an explicit timeout for assertNoResponse, because it defaults to 0.", "files_name": ["plugins/RSS/test.py"]}, {"commit_id": "a4665803fa9345a3c7a303ead66eed648e5ded63", "commit_date": "Sat Oct 5 12:12:46 2019 +0200", "commit_message": "News + RSS: Mock time.time() instead of using time.sleep() in tests.", "files_name": ["plugins/News/test.py", "plugins/RSS/test.py", "src/test.py"]}, {"commit_id": "3c42ce0861965d9507e180e2bb9aad1f1bed5446", "commit_date": "Sat Sep 28 10:33:54 2019 +0200", "commit_message": "Only clear users db if the filename is set.", "files_name": ["src/ircdb.py"]}, {"commit_id": "bcbaa979d5e736cb9b443ee3c27cc2c26fa1630c", "commit_date": "Sat Sep 28 10:33:10 2019 +0200", "commit_message": "Revert \"Deduplicate (de)serialization code shared by UsersDictionary and ChannelsDictionary.\"", "files_name": ["src/ircdb.py", "src/unpreserve.py"]}, {"commit_id": "5bfee2e72b7bb89276c1f5754de820b78b6ab468", "commit_date": "Thu Sep 26 23:00:01 2019 +0200", "commit_message": "Fix typo in doc.", "files_name": ["src/unpreserve.py"]}, {"commit_id": "a4f8e3f64734f1cd3331cb380e00ba8fe8bdf65e", "commit_date": "Thu Sep 26 22:48:05 2019 +0200", "commit_message": "Deduplicate (de)serialization code shared by UsersDictionary and ChannelsDictionary.", "files_name": ["src/ircdb.py", "src/unpreserve.py"]}, {"commit_id": "7d218ec8ce8e2150ec7ae5c5f8a629ed349c9403", "commit_date": "Thu Sep 26 22:47:04 2019 +0200", "commit_message": "Document unpreserve.Reader (expected format + method hooks).", "files_name": ["src/unpreserve.py"]}, {"commit_id": "84c1f1572d2f41c8c41b9456e5c9eb690b4f5613", "commit_date": "Fri Sep 20 21:23:49 2019 +0200", "commit_message": "Don't temporarily set msg.channel to invalid values.", "files_name": ["src/irclib.py"]}, {"commit_id": "6c5072cfe0dae0069bb2f8d9ba8e994b00a64b5f", "commit_date": "Wed Sep 18 19:27:02 2019 +0100", "commit_message": "only raise in commands.process() when a raise was wrapped (#1370)", "files_name": ["src/commands.py"]}, {"commit_id": "219ac6d154891900fc1444c3677c0b4b41215807", "commit_date": "Sun Sep 15 08:03:12 2019 +0200", "commit_message": "Include plugins setup.py in  installed files / release tarballs.", "files_name": ["setup.py"]}, {"commit_id": "853935743a90d7ed5fda3ca4bd604a9e461a0194", "commit_date": "Sun Sep 15 08:03:00 2019 +0200", "commit_message": "Include README.md in  installed files / release tarballs.", "files_name": ["MANIFEST.in"]}, {"commit_id": "40837dbda0fc4dbc75cc85b523d7e691b48f2c60", "commit_date": "Sun Sep 15 08:02:10 2019 +0200", "commit_message": "Don't mutate server list while iterating on it.", "files_name": ["src/httpserver.py"]}, {"commit_id": "656222e341cf4012e5123a1f25244906136ab410", "commit_date": "Sat Sep 14 14:35:43 2019 +0200", "commit_message": "ChannelLogger: Fix filename escaping.", "files_name": ["plugins/ChannelLogger/plugin.py"]}, {"commit_id": "af6052997cbaa57fe304a8078b42467b516f5315", "commit_date": "Sat Sep 14 12:15:57 2019 +0200", "commit_message": "ChannelLogger: Fix test broken by previous merge.", "files_name": ["plugins/ChannelLogger/test.py"]}, {"commit_id": "573921c00f4213889abed97c591adc38b88b8fb7", "commit_date": "Sat Sep 14 12:10:47 2019 +0200", "commit_message": "Merge branch 'netconf-and-ircmsgs-channel' into testing", "files_name": ["67c2bacd693759be9580c5e95271974197918e51 - Sun Sep 8 21:35:35 2019 +0200 : Set msg.channel in ReplyIrcProxy and NestedCommandsIrcProxy.", "src/callbacks.py"]}, {"commit_id": "de9cea89cf69f80c675b81a342930979db963c65", "commit_date": "Sun Sep 8 19:05:13 2019 +0200", "commit_message": "ChannelLogger: Fix NameError on 'irc'.", "files_name": ["plugins/ChannelLogger/plugin.py"]}, {"commit_id": "f143e977d68f6441116fae0ad08bbccfc854ab9a", "commit_date": "Sun Sep 8 14:46:56 2019 +0200", "commit_message": "Interpret empty server tag values as missing tag values.", "files_name": ["src/ircmsgs.py", "test/test_ircmsgs.py"]}, {"commit_id": "88524beadaa55bd7b1638538bcf35f9548a913f6", "commit_date": "Fri Sep 6 20:15:18 2019 +0200", "commit_message": "ChannelLogger + Karka + all DB plugins: Sanitize channel names when used in filenames.", "files_name": ["plugins/ChannelLogger/plugin.py", "plugins/ChannelLogger/test.py", "plugins/__init__.py", "src/utils/file.py", "test/test_plugins.py", "test/test_utils.py"]}], "windows_after": [{"commit_id": "6a9462be008b797c8fb03f422606413c62ff21e8", "commit_date": "Sat Nov 9 18:27:07 2019 +0100", "commit_message": "Fix reset of capabilities_ls.", "files_name": ["src/irclib.py"]}, {"commit_id": "2dddfefa98b44b8d539455e73910cd689abb5218", "commit_date": "Sat Nov 9 18:38:40 2019 +0100", "commit_message": "Fix log on SASL failure.", "files_name": ["src/irclib.py"]}, {"commit_id": "78a50c81bd75413582bf3b5c30143b52bd8991d9", "commit_date": "Mon Nov 11 12:12:10 2019 +0100", "commit_message": "Math: Display a nicer error in case of MemoryError.", "files_name": ["plugins/Math/plugin.py", "plugins/Math/test.py"]}, {"commit_id": "1a69a7b8923f4469bf3982007fec3e163cf3e9bc", "commit_date": "Mon Nov 11 12:38:27 2019 +0100", "commit_message": "Math: Fix test on Pypy.", "files_name": ["plugins/Math/test.py"]}, {"commit_id": "ad6671966c495f56a687ca34cdba75058802bce7", "commit_date": "Mon Nov 11 15:06:06 2019 +0100", "commit_message": "Scheduler: Use mocking to make tests faster.", "files_name": [".travis.yml", "plugins/Scheduler/test.py"]}, {"commit_id": "5718eafc0713c35b068af5f10f8c1734119801a1", "commit_date": "Mon Nov 11 15:29:17 2019 +0100", "commit_message": "Scheduler: Use default timeout for assertResponse.", "files_name": ["plugins/Scheduler/test.py"]}, {"commit_id": "b2f6c3c83fe2c460dd17978d9d1b378e17baf448", "commit_date": "Mon Nov 11 18:06:07 2019 +0100", "commit_message": "test: Don't overwrite the main Schedule in the driver list.", "files_name": ["test/test_schedule.py"]}, {"commit_id": "8001de6960f517ed163a9c6023178384f9180bbe", "commit_date": "Mon Nov 11 18:06:45 2019 +0100", "commit_message": "Scheduler: Use assertRegexp instead of assertNotRegexp in tests.", "files_name": ["plugins/Scheduler/test.py"]}, {"commit_id": "f85287771d74f7821a2513e5aca9eabf941bd574", "commit_date": "Mon Nov 11 19:42:34 2019 +0100", "commit_message": "RSS: Register feed config in config.py instead of plugin.py.", "files_name": ["plugins/RSS/config.py", "plugins/RSS/plugin.py"]}, {"commit_id": "bc663b164c4f87342c1e0ff523e0acf65efe22ef", "commit_date": "Fri Nov 15 21:14:46 2019 +0100", "commit_message": "Nicer error message in getChannel/makeChannelFilename when channel is None.", "files_name": ["plugins/__init__.py"]}, {"commit_id": "bace9cb6c03c3a55238a1f86d22597a13851f79a", "commit_date": "Fri Nov 15 21:24:31 2019 +0100", "commit_message": "MoobotFactoids: Fix support of commands sent in private.", "files_name": ["plugins/MoobotFactoids/plugin.py", "plugins/MoobotFactoids/test.py"]}, {"commit_id": "7854db7135478a22061fe30da7c4414394bcab61", "commit_date": "Mon Nov 11 11:09:50 2019 -0800", "commit_message": "Better formatting in supybot.Author if some fields are missing", "files_name": ["src/__init__.py", "test/test_misc.py"]}, {"commit_id": "a4701b258c35240e2610b13994551ecfda00b66e", "commit_date": "Mon Nov 11 11:53:30 2019 -0800", "commit_message": "Plugin: accept author name in 'contributors' command", "files_name": ["plugins/Plugin/plugin.py", "plugins/Plugin/test.py", "src/__init__.py", "test/test_misc.py"]}, {"commit_id": "1858eaf59e1f12adbf9d59840b54fb1a2878ef92", "commit_date": "Mon Nov 11 11:55:29 2019 -0800", "commit_message": "Plugin: support showing __maintainer__ field in the 'author' command", "files_name": ["plugins/Plugin/plugin.py"]}, {"commit_id": "9291fbd4a0cf6c3fc6e63ab82306f30252bf9736", "commit_date": "Mon Nov 11 12:00:48 2019 -0800", "commit_message": "All plugins: set Limnoria contributors as maintainer", "files_name": ["plugins/Admin/__init__.py", "plugins/Aka/__init__.py", "plugins/Alias/__init__.py", "plugins/Anonymous/__init__.py", "plugins/AutoMode/__init__.py", "plugins/BadWords/__init__.py", "plugins/Channel/__init__.py", "plugins/ChannelLogger/__init__.py", "plugins/ChannelStats/__init__.py", "plugins/Conditional/__init__.py", "plugins/Config/__init__.py", "plugins/Ctcp/__init__.py", "plugins/Debug/__init__.py", "plugins/Dict/__init__.py", "plugins/Dunno/__init__.py", "plugins/Factoids/__init__.py", "plugins/Filter/__init__.py", "plugins/Format/__init__.py", "plugins/GPG/__init__.py", "plugins/Games/__init__.py", "plugins/Google/__init__.py", "plugins/Hashes/__init__.py", "plugins/Herald/__init__.py", "plugins/Internet/__init__.py", "plugins/Karma/__init__.py", "plugins/Lart/__init__.py", "plugins/Later/__init__.py", "plugins/Limiter/__init__.py", "plugins/Math/__init__.py", "plugins/MessageParser/__init__.py", "plugins/Misc/__init__.py", "plugins/MoobotFactoids/__init__.py", "plugins/Network/__init__.py", "plugins/News/__init__.py", "plugins/NickAuth/__init__.py", "plugins/NickCapture/__init__.py", "plugins/Nickometer/__init__.py", "plugins/Note/__init__.py", "plugins/Owner/__init__.py", "plugins/Plugin/__init__.py", "plugins/Plugin/test.py", "plugins/PluginDownloader/__init__.py", "plugins/Praise/__init__.py", "plugins/Protector/__init__.py", "plugins/Quote/__init__.py", "plugins/QuoteGrabs/__init__.py", "plugins/RSS/__init__.py", "plugins/Relay/__init__.py", "plugins/Reply/__init__.py", "plugins/Scheduler/__init__.py", "plugins/Seen/__init__.py", "plugins/Services/__init__.py", "plugins/ShrinkUrl/__init__.py", "plugins/Status/__init__.py", "plugins/String/__init__.py", "plugins/Success/__init__.py", "plugins/Time/__init__.py", "plugins/Todo/__init__.py", "plugins/Topic/__init__.py", "plugins/URL/__init__.py", "plugins/Unix/__init__.py", "plugins/User/__init__.py", "plugins/Utilities/__init__.py", "plugins/Web/__init__.py", "src/__init__.py"]}, {"commit_id": "1a1707420b58f2cc2223c9fe94f7f6837e08fd8f", "commit_date": "Fri Nov 22 18:17:44 2019 +0100", "commit_message": "Web: Add early returns on exception when snarfing titles.", "files_name": ["plugins/Web/plugin.py"]}, {"commit_id": "a8b6698849995c5d15ec499b95ba85c2a2e71a94", "commit_date": "Sat Nov 23 18:48:58 2019 +0100", "commit_message": "Add config supybot.reply.format.list.maximumItems to limit the size of format('%L', ...).", "files_name": ["src/conf.py", "test/test_utils.py"]}, {"commit_id": "423a38770b49f3a85ccc87ed19f261a0bd9e4487", "commit_date": "Sun Nov 24 12:04:21 2019 +0100", "commit_message": "Get locale name on startup from registry cache instead of parsing config file.", "files_name": ["scripts/supybot", "src/i18n.py"]}, {"commit_id": "0828b207be9f7a57ca4797eb4627b1546074a274", "commit_date": "Sun Nov 24 12:46:10 2019 +0100", "commit_message": "Add fallback if getting supybot.language from registry cache failed.", "files_name": ["src/i18n.py"]}, {"commit_id": "63b0d7e653507e5a277da910d9b00a8279dfd18c", "commit_date": "Sun Nov 24 12:47:03 2019 +0100", "commit_message": "Update core fr translation.", "files_name": ["locales/fr.po", "locales/messages.pot", "src/ircutils.py", "src/registry.py"]}, {"commit_id": "a1ee580d0891782b09653ba717ea7b591d3fa595", "commit_date": "Sun Nov 24 12:59:38 2019 +0100", "commit_message": "Make getLocaleFromRegistryCache reload existing locales.", "files_name": ["src/i18n.py"]}, {"commit_id": "981a3b245a45d71a9d58803835b15246e8272d5c", "commit_date": "Wed Nov 27 16:59:11 2019 +0100", "commit_message": "QuoteGrabs: fix SyntaxWarning (#1391)", "files_name": ["plugins/QuoteGrabs/plugin.py"]}, {"commit_id": "1ed47f802fb04194d656eb207c500394f0758beb", "commit_date": "Thu Dec 5 21:10:31 2019 +0100", "commit_message": "Request msgid capability.", "files_name": ["src/irclib.py"]}, {"commit_id": "83114e5fbd4568ad4efab2065f5c823a59603929", "commit_date": "Thu Dec 5 21:11:01 2019 +0100", "commit_message": "src/callbacks.py: use network-specific values.", "files_name": ["plugins/Conditional/plugin.py", "plugins/MessageParser/plugin.py", "plugins/Scheduler/plugin.py", "plugins/Utilities/plugin.py", "plugins/__init__.py", "src/callbacks.py", "src/conf.py"]}, {"commit_id": "a86df1fc354543a05bf2cd161002c24f1b09eb90", "commit_date": "Mon Dec 9 21:27:09 2019 +0100", "commit_message": "Remove dead code from Group that belongs in Value.", "files_name": ["src/registry.py"]}, {"commit_id": "130ceede577595aaa07f4c9bdd74a039d525df5b", "commit_date": "Mon Dec 9 21:34:21 2019 +0100", "commit_message": "Update supybot-plugin-doc to work with current version of the registry.", "files_name": ["scripts/supybot-plugin-doc"]}, {"commit_id": "143cd9d506f9473fbdf38a342edab1deb1c8dac5", "commit_date": "Fri Dec 13 20:01:48 2019 +0100", "commit_message": "Services: Fix typo in doInvite() (#1394)", "files_name": ["plugins/Services/plugin.py"]}, {"commit_id": "dc2068deca353d1cec29b1e4e5857b7d5dcc1595", "commit_date": "Sun Dec 15 17:26:47 2019 +0100", "commit_message": "Web: Remove leading space if the prefix is empty.", "files_name": ["plugins/Web/plugin.py"]}, {"commit_id": "8491d0b944538572e6e9148459497bc15ecf6a3e", "commit_date": "Sun Dec 15 18:43:51 2019 +0100", "commit_message": "Web: Lower log level when title could not be found.", "files_name": ["plugins/Web/plugin.py"]}, {"commit_id": "a6392c8582ba2a98c9ad637637b5e2679a8f5f35", "commit_date": "Sun Dec 15 11:18:09 2019 -0800", "commit_message": "test: choose a random free port for tests using the HTTP server", "files_name": ["src/test.py"]}, {"commit_id": "fcb342cb2cbbaea02404e0fdd39154c1e5991c04", "commit_date": "Sun Dec 15 20:19:17 2019 +0100", "commit_message": "test: Mock calls to time.sleep()", "files_name": ["test/test_ircdb.py", "test/test_schedule.py", "test/test_utils.py"]}, {"commit_id": "12b6c9d60ea03940dea40a8328702ca37acef4e6", "commit_date": "Tue Dec 24 02:43:31 2019 +0100", "commit_message": "Config: Sort output of @list.", "files_name": ["plugins/Config/plugin.py"]}, {"commit_id": "25d9f468fef4977d996db9136393b868c5656c3e", "commit_date": "Mon Dec 30 16:35:10 2019 +1100", "commit_message": "Update TL;DR install instructions with python3-wheel dependency (#1397)", "files_name": ["README.md"]}, {"commit_id": "864b1759e3a5b368045cb9ea016a5db6e64475b5", "commit_date": "Wed Jan 1 12:02:19 2020 +0100", "commit_message": "Drop support for Python versions before 3.4.", "files_name": [".travis.yml", "README.md", "setup.py"]}, {"commit_id": "ac07b440dcfaa24cb4bff0ba15486f00b02c47b3", "commit_date": "Thu Dec 26 12:14:05 2019 +0100", "commit_message": "Rewrite ecdsa-nist256p-challenge using python-cryptography instead of python-ecdsa.", "files_name": ["requirements.txt", "src/irclib.py"]}, {"commit_id": "5348869e4fe7366a02f12436fe76e7ada43624fb", "commit_date": "Thu Dec 26 16:16:58 2019 +0100", "commit_message": "Skip irctest when optional dependencies are not installed.", "files_name": [".travis.yml"]}], "parents": [{"commit_id_before": "5e2343f717d9f78bd57930ccd73491d79a0b39d7", "url_before": "https://api.github.com/repos/progval/Limnoria/commits/5e2343f717d9f78bd57930ccd73491d79a0b39d7", "html_url_before": "https://github.com/progval/Limnoria/commit/5e2343f717d9f78bd57930ccd73491d79a0b39d7"}], "details": [{"raw_url": "https://github.com/progval/Limnoria/raw/3848ae78de45b35c029cc333963d436b9d2f0a35/plugins%2FMath%2Fevaluator.py", "code": "###\n# Copyright (c) 2019, Valentin Lorentz\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions, and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions, and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#   * Neither the name of the author of this software nor the name of\n#     contributors to this software may be used to endorse or promote products\n#     derived from this software without specific prior written consent.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n###\n\nimport ast\nimport math\nimport cmath\nimport operator\n\nclass InvalidNode(Exception):\n    pass\n\ndef filter_module(module, safe_names):\n    return dict([\n        (name, getattr(module, name))\n        for name in safe_names\n        if hasattr(module, name)\n    ])\n\nUNARY_OPS = {\n    ast.UAdd: lambda x: x,\n    ast.USub: lambda x: -x,\n}\n\nBIN_OPS = {\n    ast.Add: operator.add,\n    ast.Sub: operator.sub,\n    ast.Mult: operator.mul,\n    ast.Div: operator.truediv,\n    ast.Pow: operator.pow,\n    ast.BitXor: operator.xor,\n    ast.BitOr: operator.or_,\n    ast.BitAnd: operator.and_,\n}\n\nMATH_CONSTANTS = 'e inf nan pi tau'.split()\nSAFE_MATH_FUNCTIONS = (\n    'acos acosh asin asinh atan atan2 atanh copysign cos cosh degrees erf '\n    'erfc exp expm1 fabs fmod frexp fsum gamma hypot ldexp lgamma log log10 '\n    'log1p log2 modf pow radians remainder sin sinh tan tanh'\n).split()\nSAFE_CMATH_FUNCTIONS = (\n    'acos acosh asin asinh atan atanh cos cosh exp inf infj log log10 '\n    'nanj phase polar rect sin sinh tan tanh tau'\n).split()\n\nSAFE_ENV = filter_module(math, MATH_CONSTANTS + SAFE_MATH_FUNCTIONS)\nSAFE_ENV.update(filter_module(cmath, SAFE_CMATH_FUNCTIONS))\n\ndef _sqrt(x):\n    if isinstance(x, complex) or x < 0:\n        return cmath.sqrt(x)\n    else:\n        return math.sqrt(x)\n\ndef _cbrt(x):\n    return math.pow(x, 1.0/3)\n\ndef _factorial(x):\n    if x<=10000:\n        return float(math.factorial(x))\n    else:\n        raise Exception('factorial argument too large')\n\nSAFE_ENV.update({\n    'i': 1j,\n    'abs': abs,\n    'max': max,\n    'min': min,\n    'round': lambda x, y=0: round(x, int(y)),\n    'factorial': _factorial,\n    'sqrt': _sqrt,\n    'cbrt': _cbrt,\n    'ceil': lambda x: float(math.ceil(x)),\n    'floor': lambda x: float(math.floor(x)),\n})\n\nUNSAFE_ENV = SAFE_ENV.copy()\n# Add functions that return integers\nUNSAFE_ENV.update(filter_module(math, 'ceil floor factorial gcd'.split()))\n\n\n# It would be nice if ast.literal_eval used a visitor so we could subclass\n# to extend it, but it doesn't, so let's reimplement it entirely.\nclass SafeEvalVisitor(ast.NodeVisitor):\n    def __init__(self, allow_ints):\n        self._allow_ints = allow_ints\n        self._env = UNSAFE_ENV if allow_ints else SAFE_ENV\n\n    def _convert_num(self, x):\n        \"\"\"Converts numbers to complex if ints are not allowed.\"\"\"\n        if self._allow_ints:\n            return x\n        else:\n            x = complex(x)\n            if x.imag == 0:\n                x = x.real\n                # Need to use string-formatting here instead of str() because\n                # use of str() on large numbers loses information:\n                # str(float(33333333333333)) => '3.33333333333e+13'\n                # float('3.33333333333e+13') => 33333333333300.0\n                return float('%.16f' % x)\n            else:\n                return x\n\n    def visit_Expression(self, node):\n        return self.visit(node.body)\n\n    def visit_Num(self, node):\n        return self._convert_num(node.n)\n\n    def visit_Name(self, node):\n        id_ = node.id.lower()\n        if id_ in self._env:\n            return self._env[id_]\n        else:\n            raise NameError(node.id)\n\n    def visit_Call(self, node):\n        func = self.visit(node.func)\n        args = map(self.visit, node.args)\n        # TODO: keywords?\n        return func(*args)\n\n    def visit_UnaryOp(self, node):\n        op = UNARY_OPS.get(node.op.__class__)\n        if op:\n            return op(self.visit(node.operand))\n        else:\n            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n\n    def visit_BinOp(self, node):\n        op = BIN_OPS.get(node.op.__class__)\n        if op:\n            return op(self.visit(node.left), self.visit(node.right))\n        else:\n            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n\n    def generic_visit(self, node):\n        raise InvalidNode('illegal construct %s' % node.__class__.__name__)\n\ndef safe_eval(text, allow_ints):\n    node = ast.parse(text, mode='eval')\n    return SafeEvalVisitor(allow_ints).visit(node)\n", "code_before": "", "patch": "@@ -0,0 +1,169 @@\n+###\n+# Copyright (c) 2019, Valentin Lorentz\n+# All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are met:\n+#\n+#   * Redistributions of source code must retain the above copyright notice,\n+#     this list of conditions, and the following disclaimer.\n+#   * Redistributions in binary form must reproduce the above copyright notice,\n+#     this list of conditions, and the following disclaimer in the\n+#     documentation and/or other materials provided with the distribution.\n+#   * Neither the name of the author of this software nor the name of\n+#     contributors to this software may be used to endorse or promote products\n+#     derived from this software without specific prior written consent.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+###\n+\n+import ast\n+import math\n+import cmath\n+import operator\n+\n+class InvalidNode(Exception):\n+    pass\n+\n+def filter_module(module, safe_names):\n+    return dict([\n+        (name, getattr(module, name))\n+        for name in safe_names\n+        if hasattr(module, name)\n+    ])\n+\n+UNARY_OPS = {\n+    ast.UAdd: lambda x: x,\n+    ast.USub: lambda x: -x,\n+}\n+\n+BIN_OPS = {\n+    ast.Add: operator.add,\n+    ast.Sub: operator.sub,\n+    ast.Mult: operator.mul,\n+    ast.Div: operator.truediv,\n+    ast.Pow: operator.pow,\n+    ast.BitXor: operator.xor,\n+    ast.BitOr: operator.or_,\n+    ast.BitAnd: operator.and_,\n+}\n+\n+MATH_CONSTANTS = 'e inf nan pi tau'.split()\n+SAFE_MATH_FUNCTIONS = (\n+    'acos acosh asin asinh atan atan2 atanh copysign cos cosh degrees erf '\n+    'erfc exp expm1 fabs fmod frexp fsum gamma hypot ldexp lgamma log log10 '\n+    'log1p log2 modf pow radians remainder sin sinh tan tanh'\n+).split()\n+SAFE_CMATH_FUNCTIONS = (\n+    'acos acosh asin asinh atan atanh cos cosh exp inf infj log log10 '\n+    'nanj phase polar rect sin sinh tan tanh tau'\n+).split()\n+\n+SAFE_ENV = filter_module(math, MATH_CONSTANTS + SAFE_MATH_FUNCTIONS)\n+SAFE_ENV.update(filter_module(cmath, SAFE_CMATH_FUNCTIONS))\n+\n+def _sqrt(x):\n+    if isinstance(x, complex) or x < 0:\n+        return cmath.sqrt(x)\n+    else:\n+        return math.sqrt(x)\n+\n+def _cbrt(x):\n+    return math.pow(x, 1.0/3)\n+\n+def _factorial(x):\n+    if x<=10000:\n+        return float(math.factorial(x))\n+    else:\n+        raise Exception('factorial argument too large')\n+\n+SAFE_ENV.update({\n+    'i': 1j,\n+    'abs': abs,\n+    'max': max,\n+    'min': min,\n+    'round': lambda x, y=0: round(x, int(y)),\n+    'factorial': _factorial,\n+    'sqrt': _sqrt,\n+    'cbrt': _cbrt,\n+    'ceil': lambda x: float(math.ceil(x)),\n+    'floor': lambda x: float(math.floor(x)),\n+})\n+\n+UNSAFE_ENV = SAFE_ENV.copy()\n+# Add functions that return integers\n+UNSAFE_ENV.update(filter_module(math, 'ceil floor factorial gcd'.split()))\n+\n+\n+# It would be nice if ast.literal_eval used a visitor so we could subclass\n+# to extend it, but it doesn't, so let's reimplement it entirely.\n+class SafeEvalVisitor(ast.NodeVisitor):\n+    def __init__(self, allow_ints):\n+        self._allow_ints = allow_ints\n+        self._env = UNSAFE_ENV if allow_ints else SAFE_ENV\n+\n+    def _convert_num(self, x):\n+        \"\"\"Converts numbers to complex if ints are not allowed.\"\"\"\n+        if self._allow_ints:\n+            return x\n+        else:\n+            x = complex(x)\n+            if x.imag == 0:\n+                x = x.real\n+                # Need to use string-formatting here instead of str() because\n+                # use of str() on large numbers loses information:\n+                # str(float(33333333333333)) => '3.33333333333e+13'\n+                # float('3.33333333333e+13') => 33333333333300.0\n+                return float('%.16f' % x)\n+            else:\n+                return x\n+\n+    def visit_Expression(self, node):\n+        return self.visit(node.body)\n+\n+    def visit_Num(self, node):\n+        return self._convert_num(node.n)\n+\n+    def visit_Name(self, node):\n+        id_ = node.id.lower()\n+        if id_ in self._env:\n+            return self._env[id_]\n+        else:\n+            raise NameError(node.id)\n+\n+    def visit_Call(self, node):\n+        func = self.visit(node.func)\n+        args = map(self.visit, node.args)\n+        # TODO: keywords?\n+        return func(*args)\n+\n+    def visit_UnaryOp(self, node):\n+        op = UNARY_OPS.get(node.op.__class__)\n+        if op:\n+            return op(self.visit(node.operand))\n+        else:\n+            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n+\n+    def visit_BinOp(self, node):\n+        op = BIN_OPS.get(node.op.__class__)\n+        if op:\n+            return op(self.visit(node.left), self.visit(node.right))\n+        else:\n+            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n+\n+    def generic_visit(self, node):\n+        raise InvalidNode('illegal construct %s' % node.__class__.__name__)\n+\n+def safe_eval(text, allow_ints):\n+    node = ast.parse(text, mode='eval')\n+    return SafeEvalVisitor(allow_ints).visit(node)", "file_path": "files/2019_11\\330", "file_language": "py", "file_name": "plugins/Math/evaluator.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [], "function_after": [{"function": "class InvalidNode(Exception):\n    pass", "target": 0}, {"function": "def filter_module(module, safe_names):\n    return dict([\n        (name, getattr(module, name))\n        for name in safe_names\n        if hasattr(module, name)\n    ])", "target": 0}, {"function": "def _sqrt(x):\n    if isinstance(x, complex) or x < 0:\n        return cmath.sqrt(x)\n    else:\n        return math.sqrt(x)", "target": 0}, {"function": "def _cbrt(x):\n    return math.pow(x, 1.0/3)", "target": 0}, {"function": "def _factorial(x):\n    if x<=10000:\n        return float(math.factorial(x))\n    else:\n        raise Exception('factorial argument too large')", "target": 0}, {"function": "class SafeEvalVisitor(ast.NodeVisitor):\n    def __init__(self, allow_ints):\n        self._allow_ints = allow_ints\n        self._env = UNSAFE_ENV if allow_ints else SAFE_ENV\n\n    def _convert_num(self, x):\n        \"\"\"Converts numbers to complex if ints are not allowed.\"\"\"\n        if self._allow_ints:\n            return x\n        else:\n            x = complex(x)\n            if x.imag == 0:\n                x = x.real\n                # Need to use string-formatting here instead of str() because\n                # use of str() on large numbers loses information:\n                # str(float(33333333333333)) => '3.33333333333e+13'\n                # float('3.33333333333e+13') => 33333333333300.0\n                return float('%.16f' % x)\n            else:\n                return x\n\n    def visit_Expression(self, node):\n        return self.visit(node.body)\n\n    def visit_Num(self, node):\n        return self._convert_num(node.n)\n\n    def visit_Name(self, node):\n        id_ = node.id.lower()\n        if id_ in self._env:\n            return self._env[id_]\n        else:\n            raise NameError(node.id)\n\n    def visit_Call(self, node):\n        func = self.visit(node.func)\n        args = map(self.visit, node.args)\n        # TODO: keywords?\n        return func(*args)\n\n    def visit_UnaryOp(self, node):\n        op = UNARY_OPS.get(node.op.__class__)\n        if op:\n            return op(self.visit(node.operand))\n        else:\n            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n\n    def visit_BinOp(self, node):\n        op = BIN_OPS.get(node.op.__class__)\n        if op:\n            return op(self.visit(node.left), self.visit(node.right))\n        else:\n            raise InvalidNode('illegal operator %s' % node.op.__class__.__name__)\n\n    def generic_visit(self, node):\n        raise InvalidNode('illegal construct %s' % node.__class__.__name__)", "target": 0}, {"function": "def safe_eval(text, allow_ints):\n    node = ast.parse(text, mode='eval')\n    return SafeEvalVisitor(allow_ints).visit(node)", "target": 0}]}, {"raw_url": "https://github.com/progval/Limnoria/raw/3848ae78de45b35c029cc333963d436b9d2f0a35/plugins%2FMath%2Fplugin.py", "code": "###\n# Copyright (c) 2002-2004, Jeremiah Fincher\n# Copyright (c) 2008-2009, James McCoy\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions, and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions, and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#   * Neither the name of the author of this software nor the name of\n#     contributors to this software may be used to endorse or promote products\n#     derived from this software without specific prior written consent.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n###\n\nfrom __future__ import division\n\nimport re\nimport math\nimport cmath\nimport types\nimport string\n\nimport supybot.utils as utils\nfrom supybot.commands import *\nimport supybot.utils.minisix as minisix\nimport supybot.callbacks as callbacks\nfrom supybot.i18n import PluginInternationalization, internationalizeDocstring\n_ = PluginInternationalization('Math')\n\nfrom .local import convertcore\nfrom .evaluator import safe_eval, InvalidNode, SAFE_ENV\n\nbaseArg = ('int', 'base', lambda i: i <= 36)\n\nclass Math(callbacks.Plugin):\n    \"\"\"Provides commands to work with math, such as a calculator and\n    a unit converter.\"\"\"\n    @internationalizeDocstring\n    def base(self, irc, msg, args, frm, to, number):\n        \"\"\"<fromBase> [<toBase>] <number>\n\n        Converts <number> from base <fromBase> to base <toBase>.\n        If <toBase> is left out, it converts to decimal.\n        \"\"\"\n        if not number:\n            number = str(to)\n            to = 10\n        try:\n            irc.reply(self._convertBaseToBase(number, to, frm))\n        except ValueError:\n            irc.error(_('Invalid <number> for base %s: %s') % (frm, number))\n    base = wrap(base, [('int', 'base', lambda i: 2 <= i <= 36),\n                       optional(('int', 'base', lambda i: 2 <= i <= 36), 10),\n                       additional('something')])\n\n    def _convertDecimalToBase(self, number, base):\n        \"\"\"Convert a decimal number to another base; returns a string.\"\"\"\n        if number == 0:\n            return '0'\n        elif number < 0:\n            negative = True\n            number = -number\n        else:\n            negative = False\n        digits = []\n        while number != 0:\n            digit = number % base\n            if digit >= 10:\n                digit = string.ascii_uppercase[digit - 10]\n            else:\n                digit = str(digit)\n            digits.append(digit)\n            number = number // base\n        digits.reverse()\n        return '-'*negative + ''.join(digits)\n\n    def _convertBaseToBase(self, number, toBase, fromBase):\n        \"\"\"Convert a number from any base, 2 through 36, to any other\n        base, 2 through 36. Returns a string.\"\"\"\n        number = minisix.long(str(number), fromBase)\n        if toBase == 10:\n            return str(number)\n        return self._convertDecimalToBase(number, toBase)\n\n    def _floatToString(self, x):\n        if -1e-10 < x < 1e-10:\n            return '0'\n        elif -1e-10 < int(x) - x < 1e-10:\n            return str(int(x))\n        else:\n            return str(x)\n\n    def _complexToString(self, x):\n        realS = self._floatToString(x.real)\n        imagS = self._floatToString(x.imag)\n        if imagS == '0':\n            return realS\n        elif imagS == '1':\n            imagS = '+i'\n        elif imagS == '-1':\n            imagS = '-i'\n        elif x.imag < 0:\n            imagS = '%si' % imagS\n        else:\n            imagS = '+%si' % imagS\n        if realS == '0' and imagS == '0':\n            return '0'\n        elif realS == '0':\n            return imagS.lstrip('+')\n        elif imagS == '0':\n            return realS\n        else:\n            return '%s%s' % (realS, imagS)\n\n    @internationalizeDocstring\n    def calc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        Returns the value of the evaluated <math expression>.  The syntax is\n        Python syntax; the type of arithmetic is floating point.  Floating\n        point arithmetic is used in order to prevent a user from being able to\n        crash to the bot with something like '10**10**10**10'.  One consequence\n        is that large values such as '10**24' might not be exact.\n        \"\"\"\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = complex(safe_eval(text, allow_ints=False))\n            irc.reply(self._complexToString(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except InvalidNode as e:\n            irc.error(_('Invalid syntax: %s') % e.args[0])\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % e.args[0])\n        except Exception as e:\n            irc.error(str(e))\n    calc = wrap(calc, ['text'])\n\n    @internationalizeDocstring\n    def icalc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        This is the same as the calc command except that it allows integer\n        math, and can thus cause the bot to suck up CPU.  Hence it requires\n        the 'trusted' capability to use.\n        \"\"\"\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = safe_eval(text, allow_ints=True)\n            irc.reply(str(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except InvalidNode as e:\n            irc.error(_('Invalid syntax: %s') % e.args[0])\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(utils.exnToString(e))\n    icalc = wrap(icalc, [('checkCapability', 'trusted'), 'text'])\n\n    _rpnEnv = {\n        'dup': lambda s: s.extend([s.pop()]*2),\n        'swap': lambda s: s.extend([s.pop(), s.pop()])\n        }\n    def rpn(self, irc, msg, args):\n        \"\"\"<rpn math expression>\n\n        Returns the value of an RPN expression.\n        \"\"\"\n        stack = []\n        for arg in args:\n            try:\n                x = complex(arg)\n                if x == abs(x):\n                    x = abs(x)\n                stack.append(x)\n            except ValueError: # Not a float.\n                if arg in SAFE_ENV:\n                    f = SAFE_ENV[arg]\n                    if callable(f):\n                        called = False\n                        arguments = []\n                        while not called and stack:\n                            arguments.append(stack.pop())\n                            try:\n                                stack.append(f(*arguments))\n                                called = True\n                            except TypeError:\n                                pass\n                        if not called:\n                            irc.error(_('Not enough arguments for %s') % arg)\n                            return\n                    else:\n                        stack.append(f)\n                elif arg in self._rpnEnv:\n                    self._rpnEnv[arg](stack)\n                else:\n                    arg2 = stack.pop()\n                    arg1 = stack.pop()\n                    s = '%s%s%s' % (arg1, arg, arg2)\n                    try:\n                        stack.append(safe_eval(s, allow_ints=False))\n                    except SyntaxError:\n                        irc.error(format(_('%q is not a defined function.'),\n                                         arg))\n                        return\n        if len(stack) == 1:\n            irc.reply(str(self._complexToString(complex(stack[0]))))\n        else:\n            s = ', '.join(map(self._complexToString, list(map(complex, stack))))\n            irc.reply(_('Stack: [%s]') % s)\n\n    @internationalizeDocstring\n    def convert(self, irc, msg, args, number, unit1, unit2):\n        \"\"\"[<number>] <unit> to <other unit>\n\n        Converts from <unit> to <other unit>. If number isn't given, it\n        defaults to 1. For unit information, see 'units' command.\n        \"\"\"\n        try:\n            digits = len(str(number).split('.')[1])\n        except IndexError:\n            digits = 0\n        try:\n            newNum = convertcore.convert(number, unit1, unit2)\n            if isinstance(newNum, float):\n                zeros = 0\n                for char in str(newNum).split('.')[1]:\n                    if char != '0':\n                        break\n                    zeros += 1\n                # Let's add one signifiant digit. Physicists would not like\n                # that, but common people usually do not give extra zeros...\n                # (for example, with '32 C to F', an extra digit would be\n                # expected).\n                newNum = round(newNum, digits + 1 + zeros)\n            newNum = self._floatToString(newNum)\n            irc.reply(str(newNum))\n        except convertcore.UnitDataError as ude:\n            irc.error(str(ude))\n    convert = wrap(convert, [optional('float', 1.0),'something','to','text'])\n\n    @internationalizeDocstring\n    def units(self, irc, msg, args, type):\n        \"\"\" [<type>]\n\n        With no arguments, returns a list of measurement types, which can be\n        passed as arguments. When called with a type as an argument, returns\n        the units of that type.\n        \"\"\"\n\n        irc.reply(convertcore.units(type))\n    units = wrap(units, [additional('text')])\n\nClass = Math\n\n# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:\n", "code_before": "###\n# Copyright (c) 2002-2004, Jeremiah Fincher\n# Copyright (c) 2008-2009, James McCoy\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions, and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions, and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#   * Neither the name of the author of this software nor the name of\n#     contributors to this software may be used to endorse or promote products\n#     derived from this software without specific prior written consent.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n###\n\nfrom __future__ import division\n\nimport re\nimport math\nimport cmath\nimport types\nimport string\n\nimport supybot.utils as utils\nfrom supybot.commands import *\nimport supybot.utils.minisix as minisix\nimport supybot.callbacks as callbacks\nfrom supybot.i18n import PluginInternationalization, internationalizeDocstring\n_ = PluginInternationalization('Math')\n\nfrom .local import convertcore\n\nbaseArg = ('int', 'base', lambda i: i <= 36)\n\nclass Math(callbacks.Plugin):\n    \"\"\"Provides commands to work with math, such as a calculator and\n    a unit converter.\"\"\"\n    @internationalizeDocstring\n    def base(self, irc, msg, args, frm, to, number):\n        \"\"\"<fromBase> [<toBase>] <number>\n\n        Converts <number> from base <fromBase> to base <toBase>.\n        If <toBase> is left out, it converts to decimal.\n        \"\"\"\n        if not number:\n            number = str(to)\n            to = 10\n        try:\n            irc.reply(self._convertBaseToBase(number, to, frm))\n        except ValueError:\n            irc.error(_('Invalid <number> for base %s: %s') % (frm, number))\n    base = wrap(base, [('int', 'base', lambda i: 2 <= i <= 36),\n                       optional(('int', 'base', lambda i: 2 <= i <= 36), 10),\n                       additional('something')])\n\n    def _convertDecimalToBase(self, number, base):\n        \"\"\"Convert a decimal number to another base; returns a string.\"\"\"\n        if number == 0:\n            return '0'\n        elif number < 0:\n            negative = True\n            number = -number\n        else:\n            negative = False\n        digits = []\n        while number != 0:\n            digit = number % base\n            if digit >= 10:\n                digit = string.ascii_uppercase[digit - 10]\n            else:\n                digit = str(digit)\n            digits.append(digit)\n            number = number // base\n        digits.reverse()\n        return '-'*negative + ''.join(digits)\n\n    def _convertBaseToBase(self, number, toBase, fromBase):\n        \"\"\"Convert a number from any base, 2 through 36, to any other\n        base, 2 through 36. Returns a string.\"\"\"\n        number = minisix.long(str(number), fromBase)\n        if toBase == 10:\n            return str(number)\n        return self._convertDecimalToBase(number, toBase)\n\n    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}\n    _mathEnv.update(math.__dict__)\n    _mathEnv.update(cmath.__dict__)\n    def _sqrt(x):\n        if isinstance(x, complex) or x < 0:\n            return cmath.sqrt(x)\n        else:\n            return math.sqrt(x)\n    def _cbrt(x):\n        return math.pow(x, 1.0/3)\n    def _factorial(x):\n        if x<=10000:\n            return float(math.factorial(x))\n        else:\n            raise Exception('factorial argument too large')\n    _mathEnv['sqrt'] = _sqrt\n    _mathEnv['cbrt'] = _cbrt\n    _mathEnv['abs'] = abs\n    _mathEnv['max'] = max\n    _mathEnv['min'] = min\n    _mathEnv['round'] = lambda x, y=0: round(x, int(y))\n    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])\n    _mathSafeEnv['factorial'] = _factorial\n    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\n                         r'(?:0x[A-Fa-f\\d]+|'\n                         r'0[0-7]+|'\n                         r'\\d+\\.\\d+|'\n                         r'\\.\\d+|'\n                         r'\\d+\\.|'\n                         r'\\d+))')\n    def _floatToString(self, x):\n        if -1e-10 < x < 1e-10:\n            return '0'\n        elif -1e-10 < int(x) - x < 1e-10:\n            return str(int(x))\n        else:\n            return str(x)\n\n    def _complexToString(self, x):\n        realS = self._floatToString(x.real)\n        imagS = self._floatToString(x.imag)\n        if imagS == '0':\n            return realS\n        elif imagS == '1':\n            imagS = '+i'\n        elif imagS == '-1':\n            imagS = '-i'\n        elif x.imag < 0:\n            imagS = '%si' % imagS\n        else:\n            imagS = '+%si' % imagS\n        if realS == '0' and imagS == '0':\n            return '0'\n        elif realS == '0':\n            return imagS.lstrip('+')\n        elif imagS == '0':\n            return realS\n        else:\n            return '%s%s' % (realS, imagS)\n\n    _calc_match_forbidden_chars = re.compile('[_\\[\\]]')\n    _calc_remover = utils.str.MultipleRemover('_[] \\t')\n    ###\n    # So this is how the 'calc' command works:\n    # First, we make a nice little safe environment for evaluation; basically,\n    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability\n    # of a random user to get ints evaluated: this means we have to turn all\n    # int literals (even octal numbers and hexadecimal numbers) into floats.\n    # Then we delete all square brackets, underscores, and whitespace, so no\n    # one can do list comprehensions or call __...__ functions.\n    ###\n    @internationalizeDocstring\n    def calc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        Returns the value of the evaluated <math expression>.  The syntax is\n        Python syntax; the type of arithmetic is floating point.  Floating\n        point arithmetic is used in order to prevent a user from being able to\n        crash to the bot with something like '10**10**10**10'.  One consequence\n        is that large values such as '10**24' might not be exact.\n        \"\"\"\n        try:\n            text = str(text)\n        except UnicodeEncodeError:\n            irc.error(_(\"There's no reason you should have fancy non-ASCII \"\n                            \"characters in your mathematical expression. \"\n                            \"Please remove them.\"))\n            return\n        if self._calc_match_forbidden_chars.match(text):\n            # Note: this is important to keep this to forbid usage of\n            # __builtins__\n            irc.error(_('There\\'s really no reason why you should have '\n                           'underscores or brackets in your mathematical '\n                           'expression.  Please remove them.'))\n            return\n        text = self._calc_remover(text)\n        if 'lambda' in text:\n            irc.error(_('You can\\'t use lambda in this command.'))\n            return\n        text = text.lower()\n        def handleMatch(m):\n            s = m.group(1)\n            if s.startswith('0x'):\n                i = int(s, 16)\n            elif s.startswith('0') and '.' not in s:\n                try:\n                    i = int(s, 8)\n                except ValueError:\n                    i = int(s)\n            else:\n                i = float(s)\n            x = complex(i)\n            if x.imag == 0:\n                x = x.real\n                # Need to use string-formatting here instead of str() because\n                # use of str() on large numbers loses information:\n                # str(float(33333333333333)) => '3.33333333333e+13'\n                # float('3.33333333333e+13') => 33333333333300.0\n                return '%.16f' % x\n            return str(x)\n        text = self._mathRe.sub(handleMatch, text)\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\n            irc.reply(self._complexToString(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except TypeError:\n            irc.error(_('Something in there wasn\\'t a valid number.'))\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(str(e))\n    calc = wrap(calc, ['text'])\n\n    @internationalizeDocstring\n    def icalc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        This is the same as the calc command except that it allows integer\n        math, and can thus cause the bot to suck up CPU.  Hence it requires\n        the 'trusted' capability to use.\n        \"\"\"\n        if self._calc_match_forbidden_chars.match(text):\n            # Note: this is important to keep this to forbid usage of\n            # __builtins__\n            irc.error(_('There\\'s really no reason why you should have '\n                           'underscores or brackets in your mathematical '\n                           'expression.  Please remove them.'))\n            return\n        # This removes spaces, too, but we'll leave the removal of _[] for\n        # safety's sake.\n        text = self._calc_remover(text)\n        if 'lambda' in text:\n            irc.error(_('You can\\'t use lambda in this command.'))\n            return\n        text = text.replace('lambda', '')\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except TypeError:\n            irc.error(_('Something in there wasn\\'t a valid number.'))\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(utils.exnToString(e))\n    icalc = wrap(icalc, [('checkCapability', 'trusted'), 'text'])\n\n    _rpnEnv = {\n        'dup': lambda s: s.extend([s.pop()]*2),\n        'swap': lambda s: s.extend([s.pop(), s.pop()])\n        }\n    def rpn(self, irc, msg, args):\n        \"\"\"<rpn math expression>\n\n        Returns the value of an RPN expression.\n        \"\"\"\n        stack = []\n        for arg in args:\n            try:\n                x = complex(arg)\n                if x == abs(x):\n                    x = abs(x)\n                stack.append(x)\n            except ValueError: # Not a float.\n                if arg in self._mathSafeEnv:\n                    f = self._mathSafeEnv[arg]\n                    if callable(f):\n                        called = False\n                        arguments = []\n                        while not called and stack:\n                            arguments.append(stack.pop())\n                            try:\n                                stack.append(f(*arguments))\n                                called = True\n                            except TypeError:\n                                pass\n                        if not called:\n                            irc.error(_('Not enough arguments for %s') % arg)\n                            return\n                    else:\n                        stack.append(f)\n                elif arg in self._rpnEnv:\n                    self._rpnEnv[arg](stack)\n                else:\n                    arg2 = stack.pop()\n                    arg1 = stack.pop()\n                    s = '%s%s%s' % (arg1, arg, arg2)\n                    try:\n                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\n                    except SyntaxError:\n                        irc.error(format(_('%q is not a defined function.'),\n                                         arg))\n                        return\n        if len(stack) == 1:\n            irc.reply(str(self._complexToString(complex(stack[0]))))\n        else:\n            s = ', '.join(map(self._complexToString, list(map(complex, stack))))\n            irc.reply(_('Stack: [%s]') % s)\n\n    @internationalizeDocstring\n    def convert(self, irc, msg, args, number, unit1, unit2):\n        \"\"\"[<number>] <unit> to <other unit>\n\n        Converts from <unit> to <other unit>. If number isn't given, it\n        defaults to 1. For unit information, see 'units' command.\n        \"\"\"\n        try:\n            digits = len(str(number).split('.')[1])\n        except IndexError:\n            digits = 0\n        try:\n            newNum = convertcore.convert(number, unit1, unit2)\n            if isinstance(newNum, float):\n                zeros = 0\n                for char in str(newNum).split('.')[1]:\n                    if char != '0':\n                        break\n                    zeros += 1\n                # Let's add one signifiant digit. Physicists would not like\n                # that, but common people usually do not give extra zeros...\n                # (for example, with '32 C to F', an extra digit would be\n                # expected).\n                newNum = round(newNum, digits + 1 + zeros)\n            newNum = self._floatToString(newNum)\n            irc.reply(str(newNum))\n        except convertcore.UnitDataError as ude:\n            irc.error(str(ude))\n    convert = wrap(convert, [optional('float', 1.0),'something','to','text'])\n\n    @internationalizeDocstring\n    def units(self, irc, msg, args, type):\n        \"\"\" [<type>]\n\n        With no arguments, returns a list of measurement types, which can be\n        passed as arguments. When called with a type as an argument, returns\n        the units of that type.\n        \"\"\"\n\n        irc.reply(convertcore.units(type))\n    units = wrap(units, [additional('text')])\n\nClass = Math\n\n# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:\n", "patch": "@@ -44,6 +44,7 @@\n _ = PluginInternationalization('Math')\n \n from .local import convertcore\n+from .evaluator import safe_eval, InvalidNode, SAFE_ENV\n \n baseArg = ('int', 'base', lambda i: i <= 36)\n \n@@ -97,36 +98,6 @@ def _convertBaseToBase(self, number, toBase, fromBase):\n             return str(number)\n         return self._convertDecimalToBase(number, toBase)\n \n-    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}\n-    _mathEnv.update(math.__dict__)\n-    _mathEnv.update(cmath.__dict__)\n-    def _sqrt(x):\n-        if isinstance(x, complex) or x < 0:\n-            return cmath.sqrt(x)\n-        else:\n-            return math.sqrt(x)\n-    def _cbrt(x):\n-        return math.pow(x, 1.0/3)\n-    def _factorial(x):\n-        if x<=10000:\n-            return float(math.factorial(x))\n-        else:\n-            raise Exception('factorial argument too large')\n-    _mathEnv['sqrt'] = _sqrt\n-    _mathEnv['cbrt'] = _cbrt\n-    _mathEnv['abs'] = abs\n-    _mathEnv['max'] = max\n-    _mathEnv['min'] = min\n-    _mathEnv['round'] = lambda x, y=0: round(x, int(y))\n-    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])\n-    _mathSafeEnv['factorial'] = _factorial\n-    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\n-                         r'(?:0x[A-Fa-f\\d]+|'\n-                         r'0[0-7]+|'\n-                         r'\\d+\\.\\d+|'\n-                         r'\\.\\d+|'\n-                         r'\\d+\\.|'\n-                         r'\\d+))')\n     def _floatToString(self, x):\n         if -1e-10 < x < 1e-10:\n             return '0'\n@@ -157,17 +128,6 @@ def _complexToString(self, x):\n         else:\n             return '%s%s' % (realS, imagS)\n \n-    _calc_match_forbidden_chars = re.compile('[_\\[\\]]')\n-    _calc_remover = utils.str.MultipleRemover('_[] \\t')\n-    ###\n-    # So this is how the 'calc' command works:\n-    # First, we make a nice little safe environment for evaluation; basically,\n-    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability\n-    # of a random user to get ints evaluated: this means we have to turn all\n-    # int literals (even octal numbers and hexadecimal numbers) into floats.\n-    # Then we delete all square brackets, underscores, and whitespace, so no\n-    # one can do list comprehensions or call __...__ functions.\n-    ###\n     @internationalizeDocstring\n     def calc(self, irc, msg, args, text):\n         \"\"\"<math expression>\n@@ -178,57 +138,17 @@ def calc(self, irc, msg, args, text):\n         crash to the bot with something like '10**10**10**10'.  One consequence\n         is that large values such as '10**24' might not be exact.\n         \"\"\"\n-        try:\n-            text = str(text)\n-        except UnicodeEncodeError:\n-            irc.error(_(\"There's no reason you should have fancy non-ASCII \"\n-                            \"characters in your mathematical expression. \"\n-                            \"Please remove them.\"))\n-            return\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.lower()\n-        def handleMatch(m):\n-            s = m.group(1)\n-            if s.startswith('0x'):\n-                i = int(s, 16)\n-            elif s.startswith('0') and '.' not in s:\n-                try:\n-                    i = int(s, 8)\n-                except ValueError:\n-                    i = int(s)\n-            else:\n-                i = float(s)\n-            x = complex(i)\n-            if x.imag == 0:\n-                x = x.real\n-                # Need to use string-formatting here instead of str() because\n-                # use of str() on large numbers loses information:\n-                # str(float(33333333333333)) => '3.33333333333e+13'\n-                # float('3.33333333333e+13') => 33333333333300.0\n-                return '%.16f' % x\n-            return str(x)\n-        text = self._mathRe.sub(handleMatch, text)\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\n+            x = complex(safe_eval(text, allow_ints=False))\n             irc.reply(self._complexToString(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n-            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n+            irc.error(_('%s is not a defined function.') % e.args[0])\n         except Exception as e:\n             irc.error(str(e))\n     calc = wrap(calc, ['text'])\n@@ -241,28 +161,15 @@ def icalc(self, irc, msg, args, text):\n         math, and can thus cause the bot to suck up CPU.  Hence it requires\n         the 'trusted' capability to use.\n         \"\"\"\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        # This removes spaces, too, but we'll leave the removal of _[] for\n-        # safety's sake.\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.replace('lambda', '')\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\n+            x = safe_eval(text, allow_ints=True)\n+            irc.reply(str(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n             irc.error(_('%s is not a defined function.') % str(e).split()[1])\n         except Exception as e:\n@@ -286,8 +193,8 @@ def rpn(self, irc, msg, args):\n                     x = abs(x)\n                 stack.append(x)\n             except ValueError: # Not a float.\n-                if arg in self._mathSafeEnv:\n-                    f = self._mathSafeEnv[arg]\n+                if arg in SAFE_ENV:\n+                    f = SAFE_ENV[arg]\n                     if callable(f):\n                         called = False\n                         arguments = []\n@@ -310,7 +217,7 @@ def rpn(self, irc, msg, args):\n                     arg1 = stack.pop()\n                     s = '%s%s%s' % (arg1, arg, arg2)\n                     try:\n-                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\n+                        stack.append(safe_eval(s, allow_ints=False))\n                     except SyntaxError:\n                         irc.error(format(_('%q is not a defined function.'),\n                                          arg))", "file_path": "files/2019_11\\331", "file_language": "py", "file_name": "plugins/Math/plugin.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [true, ["/data/rdhu/other/Static/tmp/2019_11_331.py:123: High: compile\n    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.\n", "/data/rdhu/other/Static/tmp/2019_11_331.py:223: High: eval\n            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.", "/data/rdhu/other/Static/tmp/2019_11_331.py:260: High: eval\n            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous.", "/data/rdhu/other/Static/tmp/2019_11_331.py:313: High: eval\n                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\nArgument 1 to this function call should be checked to ensure that it does not\ncome from an untrusted source without first verifying that it contains nothing\ndangerous."]], "semgrep": [true, ["       python.lang.security.audit.eval-detected.eval-detected                                        \n          Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If\n          this content can be input from outside the program, this may be a code injection           \n          vulnerability. Ensure evaluated content is not definable by external sources.              \n          Details: https://sg.run/ZvrD                                                               \n          313\u2506 stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))", "       python.lang.security.audit.eval-detected.eval-detected                                        \n          Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If\n          this content can be input from outside the program, this may be a code injection           \n          vulnerability. Ensure evaluated content is not definable by external sources.              \n          Details: https://sg.run/ZvrD                                                               \n\n          260\u2506 irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))", "       python.lang.security.audit.eval-detected.eval-detected                                        \n          Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If\n          this content can be input from outside the program, this may be a code injection           \n          vulnerability. Ensure evaluated content is not definable by external sources.              \n          Details: https://sg.run/ZvrD                                                               \n\n          223\u2506 x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))"]]}, "target": 1, "function_before": [{"function": "class Math(callbacks.Plugin):\n    \"\"\"Provides commands to work with math, such as a calculator and\n    a unit converter.\"\"\"\n    @internationalizeDocstring\n    def base(self, irc, msg, args, frm, to, number):\n        \"\"\"<fromBase> [<toBase>] <number>\n\n        Converts <number> from base <fromBase> to base <toBase>.\n        If <toBase> is left out, it converts to decimal.\n        \"\"\"\n        if not number:\n            number = str(to)\n            to = 10\n        try:\n            irc.reply(self._convertBaseToBase(number, to, frm))\n        except ValueError:\n            irc.error(_('Invalid <number> for base %s: %s') % (frm, number))\n    base = wrap(base, [('int', 'base', lambda i: 2 <= i <= 36),\n                       optional(('int', 'base', lambda i: 2 <= i <= 36), 10),\n                       additional('something')])\n\n    def _convertDecimalToBase(self, number, base):\n        \"\"\"Convert a decimal number to another base; returns a string.\"\"\"\n        if number == 0:\n            return '0'\n        elif number < 0:\n            negative = True\n            number = -number\n        else:\n            negative = False\n        digits = []\n        while number != 0:\n            digit = number % base\n            if digit >= 10:\n                digit = string.ascii_uppercase[digit - 10]\n            else:\n                digit = str(digit)\n            digits.append(digit)\n            number = number // base\n        digits.reverse()\n        return '-'*negative + ''.join(digits)\n\n    def _convertBaseToBase(self, number, toBase, fromBase):\n        \"\"\"Convert a number from any base, 2 through 36, to any other\n        base, 2 through 36. Returns a string.\"\"\"\n        number = minisix.long(str(number), fromBase)\n        if toBase == 10:\n            return str(number)\n        return self._convertDecimalToBase(number, toBase)\n\n    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}\n    _mathEnv.update(math.__dict__)\n    _mathEnv.update(cmath.__dict__)\n    def _sqrt(x):\n        if isinstance(x, complex) or x < 0:\n            return cmath.sqrt(x)\n        else:\n            return math.sqrt(x)\n    def _cbrt(x):\n        return math.pow(x, 1.0/3)\n    def _factorial(x):\n        if x<=10000:\n            return float(math.factorial(x))\n        else:\n            raise Exception('factorial argument too large')\n    _mathEnv['sqrt'] = _sqrt\n    _mathEnv['cbrt'] = _cbrt\n    _mathEnv['abs'] = abs\n    _mathEnv['max'] = max\n    _mathEnv['min'] = min\n    _mathEnv['round'] = lambda x, y=0: round(x, int(y))\n    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])\n    _mathSafeEnv['factorial'] = _factorial\n    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\n                         r'(?:0x[A-Fa-f\\d]+|'\n                         r'0[0-7]+|'\n                         r'\\d+\\.\\d+|'\n                         r'\\.\\d+|'\n                         r'\\d+\\.|'\n                         r'\\d+))')\n    def _floatToString(self, x):\n        if -1e-10 < x < 1e-10:\n            return '0'\n        elif -1e-10 < int(x) - x < 1e-10:\n            return str(int(x))\n        else:\n            return str(x)\n\n    def _complexToString(self, x):\n        realS = self._floatToString(x.real)\n        imagS = self._floatToString(x.imag)\n        if imagS == '0':\n            return realS\n        elif imagS == '1':\n            imagS = '+i'\n        elif imagS == '-1':\n            imagS = '-i'\n        elif x.imag < 0:\n            imagS = '%si' % imagS\n        else:\n            imagS = '+%si' % imagS\n        if realS == '0' and imagS == '0':\n            return '0'\n        elif realS == '0':\n            return imagS.lstrip('+')\n        elif imagS == '0':\n            return realS\n        else:\n            return '%s%s' % (realS, imagS)\n\n    _calc_match_forbidden_chars = re.compile('[_\\[\\]]')\n    _calc_remover = utils.str.MultipleRemover('_[] \\t')\n    ###\n    # So this is how the 'calc' command works:\n    # First, we make a nice little safe environment for evaluation; basically,\n    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability\n    # of a random user to get ints evaluated: this means we have to turn all\n    # int literals (even octal numbers and hexadecimal numbers) into floats.\n    # Then we delete all square brackets, underscores, and whitespace, so no\n    # one can do list comprehensions or call __...__ functions.\n    ###\n    @internationalizeDocstring\n    def calc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        Returns the value of the evaluated <math expression>.  The syntax is\n        Python syntax; the type of arithmetic is floating point.  Floating\n        point arithmetic is used in order to prevent a user from being able to\n        crash to the bot with something like '10**10**10**10'.  One consequence\n        is that large values such as '10**24' might not be exact.\n        \"\"\"\n        try:\n            text = str(text)\n        except UnicodeEncodeError:\n            irc.error(_(\"There's no reason you should have fancy non-ASCII \"\n                            \"characters in your mathematical expression. \"\n                            \"Please remove them.\"))\n            return\n        if self._calc_match_forbidden_chars.match(text):\n            # Note: this is important to keep this to forbid usage of\n            # __builtins__\n            irc.error(_('There\\'s really no reason why you should have '\n                           'underscores or brackets in your mathematical '\n                           'expression.  Please remove them.'))\n            return\n        text = self._calc_remover(text)\n        if 'lambda' in text:\n            irc.error(_('You can\\'t use lambda in this command.'))\n            return\n        text = text.lower()\n        def handleMatch(m):\n            s = m.group(1)\n            if s.startswith('0x'):\n                i = int(s, 16)\n            elif s.startswith('0') and '.' not in s:\n                try:\n                    i = int(s, 8)\n                except ValueError:\n                    i = int(s)\n            else:\n                i = float(s)\n            x = complex(i)\n            if x.imag == 0:\n                x = x.real\n                # Need to use string-formatting here instead of str() because\n                # use of str() on large numbers loses information:\n                # str(float(33333333333333)) => '3.33333333333e+13'\n                # float('3.33333333333e+13') => 33333333333300.0\n                return '%.16f' % x\n            return str(x)\n        text = self._mathRe.sub(handleMatch, text)\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\n            irc.reply(self._complexToString(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except TypeError:\n            irc.error(_('Something in there wasn\\'t a valid number.'))\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(str(e))\n    calc = wrap(calc, ['text'])\n\n    @internationalizeDocstring\n    def icalc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        This is the same as the calc command except that it allows integer\n        math, and can thus cause the bot to suck up CPU.  Hence it requires\n        the 'trusted' capability to use.\n        \"\"\"\n        if self._calc_match_forbidden_chars.match(text):\n            # Note: this is important to keep this to forbid usage of\n            # __builtins__\n            irc.error(_('There\\'s really no reason why you should have '\n                           'underscores or brackets in your mathematical '\n                           'expression.  Please remove them.'))\n            return\n        # This removes spaces, too, but we'll leave the removal of _[] for\n        # safety's sake.\n        text = self._calc_remover(text)\n        if 'lambda' in text:\n            irc.error(_('You can\\'t use lambda in this command.'))\n            return\n        text = text.replace('lambda', '')\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except TypeError:\n            irc.error(_('Something in there wasn\\'t a valid number.'))\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(utils.exnToString(e))\n    icalc = wrap(icalc, [('checkCapability', 'trusted'), 'text'])\n\n    _rpnEnv = {\n        'dup': lambda s: s.extend([s.pop()]*2),\n        'swap': lambda s: s.extend([s.pop(), s.pop()])\n        }\n    def rpn(self, irc, msg, args):\n        \"\"\"<rpn math expression>\n\n        Returns the value of an RPN expression.\n        \"\"\"\n        stack = []\n        for arg in args:\n            try:\n                x = complex(arg)\n                if x == abs(x):\n                    x = abs(x)\n                stack.append(x)\n            except ValueError: # Not a float.\n                if arg in self._mathSafeEnv:\n                    f = self._mathSafeEnv[arg]\n                    if callable(f):\n                        called = False\n                        arguments = []\n                        while not called and stack:\n                            arguments.append(stack.pop())\n                            try:\n                                stack.append(f(*arguments))\n                                called = True\n                            except TypeError:\n                                pass\n                        if not called:\n                            irc.error(_('Not enough arguments for %s') % arg)\n                            return\n                    else:\n                        stack.append(f)\n                elif arg in self._rpnEnv:\n                    self._rpnEnv[arg](stack)\n                else:\n                    arg2 = stack.pop()\n                    arg1 = stack.pop()\n                    s = '%s%s%s' % (arg1, arg, arg2)\n                    try:\n                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\n                    except SyntaxError:\n                        irc.error(format(_('%q is not a defined function.'),\n                                         arg))\n                        return\n        if len(stack) == 1:\n            irc.reply(str(self._complexToString(complex(stack[0]))))\n        else:\n            s = ', '.join(map(self._complexToString, list(map(complex, stack))))\n            irc.reply(_('Stack: [%s]') % s)\n\n    @internationalizeDocstring\n    def convert(self, irc, msg, args, number, unit1, unit2):\n        \"\"\"[<number>] <unit> to <other unit>\n\n        Converts from <unit> to <other unit>. If number isn't given, it\n        defaults to 1. For unit information, see 'units' command.\n        \"\"\"\n        try:\n            digits = len(str(number).split('.')[1])\n        except IndexError:\n            digits = 0\n        try:\n            newNum = convertcore.convert(number, unit1, unit2)\n            if isinstance(newNum, float):\n                zeros = 0\n                for char in str(newNum).split('.')[1]:\n                    if char != '0':\n                        break\n                    zeros += 1\n                # Let's add one signifiant digit. Physicists would not like\n                # that, but common people usually do not give extra zeros...\n                # (for example, with '32 C to F', an extra digit would be\n                # expected).\n                newNum = round(newNum, digits + 1 + zeros)\n            newNum = self._floatToString(newNum)\n            irc.reply(str(newNum))\n        except convertcore.UnitDataError as ude:\n            irc.error(str(ude))\n    convert = wrap(convert, [optional('float', 1.0),'something','to','text'])\n\n    @internationalizeDocstring\n    def units(self, irc, msg, args, type):\n        \"\"\" [<type>]\n\n        With no arguments, returns a list of measurement types, which can be\n        passed as arguments. When called with a type as an argument, returns\n        the units of that type.\n        \"\"\"\n\n        irc.reply(convertcore.units(type))\n    units = wrap(units, [additional('text')])", "target": 1, "line": "@@  -44,6 +44,7  @@\n _ = PluginInternationalization('Math')\n \n from .local import convertcore\n+from .evaluator import safe_eval, InvalidNode, SAFE_ENV\n \n baseArg = ('int', 'base', lambda i: i <= 36)\n \n@@  -97,36 +98,6  @@ def _convertBaseToBase(self, number, toBase, fromBase):\n             return str(number)\n         return self._convertDecimalToBase(number, toBase)\n \n-    _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}\n-    _mathEnv.update(math.__dict__)\n-    _mathEnv.update(cmath.__dict__)\n-    def _sqrt(x):\n-        if isinstance(x, complex) or x < 0:\n-            return cmath.sqrt(x)\n-        else:\n-            return math.sqrt(x)\n-    def _cbrt(x):\n-        return math.pow(x, 1.0/3)\n-    def _factorial(x):\n-        if x<=10000:\n-            return float(math.factorial(x))\n-        else:\n-            raise Exception('factorial argument too large')\n-    _mathEnv['sqrt'] = _sqrt\n-    _mathEnv['cbrt'] = _cbrt\n-    _mathEnv['abs'] = abs\n-    _mathEnv['max'] = max\n-    _mathEnv['min'] = min\n-    _mathEnv['round'] = lambda x, y=0: round(x, int(y))\n-    _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])\n-    _mathSafeEnv['factorial'] = _factorial\n-    _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'\n-                         r'(?:0x[A-Fa-f\\d]+|'\n-                         r'0[0-7]+|'\n-                         r'\\d+\\.\\d+|'\n-                         r'\\.\\d+|'\n-                         r'\\d+\\.|'\n-                         r'\\d+))')\n     def _floatToString(self, x):\n         if -1e-10 < x < 1e-10:\n             return '0'\n@@  -157,17 +128,6  @@ def _complexToString(self, x):\n         else:\n             return '%s%s' % (realS, imagS)\n \n-    _calc_match_forbidden_chars = re.compile('[_\\[\\]]')\n-    _calc_remover = utils.str.MultipleRemover('_[] \\t')\n-    ###\n-    # So this is how the 'calc' command works:\n-    # First, we make a nice little safe environment for evaluation; basically,\n-    # the names in the 'math' and 'cmath' modules.  Then, we remove the ability\n-    # of a random user to get ints evaluated: this means we have to turn all\n-    # int literals (even octal numbers and hexadecimal numbers) into floats.\n-    # Then we delete all square brackets, underscores, and whitespace, so no\n-    # one can do list comprehensions or call __...__ functions.\n-    ###\n     @internationalizeDocstring\n     def calc(self, irc, msg, args, text):\n         \"\"\"<math expression>\n@@  -178,57 +138,17  @@ def calc(self, irc, msg, args, text):\n         crash to the bot with something like '10**10**10**10'.  One consequence\n         is that large values such as '10**24' might not be exact.\n         \"\"\"\n-        try:\n-            text = str(text)\n-        except UnicodeEncodeError:\n-            irc.error(_(\"There's no reason you should have fancy non-ASCII \"\n-                            \"characters in your mathematical expression. \"\n-                            \"Please remove them.\"))\n-            return\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.lower()\n-        def handleMatch(m):\n-            s = m.group(1)\n-            if s.startswith('0x'):\n-                i = int(s, 16)\n-            elif s.startswith('0') and '.' not in s:\n-                try:\n-                    i = int(s, 8)\n-                except ValueError:\n-                    i = int(s)\n-            else:\n-                i = float(s)\n-            x = complex(i)\n-            if x.imag == 0:\n-                x = x.real\n-                # Need to use string-formatting here instead of str() because\n-                # use of str() on large numbers loses information:\n-                # str(float(33333333333333)) => '3.33333333333e+13'\n-                # float('3.33333333333e+13') => 33333333333300.0\n-                return '%.16f' % x\n-            return str(x)\n-        text = self._mathRe.sub(handleMatch, text)\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))\n+            x = complex(safe_eval(text, allow_ints=False))\n             irc.reply(self._complexToString(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n-            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n+            irc.error(_('%s is not a defined function.') % e.args[0])\n         except Exception as e:\n             irc.error(str(e))\n     calc = wrap(calc, ['text'])\n@@  -241,28 +161,15  @@ def icalc(self, irc, msg, args, text):\n         math, and can thus cause the bot to suck up CPU.  Hence it requires\n         the 'trusted' capability to use.\n         \"\"\"\n-        if self._calc_match_forbidden_chars.match(text):\n-            # Note: this is important to keep this to forbid usage of\n-            # __builtins__\n-            irc.error(_('There\\'s really no reason why you should have '\n-                           'underscores or brackets in your mathematical '\n-                           'expression.  Please remove them.'))\n-            return\n-        # This removes spaces, too, but we'll leave the removal of _[] for\n-        # safety's sake.\n-        text = self._calc_remover(text)\n-        if 'lambda' in text:\n-            irc.error(_('You can\\'t use lambda in this command.'))\n-            return\n-        text = text.replace('lambda', '')\n         try:\n             self.log.info('evaluating %q from %s', text, msg.prefix)\n-            irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))\n+            x = safe_eval(text, allow_ints=True)\n+            irc.reply(str(x))\n         except OverflowError:\n             maxFloat = math.ldexp(0.9999999999999999, 1024)\n             irc.error(_('The answer exceeded %s or so.') % maxFloat)\n-        except TypeError:\n-            irc.error(_('Something in there wasn\\'t a valid number.'))\n+        except InvalidNode as e:\n+            irc.error(_('Invalid syntax: %s') % e.args[0])\n         except NameError as e:\n             irc.error(_('%s is not a defined function.') % str(e).split()[1])\n         except Exception as e:\n@@  -286,8 +193,8  @@ def rpn(self, irc, msg, args):\n                     x = abs(x)\n                 stack.append(x)\n             except ValueError: # Not a float.\n-                if arg in self._mathSafeEnv:\n-                    f = self._mathSafeEnv[arg]\n+                if arg in SAFE_ENV:\n+                    f = SAFE_ENV[arg]\n                     if callable(f):\n                         called = False\n                         arguments = []\n@@  -310,7 +217,7  @@ def rpn(self, irc, msg, args):\n                     arg1 = stack.pop()\n                     s = '%s%s%s' % (arg1, arg, arg2)\n                     try:\n-                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))\n+                        stack.append(safe_eval(s, allow_ints=False))\n                     except SyntaxError:\n                         irc.error(format(_('%q is not a defined function.'),\n                                          arg))"}], "function_after": [{"function": "class Math(callbacks.Plugin):\n    \"\"\"Provides commands to work with math, such as a calculator and\n    a unit converter.\"\"\"\n    @internationalizeDocstring\n    def base(self, irc, msg, args, frm, to, number):\n        \"\"\"<fromBase> [<toBase>] <number>\n\n        Converts <number> from base <fromBase> to base <toBase>.\n        If <toBase> is left out, it converts to decimal.\n        \"\"\"\n        if not number:\n            number = str(to)\n            to = 10\n        try:\n            irc.reply(self._convertBaseToBase(number, to, frm))\n        except ValueError:\n            irc.error(_('Invalid <number> for base %s: %s') % (frm, number))\n    base = wrap(base, [('int', 'base', lambda i: 2 <= i <= 36),\n                       optional(('int', 'base', lambda i: 2 <= i <= 36), 10),\n                       additional('something')])\n\n    def _convertDecimalToBase(self, number, base):\n        \"\"\"Convert a decimal number to another base; returns a string.\"\"\"\n        if number == 0:\n            return '0'\n        elif number < 0:\n            negative = True\n            number = -number\n        else:\n            negative = False\n        digits = []\n        while number != 0:\n            digit = number % base\n            if digit >= 10:\n                digit = string.ascii_uppercase[digit - 10]\n            else:\n                digit = str(digit)\n            digits.append(digit)\n            number = number // base\n        digits.reverse()\n        return '-'*negative + ''.join(digits)\n\n    def _convertBaseToBase(self, number, toBase, fromBase):\n        \"\"\"Convert a number from any base, 2 through 36, to any other\n        base, 2 through 36. Returns a string.\"\"\"\n        number = minisix.long(str(number), fromBase)\n        if toBase == 10:\n            return str(number)\n        return self._convertDecimalToBase(number, toBase)\n\n    def _floatToString(self, x):\n        if -1e-10 < x < 1e-10:\n            return '0'\n        elif -1e-10 < int(x) - x < 1e-10:\n            return str(int(x))\n        else:\n            return str(x)\n\n    def _complexToString(self, x):\n        realS = self._floatToString(x.real)\n        imagS = self._floatToString(x.imag)\n        if imagS == '0':\n            return realS\n        elif imagS == '1':\n            imagS = '+i'\n        elif imagS == '-1':\n            imagS = '-i'\n        elif x.imag < 0:\n            imagS = '%si' % imagS\n        else:\n            imagS = '+%si' % imagS\n        if realS == '0' and imagS == '0':\n            return '0'\n        elif realS == '0':\n            return imagS.lstrip('+')\n        elif imagS == '0':\n            return realS\n        else:\n            return '%s%s' % (realS, imagS)\n\n    @internationalizeDocstring\n    def calc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        Returns the value of the evaluated <math expression>.  The syntax is\n        Python syntax; the type of arithmetic is floating point.  Floating\n        point arithmetic is used in order to prevent a user from being able to\n        crash to the bot with something like '10**10**10**10'.  One consequence\n        is that large values such as '10**24' might not be exact.\n        \"\"\"\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = complex(safe_eval(text, allow_ints=False))\n            irc.reply(self._complexToString(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except InvalidNode as e:\n            irc.error(_('Invalid syntax: %s') % e.args[0])\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % e.args[0])\n        except Exception as e:\n            irc.error(str(e))\n    calc = wrap(calc, ['text'])\n\n    @internationalizeDocstring\n    def icalc(self, irc, msg, args, text):\n        \"\"\"<math expression>\n\n        This is the same as the calc command except that it allows integer\n        math, and can thus cause the bot to suck up CPU.  Hence it requires\n        the 'trusted' capability to use.\n        \"\"\"\n        try:\n            self.log.info('evaluating %q from %s', text, msg.prefix)\n            x = safe_eval(text, allow_ints=True)\n            irc.reply(str(x))\n        except OverflowError:\n            maxFloat = math.ldexp(0.9999999999999999, 1024)\n            irc.error(_('The answer exceeded %s or so.') % maxFloat)\n        except InvalidNode as e:\n            irc.error(_('Invalid syntax: %s') % e.args[0])\n        except NameError as e:\n            irc.error(_('%s is not a defined function.') % str(e).split()[1])\n        except Exception as e:\n            irc.error(utils.exnToString(e))\n    icalc = wrap(icalc, [('checkCapability', 'trusted'), 'text'])\n\n    _rpnEnv = {\n        'dup': lambda s: s.extend([s.pop()]*2),\n        'swap': lambda s: s.extend([s.pop(), s.pop()])\n        }\n    def rpn(self, irc, msg, args):\n        \"\"\"<rpn math expression>\n\n        Returns the value of an RPN expression.\n        \"\"\"\n        stack = []\n        for arg in args:\n            try:\n                x = complex(arg)\n                if x == abs(x):\n                    x = abs(x)\n                stack.append(x)\n            except ValueError: # Not a float.\n                if arg in SAFE_ENV:\n                    f = SAFE_ENV[arg]\n                    if callable(f):\n                        called = False\n                        arguments = []\n                        while not called and stack:\n                            arguments.append(stack.pop())\n                            try:\n                                stack.append(f(*arguments))\n                                called = True\n                            except TypeError:\n                                pass\n                        if not called:\n                            irc.error(_('Not enough arguments for %s') % arg)\n                            return\n                    else:\n                        stack.append(f)\n                elif arg in self._rpnEnv:\n                    self._rpnEnv[arg](stack)\n                else:\n                    arg2 = stack.pop()\n                    arg1 = stack.pop()\n                    s = '%s%s%s' % (arg1, arg, arg2)\n                    try:\n                        stack.append(safe_eval(s, allow_ints=False))\n                    except SyntaxError:\n                        irc.error(format(_('%q is not a defined function.'),\n                                         arg))\n                        return\n        if len(stack) == 1:\n            irc.reply(str(self._complexToString(complex(stack[0]))))\n        else:\n            s = ', '.join(map(self._complexToString, list(map(complex, stack))))\n            irc.reply(_('Stack: [%s]') % s)\n\n    @internationalizeDocstring\n    def convert(self, irc, msg, args, number, unit1, unit2):\n        \"\"\"[<number>] <unit> to <other unit>\n\n        Converts from <unit> to <other unit>. If number isn't given, it\n        defaults to 1. For unit information, see 'units' command.\n        \"\"\"\n        try:\n            digits = len(str(number).split('.')[1])\n        except IndexError:\n            digits = 0\n        try:\n            newNum = convertcore.convert(number, unit1, unit2)\n            if isinstance(newNum, float):\n                zeros = 0\n                for char in str(newNum).split('.')[1]:\n                    if char != '0':\n                        break\n                    zeros += 1\n                # Let's add one signifiant digit. Physicists would not like\n                # that, but common people usually do not give extra zeros...\n                # (for example, with '32 C to F', an extra digit would be\n                # expected).\n                newNum = round(newNum, digits + 1 + zeros)\n            newNum = self._floatToString(newNum)\n            irc.reply(str(newNum))\n        except convertcore.UnitDataError as ude:\n            irc.error(str(ude))\n    convert = wrap(convert, [optional('float', 1.0),'something','to','text'])\n\n    @internationalizeDocstring\n    def units(self, irc, msg, args, type):\n        \"\"\" [<type>]\n\n        With no arguments, returns a list of measurement types, which can be\n        passed as arguments. When called with a type as an argument, returns\n        the units of that type.\n        \"\"\"\n\n        irc.reply(convertcore.units(type))\n    units = wrap(units, [additional('text')])", "target": 0}]}, {"raw_url": "https://github.com/progval/Limnoria/raw/3848ae78de45b35c029cc333963d436b9d2f0a35/plugins%2FMath%2Ftest.py", "code": "###\n# Copyright (c) 2002-2004, Jeremiah Fincher\n# Copyright (c) 2008, James McCoy\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions, and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions, and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#   * Neither the name of the author of this software nor the name of\n#     contributors to this software may be used to endorse or promote products\n#     derived from this software without specific prior written consent.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n###\n\nfrom __future__ import print_function\n\nfrom supybot.test import *\n\nclass MathTestCase(PluginTestCase):\n    plugins = ('Math',)\n    def testBase(self):\n        self.assertNotRegexp('base 56 asdflkj', 'ValueError')\n        self.assertResponse('base 16 2 F', '1111')\n        self.assertResponse('base 2 16 1111', 'F')\n        self.assertResponse('base 20 BBBB', '92631')\n        self.assertResponse('base 10 20 92631', 'BBBB')\n        self.assertResponse('base 2 36 10', '2')\n        self.assertResponse('base 36 2 10', '100100')\n        self.assertResponse('base 2 1010101', '85')\n        self.assertResponse('base 2 2 11', '11')\n\n        self.assertResponse('base 12 0', '0')\n        self.assertResponse('base 36 2 0', '0')\n\n\n        self.assertNotError(\"base 36 \" +\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse(\"base 10 36 [base 36 \" +\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz]\",\n\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse('base 2 10 [base 10 2 12]', '12')\n        self.assertResponse('base 16 2 [base 2 16 110101]', '110101')\n        self.assertResponse('base 10 8 [base 8 76532]', '76532')\n        self.assertResponse('base 10 36 [base 36 csalnwea]', 'CSALNWEA')\n        self.assertResponse('base 5 4 [base 4 5 212231]', '212231')\n\n        self.assertError('base 37 1')\n        self.assertError('base 1 1')\n        self.assertError('base 12 1 1')\n        self.assertError('base 1 12 1')\n        self.assertError('base 1.0 12 1')\n        self.assertError('base A 1')\n\n        self.assertError('base 4 4')\n        self.assertError('base 10 12 A')\n\n        self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n        self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n\n    def testCalc(self):\n        self.assertResponse('calc 5*0.06', str(5*0.06))\n        self.assertResponse('calc 2.0-7.0', str(2-7))\n        self.assertResponse('calc e**(i*pi)+1', '0')\n        if minisix.PY3:\n            # Python 2 has bad handling of exponentiation of negative numbers\n            self.assertResponse('calc (-1)**.5', 'i')\n            self.assertRegexp('calc (-5)**.5', '2.236067977[0-9]+i')\n            self.assertRegexp('calc -((-5)**.5)', '-2.236067977[0-9]+i')\n        self.assertNotRegexp('calc [9, 5] + [9, 10]', 'TypeError')\n        self.assertError('calc [9, 5] + [9, 10]')\n        self.assertNotError('calc degrees(2)')\n        self.assertNotError('calc (2 * 3) - 2*(3*4)')\n        self.assertNotError('calc (3) - 2*(3*4)')\n        self.assertNotError('calc (1600 * 1200) - 2*(1024*1280)')\n        self.assertNotError('calc 3-2*4')\n        self.assertNotError('calc (1600 * 1200)-2*(1024*1280)')\n        self.assertError('calc factorial(20000)')\n\n    def testCalcNoNameError(self):\n        self.assertRegexp('calc foobar(x)', 'foobar is not a defined function')\n\n    def testCalcInvalidNode(self):\n        self.assertRegexp('calc {\"foo\": \"bar\"}', 'Illegal construct Dict')\n\n    def testCalcImaginary(self):\n        self.assertResponse('calc 3 + sqrt(-1)', '3+i')\n\n    def testCalcFloorWorksWithSqrt(self):\n        self.assertNotError('calc floor(sqrt(5))')\n\n    def testCaseInsensitive(self):\n        self.assertNotError('calc PI**PI')\n\n    def testCalcMaxMin(self):\n        self.assertResponse('calc max(1,2)', '2')\n        self.assertResponse('calc min(1,2)', '1')\n\n    def testCalcStrFloat(self):\n        self.assertResponse('calc 3+33333333333333', '33333333333336')\n\n    def testICalc(self):\n        self.assertResponse('icalc 1^1', '0')\n        self.assertResponse('icalc 10**24', '1' + '0'*24)\n        self.assertRegexp('icalc 49/6', '8.16')\n        self.assertNotError('icalc factorial(20000)')\n\n    def testRpn(self):\n        self.assertResponse('rpn 5 2 +', '7')\n        self.assertResponse('rpn 1 2 3 +', 'Stack: [1, 5]')\n        self.assertResponse('rpn 1 dup', 'Stack: [1, 1]')\n        self.assertResponse('rpn 2 3 4 + -', str(2-7))\n        self.assertNotError('rpn 2 degrees')\n\n    def testRpnSwap(self):\n        self.assertResponse('rpn 1 2 swap', 'Stack: [2, 1]')\n\n    def testRpmNoSyntaxError(self):\n        self.assertNotRegexp('rpn 2 3 foobar', 'SyntaxError')\n\n    def testConvert(self):\n        self.assertResponse('convert 1 m to cm', '100')\n        self.assertResponse('convert m to cm', '100')\n        self.assertResponse('convert 3 metres to km', '0.003')\n        self.assertResponse('convert 32 F to C', '0')\n        self.assertResponse('convert 32 C to F', '89.6')\n        self.assertResponse('convert [calc 2*pi] rad to degree', '360')\n        self.assertResponse('convert amu to atomic mass unit',\n                            '1')\n        self.assertResponse('convert [calc 2*pi] rad to circle', '1')\n\n\n\n        self.assertError('convert 1 meatball to bananas')\n        self.assertError('convert 1 gram to meatballs')\n        self.assertError('convert 1 mol to grams')\n        self.assertError('convert 1 m to kpa')\n\n    def testConvertSingularPlural(self):\n        self.assertResponse('convert [calc 2*pi] rads to degrees', '360')\n        self.assertResponse('convert 1 carat to grams', '0.2')\n        self.assertResponse('convert 10 lbs to oz', '160')\n        self.assertResponse('convert mA to amps', '0.001')\n\n    def testConvertCaseSensitivity(self):\n        self.assertError('convert MA to amps')\n        self.assertError('convert M to amps')\n        self.assertError('convert Radians to rev')\n\n    def testUnits(self):\n        self.assertNotError('units')\n        self.assertNotError('units mass')\n        self.assertNotError('units flux density')\n\n    def testAbs(self):\n        self.assertResponse('calc abs(2)', '2')\n        self.assertResponse('calc abs(-2)', '2')\n        self.assertResponse('calc abs(2.0)', '2')\n        self.assertResponse('calc abs(-2.0)', '2')\n\n\n# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:\n\n", "code_before": "###\n# Copyright (c) 2002-2004, Jeremiah Fincher\n# Copyright (c) 2008, James McCoy\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions, and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions, and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#   * Neither the name of the author of this software nor the name of\n#     contributors to this software may be used to endorse or promote products\n#     derived from this software without specific prior written consent.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n###\n\nfrom __future__ import print_function\n\nfrom supybot.test import *\n\nclass MathTestCase(PluginTestCase):\n    plugins = ('Math',)\n    def testBase(self):\n        self.assertNotRegexp('base 56 asdflkj', 'ValueError')\n        self.assertResponse('base 16 2 F', '1111')\n        self.assertResponse('base 2 16 1111', 'F')\n        self.assertResponse('base 20 BBBB', '92631')\n        self.assertResponse('base 10 20 92631', 'BBBB')\n        self.assertResponse('base 2 36 10', '2')\n        self.assertResponse('base 36 2 10', '100100')\n        self.assertResponse('base 2 1010101', '85')\n        self.assertResponse('base 2 2 11', '11')\n\n        self.assertResponse('base 12 0', '0')\n        self.assertResponse('base 36 2 0', '0')\n\n\n        self.assertNotError(\"base 36 \" +\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse(\"base 10 36 [base 36 \" +\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz]\",\n\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse('base 2 10 [base 10 2 12]', '12')\n        self.assertResponse('base 16 2 [base 2 16 110101]', '110101')\n        self.assertResponse('base 10 8 [base 8 76532]', '76532')\n        self.assertResponse('base 10 36 [base 36 csalnwea]', 'CSALNWEA')\n        self.assertResponse('base 5 4 [base 4 5 212231]', '212231')\n\n        self.assertError('base 37 1')\n        self.assertError('base 1 1')\n        self.assertError('base 12 1 1')\n        self.assertError('base 1 12 1')\n        self.assertError('base 1.0 12 1')\n        self.assertError('base A 1')\n\n        self.assertError('base 4 4')\n        self.assertError('base 10 12 A')\n\n        print()\n        print(\"If we have not fixed a bug with Math.base, the following \")\n        print(\"tests will hang the test-suite.\")\n        self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n        self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n\n    def testCalc(self):\n        self.assertResponse('calc 5*0.06', str(5*0.06))\n        self.assertResponse('calc 2.0-7.0', str(2-7))\n        self.assertResponse('calc e**(i*pi)+1', '0')\n        if minisix.PY3:\n            # Python 2 has bad handling of exponentiation of negative numbers\n            self.assertResponse('calc (-1)**.5', 'i')\n            self.assertRegexp('calc (-5)**.5', '2.236067977[0-9]+i')\n            self.assertRegexp('calc -((-5)**.5)', '-2.236067977[0-9]+i')\n        self.assertNotRegexp('calc [9, 5] + [9, 10]', 'TypeError')\n        self.assertError('calc [9, 5] + [9, 10]')\n        self.assertNotError('calc degrees(2)')\n        self.assertNotError('calc (2 * 3) - 2*(3*4)')\n        self.assertNotError('calc (3) - 2*(3*4)')\n        self.assertNotError('calc (1600 * 1200) - 2*(1024*1280)')\n        self.assertNotError('calc 3-2*4')\n        self.assertNotError('calc (1600 * 1200)-2*(1024*1280)')\n        self.assertError('calc factorial(20000)')\n\n    def testCalcNoNameError(self):\n        self.assertNotRegexp('calc foobar(x)', 'NameError')\n\n    def testCalcImaginary(self):\n        self.assertResponse('calc 3 + sqrt(-1)', '3+i')\n\n    def testCalcFloorWorksWithSqrt(self):\n        self.assertNotError('calc floor(sqrt(5))')\n\n    def testCaseInsensitive(self):\n        self.assertNotError('calc PI**PI')\n\n    def testCalcMaxMin(self):\n        self.assertResponse('calc max(1,2)', '2')\n        self.assertResponse('calc min(1,2)', '1')\n\n    def testCalcStrFloat(self):\n        self.assertResponse('calc 3+33333333333333', '33333333333336')\n\n    def testICalc(self):\n        self.assertResponse('icalc 1^1', '0')\n        self.assertResponse('icalc 10**24', '1' + '0'*24)\n        self.assertRegexp('icalc 49/6', '8.16')\n        self.assertNotError('icalc factorial(20000)')\n\n    def testRpn(self):\n        self.assertResponse('rpn 5 2 +', '7')\n        self.assertResponse('rpn 1 2 3 +', 'Stack: [1, 5]')\n        self.assertResponse('rpn 1 dup', 'Stack: [1, 1]')\n        self.assertResponse('rpn 2 3 4 + -', str(2-7))\n        self.assertNotError('rpn 2 degrees')\n\n    def testRpnSwap(self):\n        self.assertResponse('rpn 1 2 swap', 'Stack: [2, 1]')\n\n    def testRpmNoSyntaxError(self):\n        self.assertNotRegexp('rpn 2 3 foobar', 'SyntaxError')\n\n    def testConvert(self):\n        self.assertResponse('convert 1 m to cm', '100')\n        self.assertResponse('convert m to cm', '100')\n        self.assertResponse('convert 3 metres to km', '0.003')\n        self.assertResponse('convert 32 F to C', '0')\n        self.assertResponse('convert 32 C to F', '89.6')\n        self.assertResponse('convert [calc 2*pi] rad to degree', '360')\n        self.assertResponse('convert amu to atomic mass unit',\n                            '1')\n        self.assertResponse('convert [calc 2*pi] rad to circle', '1')\n\n\n\n        self.assertError('convert 1 meatball to bananas')\n        self.assertError('convert 1 gram to meatballs')\n        self.assertError('convert 1 mol to grams')\n        self.assertError('convert 1 m to kpa')\n\n    def testConvertSingularPlural(self):\n        self.assertResponse('convert [calc 2*pi] rads to degrees', '360')\n        self.assertResponse('convert 1 carat to grams', '0.2')\n        self.assertResponse('convert 10 lbs to oz', '160')\n        self.assertResponse('convert mA to amps', '0.001')\n\n    def testConvertCaseSensitivity(self):\n        self.assertError('convert MA to amps')\n        self.assertError('convert M to amps')\n        self.assertError('convert Radians to rev')\n\n    def testUnits(self):\n        self.assertNotError('units')\n        self.assertNotError('units mass')\n        self.assertNotError('units flux density')\n\n    def testAbs(self):\n        self.assertResponse('calc abs(2)', '2')\n        self.assertResponse('calc abs(-2)', '2')\n        self.assertResponse('calc abs(2.0)', '2')\n        self.assertResponse('calc abs(-2.0)', '2')\n\n\n# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:\n\n", "patch": "@@ -91,9 +91,6 @@ def testBase(self):\n         self.assertError('base 4 4')\n         self.assertError('base 10 12 A')\n \n-        print()\n-        print(\"If we have not fixed a bug with Math.base, the following \")\n-        print(\"tests will hang the test-suite.\")\n         self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n         self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n \n@@ -117,7 +114,10 @@ def testCalc(self):\n         self.assertError('calc factorial(20000)')\n \n     def testCalcNoNameError(self):\n-        self.assertNotRegexp('calc foobar(x)', 'NameError')\n+        self.assertRegexp('calc foobar(x)', 'foobar is not a defined function')\n+\n+    def testCalcInvalidNode(self):\n+        self.assertRegexp('calc {\"foo\": \"bar\"}', 'Illegal construct Dict')\n \n     def testCalcImaginary(self):\n         self.assertResponse('calc 3 + sqrt(-1)', '3+i')", "file_path": "files/2019_11\\332", "file_language": "py", "file_name": "plugins/Math/test.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class MathTestCase(PluginTestCase):\n    plugins = ('Math',)\n    def testBase(self):\n        self.assertNotRegexp('base 56 asdflkj', 'ValueError')\n        self.assertResponse('base 16 2 F', '1111')\n        self.assertResponse('base 2 16 1111', 'F')\n        self.assertResponse('base 20 BBBB', '92631')\n        self.assertResponse('base 10 20 92631', 'BBBB')\n        self.assertResponse('base 2 36 10', '2')\n        self.assertResponse('base 36 2 10', '100100')\n        self.assertResponse('base 2 1010101', '85')\n        self.assertResponse('base 2 2 11', '11')\n\n        self.assertResponse('base 12 0', '0')\n        self.assertResponse('base 36 2 0', '0')\n\n\n        self.assertNotError(\"base 36 \" +\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse(\"base 10 36 [base 36 \" +\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz]\",\n\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse('base 2 10 [base 10 2 12]', '12')\n        self.assertResponse('base 16 2 [base 2 16 110101]', '110101')\n        self.assertResponse('base 10 8 [base 8 76532]', '76532')\n        self.assertResponse('base 10 36 [base 36 csalnwea]', 'CSALNWEA')\n        self.assertResponse('base 5 4 [base 4 5 212231]', '212231')\n\n        self.assertError('base 37 1')\n        self.assertError('base 1 1')\n        self.assertError('base 12 1 1')\n        self.assertError('base 1 12 1')\n        self.assertError('base 1.0 12 1')\n        self.assertError('base A 1')\n\n        self.assertError('base 4 4')\n        self.assertError('base 10 12 A')\n\n        print()\n        print(\"If we have not fixed a bug with Math.base, the following \")\n        print(\"tests will hang the test-suite.\")\n        self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n        self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n\n    def testCalc(self):\n        self.assertResponse('calc 5*0.06', str(5*0.06))\n        self.assertResponse('calc 2.0-7.0', str(2-7))\n        self.assertResponse('calc e**(i*pi)+1', '0')\n        if minisix.PY3:\n            # Python 2 has bad handling of exponentiation of negative numbers\n            self.assertResponse('calc (-1)**.5', 'i')\n            self.assertRegexp('calc (-5)**.5', '2.236067977[0-9]+i')\n            self.assertRegexp('calc -((-5)**.5)', '-2.236067977[0-9]+i')\n        self.assertNotRegexp('calc [9, 5] + [9, 10]', 'TypeError')\n        self.assertError('calc [9, 5] + [9, 10]')\n        self.assertNotError('calc degrees(2)')\n        self.assertNotError('calc (2 * 3) - 2*(3*4)')\n        self.assertNotError('calc (3) - 2*(3*4)')\n        self.assertNotError('calc (1600 * 1200) - 2*(1024*1280)')\n        self.assertNotError('calc 3-2*4')\n        self.assertNotError('calc (1600 * 1200)-2*(1024*1280)')\n        self.assertError('calc factorial(20000)')\n\n    def testCalcNoNameError(self):\n        self.assertNotRegexp('calc foobar(x)', 'NameError')\n\n    def testCalcImaginary(self):\n        self.assertResponse('calc 3 + sqrt(-1)', '3+i')\n\n    def testCalcFloorWorksWithSqrt(self):\n        self.assertNotError('calc floor(sqrt(5))')\n\n    def testCaseInsensitive(self):\n        self.assertNotError('calc PI**PI')\n\n    def testCalcMaxMin(self):\n        self.assertResponse('calc max(1,2)', '2')\n        self.assertResponse('calc min(1,2)', '1')\n\n    def testCalcStrFloat(self):\n        self.assertResponse('calc 3+33333333333333', '33333333333336')\n\n    def testICalc(self):\n        self.assertResponse('icalc 1^1', '0')\n        self.assertResponse('icalc 10**24', '1' + '0'*24)\n        self.assertRegexp('icalc 49/6', '8.16')\n        self.assertNotError('icalc factorial(20000)')\n\n    def testRpn(self):\n        self.assertResponse('rpn 5 2 +', '7')\n        self.assertResponse('rpn 1 2 3 +', 'Stack: [1, 5]')\n        self.assertResponse('rpn 1 dup', 'Stack: [1, 1]')\n        self.assertResponse('rpn 2 3 4 + -', str(2-7))\n        self.assertNotError('rpn 2 degrees')\n\n    def testRpnSwap(self):\n        self.assertResponse('rpn 1 2 swap', 'Stack: [2, 1]')\n\n    def testRpmNoSyntaxError(self):\n        self.assertNotRegexp('rpn 2 3 foobar', 'SyntaxError')\n\n    def testConvert(self):\n        self.assertResponse('convert 1 m to cm', '100')\n        self.assertResponse('convert m to cm', '100')\n        self.assertResponse('convert 3 metres to km', '0.003')\n        self.assertResponse('convert 32 F to C', '0')\n        self.assertResponse('convert 32 C to F', '89.6')\n        self.assertResponse('convert [calc 2*pi] rad to degree', '360')\n        self.assertResponse('convert amu to atomic mass unit',\n                            '1')\n        self.assertResponse('convert [calc 2*pi] rad to circle', '1')\n\n\n\n        self.assertError('convert 1 meatball to bananas')\n        self.assertError('convert 1 gram to meatballs')\n        self.assertError('convert 1 mol to grams')\n        self.assertError('convert 1 m to kpa')\n\n    def testConvertSingularPlural(self):\n        self.assertResponse('convert [calc 2*pi] rads to degrees', '360')\n        self.assertResponse('convert 1 carat to grams', '0.2')\n        self.assertResponse('convert 10 lbs to oz', '160')\n        self.assertResponse('convert mA to amps', '0.001')\n\n    def testConvertCaseSensitivity(self):\n        self.assertError('convert MA to amps')\n        self.assertError('convert M to amps')\n        self.assertError('convert Radians to rev')\n\n    def testUnits(self):\n        self.assertNotError('units')\n        self.assertNotError('units mass')\n        self.assertNotError('units flux density')\n\n    def testAbs(self):\n        self.assertResponse('calc abs(2)', '2')\n        self.assertResponse('calc abs(-2)', '2')\n        self.assertResponse('calc abs(2.0)', '2')\n        self.assertResponse('calc abs(-2.0)', '2')", "target": 0}], "function_after": [{"function": "class MathTestCase(PluginTestCase):\n    plugins = ('Math',)\n    def testBase(self):\n        self.assertNotRegexp('base 56 asdflkj', 'ValueError')\n        self.assertResponse('base 16 2 F', '1111')\n        self.assertResponse('base 2 16 1111', 'F')\n        self.assertResponse('base 20 BBBB', '92631')\n        self.assertResponse('base 10 20 92631', 'BBBB')\n        self.assertResponse('base 2 36 10', '2')\n        self.assertResponse('base 36 2 10', '100100')\n        self.assertResponse('base 2 1010101', '85')\n        self.assertResponse('base 2 2 11', '11')\n\n        self.assertResponse('base 12 0', '0')\n        self.assertResponse('base 36 2 0', '0')\n\n\n        self.assertNotError(\"base 36 \" +\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse(\"base 10 36 [base 36 \" +\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"\\\n            \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz]\",\n\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\"\\\n            \"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\")\n\n        self.assertResponse('base 2 10 [base 10 2 12]', '12')\n        self.assertResponse('base 16 2 [base 2 16 110101]', '110101')\n        self.assertResponse('base 10 8 [base 8 76532]', '76532')\n        self.assertResponse('base 10 36 [base 36 csalnwea]', 'CSALNWEA')\n        self.assertResponse('base 5 4 [base 4 5 212231]', '212231')\n\n        self.assertError('base 37 1')\n        self.assertError('base 1 1')\n        self.assertError('base 12 1 1')\n        self.assertError('base 1 12 1')\n        self.assertError('base 1.0 12 1')\n        self.assertError('base A 1')\n\n        self.assertError('base 4 4')\n        self.assertError('base 10 12 A')\n\n        self.assertRegexp('base 2 10 [base 10 2 -12]', '-12')\n        self.assertRegexp('base 16 2 [base 2 16 -110101]', '-110101')\n\n    def testCalc(self):\n        self.assertResponse('calc 5*0.06', str(5*0.06))\n        self.assertResponse('calc 2.0-7.0', str(2-7))\n        self.assertResponse('calc e**(i*pi)+1', '0')\n        if minisix.PY3:\n            # Python 2 has bad handling of exponentiation of negative numbers\n            self.assertResponse('calc (-1)**.5', 'i')\n            self.assertRegexp('calc (-5)**.5', '2.236067977[0-9]+i')\n            self.assertRegexp('calc -((-5)**.5)', '-2.236067977[0-9]+i')\n        self.assertNotRegexp('calc [9, 5] + [9, 10]', 'TypeError')\n        self.assertError('calc [9, 5] + [9, 10]')\n        self.assertNotError('calc degrees(2)')\n        self.assertNotError('calc (2 * 3) - 2*(3*4)')\n        self.assertNotError('calc (3) - 2*(3*4)')\n        self.assertNotError('calc (1600 * 1200) - 2*(1024*1280)')\n        self.assertNotError('calc 3-2*4')\n        self.assertNotError('calc (1600 * 1200)-2*(1024*1280)')\n        self.assertError('calc factorial(20000)')\n\n    def testCalcNoNameError(self):\n        self.assertRegexp('calc foobar(x)', 'foobar is not a defined function')\n\n    def testCalcInvalidNode(self):\n        self.assertRegexp('calc {\"foo\": \"bar\"}', 'Illegal construct Dict')\n\n    def testCalcImaginary(self):\n        self.assertResponse('calc 3 + sqrt(-1)', '3+i')\n\n    def testCalcFloorWorksWithSqrt(self):\n        self.assertNotError('calc floor(sqrt(5))')\n\n    def testCaseInsensitive(self):\n        self.assertNotError('calc PI**PI')\n\n    def testCalcMaxMin(self):\n        self.assertResponse('calc max(1,2)', '2')\n        self.assertResponse('calc min(1,2)', '1')\n\n    def testCalcStrFloat(self):\n        self.assertResponse('calc 3+33333333333333', '33333333333336')\n\n    def testICalc(self):\n        self.assertResponse('icalc 1^1', '0')\n        self.assertResponse('icalc 10**24', '1' + '0'*24)\n        self.assertRegexp('icalc 49/6', '8.16')\n        self.assertNotError('icalc factorial(20000)')\n\n    def testRpn(self):\n        self.assertResponse('rpn 5 2 +', '7')\n        self.assertResponse('rpn 1 2 3 +', 'Stack: [1, 5]')\n        self.assertResponse('rpn 1 dup', 'Stack: [1, 1]')\n        self.assertResponse('rpn 2 3 4 + -', str(2-7))\n        self.assertNotError('rpn 2 degrees')\n\n    def testRpnSwap(self):\n        self.assertResponse('rpn 1 2 swap', 'Stack: [2, 1]')\n\n    def testRpmNoSyntaxError(self):\n        self.assertNotRegexp('rpn 2 3 foobar', 'SyntaxError')\n\n    def testConvert(self):\n        self.assertResponse('convert 1 m to cm', '100')\n        self.assertResponse('convert m to cm', '100')\n        self.assertResponse('convert 3 metres to km', '0.003')\n        self.assertResponse('convert 32 F to C', '0')\n        self.assertResponse('convert 32 C to F', '89.6')\n        self.assertResponse('convert [calc 2*pi] rad to degree', '360')\n        self.assertResponse('convert amu to atomic mass unit',\n                            '1')\n        self.assertResponse('convert [calc 2*pi] rad to circle', '1')\n\n\n\n        self.assertError('convert 1 meatball to bananas')\n        self.assertError('convert 1 gram to meatballs')\n        self.assertError('convert 1 mol to grams')\n        self.assertError('convert 1 m to kpa')\n\n    def testConvertSingularPlural(self):\n        self.assertResponse('convert [calc 2*pi] rads to degrees', '360')\n        self.assertResponse('convert 1 carat to grams', '0.2')\n        self.assertResponse('convert 10 lbs to oz', '160')\n        self.assertResponse('convert mA to amps', '0.001')\n\n    def testConvertCaseSensitivity(self):\n        self.assertError('convert MA to amps')\n        self.assertError('convert M to amps')\n        self.assertError('convert Radians to rev')\n\n    def testUnits(self):\n        self.assertNotError('units')\n        self.assertNotError('units mass')\n        self.assertNotError('units flux density')\n\n    def testAbs(self):\n        self.assertResponse('calc abs(2)', '2')\n        self.assertResponse('calc abs(-2)', '2')\n        self.assertResponse('calc abs(2.0)', '2')\n        self.assertResponse('calc abs(-2.0)', '2')", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
