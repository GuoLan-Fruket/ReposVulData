{"index": 12259, "cve_id": "CVE-2023-26145", "cwe_id": ["CWE-94", "CWE-77"], "cve_language": "Python", "cve_description": "This affects versions of the package pydash before 6.0.0. A number of pydash methods such as pydash.objects.invoke() and pydash.collections.invoke_map() accept dotted paths (Deep Path Strings) to target a nested Python object, relative to the original source object. These paths can be used to target internal class attributes and dict items, to retrieve, modify or invoke nested Python objects.\r\r**Note:**\r\rThe pydash.objects.invoke() method is vulnerable to Command Injection when the following prerequisites are satisfied:\r\r1) The source object (argument 1) is not a built-in object such as list/dict (otherwise, the __init__.__globals__ path is not accessible)\r\r2) The attacker has control over argument 2 (the path string) and argument 3 (the argument to pass to the invoked method)\r\r\rThe pydash.collections.invoke_map() method is also vulnerable, but is harder to exploit as the attacker does not have direct control over the argument to be passed to the invoked function.", "cvss": "8.1", "publish_date": "September 28, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "6ff0831ad285fff937cafd2a853f20cc9ae92021", "commit_message": "fix: don't allow object paths that reference dunder-method attributes for functions like get()", "commit_date": "2023-01-29T01:30:52Z", "project": "dgilland/pydash", "url": "https://api.github.com/repos/dgilland/pydash/commits/6ff0831ad285fff937cafd2a853f20cc9ae92021", "html_url": "https://github.com/dgilland/pydash/commit/6ff0831ad285fff937cafd2a853f20cc9ae92021", "windows_before": [{"commit_id": "1947d2ad210129d1c2925f0c8837323d7fd420db", "commit_date": "Sat Jan 28 20:22:47 2023 -0500", "commit_message": "chore: minor tweak to error message shown when lint fails", "files_name": ["tasks.py"]}, {"commit_id": "bfa8de1eb522fc0ac8c037408aa98de606c5d488", "commit_date": "Sat Jan 28 19:21:09 2023 -0500", "commit_message": "chore: drop support for Python 3.6 (part 2)", "files_name": ["setup.cfg"]}, {"commit_id": "a8a1b109b61f3fa6571e9abea2c6559b6dae1012", "commit_date": "Sat Jan 28 13:02:16 2023 -0500", "commit_message": "fix: revert flake8>=6.0 pinning since it's not compatible with Python 3.7", "files_name": ["setup.cfg"]}, {"commit_id": "0a430c67c85afd499e93b0cdeb2b0b58aa37b87b", "commit_date": "Sat Jan 28 13:00:43 2023 -0500", "commit_message": "fix: try to use flake8>=6.0 on all Python versions", "files_name": ["setup.cfg"]}, {"commit_id": "933b78d0cd1aaef2c73c3eebeff08da3fc17482e", "commit_date": "Sat Jan 28 12:43:36 2023 -0500", "commit_message": "fix: pin importlib_metadata<5 on Python 3.7 due to compatibility issue with flake8", "files_name": ["setup.cfg"]}, {"commit_id": "528f78c10dc375e8afd7e5d040fbbc21b9af0d42", "commit_date": "Sat Jan 28 12:36:37 2023 -0500", "commit_message": "chore: drop support for Python 3.6", "files_name": [".github/workflows/main.yml", "tox.ini"]}, {"commit_id": "1b1b02033a84aa6006d4f37557b9b97ae97162ea", "commit_date": "Sat Jan 28 12:33:37 2023 -0500", "commit_message": "fix: lint errors in tests for pytest.raises", "files_name": ["tests/test_utilities.py"]}, {"commit_id": "35f9505442561f39ab350323d1d797b85c3027c6", "commit_date": "Sat Jan 28 12:32:55 2023 -0500", "commit_message": "chore: add support for Python 3.11", "files_name": [".github/workflows/main.yml", "tox.ini"]}, {"commit_id": "7d150fe36daa6fcdbaf0e8dc928c236c54d951cb", "commit_date": "Wed Nov 30 23:55:35 2022 -0500", "commit_message": "Release v5.1.2.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "676bd4d86b847c1d6a5eebbdde52cba0e77e4712", "commit_date": "Wed Nov 30 23:54:44 2022 -0500", "commit_message": "Remove unnecessary type check and conversion for exceptions argument in retry.", "files_name": ["CHANGELOG.rst", "src/pydash/utilities.py"]}, {"commit_id": "111bc97cbe2850af8ce700b3a32092d6f6b7842c", "commit_date": "Fri Sep 23 09:50:49 2022 -0400", "commit_message": "Release v5.1.1.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "bd001f654a46d33fc336f92059cde35780978ba4", "commit_date": "Fri Sep 23 09:50:35 2022 -0400", "commit_message": "Update CHANGELOG.", "files_name": ["CHANGELOG.rst"]}, {"commit_id": "5e1128060d6b7574f428541e3a9ae4788c04c95a", "commit_date": "Fri Sep 23 09:50:01 2022 -0400", "commit_message": "Fix timing assertion issue in test for pydash.delay where it could fail on certain environments.", "files_name": ["tests/test_functions.py"]}, {"commit_id": "56939f139f51a5266c841f94810e4f4550f88d48", "commit_date": "Fri Sep 23 09:26:58 2022 -0400", "commit_message": "Run auto formatter.", "files_name": ["src/pydash/predicates.py", "src/pydash/strings.py"]}, {"commit_id": "96f6e4813b150948f73b6235d4381b2747c72739", "commit_date": "Fri Sep 23 09:26:36 2022 -0400", "commit_message": "Move mocked_sleep fixture to tests/conftest.py and rename to mock_sleep. Rename tests/fixtures.py to helpers.py.", "files_name": ["tests/conftest.py", "tests/helpers.py", "tests/test_collections.py", "tests/test_functions.py", "tests/test_objects.py", "tests/test_predicates.py", "tests/test_utilities.py"]}, {"commit_id": "0daba549d87f16747b5fddda5e82a0e146e7c09e", "commit_date": "Fri Sep 23 09:24:30 2022 -0400", "commit_message": "Specify language in docs/conf.py.", "files_name": ["docs/conf.py"]}, {"commit_id": "422da18a7a58334fd1e390ef2580f33d6d3950d8", "commit_date": "Fri Sep 23 09:24:08 2022 -0400", "commit_message": "Rename invoke task \"test\" to \"ci\" and \"unit\" to \"test\".", "files_name": ["tasks.py", "tox.ini"]}, {"commit_id": "3b2a990bf3e5f6c75aa1b1f61c96b38597d7c595", "commit_date": "Fri Sep 23 09:21:49 2022 -0400", "commit_message": "Replace setup.py with pyproject.toml build. Add support for Python 3.10.", "files_name": [".github/workflows/main.yml", "pyproject.toml", "setup.cfg", "setup.py", "tox.ini"]}, {"commit_id": "278e052e52adf9086e9baec57415b269c8395eef", "commit_date": "Sun May 15 18:03:21 2022 -0400", "commit_message": "Ignore warning from pytest_pylint plugin.", "files_name": ["setup.cfg"]}, {"commit_id": "13b8789afb711582090d49791cd8f0fc5645a374", "commit_date": "Sun May 15 18:03:03 2022 -0400", "commit_message": "Rename loop variable to resolve false-positive flake8-bugbear violation.", "files_name": ["src/pydash/predicates.py"]}, {"commit_id": "42211977d8157a72bf5379ce297b8c57329ea8ff", "commit_date": "Sun May 15 18:02:19 2022 -0400", "commit_message": "Run black with latest version.", "files_name": ["src/pydash/utilities.py", "tests/test_collections.py", "tests/test_functions.py", "tests/test_strings.py"]}, {"commit_id": "24ad0e43b51b367d00447c45baa68c9c03ad1a52", "commit_date": "Sat Oct 2 20:10:25 2021 -0400", "commit_message": "Release v5.1.0.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "ca89cdeb4c57d2443b3db2736924c05c505aa855", "commit_date": "Tue Sep 28 17:49:50 2021 -0400", "commit_message": "Support matches-style callbacks on non-dictionary objects that are compatible with pydash.get().", "files_name": ["CHANGELOG.rst", "src/pydash/helpers.py", "src/pydash/predicates.py", "tests/test_collections.py"]}, {"commit_id": "728bfba426e08de491f2944c3e287480aae23322", "commit_date": "Tue Sep 28 17:44:21 2021 -0400", "commit_message": "Remove unnecessary \"from __future__\" import in docs' doctests.", "files_name": ["docs/chaining.rst"]}, {"commit_id": "f0ac1686ef74de1f2b147be5e85fff6cc60c70cc", "commit_date": "Tue Sep 28 17:43:44 2021 -0400", "commit_message": "Fix typos.", "files_name": ["src/pydash/functions.py", "src/pydash/helpers.py", "src/pydash/numerical.py", "src/pydash/objects.py", "src/pydash/predicates.py", "tests/fixtures.py", "tests/test_arrays.py", "tests/test_functions.py", "tests/test_strings.py", "tests/test_utilities.py"]}, {"commit_id": "fb72d4a4b79a92a0729410ce7c730d20dc5e7313", "commit_date": "Thu Jul 15 21:26:13 2021 -0400", "commit_message": "Add math and unicodedata to pylint's extension-pkg-whitelist list to fix false-positives on Python 3.9 and MacOS.", "files_name": ["pylintrc"]}, {"commit_id": "d1d26658c20258246e54dad536761a12ca279e16", "commit_date": "Thu Jul 15 18:25:07 2021 -0400", "commit_message": "Release v5.0.2.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "7d2aaf65517ea7499cffa615e68a274454c70077", "commit_date": "Thu Jul 15 18:21:30 2021 -0400", "commit_message": "Modify InvalidMethod to inherit from AttributeError instead of Exception to fix compatibility issues with typing.Protocol and runtime_checkable.", "files_name": ["CHANGELOG.rst", "src/pydash/exceptions.py", "tests/test_chaining.py"]}, {"commit_id": "762689a2ed1b87332ba0112624059ba16dfd2cd9", "commit_date": "Sun Jun 27 14:18:10 2021 -0400", "commit_message": "Release v5.0.1.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "033e41d4ccace414bd7d2c451c44264119ef1d24", "commit_date": "Sun Jun 27 14:17:55 2021 -0400", "commit_message": "Update changelog.", "files_name": ["CHANGELOG.rst"]}, {"commit_id": "02339b347d032d1715188ccdc612e01db968a9aa", "commit_date": "Sun Jun 27 14:14:22 2021 -0400", "commit_message": "Merge pull request #164 from weineel/develop", "files_name": ["a43ea36e46d24000f06eddd75b3fedbe6c9dec28 - Sat Jun 26 17:06:20 2021 +0800 : Iteratee is lost when _merge_with is recursing (#163).", "AUTHORS.rst", "src/pydash/objects.py", "tests/test_objects.py"]}, {"commit_id": "fa61732c01b39cec0de66f958cef27e7f31bcac2", "commit_date": "Mon Mar 29 18:20:53 2021 -0400", "commit_message": "Replace \"-\" with \"_\" in setup.cfg variable names.", "files_name": ["setup.cfg"]}, {"commit_id": "56b01ec71a059c0e13a8f6730acd27e4d31e7fcc", "commit_date": "Mon Mar 29 18:10:37 2021 -0400", "commit_message": "Release v5.0.0.", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "0c998f42df2c0f2cb3fd88a234b9248c1e30c7e8", "commit_date": "Tue Mar 9 21:30:32 2021 -0500", "commit_message": "Ensure latest setuptools is used in Github Actions.", "files_name": [".github/workflows/main.yml"]}, {"commit_id": "b71f1e2dca6bdfa10486785af66f166e249708e4", "commit_date": "Tue Mar 9 09:48:32 2021 -0500", "commit_message": "Remove from __future__ imports.", "files_name": ["src/pydash/utilities.py"]}, {"commit_id": "5a87ef4a83a086fdc6a4fb21decb0a575d1a72aa", "commit_date": "Tue Mar 9 09:48:18 2021 -0500", "commit_message": "Move package __version__ setting from setup.cfg to inside package to get rid of dependency on pkg_resources.", "files_name": ["pyproject.toml", "setup.cfg", "src/pydash/__init__.py", "src/pydash/__version__.py"]}, {"commit_id": "b2d205a7186ba26ef96d12197f7bb8bb8a360615", "commit_date": "Wed Mar 3 15:30:53 2021 -0500", "commit_message": "Alphabetize dev dependencies in setup.cfg.", "files_name": ["setup.cfg"]}, {"commit_id": "661a7ac96d6d4f3d1fa8d26075f79a5cf6ca3137", "commit_date": "Wed Mar 3 15:30:28 2021 -0500", "commit_message": "Allow custom tox commands to be run in an environment.", "files_name": ["tox.ini"]}, {"commit_id": "f53d20013513edf844396197bea2f2c94ed75599", "commit_date": "Wed Feb 3 16:53:07 2021 -0500", "commit_message": "Use typing.Pattern instead of re.Pattern for compatibility with Python 3.6.", "files_name": ["src/pydash/strings.py"]}, {"commit_id": "13926f317a1625d62f643a317546a0bfa0118f2e", "commit_date": "Mon Feb 1 17:38:15 2021 -0500", "commit_message": "Remove unused argument in helper function.", "files_name": ["src/pydash/objects.py"]}, {"commit_id": "8401993518b5fcfe30b6f3ff7cb208a7ebb7e4bf", "commit_date": "Mon Feb 1 17:37:50 2021 -0500", "commit_message": "Fix missing arguments in docstrings.", "files_name": ["src/pydash/collections.py", "src/pydash/helpers.py", "src/pydash/objects.py", "src/pydash/strings.py"]}, {"commit_id": "633aaf9dea92b12ae574a2d733c58c2957f19e4b", "commit_date": "Mon Feb 1 17:16:58 2021 -0500", "commit_message": "Use f-strings instead of str.format.", "files_name": ["setup.cfg", "src/pydash/strings.py", "src/pydash/utilities.py", "tests/test_arrays.py", "tests/test_functions.py"]}, {"commit_id": "93f917360aaafeed9c5f9c738e6fdf4f7dddc72a", "commit_date": "Wed Jan 6 12:52:02 2021 -0500", "commit_message": "Update CHANGELOG.", "files_name": ["CHANGELOG.rst"]}, {"commit_id": "3a8c3b0a941b4300f1afdcccec8ac96a91454bc4", "commit_date": "Wed Jan 6 12:51:42 2021 -0500", "commit_message": "Improve and optimize regular expression definitions and usage in strings module.", "files_name": ["src/pydash/strings.py", "tests/test_strings.py"]}, {"commit_id": "d6fe70c3cbf047c1d128456aabf94160a7a25ccd", "commit_date": "Wed Jan 6 10:04:14 2021 -0500", "commit_message": "Remove Python 2.7 support.", "files_name": ["docs/conf.py", "docs/installation.rst", "pyproject.toml", "setup.cfg", "setup.py", "src/pydash/__init__.py", "src/pydash/__version__.py", "src/pydash/_compat.py", "src/pydash/arrays.py", "src/pydash/chaining.py", "src/pydash/collections.py"]}], "windows_after": [{"commit_id": "f410919df4eec3e6e36314c9b27d441c280a7cf2", "commit_date": "Sat Jan 28 20:43:39 2023 -0500", "commit_message": "chore: update changelog", "files_name": ["CHANGELOG.rst"]}, {"commit_id": "81d58d6d028e57a252507a7a99179b1150756f7e", "commit_date": "Sat Jan 28 21:04:03 2023 -0500", "commit_message": "release: v6.0.0", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "a40d141f739a868994e6b9f47cb1a43812bbd520", "commit_date": "Tue Feb 7 08:58:40 2023 -0500", "commit_message": "fixed typo in docstring", "files_name": ["src/pydash/objects.py"]}, {"commit_id": "869523a67e013853fd77443700001e28d27fd608", "commit_date": "Sat Feb 11 13:32:27 2023 -0500", "commit_message": "Merge pull request #178 from NathanRSmith/patch-1", "files_name": ["030403aae92989aa2d6b3e9d16a56c64dd0d5761 - Mon Feb 20 11:01:31 2023 -0500 : fix: skip restricted key check when key is not a string", "src/pydash/helpers.py", "tests/test_objects.py"]}, {"commit_id": "65ef98b081562320b95dbbb76f43eb108458ba54", "commit_date": "Mon Feb 20 11:05:58 2023 -0500", "commit_message": "chore: update changelog", "files_name": ["CHANGELOG.rst"]}, {"commit_id": "c1277f191e1f6e77ba74473e45fba2f4714d6819", "commit_date": "Mon Feb 20 11:06:15 2023 -0500", "commit_message": "release: v6.0.1", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "2015f0a4bcdbc3a5b27652e38fe97b3ee13ac15f", "commit_date": "Thu Feb 23 21:33:21 2023 -0500", "commit_message": "fix: only prevent access to object paths containing __globals__ and __builtins__ for non-dict/list objects", "files_name": ["CHANGELOG.rst", "src/pydash/helpers.py", "tests/test_objects.py"]}, {"commit_id": "f2740b55e59defb87ed6f1faec48b1c3b15565e3", "commit_date": "Thu Feb 23 21:55:29 2023 -0500", "commit_message": "release: v6.0.2", "files_name": ["CHANGELOG.rst", "src/pydash/__init__.py"]}, {"commit_id": "6928a766b259ed2e4b763976fb01db6903631d13", "commit_date": "Thu Mar 2 00:09:13 2023 +0200", "commit_message": "Add support for negative indexes", "files_name": ["src/pydash/utilities.py", "tests/test_objects.py", "tests/test_utilities.py"]}, {"commit_id": "8b2341492da4c015fae9ead17ddfffce9f0f9af3", "commit_date": "Tue Mar 7 03:15:19 2023 +0100", "commit_message": "Typehints (#177)", "files_name": ["DEVGUIDE.rst", "MANIFEST.in", "scripts/mypy_doctests_generator.py", "setup.cfg", "src/pydash/arrays.py", "src/pydash/collections.py", "src/pydash/functions.py", "src/pydash/helpers.py", "src/pydash/numerical.py", "src/pydash/objects.py", "src/pydash/predicates.py", "src/pydash/py.typed", "src/pydash/strings.py", "src/pydash/types.py", "src/pydash/utilities.py", "tasks.py", "tests/pytest_mypy_testing/__init__.py", "tests/pytest_mypy_testing/test_arrays.py", "tests/pytest_mypy_testing/test_collections.py", "tests/pytest_mypy_testing/test_functions.py", "tests/pytest_mypy_testing/test_numerical.py", "tests/pytest_mypy_testing/test_objects.py", "tests/pytest_mypy_testing/test_predicates.py", "tests/pytest_mypy_testing/test_strings.py", "tests/pytest_mypy_testing/test_utilities.py", "tests/test_objects.py"]}, {"commit_id": "a0483e4663c2ad43aa78628f82bd08de267d2b48", "commit_date": "Mon Mar 6 21:17:35 2023 -0500", "commit_message": "Merge pull request #181 from bl4ckst0ne/feature/negative-indexes", "files_name": ["b57ede9f24f71ff3b76f3fd5b6c17be2ba419c28 - Thu Mar 16 23:58:04 2023 +0100 : Better get typing for basic list usage", "src/pydash/objects.py", "tests/pytest_mypy_testing/test_objects.py"]}, {"commit_id": "e3d04c580cb86e6d189c8e1c587fe59eccf33c96", "commit_date": "Fri Mar 17 09:26:47 2023 -0400", "commit_message": "Merge pull request #183 from DeviousStoat/get-list", "files_name": ["61c8f42518b23f47583422499e83f9761cd75f5d - Mon Jan 30 06:33:23 2023 +0100 : Type chaining interface", "scripts/chaining_type_generator.py", "setup.cfg", "src/pydash/chaining/__init__.py", "src/pydash/chaining/all_funcs.py", "src/pydash/chaining/all_funcs.pyi", "src/pydash/chaining/chaining.py", "src/pydash/exceptions.py", "src/pydash/utilities.py", "tests/pytest_mypy_testing/test_chaining.py", "tests/test_chaining.py"]}, {"commit_id": "429121ad476cd0e8128c28861a86764137491642", "commit_date": "Tue Mar 7 04:43:57 2023 +0100", "commit_message": "Adapt to new type changes", "files_name": ["scripts/chaining_type_generator.py", "src/pydash/chaining/all_funcs.py", "src/pydash/chaining/all_funcs.pyi", "src/pydash/chaining/chaining.py", "tasks.py"]}, {"commit_id": "d0e8fb750213df4a5a0308c21d4a01f4d6ee8beb", "commit_date": "Tue Mar 7 04:48:18 2023 +0100", "commit_message": "Add task", "files_name": ["tasks.py"]}, {"commit_id": "20a1c83d1bb2d3018426955a6cd6d39d5838331e", "commit_date": "Thu Mar 16 00:07:36 2023 +0100", "commit_message": "Add missing imports, run mypy, misc type fixes", "files_name": ["scripts/chaining_type_generator.py", "setup.cfg", "src/pydash/chaining/all_funcs.pyi", "src/pydash/strings.py", "tasks.py"]}, {"commit_id": "8e93f964536ee0ef15c3f58daa60e2e6d85591be", "commit_date": "Thu Mar 16 00:14:16 2023 +0100", "commit_message": "Remove imports argument", "files_name": ["scripts/chaining_type_generator.py"]}, {"commit_id": "0c74c9466122b9672cd384b3f3fc2aa9a2b18eea", "commit_date": "Thu Mar 16 00:17:41 2023 +0100", "commit_message": "Use required named argument instead of positional", "files_name": ["scripts/chaining_type_generator.py", "tasks.py"]}, {"commit_id": "915f620a72c48bc4e99b67ba68cc37e8947c8583", "commit_date": "Thu Mar 16 01:12:12 2023 +0100", "commit_message": "Add lint task check update needed", "files_name": ["scripts/chaining_type_generator.py", "src/pydash/chaining/all_funcs.pyi", "tasks.py"]}, {"commit_id": "2e34c32f1c4c532c2df9f127b8b4dceadfbeeb94", "commit_date": "Thu Mar 16 01:35:44 2023 +0100", "commit_message": "Fix generator script support python < 3.9", "files_name": ["scripts/chaining_type_generator.py", "tasks.py"]}, {"commit_id": "fd3155a932cdfb455959315f238ffe62dcb5b760", "commit_date": "Fri Mar 17 16:25:19 2023 +0100", "commit_message": "Rebase and update with new get types", "files_name": ["src/pydash/chaining/all_funcs.pyi"]}, {"commit_id": "a6dfe82736c6b44aded9d9dfc2317b7ca64303ff", "commit_date": "Fri Mar 17 16:29:54 2023 +0100", "commit_message": "Type tasks module", "files_name": ["tasks.py"]}, {"commit_id": "94691cf0567dd15b393b4467f7e8571b29abebca", "commit_date": "Sat Mar 18 11:00:48 2023 -0400", "commit_message": "Merge pull request #182 from DeviousStoat/type-chaining", "files_name": ["d438c30c969c5fa5251b65b2a7f02def844d6a57 - Sat Mar 18 17:54:04 2023 +0100 : Add objects function type support on any objects", "src/pydash/chaining/all_funcs.pyi", "src/pydash/objects.py", "tests/pytest_mypy_testing/test_objects.py"]}, {"commit_id": "5e283e578434999a64d35b8ec196fc7be24ce4dc", "commit_date": "Sat Mar 18 18:18:19 2023 -0400", "commit_message": "Merge pull request #185 from DeviousStoat/objects-fixes", "files_name": ["7acfce36afb455ce8c9959d23ef7e9aad5b0af73 - Sat Mar 18 18:13:04 2023 +0100 : Add sphinx typehints dependency", "setup.cfg"]}, {"commit_id": "c2242be1026fa4a66b260e6a7d9533f764e0b21a", "commit_date": "Sat Mar 18 18:38:55 2023 +0100", "commit_message": "Remove docstring typehints", "files_name": ["src/pydash/arrays.py", "src/pydash/chaining/all_funcs.py", "src/pydash/chaining/chaining.py", "src/pydash/collections.py", "src/pydash/functions.py", "src/pydash/numerical.py", "src/pydash/objects.py", "src/pydash/predicates.py", "src/pydash/strings.py", "src/pydash/utilities.py"]}, {"commit_id": "86d645464f2820e26daa49897d99d158c0c31689", "commit_date": "Sun Mar 19 00:17:09 2023 +0100", "commit_message": "Remove types in helpers", "files_name": ["src/pydash/helpers.py"]}, {"commit_id": "6df02ec020c9fda79c0bddf09fc11ea6a737da44", "commit_date": "Sat Mar 18 20:33:36 2023 -0400", "commit_message": "Merge pull request #186 from DeviousStoat/typing-docs", "files_name": ["0e0b4c04961d31add3be6e36a1d2faad3694eed6 - Mon Mar 20 11:01:21 2023 -0400 : chore: use pypi version of pytest-mypy-testing", "setup.cfg"]}, {"commit_id": "e02179b93cc5ccbda6e2b9ee8d98018ab616e617", "commit_date": "Mon Mar 20 11:02:05 2023 -0400", "commit_message": "chore: add mypy to \"inv lint\" and exclude mypy error summary from output", "files_name": ["tasks.py"]}, {"commit_id": "1dc7657ec9b8fb69227982078a959dbe8f6342ec", "commit_date": "Sun Mar 19 01:49:24 2023 +0100", "commit_message": "update to_dict types", "files_name": ["src/pydash/chaining/all_funcs.pyi", "src/pydash/objects.py", "tests/pytest_mypy_testing/test_objects.py", "tests/test_objects.py"]}, {"commit_id": "c53e593ee01ed4f8df3ad69a73b0f8b7e9909101", "commit_date": "Sat Apr 1 19:31:10 2023 +0200", "commit_message": "Remove dict() try and fix tests", "files_name": ["src/pydash/chaining/all_funcs.pyi", "src/pydash/objects.py", "tests/pytest_mypy_testing/test_objects.py", "tests/test_objects.py"]}, {"commit_id": "92ceba4e9a0b95501e33f4ada03066cb5f7411c4", "commit_date": "Sat Apr 1 19:40:17 2023 +0200", "commit_message": "Make mypy tests optional", "files_name": ["tasks.py"]}, {"commit_id": "5d2a9521eaacc3056707f51a9e44a74cf2d03723", "commit_date": "Sat Apr 1 19:13:05 2023 -0400", "commit_message": "Merge pull request #188 from DeviousStoat/fix-to-dict", "files_name": ["d5b776da7495349757a503fc5a1a1f40c8e9668f - Sat Apr 1 19:15:13 2023 -0400 : Merge pull request #191 from DeviousStoat/mypy-pytest-optional", "f2ce78b35bcd6078a89aa55ba6360e33e3c76240 - Wed Apr 5 21:14:35 2023 -0400 : fix: remove single quotes from slugify output", "src/pydash/strings.py", "tests/test_strings.py"]}, {"commit_id": "303e13c611742064a66022591d484587b2fb3fc1", "commit_date": "Wed Apr 5 22:07:50 2023 -0400", "commit_message": "fix: use triple double-quotes in the base module template of chaining types instead of single-quotes and remove unused import", "files_name": ["scripts/chaining_type_generator.py"]}, {"commit_id": "642f02a040d281dce390dae7e31e988e290ef98d", "commit_date": "Thu Apr 6 16:16:38 2023 -0400", "commit_message": "chore: call task decorator consistently", "files_name": ["tasks.py"]}, {"commit_id": "db4b252d197eb23af41e8b13f139616d7d96e8c0", "commit_date": "Tue Apr 11 22:02:25 2023 -0400", "commit_message": "chore: fix typos and grammar", "files_name": ["src/pydash/arrays.py", "src/pydash/collections.py", "src/pydash/functions.py", "src/pydash/helpers.py", "src/pydash/numerical.py", "src/pydash/objects.py", "src/pydash/strings.py", "src/pydash/utilities.py"]}, {"commit_id": "94f4b0dcc24fcf5e30f03a6d1da1939e2eb0bb09", "commit_date": "Tue Apr 11 22:12:31 2023 -0400", "commit_message": "feat: use Iterable/Sequence typing in more array functions", "files_name": ["src/pydash/arrays.py", "src/pydash/chaining/all_funcs.pyi", "tests/pytest_mypy_testing/test_arrays.py"]}, {"commit_id": "17ad19e15f48b47a00ba394b235d8cad501b04a8", "commit_date": "Tue Apr 11 22:12:53 2023 -0400", "commit_message": "chore: removing trailing spaces in test pytest_mypy_testing files", "files_name": []}], "parents": [{"commit_id_before": "1947d2ad210129d1c2925f0c8837323d7fd420db", "url_before": "https://api.github.com/repos/dgilland/pydash/commits/1947d2ad210129d1c2925f0c8837323d7fd420db", "html_url_before": "https://github.com/dgilland/pydash/commit/1947d2ad210129d1c2925f0c8837323d7fd420db"}], "details": [{"raw_url": "https://github.com/dgilland/pydash/raw/6ff0831ad285fff937cafd2a853f20cc9ae92021/src%2Fpydash%2Fhelpers.py", "code": "\"\"\"Generic utility methods not part of main API.\"\"\"\n\nimport builtins\nfrom collections.abc import Hashable, Iterable, Mapping, Sequence\nfrom decimal import Decimal\nfrom functools import wraps\nimport inspect\nfrom inspect import getfullargspec\nimport warnings\n\nimport pydash as pyd\n\n\n#: Singleton object that differentiates between an explicit ``None`` value and an unset value.\nUNSET = object()\n\n#: Tuple of number types.\nNUMBER_TYPES = (int, float, Decimal)\n\n#: Dictionary of builtins with keys as the builtin function and values as the string name.\nBUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}\n\n\ndef callit(iteratee, *args, **kwargs):\n    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling\n    it.\"\"\"\n    maxargs = len(args)\n    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)\n    argstop = min([maxargs, argcount])\n\n    return iteratee(*args[:argstop])\n\n\ndef getargcount(iteratee, maxargs):\n    \"\"\"Return argument count of iteratee function.\"\"\"\n    if hasattr(iteratee, \"_argcount\"):\n        # Optimization feature where argcount of iteratee is known and properly\n        # set by initiator.\n        return iteratee._argcount\n\n    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):\n        # Only pass single argument to type iteratees or builtins.\n        argcount = 1\n    else:\n        argcount = 1\n\n        try:\n            argcount = _getargcount(iteratee, maxargs)\n        except TypeError:  # pragma: no cover\n            pass\n\n    return argcount\n\n\ndef _getargcount(iteratee, maxargs):\n    argcount = None\n\n    try:\n        # PY2: inspect.signature was added in Python 3.\n        # Try to use inspect.signature when possible since it works better for our purpose of\n        # getting the iteratee argcount since it takes into account the \"self\" argument in callable\n        # classes.\n        sig = inspect.signature(iteratee)\n    except (TypeError, ValueError, AttributeError):\n        pass\n    else:  # pragma: no cover\n        if not any(\n            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()\n        ):\n            argcount = len(sig.parameters)\n\n    if argcount is None:\n        argspec = getfullargspec(iteratee)\n        if argspec and not argspec.varargs:  # pragma: no cover\n            # Use inspected arg count.\n            argcount = len(argspec.args)\n\n    if argcount is None:\n        # Assume all args are handleable.\n        argcount = maxargs\n\n    return argcount\n\n\ndef iteriteratee(obj, iteratee=None, reverse=False):\n    \"\"\"Return iterative iteratee based on collection type.\"\"\"\n    if iteratee is None:\n        cbk = pyd.identity\n        argcount = 1\n    else:\n        cbk = pyd.iteratee(iteratee)\n        argcount = getargcount(cbk, maxargs=3)\n\n    items = iterator(obj)\n\n    if reverse:\n        items = reversed(tuple(items))\n\n    for key, item in items:\n        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj\n\n\ndef iterator(obj):\n    \"\"\"Return iterative based on object type.\"\"\"\n    if isinstance(obj, Mapping):\n        return obj.items()\n    elif hasattr(obj, \"iteritems\"):\n        return obj.iteritems()  # noqa: B301\n    elif hasattr(obj, \"items\"):\n        return iter(obj.items())\n    elif isinstance(obj, Iterable):\n        return enumerate(obj)\n    else:\n        return getattr(obj, \"__dict__\", {}).items()\n\n\ndef base_get(obj, key, default=UNSET):\n    \"\"\"\n    Safely get an item by `key` from a sequence or mapping object when `default` provided.\n\n    Args:\n        obj (list|dict): Sequence or mapping to retrieve item from.\n        key (mixed): Key or index identifying which item to retrieve.\n        default (mixed, optional): Default value to return if `key` not found in `obj`.\n\n    Returns:\n        mixed: `obj[key]`, `obj.key`, or `default`.\n\n    Raises:\n        KeyError: If `obj` is missing key, index, or attribute and no default value provided.\n    \"\"\"\n    if isinstance(obj, dict):\n        value = _base_get_dict(obj, key, default=default)\n    elif not isinstance(obj, (Mapping, Sequence)) or (\n        isinstance(obj, tuple) and hasattr(obj, \"_fields\")\n    ):\n        # Don't use getattr for dict/list objects since we don't want class methods/attributes\n        # returned for them but do allow getattr for namedtuple.\n        value = _base_get_object(obj, key, default=default)\n    else:\n        value = _base_get_item(obj, key, default=default)\n\n    if value is UNSET:\n        # Raise if there's no default provided.\n        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')\n\n    return value\n\n\ndef _base_get_dict(obj, key, default=UNSET):\n    value = obj.get(key, UNSET)\n    if value is UNSET:\n        value = default\n        if not isinstance(key, int):\n            # Try integer key fallback.\n            try:\n                value = obj.get(int(key), default)\n            except Exception:\n                pass\n    return value\n\n\ndef _base_get_item(obj, key, default=UNSET):\n    try:\n        return obj[key]\n    except Exception:\n        pass\n\n    if not isinstance(key, int):\n        try:\n            return obj[int(key)]\n        except Exception:\n            pass\n\n    return default\n\n\ndef _base_get_object(obj, key, default=UNSET):\n    value = _base_get_item(obj, key, default=UNSET)\n    if value is UNSET:\n        _raise_if_restricted_key(key)\n        value = default\n        try:\n            value = getattr(obj, key)\n        except Exception:\n            pass\n    return value\n\n\ndef _raise_if_restricted_key(key):\n    # Prevent access to dunder-methods since this could expose access to globals through leaky\n    # attributes such as obj.__init__.__globals__.\n    if len(key) > 4 and key.isascii() and key.startswith(\"__\") and key.endswith(\"__\"):\n        raise KeyError(f\"access to restricted key {key!r} is not allowed\")\n\n\ndef base_set(obj, key, value, allow_override=True):\n    \"\"\"\n    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available\n    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.\n\n    Args:\n        obj (list|dict): Object to assign value to.\n        key (mixed): Key or index to assign to.\n        value (mixed): Value to assign.\n        allow_override (bool): Whether to allow overriding a previously set key.\n    \"\"\"\n    if isinstance(obj, dict):\n        if allow_override or key not in obj:\n            obj[key] = value\n    elif isinstance(obj, list):\n        key = int(key)\n\n        if key < len(obj):\n            if allow_override:\n                obj[key] = value\n        else:\n            if key > len(obj):\n                # Pad list object with None values up to the index key so we can append the value\n                # into the key index.\n                obj[:] = (obj + [None] * key)[:key]\n            obj.append(value)\n    elif (allow_override or not hasattr(obj, key)) and obj is not None:\n        _raise_if_restricted_key(key)\n        setattr(obj, key, value)\n\n    return obj\n\n\ndef cmp(a, b):  # pragma: no cover\n    \"\"\"\n    Replacement for built-in function ``cmp`` that was removed in Python 3.\n\n    Note: Mainly used for comparison during sorting.\n    \"\"\"\n    if a is None and b is None:\n        return 0\n    elif a is None:\n        return -1\n    elif b is None:\n        return 1\n    return (a > b) - (a < b)\n\n\ndef parse_iteratee(iteratee_keyword, *args, **kwargs):\n    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last\n    positional argument in `args`.\"\"\"\n    iteratee = kwargs.get(iteratee_keyword)\n    last_arg = args[-1]\n\n    if iteratee is None and (\n        callable(last_arg)\n        or isinstance(last_arg, str)\n        or isinstance(last_arg, dict)\n        or last_arg is None\n    ):\n        iteratee = last_arg\n        args = args[:-1]\n\n    return iteratee, args\n\n\nclass iterator_with_default(object):\n    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"\n\n    def __init__(self, collection, default):\n        self.iter = iter(collection)\n        self.default = default\n\n    def __iter__(self):\n        return self\n\n    def next_default(self):\n        ret = self.default\n        self.default = UNSET\n        return ret\n\n    def __next__(self):\n        ret = next(self.iter, self.next_default())\n        if ret is UNSET:\n            raise StopIteration\n        return ret\n\n    next = __next__\n\n\ndef deprecated(func):  # pragma: no cover\n    \"\"\"\n    This is a decorator which can be used to mark functions as deprecated.\n\n    It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"Call to deprecated function {func.__name__}.\",\n            category=DeprecationWarning,\n            stacklevel=3,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n", "code_before": "\"\"\"Generic utility methods not part of main API.\"\"\"\n\nimport builtins\nfrom collections.abc import Hashable, Iterable, Mapping, Sequence\nfrom decimal import Decimal\nfrom functools import wraps\nimport inspect\nfrom inspect import getfullargspec\nimport warnings\n\nimport pydash as pyd\n\n\n#: Singleton object that differentiates between an explicit ``None`` value and an unset value.\nUNSET = object()\n\n#: Tuple of number types.\nNUMBER_TYPES = (int, float, Decimal)\n\n#: Dictionary of builtins with keys as the builtin function and values as the string name.\nBUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}\n\n\ndef callit(iteratee, *args, **kwargs):\n    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling\n    it.\"\"\"\n    maxargs = len(args)\n    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)\n    argstop = min([maxargs, argcount])\n\n    return iteratee(*args[:argstop])\n\n\ndef getargcount(iteratee, maxargs):\n    \"\"\"Return argument count of iteratee function.\"\"\"\n    if hasattr(iteratee, \"_argcount\"):\n        # Optimization feature where argcount of iteratee is known and properly\n        # set by initiator.\n        return iteratee._argcount\n\n    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):\n        # Only pass single argument to type iteratees or builtins.\n        argcount = 1\n    else:\n        argcount = 1\n\n        try:\n            argcount = _getargcount(iteratee, maxargs)\n        except TypeError:  # pragma: no cover\n            pass\n\n    return argcount\n\n\ndef _getargcount(iteratee, maxargs):\n    argcount = None\n\n    try:\n        # PY2: inspect.signature was added in Python 3.\n        # Try to use inspect.signature when possible since it works better for our purpose of\n        # getting the iteratee argcount since it takes into account the \"self\" argument in callable\n        # classes.\n        sig = inspect.signature(iteratee)\n    except (TypeError, ValueError, AttributeError):\n        pass\n    else:  # pragma: no cover\n        if not any(\n            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()\n        ):\n            argcount = len(sig.parameters)\n\n    if argcount is None:\n        argspec = getfullargspec(iteratee)\n        if argspec and not argspec.varargs:  # pragma: no cover\n            # Use inspected arg count.\n            argcount = len(argspec.args)\n\n    if argcount is None:\n        # Assume all args are handleable.\n        argcount = maxargs\n\n    return argcount\n\n\ndef iteriteratee(obj, iteratee=None, reverse=False):\n    \"\"\"Return iterative iteratee based on collection type.\"\"\"\n    if iteratee is None:\n        cbk = pyd.identity\n        argcount = 1\n    else:\n        cbk = pyd.iteratee(iteratee)\n        argcount = getargcount(cbk, maxargs=3)\n\n    items = iterator(obj)\n\n    if reverse:\n        items = reversed(tuple(items))\n\n    for key, item in items:\n        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj\n\n\ndef iterator(obj):\n    \"\"\"Return iterative based on object type.\"\"\"\n    if isinstance(obj, Mapping):\n        return obj.items()\n    elif hasattr(obj, \"iteritems\"):\n        return obj.iteritems()  # noqa: B301\n    elif hasattr(obj, \"items\"):\n        return iter(obj.items())\n    elif isinstance(obj, Iterable):\n        return enumerate(obj)\n    else:\n        return getattr(obj, \"__dict__\", {}).items()\n\n\ndef base_get(obj, key, default=UNSET):\n    \"\"\"\n    Safely get an item by `key` from a sequence or mapping object when `default` provided.\n\n    Args:\n        obj (list|dict): Sequence or mapping to retrieve item from.\n        key (mixed): Key or index identifying which item to retrieve.\n        default (mixed, optional): Default value to return if `key` not found in `obj`.\n\n    Returns:\n        mixed: `obj[key]`, `obj.key`, or `default`.\n\n    Raises:\n        KeyError: If `obj` is missing key, index, or attribute and no default value provided.\n    \"\"\"\n    if isinstance(obj, dict):\n        value = _base_get_dict(obj, key, default=default)\n    elif not isinstance(obj, (Mapping, Sequence)) or (\n        isinstance(obj, tuple) and hasattr(obj, \"_fields\")\n    ):\n        # Don't use getattr for dict/list objects since we don't want class methods/attributes\n        # returned for them but do allow getattr for namedtuple.\n        value = _base_get_object(obj, key, default=default)\n    else:\n        value = _base_get_item(obj, key, default=default)\n\n    if value is UNSET:\n        # Raise if there's no default provided.\n        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')\n\n    return value\n\n\ndef _base_get_dict(obj, key, default=UNSET):\n    value = obj.get(key, UNSET)\n    if value is UNSET:\n        value = default\n        if not isinstance(key, int):\n            # Try integer key fallback.\n            try:\n                value = obj.get(int(key), default)\n            except Exception:\n                pass\n    return value\n\n\ndef _base_get_item(obj, key, default=UNSET):\n    try:\n        return obj[key]\n    except Exception:\n        pass\n\n    if not isinstance(key, int):\n        try:\n            return obj[int(key)]\n        except Exception:\n            pass\n\n    return default\n\n\ndef _base_get_object(obj, key, default=UNSET):\n    value = _base_get_item(obj, key, default=UNSET)\n    if value is UNSET:\n        value = default\n        try:\n            value = getattr(obj, key)\n        except Exception:\n            pass\n    return value\n\n\ndef base_set(obj, key, value, allow_override=True):\n    \"\"\"\n    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available\n    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.\n\n    Args:\n        obj (list|dict): Object to assign value to.\n        key (mixed): Key or index to assign to.\n        value (mixed): Value to assign.\n        allow_override (bool): Whether to allow overriding a previously set key.\n    \"\"\"\n    if isinstance(obj, dict):\n        if allow_override or key not in obj:\n            obj[key] = value\n    elif isinstance(obj, list):\n        key = int(key)\n\n        if key < len(obj):\n            if allow_override:\n                obj[key] = value\n        else:\n            if key > len(obj):\n                # Pad list object with None values up to the index key so we can append the value\n                # into the key index.\n                obj[:] = (obj + [None] * key)[:key]\n            obj.append(value)\n    elif (allow_override or not hasattr(obj, key)) and obj is not None:\n        setattr(obj, key, value)\n\n    return obj\n\n\ndef cmp(a, b):  # pragma: no cover\n    \"\"\"\n    Replacement for built-in function ``cmp`` that was removed in Python 3.\n\n    Note: Mainly used for comparison during sorting.\n    \"\"\"\n    if a is None and b is None:\n        return 0\n    elif a is None:\n        return -1\n    elif b is None:\n        return 1\n    return (a > b) - (a < b)\n\n\ndef parse_iteratee(iteratee_keyword, *args, **kwargs):\n    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last\n    positional argument in `args`.\"\"\"\n    iteratee = kwargs.get(iteratee_keyword)\n    last_arg = args[-1]\n\n    if iteratee is None and (\n        callable(last_arg)\n        or isinstance(last_arg, str)\n        or isinstance(last_arg, dict)\n        or last_arg is None\n    ):\n        iteratee = last_arg\n        args = args[:-1]\n\n    return iteratee, args\n\n\nclass iterator_with_default(object):\n    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"\n\n    def __init__(self, collection, default):\n        self.iter = iter(collection)\n        self.default = default\n\n    def __iter__(self):\n        return self\n\n    def next_default(self):\n        ret = self.default\n        self.default = UNSET\n        return ret\n\n    def __next__(self):\n        ret = next(self.iter, self.next_default())\n        if ret is UNSET:\n            raise StopIteration\n        return ret\n\n    next = __next__\n\n\ndef deprecated(func):  # pragma: no cover\n    \"\"\"\n    This is a decorator which can be used to mark functions as deprecated.\n\n    It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"Call to deprecated function {func.__name__}.\",\n            category=DeprecationWarning,\n            stacklevel=3,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n", "patch": "@@ -178,6 +178,7 @@ def _base_get_item(obj, key, default=UNSET):\n def _base_get_object(obj, key, default=UNSET):\n     value = _base_get_item(obj, key, default=UNSET)\n     if value is UNSET:\n+        _raise_if_restricted_key(key)\n         value = default\n         try:\n             value = getattr(obj, key)\n@@ -186,6 +187,13 @@ def _base_get_object(obj, key, default=UNSET):\n     return value\n \n \n+def _raise_if_restricted_key(key):\n+    # Prevent access to dunder-methods since this could expose access to globals through leaky\n+    # attributes such as obj.__init__.__globals__.\n+    if len(key) > 4 and key.isascii() and key.startswith(\"__\") and key.endswith(\"__\"):\n+        raise KeyError(f\"access to restricted key {key!r} is not allowed\")\n+\n+\n def base_set(obj, key, value, allow_override=True):\n     \"\"\"\n     Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available\n@@ -213,6 +221,7 @@ def base_set(obj, key, value, allow_override=True):\n                 obj[:] = (obj + [None] * key)[:key]\n             obj.append(value)\n     elif (allow_override or not hasattr(obj, key)) and obj is not None:\n+        _raise_if_restricted_key(key)\n         setattr(obj, key, value)\n \n     return obj", "file_path": "files/2023_9/62", "file_language": "py", "file_name": "src/pydash/helpers.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/dgilland/pydash/raw/6ff0831ad285fff937cafd2a853f20cc9ae92021/tests%2Ftest_objects.py", "code": "from argparse import Namespace\nfrom collections import defaultdict, namedtuple\nimport datetime as dt\n\nimport pytest\n\nimport pydash as _\n\nfrom . import helpers\n\n\nparametrize = pytest.mark.parametrize\n\ntoday = dt.date.today()\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"employer\": \"slate\"}), {\"name\": \"fred\", \"employer\": \"slate\"}),\n        (\n            ({\"name\": \"fred\"}, {\"employer\": \"slate\"}, {\"employer\": \"medium\"}),\n            {\"name\": \"fred\", \"employer\": \"medium\"},\n        ),\n    ],\n)\ndef test_assign(case, expected):\n    assert _.assign(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"age\": 26}, lambda obj, src: src + 1), {\"name\": \"fred\", \"age\": 27}),\n    ],\n)\ndef test_assign_with(case, expected):\n    assert _.assign_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\", \"greet\": lambda: \"Hello, world!\"},), [\"greet\"]),\n        (([\"fred\", lambda: \"Hello, world!\"],), [1]),\n    ],\n)\ndef test_callables(case, expected):\n    assert _.callables(*case) == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone(case):\n    result = _.clone(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 3}},\n        ),\n    ],\n)\ndef test_clone_with(case, iteratee, expected):\n    result = _.clone_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone_deep(case):\n    result = _.clone_deep(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is not case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 5}},\n        ),\n        ([\"a\"], lambda a: None, [\"a\"]),\n        (\"a\", lambda a: None, \"a\"),\n    ],\n)\ndef test_clone_deep_with(case, iteratee, expected):\n    result = _.clone_deep_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"barney\"}, {\"name\": \"fred\", \"employer\": \"slate\"}),\n            {\"name\": \"barney\", \"employer\": \"slate\"},\n        ),\n    ],\n)\ndef test_defaults(case, expected):\n    assert _.defaults(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"user\": {\"name\": \"barney\"}}, {\"user\": {\"name\": \"fred\", \"age\": 36}}),\n            {\"user\": {\"name\": \"barney\", \"age\": 36}},\n        ),\n        (({}, {\"a\": {\"b\": [\"c\"]}}, {\"a\": {\"b\": [\"d\"]}}), {\"a\": {\"b\": [\"c\"]}}),\n        (\n            ({\"a\": {\"b\": [{\"d\": \"e\"}]}}, {\"a\": {\"b\": [{\"d\": \"f\"}]}}, {\"a\": {\"b\": [{\"g\": \"h\"}]}}),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"g\": \"h\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}, {\"x\": \"y\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}, {\"x\": \"y\", \"g\": \"h\"}]}},\n        ),\n    ],\n)\ndef test_defaults_deep(case, expected):\n    assert _.defaults_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ([1, 2, 3], {0: 1, 1: 2, 2: 3}),\n        ({0: 1, 1: 2, 2: 3}, {0: 1, 1: 2, 2: 3}),\n    ],\n)\ndef test_to_dict(case, expected):\n    assert _.to_dict(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, {1: \"a\", 2: \"b\", 3: \"c\"}),\n        ([1, 2, 3], {1: 0, 2: 1, 3: 2}),\n    ],\n)\ndef test_invert(case, expected):\n    assert _.invert(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (([1, 2, 3],), {1: [0], 2: [1], 3: [2]}),\n        (\n            ({\"first\": \"fred\", \"second\": \"barney\", \"third\": \"fred\"},),\n            {\"fred\": [\"first\", \"third\"], \"barney\": [\"second\"]},\n        ),\n        (({\"a\": 1, \"b\": 2}, lambda val: val * 2), {2: [\"a\"], 4: [\"b\"]}),\n    ],\n)\ndef test_invert_by(case, expected):\n    result = _.invert_by(*case)\n    for key in result:\n        assert set(result[key]) == set(expected[key])\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, \"get\", \"a\"), 1),\n        (({\"a\": {\"b\": {\"c\": [1, 2, 3, 3]}}}, \"a.b.c.count\", 3), 2),\n        (({}, \"count\"), None),\n    ],\n)\ndef test_invoke(case, expected):\n    assert _.invoke(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_key returns only a single\n        # value. However, since dicts do not have an order, it's unknown what the\n        # \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [0]),\n    ],\n)\ndef test_find_key(case, expected):\n    assert _.find_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_last_key returns only a\n        # single value. However, since dicts do not have an order, it's unknown\n        # what the \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [2]),\n    ],\n)\ndef test_find_last_key(case, expected):\n    assert _.find_last_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([False, True, 3],)),\n    ],\n)\ndef test_for_in(case, expected):\n    assert _.for_in(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([1, True, \"index:2\"],)),\n    ],\n)\ndef test_for_in_right(case, expected):\n    assert _.for_in_right(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.0.a\", [{\"a\": 1}]), [{\"a\": 1}]),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), None),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", {\"test\": \"value\"}), {\"test\": \"value\"}),\n        (\n            ({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", {\"test\": \"value\"}),\n            {\"test\": \"value\"},\n        ),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), None),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), 5),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), 4),\n        (([\"one\", {\"two\": {\"three\": [4, [{\"four\": [5]}]]}}], \"[1].two.three[1][0].four[0]\"), 5),\n        ((range(50), \"[42]\"), 42),\n        (([[[[[[[[[[42]]]]]]]]]], \"[0][0][0][0][0][0][0][0][0][0]\"), 42),\n        (([range(50)], \"[0][42]\"), 42),\n        (({\"a\": [{\"b\": range(50)}]}, \"a[0].b[42]\"), 42),\n        (\n            ({\"lev.el1\": {\"lev\\\\el2\": {\"level3\": [\"value\"]}}}, \"lev\\\\.el1.lev\\\\\\\\el2.level3.[0]\"),\n            \"value\",\n        ),\n        (({\"one\": [\"hello\", \"there\"]}, \"one.bad.hello\", []), []),\n        (({\"one\": [\"hello\", None]}, \"one.1.hello\"), None),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), \"a\"), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), 0), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])({\"c\": {\"d\": 1}}, 2), \"a.c.d\"), 1),\n        (({}, \"update\"), None),\n        (([], \"extend\"), None),\n        (({(1,): {(2,): 3}}, (1,)), {(2,): 3}),\n        (({(1,): {(2,): 3}}, [(1,), (2,)]), 3),\n        (({object: 1}, object), 1),\n        (({object: {object: 1}}, [object, object]), 1),\n        (({1: {\"name\": \"John Doe\"}}, \"1.name\"), \"John Doe\"),\n    ],\n)\ndef test_get(case, expected):\n    assert _.get(*case) == expected\n\n\ndef test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\n    \"obj,path\",\n    [\n        (helpers.Object(), \"__init__\"),\n        (helpers.Object(subobj=helpers.Object()), \"subobj.__init__\"),\n        (namedtuple(\"a\", [\"a\"])(a=1), \"__len__\"),\n    ],\n)\ndef test_get__raises_for_objects_when_path_restricted(obj, path):\n    with pytest.raises(KeyError, match=\"access to restricted key\"):\n        _.get(obj, path)\n\n\n@parametrize(\n    \"obj,path\",\n    [\n        ({}, \"__init__\"),\n        ([], \"__contains__\"),\n    ],\n)\ndef test_get__does_not_raise_for_dict_or_list_when_path_restricted(obj, path):\n    assert _.get(obj, path) is None\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), False),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), False),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), True),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), True),\n        (({\"lev.el1\": {r\"lev\\el2\": {\"level3\": [\"value\"]}}}, r\"lev\\.el1.lev\\\\el2.level3.[0]\"), True),\n    ],\n)\ndef test_has(case, expected):\n    assert _.has(*case) == expected\n\n\ndef test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\", \"c\"]), ([1, 2, 3], [0, 1, 2])])\ndef test_keys(case, expected):\n    assert set(_.keys(case)) == set(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda num: num * 3), {\"a\": 3, \"b\": 6, \"c\": 9}),\n        (\n            (\n                {\"fred\": {\"name\": \"fred\", \"age\": 40}, \"pebbles\": {\"name\": \"pebbles\", \"age\": 1}},\n                \"age\",\n            ),\n            {\"fred\": 40, \"pebbles\": 1},\n        ),\n    ],\n)\ndef test_map_values(case, expected):\n    assert _.map_values(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\n                    \"level1\": {\n                        \"value\": \"value 1\",\n                        \"level2\": {\"value\": \"value 2\", \"level3\": {\"value\": \"value 3\"}},\n                    }\n                },\n                lambda value, property_path: \".\".join(property_path) + \"==\" + value,\n            ),\n            {\n                \"level1\": {\n                    \"value\": \"level1.value==value 1\",\n                    \"level2\": {\n                        \"value\": \"level1.level2.value==value 2\",\n                        \"level3\": {\"value\": \"level1.level2.level3.value==value 3\"},\n                    },\n                }\n            },\n        ),\n        (\n            (\n                [[\"value 1\", [[\"value 2\", [\"value 3\"]]]]],\n                lambda value, property_path: (_.join(property_path, \".\") + \"==\" + value),\n            ),\n            [[\"0.0==value 1\", [[\"0.1.0.0==value 2\", [\"0.1.0.1.0==value 3\"]]]]],\n        ),\n    ],\n)\ndef test_map_values_deep(case, expected):\n    assert _.map_values_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}, {}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}, {}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n                {\"characters\": [{\"score\": 5}, {\"score\": 7}]},\n            ),\n            {\n                \"characters\": [\n                    {\"name\": \"barney\", \"age\": 36, \"score\": 5},\n                    {\"name\": \"fred\", \"age\": 40, \"score\": 7},\n                ]\n            },\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": {\"score\": 5}, \"fred\": {\"age\": 40}}},\n            ),\n            {\"characters\": {\"barney\": {\"age\": 36, \"score\": 5}, \"fred\": {\"age\": 40, \"score\": 7}}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\"characters\": {\"barney\": [5], \"fred\": 7}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"foo\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\n                \"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}},\n                \"foo\": {\"barney\": [5], \"fred\": 7},\n            },\n        ),\n        (({\"foo\": {\"bar\": 1}}, {\"foo\": {}}), {\"foo\": {\"bar\": 1}}),\n        (({},), {}),\n        (([],), []),\n        ((None,), None),\n        ((None, {\"a\": 1}), None),\n        ((None, None, None, {\"a\": 1}), None),\n        (({\"a\": 1}, None), {\"a\": 1}),\n        (({\"a\": 1}, None, None, None, {\"b\": 2}), {\"a\": 1, \"b\": 2}),\n        (({\"a\": None}, None, None, None, {\"b\": None}), {\"a\": None, \"b\": None}),\n    ],\n)\ndef test_merge(case, expected):\n    assert _.merge(*case) == expected\n\n\ndef test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}\n\n\ndef test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"fruits\": [\"apple\"], \"others\": {\"vegetables\": [\"beet\"]}},\n                {\"fruits\": [\"banana\"], \"others\": {\"vegetables\": [\"carrot\"]}},\n                lambda a, b: a + b if isinstance(a, list) else None,\n            ),\n            {\"fruits\": [\"apple\", \"banana\"], \"others\": {\"vegetables\": [\"beet\", \"carrot\"]}},\n        ),\n    ],\n)\ndef test_merge_with(case, expected):\n    assert _.merge_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"b\": 2, \"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], 0), {1: 2, 2: 3}),\n        (([1, 2, 3], 0, 1), {2: 3}),\n        (({\"a\": {\"b\": {\"c\": \"d\"}}, \"e\": \"f\"}, \"a.b.c\", \"e\"), {\"a\": {\"b\": {}}}),\n        (({\"a\": [{\"b\": 1, \"c\": 2}, {\"d\": 3}]}, \"a[0].c\", \"a[1].d\"), {\"a\": [{\"b\": 1}, {}]}),\n    ],\n)\ndef test_omit(case, expected):\n    assert _.omit(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key == \"a\"), {\"b\": 2, \"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {1: 2, 2: 3}),\n    ],\n)\ndef test_omit_by(case, expected):\n    assert _.omit_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((1,), 1),\n        ((1.0,), 1),\n        ((\"1\",), 1),\n        ((\"00001\",), 1),\n        ((13, 8), 11),\n        ((\"0A\",), 10),\n        ((\"08\",), 8),\n        ((\"10\",), 16),\n        ((\"10\", 10), 10),\n        ((\"xyz\",), None),\n    ],\n)\ndef test_parse_int(case, expected):\n    assert _.parse_int(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"a\": 1}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"a\": 1, \"b\": 2}),\n        (([1, 2, 3],), {}),\n        (([1, 2, 3], 0), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        (({\"a\": {\"b\": 1, \"c\": 2, \"d\": 3}}, \"a.b\", \"a.d\"), {\"a\": {\"b\": 1, \"d\": 3}}),\n        (\n            ({\"a\": [{\"b\": 1}, {\"c\": 2}, {\"d\": 3}]}, \"a[0]\", \"a[2]\"),\n            {\"a\": [{\"b\": 1}, None, {\"d\": 3}]},\n        ),\n    ],\n)\ndef test_pick(case, expected):\n    assert _.pick(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key in [\"a\"]), {\"a\": 1}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n    ],\n)\ndef test_pick_by(case, expected):\n    assert _.pick_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\", \"b\": \"B\"}), {\"A\": 1, \"B\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\"}), {\"A\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"c\": \"C\", \"b\": \"B\"}), {\"a\": 1, \"B\": 2}),\n    ],\n)\ndef test_rename_keys(case, expected):\n    assert _.rename_keys(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, [\"one\", \"two\", \"three\", \"four\"], 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (({}, \"one.two.three.four\", 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, [\"one\", \"two\", \"three\", \"four\"], 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, \"one.two.three.four\", 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (({}, \"one\", 1), {\"one\": 1}),\n        (([], [0, 0, 0], 1), [[[1]]]),\n        (([], \"[0].[0].[0]\", 1), [[[1]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 1], 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[1]\", 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 2], 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[2]\", 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (({}, \"a.b[0].c\", 1), {\"a\": {\"b\": [{\"c\": 1}]}}),\n        (({}, \"a.b[0][0].c\", 1), {\"a\": {\"b\": [[{\"c\": 1}]]}}),\n        (({}, \"a\", tuple), {\"a\": tuple}),\n        (({}, r\"a.b\\.c.d\", 1), {\"a\": {\"b.c\": {\"d\": 1}}}),\n    ],\n)\ndef test_set_(case, expected):\n    assert _.set_(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", \"a\", lambda: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", dict, lambda: {}), {0: {1: dict}}),\n        ((Namespace(), \"a.b\", 5, lambda: Namespace()), Namespace(a=Namespace(b=5))),\n        (\n            (Namespace(a=Namespace(b=5)), \"a.c.d\", 55, lambda: Namespace()),\n            Namespace(a=Namespace(b=5, c=Namespace(d=55))),\n        ),\n    ],\n)\ndef test_set_with(case, expected):\n    assert _.set_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((\"1\",), True),\n        ((\"0\",), False),\n        ((\"true\",), True),\n        ((\"True\",), True),\n        ((\"false\",), False),\n        ((\"False\",), False),\n        ((\"\",), None),\n        ((\"a\",), None),\n        ((0,), False),\n        ((1,), True),\n        (([],), False),\n        ((True,), True),\n        ((False,), False),\n        ((None,), False),\n        ((\"Truthy\", [\"truthy\"]), True),\n        ((\"Falsey\", [], [\"falsey\"]), False),\n        ((\"foobar\", [\"^[f]\"]), True),\n        ((\"ofobar\", [\"^[f]\"]), None),\n        ((\"foobar\", [], [\".+[r]$\"]), False),\n        ((\"foobra\", [], [\".+[r]$\"]), None),\n    ],\n)\ndef test_to_boolean(case, expected):\n    assert _.to_boolean(*case) is expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1.4, 1),\n        (1.9, 1),\n        (\"1.4\", 1),\n        (\"1.9\", 1),\n        (\"foo\", 0),\n        (None, 0),\n        (True, 1),\n        (False, 0),\n        ({}, 0),\n        ([], 0),\n        ((), 0),\n    ],\n)\ndef test_to_integer(case, expected):\n    assert _.to_integer(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [((\"2.556\",), 3.0), ((\"2.556\", 1), 2.6), ((\"999.999\", -1), 990.0), ((\"foo\",), None)],\n)\ndef test_to_number(case, expected):\n    assert _.to_number(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, [[\"a\", 1], [\"b\", 2], [\"c\", 3]]),\n        ([1, 2, 3], [[0, 1], [1, 2], [2, 3]]),\n    ],\n)\ndef test_to_pairs(case, expected):\n    assert dict(_.to_pairs(case)) == dict(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1, \"1\"),\n        (1.25, \"1.25\"),\n        (True, \"True\"),\n        ([1], \"[1]\"),\n        (\"d\\xc3\\xa9j\\xc3\\xa0 vu\", \"d\\xc3\\xa9j\\xc3\\xa0 vu\"),\n        (\"\", \"\"),\n        (None, \"\"),\n        (today, str(today)),\n    ],\n)\ndef test_to_string(case, expected):\n    assert _.to_string(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ([1, 2, 3, 4, 5], lambda acc, value, key: acc.append((key, value))),\n            [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)],\n        ),\n        (([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], helpers.transform_iteratee0), [1, 9, 25]),\n        (([1, 2, 3, 4, 5],), []),\n    ],\n)\ndef test_transform(case, expected):\n    assert _.transform(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"rome\": \"Republic\"},\n                [\"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"rome\": \"Empire\"},\n        ),\n        (({}, [\"rome\"], lambda value: \"Empire\" if value == \"Republic\" else value), {\"rome\": None}),\n        (\n            (\n                {\"earth\": {\"rome\": \"Republic\"}},\n                [\"earth\", \"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"earth\": {\"rome\": \"Empire\"}},\n        ),\n    ],\n)\ndef test_update(case, expected):\n    assert _.update(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", _.constant(\"a\"), lambda *_: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", _.constant(\"a\"), {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", \"a\", {}), {0: {1: \"a\"}}),\n    ],\n)\ndef test_update_with(case, expected):\n    assert _.update_with(*case) == expected\n\n\n@parametrize(\n    \"obj,path,expected,new_obj\",\n    [\n        ({\"a\": [{\"b\": {\"c\": 7}}]}, \"a.0.b.c\", True, {\"a\": [{\"b\": {}}]}),\n        ([1, 2, 3], \"1\", True, [1, 3]),\n        ([1, 2, 3], 1, True, [1, 3]),\n        ([1, [2, 3]], [1, 1], True, [1, [2]]),\n        ([1, 2, 3], \"[0][0]\", False, [1, 2, 3]),\n        ([1, 2, 3], \"[0][0][0]\", False, [1, 2, 3]),\n    ],\n)\ndef test_unset(obj, path, expected, new_obj):\n    assert _.unset(obj, path) == expected\n    assert obj == new_obj\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [1, 2, 3]), ([1, 2, 3], [1, 2, 3])])\ndef test_values(case, expected):\n    assert set(_.values(case)) == set(expected)\n", "code_before": "from argparse import Namespace\nfrom collections import defaultdict, namedtuple\nimport datetime as dt\n\nimport pytest\n\nimport pydash as _\n\nfrom . import helpers\n\n\nparametrize = pytest.mark.parametrize\n\ntoday = dt.date.today()\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"employer\": \"slate\"}), {\"name\": \"fred\", \"employer\": \"slate\"}),\n        (\n            ({\"name\": \"fred\"}, {\"employer\": \"slate\"}, {\"employer\": \"medium\"}),\n            {\"name\": \"fred\", \"employer\": \"medium\"},\n        ),\n    ],\n)\ndef test_assign(case, expected):\n    assert _.assign(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\"}, {\"age\": 26}, lambda obj, src: src + 1), {\"name\": \"fred\", \"age\": 27}),\n    ],\n)\ndef test_assign_with(case, expected):\n    assert _.assign_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"name\": \"fred\", \"greet\": lambda: \"Hello, world!\"},), [\"greet\"]),\n        (([\"fred\", lambda: \"Hello, world!\"],), [1]),\n    ],\n)\ndef test_callables(case, expected):\n    assert _.callables(*case) == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone(case):\n    result = _.clone(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 3}},\n        ),\n    ],\n)\ndef test_clone_with(case, iteratee, expected):\n    result = _.clone_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case\",\n    [\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}},\n        [{\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}],\n    ],\n)\ndef test_clone_deep(case):\n    result = _.clone_deep(case)\n\n    assert result is not case\n\n    for key, value in _.helpers.iterator(result):\n        assert value is not case[key]\n\n\n@parametrize(\n    \"case,iteratee,expected\",\n    [\n        ({\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}, lambda v: v, {\"a\": {\"d\": 1}, \"b\": {\"c\": 2}}),\n        (\n            {\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}},\n            lambda v, k: v + 2 if isinstance(v, int) and k else None,\n            {\"a\": 3, \"b\": 4, \"c\": {\"d\": 5}},\n        ),\n        ([\"a\"], lambda a: None, [\"a\"]),\n        (\"a\", lambda a: None, \"a\"),\n    ],\n)\ndef test_clone_deep_with(case, iteratee, expected):\n    result = _.clone_deep_with(case, iteratee)\n\n    assert result == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"barney\"}, {\"name\": \"fred\", \"employer\": \"slate\"}),\n            {\"name\": \"barney\", \"employer\": \"slate\"},\n        ),\n    ],\n)\ndef test_defaults(case, expected):\n    assert _.defaults(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"user\": {\"name\": \"barney\"}}, {\"user\": {\"name\": \"fred\", \"age\": 36}}),\n            {\"user\": {\"name\": \"barney\", \"age\": 36}},\n        ),\n        (({}, {\"a\": {\"b\": [\"c\"]}}, {\"a\": {\"b\": [\"d\"]}}), {\"a\": {\"b\": [\"c\"]}}),\n        (\n            ({\"a\": {\"b\": [{\"d\": \"e\"}]}}, {\"a\": {\"b\": [{\"d\": \"f\"}]}}, {\"a\": {\"b\": [{\"g\": \"h\"}]}}),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"g\": \"h\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}]}},\n        ),\n        (\n            (\n                {\"a\": {\"b\": [{\"d\": \"e\"}, {\"x\": \"y\"}]}},\n                {\"a\": {\"b\": [{\"d\": \"f\"}, {\"g\": \"h\"}]}},\n                {\"a\": {\"b\": [{\"i\": \"j\"}]}},\n            ),\n            {\"a\": {\"b\": [{\"d\": \"e\", \"i\": \"j\"}, {\"x\": \"y\", \"g\": \"h\"}]}},\n        ),\n    ],\n)\ndef test_defaults_deep(case, expected):\n    assert _.defaults_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ([1, 2, 3], {0: 1, 1: 2, 2: 3}),\n        ({0: 1, 1: 2, 2: 3}, {0: 1, 1: 2, 2: 3}),\n    ],\n)\ndef test_to_dict(case, expected):\n    assert _.to_dict(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, {1: \"a\", 2: \"b\", 3: \"c\"}),\n        ([1, 2, 3], {1: 0, 2: 1, 3: 2}),\n    ],\n)\ndef test_invert(case, expected):\n    assert _.invert(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (([1, 2, 3],), {1: [0], 2: [1], 3: [2]}),\n        (\n            ({\"first\": \"fred\", \"second\": \"barney\", \"third\": \"fred\"},),\n            {\"fred\": [\"first\", \"third\"], \"barney\": [\"second\"]},\n        ),\n        (({\"a\": 1, \"b\": 2}, lambda val: val * 2), {2: [\"a\"], 4: [\"b\"]}),\n    ],\n)\ndef test_invert_by(case, expected):\n    result = _.invert_by(*case)\n    for key in result:\n        assert set(result[key]) == set(expected[key])\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, \"get\", \"a\"), 1),\n        (({\"a\": {\"b\": {\"c\": [1, 2, 3, 3]}}}, \"a.b.c.count\", 3), 2),\n        (({}, \"count\"), None),\n    ],\n)\ndef test_invoke(case, expected):\n    assert _.invoke(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_key returns only a single\n        # value. However, since dicts do not have an order, it's unknown what the\n        # \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [0]),\n    ],\n)\ndef test_find_key(case, expected):\n    assert _.find_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        # NOTE: The expected is a list of values but find_last_key returns only a\n        # single value. However, since dicts do not have an order, it's unknown\n        # what the \"first\" returned value will be.\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n                lambda obj: obj[\"age\"] < 40,\n            ),\n            [\"pebbles\", \"barney\"],\n        ),\n        (\n            (\n                {\n                    \"barney\": {\"age\": 36, \"blocked\": False},\n                    \"fred\": {\"age\": 40, \"blocked\": True},\n                    \"pebbles\": {\"age\": 1, \"blocked\": False},\n                },\n            ),\n            [\"barney\", \"fred\", \"pebbles\"],\n        ),\n        (([1, 2, 3],), [2]),\n    ],\n)\ndef test_find_last_key(case, expected):\n    assert _.find_last_key(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([False, True, 3],)),\n    ],\n)\ndef test_for_in(case, expected):\n    assert _.for_in(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee0),\n            ({\"name\": \"fredfred\", \"employer\": \"slateslate\"},),\n        ),\n        (\n            ({\"name\": \"fred\", \"employer\": \"slate\"}, helpers.for_in_iteratee1),\n            ({\"name\": \"fredfred\", \"employer\": \"slate\"}, {\"name\": \"fred\", \"employer\": \"slateslate\"}),\n        ),\n        (([1, 2, 3], helpers.for_in_iteratee2), ([1, True, \"index:2\"],)),\n    ],\n)\ndef test_for_in_right(case, expected):\n    assert _.for_in_right(*case) in expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), {\"three\": 4}),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), 4),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.0.a\", [{\"a\": 1}]), [{\"a\": 1}]),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", []), []),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), None),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), None),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", 2), 2),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", {\"test\": \"value\"}), {\"test\": \"value\"}),\n        (\n            ({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", {\"test\": \"value\"}),\n            {\"test\": \"value\"},\n        ),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\", \"haha\"), \"haha\"),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), None),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), 5),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), 5),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), 4),\n        (([\"one\", {\"two\": {\"three\": [4, [{\"four\": [5]}]]}}], \"[1].two.three[1][0].four[0]\"), 5),\n        ((range(50), \"[42]\"), 42),\n        (([[[[[[[[[[42]]]]]]]]]], \"[0][0][0][0][0][0][0][0][0][0]\"), 42),\n        (([range(50)], \"[0][42]\"), 42),\n        (({\"a\": [{\"b\": range(50)}]}, \"a[0].b[42]\"), 42),\n        (\n            ({\"lev.el1\": {\"lev\\\\el2\": {\"level3\": [\"value\"]}}}, \"lev\\\\.el1.lev\\\\\\\\el2.level3.[0]\"),\n            \"value\",\n        ),\n        (({\"one\": [\"hello\", \"there\"]}, \"one.bad.hello\", []), []),\n        (({\"one\": [\"hello\", None]}, \"one.1.hello\"), None),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), \"a\"), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])(1, 2), 0), 1),\n        ((namedtuple(\"a\", [\"a\", \"b\"])({\"c\": {\"d\": 1}}, 2), \"a.c.d\"), 1),\n        (({}, \"update\"), None),\n        (([], \"extend\"), None),\n        (({(1,): {(2,): 3}}, (1,)), {(2,): 3}),\n        (({(1,): {(2,): 3}}, [(1,), (2,)]), 3),\n        (({object: 1}, object), 1),\n        (({object: {object: 1}}, [object, object]), 1),\n        (({1: {\"name\": \"John Doe\"}}, \"1.name\"), \"John Doe\"),\n    ],\n)\ndef test_get(case, expected):\n    assert _.get(*case) == expected\n\n\ndef test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"b\"), True),\n        (([1, 2, 3], 0), True),\n        (([1, 2, 3], 1), True),\n        (([1, 2, 3], 3), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.two.three\"), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, [\"one\", \"two\", \"three\"]), True),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"five\"), False),\n        (({\"one\": {\"two\": {\"three\": 4}}}, \"one.four.three\"), False),\n        (({\"one\": {\"two\": {\"three\": [{\"a\": 1}]}}}, \"one.four.three.0.a\"), False),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, [\"one\", 1, \"three\", 1]), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.[1].three.[1]\"), True),\n        (({\"one\": [\"two\", {\"three\": [4, 5]}]}, \"one.1.three.1\"), True),\n        (([\"one\", {\"two\": {\"three\": [4, 5]}}], \"[1].two.three.[0]\"), True),\n        (({\"lev.el1\": {r\"lev\\el2\": {\"level3\": [\"value\"]}}}, r\"lev\\.el1.lev\\\\el2.level3.[0]\"), True),\n    ],\n)\ndef test_has(case, expected):\n    assert _.has(*case) == expected\n\n\ndef test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\", \"c\"]), ([1, 2, 3], [0, 1, 2])])\ndef test_keys(case, expected):\n    assert set(_.keys(case)) == set(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda num: num * 3), {\"a\": 3, \"b\": 6, \"c\": 9}),\n        (\n            (\n                {\"fred\": {\"name\": \"fred\", \"age\": 40}, \"pebbles\": {\"name\": \"pebbles\", \"age\": 1}},\n                \"age\",\n            ),\n            {\"fred\": 40, \"pebbles\": 1},\n        ),\n    ],\n)\ndef test_map_values(case, expected):\n    assert _.map_values(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\n                    \"level1\": {\n                        \"value\": \"value 1\",\n                        \"level2\": {\"value\": \"value 2\", \"level3\": {\"value\": \"value 3\"}},\n                    }\n                },\n                lambda value, property_path: \".\".join(property_path) + \"==\" + value,\n            ),\n            {\n                \"level1\": {\n                    \"value\": \"level1.value==value 1\",\n                    \"level2\": {\n                        \"value\": \"level1.level2.value==value 2\",\n                        \"level3\": {\"value\": \"level1.level2.level3.value==value 3\"},\n                    },\n                }\n            },\n        ),\n        (\n            (\n                [[\"value 1\", [[\"value 2\", [\"value 3\"]]]]],\n                lambda value, property_path: (_.join(property_path, \".\") + \"==\" + value),\n            ),\n            [[\"0.0==value 1\", [[\"0.1.0.0==value 2\", [\"0.1.0.1.0==value 3\"]]]]],\n        ),\n    ],\n)\ndef test_map_values_deep(case, expected):\n    assert _.map_values_deep(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}, {}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}, {}]},\n            ),\n            {\"characters\": [{\"name\": \"barney\", \"age\": 36}, {\"name\": \"fred\", \"age\": 40}, {}]},\n        ),\n        (\n            (\n                {\"characters\": [{\"name\": \"barney\"}, {\"name\": \"fred\"}]},\n                {\"characters\": [{\"age\": 36}, {\"age\": 40}]},\n                {\"characters\": [{\"score\": 5}, {\"score\": 7}]},\n            ),\n            {\n                \"characters\": [\n                    {\"name\": \"barney\", \"age\": 36, \"score\": 5},\n                    {\"name\": \"fred\", \"age\": 40, \"score\": 7},\n                ]\n            },\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": {\"score\": 5}, \"fred\": {\"age\": 40}}},\n            ),\n            {\"characters\": {\"barney\": {\"age\": 36, \"score\": 5}, \"fred\": {\"age\": 40, \"score\": 7}}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"characters\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\"characters\": {\"barney\": [5], \"fred\": 7}},\n        ),\n        (\n            (\n                {\"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}}},\n                {\"foo\": {\"barney\": [5], \"fred\": 7}},\n            ),\n            {\n                \"characters\": {\"barney\": {\"age\": 36}, \"fred\": {\"score\": 7}},\n                \"foo\": {\"barney\": [5], \"fred\": 7},\n            },\n        ),\n        (({\"foo\": {\"bar\": 1}}, {\"foo\": {}}), {\"foo\": {\"bar\": 1}}),\n        (({},), {}),\n        (([],), []),\n        ((None,), None),\n        ((None, {\"a\": 1}), None),\n        ((None, None, None, {\"a\": 1}), None),\n        (({\"a\": 1}, None), {\"a\": 1}),\n        (({\"a\": 1}, None, None, None, {\"b\": 2}), {\"a\": 1, \"b\": 2}),\n        (({\"a\": None}, None, None, None, {\"b\": None}), {\"a\": None, \"b\": None}),\n    ],\n)\ndef test_merge(case, expected):\n    assert _.merge(*case) == expected\n\n\ndef test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}\n\n\ndef test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"fruits\": [\"apple\"], \"others\": {\"vegetables\": [\"beet\"]}},\n                {\"fruits\": [\"banana\"], \"others\": {\"vegetables\": [\"carrot\"]}},\n                lambda a, b: a + b if isinstance(a, list) else None,\n            ),\n            {\"fruits\": [\"apple\", \"banana\"], \"others\": {\"vegetables\": [\"beet\", \"carrot\"]}},\n        ),\n    ],\n)\ndef test_merge_with(case, expected):\n    assert _.merge_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"b\": 2, \"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], 0), {1: 2, 2: 3}),\n        (([1, 2, 3], 0, 1), {2: 3}),\n        (({\"a\": {\"b\": {\"c\": \"d\"}}, \"e\": \"f\"}, \"a.b.c\", \"e\"), {\"a\": {\"b\": {}}}),\n        (({\"a\": [{\"b\": 1, \"c\": 2}, {\"d\": 3}]}, \"a[0].c\", \"a[1].d\"), {\"a\": [{\"b\": 1}, {}]}),\n    ],\n)\ndef test_omit(case, expected):\n    assert _.omit(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"c\": 3}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key == \"a\"), {\"b\": 2, \"c\": 3}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {1: 2, 2: 3}),\n    ],\n)\ndef test_omit_by(case, expected):\n    assert _.omit_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((1,), 1),\n        ((1.0,), 1),\n        ((\"1\",), 1),\n        ((\"00001\",), 1),\n        ((13, 8), 11),\n        ((\"0A\",), 10),\n        ((\"08\",), 8),\n        ((\"10\",), 16),\n        ((\"10\", 10), 10),\n        ((\"xyz\",), None),\n    ],\n)\ndef test_parse_int(case, expected):\n    assert _.parse_int(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\"), {\"a\": 1}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, \"a\", \"b\"), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\"], [\"b\"]), {\"a\": 1, \"b\": 2}),\n        (([1, 2, 3],), {}),\n        (([1, 2, 3], 0), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        (({\"a\": {\"b\": 1, \"c\": 2, \"d\": 3}}, \"a.b\", \"a.d\"), {\"a\": {\"b\": 1, \"d\": 3}}),\n        (\n            ({\"a\": [{\"b\": 1}, {\"c\": 2}, {\"d\": 3}]}, \"a[0]\", \"a[2]\"),\n            {\"a\": [{\"b\": 1}, None, {\"d\": 3}]},\n        ),\n    ],\n)\ndef test_pick(case, expected):\n    assert _.pick(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, [\"a\", \"b\"]), {\"a\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2, \"c\": 3}, lambda value, key: key in [\"a\"]), {\"a\": 1}),\n        (([1, 2, 3],), {0: 1, 1: 2, 2: 3}),\n        (([1, 2, 3], [0]), {0: 1}),\n        ((helpers.Object(a=1, b=2, c=3), \"a\"), {\"a\": 1}),\n        ((helpers.ItemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n        ((helpers.IteritemsObject({\"a\": 1, \"b\": 2, \"c\": 3}), \"a\"), {\"a\": 1}),\n    ],\n)\ndef test_pick_by(case, expected):\n    assert _.pick_by(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\", \"b\": \"B\"}), {\"A\": 1, \"B\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"a\": \"A\"}), {\"A\": 1, \"b\": 2}),\n        (({\"a\": 1, \"b\": 2}, {\"c\": \"C\", \"b\": \"B\"}), {\"a\": 1, \"B\": 2}),\n    ],\n)\ndef test_rename_keys(case, expected):\n    assert _.rename_keys(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, [\"one\", \"two\", \"three\", \"four\"], 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (({}, \"one.two.three.four\", 1), {\"one\": {\"two\": {\"three\": {\"four\": 1}}}}),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, [\"one\", \"two\", \"three\", \"four\"], 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (\n            ({\"one\": {\"two\": {}, \"three\": {}}}, \"one.two.three.four\", 1),\n            {\"one\": {\"two\": {\"three\": {\"four\": 1}}, \"three\": {}}},\n        ),\n        (({}, \"one\", 1), {\"one\": 1}),\n        (([], [0, 0, 0], 1), [[[1]]]),\n        (([], \"[0].[0].[0]\", 1), [[[1]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 1], 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[1]\", 7), [1, 2, [3, 4, [5, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], [2, 2, 2], 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (([1, 2, [3, 4, [5, 6]]], \"[2].[2].[2]\", 7), [1, 2, [3, 4, [5, 6, 7]]]),\n        (({}, \"a.b[0].c\", 1), {\"a\": {\"b\": [{\"c\": 1}]}}),\n        (({}, \"a.b[0][0].c\", 1), {\"a\": {\"b\": [[{\"c\": 1}]]}}),\n        (({}, \"a\", tuple), {\"a\": tuple}),\n        (({}, r\"a.b\\.c.d\", 1), {\"a\": {\"b.c\": {\"d\": 1}}}),\n    ],\n)\ndef test_set_(case, expected):\n    assert _.set_(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", \"a\", lambda: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", dict, lambda: {}), {0: {1: dict}}),\n        ((Namespace(), \"a.b\", 5, lambda: Namespace()), Namespace(a=Namespace(b=5))),\n        (\n            (Namespace(a=Namespace(b=5)), \"a.c.d\", 55, lambda: Namespace()),\n            Namespace(a=Namespace(b=5, c=Namespace(d=55))),\n        ),\n    ],\n)\ndef test_set_with(case, expected):\n    assert _.set_with(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ((\"1\",), True),\n        ((\"0\",), False),\n        ((\"true\",), True),\n        ((\"True\",), True),\n        ((\"false\",), False),\n        ((\"False\",), False),\n        ((\"\",), None),\n        ((\"a\",), None),\n        ((0,), False),\n        ((1,), True),\n        (([],), False),\n        ((True,), True),\n        ((False,), False),\n        ((None,), False),\n        ((\"Truthy\", [\"truthy\"]), True),\n        ((\"Falsey\", [], [\"falsey\"]), False),\n        ((\"foobar\", [\"^[f]\"]), True),\n        ((\"ofobar\", [\"^[f]\"]), None),\n        ((\"foobar\", [], [\".+[r]$\"]), False),\n        ((\"foobra\", [], [\".+[r]$\"]), None),\n    ],\n)\ndef test_to_boolean(case, expected):\n    assert _.to_boolean(*case) is expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1.4, 1),\n        (1.9, 1),\n        (\"1.4\", 1),\n        (\"1.9\", 1),\n        (\"foo\", 0),\n        (None, 0),\n        (True, 1),\n        (False, 0),\n        ({}, 0),\n        ([], 0),\n        ((), 0),\n    ],\n)\ndef test_to_integer(case, expected):\n    assert _.to_integer(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [((\"2.556\",), 3.0), ((\"2.556\", 1), 2.6), ((\"999.999\", -1), 990.0), ((\"foo\",), None)],\n)\ndef test_to_number(case, expected):\n    assert _.to_number(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        ({\"a\": 1, \"b\": 2, \"c\": 3}, [[\"a\", 1], [\"b\", 2], [\"c\", 3]]),\n        ([1, 2, 3], [[0, 1], [1, 2], [2, 3]]),\n    ],\n)\ndef test_to_pairs(case, expected):\n    assert dict(_.to_pairs(case)) == dict(expected)\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (1, \"1\"),\n        (1.25, \"1.25\"),\n        (True, \"True\"),\n        ([1], \"[1]\"),\n        (\"d\\xc3\\xa9j\\xc3\\xa0 vu\", \"d\\xc3\\xa9j\\xc3\\xa0 vu\"),\n        (\"\", \"\"),\n        (None, \"\"),\n        (today, str(today)),\n    ],\n)\ndef test_to_string(case, expected):\n    assert _.to_string(case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            ([1, 2, 3, 4, 5], lambda acc, value, key: acc.append((key, value))),\n            [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)],\n        ),\n        (([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], helpers.transform_iteratee0), [1, 9, 25]),\n        (([1, 2, 3, 4, 5],), []),\n    ],\n)\ndef test_transform(case, expected):\n    assert _.transform(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (\n            (\n                {\"rome\": \"Republic\"},\n                [\"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"rome\": \"Empire\"},\n        ),\n        (({}, [\"rome\"], lambda value: \"Empire\" if value == \"Republic\" else value), {\"rome\": None}),\n        (\n            (\n                {\"earth\": {\"rome\": \"Republic\"}},\n                [\"earth\", \"rome\"],\n                lambda value: \"Empire\" if value == \"Republic\" else value,\n            ),\n            {\"earth\": {\"rome\": \"Empire\"}},\n        ),\n    ],\n)\ndef test_update(case, expected):\n    assert _.update(*case) == expected\n\n\n@parametrize(\n    \"case,expected\",\n    [\n        (({}, \"[0][1]\", _.constant(\"a\"), lambda *_: {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", _.constant(\"a\"), {}), {0: {1: \"a\"}}),\n        (({}, \"[0][1]\", \"a\", {}), {0: {1: \"a\"}}),\n    ],\n)\ndef test_update_with(case, expected):\n    assert _.update_with(*case) == expected\n\n\n@parametrize(\n    \"obj,path,expected,new_obj\",\n    [\n        ({\"a\": [{\"b\": {\"c\": 7}}]}, \"a.0.b.c\", True, {\"a\": [{\"b\": {}}]}),\n        ([1, 2, 3], \"1\", True, [1, 3]),\n        ([1, 2, 3], 1, True, [1, 3]),\n        ([1, [2, 3]], [1, 1], True, [1, [2]]),\n        ([1, 2, 3], \"[0][0]\", False, [1, 2, 3]),\n        ([1, 2, 3], \"[0][0][0]\", False, [1, 2, 3]),\n    ],\n)\ndef test_unset(obj, path, expected, new_obj):\n    assert _.unset(obj, path) == expected\n    assert obj == new_obj\n\n\n@parametrize(\"case,expected\", [({\"a\": 1, \"b\": 2, \"c\": 3}, [1, 2, 3]), ([1, 2, 3], [1, 2, 3])])\ndef test_values(case, expected):\n    assert set(_.values(case)) == set(expected)\n", "patch": "@@ -380,6 +380,30 @@ def test_get__should_not_populate_defaultdict():\n     assert data == {}\n \n \n+@parametrize(\n+    \"obj,path\",\n+    [\n+        (helpers.Object(), \"__init__\"),\n+        (helpers.Object(subobj=helpers.Object()), \"subobj.__init__\"),\n+        (namedtuple(\"a\", [\"a\"])(a=1), \"__len__\"),\n+    ],\n+)\n+def test_get__raises_for_objects_when_path_restricted(obj, path):\n+    with pytest.raises(KeyError, match=\"access to restricted key\"):\n+        _.get(obj, path)\n+\n+\n+@parametrize(\n+    \"obj,path\",\n+    [\n+        ({}, \"__init__\"),\n+        ([], \"__contains__\"),\n+    ],\n+)\n+def test_get__does_not_raise_for_dict_or_list_when_path_restricted(obj, path):\n+    assert _.get(obj, path) is None\n+\n+\n @parametrize(\n     \"case,expected\",\n     [", "file_path": "files/2023_9/63", "file_language": "py", "file_name": "tests/test_objects.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}", "target": 0}, {"function": "def test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}", "target": 0}, {"function": "def test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}", "target": 0}, {"function": "def test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}", "target": 0}], "function_after": [{"function": "def test_get__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.get(data, \"a\")\n    assert data == {}", "target": 0}, {"function": "def test_has__should_not_populate_defaultdict():\n    data = defaultdict(list)\n    _.has(data, \"a\")\n    assert data == {}", "target": 0}, {"function": "def test_merge_no_link_dict():\n    case1 = {\"foo\": {\"bar\": None}}\n    case2 = {\"foo\": {\"bar\": False}}\n    result = _.merge({}, case1, case2)\n    result[\"foo\"][\"bar\"] = True\n\n    assert case1 == {\"foo\": {\"bar\": None}}\n    assert case2 == {\"foo\": {\"bar\": False}}", "target": 0}, {"function": "def test_merge_no_link_list():\n    case = {\"foo\": [{}]}\n    result = _.merge({}, case)\n    result[\"foo\"][0][\"bar\"] = True\n\n    assert case == {\"foo\": [{}]}", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
