{"index": 153, "cve_id": "CVE-2012-3360", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Directory traversal vulnerability in virt/disk/api.py in OpenStack Compute (Nova) Folsom (2012.2) and Essex (2012.1), when used over libvirt-based hypervisors, allows remote authenticated users to write arbitrary files to the disk image via a .. (dot dot) in the path attribute of a file element.", "cvss": "5.4", "publish_date": "July 22, 2012", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "LOW", "commit_id": "b0feaffdb2b1c51182b8dce41b367f3449af5dd9", "commit_message": "Prevent file injection writing to host filesystem.\n\nFix bug 1015531, CVE-2012-3360, CVE-2012-3361\n\nThis patch prevents the file injection code from writing into the host\nfilesystem if a user specifies a path for the injected file that\ncontains '..'. The check is to make sure that the final normalized path\nthat is about to be written to is within the mounted guest filesystem.\n\nThis is a backport of Russell Bryant, P\u00e1draig Brady and Mark\nMcLoughlin's Folsom patch.\n\nChange-Id: Id8bd6ffb4d878467ba2086d341fce23f2ff5aa0a", "commit_date": "2012-07-03T14:32:12Z", "project": "openstack/nova", "url": "https://api.github.com/repos/openstack/nova/commits/b0feaffdb2b1c51182b8dce41b367f3449af5dd9", "html_url": "https://github.com/openstack/nova/commit/b0feaffdb2b1c51182b8dce41b367f3449af5dd9", "windows_before": [{"commit_id": "2427d4a99bed35baefd8f17ba422cb7aae8dcca7", "commit_date": "Wed Jun 20 11:13:13 2012 -0400", "commit_message": "Prevent file injection writing to host filesystem.", "files_name": ["nova/tests/test_virt.py", "nova/virt/disk/api.py"]}, {"commit_id": "66bf71b1fccda05cef5a1ea807d366dd211ed872", "commit_date": "Mon Jun 25 14:52:58 2012 +0800", "commit_message": "Implement nova network API for quantum API 2.0", "files_name": ["Authors", "nova/network/quantumv2/__init__.py", "nova/network/quantumv2/api.py", "nova/tests/network/test_quantum.py", "nova/tests/network/test_quantumv2.py", "tools/pip-requires"]}, {"commit_id": "211328fb50cc35af2dd08e514deb111fd0a036d2", "commit_date": "Thu Jun 28 10:28:29 2012 -0700", "commit_message": "Expand HACKING with commit message guidelines", "files_name": ["HACKING.rst"]}, {"commit_id": "94a34e0e69a520e403a2d8e579186fad9acf14c7", "commit_date": "Fri Jun 29 21:32:08 2012 -0600", "commit_message": "Add ServiceCatalog entries to enable Cinder usage", "files_name": ["nova/api/auth.py", "nova/api/ec2/__init__.py", "nova/context.py", "nova/tests/api/test_auth.py"]}, {"commit_id": "2c144fccad21f60fd1e34436527c44abdba345dd", "commit_date": "Mon Jul 2 20:35:09 2012 +0000", "commit_message": "Pass vdi_ref to fake.create_vbd() not a string", "files_name": ["nova/tests/test_xenapi.py"]}, {"commit_id": "d335457f48d09c3d780c92413fe777030c1335e2", "commit_date": "Thu Jun 28 15:59:23 2012 -0500", "commit_message": "Switch to common logging.", "files_name": ["bin/nova-all", "bin/nova-api", "bin/nova-api-ec2", "bin/nova-api-metadata", "bin/nova-api-os-compute", "bin/nova-api-os-volume", "bin/nova-cert", "bin/nova-clear-rabbit-queues", "bin/nova-compute", "bin/nova-console", "bin/nova-consoleauth", "bin/nova-dhcpbridge", "bin/nova-instance-usage-audit", "bin/nova-manage", "bin/nova-network", "bin/nova-objectstore", "bin/nova-rpc-zmq-receiver", "bin/nova-scheduler", "bin/nova-volume", "bin/nova-volume-usage-audit", "bin/nova-xvpvncproxy", "etc/nova/logging_sample.conf", "nova/api/auth.py", "nova/api/ec2/__init__.py", "nova/api/ec2/apirequest.py", "nova/api/ec2/cloud.py", "nova/api/ec2/ec2utils.py", "nova/api/metadata/base.py", "nova/api/metadata/handler.py", "nova/api/openstack/__init__.py", "nova/api/openstack/auth.py", "nova/api/openstack/common.py", "nova/api/openstack/compute/__init__.py", "nova/api/openstack/compute/contrib/__init__.py", "nova/api/openstack/compute/contrib/accounts.py", "nova/api/openstack/compute/contrib/admin_actions.py", "nova/api/openstack/compute/contrib/aggregates.py", "nova/api/openstack/compute/contrib/certificates.py", "nova/api/openstack/compute/contrib/cloudpipe.py", "nova/api/openstack/compute/contrib/console_output.py", "nova/api/openstack/compute/contrib/consoles.py", "nova/api/openstack/compute/contrib/deferred_delete.py", "nova/api/openstack/compute/contrib/extended_server_attributes.py", "nova/api/openstack/compute/contrib/extended_status.py", "nova/api/openstack/compute/contrib/flavormanage.py", "nova/api/openstack/compute/contrib/floating_ip_dns.py", "nova/api/openstack/compute/contrib/floating_ip_pools.py", "nova/api/openstack/compute/contrib/floating_ips.py", "nova/api/openstack/compute/contrib/hosts.py", "nova/api/openstack/compute/contrib/hypervisors.py", "nova/api/openstack/compute/contrib/multinic.py", "nova/api/openstack/compute/contrib/networks.py", "nova/api/openstack/compute/contrib/rescue.py", "nova/api/openstack/compute/contrib/scheduler_hints.py", "nova/api/openstack/compute/contrib/security_groups.py", "nova/api/openstack/compute/contrib/server_start_stop.py", "nova/api/openstack/compute/contrib/users.py", "nova/api/openstack/compute/contrib/virtual_interfaces.py", "nova/api/openstack/compute/contrib/volumes.py", "nova/api/openstack/compute/extensions.py", "nova/api/openstack/compute/images.py", "nova/api/openstack/compute/ips.py", "nova/api/openstack/compute/servers.py", "nova/api/openstack/compute/views/addresses.py", "nova/api/openstack/compute/views/servers.py", "nova/api/openstack/extensions.py", "nova/api/openstack/urlmap.py", "nova/api/openstack/volume/__init__.py", "nova/api/openstack/volume/contrib/__init__.py", "nova/api/openstack/volume/extensions.py", "nova/api/openstack/volume/snapshots.py", "nova/api/openstack/volume/volumes.py", "nova/api/openstack/wsgi.py", "nova/api/sizelimit.py", "nova/auth/ldapdriver.py", "nova/auth/manager.py", "nova/auth/signer.py", "nova/cert/manager.py", "nova/cloudpipe/pipelib.py", "nova/common/deprecated.py", "nova/compute/api.py", "nova/compute/instance_types.py", "nova/compute/manager.py", "nova/compute/utils.py", "nova/console/manager.py", "nova/console/vmrc_manager.py", "nova/console/xvp.py", "nova/consoleauth/manager.py", "nova/context.py", "nova/crypto.py", "nova/db/sqlalchemy/api.py", "nova/db/sqlalchemy/migrate_repo/versions/082_essex.py", "nova/db/sqlalchemy/migrate_repo/versions/083_quota_class.py", "nova/db/sqlalchemy/migrate_repo/versions/087_add_uuid_to_bw_usage_cache.py", "nova/db/sqlalchemy/migrate_repo/versions/088_change_instance_id_to_uuid_in_block_device_mapping.py", "nova/db/sqlalchemy/migrate_repo/versions/089_add_volume_id_mappings.py", "nova/db/sqlalchemy/migrate_repo/versions/090_modify_volume_id_datatype.py", "nova/db/sqlalchemy/migrate_repo/versions/091_convert_volume_ids_to_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/092_add_instance_system_metadata.py", "nova/db/sqlalchemy/migrate_repo/versions/095_change_fk_instance_id_to_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/097_quota_usages_reservations.py", "nova/db/sqlalchemy/migrate_repo/versions/099_add_disabled_instance_types.py", "nova/db/sqlalchemy/migrate_repo/versions/100_instance_metadata_uses_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/101_security_group_instance_association_uses_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/102_consoles_uses_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/105_instance_info_caches_uses_uuid.py", "nova/db/sqlalchemy/migrate_repo/versions/106_add_foreign_keys.py", "nova/db/sqlalchemy/migrate_repo/versions/107_add_instance_id_mappings.py", "nova/db/sqlalchemy/migration.py", "nova/db/sqlalchemy/session.py", "nova/exception.py", "nova/flags.py", "nova/image/glance.py", "nova/image/s3.py", "nova/manager.py", "nova/network/api.py", "nova/network/l3.py", "nova/network/ldapdns.py", "nova/network/linux_net.py", "nova/network/manager.py", "nova/network/quantum/manager.py", "nova/network/quantum/melange_connection.py", "nova/network/quantum/melange_ipam_lib.py", "nova/network/quantum/nova_ipam_lib.py", "nova/network/quantum/quantum_connection.py", "nova/network/quantum/sg.py", "nova/notifications.py", "nova/notifier/api.py", "nova/notifier/capacity_notifier.py", "nova/notifier/list_notifier.py", "nova/notifier/log_notifier.py", "nova/notifier/rabbit_notifier.py", "nova/openstack/common/log.py", "nova/openstack/common/rpc/impl_zmq.py", "nova/quota.py", "nova/scheduler/driver.py", "nova/scheduler/filter_scheduler.py", "nova/scheduler/filters/arch_filter.py", "nova/scheduler/filters/compute_filter.py", "nova/scheduler/filters/core_filter.py", "nova/scheduler/filters/ram_filter.py", "nova/scheduler/filters/trusted_filter.py", "nova/scheduler/host_manager.py", "nova/scheduler/least_cost.py", "nova/scheduler/manager.py", "nova/scheduler/scheduler_options.py", "nova/service.py", "nova/test.py", "nova/tests/__init__.py", "nova/tests/api/ec2/test_cloud.py", "nova/tests/api/ec2/test_ec2_validate.py", "nova/tests/api/openstack/compute/contrib/test_aggregates.py", "nova/tests/api/openstack/compute/contrib/test_hosts.py", "nova/tests/api/openstack/compute/contrib/test_snapshots.py", "nova/tests/api/openstack/compute/contrib/test_volume_types.py", "nova/tests/api/openstack/compute/test_urlmap.py", "nova/tests/api/openstack/volume/test_router.py", "nova/tests/api/openstack/volume/test_snapshots.py", "nova/tests/compute/test_compute.py", "nova/tests/consoleauth/test_consoleauth.py", "nova/tests/fake_utils.py", "nova/tests/image/fake.py", "nova/tests/integrated/api/client.py", "nova/tests/integrated/integrated_helpers.py", "nova/tests/integrated/test_extensions.py", "nova/tests/integrated/test_login.py", "nova/tests/integrated/test_multiprocess_api.py", "nova/tests/integrated/test_servers.py", "nova/tests/integrated/test_volumes.py", "nova/tests/integrated/test_xml.py", "nova/tests/network/test_linux_net.py", "nova/tests/network/test_manager.py", "nova/tests/network/test_network_info.py", "nova/tests/network/test_quantum.py", "nova/tests/notifier/test_list_notifier.py"]}], "windows_after": [{"commit_id": "1a7d6a0740aee2e7b5d6259d00b34847f5088b35", "commit_date": "Tue Jul 3 15:32:15 2012 +0000", "commit_message": "Merge \"Run hacking tests as part of the gate.\"", "files_name": ["70129ed19db187cc90f74abd5c93c86098d29c27 - Mon Jul 2 23:32:01 2012 +0400 : Make possible to store snapshots not in /tmp directory", "nova/tests/test_virt_drivers.py", "nova/virt/libvirt/driver.py"]}, {"commit_id": "53ddedf90a870400627e4753b16f0162ba30bc25", "commit_date": "Tue Jul 3 17:04:08 2012 +0000", "commit_message": "Fix assertRaises(Exception, ...) HACKING violation", "files_name": ["nova/tests/network/test_manager.py"]}, {"commit_id": "8fb3ea3c06aa5783009b98f484bb1ca13d907ef0", "commit_date": "Tue Jul 3 16:23:47 2012 +0000", "commit_message": "Drop xenapi session.get_imported_xenapi()", "files_name": ["nova/tests/test_xenapi.py", "nova/tests/test_xensm.py", "nova/tests/xenapi/stubs.py", "nova/virt/xenapi/connection.py", "nova/virt/xenapi/host.py", "nova/virt/xenapi/pool.py", "nova/virt/xenapi/vmops.py", "nova/virt/xenapi/volumeops.py"]}, {"commit_id": "545d5ddd6b2f8bdfe394d80c7af33e07472f9b95", "commit_date": "Tue Jul 3 17:31:03 2012 +0000", "commit_message": "Merge \"Expand HACKING with commit message guidelines\"", "files_name": ["9e282ef2d6198ae5f7b62ec6c6c2975e5b252175 - Tue Jul 3 13:16:36 2012 -0400 : Fix nova-rpc-zmq-receiver", "bin/nova-rpc-zmq-receiver"]}, {"commit_id": "907ea44dfdc6d5349ac6086e6647abaf2829b052", "commit_date": "Tue Jul 3 17:49:58 2012 +0000", "commit_message": "Merge \"Fix assertRaises(Exception, ...) HACKING violation\"", "files_name": ["1f15b28f44635f5b4fc5b2c7389727ed141d34be - Tue Jul 3 18:09:28 2012 +0000 : Merge \"Fix nova-rpc-zmq-receiver\"", "dde5b01ce129fb47050d126051775c31e36f3b89 - Tue Jul 3 18:35:02 2012 +0000 : Merge \"use import_object_ns for compute_driver loading\"", "0038e3818393415fc9628aef2747136a626682ee - Mon Jul 2 11:08:38 2012 -0700 : Modifies ec2/cloud to be able to use Cinder", "nova/api/ec2/cloud.py", "nova/db/sqlalchemy/api.py", "nova/tests/api/ec2/test_cloud.py"]}, {"commit_id": "d0e99facdca719a16b3b4c247bb1364c26ba3ef9", "commit_date": "Mon Jul 2 11:12:52 2012 -0700", "commit_message": "Add Cinder Volume API to Nova", "files_name": ["nova/tests/api/ec2/test_cinder_cloud.py", "nova/tests/fake_volume.py", "nova/volume/__init__.py", "nova/volume/cinder.py"]}, {"commit_id": "b0255f5b35513f4cbf6c603b91776cbff53168bb", "commit_date": "Tue Jul 3 19:03:26 2012 +0000", "commit_message": "Merge \"Add ServiceCatalog entries to enable Cinder usage\"", "files_name": ["2f62b72e521b135a16fb023b5da8443e0fef664d - Tue Jul 3 19:24:58 2012 +0000 : Merge \"Implement nova network API for quantum API 2.0\"", "511e24a7a37665bff36cf41cd9c30701f7946203 - Tue Jul 3 19:34:14 2012 +0000 : Merge \"Modifies ec2/cloud to be able to use Cinder\"", "ff5981b59b6fc5b280af101c2309acb5b7324dab - Tue Jul 3 19:34:16 2012 +0000 : Merge \"Add Cinder Volume API to Nova\"", "63ce7031d1b0fd0c251fffea55bc7120e3d1f6b0 - Tue Jul 3 23:54:58 2012 +0000 : Fix missing nova.log change to nova.openstack.common.log", "bin/nova-novncproxy"]}, {"commit_id": "980c76266629ea66bc23fddb02f5be61c51d873c", "commit_date": "Tue Jul 3 22:15:12 2012 -0400", "commit_message": "Fix some hacking violations in the quantum tests.", "files_name": ["nova/network/quantumv2/__init__.py", "nova/network/quantumv2/api.py", "nova/tests/network/test_quantumv2.py"]}, {"commit_id": "dab6261216dab3879c45c4e89f29627a16d8db1a", "commit_date": "Tue Jul 3 23:15:06 2012 -0400", "commit_message": "Assign service_catalog in NovaKeystoneContext.", "files_name": ["nova/api/auth.py"]}, {"commit_id": "dea224ae26c752d328ccbb622048a63e990bee50", "commit_date": "Wed Jul 4 11:21:19 2012 +0000", "commit_message": "Distinguish over-quota for volume size and number.", "files_name": ["nova/exception.py", "nova/tests/test_volume.py", "nova/volume/api.py"]}, {"commit_id": "5bce6f5fbe804cd24d8bf1c2e36680876bc044cd", "commit_date": "Wed Jul 4 22:47:06 2012 -0300", "commit_message": "Ensure system metadata is sent on new image creation.", "files_name": ["nova/tests/test_xenapi.py", "nova/virt/xenapi/vm_utils.py"]}, {"commit_id": "ccdb02105acf32a4a0c81d688749475d8abedf4b", "commit_date": "Thu Jul 5 13:49:02 2012 +0100", "commit_message": "Don't catch & ignore exceptions when setting up LXC container filesystems", "files_name": ["nova/virt/disk/api.py"]}, {"commit_id": "3456b667c38aa1d439482b9c95838aba6d3d6c5c", "commit_date": "Thu Jul 5 09:08:38 2012 -0500", "commit_message": "Finish AUTHORS transition.", "files_name": [".gitignore", "Authors", "MANIFEST.in", "nova/tests/test_misc.py"]}, {"commit_id": "be0c9e62840ae7bcff3e77a5b3bd664d3bda6d43", "commit_date": "Thu Jul 5 15:34:40 2012 +0000", "commit_message": "Merge \"Remove unused 'get_open_port' method from libvirt utils\"", "files_name": ["202579b9bc9c7c74b2e1caf10300c1ae48c12d23 - Thu Jul 5 15:46:47 2012 +0000 : Merge \"Assign service_catalog in NovaKeystoneContext.\"", "8c9539d88fd53cb150dbe41da485ef0bc919b66a - Thu Jul 5 15:46:49 2012 +0000 : Merge \"Add compatibility for CPU model config with libvirt < 0.9.10\"", "9c37ef6dc31125e1aed7f75dc1d05be3f24d6880 - Thu Jul 5 15:51:32 2012 +0000 : Merge \"Ensure system metadata is sent on new image creation.\"", "ef7462c28ebbc0b8e36c9663acab820121e5f747 - Thu Jul 5 15:18:32 2012 +0000 : Remove unnecessary setUp() method in xenapi driver tests", "nova/tests/test_xenapi.py"]}, {"commit_id": "04d6def2b1702c962757d59ed086a2577300712a", "commit_date": "Thu Jul 5 15:33:57 2012 +0000", "commit_message": "Remove unnecessary target_host flag in xenapi driver tests", "files_name": ["nova/tests/test_xenapi.py"]}, {"commit_id": "f953091dfe213e15d29209f2c2418e06eac1188e", "commit_date": "Tue Jul 3 14:39:43 2012 -0700", "commit_message": "Remove auth-related nova-manage commands", "files_name": ["bin/nova-manage", "doc/source/man/nova-manage.rst", "nova/tests/test_nova_manage.py"]}, {"commit_id": "483ec33feced931d3f7ad196ba094026f5ac580f", "commit_date": "Thu Jul 5 09:33:03 2012 -0700", "commit_message": "Add *.egg* to .gitignore", "files_name": [".gitignore"]}, {"commit_id": "90a93098a608f1d8254db712482f7cb801e6b1cf", "commit_date": "Thu Jul 5 09:45:03 2012 -0700", "commit_message": "Correct typo in tools/hacking.py l18n -> i18n", "files_name": ["tools/hacking.py"]}, {"commit_id": "dd0e0ad5942743a434adf36bb91d107ac4e484e9", "commit_date": "Thu Jul 5 11:21:13 2012 -0500", "commit_message": "Allow network_uuids that begin with a prefix", "files_name": ["nova/api/openstack/compute/servers.py", "nova/tests/api/openstack/compute/test_servers.py"]}, {"commit_id": "ac8e228e5bcdcb816ea6e7f056e16fdcc5b0aca7", "commit_date": "Thu Jul 5 17:19:49 2012 +0000", "commit_message": "Merge \"Allow network_uuids that begin with a prefix\"", "files_name": ["1eb27c33249536878e38f3865e0cfa588d72680d - Thu Jul 5 17:27:50 2012 +0000 : Merge \"Add *.egg* to .gitignore\"", "e520f558153c11f70b2b2e7a8d93e3f8d916d743 - Thu Jul 5 17:32:57 2012 +0000 : Merge \"Finish AUTHORS transition.\"", "6a4c4079c04feb7f12efd137d5bf9631345fba06 - Thu Jul 5 17:40:34 2012 +0000 : Merge \"Correct typo in tools/hacking.py l18n -> i18n\"", "e883e9756c779793ca071ee3f052f5d13610a9ac - Thu Jul 5 18:26:24 2012 +0000 : Merge \"Pass vdi_ref to fake.create_vbd() not a string\"", "4cdc30796c7c76068898cd9e9280e8d7a11a57cb - Thu Jul 5 14:27:33 2012 -0400 : Add checks for retrieving deleted instance metadata for notification events.", "nova/compute/utils.py", "nova/notifications.py", "nova/tests/test_compute_utils.py"]}, {"commit_id": "563b160071b794217c988f5fd13bccffe4996f86", "commit_date": "Thu Jul 5 18:55:02 2012 +0000", "commit_message": "Merge \"Drop xenapi session.get_imported_xenapi()\"", "files_name": ["4e4ec8178e6667f5e9eb7d92d9c014fc51686201 - Thu Jul 5 18:57:33 2012 +0000 : Merge \"Remove unnecessary setUp() method in xenapi driver tests\"", "fbb4fbf9955dc3edd217472631b514d4c52f5b8a - Thu Jul 5 19:05:51 2012 +0000 : Merge \"Remove unnecessary target_host flag in xenapi driver tests\"", "6c1d7989d9bf4aea16758542e203cbbad2f7c6f0 - Thu Jul 5 09:45:35 2012 -0400 : ignore project files for eclipse/pydev", ".gitignore"]}, {"commit_id": "19269d8464dd055e6add1779041014e51e79ba08", "commit_date": "Thu Jul 5 16:14:18 2012 -0400", "commit_message": "sort .gitignore for readability", "files_name": [".gitignore"]}, {"commit_id": "7b43eaa9d8075c3d05fd17d19de12793a9c09692", "commit_date": "Thu Jul 5 16:36:34 2012 -0400", "commit_message": "modify hacking.py to not choke on the def of _()", "files_name": ["tools/hacking.py"]}, {"commit_id": "45f9c298c2a6ba3b182ce3c225d09a0bfcb7dd2d", "commit_date": "Mon Jul 2 20:48:30 2012 +0000", "commit_message": "Properly track VBD and VDI connections in xenapi fake", "files_name": ["nova/tests/xenapi/stubs.py", "nova/virt/xenapi/fake.py"]}, {"commit_id": "eda64300014fbff336000a18082e2e5da7f642b1", "commit_date": "Thu Jul 5 21:08:47 2012 +0000", "commit_message": "Merge \"Remove auth-related nova-manage commands\"", "files_name": ["050936e6223a920fc8112b914217f4739f2b8ed1 - Thu Jul 5 21:08:49 2012 +0000 : Merge \"Add checks for retrieving deleted instance metadata for notification events.\"", "fbb93679c5d69b3800c38931b670bb55cbbe1bb7 - Thu Jul 5 21:08:51 2012 +0000 : Merge \"Don't catch & ignore exceptions when setting up LXC container filesystems\"", "974233db34c66173f9b98cf161734aaf11db20f6 - Thu Jul 5 21:48:45 2012 +0000 : Merge \"sort .gitignore for readability\"", "6335e66e1c1a825c28cb7beb46ef913401693bae - Thu Jul 5 22:10:53 2012 +0000 : Merge \"Make possible to store snapshots not in /tmp directory\"", "efa69b44ccdacc788a39b893d46168a725c95ec2 - Thu Jul 5 22:20:58 2012 +0000 : Merge \"Get hypervisor uptime.\"", "e6ec6f851223151bec1d3ef47bb1030c1ebb598b - Fri Jul 6 00:18:31 2012 +0000 : Merge \"modify hacking.py to not choke on the def of _()\"", "4bbb9cfde27cd3c8268caf272d04a009b50c7a08 - Thu Jul 5 19:40:47 2012 +0100 : Fallback to fakelibvirt in test_libvirt.py test suite", "nova/tests/fakelibvirt.py", "nova/tests/test_libvirt.py"]}, {"commit_id": "9698a45a308f54865811e67498e8f0500c8187f2", "commit_date": "Thu Jun 28 12:35:04 2012 +0100", "commit_message": "Set the default CPU mode to 'host-model' for Libvirt KVM/QEMU guests", "files_name": ["nova/tests/test_libvirt.py", "nova/virt/libvirt/driver.py"]}, {"commit_id": "0598db0a6c66eb2b6d2e0e3f0b3b2b921ebe8621", "commit_date": "Fri Jul 6 13:23:55 2012 -0400", "commit_message": "This patch stops metadata from being deleted when an instance is deleted.", "files_name": ["nova/compute/manager.py", "nova/compute/utils.py", "nova/db/sqlalchemy/api.py", "nova/notifications.py"]}, {"commit_id": "626632d4cbd5de26cc2793c9d18b599b074c507e", "commit_date": "Fri Jul 6 10:46:13 2012 -0700", "commit_message": "Fix rpc import path in nova-novncproxy", "files_name": ["bin/nova-novncproxy"]}, {"commit_id": "45a6a91e893294bdcd3b4fe38669171ac10ffe13", "commit_date": "Fri Jul 6 21:10:16 2012 +0000", "commit_message": "Merge \"Fix rpc import path in nova-novncproxy\"", "files_name": ["642ec634c3beeb69175d0df12bcec8833e7efae5 - Fri Jul 6 18:22:56 2012 -0400 : Implements updating complete bw usage data", "nova/db/sqlalchemy/api.py"]}, {"commit_id": "aa87cc10d6a02d74f1466dc1a4e0e39c1a0878da", "commit_date": "Thu Jun 28 19:18:20 2012 -0500", "commit_message": "Switch to common notifiers.", "files_name": ["nova/compute/manager.py", "nova/compute/utils.py", "nova/flags.py", "nova/network/manager.py", "nova/notifications.py", "nova/notifier/capacity_notifier.py", "nova/openstack/common/context.py", "nova/openstack/common/log.py", "nova/openstack/common/notifier/__init__.py", "nova/openstack/common/notifier/api.py", "nova/openstack/common/notifier/list_notifier.py", "nova/openstack/common/notifier/log_notifier.py", "nova/openstack/common/notifier/no_op_notifier.py", "nova/openstack/common/notifier/rabbit_notifier.py", "nova/openstack/common/notifier/test_notifier.py", "nova/scheduler/filter_scheduler.py", "nova/scheduler/manager.py", "nova/tests/compute/test_compute.py", "nova/tests/notifier/__init__.py", "nova/tests/notifier/test_capacity_notifier.py", "nova/tests/notifier/test_list_notifier.py", "nova/tests/test_compute_utils.py", "nova/tests/test_notifications.py", "nova/tests/test_notifier.py", "nova/tests/test_volume.py", "nova/tests/test_volume_utils.py", "nova/volume/utils.py", "openstack-common.conf"]}, {"commit_id": "a2032924adcce758866cd30c744d8a6a47dd4669", "commit_date": "Sat Jul 7 10:37:46 2012 +0100", "commit_message": "fix metadata file injection with xen", "files_name": ["nova/virt/xenapi/vm_utils.py"]}, {"commit_id": "eb2de037a387a2f20f50a81c973a2efd48d73494", "commit_date": "Thu Jul 5 16:27:12 2012 -0500", "commit_message": "Update common setup code to latest.", "files_name": [".gitignore", ".mailmap", "doc/ext/nova_autodoc.py", "doc/find_autodoc_modules.sh", "doc/generate_autodoc_index.sh", "doc/source/conf.py", "nova/openstack/common/setup.py", "setup.py"]}, {"commit_id": "c586de1c5826a5e132feeea94a7428f37b2c3238", "commit_date": "Thu Jul 5 16:33:27 2012 -0500", "commit_message": "Removed a bunch of cruft files.", "files_name": ["doc/.gitignore", "doc/Makefile", "doc/README.rst", "doc/build/.gitignore", "doc/build/.placeholder", "doc/source/_static/.gitignore", "doc/source/_static/.placeholder", "doc/source/_templates/.gitignore"]}], "parents": [{"commit_id_before": "33c2575ebf9c8022521d36f51b9b31cd41f7f74f", "url_before": "https://api.github.com/repos/openstack/nova/commits/33c2575ebf9c8022521d36f51b9b31cd41f7f74f", "html_url_before": "https://github.com/openstack/nova/commit/33c2575ebf9c8022521d36f51b9b31cd41f7f74f"}], "details": [{"raw_url": "https://github.com/openstack/nova/raw/b0feaffdb2b1c51182b8dce41b367f3449af5dd9/nova%2Ftests%2Ftest_virt.py", "code": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom nova import exception\nfrom nova import flags\nfrom nova import test\nfrom nova.virt.disk import api as disk_api\nfrom nova.virt import driver\n\nFLAGS = flags.FLAGS\n\n\nclass TestVirtDriver(test.TestCase):\n    def test_block_device(self):\n        swap = {'device_name': '/dev/sdb',\n                'swap_size': 1}\n        ephemerals = [{'num': 0,\n                       'virtual_name': 'ephemeral0',\n                       'device_name': '/dev/sdc1',\n                       'size': 1}]\n        block_device_mapping = [{'mount_device': '/dev/sde',\n                                 'device_path': 'fake_device'}]\n        block_device_info = {\n                'root_device_name': '/dev/sda',\n                'swap': swap,\n                'ephemerals': ephemerals,\n                'block_device_mapping': block_device_mapping}\n\n        empty_block_device_info = {}\n\n        self.assertEqual(\n            driver.block_device_info_get_root(block_device_info), '/dev/sda')\n        self.assertEqual(\n            driver.block_device_info_get_root(empty_block_device_info), None)\n        self.assertEqual(\n            driver.block_device_info_get_root(None), None)\n\n        self.assertEqual(\n            driver.block_device_info_get_swap(block_device_info), swap)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['device_name'], None)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['swap_size'], 0)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['device_name'],\n            None)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['swap_size'],\n            0)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['device_name'], None)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['swap_size'], 0)\n\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(block_device_info),\n            ephemerals)\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(empty_block_device_info),\n            [])\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(None),\n            [])\n\n    def test_swap_is_usable(self):\n        self.assertFalse(driver.swap_is_usable(None))\n        self.assertFalse(driver.swap_is_usable({'device_name': None}))\n        self.assertFalse(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 0}))\n        self.assertTrue(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 1}))\n\n\nclass TestVirtDisk(test.TestCase):\n    def test_check_safe_path(self):\n        ret = disk_api._join_and_check_path_within_fs('/foo', 'etc',\n                                                      'something.conf')\n        self.assertEquals(ret, '/foo/etc/something.conf')\n\n    def test_check_unsafe_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._join_and_check_path_within_fs,\n                          '/foo', 'etc/../../../something.conf')\n\n    def test_inject_files_with_bad_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._inject_file_into_fs,\n                          '/tmp', '/etc/../../../../etc/passwd',\n                          'hax')\n", "code_before": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom nova import flags\nfrom nova import test\nfrom nova.virt import driver\n\nFLAGS = flags.FLAGS\n\n\nclass TestVirtDriver(test.TestCase):\n    def test_block_device(self):\n        swap = {'device_name': '/dev/sdb',\n                'swap_size': 1}\n        ephemerals = [{'num': 0,\n                       'virtual_name': 'ephemeral0',\n                       'device_name': '/dev/sdc1',\n                       'size': 1}]\n        block_device_mapping = [{'mount_device': '/dev/sde',\n                                 'device_path': 'fake_device'}]\n        block_device_info = {\n                'root_device_name': '/dev/sda',\n                'swap': swap,\n                'ephemerals': ephemerals,\n                'block_device_mapping': block_device_mapping}\n\n        empty_block_device_info = {}\n\n        self.assertEqual(\n            driver.block_device_info_get_root(block_device_info), '/dev/sda')\n        self.assertEqual(\n            driver.block_device_info_get_root(empty_block_device_info), None)\n        self.assertEqual(\n            driver.block_device_info_get_root(None), None)\n\n        self.assertEqual(\n            driver.block_device_info_get_swap(block_device_info), swap)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['device_name'], None)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['swap_size'], 0)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['device_name'],\n            None)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['swap_size'],\n            0)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['device_name'], None)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['swap_size'], 0)\n\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(block_device_info),\n            ephemerals)\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(empty_block_device_info),\n            [])\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(None),\n            [])\n\n    def test_swap_is_usable(self):\n        self.assertFalse(driver.swap_is_usable(None))\n        self.assertFalse(driver.swap_is_usable({'device_name': None}))\n        self.assertFalse(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 0}))\n        self.assertTrue(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 1}))\n", "patch": "@@ -15,8 +15,10 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+from nova import exception\n from nova import flags\n from nova import test\n+from nova.virt.disk import api as disk_api\n from nova.virt import driver\n \n FLAGS = flags.FLAGS\n@@ -81,3 +83,21 @@ def test_swap_is_usable(self):\n                                                 'swap_size': 0}))\n         self.assertTrue(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                 'swap_size': 1}))\n+\n+\n+class TestVirtDisk(test.TestCase):\n+    def test_check_safe_path(self):\n+        ret = disk_api._join_and_check_path_within_fs('/foo', 'etc',\n+                                                      'something.conf')\n+        self.assertEquals(ret, '/foo/etc/something.conf')\n+\n+    def test_check_unsafe_path(self):\n+        self.assertRaises(exception.Invalid,\n+                          disk_api._join_and_check_path_within_fs,\n+                          '/foo', 'etc/../../../something.conf')\n+\n+    def test_inject_files_with_bad_path(self):\n+        self.assertRaises(exception.Invalid,\n+                          disk_api._inject_file_into_fs,\n+                          '/tmp', '/etc/../../../../etc/passwd',\n+                          'hax')", "file_path": "files/2012_7/8", "file_language": "py", "file_name": "nova/tests/test_virt.py", "outdated_file_modify": 1, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/openstack/nova/raw/b0feaffdb2b1c51182b8dce41b367f3449af5dd9/nova%2Fvirt%2Fdisk%2Fapi.py", "code": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n#\n# Copyright 2011, Piston Cloud Computing, Inc.\n#\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nUtility methods to resize, repartition, and modify disk images.\n\nIncludes injection of SSH PGP keys into authorized_keys file.\n\n\"\"\"\n\nimport crypt\nimport json\nimport os\nimport random\nimport re\nimport tempfile\n\nfrom nova import exception\nfrom nova import flags\nfrom nova import log as logging\nfrom nova.openstack.common import cfg\nfrom nova import utils\nfrom nova.virt.disk import guestfs\nfrom nova.virt.disk import loop\nfrom nova.virt.disk import nbd\n\n\nLOG = logging.getLogger(__name__)\n\ndisk_opts = [\n    cfg.StrOpt('injected_network_template',\n               default='$pybasedir/nova/virt/interfaces.template',\n               help='Template file for injected network'),\n    cfg.ListOpt('img_handlers',\n                default=['loop', 'nbd', 'guestfs'],\n                help='Order of methods used to mount disk images'),\n\n    # NOTE(yamahata): ListOpt won't work because the command may include a\n    #                 comma. For example:\n    #\n    #                 mkfs.ext3 -O dir_index,extent -E stride=8,stripe-width=16\n    #                           --label %(fs_label)s %(target)s\n    #\n    #                 list arguments are comma separated and there is no way to\n    #                 escape such commas.\n    #\n    cfg.MultiStrOpt('virt_mkfs',\n                    default=[\n                      'default=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'linux=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'windows=mkfs.ntfs'\n                      ' --force --fast --label %(fs_label)s %(target)s',\n                      # NOTE(yamahata): vfat case\n                      #'windows=mkfs.vfat -n %(fs_label)s %(target)s',\n                      ],\n                    help='mkfs commands for ephemeral device. '\n                         'The format is <os_type>=<mkfs command>'),\n    ]\n\nFLAGS = flags.FLAGS\nFLAGS.register_opts(disk_opts)\n\n_MKFS_COMMAND = {}\n_DEFAULT_MKFS_COMMAND = None\n\n\nfor s in FLAGS.virt_mkfs:\n    # NOTE(yamahata): mkfs command may includes '=' for its options.\n    #                 So item.partition('=') doesn't work here\n    os_type, mkfs_command = s.split('=', 1)\n    if os_type:\n        _MKFS_COMMAND[os_type] = mkfs_command\n    if os_type == 'default':\n        _DEFAULT_MKFS_COMMAND = mkfs_command\n\n\n_QEMU_VIRT_SIZE_REGEX = re.compile('^virtual size: (.*) \\(([0-9]+) bytes\\)',\n                                   re.MULTILINE)\n\n\ndef mkfs(os_type, fs_label, target):\n    mkfs_command = (_MKFS_COMMAND.get(os_type, _DEFAULT_MKFS_COMMAND) or\n                    '') % locals()\n    if mkfs_command:\n        utils.execute(*mkfs_command.split())\n\n\ndef get_image_virtual_size(image):\n    out, _err = utils.execute('qemu-img', 'info', image)\n    m = _QEMU_VIRT_SIZE_REGEX.search(out)\n    return int(m.group(2))\n\n\ndef extend(image, size):\n    \"\"\"Increase image to size\"\"\"\n    # NOTE(MotoKen): check image virtual size before resize\n    virt_size = get_image_virtual_size(image)\n    if virt_size >= size:\n        return\n    utils.execute('qemu-img', 'resize', image, size)\n    # NOTE(vish): attempts to resize filesystem\n    utils.execute('e2fsck', '-fp', image, check_exit_code=False)\n    utils.execute('resize2fs', image, check_exit_code=False)\n\n\ndef bind(src, target, instance_name):\n    \"\"\"Bind device to a filesytem\"\"\"\n    if src:\n        utils.execute('touch', target, run_as_root=True)\n        utils.execute('mount', '-o', 'bind', src, target,\n                run_as_root=True)\n        s = os.stat(src)\n        cgroup_info = \"b %s:%s rwm\\n\" % (os.major(s.st_rdev),\n                                         os.minor(s.st_rdev))\n        cgroups_path = \\\n            \"/sys/fs/cgroup/devices/libvirt/lxc/%s/devices.allow\" \\\n            % instance_name\n        utils.execute('tee', cgroups_path,\n                      process_input=cgroup_info, run_as_root=True)\n\n\ndef unbind(target):\n    if target:\n        utils.execute('umount', target, run_as_root=True)\n\n\nclass _DiskImage(object):\n    \"\"\"Provide operations on a disk image file.\"\"\"\n\n    def __init__(self, image, partition=None, use_cow=False, mount_dir=None):\n        # These passed to each mounter\n        self.image = image\n        self.partition = partition\n        self.mount_dir = mount_dir\n\n        # Internal\n        self._mkdir = False\n        self._mounter = None\n        self._errors = []\n\n        # As a performance tweak, don't bother trying to\n        # directly loopback mount a cow image.\n        self.handlers = FLAGS.img_handlers[:]\n        if use_cow and 'loop' in self.handlers:\n            self.handlers.remove('loop')\n\n        if not self.handlers:\n            raise exception.Error(_('no capable image handler configured'))\n\n    @property\n    def errors(self):\n        \"\"\"Return the collated errors from all operations.\"\"\"\n        return '\\n--\\n'.join([''] + self._errors)\n\n    @staticmethod\n    def _handler_class(mode):\n        \"\"\"Look up the appropriate class to use based on MODE.\"\"\"\n        for cls in (loop.Mount, nbd.Mount, guestfs.Mount):\n            if cls.mode == mode:\n                return cls\n        raise exception.Error(_(\"unknown disk image handler: %s\") % mode)\n\n    def mount(self):\n        \"\"\"Mount a disk image, using the object attributes.\n\n        The first supported means provided by the mount classes is used.\n\n        True, or False is returned and the 'errors' attribute\n        contains any diagnostics.\n        \"\"\"\n        if self._mounter:\n            raise exception.Error(_('image already mounted'))\n\n        if not self.mount_dir:\n            self.mount_dir = tempfile.mkdtemp()\n            self._mkdir = True\n\n        try:\n            for h in self.handlers:\n                mounter_cls = self._handler_class(h)\n                mounter = mounter_cls(image=self.image,\n                                      partition=self.partition,\n                                      mount_dir=self.mount_dir)\n                if mounter.do_mount():\n                    self._mounter = mounter\n                    break\n                else:\n                    LOG.debug(mounter.error)\n                    self._errors.append(mounter.error)\n        finally:\n            if not self._mounter:\n                self.umount()  # rmdir\n\n        return bool(self._mounter)\n\n    def umount(self):\n        \"\"\"Unmount a disk image from the file system.\"\"\"\n        try:\n            if self._mounter:\n                self._mounter.do_umount()\n        finally:\n            if self._mkdir:\n                os.rmdir(self.mount_dir)\n\n\n# Public module functions\n\ndef inject_data(image,\n                key=None, net=None, metadata=None, admin_password=None,\n                partition=None, use_cow=False):\n    \"\"\"Injects a ssh key and optionally net data into a disk image.\n\n    it will mount the image as a fully partitioned disk and attempt to inject\n    into the specified partition number.\n\n    If partition is not specified it mounts the image as a single partition.\n\n    \"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            inject_data_into_fs(img.mount_dir,\n                                key, net, metadata, admin_password,\n                                utils.execute)\n        finally:\n            img.umount()\n    else:\n        raise exception.Error(img.errors)\n\n\ndef inject_files(image, files, partition=None, use_cow=False):\n    \"\"\"Injects arbitrary files into a disk image\"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            for (path, contents) in files:\n                _inject_file_into_fs(img.mount_dir, path, contents)\n        finally:\n            img.umount()\n    else:\n        raise exception.Error(img.errors)\n\n\ndef setup_container(image, container_dir=None, use_cow=False):\n    \"\"\"Setup the LXC container.\n\n    It will mount the loopback image to the container directory in order\n    to create the root filesystem for the container.\n\n    LXC does not support qcow2 images yet.\n    \"\"\"\n    try:\n        img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir)\n        if img.mount():\n            return img\n        else:\n            raise exception.Error(img.errors)\n    except Exception, exn:\n        LOG.exception(_('Failed to mount filesystem: %s'), exn)\n\n\ndef destroy_container(img):\n    \"\"\"Destroy the container once it terminates.\n\n    It will umount the container that is mounted,\n    and delete any  linked devices.\n\n    LXC does not support qcow2 images yet.\n    \"\"\"\n    try:\n        if img:\n            img.umount()\n    except Exception, exn:\n        LOG.exception(_('Failed to remove container: %s'), exn)\n\n\ndef inject_data_into_fs(fs, key, net, metadata, admin_password, execute):\n    \"\"\"Injects data into a filesystem already mounted by the caller.\n    Virt connections can call this directly if they mount their fs\n    in a different way to inject_data\n    \"\"\"\n    if key:\n        _inject_key_into_fs(key, fs, execute=execute)\n    if net:\n        _inject_net_into_fs(net, fs, execute=execute)\n    if metadata:\n        _inject_metadata_into_fs(metadata, fs, execute=execute)\n    if admin_password:\n        _inject_admin_password_into_fs(admin_password, fs, execute=execute)\n\n\ndef _join_and_check_path_within_fs(fs, *args):\n    '''os.path.join() with safety check for injected file paths.\n\n    Join the supplied path components and make sure that the\n    resulting path we are injecting into is within the\n    mounted guest fs.  Trying to be clever and specifying a\n    path with '..' in it will hit this safeguard.\n    '''\n    absolute_path = os.path.realpath(os.path.join(fs, *args))\n    if not absolute_path.startswith(os.path.realpath(fs) + '/'):\n        raise exception.Invalid(_('injected file path not valid'))\n    return absolute_path\n\n\ndef _inject_file_into_fs(fs, path, contents, append=False):\n    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n\n    args = []\n    if append:\n        args.append('-a')\n    args.append(absolute_path)\n\n    kwargs = dict(process_input=contents, run_as_root=True)\n\n    utils.execute('tee', *args, **kwargs)\n\n\ndef _inject_metadata_into_fs(metadata, fs, execute=None):\n    metadata = dict([(m.key, m.value) for m in metadata])\n    _inject_file_into_fs(fs, 'meta.js', json.dumps(metadata))\n\n\ndef _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n\n    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n\n    key_data = ''.join([\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ])\n\n    _inject_file_into_fs(fs, keyfile, key_data, append=True)\n\n\ndef _inject_net_into_fs(net, fs, execute=None):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n\n    netfile = os.path.join('etc', 'network', 'interfaces')\n    _inject_file_into_fs(fs, netfile, net)\n\n\ndef _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n\n    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n    os.unlink(tmp_shadow)\n\n\ndef _set_passwd(username, admin_passwd, passwd_file, shadow_file):\n    \"\"\"set the password for username to admin_passwd\n\n    The passwd_file is not modified.  The shadow_file is updated.\n    if the username is not found in both files, an exception is raised.\n\n    :param username: the username\n    :param encrypted_passwd: the  encrypted password\n    :param passwd_file: path to the passwd file\n    :param shadow_file: path to the shadow password file\n    :returns: nothing\n    :raises: exception.Error(), IOError()\n\n    \"\"\"\n    salt_set = ('abcdefghijklmnopqrstuvwxyz'\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                '0123456789./')\n    # encryption algo - id pairs for crypt()\n    algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''}\n\n    salt = 16 * ' '\n    salt = ''.join([random.choice(salt_set) for c in salt])\n\n    # crypt() depends on the underlying libc, and may not support all\n    # forms of hash. We try md5 first. If we get only 13 characters back,\n    # then the underlying crypt() didn't understand the '$n$salt' magic,\n    # so we fall back to DES.\n    # md5 is the default because it's widely supported. Although the\n    # local crypt() might support stronger SHA, the target instance\n    # might not.\n    encrypted_passwd = crypt.crypt(admin_passwd, algos['MD5'] + salt)\n    if len(encrypted_passwd) == 13:\n        encrypted_passwd = crypt.crypt(admin_passwd, algos['DES'] + salt)\n\n    try:\n        p_file = open(passwd_file, 'rb')\n        s_file = open(shadow_file, 'rb')\n\n        # username MUST exist in passwd file or it's an error\n        found = False\n        for entry in p_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                found = True\n                break\n        if not found:\n            msg = _('User %(username)s not found in password file.')\n            raise exception.Error(msg % username)\n\n        # update password in the shadow file.It's an error if the\n        # the user doesn't exist.\n        new_shadow = list()\n        found = False\n        for entry in s_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                split_entry[1] = encrypted_passwd\n                found = True\n            new_entry = ':'.join(split_entry)\n            new_shadow.append(new_entry)\n        s_file.close()\n        if not found:\n            msg = _('User %(username)s not found in shadow file.')\n            raise exception.Error(msg % username)\n        s_file = open(shadow_file, 'wb')\n        for entry in new_shadow:\n            s_file.write(entry)\n    finally:\n        p_file.close()\n        s_file.close()\n", "code_before": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n#\n# Copyright 2011, Piston Cloud Computing, Inc.\n#\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nUtility methods to resize, repartition, and modify disk images.\n\nIncludes injection of SSH PGP keys into authorized_keys file.\n\n\"\"\"\n\nimport crypt\nimport json\nimport os\nimport random\nimport re\nimport tempfile\n\nfrom nova import exception\nfrom nova import flags\nfrom nova import log as logging\nfrom nova.openstack.common import cfg\nfrom nova import utils\nfrom nova.virt.disk import guestfs\nfrom nova.virt.disk import loop\nfrom nova.virt.disk import nbd\n\n\nLOG = logging.getLogger(__name__)\n\ndisk_opts = [\n    cfg.StrOpt('injected_network_template',\n               default='$pybasedir/nova/virt/interfaces.template',\n               help='Template file for injected network'),\n    cfg.ListOpt('img_handlers',\n                default=['loop', 'nbd', 'guestfs'],\n                help='Order of methods used to mount disk images'),\n\n    # NOTE(yamahata): ListOpt won't work because the command may include a\n    #                 comma. For example:\n    #\n    #                 mkfs.ext3 -O dir_index,extent -E stride=8,stripe-width=16\n    #                           --label %(fs_label)s %(target)s\n    #\n    #                 list arguments are comma separated and there is no way to\n    #                 escape such commas.\n    #\n    cfg.MultiStrOpt('virt_mkfs',\n                    default=[\n                      'default=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'linux=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'windows=mkfs.ntfs'\n                      ' --force --fast --label %(fs_label)s %(target)s',\n                      # NOTE(yamahata): vfat case\n                      #'windows=mkfs.vfat -n %(fs_label)s %(target)s',\n                      ],\n                    help='mkfs commands for ephemeral device. '\n                         'The format is <os_type>=<mkfs command>'),\n    ]\n\nFLAGS = flags.FLAGS\nFLAGS.register_opts(disk_opts)\n\n_MKFS_COMMAND = {}\n_DEFAULT_MKFS_COMMAND = None\n\n\nfor s in FLAGS.virt_mkfs:\n    # NOTE(yamahata): mkfs command may includes '=' for its options.\n    #                 So item.partition('=') doesn't work here\n    os_type, mkfs_command = s.split('=', 1)\n    if os_type:\n        _MKFS_COMMAND[os_type] = mkfs_command\n    if os_type == 'default':\n        _DEFAULT_MKFS_COMMAND = mkfs_command\n\n\n_QEMU_VIRT_SIZE_REGEX = re.compile('^virtual size: (.*) \\(([0-9]+) bytes\\)',\n                                   re.MULTILINE)\n\n\ndef mkfs(os_type, fs_label, target):\n    mkfs_command = (_MKFS_COMMAND.get(os_type, _DEFAULT_MKFS_COMMAND) or\n                    '') % locals()\n    if mkfs_command:\n        utils.execute(*mkfs_command.split())\n\n\ndef get_image_virtual_size(image):\n    out, _err = utils.execute('qemu-img', 'info', image)\n    m = _QEMU_VIRT_SIZE_REGEX.search(out)\n    return int(m.group(2))\n\n\ndef extend(image, size):\n    \"\"\"Increase image to size\"\"\"\n    # NOTE(MotoKen): check image virtual size before resize\n    virt_size = get_image_virtual_size(image)\n    if virt_size >= size:\n        return\n    utils.execute('qemu-img', 'resize', image, size)\n    # NOTE(vish): attempts to resize filesystem\n    utils.execute('e2fsck', '-fp', image, check_exit_code=False)\n    utils.execute('resize2fs', image, check_exit_code=False)\n\n\ndef bind(src, target, instance_name):\n    \"\"\"Bind device to a filesytem\"\"\"\n    if src:\n        utils.execute('touch', target, run_as_root=True)\n        utils.execute('mount', '-o', 'bind', src, target,\n                run_as_root=True)\n        s = os.stat(src)\n        cgroup_info = \"b %s:%s rwm\\n\" % (os.major(s.st_rdev),\n                                         os.minor(s.st_rdev))\n        cgroups_path = \\\n            \"/sys/fs/cgroup/devices/libvirt/lxc/%s/devices.allow\" \\\n            % instance_name\n        utils.execute('tee', cgroups_path,\n                      process_input=cgroup_info, run_as_root=True)\n\n\ndef unbind(target):\n    if target:\n        utils.execute('umount', target, run_as_root=True)\n\n\nclass _DiskImage(object):\n    \"\"\"Provide operations on a disk image file.\"\"\"\n\n    def __init__(self, image, partition=None, use_cow=False, mount_dir=None):\n        # These passed to each mounter\n        self.image = image\n        self.partition = partition\n        self.mount_dir = mount_dir\n\n        # Internal\n        self._mkdir = False\n        self._mounter = None\n        self._errors = []\n\n        # As a performance tweak, don't bother trying to\n        # directly loopback mount a cow image.\n        self.handlers = FLAGS.img_handlers[:]\n        if use_cow and 'loop' in self.handlers:\n            self.handlers.remove('loop')\n\n        if not self.handlers:\n            raise exception.Error(_('no capable image handler configured'))\n\n    @property\n    def errors(self):\n        \"\"\"Return the collated errors from all operations.\"\"\"\n        return '\\n--\\n'.join([''] + self._errors)\n\n    @staticmethod\n    def _handler_class(mode):\n        \"\"\"Look up the appropriate class to use based on MODE.\"\"\"\n        for cls in (loop.Mount, nbd.Mount, guestfs.Mount):\n            if cls.mode == mode:\n                return cls\n        raise exception.Error(_(\"unknown disk image handler: %s\") % mode)\n\n    def mount(self):\n        \"\"\"Mount a disk image, using the object attributes.\n\n        The first supported means provided by the mount classes is used.\n\n        True, or False is returned and the 'errors' attribute\n        contains any diagnostics.\n        \"\"\"\n        if self._mounter:\n            raise exception.Error(_('image already mounted'))\n\n        if not self.mount_dir:\n            self.mount_dir = tempfile.mkdtemp()\n            self._mkdir = True\n\n        try:\n            for h in self.handlers:\n                mounter_cls = self._handler_class(h)\n                mounter = mounter_cls(image=self.image,\n                                      partition=self.partition,\n                                      mount_dir=self.mount_dir)\n                if mounter.do_mount():\n                    self._mounter = mounter\n                    break\n                else:\n                    LOG.debug(mounter.error)\n                    self._errors.append(mounter.error)\n        finally:\n            if not self._mounter:\n                self.umount()  # rmdir\n\n        return bool(self._mounter)\n\n    def umount(self):\n        \"\"\"Unmount a disk image from the file system.\"\"\"\n        try:\n            if self._mounter:\n                self._mounter.do_umount()\n        finally:\n            if self._mkdir:\n                os.rmdir(self.mount_dir)\n\n\n# Public module functions\n\ndef inject_data(image,\n                key=None, net=None, metadata=None, admin_password=None,\n                partition=None, use_cow=False):\n    \"\"\"Injects a ssh key and optionally net data into a disk image.\n\n    it will mount the image as a fully partitioned disk and attempt to inject\n    into the specified partition number.\n\n    If partition is not specified it mounts the image as a single partition.\n\n    \"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            inject_data_into_fs(img.mount_dir,\n                                key, net, metadata, admin_password,\n                                utils.execute)\n        finally:\n            img.umount()\n    else:\n        raise exception.Error(img.errors)\n\n\ndef inject_files(image, files, partition=None, use_cow=False):\n    \"\"\"Injects arbitrary files into a disk image\"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            for (path, contents) in files:\n                _inject_file_into_fs(img.mount_dir, path, contents)\n        finally:\n            img.umount()\n    else:\n        raise exception.Error(img.errors)\n\n\ndef setup_container(image, container_dir=None, use_cow=False):\n    \"\"\"Setup the LXC container.\n\n    It will mount the loopback image to the container directory in order\n    to create the root filesystem for the container.\n\n    LXC does not support qcow2 images yet.\n    \"\"\"\n    try:\n        img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir)\n        if img.mount():\n            return img\n        else:\n            raise exception.Error(img.errors)\n    except Exception, exn:\n        LOG.exception(_('Failed to mount filesystem: %s'), exn)\n\n\ndef destroy_container(img):\n    \"\"\"Destroy the container once it terminates.\n\n    It will umount the container that is mounted,\n    and delete any  linked devices.\n\n    LXC does not support qcow2 images yet.\n    \"\"\"\n    try:\n        if img:\n            img.umount()\n    except Exception, exn:\n        LOG.exception(_('Failed to remove container: %s'), exn)\n\n\ndef inject_data_into_fs(fs, key, net, metadata, admin_password, execute):\n    \"\"\"Injects data into a filesystem already mounted by the caller.\n    Virt connections can call this directly if they mount their fs\n    in a different way to inject_data\n    \"\"\"\n    if key:\n        _inject_key_into_fs(key, fs, execute=execute)\n    if net:\n        _inject_net_into_fs(net, fs, execute=execute)\n    if metadata:\n        _inject_metadata_into_fs(metadata, fs, execute=execute)\n    if admin_password:\n        _inject_admin_password_into_fs(admin_password, fs, execute=execute)\n\n\ndef _inject_file_into_fs(fs, path, contents):\n    absolute_path = os.path.join(fs, path.lstrip('/'))\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n    utils.execute('tee', absolute_path, process_input=contents,\n          run_as_root=True)\n\n\ndef _inject_metadata_into_fs(metadata, fs, execute=None):\n    metadata_path = os.path.join(fs, \"meta.js\")\n    metadata = dict([(m.key, m.value) for m in metadata])\n\n    utils.execute('tee', metadata_path,\n                  process_input=json.dumps(metadata), run_as_root=True)\n\n\ndef _inject_key_into_fs(key, fs, execute=None):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = os.path.join(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n    keyfile = os.path.join(sshdir, 'authorized_keys')\n    key_data = [\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ]\n    utils.execute('tee', '-a', keyfile,\n                  process_input=''.join(key_data), run_as_root=True)\n\n\ndef _inject_net_into_fs(net, fs, execute=None):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = os.path.join(os.path.join(fs, 'etc'), 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n    netfile = os.path.join(netdir, 'interfaces')\n    utils.execute('tee', netfile, process_input=net, run_as_root=True)\n\n\ndef _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    utils.execute('cp', os.path.join(fs, 'etc', 'passwd'), tmp_passwd,\n                  run_as_root=True)\n    utils.execute('cp', os.path.join(fs, 'etc', 'shadow'), tmp_shadow,\n                  run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, os.path.join(fs, 'etc', 'passwd'),\n                  run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, os.path.join(fs, 'etc', 'shadow'),\n                  run_as_root=True)\n    os.unlink(tmp_shadow)\n\n\ndef _set_passwd(username, admin_passwd, passwd_file, shadow_file):\n    \"\"\"set the password for username to admin_passwd\n\n    The passwd_file is not modified.  The shadow_file is updated.\n    if the username is not found in both files, an exception is raised.\n\n    :param username: the username\n    :param encrypted_passwd: the  encrypted password\n    :param passwd_file: path to the passwd file\n    :param shadow_file: path to the shadow password file\n    :returns: nothing\n    :raises: exception.Error(), IOError()\n\n    \"\"\"\n    salt_set = ('abcdefghijklmnopqrstuvwxyz'\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                '0123456789./')\n    # encryption algo - id pairs for crypt()\n    algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''}\n\n    salt = 16 * ' '\n    salt = ''.join([random.choice(salt_set) for c in salt])\n\n    # crypt() depends on the underlying libc, and may not support all\n    # forms of hash. We try md5 first. If we get only 13 characters back,\n    # then the underlying crypt() didn't understand the '$n$salt' magic,\n    # so we fall back to DES.\n    # md5 is the default because it's widely supported. Although the\n    # local crypt() might support stronger SHA, the target instance\n    # might not.\n    encrypted_passwd = crypt.crypt(admin_passwd, algos['MD5'] + salt)\n    if len(encrypted_passwd) == 13:\n        encrypted_passwd = crypt.crypt(admin_passwd, algos['DES'] + salt)\n\n    try:\n        p_file = open(passwd_file, 'rb')\n        s_file = open(shadow_file, 'rb')\n\n        # username MUST exist in passwd file or it's an error\n        found = False\n        for entry in p_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                found = True\n                break\n        if not found:\n            msg = _('User %(username)s not found in password file.')\n            raise exception.Error(msg % username)\n\n        # update password in the shadow file.It's an error if the\n        # the user doesn't exist.\n        new_shadow = list()\n        found = False\n        for entry in s_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                split_entry[1] = encrypted_passwd\n                found = True\n            new_entry = ':'.join(split_entry)\n            new_shadow.append(new_entry)\n        s_file.close()\n        if not found:\n            msg = _('User %(username)s not found in shadow file.')\n            raise exception.Error(msg % username)\n        s_file = open(shadow_file, 'wb')\n        for entry in new_shadow:\n            s_file.write(entry)\n    finally:\n        p_file.close()\n        s_file.close()\n", "patch": "@@ -306,20 +306,39 @@ def inject_data_into_fs(fs, key, net, metadata, admin_password, execute):\n         _inject_admin_password_into_fs(admin_password, fs, execute=execute)\n \n \n-def _inject_file_into_fs(fs, path, contents):\n-    absolute_path = os.path.join(fs, path.lstrip('/'))\n+def _join_and_check_path_within_fs(fs, *args):\n+    '''os.path.join() with safety check for injected file paths.\n+\n+    Join the supplied path components and make sure that the\n+    resulting path we are injecting into is within the\n+    mounted guest fs.  Trying to be clever and specifying a\n+    path with '..' in it will hit this safeguard.\n+    '''\n+    absolute_path = os.path.realpath(os.path.join(fs, *args))\n+    if not absolute_path.startswith(os.path.realpath(fs) + '/'):\n+        raise exception.Invalid(_('injected file path not valid'))\n+    return absolute_path\n+\n+\n+def _inject_file_into_fs(fs, path, contents, append=False):\n+    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n+\n     parent_dir = os.path.dirname(absolute_path)\n     utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n-    utils.execute('tee', absolute_path, process_input=contents,\n-          run_as_root=True)\n+\n+    args = []\n+    if append:\n+        args.append('-a')\n+    args.append(absolute_path)\n+\n+    kwargs = dict(process_input=contents, run_as_root=True)\n+\n+    utils.execute('tee', *args, **kwargs)\n \n \n def _inject_metadata_into_fs(metadata, fs, execute=None):\n-    metadata_path = os.path.join(fs, \"meta.js\")\n     metadata = dict([(m.key, m.value) for m in metadata])\n-\n-    utils.execute('tee', metadata_path,\n-                  process_input=json.dumps(metadata), run_as_root=True)\n+    _inject_file_into_fs(fs, 'meta.js', json.dumps(metadata))\n \n \n def _inject_key_into_fs(key, fs, execute=None):\n@@ -328,33 +347,36 @@ def _inject_key_into_fs(key, fs, execute=None):\n     key is an ssh key string.\n     fs is the path to the base of the filesystem into which to inject the key.\n     \"\"\"\n-    sshdir = os.path.join(fs, 'root', '.ssh')\n+    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n     utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n     utils.execute('chown', 'root', sshdir, run_as_root=True)\n     utils.execute('chmod', '700', sshdir, run_as_root=True)\n-    keyfile = os.path.join(sshdir, 'authorized_keys')\n-    key_data = [\n+\n+    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n+\n+    key_data = ''.join([\n         '\\n',\n         '# The following ssh key was injected by Nova',\n         '\\n',\n         key.strip(),\n         '\\n',\n-    ]\n-    utils.execute('tee', '-a', keyfile,\n-                  process_input=''.join(key_data), run_as_root=True)\n+    ])\n+\n+    _inject_file_into_fs(fs, keyfile, key_data, append=True)\n \n \n def _inject_net_into_fs(net, fs, execute=None):\n     \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n \n     net is the contents of /etc/network/interfaces.\n     \"\"\"\n-    netdir = os.path.join(os.path.join(fs, 'etc'), 'network')\n+    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n     utils.execute('mkdir', '-p', netdir, run_as_root=True)\n     utils.execute('chown', 'root:root', netdir, run_as_root=True)\n     utils.execute('chmod', 755, netdir, run_as_root=True)\n-    netfile = os.path.join(netdir, 'interfaces')\n-    utils.execute('tee', netfile, process_input=net, run_as_root=True)\n+\n+    netfile = os.path.join('etc', 'network', 'interfaces')\n+    _inject_file_into_fs(fs, netfile, net)\n \n \n def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n@@ -379,16 +401,15 @@ def _inject_admin_password_into_fs(admin_passwd, fs, execute=None):\n     fd, tmp_shadow = tempfile.mkstemp()\n     os.close(fd)\n \n-    utils.execute('cp', os.path.join(fs, 'etc', 'passwd'), tmp_passwd,\n-                  run_as_root=True)\n-    utils.execute('cp', os.path.join(fs, 'etc', 'shadow'), tmp_shadow,\n-                  run_as_root=True)\n+    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n+    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n+\n+    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n+    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n     _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n-    utils.execute('cp', tmp_passwd, os.path.join(fs, 'etc', 'passwd'),\n-                  run_as_root=True)\n+    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n     os.unlink(tmp_passwd)\n-    utils.execute('cp', tmp_shadow, os.path.join(fs, 'etc', 'shadow'),\n-                  run_as_root=True)\n+    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n     os.unlink(tmp_shadow)\n \n ", "file_path": "files/2012_7/9", "file_language": "py", "file_name": "nova/virt/disk/api.py", "outdated_file_modify": 1, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 1, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
