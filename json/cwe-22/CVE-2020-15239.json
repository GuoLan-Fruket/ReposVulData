{"index": 5016, "cve_id": "CVE-2020-15239", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "In xmpp-http-upload before version 0.4.0, when the GET method is attacked, attackers can read files which have a `.data` suffix and which are accompanied by a JSON file with the `.meta` suffix. This can lead to Information Disclosure and in some shared-hosting scenarios also to circumvention of authentication or other limitations on the outbound (GET) traffic. For example, in a scenario where a single server has multiple instances of the application running (with separate DATA_ROOT settings), an attacker who has knowledge about the directory structure is able to read files from any other instance to which the process has read access. If instances have individual authentication (for example, HTTP authentication via a reverse proxy, source IP based filtering) or other restrictions (such as quotas), attackers may circumvent those limits in such a scenario by using the Directory Traversal to retrieve data from the other instances. If the associated XMPP server (or anyone knowing the SECRET_KEY) is malicious, they can write files outside the DATA_ROOT. The files which are written are constrained to have the `.meta` and the `.data` suffixes; the `.meta` file will contain the JSON with the Content-Type of the original request and the `.data` file will contain the payload. The issue is patched in version 0.4.0.", "cvss": "3.5", "publish_date": "October 22, 2020", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "CHANGED", "C": "LOW", "I": "NONE", "A": "NONE", "commit_id": "82056540191e89f0cd697c81f57714c00962ed75", "commit_message": "Simplify path handling, use safe_join\n\nThe current implementation of sanitized_join did not handle\n\"..\" properly. The problem is, that .absolute() does not do\nwhat .resolve() does, but .resolve() does not work on non\nexistant paths.\n\nAnyway, flask has a function exactly for this: safe_join.\n\nSo let's use that one.\n\nWhile at it, simplified the whole path handling a bit.", "commit_date": "2020-10-05T23:06:21Z", "project": "horazont/xmpp-http-upload", "url": "https://api.github.com/repos/horazont/xmpp-http-upload/commits/82056540191e89f0cd697c81f57714c00962ed75", "html_url": "https://github.com/horazont/xmpp-http-upload/commit/82056540191e89f0cd697c81f57714c00962ed75", "windows_before": [{"commit_id": "f0fc7443c06a0e8aecb5696fc2bd513a2cc8b611", "commit_date": "Sun Apr 29 16:31:12 2018 +0200", "commit_message": "Bump version to 0.3.0", "files_name": ["setup.py"]}, {"commit_id": "ada8073b29a4a14036a08e09885ca9e01c33f86c", "commit_date": "Sun Apr 29 16:30:48 2018 +0200", "commit_message": "Add documentation for new CORS setting", "files_name": ["README.rst"]}, {"commit_id": "0e38af0642b6a6d4d9596cb2c416b521eaf6cc0d", "commit_date": "Sun Apr 29 16:29:37 2018 +0200", "commit_message": "Merge commit 'refs/pull/4/head' of github.com:horazont/xmpp-http-upload", "files_name": ["68d56552e13296b130782d8446b605c5353bddcf - Sun Apr 29 16:28:35 2018 +0200 : Add another bandaid to forbid embedding of things in frames", "xhu.py"]}, {"commit_id": "045dd82b0c22b8e5c7137721702884fbc1213160", "commit_date": "Mon Apr 16 16:15:40 2018 +0000", "commit_message": "Add flask-cors as dependency", "files_name": ["setup.py"]}, {"commit_id": "069526edf34d848c518f8f57998d6b03a1044b88", "commit_date": "Sun Apr 15 08:04:53 2018 +0000", "commit_message": "Add CORS support", "files_name": ["config.example.py", "xhu.py"]}, {"commit_id": "bb5614b5dd1816233c123ddfe0b62e8eb4f36fcf", "commit_date": "Tue Jan 23 10:02:43 2018 +0100", "commit_message": "Merge commit 'refs/pull/2/head' of github.com:horazont/xmpp-http-upload", "files_name": ["cb2a1f30a648ba075d2446dd2f5265218a52c05a - Tue Jan 23 15:55:39 2018 +0700 : Use utf-8 instead of ascii to encode the HMAC input string", "xhu.py"]}, {"commit_id": "1ce2849b1d14c80116709217d7956b4f79a2d17b", "commit_date": "Sun Jan 21 11:14:10 2018 +0100", "commit_message": "fix readme", "files_name": ["README.rst"]}, {"commit_id": "747f5e0d124133b4891e692a8654ff18ae6df33f", "commit_date": "Sun Jan 21 10:12:41 2018 +0100", "commit_message": "use localhost in nginx example", "files_name": ["contrib/nginx-example.conf"]}, {"commit_id": "d2c3a556db5d151242d755f8d356522f694367b8", "commit_date": "Fri Jan 19 12:52:29 2018 +0100", "commit_message": "change flask path in systemd unit", "files_name": ["contrib/xmpp-http-upload.service"]}, {"commit_id": "e5c02a9678552747009f027dfa001dfe64afae61", "commit_date": "Fri Jan 19 12:47:34 2018 +0100", "commit_message": "Merge branch 'master' into examples", "files_name": ["21da0ec33311fe0574fabc052d7141fe117a3591 - Fri Jan 19 09:38:47 2018 +0100 : Add note about security", "README.rst"]}, {"commit_id": "a039fc96917e307fd26cacb1b27d30fbf43ea2f0", "commit_date": "Sat Dec 30 16:58:32 2017 +0100", "commit_message": "Update readme", "files_name": ["README.rst"]}, {"commit_id": "1600cc689985ad7a07cbbe43a2629738f259faff", "commit_date": "Sat Dec 30 13:29:08 2017 +0100", "commit_message": "add systemd unit", "files_name": ["contrib/xmpp-http-upload.service"]}, {"commit_id": "0654b7a22c1a7b98420e4cd06b97ac6b35ba28b0", "commit_date": "Sat Dec 30 13:28:33 2017 +0100", "commit_message": "add nginx config example", "files_name": ["contrib/nginx-example.conf"]}, {"commit_id": "0e3c26fdb11ef66735c005e1ea8cbb8537e2cfc9", "commit_date": "Sat Dec 30 13:28:09 2017 +0100", "commit_message": "add example config file", "files_name": ["config.example.py"]}, {"commit_id": "d89d565ae7fbe274f4f1da68d4ad8bd5741cb175", "commit_date": "Wed Nov 15 17:17:06 2017 +0100", "commit_message": "Note about incompatiblity with mod_http_upload", "files_name": ["README.rst"]}, {"commit_id": "4cd3eff29a26dfb0b270bb52fc2e9db085b76ce5", "commit_date": "Wed Nov 15 17:14:13 2017 +0100", "commit_message": "Release of version 0.2.0", "files_name": ["setup.py"]}, {"commit_id": "1ed7e7d0547cafc56aeea7db32e64efb05011cd6", "commit_date": "Wed Nov 15 17:14:07 2017 +0100", "commit_message": "Sort out license things", "files_name": ["COPYING", "MANIFEST.in", "xhu.py"]}, {"commit_id": "96eedad14e4e217516300b75fec7ff62f23efeda", "commit_date": "Wed Nov 15 17:12:04 2017 +0100", "commit_message": "Update readme with new option", "files_name": ["README.rst"]}, {"commit_id": "f939ac860d1f3388946210c87c6e6c5ef7e5473f", "commit_date": "Wed Nov 15 17:06:16 2017 +0100", "commit_message": "Fix X-Content-Type-Options header", "files_name": ["xhu.py"]}, {"commit_id": "d8b4a2f8fc644d53ed43865b68c9136ac6aceced", "commit_date": "Wed Nov 15 16:59:39 2017 +0100", "commit_message": "Add security headers", "files_name": ["xhu.py"]}, {"commit_id": "af2de3f9a831286fef2daafe5d6c76ed698b0090", "commit_date": "Wed Nov 15 16:40:28 2017 +0100", "commit_message": "Functional implementation", "files_name": ["README.rst", "setup.py", "xhu.py"]}, {"commit_id": "55c7131c3451796b803d258ab5122c4ca784c1f4", "commit_date": "Wed Nov 15 15:16:05 2017 +0100", "commit_message": "Initialise repository", "files_name": [".gitignore", "README.rst", "xhu.py"]}], "windows_after": [{"commit_id": "741157cb9215b2d8968a2627b8e3383bccd3458c", "commit_date": "Tue Oct 6 17:59:56 2020 +0200", "commit_message": "Merge pull request #12 from ChristianTacke/pr/safe_join", "files_name": ["28c25b67b43b864ac04bd374a46135e78b4e84d0 - Tue Oct 6 18:11:21 2020 +0200 : Bump version number to 0.4.0", "setup.py"]}, {"commit_id": "746d9db310313c60e4465554842421dd2a3744e7", "commit_date": "Tue Oct 6 21:29:10 2020 +0200", "commit_message": "Update flask dependency", "files_name": ["setup.py"]}, {"commit_id": "1a035fa118afc1e3d4b057b572e15f5066391c3d", "commit_date": "Wed May 25 01:56:41 2022 -0400", "commit_message": "Drop flask.helpers.safe_join for werkzeug.utils.safe_join", "files_name": ["xhu.py"]}, {"commit_id": "5a1a230de655d48bbd0bb8a2a21f4798c3c19cfb", "commit_date": "Wed May 25 13:59:33 2022 +0200", "commit_message": "Merge pull request #14 from anjandev/flash", "files_name": ["9dcec63b66f43f39df7b592346877b350ed2a81b - Mon Oct 24 09:44:18 2022 +0200 : Werkzeug breaking APIs again", "xhu.py"]}], "parents": [{"commit_id_before": "f0fc7443c06a0e8aecb5696fc2bd513a2cc8b611", "url_before": "https://api.github.com/repos/horazont/xmpp-http-upload/commits/f0fc7443c06a0e8aecb5696fc2bd513a2cc8b611", "html_url_before": "https://github.com/horazont/xmpp-http-upload/commit/f0fc7443c06a0e8aecb5696fc2bd513a2cc8b611"}], "details": [{"raw_url": "https://github.com/horazont/xmpp-http-upload/raw/82056540191e89f0cd697c81f57714c00962ed75/xhu.py", "code": "########################################################################\n# File name: xhu.py\n# This file is part of: xmpp-http-upload\n#\n# LICENSE\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public\n# License along with this program.  If not, see\n# <http://www.gnu.org/licenses/>.\n#\n########################################################################\nimport contextlib\nimport errno\nimport fnmatch\nimport json\nimport hashlib\nimport hmac\nimport pathlib\nimport typing\n\nimport flask\nimport werkzeug.exceptions\n\napp = flask.Flask(\"xmpp-http-upload\")\napp.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")\napplication = app\n\nif app.config['ENABLE_CORS']:\n    from flask_cors import CORS\n    CORS(app)\n\n\ndef get_paths(root: str, sub_path: str) \\\n        -> typing.Tuple[pathlib.Path, pathlib.Path]:\n    base_path = flask.safe_join(root, sub_path)\n    data_file = pathlib.Path(base_path + \".data\")\n    metadata_file = pathlib.Path(base_path + \".meta\")\n\n    return data_file, metadata_file\n\n\ndef load_metadata(metadata_file):\n    with metadata_file.open(\"r\") as f:\n        return json.load(f)\n\n\ndef get_info(path: str) -> typing.Tuple[\n        pathlib.Path,\n        dict]:\n    data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n\n    return data_file, load_metadata(metadata_file)\n\n\n@contextlib.contextmanager\ndef write_file(at: pathlib.Path):\n    with at.open(\"xb\") as f:\n        try:\n            yield f\n        except:  # NOQA\n            at.unlink()\n            raise\n\n\n@app.route(\"/\")\ndef index():\n    return flask.Response(\n        \"Welcome to XMPP HTTP Upload. State your business.\",\n        mimetype=\"text/plain\",\n    )\n\n\ndef stream_file(src, dest, nbytes):\n    while nbytes > 0:\n        data = src.read(min(nbytes, 4096))\n        if not data:\n            break\n        dest.write(data)\n        nbytes -= len(data)\n\n    if nbytes > 0:\n        raise EOFError\n\n\n@app.route(\"/<path:path>\", methods=[\"PUT\"])\ndef put_file(path):\n    try:\n        data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n    except werkzeug.exceptions.NotFound:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n\n\ndef generate_headers(response_headers, metadata_headers):\n    for key, value in metadata_headers.items():\n        response_headers[key] = value\n\n    content_type = metadata_headers[\"Content-Type\"]\n    for mimetype_glob in app.config.get(\"NON_ATTACHMENT_MIME_TYPES\", []):\n        if fnmatch.fnmatch(content_type, mimetype_glob):\n            break\n    else:\n        response_headers[\"Content-Disposition\"] = \"attachment\"\n\n    response_headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response_headers[\"X-Frame-Options\"] = \"DENY\"\n    response_headers[\"Content-Security-Policy\"] = \"default-src 'none'; frame-ancestors 'none'; sandbox\"\n\n\n@app.route(\"/<path:path>\", methods=[\"HEAD\"])\ndef head_file(path):\n    try:\n        data_file, metadata = get_info(path)\n\n        stat = data_file.stat()\n    except (OSError, werkzeug.exceptions.NotFound):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.Response()\n    response.headers[\"Content-Length\"] = str(stat.st_size)\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n\n\n@app.route(\"/<path:path>\", methods=[\"GET\"])\ndef get_file(path):\n    try:\n        data_file, metadata = get_info(path)\n    except (OSError, werkzeug.exceptions.NotFound):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.make_response(flask.send_file(\n        str(data_file),\n    ))\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n", "code_before": "########################################################################\n# File name: xhu.py\n# This file is part of: xmpp-http-upload\n#\n# LICENSE\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public\n# License along with this program.  If not, see\n# <http://www.gnu.org/licenses/>.\n#\n########################################################################\nimport contextlib\nimport errno\nimport fnmatch\nimport json\nimport hashlib\nimport hmac\nimport pathlib\nimport typing\n\nimport flask\n\napp = flask.Flask(\"xmpp-http-upload\")\napp.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")\napplication = app\n\nif app.config['ENABLE_CORS']:\n    from flask_cors import CORS\n    CORS(app)\n\n\ndef sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:\n    result = (root / path).absolute()\n    if not str(result).startswith(str(root) + \"/\"):\n        raise ValueError(\"resulting path is outside root\")\n    return result\n\n\ndef get_paths(base_path: pathlib.Path):\n    data_file = pathlib.Path(str(base_path) + \".data\")\n    metadata_file = pathlib.Path(str(base_path) + \".meta\")\n\n    return data_file, metadata_file\n\n\ndef load_metadata(metadata_file):\n    with metadata_file.open(\"r\") as f:\n        return json.load(f)\n\n\ndef get_info(path: str, root: pathlib.Path) -> typing.Tuple[\n        pathlib.Path,\n        dict]:\n    dest_path = sanitized_join(\n        path,\n        pathlib.Path(app.config[\"DATA_ROOT\"]),\n    )\n\n    data_file, metadata_file = get_paths(dest_path)\n\n    return data_file, load_metadata(metadata_file)\n\n\n@contextlib.contextmanager\ndef write_file(at: pathlib.Path):\n    with at.open(\"xb\") as f:\n        try:\n            yield f\n        except:  # NOQA\n            at.unlink()\n            raise\n\n\n@app.route(\"/\")\ndef index():\n    return flask.Response(\n        \"Welcome to XMPP HTTP Upload. State your business.\",\n        mimetype=\"text/plain\",\n    )\n\n\ndef stream_file(src, dest, nbytes):\n    while nbytes > 0:\n        data = src.read(min(nbytes, 4096))\n        if not data:\n            break\n        dest.write(data)\n        nbytes -= len(data)\n\n    if nbytes > 0:\n        raise EOFError\n\n\n@app.route(\"/<path:path>\", methods=[\"PUT\"])\ndef put_file(path):\n    try:\n        dest_path = sanitized_join(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"]),\n        )\n    except ValueError:\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    verification_key = flask.request.args.get(\"v\", \"\")\n    length = int(flask.request.headers.get(\"Content-Length\", 0))\n    hmac_input = \"{} {}\".format(path, length).encode(\"utf-8\")\n    key = app.config[\"SECRET_KEY\"]\n    mac = hmac.new(key, hmac_input, hashlib.sha256)\n    digest = mac.hexdigest()\n\n    if not hmac.compare_digest(digest, verification_key):\n        return flask.Response(\n            \"Invalid verification key\",\n            403,\n            mimetype=\"text/plain\",\n        )\n\n    content_type = flask.request.headers.get(\n        \"Content-Type\",\n        \"application/octet-stream\",\n    )\n\n    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n    data_file, metadata_file = get_paths(dest_path)\n\n    try:\n        with write_file(data_file) as fout:\n            stream_file(flask.request.stream, fout, length)\n\n            with metadata_file.open(\"x\") as f:\n                json.dump(\n                    {\n                        \"headers\": {\"Content-Type\": content_type},\n                    },\n                    f,\n                )\n    except EOFError:\n        return flask.Response(\n            \"Bad Request\",\n            400,\n            mimetype=\"text/plain\",\n        )\n    except OSError as exc:\n        if exc.errno == errno.EEXIST:\n            return flask.Response(\n                \"Conflict\",\n                409,\n                mimetype=\"text/plain\",\n            )\n        raise\n\n    return flask.Response(\n        \"Created\",\n        201,\n        mimetype=\"text/plain\",\n    )\n\n\ndef generate_headers(response_headers, metadata_headers):\n    for key, value in metadata_headers.items():\n        response_headers[key] = value\n\n    content_type = metadata_headers[\"Content-Type\"]\n    for mimetype_glob in app.config.get(\"NON_ATTACHMENT_MIME_TYPES\", []):\n        if fnmatch.fnmatch(content_type, mimetype_glob):\n            break\n    else:\n        response_headers[\"Content-Disposition\"] = \"attachment\"\n\n    response_headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response_headers[\"X-Frame-Options\"] = \"DENY\"\n    response_headers[\"Content-Security-Policy\"] = \"default-src 'none'; frame-ancestors 'none'; sandbox\"\n\n\n@app.route(\"/<path:path>\", methods=[\"HEAD\"])\ndef head_file(path):\n    try:\n        data_file, metadata = get_info(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"])\n        )\n\n        stat = data_file.stat()\n    except (OSError, ValueError):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.Response()\n    response.headers[\"Content-Length\"] = str(stat.st_size)\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n\n\n@app.route(\"/<path:path>\", methods=[\"GET\"])\ndef get_file(path):\n    try:\n        data_file, metadata = get_info(\n            path,\n            pathlib.Path(app.config[\"DATA_ROOT\"])\n        )\n    except (OSError, ValueError):\n        return flask.Response(\n            \"Not Found\",\n            404,\n            mimetype=\"text/plain\",\n        )\n\n    response = flask.make_response(flask.send_file(\n        str(data_file),\n    ))\n    generate_headers(\n        response.headers,\n        metadata[\"headers\"],\n    )\n    return response\n", "patch": "@@ -29,6 +29,7 @@\n import typing\n \n import flask\n+import werkzeug.exceptions\n \n app = flask.Flask(\"xmpp-http-upload\")\n app.config.from_envvar(\"XMPP_HTTP_UPLOAD_CONFIG\")\n@@ -39,16 +40,11 @@\n     CORS(app)\n \n \n-def sanitized_join(path: str, root: pathlib.Path) -> pathlib.Path:\n-    result = (root / path).absolute()\n-    if not str(result).startswith(str(root) + \"/\"):\n-        raise ValueError(\"resulting path is outside root\")\n-    return result\n-\n-\n-def get_paths(base_path: pathlib.Path):\n-    data_file = pathlib.Path(str(base_path) + \".data\")\n-    metadata_file = pathlib.Path(str(base_path) + \".meta\")\n+def get_paths(root: str, sub_path: str) \\\n+        -> typing.Tuple[pathlib.Path, pathlib.Path]:\n+    base_path = flask.safe_join(root, sub_path)\n+    data_file = pathlib.Path(base_path + \".data\")\n+    metadata_file = pathlib.Path(base_path + \".meta\")\n \n     return data_file, metadata_file\n \n@@ -58,15 +54,10 @@ def load_metadata(metadata_file):\n         return json.load(f)\n \n \n-def get_info(path: str, root: pathlib.Path) -> typing.Tuple[\n+def get_info(path: str) -> typing.Tuple[\n         pathlib.Path,\n         dict]:\n-    dest_path = sanitized_join(\n-        path,\n-        pathlib.Path(app.config[\"DATA_ROOT\"]),\n-    )\n-\n-    data_file, metadata_file = get_paths(dest_path)\n+    data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n \n     return data_file, load_metadata(metadata_file)\n \n@@ -104,11 +95,8 @@ def stream_file(src, dest, nbytes):\n @app.route(\"/<path:path>\", methods=[\"PUT\"])\n def put_file(path):\n     try:\n-        dest_path = sanitized_join(\n-            path,\n-            pathlib.Path(app.config[\"DATA_ROOT\"]),\n-        )\n-    except ValueError:\n+        data_file, metadata_file = get_paths(app.config[\"DATA_ROOT\"], path)\n+    except werkzeug.exceptions.NotFound:\n         return flask.Response(\n             \"Not Found\",\n             404,\n@@ -134,8 +122,7 @@ def put_file(path):\n         \"application/octet-stream\",\n     )\n \n-    dest_path.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n-    data_file, metadata_file = get_paths(dest_path)\n+    data_file.parent.mkdir(parents=True, exist_ok=True, mode=0o770)\n \n     try:\n         with write_file(data_file) as fout:\n@@ -189,13 +176,10 @@ def generate_headers(response_headers, metadata_headers):\n @app.route(\"/<path:path>\", methods=[\"HEAD\"])\n def head_file(path):\n     try:\n-        data_file, metadata = get_info(\n-            path,\n-            pathlib.Path(app.config[\"DATA_ROOT\"])\n-        )\n+        data_file, metadata = get_info(path)\n \n         stat = data_file.stat()\n-    except (OSError, ValueError):\n+    except (OSError, werkzeug.exceptions.NotFound):\n         return flask.Response(\n             \"Not Found\",\n             404,\n@@ -214,11 +198,8 @@ def head_file(path):\n @app.route(\"/<path:path>\", methods=[\"GET\"])\n def get_file(path):\n     try:\n-        data_file, metadata = get_info(\n-            path,\n-            pathlib.Path(app.config[\"DATA_ROOT\"])\n-        )\n-    except (OSError, ValueError):\n+        data_file, metadata = get_info(path)\n+    except (OSError, werkzeug.exceptions.NotFound):\n         return flask.Response(\n             \"Not Found\",\n             404,", "file_path": "files/2020_10/75", "file_language": "py", "file_name": "xhu.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
