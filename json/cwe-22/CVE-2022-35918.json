{"index": 8851, "cve_id": "CVE-2022-35918", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Streamlit is a data oriented application development framework for python. Users hosting Streamlit app(s) that use custom components are vulnerable to a directory traversal attack that could leak data from their web server file-system such as: server logs, world readable files, and potentially other sensitive information. An attacker can craft a malicious URL with file paths and the streamlit server would process that URL and return the contents of that file. This issue has been resolved in version 1.11.1. Users are advised to upgrade. There are no known workarounds for this issue.", "cvss": "5.3", "publish_date": "August 1, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "NONE", "I": "NONE", "A": "LOW", "commit_id": "80d9979d5f4a00217743d607078a1d867fad8acf", "commit_message": "Ignore component requests outside of the component root", "commit_date": "2022-07-27T18:30:37Z", "project": "streamlit/streamlit", "url": "https://api.github.com/repos/streamlit/streamlit/commits/80d9979d5f4a00217743d607078a1d867fad8acf", "html_url": "https://github.com/streamlit/streamlit/commit/80d9979d5f4a00217743d607078a1d867fad8acf", "windows_before": [{"commit_id": "da3f6733b39fd3fbd09992781c5a8ea1d3cc087e", "commit_date": "Wed Jul 27 10:50:56 2022 -0700", "commit_message": "Ignore component requests outside of the component root (#5046)", "files_name": ["lib/streamlit/web/server/component_request_handler.py", "lib/tests/streamlit/web/server/component_request_handler_test.py"]}, {"commit_id": "710b7acdb89a99b184d601f2de8e5bc828aa43cd", "commit_date": "Tue Jul 26 10:20:19 2022 -0700", "commit_message": "Handle old memo persist format files (#5035)", "files_name": ["lib/streamlit/caching/memo_decorator.py", "lib/tests/streamlit/caching/memo_test.py"]}, {"commit_id": "d33294c83cfd72955856c7d9d75c2ca1c1766579", "commit_date": "Mon Jul 25 23:13:01 2022 -0700", "commit_message": "Ensure \"script_path\" fields returned by get_pages are always absolute paths (#5023)", "files_name": ["lib/streamlit/source_util.py"]}, {"commit_id": "ae8a5699ea64b92dacb8b3597bab6aac865fbcc2", "commit_date": "Mon Jul 25 17:59:13 2022 -0700", "commit_message": "Don't install streamlit locally when making packages (#5034)", "files_name": ["Makefile"]}, {"commit_id": "bd406d0df060cec51364176a8eb552c3a643c949", "commit_date": "Mon Jul 25 11:10:28 2022 -0700", "commit_message": "Update plotly.js version (#5022)", "files_name": ["e2e/specs/st_plotly_chart.spec.js", "frontend/yarn.lock"]}, {"commit_id": "be82f0699ce3343c28ed24ddfd4fdbc8c8acac8b", "commit_date": "Mon Jul 25 11:10:05 2022 -0700", "commit_message": "Don't explode when a list-like dataframe is passed to st.radio (#5021)", "files_name": ["e2e/scripts/st_radio.py", "e2e/specs/st_radio.spec.js", "lib/streamlit/elements/radio.py"]}, {"commit_id": "f42f5acacda67a12a4f165a7b8204c3ab489931a", "commit_date": "Mon Jul 25 16:37:04 2022 +0530", "commit_message": "List languages supported by st.code for syntax highlighting (#5029)", "files_name": ["lib/streamlit/elements/markdown.py"]}, {"commit_id": "756072522ee4a473158355f025f36e1dbd7b74a2", "commit_date": "Sat Jul 23 17:20:22 2022 +0400", "commit_message": "fix #4540 Keep track of user specified widgets keys in ScriptRunContext (#5000)", "files_name": ["e2e/specs/st_multiselect.spec.js", "lib/streamlit/scriptrunner/script_run_context.py", "lib/streamlit/state/widgets.py", "lib/tests/streamlit/caching/common_cache_test.py", "lib/tests/streamlit/delta_generator_test.py"]}, {"commit_id": "c610b8f78d1e28d653cf9313eebdf6749d1447f1", "commit_date": "Fri Jul 22 15:52:45 2022 -0700", "commit_message": "No explicit IOLoop (#5014)", "files_name": ["lib/streamlit/app_session.py", "lib/streamlit/web/bootstrap.py", "lib/streamlit/web/server/browser_websocket_handler.py", "lib/streamlit/web/server/server.py", "lib/tests/streamlit/app_session_test.py", "lib/tests/streamlit/web/bootstrap_test.py", "lib/tests/streamlit/web/server/server_test.py", "lib/tests/streamlit/web/server/server_test_case.py"]}, {"commit_id": "d281234c18eb73b153e7120f47afd4e9c21ce61a", "commit_date": "Fri Jul 22 21:33:41 2022 +0400", "commit_message": "Fix for Issue #4538, based on PR #4648 (#5007)", "files_name": ["lib/streamlit/elements/slider.py"]}, {"commit_id": "fcd59611948b0ca8bd94389b2b164895c692d8c3", "commit_date": "Fri Jul 22 14:33:13 2022 -0300", "commit_message": "Improve `st.progress` UI (#5011)", "files_name": ["frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_progress.spec.js/progressbar-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_progress.spec.js/progressbar.snap.png", "frontend/src/components/shared/ProgressBar/ProgressBar.tsx"]}, {"commit_id": "f1bc191904ce8b2d01e912df6d91b983698c8bef", "commit_date": "Fri Jul 22 20:00:28 2022 +0530", "commit_message": "Fix chart studio link in st.plotly_chart docstring (#5017)", "files_name": ["lib/streamlit/elements/plotly_chart.py"]}, {"commit_id": "900b676261e0a4cea2a8b5bf9de019302f47f61d", "commit_date": "Thu Jul 21 16:19:55 2022 -0700", "commit_message": "move BrowserWebSocketHandler into its own file (#5012)", "files_name": ["lib/streamlit/web/server/browser_websocket_handler.py", "lib/streamlit/web/server/server.py", "lib/streamlit/web/server/session_client.py", "lib/tests/streamlit/web/server/browser_websocket_handler_test.py", "lib/tests/streamlit/web/server/component_request_handler_test.py", "lib/tests/streamlit/web/server/server_test.py", "lib/tests/streamlit/web/server/server_test_case.py"]}, {"commit_id": "bdf3f13bdbb74da323f488f2bec69648a83e7031", "commit_date": "Thu Jul 21 22:21:52 2022 +0400", "commit_message": "Specify max line length for Python file in .editorconfig to match Black formatter rules (#5001)", "files_name": [".editorconfig"]}, {"commit_id": "032286e6eb2dd1a93f96ab1d9f03c3824e0e5046", "commit_date": "Thu Jul 21 10:09:39 2022 -0700", "commit_message": "Add basic support for enums in multiselect (#4987)", "files_name": ["e2e/scripts/st_multiselect.py", "e2e/specs/st_multiselect.spec.js", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect6.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect7-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect7.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect8-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect8.snap.png", "lib/streamlit/elements/multiselect.py", "lib/tests/streamlit/multiselect_test.py"]}, {"commit_id": "07ee3c225b903166dfee1e9b3104d4513e84c2a2", "commit_date": "Thu Jul 21 10:09:00 2022 -0700", "commit_message": "Don't expose SessionInfo to UploadFileRequestHandler (#4997)", "files_name": ["lib/streamlit/web/server/server.py", "lib/streamlit/web/server/upload_file_request_handler.py", "lib/tests/streamlit/web/server/server_test.py", "lib/tests/streamlit/web/server/upload_file_request_handler_test.py"]}, {"commit_id": "53303b7cb2dee2fa8313ba1bc4ac89a7b5359492", "commit_date": "Thu Jul 21 08:32:08 2022 -0700", "commit_message": "Replace `attrs` with stdlib `dataclass` (#5006)", "files_name": ["lib/setup.py", "lib/streamlit/elements/metric.py", "lib/streamlit/elements/time_widgets.py", "lib/streamlit/legacy_caching/caching.py", "lib/streamlit/scriptrunner/script_requests.py", "lib/streamlit/scriptrunner/script_run_context.py", "lib/streamlit/scriptrunner/script_runner.py", "lib/streamlit/session_data.py", "lib/streamlit/state/session_state.py", "lib/tests/streamlit/app_session_test.py", "lib/tests/streamlit/caching/common_cache_test.py", "lib/tests/streamlit/script_run_context_test.py", "lib/tests/streamlit/scriptrunner/script_runner_test.py", "lib/tests/streamlit/state/session_state_proxy_test.py", "lib/tests/streamlit/state/session_state_test.py", "lib/tests/streamlit/user_info_test.py", "lib/tests/testutil.py"]}, {"commit_id": "b5fde20cfb46a3d2569bbd6ea77256b725402da3", "commit_date": "Wed Jul 20 19:09:22 2022 -0700", "commit_message": "Bump terser from 4.8.0 to 4.8.1 in /frontend (#4998)", "files_name": ["frontend/package-lock.json", "frontend/yarn.lock"]}, {"commit_id": "60f6aef48c01f6226eec4b85201dcbba0d5d28b6", "commit_date": "Wed Jul 20 19:09:01 2022 -0700", "commit_message": "Bump moment from 2.29.3 to 2.29.4 in /frontend (#4961)", "files_name": ["frontend/package-lock.json", "frontend/package.json", "frontend/yarn.lock"]}, {"commit_id": "9016cbb3187684abc6bab29586e19c07f13dc798", "commit_date": "Wed Jul 20 10:49:32 2022 -0700", "commit_message": "Replay st elements inside memo/singleton functions (#4936)", "files_name": ["lib/streamlit/caching/__init__.py", "lib/streamlit/caching/cache_errors.py", "lib/streamlit/caching/cache_utils.py", "lib/streamlit/caching/memo_decorator.py", "lib/streamlit/caching/singleton_decorator.py", "lib/streamlit/delta_generator.py", "lib/streamlit/elements/__init__.py", "lib/tests/streamlit/caching/cache_errors_test.py", "lib/tests/streamlit/caching/common_cache_test.py", "lib/tests/streamlit/caching/memo_test.py", "lib/tests/streamlit/caching/singleton_test.py"]}, {"commit_id": "bb6cbe2b5e324d9191da9b373f0ce588d78297f0", "commit_date": "Wed Jul 20 11:57:24 2022 -0300", "commit_message": "Fix widget alignments (#4995)", "files_name": ["frontend/cypress/snapshots/linux/2x/empty_labels.spec.js/empty_labels-dark.snap.png", "frontend/cypress/snapshots/linux/2x/empty_labels.spec.js/empty_labels.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox0.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox1.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox2.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox3.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox4.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_checkbox.spec.js/checkbox5.snap.png", "frontend/cypress/snapshots/linux/2x/st_disabled.spec.js/disabled-widgets-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_disabled.spec.js/disabled-widgets-5.snap.png", "frontend/cypress/snapshots/linux/2x/st_disabled.spec.js/disabled-widgets-7.snap.png", "frontend/cypress/snapshots/linux/2x/st_disabled.spec.js/disabled-widgets-8.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/animation-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/animation-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/dataframe-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/dataframe-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect-dropdown-long-label-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect-selection-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect-selection.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect0.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect1.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect2.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect3.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect4.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect5.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_multiselect.spec.js/multiselect6.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox0.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox1.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox2.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox3.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox4.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_selectbox.spec.js/selectbox5.snap.png", "frontend/src/components/shared/Dropdown/Selectbox.tsx", "frontend/src/components/widgets/Checkbox/Checkbox.tsx", "frontend/src/components/widgets/Multiselect/Multiselect.tsx"]}, {"commit_id": "b52c0235e45765e04a6d0c3398bb9964a7f648d0", "commit_date": "Wed Jul 20 13:36:13 2022 +0530", "commit_message": "Replace static embdedded app in st.pydeck_chart docstring (#4999)", "files_name": ["lib/streamlit/elements/deck_gl_json_chart.py"]}, {"commit_id": "0682498a82a29ee90fba7812b21f083936e1c4ef", "commit_date": "Tue Jul 19 11:04:57 2022 -0700", "commit_message": "Add the ability to exclude dependencies from conda builds of Streamlit (#4991)", "files_name": ["Makefile", "lib/conda-recipe/meta.yaml", "lib/setup.py"]}, {"commit_id": "80cbbb8598bb63674d67afa8525e775d6ba9ffa6", "commit_date": "Mon Jul 18 19:32:16 2022 -0700", "commit_message": "Release 1.11.0 (#4969)", "files_name": ["frontend/package.json", "lib/setup.py"]}, {"commit_id": "eede5de333e33a4652f9363c0ee379697ea12985", "commit_date": "Mon Jul 18 08:38:32 2022 -0700", "commit_message": "SessionClientDisconnectedError (#4985)", "files_name": ["lib/streamlit/web/server/server.py", "lib/tests/streamlit/web/server/server_test.py"]}], "windows_after": [{"commit_id": "52a8debd071343e18044c2c00f4fe26571056f60", "commit_date": "Thu Jul 28 12:23:53 2022 +0200", "commit_message": "Add pytest.ini with custom mark slow", "files_name": ["lib/pytest.ini"]}, {"commit_id": "d6d096bcbc128772066e3bf834ff157d9145bdc2", "commit_date": "Thu Jul 28 15:09:56 2022 +0200", "commit_message": "Add pytest.ini with custom mark slow", "files_name": ["9eca76aa7ba00716d4dcbcc8b68132edbd37c2f0 - Thu Jul 28 17:56:51 2022 +0200 : Prevent class TestScriptRunner to be collected by PyTest (#5055)", "lib/tests/streamlit/scriptrunner/script_runner_test.py"]}, {"commit_id": "32266472f2ca30bb43552ab1351b25aca38bfaee", "commit_date": "Thu Jul 28 10:50:55 2022 -0700", "commit_message": "Release 1.11.1 (#5048)", "files_name": ["frontend/package.json", "lib/setup.py"]}, {"commit_id": "ecd0a88f8bbec8011373d29cb34e6576a4d3e028", "commit_date": "Thu Jul 28 21:20:49 2022 +0200", "commit_message": "Add support for selecting x/y axis data for built-in charts (#5002)", "files_name": ["e2e/scripts/st_arrow_area_chart.py", "e2e/scripts/st_arrow_bar_chart.py", "e2e/scripts/st_arrow_line_chart.py", "e2e/specs/st_arrow_area_chart.spec.js", "e2e/specs/st_arrow_bar_chart.spec.js", "e2e/specs/st_arrow_line_chart.spec.js", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_chart_utc_time.spec.js/arrowChartUTCTime-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_chart_utc_time.spec.js/arrowChartUTCTime-1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_chart_utc_time.spec.js/arrowChartUTCTime-2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart_add_rows_special.spec.js/arrowLineChartAddRows-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart_add_rows_special.spec.js/arrowLineChartAddRows.snap.png", "lib/streamlit/elements/arrow_altair.py", "lib/streamlit/elements/dataframe_selector.py", "lib/streamlit/type_util.py", "lib/tests/streamlit/arrow_altair_test.py", "lib/tests/streamlit/dataframe_selector_test.py"]}, {"commit_id": "a91dba56112eeefa3a78ea4dbfdc20fd991b94f3", "commit_date": "Thu Jul 28 23:59:22 2022 +0200", "commit_message": "Prevent logging exceptions on pytest sessionfinish (#5047)", "files_name": ["lib/tests/conftest.py"]}, {"commit_id": "7b48c8d5b40df6a00784c1d838149ea1d621b3e2", "commit_date": "Thu Jul 28 15:31:50 2022 -0700", "commit_message": "Resizable Sidebar (#5043)", "files_name": ["e2e/specs/st_hello.spec.js", "e2e/specs/st_sidebar.spec.js", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/animation-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/animation-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/dataframe-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/dataframe-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/mapping-demo.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/welcome-streamlit-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_hello.spec.js/welcome-streamlit.snap.png", "frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/date-popover-sidebar.snap.png", "frontend/package.json", "frontend/src/components/core/AppView/styled-components.ts", "frontend/src/components/core/Sidebar/Sidebar.test.tsx", "frontend/src/components/core/Sidebar/Sidebar.tsx", "frontend/src/components/core/Sidebar/styled-components.ts", "frontend/yarn.lock"]}, {"commit_id": "b32cb4257870c2720f7000273f93f677c8b7d597", "commit_date": "Thu Jul 28 18:09:39 2022 -0700", "commit_message": "Fix full-screen (#5059)", "files_name": ["frontend/src/components/core/Sidebar/styled-components.ts"]}, {"commit_id": "4edca1dbf86d67ce7d73bfe6dea4eb475baa3ad0", "commit_date": "Fri Jul 29 08:28:53 2022 -0700", "commit_message": "Fix (some) logger.py nits (#5057)", "files_name": ["lib/streamlit/logger.py", "lib/tests/streamlit/logger_test.py"]}, {"commit_id": "76d1aebccfb29e2ff6e7c2b23ef24eaa4ef5c59e", "commit_date": "Mon Aug 1 14:36:25 2022 -0700", "commit_message": "Don't expose SessionData class (#5071)", "files_name": ["lib/streamlit/app_session.py", "lib/streamlit/scriptrunner/script_runner.py", "lib/streamlit/watcher/local_sources_watcher.py", "lib/streamlit/web/server/server.py", "lib/tests/streamlit/app_session_test.py", "lib/tests/streamlit/scriptrunner/script_runner_test.py", "lib/tests/streamlit/watcher/local_sources_watcher_test.py"]}, {"commit_id": "d652d8eeaf991dc3fee0d0e1f3a46e51067f9f1d", "commit_date": "Mon Aug 1 20:43:34 2022 -0300", "commit_message": "Add top padding to chart and table components (#5061)", "files_name": ["frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_add_rows.spec.js/arrowstArrowVegaLiteChart-5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_altair_chart.spec.js/altair_chart_6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_area_chart.spec.js/arrow_area_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_bar_chart.spec.js/arrow_bar_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_empty_charts.spec.js/arrowVegaLiteChart-3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart2.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart3-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart3.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart4-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart4.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart5-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart5.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart6-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart.spec.js/arrow_line_chart6.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart_add_rows_special.spec.js/arrowLineChartAddRows-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_line_chart_add_rows_special.spec.js/arrowLineChartAddRows.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals0-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals0.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals1-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals1.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals2-dark.snap.png", "frontend/cypress/snapshots/linux/2x/st_arrow_new_features.spec.js/arrow-new-features-visuals2.snap.png"]}], "parents": [{"commit_id_before": "4a04eefe248b9af28ba5b563e54d665f68e49116", "url_before": "https://api.github.com/repos/streamlit/streamlit/commits/4a04eefe248b9af28ba5b563e54d665f68e49116", "html_url_before": "https://github.com/streamlit/streamlit/commit/4a04eefe248b9af28ba5b563e54d665f68e49116"}], "details": [{"raw_url": "https://github.com/streamlit/streamlit/raw/80d9979d5f4a00217743d607078a1d867fad8acf/lib%2Fstreamlit%2Fcomponents%2Fv1%2Fcomponents.py", "code": "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport json\nimport mimetypes\nimport os\nimport threading\nfrom typing import Any, Dict, Optional, Type, Union\n\nimport tornado.web\nfrom streamlit.scriptrunner import get_script_run_ctx\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit.elements.form import current_form_id\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.state import NoValue, register_widget\nfrom streamlit.type_util import to_bytes\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.components.v1 import component_arrow\n        except ImportError:\n            raise StreamlitAPIException(\n                \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"\n            )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            element.component_instance.form_id = current_form_id(dg)\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            def deserialize_component(ui_value, widget_id=\"\"):\n                # ui_value is an object from json, an ArrowTable proto, or a bytearray\n                return ui_value\n\n            ctx = get_script_run_ctx()\n            component_state = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n                deserializer=deserialize_component,\n                serializer=lambda x: x,\n                ctx=ctx,\n            )\n            widget_value = component_state.value\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        dg = streamlit._main\n\n        element = Element()\n        return_value = marshall_component(dg, element)\n        result = dg._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(\"not found\")\n            self.set_status(404)\n            return\n\n        # follow symlinks to get an accurate normalized path\n        component_root = os.path.realpath(component_root)\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.realpath(os.path.join(component_root, filename))\n\n        # Do NOT expose anything outside of the component root.\n        if os.path.commonprefix([component_root, abspath]) != component_root:\n            self.write(\"forbidden\")\n            self.set_status(403)\n            return\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"rb\") as file:\n                contents = file.read()\n        except (OSError) as e:\n            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)\n            self.write(\"read error\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock: threading.Lock = threading.Lock()\n    _instance: Optional[\"ComponentRegistry\"] = None\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "code_before": "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport json\nimport mimetypes\nimport os\nimport threading\nfrom typing import Any, Dict, Optional, Type, Union\n\nimport tornado.web\nfrom streamlit.scriptrunner import get_script_run_ctx\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit.elements.form import current_form_id\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.state import NoValue, register_widget\nfrom streamlit.type_util import to_bytes\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.components.v1 import component_arrow\n        except ImportError:\n            raise StreamlitAPIException(\n                \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"\n            )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            element.component_instance.form_id = current_form_id(dg)\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            def deserialize_component(ui_value, widget_id=\"\"):\n                # ui_value is an object from json, an ArrowTable proto, or a bytearray\n                return ui_value\n\n            ctx = get_script_run_ctx()\n            component_state = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n                deserializer=deserialize_component,\n                serializer=lambda x: x,\n                ctx=ctx,\n            )\n            widget_value = component_state.value\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        dg = streamlit._main\n\n        element = Element()\n        return_value = marshall_component(dg, element)\n        result = dg._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(\"not found\")\n            self.set_status(404)\n            return\n\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.join(component_root, filename)\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"rb\") as file:\n                contents = file.read()\n        except (OSError) as e:\n            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)\n            self.write(\"read error\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock: threading.Lock = threading.Lock()\n    _instance: Optional[\"ComponentRegistry\"] = None\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "patch": "@@ -316,8 +316,16 @@ def get(self, path: str) -> None:\n             self.set_status(404)\n             return\n \n+        # follow symlinks to get an accurate normalized path\n+        component_root = os.path.realpath(component_root)\n         filename = \"/\".join(parts[1:])\n-        abspath = os.path.join(component_root, filename)\n+        abspath = os.path.realpath(os.path.join(component_root, filename))\n+\n+        # Do NOT expose anything outside of the component root.\n+        if os.path.commonprefix([component_root, abspath]) != component_root:\n+            self.write(\"forbidden\")\n+            self.set_status(403)\n+            return\n \n         LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n ", "file_path": "files/2022_8/1572", "file_language": "py", "file_name": "lib/streamlit/components/v1/components.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/streamlit/streamlit/raw/80d9979d5f4a00217743d607078a1d867fad8acf/lib%2Ftests%2Fstreamlit%2Fcomponents_test.py", "code": "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\nfrom unittest.mock import patch\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1 import component_arrow\nfrom streamlit.components.v1.components import (\n    ComponentRegistry,\n    ComponentRequestHandler,\n    CustomComponent,\n    declare_component,\n)\nimport streamlit.components.v1 as components\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.Components_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\nimport streamlit as st\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path based on the root directory (and therefore\n        outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test//etc/hosts\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_relative_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path relative to the component root directory\n        (and specifically outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test/../foo\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_symlink_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path symlinked to a file outside the component\n        root directory is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.realpath\",\n            side_effect=[PATH, \"/etc/hosts\"],\n        ):\n            response = self._request_component(\n                \"components_test.test\"\n            )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n", "code_before": "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\nfrom unittest.mock import patch\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1 import component_arrow\nfrom streamlit.components.v1.components import (\n    ComponentRegistry,\n    ComponentRequestHandler,\n    CustomComponent,\n    declare_component,\n)\nimport streamlit.components.v1 as components\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.Components_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\nimport streamlit as st\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n", "patch": "@@ -434,6 +434,55 @@ def test_success_request(self):\n         self.assertEqual(200, response.code)\n         self.assertEqual(b\"Test Content\", response.body)\n \n+    def test_outside_component_root_request(self):\n+        \"\"\"Tests to ensure a path based on the root directory (and therefore\n+        outside of the component root) is disallowed.\"\"\"\n+\n+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n+            # We don't need the return value in this case.\n+            declare_component(\"test\", path=PATH)\n+\n+        response = self._request_component(\n+            \"components_test.test//etc/hosts\"\n+        )\n+\n+        self.assertEqual(403, response.code)\n+        self.assertEqual(b\"forbidden\", response.body)\n+\n+    def test_relative_outside_component_root_request(self):\n+        \"\"\"Tests to ensure a path relative to the component root directory\n+        (and specifically outside of the component root) is disallowed.\"\"\"\n+\n+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n+            # We don't need the return value in this case.\n+            declare_component(\"test\", path=PATH)\n+\n+        response = self._request_component(\n+            \"components_test.test/../foo\"\n+        )\n+\n+        self.assertEqual(403, response.code)\n+        self.assertEqual(b\"forbidden\", response.body)\n+\n+    def test_symlink_outside_component_root_request(self):\n+        \"\"\"Tests to ensure a path symlinked to a file outside the component\n+        root directory is disallowed.\"\"\"\n+\n+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n+            # We don't need the return value in this case.\n+            declare_component(\"test\", path=PATH)\n+\n+        with mock.patch(\n+            \"streamlit.components.v1.components.os.path.realpath\",\n+            side_effect=[PATH, \"/etc/hosts\"],\n+        ):\n+            response = self._request_component(\n+                \"components_test.test\"\n+            )\n+\n+        self.assertEqual(403, response.code)\n+        self.assertEqual(b\"forbidden\", response.body)\n+\n     def test_invalid_component_request(self):\n         \"\"\"Test request failure when invalid component name is provided.\"\"\"\n ", "file_path": "files/2022_8/1573", "file_language": "py", "file_name": "lib/tests/streamlit/components_test.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg", "target": 0}, {"function": "def _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg", "target": 0}, {"function": "class DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )", "target": 0}, {"function": "class ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))", "target": 0}, {"function": "class InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)", "target": 0}, {"function": "class ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )", "target": 0}, {"function": "class IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)", "target": 0}], "function_after": [{"function": "def _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg", "target": 0}, {"function": "def _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg", "target": 0}, {"function": "class DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )", "target": 0}, {"function": "class ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))", "target": 0}, {"function": "class InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)", "target": 0}, {"function": "class ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path based on the root directory (and therefore\n        outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test//etc/hosts\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_relative_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path relative to the component root directory\n        (and specifically outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test/../foo\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_symlink_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path symlinked to a file outside the component\n        root directory is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.realpath\",\n            side_effect=[PATH, \"/etc/hosts\"],\n        ):\n            response = self._request_component(\n                \"components_test.test\"\n            )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )", "target": 0}, {"function": "class IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)", "target": 0}]}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
