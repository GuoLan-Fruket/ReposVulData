{"index": 1695, "cve_id": "CVE-2015-8309", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Directory traversal vulnerability in Cherry Music before 0.36.0 allows remote authenticated users to read arbitrary files via the \"value\" parameter to \"download.\"", "cvss": "4.3", "publish_date": "March 27, 2017", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "NONE", "A": "NONE", "commit_id": "62dec34a1ea0741400dd6b6c660d303dcd651e86", "commit_message": "fixes for CVE-2015-8309 (download arbitrary files) and CVE-2015-8309 (XSS vulnerability)\n\nMany thanks to feedersec for checking the security of CherryMusic!\n\nNote to CM users: Both those vulnerabilities only work for logged-in users.", "commit_date": "2015-11-21T16:04:02Z", "project": "devsnd/cherrymusic", "url": "https://api.github.com/repos/devsnd/cherrymusic/commits/62dec34a1ea0741400dd6b6c660d303dcd651e86", "html_url": "https://github.com/devsnd/cherrymusic/commit/62dec34a1ea0741400dd6b6c660d303dcd651e86", "windows_before": [{"commit_id": "82ad79374f2895e79573255bc81ee143fce4d6a0", "commit_date": "Sun Nov 8 17:33:38 2015 +0100", "commit_message": "disable confirm-to-quit when downloading the playlist", "files_name": ["res/dist/cherrymusic.dist.js", "res/js/cherrymusic.js"]}, {"commit_id": "e1e545f9169cc01634304a54ad2a1cd57a6bf31b", "commit_date": "Sun Nov 8 17:21:46 2015 +0100", "commit_message": "updated travis.yml using mirrors for pip is apparently deprecated in python 3.5 see: https://pypi.python.org/mirrors", "files_name": [".travis.yml"]}, {"commit_id": "c3ef68f6faca7bcd2f71f2eb52ae8c66fd991ebc", "commit_date": "Sun Nov 8 17:16:54 2015 +0100", "commit_message": "Merged id3-images branch, closes #531, refactored albumartfetcher for embedded images to support pillow", "files_name": ["9307f326700dbd0d9ffab28c33fdb24802b7e7b5 - Sun Nov 8 16:29:55 2015 +0100 : updated copyright to 2015, closes #572", "cherrymusicserver/albumartfetcher.py", "cherrymusicserver/api/v1/jsontools.py", "cherrymusicserver/api/v1/models.py", "cherrymusicserver/api/v1/resources.py", "cherrymusicserver/api/v1/users.py", "cherrymusicserver/browsersetup.py", "cherrymusicserver/cherrymodel.py", "cherrymusicserver/configuration.py", "cherrymusicserver/database/__init__.py", "cherrymusicserver/database/connect.py", "cherrymusicserver/database/sql.py", "cherrymusicserver/httphandler.py", "cherrymusicserver/log.py", "cherrymusicserver/metainfo.py", "cherrymusicserver/pathprovider.py", "cherrymusicserver/playlistdb.py", "cherrymusicserver/progress.py", "cherrymusicserver/resultorder.py", "cherrymusicserver/service.py", "cherrymusicserver/sqlitecache.py", "cherrymusicserver/tweak.py", "cherrymusicserver/userdb.py", "cherrymusicserver/useroptiondb.py", "cherrymusicserver/util.py"]}, {"commit_id": "288c90c499eba9cd248f2a304f36b2e1cd6ce78b", "commit_date": "Sun Nov 8 16:21:07 2015 +0100", "commit_message": "updated travis.yml: coveralls dropped support for python 3.2", "files_name": [".travis.yml"]}, {"commit_id": "c640cc021d772883ec3840740dde792c98ac69a8", "commit_date": "Sun Nov 8 16:17:11 2015 +0100", "commit_message": "recompiled client", "files_name": ["devscripts/deploy.py", "res/dist/cherrymusic.dist.js"]}, {"commit_id": "91c9154987c590d18b6c40af7e8d9efa9e7c90bf", "commit_date": "Sun Nov 8 16:15:02 2015 +0100", "commit_message": "fixed sorting by track numbers (numbers are no longer sorted alphabetically)", "files_name": ["res/js/playlistmanager.js"]}, {"commit_id": "cffa8999e00975ecf481115d3ea53622a2f62d3f", "commit_date": "Sun Nov 8 15:14:46 2015 +0100", "commit_message": "added optional-dependency on pillow for album art resizing", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "cf1d95e0fdc4bef411a754cdcc123df9a3464b65", "commit_date": "Sun Nov 8 14:52:42 2015 +0100", "commit_message": "prefer ffmpeg over faad for ALAC streams, closes #584 added decoder for oga files, closes #597", "files_name": ["audiotranscode/__init__.py"]}, {"commit_id": "5c0aa3121832e2c493167b6af10e980bd918de2b", "commit_date": "Mon Oct 12 18:39:01 2015 +0200", "commit_message": "updated tinytag to version 0.10.1, with much faster ID3 parsing", "files_name": ["tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "fb76b274a7cb7e3898eba398ac7bb32d19530423", "commit_date": "Sun Jul 19 14:52:18 2015 +0200", "commit_message": "Merge branch 'devel' of github.com:devsnd/cherrymusic into devel", "files_name": ["cc6d09d72ff2307a627fd65e846fc1a148451f7b - Sun Jul 19 14:50:35 2015 +0200 : updated tinytag to version 0.9.2, closes #581", "tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "6683ef47e6169f238d4d920871ff3046e3f55aaf", "commit_date": "Sun Jul 19 14:02:48 2015 +0200", "commit_message": "Update tinytag -> 0.9.2", "files_name": ["tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "d71406e3bc4904a537d6624308a3ef00b235bcf1", "commit_date": "Sat Jun 20 14:26:28 2015 +0200", "commit_message": "Merge pull request #574 from lzh9102/devel", "files_name": ["770d1565ae9cbda7efa6ef21792d4e99181e638d - Tue Jun 16 10:29:21 2015 +0800 : always select the first image in alphabetical order as the local albumart", "cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "4d6117b574e73992bbb2e6f0d0831280d445aef5", "commit_date": "Fri Jun 5 10:58:07 2015 +0200", "commit_message": "Merge pull request #558 from pando85/reverse-sorting", "files_name": ["cd4f25195658db58d63d070c2e0389bf8a7f42cc - Mon May 18 00:27:44 2015 +0200 : Added reverse-sorting feature", "cherrymusicserver/httphandler.py", "res/devel.html", "res/dist/cherrymusic.dist.js", "res/dist/main.html", "res/js/cherrymusic.js"]}, {"commit_id": "3e22d086efe806850a1a4c9aa919042483d33844", "commit_date": "Sun May 17 21:22:19 2015 +0200", "commit_message": "updated tinytag to version 0.9.1, fixes #536", "files_name": ["tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "a0c8a57dd873bf108d5736575255023953ce8806", "commit_date": "Sun May 17 16:38:29 2015 +0200", "commit_message": "list files from basedir if no path is given to cherrymodel.listdir, #530", "files_name": ["cherrymusicserver/cherrymodel.py"]}, {"commit_id": "5a13429a33749a0249a462a9537d34e6c90e4943", "commit_date": "Sun May 17 15:59:42 2015 +0200", "commit_message": "retain public state of playlists when saving, closes #556", "files_name": ["cherrymusicserver/playlistdb.py"]}, {"commit_id": "09ec6788223c1f0c6741089c6837297d8887bf66", "commit_date": "Sun May 17 15:47:05 2015 +0200", "commit_message": "CLI user deletion and password change, allow complex passwords on CLI, closes #553", "files_name": ["cherrymusic", "cherrymusicserver/__init__.py", "cherrymusicserver/userdb.py"]}, {"commit_id": "fe642d1aabb0120fa0bff9fa327c047a297158ad", "commit_date": "Fri Apr 24 12:45:13 2015 +0200", "commit_message": "fixed path of default folder image, closes #543", "files_name": ["cherrymusicserver/httphandler.py"]}, {"commit_id": "8e71f5a71a10e318358fa1a0d0027d14c59aca5a", "commit_date": "Fri Apr 24 12:24:00 2015 +0200", "commit_message": "Merge branch 'devel' of github.com:devsnd/cherrymusic into devel", "files_name": ["e0eb0dbd015f699b79f459fad593d010bebd0d61 - Fri Apr 24 12:22:50 2015 +0200 : redeploy js changes", "res/dist/cherrymusic.dist.js"]}, {"commit_id": "4e75dc26168f9e3b408976dd1071189d22ccd6aa", "commit_date": "Fri Apr 24 12:20:33 2015 +0200", "commit_message": "allow fetching album art from files directly, #528", "files_name": ["cherrymusicserver/httphandler.py", "res/js/playlistmanager.js"]}, {"commit_id": "e6512baa9f9b07ecb82d60f96747f2538ba2d18a", "commit_date": "Fri Apr 24 12:19:48 2015 +0200", "commit_message": "updated tinytag to version 0.8.0", "files_name": ["CHANGES", "cherrymusicserver/__init__.py", "tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "c31a42eb4a75414fd1fa456799a4f02066e269b7", "commit_date": "Tue Apr 21 00:13:14 2015 +0200", "commit_message": "Merge branch 'master' into devel", "files_name": ["7ec737ca053954b1b3b63a014c3ec8134f169e3e - Mon Apr 20 22:11:37 2015 +0200 : \"release 0.35.2\"", "CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "5a0d4a67e00e725552213b9c3e5a24d1b7ed0104", "commit_date": "Mon Apr 20 21:56:02 2015 +0200", "commit_message": "fixed problem starting CM on windows with stale pidfile, #549", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "65f7d83148f752ba1e9f6186d0b69e8b122621b5", "commit_date": "Sun Apr 19 20:03:42 2015 +0200", "commit_message": "fixed unability to load playlist with single quotes, closes #545", "files_name": ["res/templates/mediabrowser-playlist.html"]}, {"commit_id": "be939718dfdff04dd7607477935a4b4515c44567", "commit_date": "Tue Apr 14 20:26:48 2015 +0200", "commit_message": "Merge pull request #542 from rtaibah/devel", "files_name": ["ead241ff11dc66d2955d87bf336c2de0e437173e - Tue Apr 14 17:55:44 2015 +0300 : Fix a typo in error message", "cherrymusicserver/__init__.py", "res/i18n/cherrymusic.pot", "res/i18n/de/LC_MESSAGES/default.po"]}, {"commit_id": "f357c0bdccde0889ef055eb3bc68de572f8325ba", "commit_date": "Tue Apr 14 00:49:38 2015 +0200", "commit_message": "Fix max_tries in albumart ID3 fetcher", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "3796a3ca6924f221bfe2c12d96f371fbbf8a5235", "commit_date": "Tue Apr 14 00:20:14 2015 +0200", "commit_message": "Merge branch 'devel' into id3-images", "files_name": ["b7a3d65bb6777a8664c217fd6d2ad37b22f88e0c - Tue Apr 14 00:19:38 2015 +0200 : Add test for albumart fetching from ID3", "cherrymusicserver/test/test_albumartfetcher.py"]}, {"commit_id": "1f16da8245029039935263fda240c4f13cf2f807", "commit_date": "Tue Apr 14 00:16:36 2015 +0200", "commit_message": "Fix albumart fetching from ID3", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "72183b6ea9460f1bd9fa35421337596836547514", "commit_date": "Fri Apr 10 17:39:38 2015 +0200", "commit_message": "\"release 0.35.1\"", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "7078c60fbcce1c0bc6f62ea0dbf9d64e421ba3fc", "commit_date": "Fri Apr 10 17:38:50 2015 +0200", "commit_message": "Merge branch 'master' into devel", "files_name": ["3e5d8d79498446c654945e93942b8eddb8d59ca4 - Fri Apr 10 17:37:49 2015 +0200 : removed Exception from py3.3 breaking backward compat, closing #540", "cherrymusicserver/__init__.py"]}, {"commit_id": "4c1a4d8ac75d9b7f1c00b544cd02b2615dd92e49", "commit_date": "Tue Apr 7 10:17:09 2015 +0200", "commit_message": "Add albumart fetching from ID3", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "215cc5fe32a2fcb4999d862988f1c9a1e531c5d1", "commit_date": "Mon Apr 6 19:51:15 2015 +0200", "commit_message": "Update tinytag to v0.8.0", "files_name": ["tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "cc710f3b71c5e18ba0ac9d8e30f34f7148f67e76", "commit_date": "Fri Mar 27 20:42:25 2015 +0100", "commit_message": "Merge pull request #529 from MartijnRas/httphandling", "files_name": ["7f1a527f15b3fb5a4d1d9cc76d16e3c1053f3d17 - Fri Mar 27 14:33:36 2015 +0100 : Prevent mixing content over HTTP and HTTPS", "cherrymusicserver/httphandler.py"]}, {"commit_id": "8331e785c59a452ea1c4cf513dfec7b70f6230a8", "commit_date": "Thu Mar 26 19:21:02 2015 +0100", "commit_message": "Merge remote-tracking branch 'upstream/devel' into devel", "files_name": ["39ba7278ca426a9a7af00fa03ab408e4c7e62846 - Sun Mar 22 23:34:24 2015 +0100 : release 0.35.0", ".gitignore", "res/dist/cherrymusic.dist.js", "res/dist/main.html"]}, {"commit_id": "cb7385aae3896413e0a3a5566fb4ae9e66208658", "commit_date": "Sun Mar 22 23:29:51 2015 +0100", "commit_message": "prepare release 0.35.0", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "74d9ec0f16b9726185ab1e3f71e066983359386a", "commit_date": "Sun Mar 22 16:11:20 2015 +0100", "commit_message": "Merge branch 'pull-527' into devel", "files_name": ["78858706abc763fb4eada699402591c11e42215c - Sun Mar 22 16:06:18 2015 +0100 : Readability; minor corrections to original logic (#527)", "cherrymusicserver/__init__.py"]}, {"commit_id": "10f5c146da988e211247fb172c46ab8241f3a24d", "commit_date": "Wed Mar 18 21:45:19 2015 +0100", "commit_message": "Merge remote-tracking branch 'upstream/devel' into devel", "files_name": ["17e4adc8be200499af5b78f69c295cac398981c4 - Wed Mar 18 21:43:43 2015 +0100 : Revert to commit at which I created my fork", "cherrymusicserver/__init__.py", "cherrymusicserver/configuration.py", "res/js/playlistmanager.js"]}, {"commit_id": "fab479e4eebfaa2d78f303017d0149fd5ce06031", "commit_date": "Wed Mar 18 19:07:00 2015 +0100", "commit_message": "Fixed indentation", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "03056281835dfa2a9bee2165917720370f941243", "commit_date": "Tue Mar 17 21:03:29 2015 +0100", "commit_message": "Refactoring _get_version_from_git to work before Python 3.2", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "cc6b281f822e4e61d5af609c46ce758e4f3445ad", "commit_date": "Tue Mar 17 21:00:39 2015 +0100", "commit_message": "Refactoring exception handling in _get_version_from_git", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "fef00a7f03a856c359a71bf0e0b706c708e8a29b", "commit_date": "Tue Mar 17 20:56:12 2015 +0100", "commit_message": "Check git directory exists", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "1ca0dec172b888d7e66238ba6483a8a796224922", "commit_date": "Sat Mar 14 16:12:36 2015 +0100", "commit_message": "Update translations", "files_name": ["res/i18n/cherrymusic.pot", "res/i18n/de/LC_MESSAGES/default.mo", "res/i18n/de/LC_MESSAGES/default.po", "res/i18n/es/LC_MESSAGES/default.mo", "res/i18n/es/LC_MESSAGES/default.po"]}, {"commit_id": "99d84aaf6ef8a08ae05d5375c8c52e53cc7c9346", "commit_date": "Sat Mar 14 16:10:17 2015 +0100", "commit_message": "Allow sqlitecache to index file symlinks (#518)", "files_name": ["cherrymusicserver/sqlitecache.py", "cherrymusicserver/test/helpers.py", "cherrymusicserver/test/test_cherrymodel.py"]}], "windows_after": [{"commit_id": "e6393ff9b2912cde22e016b3b7384468d9a66c22", "commit_date": "Sat Nov 21 17:08:49 2015 +0100", "commit_message": "recompiled client", "files_name": ["res/dist/cherrymusic.dist.js"]}, {"commit_id": "18c7c86a2305391d0e9e5c82850145a8aa5c104b", "commit_date": "Sat Nov 21 17:37:56 2015 +0100", "commit_message": "\"release 0.36.0\"", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "97a4215083db6b8fd2dfa41287fb487568090271", "commit_date": "Sat Apr 9 19:33:36 2016 +0200", "commit_message": "Updated man page to include --deleteuser and --changepassword switches from issue #553.", "files_name": ["doc/man/cherrymusic.1"]}, {"commit_id": "013defb841571fcd0202f0bfa6cc1d8c349cf045", "commit_date": "Mon May 23 06:42:50 2016 +0200", "commit_message": "fixed: allow the HTTP port to be port 80, #616", "files_name": ["cherrymusicserver/httphandler.py"]}, {"commit_id": "07494fb7a13b9ed079ff38b100972e068e674257", "commit_date": "Mon May 23 06:53:37 2016 +0200", "commit_message": "Merge branch 'devel' of github.com:devsnd/cherrymusic into devel", "files_name": ["83a9353286866c7278be04e5277c20c065618d55 - Mon May 23 08:47:51 2016 +0200 : refactored pathprovider.getResourcePath, closes #594", "cherrymusicserver/cherrymodel.py", "cherrymusicserver/pathprovider.py"]}, {"commit_id": "9e66ec79731e3c55e7b5b6a5e3cfb2cf74cf0949", "commit_date": "Mon May 23 09:04:39 2016 +0200", "commit_message": "audio transcoding: reading last buffered data of encoder stdout, possible fix for #599", "files_name": ["audiotranscode/__init__.py"]}, {"commit_id": "45ce2e4ab8ea2175fffe76f30a4ed9f3dcc07583", "commit_date": "Mon May 23 09:25:26 2016 +0200", "commit_message": "audio transcoding: force resampling to 44.1kHz when using OGG encoder, #583", "files_name": ["audiotranscode/__init__.py"]}, {"commit_id": "e0d159542a0a292f96bc45124d7ee8013233f3c6", "commit_date": "Mon May 23 09:56:08 2016 +0200", "commit_message": "dont show remaining time in shuffle mode, closes #566", "files_name": ["res/dist/cherrymusic.dist.js", "res/js/playlistmanager.js"]}, {"commit_id": "6841e74f0fa3737877a79a35155533644e373217", "commit_date": "Mon May 23 10:14:25 2016 +0200", "commit_message": "updated copyright to 2016", "files_name": ["cherrymusic", "cherrymusicserver/__init__.py", "cherrymusicserver/albumartfetcher.py", "cherrymusicserver/browsersetup.py", "cherrymusicserver/cherrymodel.py", "cherrymusicserver/configuration.py", "cherrymusicserver/database/__init__.py", "cherrymusicserver/database/connect.py", "cherrymusicserver/database/sql.py", "cherrymusicserver/httphandler.py", "cherrymusicserver/log.py", "cherrymusicserver/metainfo.py", "cherrymusicserver/pathprovider.py", "cherrymusicserver/playlistdb.py", "cherrymusicserver/progress.py", "cherrymusicserver/resultorder.py", "cherrymusicserver/service.py", "cherrymusicserver/sqlitecache.py", "cherrymusicserver/tweak.py", "cherrymusicserver/userdb.py", "cherrymusicserver/useroptiondb.py", "cherrymusicserver/util.py"]}, {"commit_id": "43856934a041bb65904d2459eb8bd120e4bdc706", "commit_date": "Sat Jul 9 14:18:40 2016 +0200", "commit_message": "Applying cherrypy unicode monkey patch only for versions < 5.5 #632", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "edf14b6ec26bded3ad996843cb332b0698709126", "commit_date": "Sat Jul 9 15:02:49 2016 +0200", "commit_message": "removed deprecated google image search api", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "46f0719d300d0ca62bda424420e1af68e86e7aa7", "commit_date": "Sat Jul 9 15:12:11 2016 +0200", "commit_message": "updated tinytag to version 0.15.1, supports mp4 tags", "files_name": ["tinytag/__init__.py", "tinytag/tinytag.py"]}, {"commit_id": "05b5df181dcab90cb97c0205a08f430fe2914a8c", "commit_date": "Sat Jul 9 15:12:56 2016 +0200", "commit_message": "exclude node_modules folder in gitignore", "files_name": [".gitignore"]}, {"commit_id": "8bea0a2ce61f03b0619f5567d8352d8757b37135", "commit_date": "Sat Jul 9 15:20:39 2016 +0200", "commit_message": "\"release 0.37.0\"", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "3c1ebb87b6eba96c10209cb1efa4c91249d2bdd3", "commit_date": "Sat Jul 9 15:21:22 2016 +0200", "commit_message": "Merge tag '0.37.0'", "files_name": ["f5dfb242e68630e49c8fd562880e0d9c27539cf0 - Sat Jul 30 13:41:35 2016 +0200 : improved robustness of cherrypy version detection #633", "cherrymusicserver/__init__.py"]}, {"commit_id": "8414d5bfeb2b7d670af035ebe5672d1165be6984", "commit_date": "Sat Jul 30 13:44:27 2016 +0200", "commit_message": "Merge branch 'devel'", "files_name": ["d0e4e180dade02cdc612da809d34ebf0869ae79e - Sat Jul 30 13:47:24 2016 +0200 : \"release 0.37.1\"", "CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "e7088536d281910cffdb8c128929dd3124e36815", "commit_date": "Sat Jul 30 14:28:04 2016 +0200", "commit_message": "setup.py refactoring, updated markdown -> rst api", "files_name": ["setup.py"]}, {"commit_id": "f26a219d128f537a4d2ea5ad22a9c802d3f97f90", "commit_date": "Sat Jul 30 14:28:35 2016 +0200", "commit_message": "updated less compiler, css is a few bytes smaller", "files_name": ["res/bootstrap3/gen/cherrymusic.css"]}, {"commit_id": "fe85d3f94454d1cdc96a43c00a233eb92cc20a0a", "commit_date": "Sat Jul 30 14:29:16 2016 +0200", "commit_message": "showing error because of disabled transcoding to user, fixes #586", "files_name": ["res/dist/cherrymusic.dist.js", "res/js/playlistmanager.js"]}, {"commit_id": "4561077d83922ce9d5494c892a074b36ca13f422", "commit_date": "Sat Jul 30 21:41:39 2016 +0200", "commit_message": "fix cherrypy detection for #632", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "dc29cffa8a8a7111df7bba92cddf4b8f3f4e6f65", "commit_date": "Sun Jul 31 14:23:09 2016 +0200", "commit_message": "fix the fix for cherrypy >= 5.5 detection", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "7034d2e01d245839792e67d6946997c2bc61dbc6", "commit_date": "Sat Aug 6 12:04:15 2016 +0200", "commit_message": "Merge pull request #634 from Isgar/patch-1", "files_name": ["08f81567aa34357da08523ed59b32e16c6369d67 - Sun Aug 7 18:07:33 2016 +0200 : \"release 0.37.2\"", "CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "60a291816ae06470e3b6951cbb9a9cd4dce6c143", "commit_date": "Thu Sep 1 16:16:34 2016 +0100", "commit_message": "Add support for iTunes album artwork", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "6701db794c8188ee53d61b267e5467437a918f8d", "commit_date": "Thu Sep 1 16:20:56 2016 +0100", "commit_message": "Google album method doesn't exist", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "051353d19595d43439a370347b7f4cd9be755586", "commit_date": "Thu Sep 1 16:47:51 2016 +0100", "commit_message": "Duplicate return statement", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "d3e00807d6e122a543d20e063a67a48950a64b48", "commit_date": "Thu Sep 1 16:48:07 2016 +0100", "commit_message": "Album titles can contain numbers", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "fa8f4555dfe5e39e1ea113849de70e1f22ef4a86", "commit_date": "Thu Sep 1 16:50:07 2016 +0100", "commit_message": "Get keywords from first file in folder", "files_name": ["cherrymusicserver/httphandler.py"]}, {"commit_id": "15bcbbab8d13ae4b4c8ec3fe9e7f988b94b06106", "commit_date": "Thu Sep 1 16:50:54 2016 +0100", "commit_message": "Move the directory name filtering out of album art tool", "files_name": ["cherrymusicserver/albumartfetcher.py", "cherrymusicserver/httphandler.py"]}, {"commit_id": "d1ccacef2bfca2b9bd4675bac3140f808b854468", "commit_date": "Thu Sep 1 22:10:54 2016 +0100", "commit_message": "Fix filtering of directory names", "files_name": ["cherrymusicserver/httphandler.py"]}, {"commit_id": "4ab11292d4052b27e85e52d063d7b459b0d31d8b", "commit_date": "Tue Sep 6 15:55:46 2016 +0100", "commit_message": "Updated changelog", "files_name": ["CHANGES"]}, {"commit_id": "4aee05b209c835c10a1df6acb8c9c198e7337981", "commit_date": "Tue Sep 6 16:13:44 2016 +0100", "commit_message": "pip --use-mirrors no longer supported", "files_name": [".travis.yml"]}, {"commit_id": "46b05d2086aec6584f8620d7d253542b0d250139", "commit_date": "Thu Sep 15 11:34:50 2016 +0200", "commit_message": "Merge pull request #636 from mattss/itunes-artwork", "files_name": ["cb191975ee52d5910560215f66722a37e5d41e3e - Sat Sep 17 17:39:14 2016 +0200 : small refactoring of albumart by meta data feature", "cherrymusicserver/httphandler.py"]}, {"commit_id": "3759f4f52f04aa6fbec973efd74740aaf0f8289f", "commit_date": "Sat Sep 17 17:40:03 2016 +0200", "commit_message": "clean up", "files_name": ["cherrymusicserver/metainfo.py"]}, {"commit_id": "7ad3c473d36a7e7c057812f03433aa3760748640", "commit_date": "Sat Sep 17 17:42:24 2016 +0200", "commit_message": "\"release 0.38.0\"", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "dd5decaf7acfa02c61f4c88dadd889c7ef61bf27", "commit_date": "Mon Oct 3 16:13:56 2016 +0200", "commit_message": "small refactorings", "files_name": ["cherrymusicserver/sqlitecache.py", "cherrymusicserver/util.py"]}, {"commit_id": "6cb73fe50932d66c08d396309393536916d042f5", "commit_date": "Sun Oct 9 19:19:48 2016 +0100", "commit_message": "Fixed not used import in sqlitecache which was breaking the execution of the server.", "files_name": ["cherrymusicserver/sqlitecache.py"]}, {"commit_id": "227ade41238b315eec31b78a79f7ad063fd159a9", "commit_date": "Sun Oct 9 20:24:09 2016 +0200", "commit_message": "\"release 0.39.1\"", "files_name": ["CHANGES", "cherrymusicserver/__init__.py"]}, {"commit_id": "9040c3188e17418f5ab046a316ead934cdfbe6ee", "commit_date": "Sun Oct 9 20:24:26 2016 +0200", "commit_message": "Merge pull request #643 from drmargarido/devel", "files_name": ["545e170eb203ca08fd7011c3ddc55f16ea3ebb70 - Sun Oct 9 20:24:49 2016 +0200 : Merge branch 'devel' of github.com:devsnd/cherrymusic into devel", "ab63ac2f5eb06fcae32910add0d9e8f7bc190782 - Mon Jan 30 23:06:55 2017 +0100 : Use configured server.rootpath in client after logout (#652)", "cherrymusicserver/httphandler.py", "res/js/cherrymusic.js"]}, {"commit_id": "92dd61e8c7ba8631cd7675a887e42312ebf3badd", "commit_date": "Mon Jan 30 23:18:12 2017 +0100", "commit_message": "Backport collections.Counter for Py2.6", "files_name": ["backport/collections/__init__.py", "backport/collections/_backported.py", "cherrymusicserver/sqlitecache.py"]}, {"commit_id": "f001b3661cccae0325a1c1b83be807bb7a6283a9", "commit_date": "Mon Jan 30 23:36:30 2017 +0100", "commit_message": "Fix CherryPy version test", "files_name": ["cherrymusicserver/__init__.py"]}, {"commit_id": "863c9ee2e7925f7adc207d36ea47a2c949de0f46", "commit_date": "Mon Jan 30 23:48:40 2017 +0100", "commit_message": "Fix travis build matrix, do not test py2.6 with CherryPy > 9", "files_name": [".travis.yml"]}, {"commit_id": "6c19e84ce240374fbb3c27aa61315ea029947f26", "commit_date": "Tue Jan 31 00:41:37 2017 +0100", "commit_message": "Change user agent for bestbuy.com, they stall us", "files_name": ["cherrymusicserver/albumartfetcher.py"]}, {"commit_id": "c44216bddbee1032ea165b8f77ebbd55464a4386", "commit_date": "Tue Jan 31 01:35:21 2017 +0100", "commit_message": "Add minified JS for ab63ac2f5eb06 (fixes #652)", "files_name": ["res/dist/cherrymusic.dist.js", "res/js/cherrymusic.js"]}, {"commit_id": "33067200c2d58d3d85346feedddb3b4618347c91", "commit_date": "Tue Feb 7 13:23:15 2017 +0100", "commit_message": "Add _real_ minified JS for ab63ac2f5eb06 (fixes #655, #652)", "files_name": ["res/dist/cherrymusic.dist.js"]}, {"commit_id": "be72fc427b43fa824a8cb767d30318fe2b14dcdd", "commit_date": "Fri Feb 10 14:45:16 2017 -0700", "commit_message": "httphandler: don't assume filenames are latin-1 when transcoding", "files_name": ["cherrymusicserver/httphandler.py"]}, {"commit_id": "e5889bb21ddbea1bb2ebbd0a5bb40446609de8ad", "commit_date": "Sat Mar 4 11:40:29 2017 +0100", "commit_message": "Log supported audio formats in frontend console", "files_name": ["res/dist/cherrymusic.dist.js", "res/js/playlistmanager.js"]}, {"commit_id": "004d9d79d6d6670d58c3eef06562fbf2b606db36", "commit_date": "Sat Mar 4 11:49:50 2017 +0100", "commit_message": "Update docs to reflect new iTunes albumart default method (#663)", "files_name": ["cherrymusicserver/configuration.py", "doc/man/cherrymusic.conf.5", "res/i18n/cherrymusic.pot", "res/i18n/de/LC_MESSAGES/default.mo", "res/i18n/de/LC_MESSAGES/default.po", "res/i18n/es/LC_MESSAGES/default.mo", "res/i18n/es/LC_MESSAGES/default.po", "res/setup.html"]}, {"commit_id": "8dd9deb0548a7ef7cff35f2b82f6e49f93b7e045", "commit_date": "Sun Mar 5 14:20:08 2017 +0100", "commit_message": "Feature: Make albumart fetch method selectable in UI (#663)", "files_name": ["cherrymusicserver/httphandler.py", "res/devel.html"]}], "parents": [{"commit_id_before": "82ad79374f2895e79573255bc81ee143fce4d6a0", "url_before": "https://api.github.com/repos/devsnd/cherrymusic/commits/82ad79374f2895e79573255bc81ee143fce4d6a0", "html_url_before": "https://github.com/devsnd/cherrymusic/commit/82ad79374f2895e79573255bc81ee143fce4d6a0"}], "details": [{"raw_url": "https://github.com/devsnd/cherrymusic/raw/62dec34a1ea0741400dd6b6c660d303dcd651e86/cherrymusicserver%2Fhttphandler.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# CherryMusic - a standalone music server\n# Copyright (c) 2012 - 2015 Tom Wallroth & Tilman Boerner\n#\n# Project page:\n#   http://fomori.org/cherrymusic/\n# Sources on github:\n#   http://github.com/devsnd/cherrymusic/\n#\n# CherryMusic is based on\n#   jPlayer (GPL/MIT license) http://www.jplayer.org/\n#   CherryPy (BSD license) http://www.cherrypy.org/\n#\n# licensed under GNU GPL version 3 (or later)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>\n#\n\n\"\"\"This class provides the api to talk to the client.\nIt will then call the cherrymodel, to get the\nrequested information\"\"\"\n\nimport os  # shouldn't have to list any folder in the future!\nimport json\nimport cherrypy\nimport codecs\nimport sys\n\ntry:\n    from urllib.parse import unquote\nexcept ImportError:\n    from backport.urllib.parse import unquote\ntry:\n    from urllib import parse\nexcept ImportError:\n    from backport.urllib import parse\n\n\nimport audiotranscode\nfrom tinytag import TinyTag\n\nfrom cherrymusicserver import userdb\nfrom cherrymusicserver import log\nfrom cherrymusicserver import albumartfetcher\nfrom cherrymusicserver import service\nfrom cherrymusicserver.pathprovider import readRes\nfrom cherrymusicserver.pathprovider import albumArtFilePath\nimport cherrymusicserver as cherry\nimport cherrymusicserver.metainfo as metainfo\nfrom cherrymusicserver.util import Performance, MemoryZipFile\n\nfrom cherrymusicserver.ext import zipstream\nimport time\n\ndebug = True\n\n\n@service.user(model='cherrymodel', playlistdb='playlist',\n              useroptions='useroptions', userdb='users')\nclass HTTPHandler(object):\n    def __init__(self, config):\n        self.config = config\n\n        template_main = 'res/dist/main.html'\n        template_login = 'res/login.html'\n        template_firstrun = 'res/firstrun.html'\n\n        self.mainpage = readRes(template_main)\n        self.loginpage = readRes(template_login)\n        self.firstrunpage = readRes(template_firstrun)\n\n        self.handlers = {\n            'search': self.api_search,\n            'rememberplaylist': self.api_rememberplaylist,\n            'saveplaylist': self.api_saveplaylist,\n            'loadplaylist': self.api_loadplaylist,\n            'generaterandomplaylist': self.api_generaterandomplaylist,\n            'deleteplaylist': self.api_deleteplaylist,\n            'getmotd': self.api_getmotd,\n            'restoreplaylist': self.api_restoreplaylist,\n            'getplayables': self.api_getplayables,\n            'getuserlist': self.api_getuserlist,\n            'adduser': self.api_adduser,\n            'userdelete': self.api_userdelete,\n            'userchangepassword': self.api_userchangepassword,\n            'showplaylists': self.api_showplaylists,\n            'logout': self.api_logout,\n            'downloadpls': self.api_downloadpls,\n            'downloadm3u': self.api_downloadm3u,\n            'getsonginfo': self.api_getsonginfo,\n            'getencoders': self.api_getencoders,\n            'getdecoders': self.api_getdecoders,\n            'transcodingenabled': self.api_transcodingenabled,\n            'updatedb': self.api_updatedb,\n            'getconfiguration': self.api_getconfiguration,\n            'compactlistdir': self.api_compactlistdir,\n            'listdir': self.api_listdir,\n            'fetchalbumart': self.api_fetchalbumart,\n            'fetchalbumarturls': self.api_fetchalbumarturls,\n            'albumart_set': self.api_albumart_set,\n            'heartbeat': self.api_heartbeat,\n            'getuseroptions': self.api_getuseroptions,\n            'setuseroption': self.api_setuseroption,\n            'changeplaylist': self.api_changeplaylist,\n            'downloadcheck': self.api_downloadcheck,\n            'setuseroptionfor': self.api_setuseroptionfor,\n        }\n\n    def issecure(self, url):\n        return parse.urlparse(url).scheme == 'https'\n\n    def getBaseUrl(self, redirect_unencrypted=False):\n        ipAndPort = parse.urlparse(cherrypy.url()).netloc\n        is_secure_connection = self.issecure(cherrypy.url())\n        ssl_enabled = cherry.config['server.ssl_enabled']\n        if ssl_enabled and not is_secure_connection:\n            log.d(_('Not secure, redirecting...'))\n            ip = ipAndPort[:ipAndPort.rindex(':')]\n            url = 'https://' + ip + ':' + str(cherry.config['server.ssl_port'])\n            if redirect_unencrypted:\n                raise cherrypy.HTTPRedirect(url, 302)\n        else:\n            url = 'http://' + ipAndPort\n        return url\n\n    def index(self, *args, **kwargs):\n        self.getBaseUrl(redirect_unencrypted=True)\n        firstrun = 0 == self.userdb.getUserCount()\n        show_page = self.mainpage #generated main.html from devel.html\n        if 'devel' in kwargs:\n            #reload pages everytime in devel mode\n            show_page = readRes('res/devel.html')\n            self.loginpage = readRes('res/login.html')\n            self.firstrunpage = readRes('res/firstrun.html')\n        if 'login' in kwargs:\n            username = kwargs.get('username', '')\n            password = kwargs.get('password', '')\n            login_action = kwargs.get('login', '')\n            if login_action == 'login':\n                self.session_auth(username, password)\n                if cherrypy.session['username']:\n                    username = cherrypy.session['username']\n                    log.i(_('user {name} just logged in.').format(name=username))\n            elif login_action == 'create admin user':\n                if firstrun:\n                    if username.strip() and password.strip():\n                        self.userdb.addUser(username, password, True)\n                        self.session_auth(username, password)\n                        return show_page\n                else:\n                    return \"No, you can't.\"\n        if firstrun:\n            return self.firstrunpage\n        else:\n            if self.isAuthorized():\n                return show_page\n            else:\n                return self.loginpage\n    index.exposed = True\n\n    def isAuthorized(self):\n        try:\n            sessionUsername = cherrypy.session.get('username', None)\n            sessionUserId = cherrypy.session.get('userid', -1)\n            nameById = self.userdb.getNameById(sessionUserId)\n        except (UnicodeDecodeError, ValueError) as e:\n            # workaround for python2/python3 jump, filed bug in cherrypy\n            # https://bitbucket.org/cherrypy/cherrypy/issue/1216/sessions-python2-3-compability-unsupported\n            log.w(_('''\n            Dropping all sessions! Try not to change between python 2 and 3,\n            everybody has to relogin now.'''))\n            cherrypy.session.delete()\n            sessionUsername = None\n        if sessionUsername is None:\n            if self.autoLoginActive():\n                cherrypy.session['username'] = self.userdb.getNameById(1)\n                cherrypy.session['userid'] = 1\n                cherrypy.session['admin'] = True\n                return True\n            else:\n                return False\n        elif sessionUsername != nameById:\n            self.api_logout(value=None)\n            return False\n        return True\n\n    def autoLoginActive(self):\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if is_loopback and cherry.config['server.localhost_auto_login']:\n            return True\n        return False\n\n    def session_auth(self, username, password):\n        user = self.userdb.auth(username, password)\n        allow_remote = cherry.config['server.permit_remote_admin_login']\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if not is_loopback and user.isadmin and not allow_remote:\n            log.i(_('Rejected remote admin login from user: {name}').format(name=user.name))\n            user = userdb.User.nobody()\n        cherrypy.session['username'] = user.name\n        cherrypy.session['userid'] = user.uid\n        cherrypy.session['admin'] = user.isadmin\n\n    def getUserId(self):\n        try:\n            return cherrypy.session['userid']\n        except KeyError:\n            cherrypy.lib.sessions.expire()\n            cherrypy.HTTPRedirect(cherrypy.url(), 302)\n            return ''\n\n    def trans(self, newformat, *path, **params):\n        ''' Transcodes the track given as ``path`` into ``newformat``.\n\n            Streams the response of the corresponding\n            ``audiotranscode.AudioTranscode().transcodeStream()`` call.\n\n            params:\n                bitrate: int for kbps. None or < 1 for default\n        '''\n        if not self.isAuthorized():\n            raise cherrypy.HTTPRedirect(self.getBaseUrl(), 302)\n        cherrypy.session.release_lock()\n        if cherry.config['media.transcode'] and path:\n\n            # bitrate\n            bitrate = params.pop('bitrate', None) or None  # catch empty strings\n            if bitrate:\n                try:\n                    bitrate = max(0, int(bitrate)) or None  # None if < 1\n                except (TypeError, ValueError):\n                    raise cherrypy.HTTPError(400, \"Bad query: \"\n                        \"bitrate ({0!r}) must be an integer\".format(str(bitrate)))\n\n            # path\n            path = os.path.sep.join(path)\n            if sys.version_info < (3, 0):       # workaround for #327 (cherrypy issue)\n                path = path.decode('utf-8')     # make it work with non-ascii\n            else:\n                path = codecs.decode(codecs.encode(path, 'latin1'), 'utf-8')\n            fullpath = os.path.join(cherry.config['media.basedir'], path)\n\n            starttime = int(params.pop('starttime', 0))\n\n            transcoder = audiotranscode.AudioTranscode()\n            mimetype = audiotranscode.mime_type(newformat)\n            cherrypy.response.headers[\"Content-Type\"] = mimetype\n            try:\n                return transcoder.transcode_stream(fullpath, newformat,\n                            bitrate=bitrate, starttime=starttime)\n            except (audiotranscode.TranscodeError, IOError) as e:\n                raise cherrypy.HTTPError(404, e.value)\n    trans.exposed = True\n    trans._cp_config = {'response.stream': True}\n\n\n    def api(self, *args, **kwargs):\n        \"\"\"calls the appropriate handler from the handlers\n        dict, if available. handlers having noauth set to\n        true do not need authentification to work.\n        \"\"\"\n        #check action\n        action = args[0] if args else ''\n        if not action in self.handlers:\n            return \"Error: no such action. '%s'\" % action\n        #authorize if not explicitly deactivated\n        handler = self.handlers[action]\n        needsAuth = not ('noauth' in dir(handler) and handler.noauth)\n        if needsAuth and not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        handler_args = {}\n        if 'data' in kwargs:\n            handler_args = json.loads(kwargs['data'])\n        is_binary = ('binary' in dir(handler) and handler.binary)\n        if is_binary:\n            return handler(**handler_args)\n        else:\n            return json.dumps({'data': handler(**handler_args)})\n\n    api.exposed = True\n\n    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            # don't allow to traverse up in the file system\n            if '/../' in f or f.startswith('../'):\n                return 'invalid_file'\n            # CVE-2015-8309: do not allow absolute file paths\n            if os.path.isabs(f):\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)\n\n    def api_downloadcheck(self, filelist):\n        status = self.download_check_files(filelist)\n        if status == 'not_permitted':\n            return \"\"\"You are not allowed to download files.\"\"\"\n        elif status == 'invalid_file':\n            return \"Error: invalid filename found in {list}\".format(list=filelist)\n        elif status == 'too_big':\n            size_limit = cherry.config['media.maximum_download_size']\n            return \"\"\"Can't download: Playlist is bigger than {maxsize} mB.\n                        The server administrator can change this configuration.\n                        \"\"\".format(maxsize=size_limit/1024/1024)\n        elif status == 'ok':\n            return status\n        else:\n            message = \"Error status check for download: {status!r}\".format(status=status)\n            log.e(message)\n            return message\n\n    def download(self, value):\n        if not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        filelist = [filepath for filepath in json.loads(unquote(value))]\n        dlstatus = self.download_check_files(filelist)\n        if dlstatus == 'ok':\n            _save_and_release_session()\n            zipmime = 'application/x-zip-compressed'\n            cherrypy.response.headers[\"Content-Type\"] = zipmime\n            zipname = 'attachment; filename=\"music.zip\"'\n            cherrypy.response.headers['Content-Disposition'] = zipname\n            basedir = cherry.config['media.basedir']\n            fullpath_filelist = [os.path.join(basedir, f) for f in filelist]\n            return zipstream.ZipStream(fullpath_filelist)\n        else:\n            return dlstatus\n    download.exposed = True\n    download._cp_config = {'response.stream': True}\n\n    def api_getuseroptions(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uco = uo.getChangableOptions()\n        if cherrypy.session['admin']:\n            uco['media'].update({'may_download': True})\n        else:\n            uco['media'].update({'may_download': uo.getOptionValue('media.may_download')})\n        return uco\n\n    def api_heartbeat(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption('last_time_online', int(time.time()))\n\n    def api_setuseroption(self, optionkey, optionval):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption(optionkey, optionval)\n        return \"success\"\n\n    def api_setuseroptionfor(self, userid, optionkey, optionval):\n        if cherrypy.session['admin']:\n            uo = self.useroptions.forUser(userid)\n            uo.setOption(optionkey, optionval)\n            return \"success\"\n        else:\n            return \"error: not permitted. Only admins can change other users options\"\n\n    def api_fetchalbumarturls(self, searchterm):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        _save_and_release_session()\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        imgurls = fetcher.fetchurls(searchterm)\n        # show no more than 10 images\n        return imgurls[:min(len(imgurls), 10)]\n\n    def api_albumart_set(self, directory, imageurl):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        b64imgpath = albumArtFilePath(directory)\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        data, header = fetcher.retrieveData(imageurl)\n        self.albumartcache_save(b64imgpath, data)\n\n    def api_fetchalbumart(self, directory):\n        _save_and_release_session()\n        default_folder_image = \"../res/img/folder.png\"\n\n        log.i('Fetching album art for: %s' % directory)\n        filepath = os.path.join(cherry.config['media.basedir'], directory)\n\n        if os.path.isfile(filepath):\n            # if the given path is a file, try to get the image from ID3\n            tag = TinyTag.get(filepath, image=True)\n            image_data = tag.get_image()\n            if image_data:\n                log.d('Image found in tag.')\n                header = {'Content-Type': 'image/jpg', 'Content-Length': len(image_data)}\n                cherrypy.response.headers.update(header)\n                return image_data\n            else:\n                # if the file does not contain an image, display the image of the\n                # parent directory\n                directory = os.path.dirname(directory)\n\n        #try getting a cached album art image\n        b64imgpath = albumArtFilePath(directory)\n        img_data = self.albumartcache_load(b64imgpath)\n        if img_data:\n            cherrypy.response.headers[\"Content-Length\"] = len(img_data)\n            return img_data\n\n        #try getting album art inside local folder\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        localpath = os.path.join(cherry.config['media.basedir'], directory)\n        header, data, resized = fetcher.fetchLocal(localpath)\n\n        if header:\n            if resized:\n                #cache resized image for next time\n                self.albumartcache_save(b64imgpath, data)\n            cherrypy.response.headers.update(header)\n            return data\n        elif cherry.config['media.fetch_album_art']:\n            #fetch album art from online source\n            try:\n                foldername = os.path.basename(directory)\n                keywords = foldername\n                log.i(_(\"Fetching album art for keywords {keywords!r}\").format(keywords=keywords))\n                header, data = fetcher.fetch(keywords)\n                if header:\n                    cherrypy.response.headers.update(header)\n                    self.albumartcache_save(b64imgpath, data)\n                    return data\n                else:\n                    # albumart fetcher failed, so we serve a standard image\n                    raise cherrypy.HTTPRedirect(default_folder_image, 302)\n            except:\n                # albumart fetcher threw exception, so we serve a standard image\n                raise cherrypy.HTTPRedirect(default_folder_image, 302)\n        else:\n            # no local album art found, online fetching deactivated, show default\n            raise cherrypy.HTTPRedirect(default_folder_image, 302)\n    api_fetchalbumart.noauth = True\n    api_fetchalbumart.binary = True\n\n    def albumartcache_load(self, imgb64path):\n        if os.path.exists(imgb64path):\n            with open(imgb64path, 'rb') as f:\n                return f.read()\n\n    def albumartcache_save(self, path, data):\n        with open(path, 'wb') as f:\n            f.write(data)\n\n    def api_compactlistdir(self, directory, filterstr=None):\n        try:\n            files_to_list = self.model.listdir(directory, filterstr)\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n        return [entry.to_dict() for entry in files_to_list]\n\n    def api_listdir(self, directory):\n        try:\n            return [entry.to_dict() for entry in self.model.listdir(directory)]\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n\n    def api_search(self, searchstring):\n        if not searchstring.strip():\n            jsonresults = '[]'\n        else:\n            with Performance(_('processing whole search request')):\n                searchresults = self.model.search(searchstring.strip())\n                with Performance(_('rendering search results as json')):\n                    jsonresults = [entry.to_dict() for entry in searchresults]\n        return jsonresults\n\n    def api_rememberplaylist(self, playlist):\n        cherrypy.session['playlist'] = playlist\n\n    def api_saveplaylist(self, playlist, public, playlistname, overwrite=False):\n        res = self.playlistdb.savePlaylist(\n            userid=self.getUserId(),\n            public=1 if public else 0,\n            playlist=playlist,\n            playlisttitle=playlistname,\n            overwrite=overwrite)\n        if res == \"success\":\n            return res\n        else:\n            raise cherrypy.HTTPError(400, res)\n\n    def api_deleteplaylist(self, playlistid):\n        res = self.playlistdb.deletePlaylist(playlistid,\n                                             self.getUserId(),\n                                             override_owner=False)\n        if res == \"success\":\n            return res\n        else:\n            # not the ideal status code but we don't know the actual\n            # cause without parsing res\n            raise cherrypy.HTTPError(400, res)\n\n    def api_loadplaylist(self, playlistid):\n        return [entry.to_dict() for entry in self.playlistdb.loadPlaylist(\n                                        playlistid=playlistid,\n                                        userid=self.getUserId()\n                                        )]\n\n    def api_generaterandomplaylist(self):\n        return [entry.to_dict() for entry in self.model.randomMusicEntries(50)]\n\n    def api_changeplaylist(self, plid, attribute, value):\n        if attribute == 'public':\n            is_valid = type(value) == bool and type(plid) == int\n            if is_valid:\n                return self.playlistdb.setPublic(userid=self.getUserId(),\n                                                 plid=plid,\n                                                 public=value)\n\n    def api_getmotd(self):\n        if cherrypy.session['admin'] and cherry.config['general.update_notification']:\n            _save_and_release_session()\n            new_versions = self.model.check_for_updates()\n            if new_versions:\n                newest_version = new_versions[0]['version']\n                features = []\n                fixes = []\n                for version in new_versions:\n                    for update in version['features']:\n                        if update.startswith('FEATURE:'):\n                            features.append(update[len('FEATURE:'):])\n                        elif update.startswith('FIX:'):\n                            fixes.append(update[len('FIX:'):])\n                        elif update.startswith('FIXED:'):\n                            fixes.append(update[len('FIXED:'):])\n                retdata = {'type': 'update', 'data': {}}\n                retdata['data']['version'] = newest_version\n                retdata['data']['features'] = features\n                retdata['data']['fixes'] = fixes\n                return retdata\n        return {'type': 'wisdom', 'data': self.model.motd()}\n\n    def api_restoreplaylist(self):\n        session_playlist = cherrypy.session.get('playlist', [])\n        return session_playlist\n\n    def api_getplayables(self):\n        \"\"\"DEPRECATED\"\"\"\n        return json.dumps(cherry.config['media.playable'])\n\n    def api_getuserlist(self):\n        if cherrypy.session['admin']:\n            userlist = self.userdb.getUserList()\n            for user in userlist:\n                if user['id'] == cherrypy.session['userid']:\n                    user['deletable'] = False\n                user_options = self.useroptions.forUser(user['id'])\n                t = user_options.getOptionValue('last_time_online')\n                may_download = user_options.getOptionValue('media.may_download')\n                user['last_time_online'] = t\n                user['may_download'] = may_download\n            sortfunc = lambda user: user['last_time_online']\n            userlist = sorted(userlist, key=sortfunc, reverse=True)\n            return json.dumps({'time': int(time.time()),\n                               'userlist': userlist})\n        else:\n            return json.dumps({'time': 0, 'userlist': []})\n\n    def api_adduser(self, username, password, isadmin):\n        if cherrypy.session['admin']:\n            if self.userdb.addUser(username, password, isadmin):\n                return 'added new user: %s' % username\n            else:\n                return 'error, cannot add new user!' % username\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_userchangepassword(self, oldpassword, newpassword, username=''):\n        isself = username == ''\n        if isself:\n            username = cherrypy.session['username']\n            authed_user = self.userdb.auth(username, oldpassword)\n            is_authenticated = userdb.User.nobody() != authed_user\n            if not is_authenticated:\n                raise cherrypy.HTTPError(403, \"Forbidden\")\n        if isself or cherrypy.session['admin']:\n            return self.userdb.changePassword(username, newpassword)\n        else:\n            raise cherrypy.HTTPError(403, \"Forbidden\")\n\n    def api_userdelete(self, userid):\n        is_self = cherrypy.session['userid'] == userid\n        if cherrypy.session['admin'] and not is_self:\n            deleted = self.userdb.deleteUser(userid)\n            return 'success' if deleted else 'failed'\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_showplaylists(self, sortby=\"created\", filterby=''):\n        playlists = self.playlistdb.showPlaylists(self.getUserId(), filterby)\n        curr_time = int(time.time())\n        is_reverse = False\n        #translate userids to usernames:\n        for pl in playlists:\n            pl['username'] = self.userdb.getNameById(pl['userid'])\n            pl['type'] = 'playlist'\n            pl['age'] = curr_time - pl['created']\n        if sortby[0] == '-':\n            is_reverse = True\n            sortby = sortby[1:]\n        if not sortby in ('username', 'age', 'title', 'default'):\n            sortby = 'created'\n        if sortby == 'default':\n            sortby = 'age'\n            is_reverse = False\n        playlists = sorted(playlists, key=lambda x: x[sortby], reverse = is_reverse)\n        return playlists\n\n    def api_logout(self):\n        cherrypy.lib.sessions.expire()\n    api_logout.no_auth = True\n\n    def api_downloadpls(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createPLS(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.pls')\n    api_downloadpls.binary = True\n\n    def api_downloadm3u(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createM3U(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.m3u')\n    api_downloadm3u.binary = True\n\n    def export_playlists(self, format, all=False, hostaddr=''):\n        userid = self.getUserId()\n        if not userid:\n            raise cherrypy.HTTPError(401, _(\"Please log in\"))\n        hostaddr = (hostaddr.strip().rstrip('/') + cherry.config['server.rootpath']).rstrip('/')\n\n        format = format.lower()\n        if format == 'm3u':\n            filemaker = self.playlistdb.createM3U\n        elif format == 'pls':\n            filemaker = self.playlistdb.createPLS\n        else:\n            raise cherrypy.HTTPError(400,\n                _('Unknown playlist format: {format!r}').format(format=format))\n\n        playlists = self.playlistdb.showPlaylists(userid, include_public=all)\n        if not playlists:\n            raise cherrypy.HTTPError(404, _('No playlists found'))\n\n        with MemoryZipFile() as zip:\n            for pl in playlists:\n                plid = pl['plid']\n                plstr = filemaker(plid=plid, userid=userid, addrstr=hostaddr)\n                name = self.playlistdb.getName(plid, userid) + '.' + format\n                if not pl['owner']:\n                    username = self.userdb.getNameById(pl['userid'])\n                    name =  username + '/' + name\n                zip.writestr(name, plstr)\n\n        zipmime = 'application/x-zip-compressed'\n        zipname = 'attachment; filename=\"playlists.zip\"'\n        cherrypy.response.headers[\"Content-Type\"] = zipmime\n        cherrypy.response.headers['Content-Disposition'] = zipname\n        return zip.getbytes()\n    export_playlists.exposed = True\n\n    def api_getsonginfo(self, path):\n        basedir = cherry.config['media.basedir']\n        abspath = os.path.join(basedir, path)\n        return json.dumps(metainfo.getSongInfo(abspath).dict())\n\n    def api_getencoders(self):\n        return json.dumps(audiotranscode.getEncoders())\n\n    def api_getdecoders(self):\n        return json.dumps(audiotranscode.getDecoders())\n\n    def api_transcodingenabled(self):\n        return json.dumps(cherry.config['media.transcode'])\n\n    def api_updatedb(self):\n        self.model.updateLibrary()\n        return 'success'\n\n    def api_getconfiguration(self):\n        clientconfigkeys = {\n            'transcodingenabled': cherry.config['media.transcode'],\n            'fetchalbumart': cherry.config['media.fetch_album_art'],\n            'isadmin': cherrypy.session['admin'],\n            'username': cherrypy.session['username'],\n            'servepath': 'serve/',\n            'transcodepath': 'trans/',\n            'auto_login': self.autoLoginActive(),\n            'version': cherry.REPO_VERSION or cherry.VERSION,\n        }\n        if cherry.config['media.transcode']:\n            decoders = list(self.model.transcoder.available_decoder_formats())\n            clientconfigkeys['getdecoders'] = decoders\n            encoders = list(self.model.transcoder.available_encoder_formats())\n            clientconfigkeys['getencoders'] = encoders\n        else:\n            clientconfigkeys['getdecoders'] = []\n            clientconfigkeys['getencoders'] = []\n        return clientconfigkeys\n\n    def serve_string_as_file(self, string, filename):\n        content_disposition = 'attachment; filename=\"'+filename+'\"'\n        cherrypy.response.headers[\"Content-Type\"] = \"application/x-download\"\n        cherrypy.response.headers[\"Content-Disposition\"] = content_disposition\n        return codecs.encode(string, \"UTF-8\")\n\n\ndef _save_and_release_session():\n    \"\"\" workaround to cleanly release FileSessions in Cherrypy >= 3.3\n\n        From https://github.com/devsnd/cherrymusic/issues/483:\n\n        > CherryPy >=3.3.0 (up to current version, 3.6) makes it impossible to\n        > explicitly release FileSession locks, because:\n\n        > 1. FileSession.save() asserts that the session is locked; and\n\n        > 2. _cptools.SessionTool always adds a hook to call sessions.save\n        > before the response is finalized.\n\n        > If we still want to release the session in a controller, I guess the\n        > best way to work around this is to remove the hook before the\n        > controller returns:\n    \"\"\"\n    cherrypy.session.save()\n    hooks = cherrypy.serving.request.hooks['before_finalize']\n    forbidden = cherrypy.lib.sessions.save\n    hooks[:] = [h for h in hooks if h.callback is not forbidden]\n    # there's likely only one hook, since a 2nd call to save would always fail;\n    # but let's be safe, and block all calls to save :)\n", "code_before": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# CherryMusic - a standalone music server\n# Copyright (c) 2012 - 2015 Tom Wallroth & Tilman Boerner\n#\n# Project page:\n#   http://fomori.org/cherrymusic/\n# Sources on github:\n#   http://github.com/devsnd/cherrymusic/\n#\n# CherryMusic is based on\n#   jPlayer (GPL/MIT license) http://www.jplayer.org/\n#   CherryPy (BSD license) http://www.cherrypy.org/\n#\n# licensed under GNU GPL version 3 (or later)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>\n#\n\n\"\"\"This class provides the api to talk to the client.\nIt will then call the cherrymodel, to get the\nrequested information\"\"\"\n\nimport os  # shouldn't have to list any folder in the future!\nimport json\nimport cherrypy\nimport codecs\nimport sys\n\ntry:\n    from urllib.parse import unquote\nexcept ImportError:\n    from backport.urllib.parse import unquote\ntry:\n    from urllib import parse\nexcept ImportError:\n    from backport.urllib import parse\n\n\nimport audiotranscode\nfrom tinytag import TinyTag\n\nfrom cherrymusicserver import userdb\nfrom cherrymusicserver import log\nfrom cherrymusicserver import albumartfetcher\nfrom cherrymusicserver import service\nfrom cherrymusicserver.pathprovider import readRes\nfrom cherrymusicserver.pathprovider import albumArtFilePath\nimport cherrymusicserver as cherry\nimport cherrymusicserver.metainfo as metainfo\nfrom cherrymusicserver.util import Performance, MemoryZipFile\n\nfrom cherrymusicserver.ext import zipstream\nimport time\n\ndebug = True\n\n\n@service.user(model='cherrymodel', playlistdb='playlist',\n              useroptions='useroptions', userdb='users')\nclass HTTPHandler(object):\n    def __init__(self, config):\n        self.config = config\n\n        template_main = 'res/dist/main.html'\n        template_login = 'res/login.html'\n        template_firstrun = 'res/firstrun.html'\n\n        self.mainpage = readRes(template_main)\n        self.loginpage = readRes(template_login)\n        self.firstrunpage = readRes(template_firstrun)\n\n        self.handlers = {\n            'search': self.api_search,\n            'rememberplaylist': self.api_rememberplaylist,\n            'saveplaylist': self.api_saveplaylist,\n            'loadplaylist': self.api_loadplaylist,\n            'generaterandomplaylist': self.api_generaterandomplaylist,\n            'deleteplaylist': self.api_deleteplaylist,\n            'getmotd': self.api_getmotd,\n            'restoreplaylist': self.api_restoreplaylist,\n            'getplayables': self.api_getplayables,\n            'getuserlist': self.api_getuserlist,\n            'adduser': self.api_adduser,\n            'userdelete': self.api_userdelete,\n            'userchangepassword': self.api_userchangepassword,\n            'showplaylists': self.api_showplaylists,\n            'logout': self.api_logout,\n            'downloadpls': self.api_downloadpls,\n            'downloadm3u': self.api_downloadm3u,\n            'getsonginfo': self.api_getsonginfo,\n            'getencoders': self.api_getencoders,\n            'getdecoders': self.api_getdecoders,\n            'transcodingenabled': self.api_transcodingenabled,\n            'updatedb': self.api_updatedb,\n            'getconfiguration': self.api_getconfiguration,\n            'compactlistdir': self.api_compactlistdir,\n            'listdir': self.api_listdir,\n            'fetchalbumart': self.api_fetchalbumart,\n            'fetchalbumarturls': self.api_fetchalbumarturls,\n            'albumart_set': self.api_albumart_set,\n            'heartbeat': self.api_heartbeat,\n            'getuseroptions': self.api_getuseroptions,\n            'setuseroption': self.api_setuseroption,\n            'changeplaylist': self.api_changeplaylist,\n            'downloadcheck': self.api_downloadcheck,\n            'setuseroptionfor': self.api_setuseroptionfor,\n        }\n\n    def issecure(self, url):\n        return parse.urlparse(url).scheme == 'https'\n\n    def getBaseUrl(self, redirect_unencrypted=False):\n        ipAndPort = parse.urlparse(cherrypy.url()).netloc\n        is_secure_connection = self.issecure(cherrypy.url())\n        ssl_enabled = cherry.config['server.ssl_enabled']\n        if ssl_enabled and not is_secure_connection:\n            log.d(_('Not secure, redirecting...'))\n            ip = ipAndPort[:ipAndPort.rindex(':')]\n            url = 'https://' + ip + ':' + str(cherry.config['server.ssl_port'])\n            if redirect_unencrypted:\n                raise cherrypy.HTTPRedirect(url, 302)\n        else:\n            url = 'http://' + ipAndPort\n        return url\n\n    def index(self, *args, **kwargs):\n        self.getBaseUrl(redirect_unencrypted=True)\n        firstrun = 0 == self.userdb.getUserCount()\n        show_page = self.mainpage #generated main.html from devel.html\n        if 'devel' in kwargs:\n            #reload pages everytime in devel mode\n            show_page = readRes('res/devel.html')\n            self.loginpage = readRes('res/login.html')\n            self.firstrunpage = readRes('res/firstrun.html')\n        if 'login' in kwargs:\n            username = kwargs.get('username', '')\n            password = kwargs.get('password', '')\n            login_action = kwargs.get('login', '')\n            if login_action == 'login':\n                self.session_auth(username, password)\n                if cherrypy.session['username']:\n                    username = cherrypy.session['username']\n                    log.i(_('user {name} just logged in.').format(name=username))\n            elif login_action == 'create admin user':\n                if firstrun:\n                    if username.strip() and password.strip():\n                        self.userdb.addUser(username, password, True)\n                        self.session_auth(username, password)\n                        return show_page\n                else:\n                    return \"No, you can't.\"\n        if firstrun:\n            return self.firstrunpage\n        else:\n            if self.isAuthorized():\n                return show_page\n            else:\n                return self.loginpage\n    index.exposed = True\n\n    def isAuthorized(self):\n        try:\n            sessionUsername = cherrypy.session.get('username', None)\n            sessionUserId = cherrypy.session.get('userid', -1)\n            nameById = self.userdb.getNameById(sessionUserId)\n        except (UnicodeDecodeError, ValueError) as e:\n            # workaround for python2/python3 jump, filed bug in cherrypy\n            # https://bitbucket.org/cherrypy/cherrypy/issue/1216/sessions-python2-3-compability-unsupported\n            log.w(_('''\n            Dropping all sessions! Try not to change between python 2 and 3,\n            everybody has to relogin now.'''))\n            cherrypy.session.delete()\n            sessionUsername = None\n        if sessionUsername is None:\n            if self.autoLoginActive():\n                cherrypy.session['username'] = self.userdb.getNameById(1)\n                cherrypy.session['userid'] = 1\n                cherrypy.session['admin'] = True\n                return True\n            else:\n                return False\n        elif sessionUsername != nameById:\n            self.api_logout(value=None)\n            return False\n        return True\n\n    def autoLoginActive(self):\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if is_loopback and cherry.config['server.localhost_auto_login']:\n            return True\n        return False\n\n    def session_auth(self, username, password):\n        user = self.userdb.auth(username, password)\n        allow_remote = cherry.config['server.permit_remote_admin_login']\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if not is_loopback and user.isadmin and not allow_remote:\n            log.i(_('Rejected remote admin login from user: {name}').format(name=user.name))\n            user = userdb.User.nobody()\n        cherrypy.session['username'] = user.name\n        cherrypy.session['userid'] = user.uid\n        cherrypy.session['admin'] = user.isadmin\n\n    def getUserId(self):\n        try:\n            return cherrypy.session['userid']\n        except KeyError:\n            cherrypy.lib.sessions.expire()\n            cherrypy.HTTPRedirect(cherrypy.url(), 302)\n            return ''\n\n    def trans(self, newformat, *path, **params):\n        ''' Transcodes the track given as ``path`` into ``newformat``.\n\n            Streams the response of the corresponding\n            ``audiotranscode.AudioTranscode().transcodeStream()`` call.\n\n            params:\n                bitrate: int for kbps. None or < 1 for default\n        '''\n        if not self.isAuthorized():\n            raise cherrypy.HTTPRedirect(self.getBaseUrl(), 302)\n        cherrypy.session.release_lock()\n        if cherry.config['media.transcode'] and path:\n\n            # bitrate\n            bitrate = params.pop('bitrate', None) or None  # catch empty strings\n            if bitrate:\n                try:\n                    bitrate = max(0, int(bitrate)) or None  # None if < 1\n                except (TypeError, ValueError):\n                    raise cherrypy.HTTPError(400, \"Bad query: \"\n                        \"bitrate ({0!r}) must be an integer\".format(str(bitrate)))\n\n            # path\n            path = os.path.sep.join(path)\n            if sys.version_info < (3, 0):       # workaround for #327 (cherrypy issue)\n                path = path.decode('utf-8')     # make it work with non-ascii\n            else:\n                path = codecs.decode(codecs.encode(path, 'latin1'), 'utf-8')\n            fullpath = os.path.join(cherry.config['media.basedir'], path)\n\n            starttime = int(params.pop('starttime', 0))\n\n            transcoder = audiotranscode.AudioTranscode()\n            mimetype = audiotranscode.mime_type(newformat)\n            cherrypy.response.headers[\"Content-Type\"] = mimetype\n            try:\n                return transcoder.transcode_stream(fullpath, newformat,\n                            bitrate=bitrate, starttime=starttime)\n            except (audiotranscode.TranscodeError, IOError) as e:\n                raise cherrypy.HTTPError(404, e.value)\n    trans.exposed = True\n    trans._cp_config = {'response.stream': True}\n\n\n    def api(self, *args, **kwargs):\n        \"\"\"calls the appropriate handler from the handlers\n        dict, if available. handlers having noauth set to\n        true do not need authentification to work.\n        \"\"\"\n        #check action\n        action = args[0] if args else ''\n        if not action in self.handlers:\n            return \"Error: no such action. '%s'\" % action\n        #authorize if not explicitly deactivated\n        handler = self.handlers[action]\n        needsAuth = not ('noauth' in dir(handler) and handler.noauth)\n        if needsAuth and not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        handler_args = {}\n        if 'data' in kwargs:\n            handler_args = json.loads(kwargs['data'])\n        is_binary = ('binary' in dir(handler) and handler.binary)\n        if is_binary:\n            return handler(**handler_args)\n        else:\n            return json.dumps({'data': handler(**handler_args)})\n\n    api.exposed = True\n\n    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            if '/../' in f:\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)\n\n    def api_downloadcheck(self, filelist):\n        status = self.download_check_files(filelist)\n        if status == 'not_permitted':\n            return \"\"\"You are not allowed to download files.\"\"\"\n        elif status == 'invalid_file':\n            return \"Error: invalid filename found in {list}\".format(list=filelist)\n        elif status == 'too_big':\n            size_limit = cherry.config['media.maximum_download_size']\n            return \"\"\"Can't download: Playlist is bigger than {maxsize} mB.\n                        The server administrator can change this configuration.\n                        \"\"\".format(maxsize=size_limit/1024/1024)\n        elif status == 'ok':\n            return status\n        else:\n            message = \"Error status check for download: {status!r}\".format(status=status)\n            log.e(message)\n            return message\n\n    def download(self, value):\n        if not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        filelist = [filepath for filepath in json.loads(unquote(value))]\n        dlstatus = self.download_check_files(filelist)\n        if dlstatus == 'ok':\n            _save_and_release_session()\n            zipmime = 'application/x-zip-compressed'\n            cherrypy.response.headers[\"Content-Type\"] = zipmime\n            zipname = 'attachment; filename=\"music.zip\"'\n            cherrypy.response.headers['Content-Disposition'] = zipname\n            basedir = cherry.config['media.basedir']\n            fullpath_filelist = [os.path.join(basedir, f) for f in filelist]\n            return zipstream.ZipStream(fullpath_filelist)\n        else:\n            return dlstatus\n    download.exposed = True\n    download._cp_config = {'response.stream': True}\n\n    def api_getuseroptions(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uco = uo.getChangableOptions()\n        if cherrypy.session['admin']:\n            uco['media'].update({'may_download': True})\n        else:\n            uco['media'].update({'may_download': uo.getOptionValue('media.may_download')})\n        return uco\n\n    def api_heartbeat(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption('last_time_online', int(time.time()))\n\n    def api_setuseroption(self, optionkey, optionval):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption(optionkey, optionval)\n        return \"success\"\n\n    def api_setuseroptionfor(self, userid, optionkey, optionval):\n        if cherrypy.session['admin']:\n            uo = self.useroptions.forUser(userid)\n            uo.setOption(optionkey, optionval)\n            return \"success\"\n        else:\n            return \"error: not permitted. Only admins can change other users options\"\n\n    def api_fetchalbumarturls(self, searchterm):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        _save_and_release_session()\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        imgurls = fetcher.fetchurls(searchterm)\n        # show no more than 10 images\n        return imgurls[:min(len(imgurls), 10)]\n\n    def api_albumart_set(self, directory, imageurl):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        b64imgpath = albumArtFilePath(directory)\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        data, header = fetcher.retrieveData(imageurl)\n        self.albumartcache_save(b64imgpath, data)\n\n    def api_fetchalbumart(self, directory):\n        _save_and_release_session()\n        default_folder_image = \"../res/img/folder.png\"\n\n        log.i('Fetching album art for: %s' % directory)\n        filepath = os.path.join(cherry.config['media.basedir'], directory)\n\n        if os.path.isfile(filepath):\n            # if the given path is a file, try to get the image from ID3\n            tag = TinyTag.get(filepath, image=True)\n            image_data = tag.get_image()\n            if image_data:\n                log.d('Image found in tag.')\n                header = {'Content-Type': 'image/jpg', 'Content-Length': len(image_data)}\n                cherrypy.response.headers.update(header)\n                return image_data\n            else:\n                # if the file does not contain an image, display the image of the\n                # parent directory\n                directory = os.path.dirname(directory)\n\n        #try getting a cached album art image\n        b64imgpath = albumArtFilePath(directory)\n        img_data = self.albumartcache_load(b64imgpath)\n        if img_data:\n            cherrypy.response.headers[\"Content-Length\"] = len(img_data)\n            return img_data\n\n        #try getting album art inside local folder\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        localpath = os.path.join(cherry.config['media.basedir'], directory)\n        header, data, resized = fetcher.fetchLocal(localpath)\n\n        if header:\n            if resized:\n                #cache resized image for next time\n                self.albumartcache_save(b64imgpath, data)\n            cherrypy.response.headers.update(header)\n            return data\n        elif cherry.config['media.fetch_album_art']:\n            #fetch album art from online source\n            try:\n                foldername = os.path.basename(directory)\n                keywords = foldername\n                log.i(_(\"Fetching album art for keywords {keywords!r}\").format(keywords=keywords))\n                header, data = fetcher.fetch(keywords)\n                if header:\n                    cherrypy.response.headers.update(header)\n                    self.albumartcache_save(b64imgpath, data)\n                    return data\n                else:\n                    # albumart fetcher failed, so we serve a standard image\n                    raise cherrypy.HTTPRedirect(default_folder_image, 302)\n            except:\n                # albumart fetcher threw exception, so we serve a standard image\n                raise cherrypy.HTTPRedirect(default_folder_image, 302)\n        else:\n            # no local album art found, online fetching deactivated, show default\n            raise cherrypy.HTTPRedirect(default_folder_image, 302)\n    api_fetchalbumart.noauth = True\n    api_fetchalbumart.binary = True\n\n    def albumartcache_load(self, imgb64path):\n        if os.path.exists(imgb64path):\n            with open(imgb64path, 'rb') as f:\n                return f.read()\n\n    def albumartcache_save(self, path, data):\n        with open(path, 'wb') as f:\n            f.write(data)\n\n    def api_compactlistdir(self, directory, filterstr=None):\n        try:\n            files_to_list = self.model.listdir(directory, filterstr)\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n        return [entry.to_dict() for entry in files_to_list]\n\n    def api_listdir(self, directory):\n        try:\n            return [entry.to_dict() for entry in self.model.listdir(directory)]\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n\n    def api_search(self, searchstring):\n        if not searchstring.strip():\n            jsonresults = '[]'\n        else:\n            with Performance(_('processing whole search request')):\n                searchresults = self.model.search(searchstring.strip())\n                with Performance(_('rendering search results as json')):\n                    jsonresults = [entry.to_dict() for entry in searchresults]\n        return jsonresults\n\n    def api_rememberplaylist(self, playlist):\n        cherrypy.session['playlist'] = playlist\n\n    def api_saveplaylist(self, playlist, public, playlistname, overwrite=False):\n        res = self.playlistdb.savePlaylist(\n            userid=self.getUserId(),\n            public=1 if public else 0,\n            playlist=playlist,\n            playlisttitle=playlistname,\n            overwrite=overwrite)\n        if res == \"success\":\n            return res\n        else:\n            raise cherrypy.HTTPError(400, res)\n\n    def api_deleteplaylist(self, playlistid):\n        res = self.playlistdb.deletePlaylist(playlistid,\n                                             self.getUserId(),\n                                             override_owner=False)\n        if res == \"success\":\n            return res\n        else:\n            # not the ideal status code but we don't know the actual\n            # cause without parsing res\n            raise cherrypy.HTTPError(400, res)\n\n    def api_loadplaylist(self, playlistid):\n        return [entry.to_dict() for entry in self.playlistdb.loadPlaylist(\n                                        playlistid=playlistid,\n                                        userid=self.getUserId()\n                                        )]\n\n    def api_generaterandomplaylist(self):\n        return [entry.to_dict() for entry in self.model.randomMusicEntries(50)]\n\n    def api_changeplaylist(self, plid, attribute, value):\n        if attribute == 'public':\n            is_valid = type(value) == bool and type(plid) == int\n            if is_valid:\n                return self.playlistdb.setPublic(userid=self.getUserId(),\n                                                 plid=plid,\n                                                 public=value)\n\n    def api_getmotd(self):\n        if cherrypy.session['admin'] and cherry.config['general.update_notification']:\n            _save_and_release_session()\n            new_versions = self.model.check_for_updates()\n            if new_versions:\n                newest_version = new_versions[0]['version']\n                features = []\n                fixes = []\n                for version in new_versions:\n                    for update in version['features']:\n                        if update.startswith('FEATURE:'):\n                            features.append(update[len('FEATURE:'):])\n                        elif update.startswith('FIX:'):\n                            fixes.append(update[len('FIX:'):])\n                        elif update.startswith('FIXED:'):\n                            fixes.append(update[len('FIXED:'):])\n                retdata = {'type': 'update', 'data': {}}\n                retdata['data']['version'] = newest_version\n                retdata['data']['features'] = features\n                retdata['data']['fixes'] = fixes\n                return retdata\n        return {'type': 'wisdom', 'data': self.model.motd()}\n\n    def api_restoreplaylist(self):\n        session_playlist = cherrypy.session.get('playlist', [])\n        return session_playlist\n\n    def api_getplayables(self):\n        \"\"\"DEPRECATED\"\"\"\n        return json.dumps(cherry.config['media.playable'])\n\n    def api_getuserlist(self):\n        if cherrypy.session['admin']:\n            userlist = self.userdb.getUserList()\n            for user in userlist:\n                if user['id'] == cherrypy.session['userid']:\n                    user['deletable'] = False\n                user_options = self.useroptions.forUser(user['id'])\n                t = user_options.getOptionValue('last_time_online')\n                may_download = user_options.getOptionValue('media.may_download')\n                user['last_time_online'] = t\n                user['may_download'] = may_download\n            sortfunc = lambda user: user['last_time_online']\n            userlist = sorted(userlist, key=sortfunc, reverse=True)\n            return json.dumps({'time': int(time.time()),\n                               'userlist': userlist})\n        else:\n            return json.dumps({'time': 0, 'userlist': []})\n\n    def api_adduser(self, username, password, isadmin):\n        if cherrypy.session['admin']:\n            if self.userdb.addUser(username, password, isadmin):\n                return 'added new user: %s' % username\n            else:\n                return 'error, cannot add new user!' % username\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_userchangepassword(self, oldpassword, newpassword, username=''):\n        isself = username == ''\n        if isself:\n            username = cherrypy.session['username']\n            authed_user = self.userdb.auth(username, oldpassword)\n            is_authenticated = userdb.User.nobody() != authed_user\n            if not is_authenticated:\n                raise cherrypy.HTTPError(403, \"Forbidden\")\n        if isself or cherrypy.session['admin']:\n            return self.userdb.changePassword(username, newpassword)\n        else:\n            raise cherrypy.HTTPError(403, \"Forbidden\")\n\n    def api_userdelete(self, userid):\n        is_self = cherrypy.session['userid'] == userid\n        if cherrypy.session['admin'] and not is_self:\n            deleted = self.userdb.deleteUser(userid)\n            return 'success' if deleted else 'failed'\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_showplaylists(self, sortby=\"created\", filterby=''):\n        playlists = self.playlistdb.showPlaylists(self.getUserId(), filterby)\n        curr_time = int(time.time())\n        is_reverse = False\n        #translate userids to usernames:\n        for pl in playlists:\n            pl['username'] = self.userdb.getNameById(pl['userid'])\n            pl['type'] = 'playlist'\n            pl['age'] = curr_time - pl['created']\n        if sortby[0] == '-':\n            is_reverse = True\n            sortby = sortby[1:]\n        if not sortby in ('username', 'age', 'title', 'default'):\n            sortby = 'created'\n        if sortby == 'default':\n            sortby = 'age'\n            is_reverse = False\n        playlists = sorted(playlists, key=lambda x: x[sortby], reverse = is_reverse)\n        return playlists\n\n    def api_logout(self):\n        cherrypy.lib.sessions.expire()\n    api_logout.no_auth = True\n\n    def api_downloadpls(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createPLS(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.pls')\n    api_downloadpls.binary = True\n\n    def api_downloadm3u(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createM3U(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.m3u')\n    api_downloadm3u.binary = True\n\n    def export_playlists(self, format, all=False, hostaddr=''):\n        userid = self.getUserId()\n        if not userid:\n            raise cherrypy.HTTPError(401, _(\"Please log in\"))\n        hostaddr = (hostaddr.strip().rstrip('/') + cherry.config['server.rootpath']).rstrip('/')\n\n        format = format.lower()\n        if format == 'm3u':\n            filemaker = self.playlistdb.createM3U\n        elif format == 'pls':\n            filemaker = self.playlistdb.createPLS\n        else:\n            raise cherrypy.HTTPError(400,\n                _('Unknown playlist format: {format!r}').format(format=format))\n\n        playlists = self.playlistdb.showPlaylists(userid, include_public=all)\n        if not playlists:\n            raise cherrypy.HTTPError(404, _('No playlists found'))\n\n        with MemoryZipFile() as zip:\n            for pl in playlists:\n                plid = pl['plid']\n                plstr = filemaker(plid=plid, userid=userid, addrstr=hostaddr)\n                name = self.playlistdb.getName(plid, userid) + '.' + format\n                if not pl['owner']:\n                    username = self.userdb.getNameById(pl['userid'])\n                    name =  username + '/' + name\n                zip.writestr(name, plstr)\n\n        zipmime = 'application/x-zip-compressed'\n        zipname = 'attachment; filename=\"playlists.zip\"'\n        cherrypy.response.headers[\"Content-Type\"] = zipmime\n        cherrypy.response.headers['Content-Disposition'] = zipname\n        return zip.getbytes()\n    export_playlists.exposed = True\n\n    def api_getsonginfo(self, path):\n        basedir = cherry.config['media.basedir']\n        abspath = os.path.join(basedir, path)\n        return json.dumps(metainfo.getSongInfo(abspath).dict())\n\n    def api_getencoders(self):\n        return json.dumps(audiotranscode.getEncoders())\n\n    def api_getdecoders(self):\n        return json.dumps(audiotranscode.getDecoders())\n\n    def api_transcodingenabled(self):\n        return json.dumps(cherry.config['media.transcode'])\n\n    def api_updatedb(self):\n        self.model.updateLibrary()\n        return 'success'\n\n    def api_getconfiguration(self):\n        clientconfigkeys = {\n            'transcodingenabled': cherry.config['media.transcode'],\n            'fetchalbumart': cherry.config['media.fetch_album_art'],\n            'isadmin': cherrypy.session['admin'],\n            'username': cherrypy.session['username'],\n            'servepath': 'serve/',\n            'transcodepath': 'trans/',\n            'auto_login': self.autoLoginActive(),\n            'version': cherry.REPO_VERSION or cherry.VERSION,\n        }\n        if cherry.config['media.transcode']:\n            decoders = list(self.model.transcoder.available_decoder_formats())\n            clientconfigkeys['getdecoders'] = decoders\n            encoders = list(self.model.transcoder.available_encoder_formats())\n            clientconfigkeys['getencoders'] = encoders\n        else:\n            clientconfigkeys['getdecoders'] = []\n            clientconfigkeys['getencoders'] = []\n        return clientconfigkeys\n\n    def serve_string_as_file(self, string, filename):\n        content_disposition = 'attachment; filename=\"'+filename+'\"'\n        cherrypy.response.headers[\"Content-Type\"] = \"application/x-download\"\n        cherrypy.response.headers[\"Content-Disposition\"] = content_disposition\n        return codecs.encode(string, \"UTF-8\")\n\n\ndef _save_and_release_session():\n    \"\"\" workaround to cleanly release FileSessions in Cherrypy >= 3.3\n\n        From https://github.com/devsnd/cherrymusic/issues/483:\n\n        > CherryPy >=3.3.0 (up to current version, 3.6) makes it impossible to\n        > explicitly release FileSession locks, because:\n\n        > 1. FileSession.save() asserts that the session is locked; and\n\n        > 2. _cptools.SessionTool always adds a hook to call sessions.save\n        > before the response is finalized.\n\n        > If we still want to release the session in a controller, I guess the\n        > best way to work around this is to remove the hook before the\n        > controller returns:\n    \"\"\"\n    cherrypy.session.save()\n    hooks = cherrypy.serving.request.hooks['before_finalize']\n    forbidden = cherrypy.lib.sessions.save\n    hooks[:] = [h for h in hooks if h.callback is not forbidden]\n    # there's likely only one hook, since a 2nd call to save would always fail;\n    # but let's be safe, and block all calls to save :)\n", "patch": "@@ -300,7 +300,11 @@ def download_check_files(self, filelist):\n                 return 'not_permitted'\n         # make sure nobody tries to escape from basedir\n         for f in filelist:\n-            if '/../' in f:\n+            # don't allow to traverse up in the file system\n+            if '/../' in f or f.startswith('../'):\n+                return 'invalid_file'\n+            # CVE-2015-8309: do not allow absolute file paths\n+            if os.path.isabs(f):\n                 return 'invalid_file'\n         # make sure all files are smaller than maximum download size\n         size_limit = cherry.config['media.maximum_download_size']", "file_path": "files/2017_3/225", "file_language": "py", "file_name": "cherrymusicserver/httphandler.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/devsnd/cherrymusic/raw/62dec34a1ea0741400dd6b6c660d303dcd651e86/res%2Fjs%2Fplaylistmanager.js", "code": "\n/* PLAYLIST CREATION AND MANAGEMENT */\n\n\nvar ManagedPlaylist = function(playlistManager, playlist, options){\n    this.playlistManager = playlistManager;\n    this.id = options.id;\n    this.name = options.name;\n    this.closable = options.closable;\n    this.public = options.public;\n    this.owner = options.owner;\n    this.saved = options.saved;\n    //can be 'recommendation', 'ownwill', 'queue'\n    this.reason_open = options.reason_open;\n\n    this.jplayerplaylist;\n    this._init(playlist, playlistManager)\n}\nManagedPlaylist.prototype = {\n    _init : function(playlist, playlistManager){\n        var self = this;\n        this.playlistSelector = self._createNewPlaylistContainer();\n        //check if playlist is sane:\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[0].path === 'undefined'){\n                window.console.error('track has no path set!');\n            }\n            if(typeof playlist[0].label === 'undefined'){\n                window.console.error('track has no label set!');\n            }\n        }\n        self.jplayerplaylist = new jPlayerPlaylist(\n            {\n                jPlayer: this.playlistManager.cssSelectorjPlayer,\n                cssSelectorAncestor: this.playlistManager.cssSelectorJPlayerControls\n            },\n            playlist,\n            {   playlistOptions: {\n                    'enableRemoveControls': true,\n                    'playlistSelector': this.playlistSelector,\n                    'playlistController' : this,\n                    'loopOnPrevious': true\n                },\n                hooks: {\n                    \"setMedia\": playlistManager.transcodeURL\n                },\n                loop: self.playlistManager.loop\n            }\n        );\n        self.jplayerplaylist._init();\n        // The following is a workaround to avoid jplayer to try to update the \"shuffle\" control\n        // This is needed because we are currently not using the \"shuffle\" option of jplayer\n        self.jplayerplaylist._updateControls = function() {\n            playlistManager.refreshCommands();\n        }\n        $(self.playlistSelector+\">ul.playlist-container-list\").sortable({\n            axis: \"y\",\n            delay: 150,\n            helper : 'clone',\n            update: function(e,ui){\n                self.jplayerplaylist.scan();\n            }\n        });\n        $(self.playlistSelector+\">ul.playlist-container-list\").disableSelection();\n\n        //event handler for clicked tracks in jplayer playlist\n        $(this.playlistSelector).bind('requestPlay', function(event,playlistSelector) {\n            self.playlistManager.setPlayingPlaylist(self.playlistManager.htmlid2plid(playlistSelector));\n        });\n        //event handler for clicked \"x\" for tracks in jplayer playlist\n        $(this.playlistSelector).bind('removedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('sortedItems', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('addedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n    },\n    setSaved : function(issaved){\n        this.saved = issaved;\n        this.playlistManager.refreshCommands();\n        this.playlistManager.refreshTabs();\n    },\n    wasSaved : function(){\n        return this.saved;\n    },\n    _createNewPlaylistContainer : function(){\n        var playlistContainerParent = this.playlistManager.cssSelectorPlaylistContainerParent;\n        var id = this.playlistManager.plid2htmlid(this.id);\n        $(playlistContainerParent).append(\n            '<div class=\"playlist-container jp-playlist\" id=\"'+id+'\">'+\n            '<ul class=\"playlist-container-list\"><li></li></ul>'+\n            '<div class=\"jp-playlist-playtime-sum\"></div></div>'\n        );\n        return '#'+id;\n    },\n    getCanonicalPlaylist : function(){\n        var canonical = [];\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            var elem = this.jplayerplaylist.playlist[i];\n            var track = {\n                title : elem.title,\n                duration : elem.duration,\n                url: elem.url,\n                meta: elem.meta,\n            }\n            canonical.push(track);\n        }\n        return {\n            'playlist' : canonical,\n            'name' : this.name,\n            'closable' : this.closable,\n            'public' : this.public,\n            'owner' : this.owner,\n            'saved' : this.saved,\n            'reason_open' : this.reason_open,\n        };\n    },\n    getPlayTimeSec : function(playlist){\n        var durationsec = 0;\n        var tracks_with_duration = 0;\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[i].duration !== 'undefined'){\n                durationsec += playlist[i].duration;\n                tracks_with_duration++;\n            }\n        }\n        if(tracks_with_duration == 0){\n            // just show the number of track remaining\n            return;\n        } else {\n            // estimate the length of the playlist\n            return (durationsec / tracks_with_duration) * playlist.length;\n        }\n        \n    },\n    getRemainingTracks : function(){\n        if(playlistManager.shuffled){\n            var n = this._getMostPlayedTrack();\n            var remainingTracks = this.jplayerplaylist.playlist.filter(function(elem,idx,arr){\n                return elem.wasPlayed < n;\n            });\n            remainingTracks.push(this.jplayerplaylist.playlist[this.jplayerplaylist.current]);\n            return remainingTracks\n        } else {\n            return this.jplayerplaylist.playlist.slice(this.jplayerplaylist.current);\n        }\n    },\n    _getMostPlayedTrack : function(){\n        var wasplayermost = 0;\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            if(this.jplayerplaylist.playlist[i].wasPlayed > wasplayermost){\n                wasplayermost = this.jplayerplaylist.playlist[i].wasPlayed;\n            }\n        }\n        return wasplayermost;\n    },\n    makeThisPlayingPlaylist : function(){\n        this.playlistManager.setPlayingPlaylist(this.id);\n    },\n    addTrack : function(track, animate) {\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        this.jplayerplaylist.add(track, false, animate);\n        this.scrollToTrack(this.jplayerplaylist.playlist.length-1);\n    },\n    scrollToTrack: function(number){\n        var htmlid = '#'+playlistManager.plid2htmlid(this.id);\n        var yoffset = $($(htmlid + ' > ul > li')[number]).position().top;\n        var current_scroll = $('.playlist-container-parent').scrollTop();\n        $('.playlist-container-parent').scrollTop(current_scroll + yoffset);\n    },\n    scrollToCurrentTrack: function(){\n        this.scrollToTrack(this.jplayerplaylist.current);\n    },\n    sort_by: function(sort_by){\n        this.jplayerplaylist.playlist.sort(\n            function(a, b){\n                var value_a = '';\n                var value_b = '';\n                if(typeof a.meta !== 'undefined'){\n                    value_a = a.meta[sort_by];\n                }\n                if(typeof b.meta !== 'undefined'){\n                    value_b = b.meta[sort_by];\n                }\n                // sort numerically if both values start with numbers\n                if(!!value_a.match(/^\\d+/) && !!value_b.match(/^\\d+/)){\n                    return parseInt(value_a) - parseInt(value_b);\n                }\n                // otherwise sort alphabetically\n                if(value_a > value_b){\n                    return 1;\n                } else if(value_a < value_b){\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        );\n        this.jplayerplaylist._refresh(true);\n    }\n}\n\nvar NewplaylistProxy = function(playlistManager){\n    options = {};\n    //override options\n    options.id = 0;\n    options.name = \"new playlist\";\n    options.closable = false;\n    options.public = true;\n    options.owner = 'me';\n    options.saved = true;\n    options.reason_open = 'newplaylist_proxy';\n\n    //create original object\n    var actual = new ManagedPlaylist(playlistManager, [], options);\n\n    //override methods\n    actual.makeThisPlayingPlaylist = function(){\n        var newpl = this.playlistManager.newPlaylist();\n        newpl.makeThisPlayingPlaylist();\n    };\n    actual.addTrack = function(track) {\n        var newpl = this.playlistManager.newPlaylist();\n        this.playlistManager.setEditingPlaylist(newpl.id);\n        newpl.jplayerplaylist.add(track);\n    };\n    return actual;\n}\n\nPlaylistManager = function(){\n    \"use strict\";\n    var self = this;\n    this.cssSelectorPlaylistContainerParent = '.playlist-container-parent';\n    this.cssSelectorPlaylistChooser = '#playlistChooser';\n    this.cssSelectorPlaylistCommands = '#playlistCommands';\n    this.cssSelectorJPlayerControls = '#jp_ancestor';\n    this.cssSelectorjPlayer = \"#jquery_jplayer_1\";\n    this.cssSelectorAlbumArt = \"#albumart\";\n    this.newplaylistProxy = new NewplaylistProxy(this);\n    this.managedPlaylists = [] //hold instances of ManagedPlaylist\n    this.playingPlaylist = 0;\n    this.editingPlaylist = 0;\n    this.shuffled = false;\n    this.cssSelector = {}\n    this.lastRememberedPlaylist = '';\n    this.nrOfCreatedPlaylists = 0;\n    this.flashBlockCheckIntervalId;\n\n    this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n    this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n    this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n    this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.ready, function(event) {\n        self.restorePlaylists();\n        window.setInterval('playlistManager.displayCurrentSong()',1000);\n        //used to update remaining playlist time:\n        // should be triggered by jplayer time update event in the future.\n        window.setInterval('playlistManager.refreshCommands()',1000);\n        self.flashSize('0px','0px',-10000);\n        //update formats that can be played:\n        availablejPlayerFormats = []\n        var jplayer = self.jPlayerInstance.data('jPlayer');\n        if(jplayer.html.canPlay.oga || jplayer.flash.canPlay.oga){\n            availablejPlayerFormats.push('opus');\n            availablejPlayerFormats.push('ogg')\n        }\n        if(jplayer.html.canPlay.mp3 || jplayer.flash.canPlay.mp3){\n            availablejPlayerFormats.push('mp3')\n        }\n        if(availablejPlayerFormats.length == 0){\n            alert('Your browser does not support audio playback.');\n        }\n\t});\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.setmedia, function(event) {\n        var playlist = self.getPlayingPlaylist().jplayerplaylist;\n        var track = playlist.playlist[playlist.current];\n        if (track) {\n            self.setAlbumArtDisplay(track);\n        }\n    });\n    this.initJPlayer();\n}\n\nPlaylistManager.prototype = {\n    initJPlayer : function(){\n        \"use strict\";\n\n        //hack to use flash AND HTML solution in every case\n        //https://github.com/happyworm/jPlayer/issues/136#issuecomment-12941923\n        availablejPlayerFormats.push(\"m4v\");\n\n        var usedSolution = \"html, flash\";\n        if(detectBrowser() == 'midori'){\n            //WORKAROUND: the midori falsely reports mp3 support\n            usedSolution = \"flash, html\";\n        }\n        var self = this;\n        if (typeof self.jPlayerInstance === 'undefined'){\n            // Instance jPlayer\n            self.jPlayerInstance = $(self.cssSelectorjPlayer).jPlayer({\n                swfPath: \"res/js/ext\",\n                solution: usedSolution,\n                preload: 'metadata',\n                supplied: \"mp3, oga, m4v\",\n                wmode: \"window\",\n                cssSelectorAncestor: self.cssSelectorJPlayerControls,\n                errorAlerts: false,\n                repeat: self._getRepeatHandler()\n            });\n            this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n            this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n            this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n            this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n            /* JPLAYER EVENT BINDINGS */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.ended, function(event) {\n                self.cmd_next();\n            });\n\n            /* WORKAROUND FOR BUG #343 (playback stops sometimes in google chrome) */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.error, function(event) {\n                var now = new Date().getTime();\n                 // there must be at least 5 seconds between errors, so we don't retry 1000 times.\n                var min_error_gap_sec = 5;\n                if(typeof self.jPlayerInstance.data(\"jPlayer\").status.media.last_error === 'undefined'){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = 0;\n                }\n                var error_gap = now - self.jPlayerInstance.data(\"jPlayer\").status.media.last_error;\n                if(error_gap > min_error_gap_sec){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = now;\n                    window.console.log(\"Playback failed! trying to resume from the point it failed.\");\n                    // get current time where playback failed and resume from there\n                    var current_playtime = self.jPlayerInstance.data(\"jPlayer\").status.currentTime;\n                    playlistManager.jPlayerInstance.data(\"jPlayer\").play(current_playtime);\n                } else {\n                    window.console.log(\"Playback failed too often! Trying next track.\");\n                    self.cmd_next();\n                }\n            });\n            /* WORKAROUND END */\n\n            /* JPLAYER CONTROLS BINDINGS */\n            $(this.cssSelector.previous).click(function() {\n                self.cmd_previous();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.next).click(function() {\n                self.cmd_next();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.shuffle).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n            $(this.cssSelector.shuffleOff).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n\n            /* Set initial UI State */\n            self.refreshShuffle();\n            this.flashBlockCheckIntervalId = window.setInterval(\"playlistManager.checkFlashBlock()\", 200);\n        }\n    },\n    cmd_play : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"play\");\n    },\n    cmd_pause : function(){\n        if($(this.cssSelectorjPlayer).data().jPlayer.status.paused){\n            $(this.cssSelectorjPlayer).jPlayer(\"play\");\n        } else {\n            $(this.cssSelectorjPlayer).jPlayer(\"pause\");\n        }\n    },\n    cmd_stop : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"stop\");\n    },\n    cmd_previous : function(){\n        this.getPlayingPlaylist().jplayerplaylist.previous();\n    },\n    cmd_next : function(){\n        if(this.shuffled){\n            this.getPlayingPlaylist().jplayerplaylist.playRandomTrack();\n            return false;\n        } else {\n            var currentPL = this.getPlayingPlaylist();\n            currentPL.jplayerplaylist.next();\n            if(currentPL.id == this.getEditingPlaylist().id){\n                currentPL.scrollToCurrentTrack();\n            }\n            return false;\n        }\n    },\n    checkFlashBlock : function(){\n        flashBlocked = false;\n\n        if(detectBrowser() == 'opera'){\n            try {\n                window.document.getElementById('jp_flash_0').SetVariable(\"flashblock\", \"flashblock\");\n            } catch(err) {\n                flashBlocked = true;\n            }\n        } else {\n            //works for firefox (and chrome?)\n            flashBlocked = $('#jquery_jplayer_1 > div').length > 0;\n        }\n\n        if(flashBlocked){\n            $('#jquery_jplayer_1 div').css('background-color', '#fff');\n            this.flashSize('100%','80px','10000');\n            errorFunc('Flashblock is enabled. Please click on the flash symbol on top of the player to activate flash.')();\n        } else {\n            window.clearInterval(this.flashBlockCheckIntervalId);\n            window.setTimeout(\"playlistManager.flashSize('0px','0px',-10000);\",1000);\n            playlistManager.flashSize('0px','0px',-10000);\n        }\n\n    },\n    flashSize : function(w, h, zidx){\n        $('#jquery_jplayer_1 object').css('z-index', zidx);\n        $('#jquery_jplayer_1 object').css('position', 'absolute');\n        $('#jquery_jplayer_1 div').css('z-index', zidx);\n        $('#jquery_jplayer_1 div').css('position', 'absolute');\n        $('#jquery_jplayer_1 object').css('width', w);\n        $('#jquery_jplayer_1 object').css('height', h);\n        $('#jquery_jplayer_1 div').css('width', w);\n        $('#jquery_jplayer_1 div').css('height', h);\n    },\n    shuffleToggle : function(){\n      this.shuffled = !this.shuffled;\n      this.refreshShuffle();\n    },\n    refresh : function(){\n        var self = this;\n        self.refreshTabs();\n        self.refreshCommands();\n        self.refreshPlaylists();\n        self.refreshShuffle();\n    },\n    refreshShuffle : function(){\n        if(this.shuffled){\n            $(this.cssSelector.shuffle).hide();\n            $(this.cssSelector.shuffleOff).show();\n        } else {\n            $(this.cssSelector.shuffle).show();\n            $(this.cssSelector.shuffleOff).hide();\n        }\n    },\n    refreshCommands : function(){\n        var epl = this.getEditingPlaylist();\n        if(typeof epl !== 'undefined'){\n            show_ui_conditionally(\n                ['.playlist-command-buttons',\n                 '#playlist-command-button-group'],\n                {\n                    'queue': epl.reason_open == 'queue',\n                    'playlist': epl.reason_open != 'queue',\n                    'not-saved': epl.saved == false,\n                    'user-may-download': userOptions.media.may_download,\n                }\n            );\n\n            $('.save-current-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                savePlaylist(epl.id, false,false,true);\n                $(this).blur();\n                return false;\n            });\n\n            $('.save-as-new-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                $('#playlisttitle').val(epl.name+' copy');\n                if(epl.public){\n                    $(\"#playlistpublic\").attr(\"checked\", true);\n                } else {\n                    $(\"#playlistpublic\").removeAttr(\"checked\");\n                }\n            });\n\n            var remaintracks = epl.getRemainingTracks();\n            var completetimesec = epl.getPlayTimeSec(epl.jplayerplaylist.playlist);\n            var remaintimesec = epl.getPlayTimeSec(remaintracks);\n            var playingPlaylist = this.getPlayingPlaylist();\n            if(playingPlaylist && epl.id === playingPlaylist.id){\n                remaintimesec -= $(this.cssSelectorjPlayer).data(\"jPlayer\").status.currentTime;\n            }\n            remaintimesec = remaintimesec < 0 ? 0 : remaintimesec;\n\n            var littleTimeLeft = false;\n            var remainingStr = '';\n            var proc = 0;\n            if(typeof remaintimesec !== 'undefined' && typeof completetimesec !== 'undefined' ){\n                //if there is enough time info, show remaining time\n                if(completetimesec != 0){\n                    proc = remaintimesec/completetimesec;\n                } else {\n                    proc = 1;\n                }\n                littleTimeLeft = remaintimesec < 300;\n                remainingStr = epl.jplayerplaylist._formatTime(remaintimesec)+' remaining'\n            } else {\n                //show remaining tracks\n                proc = remaintracks.length/epl.jplayerplaylist.playlist.length;\n                littleTimeLeft = remaintracks.length < 3;\n                remainingStr = remaintracks.length+' remaining tracks';\n            }\n            if(littleTimeLeft){\n                $('.remaining-tracks-or-time').removeClass('label-default');\n                $('.remaining-tracks-or-time').addClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-danger');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-default');\n            } else {\n                $('.remaining-tracks-or-time').addClass('label-default');\n                $('.remaining-tracks-or-time').removeClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-default');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-danger');\n            }\n            $('.remaining-tracks-or-time').html(remainingStr);\n            $('.playlist-progress-bar .progress-bar').css('width',parseInt(100-proc*100)+'%');\n        }\n    },\n    refreshTabs : function(){\n        \"use strict\";\n        window.console.log('refreshTabs');\n        var self = this;\n        var pltabs = '';\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var pl = this.managedPlaylists[i];\n\n            var isactive = ''\n            if(pl.id == this.editingPlaylist){\n                isactive = ' class=\"active\" ';\n            } else {\n                isactive = ' class=\"playlist-tab-inactive\" ';\n            }\n            pltabs += '<li '+isactive+' id=\"'+this.tabid2htmlid(pl.id)+'\">';\n\n            var isplaying = '';\n            if(pl.id == this.playingPlaylist){\n                isplaying += '&#9654;';\n            }\n\n            var isunsaved = '';\n            if(!pl.saved && pl.reason_open !== 'queue'){\n                isunsaved += ' <em>(unsaved)</em>';\n            }\n\n            // fix for CVE-2015-8310\n            var escaped_playlist_name = $(\"<div>\").text(pl.name).html();\n            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+escaped_playlist_name + isunsaved;\n            if(pl.closable){\n                pltabs += '<span class=\"playlist-tab-closer pointer\" href=\"#\" onclick=\"playlistManager.closePlaylist('+pl.id+')\">&times;</span>';\n            }\n            pltabs += '</a></li>';\n        }\n        pltabs += '<li class=\"playlist-tab-inactive playlist-tab-new\"><a href=\"#\" onclick=\"playlistManager.newPlaylist()\"><b>+</b></a></li>';\n        $(self.cssSelectorPlaylistChooser+' ul').empty()\n        $(self.cssSelectorPlaylistChooser+' ul').append(pltabs);\n    },\n    tabid2htmlid : function(id){\n        return this.plid2htmlid(id)+'-tab';\n    },\n    plid2htmlid : function(id){\n        return 'pl-'+id;\n    },\n    htmlid2plid : function(htmlid){\n        return parseInt(htmlid.slice(4,htmlid.length))\n    },\n    refreshPlaylists : function(){\n        window.console.log('refreshPlaylists');\n        var self = this;\n        var validHTMLIds = [];\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            validHTMLIds.push(this.plid2htmlid(this.managedPlaylists[i].id));\n        }\n        window.console.log(validHTMLIds);\n        $.each($('#playlistContainerParent>div'), function(i,v){\n            window.console.log($(this).attr('id'));\n            if($.inArray($(this).attr('id'), validHTMLIds)<0){\n                $(this).remove();\n                window.console.log('removing invalid playlist from ui');\n            }\n        });\n\n        this.showPlaylist(this.getEditingPlaylist().id);\n    },\n    showPlaylist : function(playlistid){\n        $('#playlistCommands').show();\n        $('#playlistContainerParent').show();\n        $('#playlistBrowser').hide();\n        var self = this;\n        var plhtmlid = '#'+this.plid2htmlid(playlistid);\n        var showpl = $(plhtmlid);\n        this.hideAll();\n        $('#playlistChooser ul li:last').removeClass('active');\n        if(showpl.length<1){\n            window.console.warn(\"tried showing playlist with htmlid \"+plhtmlid+\" which doesn't exist!\");\n            this.setEditingPlaylist(this.managedPlaylists[0].id);\n            showpl = $('#'+this.plid2htmlid(this.getEditingPlaylist().id));\n        } else {\n            this.setEditingPlaylist(playlistid);\n        }\n        this.setTrackDestinationLabel();\n        showpl.show();\n        this.refreshTabs();\n        this.refreshCommands();\n    },\n    setTrackDestinationLabel : function(){\n        $('#searchresults .add-track-destination').text('add all to '+this.getEditingPlaylist().name);\n    },\n    hideAll : function(){\n        $(this.cssSelectorPlaylistContainerParent+'>div').hide();\n        $(this.cssSelectorPlaylistChooser+' ul li').removeClass('active');\n        this.setEditingPlaylist(0);\n    },\n    getPlaylistById : function(plid){\n        if (plid === 0) {\n            return this.newplaylistProxy;\n        }\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                return this.managedPlaylists[i];\n            }\n        }\n    },\n    getEditingPlaylist : function(){\n        var pl = this.getPlaylistById(this.editingPlaylist);\n        if(typeof pl !== 'undefined'){\n            return pl;\n        }\n    },\n    getPlayingPlaylist : function (){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == this.playingPlaylist){\n                return this.managedPlaylists[i];\n            }\n        }\n        return this.managedPlaylists[0];\n    },\n    newPlaylistFromQueue : function(){\n        return this.newPlaylist(this.managedPlaylists[0].jplayerplaylist.playlist);\n    },\n    newPlaylistFromEditing : function(){\n        return this.newPlaylist(this.getEditingPlaylist().jplayerplaylist.playlist);\n    },\n\n    closePlaylist : function(plid){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                window.console.log('closing PL '+plid)\n                this.managedPlaylists.splice(i,1);\n                $('#'+this.plid2htmlid(plid)).remove()\n                var otherId = this.managedPlaylists[i<this.managedPlaylists.length?i:0].id;\n                window.console.log('showing '+otherId+' and using it as editing PL')\n                this.showPlaylist(otherId)\n                return false;\n            }\n        }\n        this.refresh();\n        $(this).blur();\n        return false;\n    },\n    clearQueue : function(){\n      this.managedPlaylists[0].jplayerplaylist.remove();\n      this.refreshCommands();\n      $(this).blur();\n      return false;\n    },\n    setEditingPlaylist : function (editingplid){\n        var plist = this.getPlaylistById(editingplid);\n        var plname = '';\n        if (typeof plist !== 'undefined') {\n            this.editingPlaylist = editingplid;\n            plname = plist.name;\n        } else {\n            window.console.error('Tried setting editing playlist to unknown id '+editingplid);\n            this.editingPlaylist = 0;\n            plname = 'unknown playlist'\n        }\n        $('.plsmgr-editingplaylist-name').text(plname);\n    },\n    setPlayingPlaylist : function (plid){\n        this.playingPlaylist = plid;\n        this.refreshTabs();\n    },\n    transcodeURL: function(track){\n        \"use strict\";\n        var self = this;\n        var path = track.url;\n        var title = track.title;\n        var duration = track.duration;\n        var ext = getFileTypeByExt(path);\n        var track = {\n            title: title,\n            wasPlayed : 0,\n            duration: duration,\n        }\n        var forced_bitrate = userOptions.media.force_transcode_to_bitrate;\n        var formats = [];\n        if(!(forced_bitrate) && availablejPlayerFormats.indexOf(ext) !== -1){\n            //add natively supported path\n            track[ext2jPlayerFormat(ext)] = SERVER_CONFIG.serve_path + path;\n            formats.push(ext);\n            window.console.log('added native format '+ext);\n        } else if(!transcodingEnabled){\n            //not natively supported (or bitrate limited) but no transcoding\n            var msg = forced_bitrate ? \"bitrate limit requested\" : (\"browser doesn't support filetype \"+ext);\n            msg += ' and transcoding is disabled. Transcoding can be enabled in the server configuration.';\n            window.console.log(msg);\n            return;\n        } else {\n            //try transcoding\n            window.console.log('Trying available transcoders.');\n            if(availableDecoders.indexOf(ext) === -1){\n                window.console.log('missing decoder for filetype '+ext+'. track '+path+' can not be transcoded.')\n                return;\n            } else {\n                for(var i=0; i<availablejPlayerFormats.length; i++){\n                    if(availableEncoders.indexOf(availablejPlayerFormats[i]) !== -1){\n                        formats.push(availablejPlayerFormats[i]);\n                        var transurl = SERVER_CONFIG.transcode_path + availablejPlayerFormats[i] + '/' + path;\n                        transurl += '?bitrate=' + forced_bitrate;\n                        track[ext2jPlayerFormat(availablejPlayerFormats[i])] = transurl;\n                        window.console.log('added live transcoding '+ext+' --> '+availablejPlayerFormats[i]+' @ '+transurl);\n                    }\n                }\n            }\n            if(formats.length == 0){\n                window.console.log('no suitable encoder available! Try installing vorbis-tools or lame!');\n                return;\n            }\n        }\n        return track;\n    },\n    setAlbumArtDisplay : function(track) {\n        if(userOptions.ui.display_album_art){\n            // strip filename from url\n            var directory = track.url;\n            if (directory == '') // root directory\n                directory = '/';\n            var api_param = JSON.stringify({directory: directory});\n            var imgurl = 'api/fetchalbumart?data=' + api_param;\n            $(this.cssSelectorAlbumArt).attr('src', imgurl);\n        }\n    },\n    addSong : function(path, title, plid, animate){\n        \"use strict\";\n        var self = this;\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        var track = {\n            title: title,\n            url: path,\n            wasPlayed : 0,\n        }\n        var playlist;\n        if (plid) {\n            playlist = this.getPlaylistById(plid);\n        }\n        if (typeof playlist == 'undefined') {\n            playlist = this.getEditingPlaylist();\n        }\n        playlist.addTrack(track, animate);\n\n        //directly play/select first added track\n        if(!jPlayerIsPlaying() && playlist.jplayerplaylist.playlist.length == 1){\n            if(userOptions.misc.autoplay_on_add){\n                playlist.makeThisPlayingPlaylist();\n                playlist.jplayerplaylist.play(0);\n            } else {\n                playlist.jplayerplaylist.select(0);\n            }\n        }\n        var success = function(data){\n            var metainfo = $.parseJSON(data);\n            var any_info_received = false;\n            // save all the meta-data in the track\n            track.meta = metainfo;\n            if (metainfo.length) {\n                track.duration = metainfo.length;\n                any_info_received = true;\n            }\n            // only show id tags if at least artist and title are known\n            if (metainfo.title.length > 0 && metainfo.artist.length > 0) {\n                track.title = metainfo.artist+' - '+metainfo.title;\n                if(metainfo.track.length > 0){\n                    track.title = metainfo.track + ' ' + track.title;\n                    if(metainfo.track.length < 2){\n                        track.title = '0' + track.title;\n                    }\n                }\n                any_info_received = true;\n            }\n            if(any_info_received){\n                //only rerender playlist if it would visually change\n                self.getEditingPlaylist().jplayerplaylist._refresh(true);\n            }\n        }\n        // WORKAROUND: delay the meta-data fetching, so that a request\n        // for the actual audio data comes through frist\n         window.setTimeout(\n            function(){\n                api('getsonginfo', {'path': decodeURIComponent(path)}, success, errorFunc('error getting song metainfo'), true);\n            },\n            1000\n        );\n    },\n    clearPlaylist : function(){\n        \"use strict\";\n        this.getEditingPlaylist().remove();\n        if(this.getEditingPlaylist() == this.getPlayingPlaylist()){\n            $(this.cssSelectorjPlayer).jPlayer(\"clearMedia\");\n        }\n        return false;\n    },\n    displayCurrentSong : function (){\n        var pl = this.getPlayingPlaylist();\n        if(typeof pl === 'undefined'){\n            return;\n        }\n        var jPlaylist = pl.jplayerplaylist;\n        var songtitle = '';\n        var tabtitle = 'CherryMusic';\n        if(typeof this.jPlayerInstance !== 'undefined'){\n            var currentTitle = this.jPlayerInstance.data().jPlayer.status.media.title;\n            if(typeof currentTitle !== 'undefined'){\n                songtitle = currentTitle;\n                tabtitle = currentTitle+' | CherryMusic';\n            }\n        }\n        $('.cm-songtitle').html(songtitle);\n        $('title').text(tabtitle);\n    },\n    rememberPlaylist : function(){\n        \"use strict\";\n        var self = this;\n        var canonicalPlaylists = []\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var cano = this.managedPlaylists[i].getCanonicalPlaylist();\n            if(cano.playlist.length || cano.reason_open == 'queue'){\n                canonicalPlaylists.push(cano);\n            }\n        }\n        var newToRememberPlaylist = JSON.stringify(canonicalPlaylists)\n        if(this.lastRememberedPlaylist !== newToRememberPlaylist){\n            // save playlist in session\n            var error = errorFunc('cannot remember playlist: failed to connect to server.');\n            var success = function(){\n                self.lastRememberedPlaylist = newToRememberPlaylist;\n            }\n            api('rememberplaylist', {'playlist': canonicalPlaylists}, success, error, true);\n        }\n    },\n    restorePlaylists : function(){\n        var self = this;\n        \"use strict\";\n        /*restore playlist from session*/\n        var success = function(data){\n            var playlistsToRestore = data;\n            if(playlistsToRestore !== null && playlistsToRestore.length>0){\n                window.console.log('restoring playlist from last session');\n                for(var i=0; i<playlistsToRestore.length; i++){\n                    var pl = playlistsToRestore[i];\n                    var newpl = self._createPlaylist(pl.playlist,pl.closable,pl.public,pl.owner,pl.reason_open,pl.name,pl.saved);\n                }\n                self.setPlayingPlaylist(self.getPlayingPlaylist().id);\n                self.showPlaylist();\n            } else {\n                var pl = self._createPlaylist([],false,false,'self','queue','Queue',true);\n                self.playingPlaylist = pl.id;\n                self.setEditingPlaylist(pl.id);\n                self.showPlaylist(pl.id);\n            }\n            self.refresh();\n            window.console.log('remembering playlists periodically');\n            window.setInterval(\"playlistManager.rememberPlaylist()\",REMEMBER_PLAYLIST_INTERVAL );\n        };\n        api('restoreplaylist', success, errorFunc('error restoring playlist'));\n    },\n    _createPlaylist : function(playlist, closable, public, owner, reason, name, saved){\n        var a = new Date();\n        var timemillis = a.getTime();\n        if(typeof name === 'undefined'){\n            this.nrOfCreatedPlaylists++;\n            name = 'playlist '+this.nrOfCreatedPlaylists;\n        }\n        if(typeof saved === 'undefined'){\n            saved = false;\n        }\n        var newpl = new ManagedPlaylist(\n            this,\n            playlist,\n            {\n                'id' : parseInt(timemillis),\n                'name' : name,\n                'closable' : closable,\n                'public' : public,\n                'owner' : owner,\n                'reason_open' : reason,\n                'saved' : saved,\n            }\n        );\n        this.managedPlaylists.push(newpl);\n        this.refresh();\n        return newpl;\n    },\n    newPlaylist : function(playlist, name){\n        var newpl = this.newPlaylistNoShow(playlist, name);\n        this.showPlaylist(newpl.id);\n        return newpl;\n    },\n    newPlaylistNoShow : function(playlist, name){\n        playlist = playlist || [];\n        var newpl = this._createPlaylist(playlist,true,false,'me','ownwill', name, true);\n        return newpl;\n    },\n    removePlayedFromPlaylist : function (){\n        var mediaPlaylist = this.getEditingPlaylist().jplayerplaylist;\n        for(var i=0; i<mediaPlaylist.playlist.length; i++){\n            var wasPlayed = mediaPlaylist.playlist[i].wasPlayed>0;\n            var isCurrentTrack = i == mediaPlaylist.current;\n            var isBeforeCurrent = i < mediaPlaylist.current;\n            var clearCurrent = !jPlayerIsPlaying();\n            if(wasPlayed && (!isCurrentTrack || clearCurrent)){\n                mediaPlaylist.playlist.splice(i,1);\n                i--;\n                if(isBeforeCurrent){\n                    mediaPlaylist.current--;\n                }\n            }\n        }\n        mediaPlaylist._refresh(true);\n    },\n    _getRepeatHandler : function() {\n        var playlistManager = this;\n        var _handleRepeat = function(event) {\n            var repeatState = event.jPlayer.options.loop;\n            playlistManager.loop = repeatState;\n            $.each(playlistManager.managedPlaylists, function(i, playlist) {\n                playlist.jplayerplaylist.loop = repeatState;\n            });\n        }\n        return _handleRepeat;\n    }\n}\n", "code_before": "\n/* PLAYLIST CREATION AND MANAGEMENT */\n\n\nvar ManagedPlaylist = function(playlistManager, playlist, options){\n    this.playlistManager = playlistManager;\n    this.id = options.id;\n    this.name = options.name;\n    this.closable = options.closable;\n    this.public = options.public;\n    this.owner = options.owner;\n    this.saved = options.saved;\n    //can be 'recommendation', 'ownwill', 'queue'\n    this.reason_open = options.reason_open;\n\n    this.jplayerplaylist;\n    this._init(playlist, playlistManager)\n}\nManagedPlaylist.prototype = {\n    _init : function(playlist, playlistManager){\n        var self = this;\n        this.playlistSelector = self._createNewPlaylistContainer();\n        //check if playlist is sane:\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[0].path === 'undefined'){\n                window.console.error('track has no path set!');\n            }\n            if(typeof playlist[0].label === 'undefined'){\n                window.console.error('track has no label set!');\n            }\n        }\n        self.jplayerplaylist = new jPlayerPlaylist(\n            {\n                jPlayer: this.playlistManager.cssSelectorjPlayer,\n                cssSelectorAncestor: this.playlistManager.cssSelectorJPlayerControls\n            },\n            playlist,\n            {   playlistOptions: {\n                    'enableRemoveControls': true,\n                    'playlistSelector': this.playlistSelector,\n                    'playlistController' : this,\n                    'loopOnPrevious': true\n                },\n                hooks: {\n                    \"setMedia\": playlistManager.transcodeURL\n                },\n                loop: self.playlistManager.loop\n            }\n        );\n        self.jplayerplaylist._init();\n        // The following is a workaround to avoid jplayer to try to update the \"shuffle\" control\n        // This is needed because we are currently not using the \"shuffle\" option of jplayer\n        self.jplayerplaylist._updateControls = function() {\n            playlistManager.refreshCommands();\n        }\n        $(self.playlistSelector+\">ul.playlist-container-list\").sortable({\n            axis: \"y\",\n            delay: 150,\n            helper : 'clone',\n            update: function(e,ui){\n                self.jplayerplaylist.scan();\n            }\n        });\n        $(self.playlistSelector+\">ul.playlist-container-list\").disableSelection();\n\n        //event handler for clicked tracks in jplayer playlist\n        $(this.playlistSelector).bind('requestPlay', function(event,playlistSelector) {\n            self.playlistManager.setPlayingPlaylist(self.playlistManager.htmlid2plid(playlistSelector));\n        });\n        //event handler for clicked \"x\" for tracks in jplayer playlist\n        $(this.playlistSelector).bind('removedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('sortedItems', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('addedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n    },\n    setSaved : function(issaved){\n        this.saved = issaved;\n        this.playlistManager.refreshCommands();\n        this.playlistManager.refreshTabs();\n    },\n    wasSaved : function(){\n        return this.saved;\n    },\n    _createNewPlaylistContainer : function(){\n        var playlistContainerParent = this.playlistManager.cssSelectorPlaylistContainerParent;\n        var id = this.playlistManager.plid2htmlid(this.id);\n        $(playlistContainerParent).append(\n            '<div class=\"playlist-container jp-playlist\" id=\"'+id+'\">'+\n            '<ul class=\"playlist-container-list\"><li></li></ul>'+\n            '<div class=\"jp-playlist-playtime-sum\"></div></div>'\n        );\n        return '#'+id;\n    },\n    getCanonicalPlaylist : function(){\n        var canonical = [];\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            var elem = this.jplayerplaylist.playlist[i];\n            var track = {\n                title : elem.title,\n                duration : elem.duration,\n                url: elem.url,\n                meta: elem.meta,\n            }\n            canonical.push(track);\n        }\n        return {\n            'playlist' : canonical,\n            'name' : this.name,\n            'closable' : this.closable,\n            'public' : this.public,\n            'owner' : this.owner,\n            'saved' : this.saved,\n            'reason_open' : this.reason_open,\n        };\n    },\n    getPlayTimeSec : function(playlist){\n        var durationsec = 0;\n        var tracks_with_duration = 0;\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[i].duration !== 'undefined'){\n                durationsec += playlist[i].duration;\n                tracks_with_duration++;\n            }\n        }\n        if(tracks_with_duration == 0){\n            // just show the number of track remaining\n            return;\n        } else {\n            // estimate the length of the playlist\n            return (durationsec / tracks_with_duration) * playlist.length;\n        }\n        \n    },\n    getRemainingTracks : function(){\n        if(playlistManager.shuffled){\n            var n = this._getMostPlayedTrack();\n            var remainingTracks = this.jplayerplaylist.playlist.filter(function(elem,idx,arr){\n                return elem.wasPlayed < n;\n            });\n            remainingTracks.push(this.jplayerplaylist.playlist[this.jplayerplaylist.current]);\n            return remainingTracks\n        } else {\n            return this.jplayerplaylist.playlist.slice(this.jplayerplaylist.current);\n        }\n    },\n    _getMostPlayedTrack : function(){\n        var wasplayermost = 0;\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            if(this.jplayerplaylist.playlist[i].wasPlayed > wasplayermost){\n                wasplayermost = this.jplayerplaylist.playlist[i].wasPlayed;\n            }\n        }\n        return wasplayermost;\n    },\n    makeThisPlayingPlaylist : function(){\n        this.playlistManager.setPlayingPlaylist(this.id);\n    },\n    addTrack : function(track, animate) {\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        this.jplayerplaylist.add(track, false, animate);\n        this.scrollToTrack(this.jplayerplaylist.playlist.length-1);\n    },\n    scrollToTrack: function(number){\n        var htmlid = '#'+playlistManager.plid2htmlid(this.id);\n        var yoffset = $($(htmlid + ' > ul > li')[number]).position().top;\n        var current_scroll = $('.playlist-container-parent').scrollTop();\n        $('.playlist-container-parent').scrollTop(current_scroll + yoffset);\n    },\n    scrollToCurrentTrack: function(){\n        this.scrollToTrack(this.jplayerplaylist.current);\n    },\n    sort_by: function(sort_by){\n        this.jplayerplaylist.playlist.sort(\n            function(a, b){\n                var value_a = '';\n                var value_b = '';\n                if(typeof a.meta !== 'undefined'){\n                    value_a = a.meta[sort_by];\n                }\n                if(typeof b.meta !== 'undefined'){\n                    value_b = b.meta[sort_by];\n                }\n                // sort numerically if both values start with numbers\n                if(!!value_a.match(/^\\d+/) && !!value_b.match(/^\\d+/)){\n                    return parseInt(value_a) - parseInt(value_b);\n                }\n                // otherwise sort alphabetically\n                if(value_a > value_b){\n                    return 1;\n                } else if(value_a < value_b){\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        );\n        this.jplayerplaylist._refresh(true);\n    }\n}\n\nvar NewplaylistProxy = function(playlistManager){\n    options = {};\n    //override options\n    options.id = 0;\n    options.name = \"new playlist\";\n    options.closable = false;\n    options.public = true;\n    options.owner = 'me';\n    options.saved = true;\n    options.reason_open = 'newplaylist_proxy';\n\n    //create original object\n    var actual = new ManagedPlaylist(playlistManager, [], options);\n\n    //override methods\n    actual.makeThisPlayingPlaylist = function(){\n        var newpl = this.playlistManager.newPlaylist();\n        newpl.makeThisPlayingPlaylist();\n    };\n    actual.addTrack = function(track) {\n        var newpl = this.playlistManager.newPlaylist();\n        this.playlistManager.setEditingPlaylist(newpl.id);\n        newpl.jplayerplaylist.add(track);\n    };\n    return actual;\n}\n\nPlaylistManager = function(){\n    \"use strict\";\n    var self = this;\n    this.cssSelectorPlaylistContainerParent = '.playlist-container-parent';\n    this.cssSelectorPlaylistChooser = '#playlistChooser';\n    this.cssSelectorPlaylistCommands = '#playlistCommands';\n    this.cssSelectorJPlayerControls = '#jp_ancestor';\n    this.cssSelectorjPlayer = \"#jquery_jplayer_1\";\n    this.cssSelectorAlbumArt = \"#albumart\";\n    this.newplaylistProxy = new NewplaylistProxy(this);\n    this.managedPlaylists = [] //hold instances of ManagedPlaylist\n    this.playingPlaylist = 0;\n    this.editingPlaylist = 0;\n    this.shuffled = false;\n    this.cssSelector = {}\n    this.lastRememberedPlaylist = '';\n    this.nrOfCreatedPlaylists = 0;\n    this.flashBlockCheckIntervalId;\n\n    this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n    this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n    this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n    this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.ready, function(event) {\n        self.restorePlaylists();\n        window.setInterval('playlistManager.displayCurrentSong()',1000);\n        //used to update remaining playlist time:\n        // should be triggered by jplayer time update event in the future.\n        window.setInterval('playlistManager.refreshCommands()',1000);\n        self.flashSize('0px','0px',-10000);\n        //update formats that can be played:\n        availablejPlayerFormats = []\n        var jplayer = self.jPlayerInstance.data('jPlayer');\n        if(jplayer.html.canPlay.oga || jplayer.flash.canPlay.oga){\n            availablejPlayerFormats.push('opus');\n            availablejPlayerFormats.push('ogg')\n        }\n        if(jplayer.html.canPlay.mp3 || jplayer.flash.canPlay.mp3){\n            availablejPlayerFormats.push('mp3')\n        }\n        if(availablejPlayerFormats.length == 0){\n            alert('Your browser does not support audio playback.');\n        }\n\t});\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.setmedia, function(event) {\n        var playlist = self.getPlayingPlaylist().jplayerplaylist;\n        var track = playlist.playlist[playlist.current];\n        if (track) {\n            self.setAlbumArtDisplay(track);\n        }\n    });\n    this.initJPlayer();\n}\n\nPlaylistManager.prototype = {\n    initJPlayer : function(){\n        \"use strict\";\n\n        //hack to use flash AND HTML solution in every case\n        //https://github.com/happyworm/jPlayer/issues/136#issuecomment-12941923\n        availablejPlayerFormats.push(\"m4v\");\n\n        var usedSolution = \"html, flash\";\n        if(detectBrowser() == 'midori'){\n            //WORKAROUND: the midori falsely reports mp3 support\n            usedSolution = \"flash, html\";\n        }\n        var self = this;\n        if (typeof self.jPlayerInstance === 'undefined'){\n            // Instance jPlayer\n            self.jPlayerInstance = $(self.cssSelectorjPlayer).jPlayer({\n                swfPath: \"res/js/ext\",\n                solution: usedSolution,\n                preload: 'metadata',\n                supplied: \"mp3, oga, m4v\",\n                wmode: \"window\",\n                cssSelectorAncestor: self.cssSelectorJPlayerControls,\n                errorAlerts: false,\n                repeat: self._getRepeatHandler()\n            });\n            this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n            this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n            this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n            this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n            /* JPLAYER EVENT BINDINGS */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.ended, function(event) {\n                self.cmd_next();\n            });\n\n            /* WORKAROUND FOR BUG #343 (playback stops sometimes in google chrome) */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.error, function(event) {\n                var now = new Date().getTime();\n                 // there must be at least 5 seconds between errors, so we don't retry 1000 times.\n                var min_error_gap_sec = 5;\n                if(typeof self.jPlayerInstance.data(\"jPlayer\").status.media.last_error === 'undefined'){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = 0;\n                }\n                var error_gap = now - self.jPlayerInstance.data(\"jPlayer\").status.media.last_error;\n                if(error_gap > min_error_gap_sec){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = now;\n                    window.console.log(\"Playback failed! trying to resume from the point it failed.\");\n                    // get current time where playback failed and resume from there\n                    var current_playtime = self.jPlayerInstance.data(\"jPlayer\").status.currentTime;\n                    playlistManager.jPlayerInstance.data(\"jPlayer\").play(current_playtime);\n                } else {\n                    window.console.log(\"Playback failed too often! Trying next track.\");\n                    self.cmd_next();\n                }\n            });\n            /* WORKAROUND END */\n\n            /* JPLAYER CONTROLS BINDINGS */\n            $(this.cssSelector.previous).click(function() {\n                self.cmd_previous();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.next).click(function() {\n                self.cmd_next();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.shuffle).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n            $(this.cssSelector.shuffleOff).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n\n            /* Set initial UI State */\n            self.refreshShuffle();\n            this.flashBlockCheckIntervalId = window.setInterval(\"playlistManager.checkFlashBlock()\", 200);\n        }\n    },\n    cmd_play : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"play\");\n    },\n    cmd_pause : function(){\n        if($(this.cssSelectorjPlayer).data().jPlayer.status.paused){\n            $(this.cssSelectorjPlayer).jPlayer(\"play\");\n        } else {\n            $(this.cssSelectorjPlayer).jPlayer(\"pause\");\n        }\n    },\n    cmd_stop : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"stop\");\n    },\n    cmd_previous : function(){\n        this.getPlayingPlaylist().jplayerplaylist.previous();\n    },\n    cmd_next : function(){\n        if(this.shuffled){\n            this.getPlayingPlaylist().jplayerplaylist.playRandomTrack();\n            return false;\n        } else {\n            var currentPL = this.getPlayingPlaylist();\n            currentPL.jplayerplaylist.next();\n            if(currentPL.id == this.getEditingPlaylist().id){\n                currentPL.scrollToCurrentTrack();\n            }\n            return false;\n        }\n    },\n    checkFlashBlock : function(){\n        flashBlocked = false;\n\n        if(detectBrowser() == 'opera'){\n            try {\n                window.document.getElementById('jp_flash_0').SetVariable(\"flashblock\", \"flashblock\");\n            } catch(err) {\n                flashBlocked = true;\n            }\n        } else {\n            //works for firefox (and chrome?)\n            flashBlocked = $('#jquery_jplayer_1 > div').length > 0;\n        }\n\n        if(flashBlocked){\n            $('#jquery_jplayer_1 div').css('background-color', '#fff');\n            this.flashSize('100%','80px','10000');\n            errorFunc('Flashblock is enabled. Please click on the flash symbol on top of the player to activate flash.')();\n        } else {\n            window.clearInterval(this.flashBlockCheckIntervalId);\n            window.setTimeout(\"playlistManager.flashSize('0px','0px',-10000);\",1000);\n            playlistManager.flashSize('0px','0px',-10000);\n        }\n\n    },\n    flashSize : function(w, h, zidx){\n        $('#jquery_jplayer_1 object').css('z-index', zidx);\n        $('#jquery_jplayer_1 object').css('position', 'absolute');\n        $('#jquery_jplayer_1 div').css('z-index', zidx);\n        $('#jquery_jplayer_1 div').css('position', 'absolute');\n        $('#jquery_jplayer_1 object').css('width', w);\n        $('#jquery_jplayer_1 object').css('height', h);\n        $('#jquery_jplayer_1 div').css('width', w);\n        $('#jquery_jplayer_1 div').css('height', h);\n    },\n    shuffleToggle : function(){\n      this.shuffled = !this.shuffled;\n      this.refreshShuffle();\n    },\n    refresh : function(){\n        var self = this;\n        self.refreshTabs();\n        self.refreshCommands();\n        self.refreshPlaylists();\n        self.refreshShuffle();\n    },\n    refreshShuffle : function(){\n        if(this.shuffled){\n            $(this.cssSelector.shuffle).hide();\n            $(this.cssSelector.shuffleOff).show();\n        } else {\n            $(this.cssSelector.shuffle).show();\n            $(this.cssSelector.shuffleOff).hide();\n        }\n    },\n    refreshCommands : function(){\n        var epl = this.getEditingPlaylist();\n        if(typeof epl !== 'undefined'){\n            show_ui_conditionally(\n                ['.playlist-command-buttons',\n                 '#playlist-command-button-group'],\n                {\n                    'queue': epl.reason_open == 'queue',\n                    'playlist': epl.reason_open != 'queue',\n                    'not-saved': epl.saved == false,\n                    'user-may-download': userOptions.media.may_download,\n                }\n            );\n\n            $('.save-current-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                savePlaylist(epl.id, false,false,true);\n                $(this).blur();\n                return false;\n            });\n\n            $('.save-as-new-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                $('#playlisttitle').val(epl.name+' copy');\n                if(epl.public){\n                    $(\"#playlistpublic\").attr(\"checked\", true);\n                } else {\n                    $(\"#playlistpublic\").removeAttr(\"checked\");\n                }\n            });\n\n            var remaintracks = epl.getRemainingTracks();\n            var completetimesec = epl.getPlayTimeSec(epl.jplayerplaylist.playlist);\n            var remaintimesec = epl.getPlayTimeSec(remaintracks);\n            var playingPlaylist = this.getPlayingPlaylist();\n            if(playingPlaylist && epl.id === playingPlaylist.id){\n                remaintimesec -= $(this.cssSelectorjPlayer).data(\"jPlayer\").status.currentTime;\n            }\n            remaintimesec = remaintimesec < 0 ? 0 : remaintimesec;\n\n            var littleTimeLeft = false;\n            var remainingStr = '';\n            var proc = 0;\n            if(typeof remaintimesec !== 'undefined' && typeof completetimesec !== 'undefined' ){\n                //if there is enough time info, show remaining time\n                if(completetimesec != 0){\n                    proc = remaintimesec/completetimesec;\n                } else {\n                    proc = 1;\n                }\n                littleTimeLeft = remaintimesec < 300;\n                remainingStr = epl.jplayerplaylist._formatTime(remaintimesec)+' remaining'\n            } else {\n                //show remaining tracks\n                proc = remaintracks.length/epl.jplayerplaylist.playlist.length;\n                littleTimeLeft = remaintracks.length < 3;\n                remainingStr = remaintracks.length+' remaining tracks';\n            }\n            if(littleTimeLeft){\n                $('.remaining-tracks-or-time').removeClass('label-default');\n                $('.remaining-tracks-or-time').addClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-danger');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-default');\n            } else {\n                $('.remaining-tracks-or-time').addClass('label-default');\n                $('.remaining-tracks-or-time').removeClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-default');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-danger');\n            }\n            $('.remaining-tracks-or-time').html(remainingStr);\n            $('.playlist-progress-bar .progress-bar').css('width',parseInt(100-proc*100)+'%');\n        }\n    },\n    refreshTabs : function(){\n        \"use strict\";\n        window.console.log('refreshTabs');\n        var self = this;\n        var pltabs = '';\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var pl = this.managedPlaylists[i];\n\n            var isactive = ''\n            if(pl.id == this.editingPlaylist){\n                isactive = ' class=\"active\" ';\n            } else {\n                isactive = ' class=\"playlist-tab-inactive\" ';\n            }\n            pltabs += '<li '+isactive+' id=\"'+this.tabid2htmlid(pl.id)+'\">';\n\n            var isplaying = '';\n            if(pl.id == this.playingPlaylist){\n                isplaying += '&#9654;';\n            }\n\n            var isunsaved = '';\n            if(!pl.saved && pl.reason_open !== 'queue'){\n                isunsaved += ' <em>(unsaved)</em>';\n            }\n\n\n            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+pl.name+ isunsaved;\n            if(pl.closable){\n                pltabs += '<span class=\"playlist-tab-closer pointer\" href=\"#\" onclick=\"playlistManager.closePlaylist('+pl.id+')\">&times;</span>';\n            }\n            pltabs += '</a></li>';\n        }\n        pltabs += '<li class=\"playlist-tab-inactive playlist-tab-new\"><a href=\"#\" onclick=\"playlistManager.newPlaylist()\"><b>+</b></a></li>';\n        $(self.cssSelectorPlaylistChooser+' ul').empty()\n        $(self.cssSelectorPlaylistChooser+' ul').append(pltabs);\n    },\n    tabid2htmlid : function(id){\n        return this.plid2htmlid(id)+'-tab';\n    },\n    plid2htmlid : function(id){\n        return 'pl-'+id;\n    },\n    htmlid2plid : function(htmlid){\n        return parseInt(htmlid.slice(4,htmlid.length))\n    },\n    refreshPlaylists : function(){\n        window.console.log('refreshPlaylists');\n        var self = this;\n        var validHTMLIds = [];\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            validHTMLIds.push(this.plid2htmlid(this.managedPlaylists[i].id));\n        }\n        window.console.log(validHTMLIds);\n        $.each($('#playlistContainerParent>div'), function(i,v){\n            window.console.log($(this).attr('id'));\n            if($.inArray($(this).attr('id'), validHTMLIds)<0){\n                $(this).remove();\n                window.console.log('removing invalid playlist from ui');\n            }\n        });\n\n        this.showPlaylist(this.getEditingPlaylist().id);\n    },\n    showPlaylist : function(playlistid){\n        $('#playlistCommands').show();\n        $('#playlistContainerParent').show();\n        $('#playlistBrowser').hide();\n        var self = this;\n        var plhtmlid = '#'+this.plid2htmlid(playlistid);\n        var showpl = $(plhtmlid);\n        this.hideAll();\n        $('#playlistChooser ul li:last').removeClass('active');\n        if(showpl.length<1){\n            window.console.warn(\"tried showing playlist with htmlid \"+plhtmlid+\" which doesn't exist!\");\n            this.setEditingPlaylist(this.managedPlaylists[0].id);\n            showpl = $('#'+this.plid2htmlid(this.getEditingPlaylist().id));\n        } else {\n            this.setEditingPlaylist(playlistid);\n        }\n        this.setTrackDestinationLabel();\n        showpl.show();\n        this.refreshTabs();\n        this.refreshCommands();\n    },\n    setTrackDestinationLabel : function(){\n        $('#searchresults .add-track-destination').text('add all to '+this.getEditingPlaylist().name);\n    },\n    hideAll : function(){\n        $(this.cssSelectorPlaylistContainerParent+'>div').hide();\n        $(this.cssSelectorPlaylistChooser+' ul li').removeClass('active');\n        this.setEditingPlaylist(0);\n    },\n    getPlaylistById : function(plid){\n        if (plid === 0) {\n            return this.newplaylistProxy;\n        }\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                return this.managedPlaylists[i];\n            }\n        }\n    },\n    getEditingPlaylist : function(){\n        var pl = this.getPlaylistById(this.editingPlaylist);\n        if(typeof pl !== 'undefined'){\n            return pl;\n        }\n    },\n    getPlayingPlaylist : function (){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == this.playingPlaylist){\n                return this.managedPlaylists[i];\n            }\n        }\n        return this.managedPlaylists[0];\n    },\n    newPlaylistFromQueue : function(){\n        return this.newPlaylist(this.managedPlaylists[0].jplayerplaylist.playlist);\n    },\n    newPlaylistFromEditing : function(){\n        return this.newPlaylist(this.getEditingPlaylist().jplayerplaylist.playlist);\n    },\n\n    closePlaylist : function(plid){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                window.console.log('closing PL '+plid)\n                this.managedPlaylists.splice(i,1);\n                $('#'+this.plid2htmlid(plid)).remove()\n                var otherId = this.managedPlaylists[i<this.managedPlaylists.length?i:0].id;\n                window.console.log('showing '+otherId+' and using it as editing PL')\n                this.showPlaylist(otherId)\n                return false;\n            }\n        }\n        this.refresh();\n        $(this).blur();\n        return false;\n    },\n    clearQueue : function(){\n      this.managedPlaylists[0].jplayerplaylist.remove();\n      this.refreshCommands();\n      $(this).blur();\n      return false;\n    },\n    setEditingPlaylist : function (editingplid){\n        var plist = this.getPlaylistById(editingplid);\n        var plname = '';\n        if (typeof plist !== 'undefined') {\n            this.editingPlaylist = editingplid;\n            plname = plist.name;\n        } else {\n            window.console.error('Tried setting editing playlist to unknown id '+editingplid);\n            this.editingPlaylist = 0;\n            plname = 'unknown playlist'\n        }\n        $('.plsmgr-editingplaylist-name').text(plname);\n    },\n    setPlayingPlaylist : function (plid){\n        this.playingPlaylist = plid;\n        this.refreshTabs();\n    },\n    transcodeURL: function(track){\n        \"use strict\";\n        var self = this;\n        var path = track.url;\n        var title = track.title;\n        var duration = track.duration;\n        var ext = getFileTypeByExt(path);\n        var track = {\n            title: title,\n            wasPlayed : 0,\n            duration: duration,\n        }\n        var forced_bitrate = userOptions.media.force_transcode_to_bitrate;\n        var formats = [];\n        if(!(forced_bitrate) && availablejPlayerFormats.indexOf(ext) !== -1){\n            //add natively supported path\n            track[ext2jPlayerFormat(ext)] = SERVER_CONFIG.serve_path + path;\n            formats.push(ext);\n            window.console.log('added native format '+ext);\n        } else if(!transcodingEnabled){\n            //not natively supported (or bitrate limited) but no transcoding\n            var msg = forced_bitrate ? \"bitrate limit requested\" : (\"browser doesn't support filetype \"+ext);\n            msg += ' and transcoding is disabled. Transcoding can be enabled in the server configuration.';\n            window.console.log(msg);\n            return;\n        } else {\n            //try transcoding\n            window.console.log('Trying available transcoders.');\n            if(availableDecoders.indexOf(ext) === -1){\n                window.console.log('missing decoder for filetype '+ext+'. track '+path+' can not be transcoded.')\n                return;\n            } else {\n                for(var i=0; i<availablejPlayerFormats.length; i++){\n                    if(availableEncoders.indexOf(availablejPlayerFormats[i]) !== -1){\n                        formats.push(availablejPlayerFormats[i]);\n                        var transurl = SERVER_CONFIG.transcode_path + availablejPlayerFormats[i] + '/' + path;\n                        transurl += '?bitrate=' + forced_bitrate;\n                        track[ext2jPlayerFormat(availablejPlayerFormats[i])] = transurl;\n                        window.console.log('added live transcoding '+ext+' --> '+availablejPlayerFormats[i]+' @ '+transurl);\n                    }\n                }\n            }\n            if(formats.length == 0){\n                window.console.log('no suitable encoder available! Try installing vorbis-tools or lame!');\n                return;\n            }\n        }\n        return track;\n    },\n    setAlbumArtDisplay : function(track) {\n        if(userOptions.ui.display_album_art){\n            // strip filename from url\n            var directory = track.url;\n            if (directory == '') // root directory\n                directory = '/';\n            var api_param = JSON.stringify({directory: directory});\n            var imgurl = 'api/fetchalbumart?data=' + api_param;\n            $(this.cssSelectorAlbumArt).attr('src', imgurl);\n        }\n    },\n    addSong : function(path, title, plid, animate){\n        \"use strict\";\n        var self = this;\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        var track = {\n            title: title,\n            url: path,\n            wasPlayed : 0,\n        }\n        var playlist;\n        if (plid) {\n            playlist = this.getPlaylistById(plid);\n        }\n        if (typeof playlist == 'undefined') {\n            playlist = this.getEditingPlaylist();\n        }\n        playlist.addTrack(track, animate);\n\n        //directly play/select first added track\n        if(!jPlayerIsPlaying() && playlist.jplayerplaylist.playlist.length == 1){\n            if(userOptions.misc.autoplay_on_add){\n                playlist.makeThisPlayingPlaylist();\n                playlist.jplayerplaylist.play(0);\n            } else {\n                playlist.jplayerplaylist.select(0);\n            }\n        }\n        var success = function(data){\n            var metainfo = $.parseJSON(data);\n            var any_info_received = false;\n            // save all the meta-data in the track\n            track.meta = metainfo;\n            if (metainfo.length) {\n                track.duration = metainfo.length;\n                any_info_received = true;\n            }\n            // only show id tags if at least artist and title are known\n            if (metainfo.title.length > 0 && metainfo.artist.length > 0) {\n                track.title = metainfo.artist+' - '+metainfo.title;\n                if(metainfo.track.length > 0){\n                    track.title = metainfo.track + ' ' + track.title;\n                    if(metainfo.track.length < 2){\n                        track.title = '0' + track.title;\n                    }\n                }\n                any_info_received = true;\n            }\n            if(any_info_received){\n                //only rerender playlist if it would visually change\n                self.getEditingPlaylist().jplayerplaylist._refresh(true);\n            }\n        }\n        // WORKAROUND: delay the meta-data fetching, so that a request\n        // for the actual audio data comes through frist\n         window.setTimeout(\n            function(){\n                api('getsonginfo', {'path': decodeURIComponent(path)}, success, errorFunc('error getting song metainfo'), true);\n            },\n            1000\n        );\n    },\n    clearPlaylist : function(){\n        \"use strict\";\n        this.getEditingPlaylist().remove();\n        if(this.getEditingPlaylist() == this.getPlayingPlaylist()){\n            $(this.cssSelectorjPlayer).jPlayer(\"clearMedia\");\n        }\n        return false;\n    },\n    displayCurrentSong : function (){\n        var pl = this.getPlayingPlaylist();\n        if(typeof pl === 'undefined'){\n            return;\n        }\n        var jPlaylist = pl.jplayerplaylist;\n        var songtitle = '';\n        var tabtitle = 'CherryMusic';\n        if(typeof this.jPlayerInstance !== 'undefined'){\n            var currentTitle = this.jPlayerInstance.data().jPlayer.status.media.title;\n            if(typeof currentTitle !== 'undefined'){\n                songtitle = currentTitle;\n                tabtitle = currentTitle+' | CherryMusic';\n            }\n        }\n        $('.cm-songtitle').html(songtitle);\n        $('title').text(tabtitle);\n    },\n    rememberPlaylist : function(){\n        \"use strict\";\n        var self = this;\n        var canonicalPlaylists = []\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var cano = this.managedPlaylists[i].getCanonicalPlaylist();\n            if(cano.playlist.length || cano.reason_open == 'queue'){\n                canonicalPlaylists.push(cano);\n            }\n        }\n        var newToRememberPlaylist = JSON.stringify(canonicalPlaylists)\n        if(this.lastRememberedPlaylist !== newToRememberPlaylist){\n            // save playlist in session\n            var error = errorFunc('cannot remember playlist: failed to connect to server.');\n            var success = function(){\n                self.lastRememberedPlaylist = newToRememberPlaylist;\n            }\n            api('rememberplaylist', {'playlist': canonicalPlaylists}, success, error, true);\n        }\n    },\n    restorePlaylists : function(){\n        var self = this;\n        \"use strict\";\n        /*restore playlist from session*/\n        var success = function(data){\n            var playlistsToRestore = data;\n            if(playlistsToRestore !== null && playlistsToRestore.length>0){\n                window.console.log('restoring playlist from last session');\n                for(var i=0; i<playlistsToRestore.length; i++){\n                    var pl = playlistsToRestore[i];\n                    var newpl = self._createPlaylist(pl.playlist,pl.closable,pl.public,pl.owner,pl.reason_open,pl.name,pl.saved);\n                }\n                self.setPlayingPlaylist(self.getPlayingPlaylist().id);\n                self.showPlaylist();\n            } else {\n                var pl = self._createPlaylist([],false,false,'self','queue','Queue',true);\n                self.playingPlaylist = pl.id;\n                self.setEditingPlaylist(pl.id);\n                self.showPlaylist(pl.id);\n            }\n            self.refresh();\n            window.console.log('remembering playlists periodically');\n            window.setInterval(\"playlistManager.rememberPlaylist()\",REMEMBER_PLAYLIST_INTERVAL );\n        };\n        api('restoreplaylist', success, errorFunc('error restoring playlist'));\n    },\n    _createPlaylist : function(playlist, closable, public, owner, reason, name, saved){\n        var a = new Date();\n        var timemillis = a.getTime();\n        if(typeof name === 'undefined'){\n            this.nrOfCreatedPlaylists++;\n            name = 'playlist '+this.nrOfCreatedPlaylists;\n        }\n        if(typeof saved === 'undefined'){\n            saved = false;\n        }\n        var newpl = new ManagedPlaylist(\n            this,\n            playlist,\n            {\n                'id' : parseInt(timemillis),\n                'name' : name,\n                'closable' : closable,\n                'public' : public,\n                'owner' : owner,\n                'reason_open' : reason,\n                'saved' : saved,\n            }\n        );\n        this.managedPlaylists.push(newpl);\n        this.refresh();\n        return newpl;\n    },\n    newPlaylist : function(playlist, name){\n        var newpl = this.newPlaylistNoShow(playlist, name);\n        this.showPlaylist(newpl.id);\n        return newpl;\n    },\n    newPlaylistNoShow : function(playlist, name){\n        playlist = playlist || [];\n        var newpl = this._createPlaylist(playlist,true,false,'me','ownwill', name, true);\n        return newpl;\n    },\n    removePlayedFromPlaylist : function (){\n        var mediaPlaylist = this.getEditingPlaylist().jplayerplaylist;\n        for(var i=0; i<mediaPlaylist.playlist.length; i++){\n            var wasPlayed = mediaPlaylist.playlist[i].wasPlayed>0;\n            var isCurrentTrack = i == mediaPlaylist.current;\n            var isBeforeCurrent = i < mediaPlaylist.current;\n            var clearCurrent = !jPlayerIsPlaying();\n            if(wasPlayed && (!isCurrentTrack || clearCurrent)){\n                mediaPlaylist.playlist.splice(i,1);\n                i--;\n                if(isBeforeCurrent){\n                    mediaPlaylist.current--;\n                }\n            }\n        }\n        mediaPlaylist._refresh(true);\n    },\n    _getRepeatHandler : function() {\n        var playlistManager = this;\n        var _handleRepeat = function(event) {\n            var repeatState = event.jPlayer.options.loop;\n            playlistManager.loop = repeatState;\n            $.each(playlistManager.managedPlaylists, function(i, playlist) {\n                playlist.jplayerplaylist.loop = repeatState;\n            });\n        }\n        return _handleRepeat;\n    }\n}\n", "patch": "@@ -562,8 +562,9 @@ PlaylistManager.prototype = {\n                 isunsaved += ' <em>(unsaved)</em>';\n             }\n \n-\n-            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+pl.name+ isunsaved;\n+            // fix for CVE-2015-8310\n+            var escaped_playlist_name = $(\"<div>\").text(pl.name).html();\n+            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+escaped_playlist_name + isunsaved;\n             if(pl.closable){\n                 pltabs += '<span class=\"playlist-tab-closer pointer\" href=\"#\" onclick=\"playlistManager.closePlaylist('+pl.id+')\">&times;</span>';\n             }", "file_path": "files/2017_3/226", "file_language": "js", "file_name": "res/js/playlistmanager.js", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
