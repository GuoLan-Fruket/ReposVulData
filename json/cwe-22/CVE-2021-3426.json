{"index": 5878, "cve_id": "CVE-2021-3426", "cwe_id": ["CWE-200", "CWE-22"], "cve_language": "Python", "cve_description": "There's a flaw in Python 3's pydoc. A local or adjacent attacker who discovers or is able to convince another local or adjacent user to start a pydoc server could access the server and use it to disclose sensitive information belonging to the other user that they would not normally be able to access. The highest risk of this flaw is to data confidentiality. This flaw affects Python versions before 3.8.9, Python versions before 3.9.3 and Python versions before 3.10.0a7.", "cvss": "5.7", "publish_date": "May 20, 2021", "AV": "ADJACENT_NETWORK", "AC": "ADJACENT_NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "NONE", "A": "NONE", "commit_id": "9b999479c0022edfc9835a8a1f06e046f3881048", "commit_message": "bpo-42988: Remove the pydoc getfile feature (GH-25015)\n\nCVE-2021-3426: Remove the \"getfile\" feature of the pydoc module which\r\ncould be abused to read arbitrary files on the disk (directory\r\ntraversal vulnerability). Moreover, even source code of Python\r\nmodules can contain sensitive data like passwords. Vulnerability\r\nreported by David Schw\u00f6rer.", "commit_date": "2021-03-29T12:40:40Z", "project": "python/cpython", "url": "https://api.github.com/repos/python/cpython/commits/9b999479c0022edfc9835a8a1f06e046f3881048", "html_url": "https://github.com/python/cpython/commit/9b999479c0022edfc9835a8a1f06e046f3881048", "windows_before": [{"commit_id": "4827483f47906fecee6b5d9097df2a69a293a85c", "commit_date": "Mon Mar 29 12:28:14 2021 +0900", "commit_message": "bpo-43510: Implement PEP 597 opt-in EncodingWarning. (GH-19481)", "files_name": ["Doc/c-api/init_config.rst", "Doc/library/exceptions.rst", "Doc/library/io.rst", "Doc/using/cmdline.rst", "Doc/whatsnew/3.10.rst", "Include/cpython/initconfig.h", "Include/internal/pycore_initconfig.h", "Include/pyerrors.h", "Lib/_pyio.py", "Lib/bz2.py", "Lib/configparser.py", "Lib/gzip.py", "Lib/io.py", "Lib/lzma.py", "Lib/pathlib.py", "Lib/site.py", "Lib/subprocess.py", "Lib/tempfile.py", "Lib/test/exception_hierarchy.txt", "Lib/test/test_embed.py", "Lib/test/test_io.py", "Lib/test/test_pickle.py", "Lib/test/test_sys.py", "Misc/NEWS.d/next/Library/2021-03-16-17-20-33.bpo-43510.-BeQH_.rst", "Modules/_io/_iomodule.c", "Modules/_io/clinic/_iomodule.c.h", "Modules/_io/textio.c", "Objects/exceptions.c", "PC/python3dll.c", "Python/initconfig.c", "Python/preconfig.c", "Python/sysmodule.c"]}, {"commit_id": "261a452a1300eeeae1428ffd6e6623329c085e2c", "commit_date": "Sun Mar 28 23:48:05 2021 +0100", "commit_message": "bpo-25643: Refactor the C tokenizer into smaller, logical units (GH-25050)", "files_name": ["Lib/test/test_eof.py", "Lib/test/test_source_encoding.py", "Parser/tokenizer.c", "Parser/tokenizer.h"]}, {"commit_id": "fb1d01b9630b5069fe975f16e07a027d90b89434", "commit_date": "Sun Mar 28 21:47:20 2021 +0100", "commit_message": "bpo-31907: [doc] clarify that str.format() does not support arbitrary expressions (#25053)", "files_name": ["Doc/library/string.rst"]}, {"commit_id": "af50c84643ce21cfbdfdabbdfae6bd5e1368c542", "commit_date": "Sat Mar 27 20:25:53 2021 -0400", "commit_message": "bpo-43644: Add docs for importlib.resources.as_file. (#25048)", "files_name": ["Doc/library/importlib.rst"]}, {"commit_id": "29c451c6989c3c94fa0a9facf187c24f3cbf2420", "commit_date": "Sat Mar 27 15:52:28 2021 -0600", "commit_message": "bpo-43562: fix test_ssl to skip on unreachable network (GH-24937)", "files_name": ["Lib/test/test_ssl.py"]}, {"commit_id": "a53e9a7cf5912a44c5143e353912e44cfcfca7dc", "commit_date": "Sat Mar 27 17:20:58 2021 +0000", "commit_message": "bpo-39231: correct tutorial annotations section (GH-25029)", "files_name": ["Doc/tutorial/controlflow.rst"]}, {"commit_id": "bacefbf41461ab703b8d561f0e3d766427eab367", "commit_date": "Sat Mar 27 18:03:54 2021 +0100", "commit_message": "bpo-43466: Unsupported static build hack (GH-25002)", "files_name": ["setup.py"]}, {"commit_id": "9798cef92b882cd82a338d3368eaf3c4a32f5c2d", "commit_date": "Sat Mar 27 16:20:11 2021 +0200", "commit_message": "bpo-39616: clarify SSLContext.check_hostname effect (GH-18484)", "files_name": ["Doc/library/ssl.rst"]}, {"commit_id": "933dfd7504e521a27fd8b94d02b79f9ed08f4631", "commit_date": "Sat Mar 27 14:55:03 2021 +0100", "commit_message": "bpo-40645: use C implementation of HMAC (GH-24920)", "files_name": ["Lib/hashlib.py", "Lib/hmac.py", "Lib/test/test_hmac.py", "Misc/NEWS.d/next/Library/2021-03-19-10-22-17.bpo-40645.5pXhb-.rst", "Modules/_hashopenssl.c", "Modules/clinic/_hashopenssl.c.h"]}, {"commit_id": "5d6e8c1c1a5f667cdce99cb3c563ac922198678d", "commit_date": "Sat Mar 27 14:44:04 2021 +0100", "commit_message": "bpo-43617: Check autoconf-archive package in configure.ac (GH-25016)", "files_name": ["Misc/NEWS.d/next/Build/2021-03-24-16-55-55.bpo-43617.d69KAv.rst", "aclocal.m4", "configure", "configure.ac", "m4/ax_c_float_words_bigendian.m4", "m4/ax_check_openssl.m4"]}, {"commit_id": "11b85abbae8aaa8410b19f358abd7b401881bb1c", "commit_date": "Sat Mar 27 03:51:46 2021 +0000", "commit_message": "bpo-43636: Validate the version tag in _PyType_Lookup (GH-25032)", "files_name": ["Objects/typeobject.c"]}, {"commit_id": "027b6699276ed8d9f68425697ac89bf61e54e6b9", "commit_date": "Fri Mar 26 22:09:09 2021 +0100", "commit_message": "bpo-43354: xmlrpc: Fix type documentation for Fault.faultCode (GH-24707)", "files_name": ["Doc/library/xmlrpc.client.rst", "Misc/NEWS.d/next/Documentation/2021-03-02-12-55-34.bpo-43354.ezZYkx.rst"]}, {"commit_id": "1899087b21119c5c64cd41619b542c0bf0ab5751", "commit_date": "Fri Mar 26 11:55:07 2021 -0700", "commit_message": "bpo-42136: Deprecate module_repr() as found in importlib (GH-25022)", "files_name": ["Doc/reference/import.rst", "Doc/whatsnew/3.10.rst", "Lib/importlib/_abc.py", "Lib/importlib/_bootstrap.py", "Lib/importlib/_bootstrap_external.py", "Lib/test/test_importlib/test_abc.py", "Lib/test/test_importlib/test_namespace_pkgs.py", "Lib/test/test_importlib/test_windows.py", "Misc/NEWS.d/next/Library/2021-03-25-08-44-26.bpo-42136.rRY9e1.rst", "Python/importlib.h", "Python/importlib_external.h"]}, {"commit_id": "21a2cabb3795f5170c746ab8f29e9d25c7442550", "commit_date": "Fri Mar 26 12:02:32 2021 -0400", "commit_message": "bpo-43620: Remove reference to os.sep from os.path.join() doc (#25025)", "files_name": ["Doc/library/os.path.rst"]}, {"commit_id": "3bb19873abd572879cc9a8810b1db9db1f704070", "commit_date": "Thu Mar 25 13:32:23 2021 -0700", "commit_message": "Revert \"bpo-40521: Remove freelist from collections.deque() (GH-21073)\" (GH-24944)", "files_name": ["Modules/_collectionsmodule.c"]}, {"commit_id": "929c9039fe0468cb37e0811ddfb7b67c98353ea8", "commit_date": "Thu Mar 25 17:16:31 2021 +0100", "commit_message": "bpo-43416: Add Include/README.rst (GH-24884)", "files_name": ["Include/README.rst"]}, {"commit_id": "56816bb845bec7714227735765e1a47c1b8f44e7", "commit_date": "Thu Mar 25 18:14:22 2021 +0200", "commit_message": "\"exists\" -> \"exist\" in What's New 3.10 (GH-25019)", "files_name": ["Doc/whatsnew/3.10.rst"]}, {"commit_id": "d41bdddbede45890e4effb1bbea6a346ff706695", "commit_date": "Thu Mar 25 12:00:30 2021 +0000", "commit_message": "Move big block of macros out of function to improve readability. (GH-25020)", "files_name": ["Python/ceval.c"]}, {"commit_id": "b045cdaf341f80b7d1e4804b932b6e415600c2e1", "commit_date": "Thu Mar 25 16:23:50 2021 +0900", "commit_message": "Doc: io: Remove \"In-memory streams\" section (GH-24927)", "files_name": ["Doc/library/io.rst"]}, {"commit_id": "df9ade9beb86935963f8ae47d9377578399ab6d2", "commit_date": "Thu Mar 25 09:19:23 2021 +0900", "commit_message": "AC: Update unsupported_special_methods (GH-24956)", "files_name": ["Tools/clinic/clinic.py"]}, {"commit_id": "72789592a3491bab49f144bb292679b1484885d9", "commit_date": "Wed Mar 24 15:33:27 2021 -0700", "commit_message": "bpo-43198:  Revert 3dd2157 that removed freeslot tracking. (#25010)", "files_name": ["Objects/setobject.c"]}, {"commit_id": "8efad61963809d239cac986e3f3bc4cb505ab8fe", "commit_date": "Wed Mar 24 19:34:17 2021 +0000", "commit_message": "bpo-41064: Improve syntax error for invalid usage of '**' in f-strings (GH-25006)", "files_name": ["Grammar/python.gram", "Lib/test/test_fstring.py", "Misc/NEWS.d/next/Core and Builtins/2021-03-24-00-32-20.bpo-41064._H0K_g.rst", "Parser/parser.c"]}, {"commit_id": "4958f5d69dd2bf86866c43491caf72f774ddec97", "commit_date": "Wed Mar 24 17:56:12 2021 +0000", "commit_message": "Only check evalbreaker after calls and on backwards egdes. Makes sure that __exit__ or __aexit__ is called in with statments in case of interrupt. (GH-18334)", "files_name": ["Misc/NEWS.d/next/Core and Builtins/2020-02-03-13-23-10.bpo-29988.8_UB5w.rst", "Python/ceval.c"]}, {"commit_id": "232f4cb6671f1ec5591faabbbbcc599da22781c4", "commit_date": "Thu Mar 25 00:47:21 2021 +0900", "commit_message": "Fix typo in fuzzer.c (GH-25013)", "files_name": ["Modules/_xxtestfuzz/fuzzer.c"]}, {"commit_id": "9cb31d671646a5ff0901f79d2d61022621447190", "commit_date": "Wed Mar 24 08:26:56 2021 -0700", "commit_message": "bpo-42137: have ModuleType.__repr__ prefer __spec__ over module_repr() (GH-24953)", "files_name": ["Doc/library/importlib.rst", "Doc/whatsnew/3.10.rst", "Lib/importlib/_bootstrap.py", "Lib/test/test_importlib/frozen/test_loader.py", "Lib/test/test_importlib/test_namespace_pkgs.py", "Misc/NEWS.d/next/Core and Builtins/2021-03-20-19-54-47.bpo-42137.A8aQvj.rst", "Python/importlib.h"]}, {"commit_id": "3ba3d513b1e3c63d09cb798b982a9e6c369cea4c", "commit_date": "Wed Mar 24 09:23:20 2021 +0100", "commit_message": "bpo-42914: add a pprint underscore_numbers option (GH-24864)", "files_name": ["Doc/library/pprint.rst", "Lib/pprint.py", "Lib/test/test_pprint.py", "Misc/NEWS.d/next/Library/2021-03-14-21-47-28.bpo-42914.9U1o33.rst"]}, {"commit_id": "a02683ac38183fa3a45c32319dfd329c5e622f0e", "commit_date": "Wed Mar 24 01:42:13 2021 +0000", "commit_message": "bpo-31861: Fix reference leak in builtin_anext_impl() (GH-25008)", "files_name": ["Python/bltinmodule.c"]}, {"commit_id": "8370e07e1e5b626e78ddc7aadbfaf248976c4454", "commit_date": "Wed Mar 24 02:23:01 2021 +0100", "commit_message": "bpo-43244: Remove the pyarena.h header (GH-25007)", "files_name": ["Doc/whatsnew/3.10.rst", "Include/Python.h", "Include/cpython/pyarena.h", "Include/internal/pycore_asdl.h", "Include/internal/pycore_compile.h", "Include/internal/pycore_pyarena.h", "Makefile.pre.in", "Misc/NEWS.d/next/C API/2021-03-24-01-22-14.bpo-43244.31-97x.rst", "PCbuild/pythoncore.vcxproj", "PCbuild/pythoncore.vcxproj.filters", "Parser/asdl_c.py", "Parser/pegen.c", "Parser/string_parser.c", "Python/Python-ast.c", "Python/ast_opt.c", "Python/bltinmodule.c", "Python/pyarena.c", "Python/pythonrun.c", "Python/symtable.c", "Tools/peg_generator/peg_extension/peg_extension.c"]}, {"commit_id": "919d42d477093154a30b55d9d79f023dbbe5614a", "commit_date": "Wed Mar 24 00:30:02 2021 +0000", "commit_message": "bpo-31861: Fix possible crash in PyAnextAwaitable_New (GH-25005)", "files_name": ["Objects/iterobject.c"]}, {"commit_id": "57364ce34e0492fbc8b0a6b8c882f384bb489457", "commit_date": "Wed Mar 24 01:29:09 2021 +0100", "commit_message": "bpo-43244: Remove parser_interface.h header file (GH-25001)", "files_name": ["Doc/whatsnew/3.10.rst", "Include/Python.h", "Include/cpython/parser_interface.h", "Include/internal/pycore_parser.h", "Makefile.pre.in", "Misc/NEWS.d/next/C API/2021-03-23-20-53-41.bpo-43244.VK3sLH.rst", "Parser/peg_api.c", "Parser/pegen.c", "Parser/pegen.h", "Python/pythonrun.c", "Python/symtable.c", "Tools/peg_generator/peg_extension/peg_extension.c"]}, {"commit_id": "a054f6b2b1d9f75edfb5ec2247bbf60f07491977", "commit_date": "Wed Mar 24 00:04:52 2021 +0000", "commit_message": "bpo-43452: Document the PyType_Lookup optimizations in the What's New for 3.10 (GH-24949)", "files_name": ["Doc/whatsnew/3.10.rst"]}, {"commit_id": "d9692027f41ee7600fe401c066617ebfc8bac930", "commit_date": "Tue Mar 23 23:57:03 2021 +0000", "commit_message": "bpo-31861: Complete the C-API docs for PyObject_GetAiter and PyAiter_Check (GH-25004)", "files_name": ["Doc/c-api/iter.rst", "Doc/c-api/object.rst", "Doc/data/refcounts.dat"]}], "windows_after": [{"commit_id": "70cdf1812cf479c6b1cd7435a6fc0679ec1fb0da", "commit_date": "Mon Mar 29 14:17:40 2021 +0100", "commit_message": "bpo-40645: Fix reference leak in the _hashopenssl extension (GH-25063)", "files_name": ["Misc/NEWS.d/next/Core and Builtins/2021-03-29-11-55-06.bpo-40645.PhaT-B.rst", "Modules/_hashopenssl.c"]}, {"commit_id": "c1b073a630bb731de18bb17afb2b8b1388b92a72", "commit_date": "Mon Mar 29 16:39:31 2021 +0300", "commit_message": "bpo-43433: Preserve query and fragment in the URL of the server in ServerProxy. (GH-25057)", "files_name": ["Lib/test/test_xmlrpc.py", "Lib/xmlrpc/client.py", "Misc/NEWS.d/next/Library/2021-03-28-23-50-20.bpo-43433.so9j5G.rst"]}, {"commit_id": "7bfd65eba73d013eee8789f2009c09c61c31b800", "commit_date": "Mon Mar 29 15:16:19 2021 +0100", "commit_message": "bpo-43648: Remove redundant datefmt option in logging file config (GH-25051)", "files_name": ["Doc/howto/logging.rst"]}, {"commit_id": "32430aadadf6e012e39167d3c18a24e49fb84874", "commit_date": "Mon Mar 29 19:22:13 2021 +0200", "commit_message": "bpo-35930: Raising an exception raised in a \"future\" instance will create reference cycles (#24995)", "files_name": ["Lib/concurrent/futures/_base.py", "Misc/NEWS.d/next/Library/2021-03-23-17-18-56.bpo-35930.RZ51pM.rst"]}, {"commit_id": "c8b5738810516df5722caf049003e9b319427bec", "commit_date": "Mon Mar 29 21:06:24 2021 +0200", "commit_message": "bpo-43659:  Fix test_curses on AIX (GH-25074)", "files_name": ["Lib/test/test_curses.py"]}, {"commit_id": "09b90a037d18f5d4acdf1b14082e57bda78e85d3", "commit_date": "Mon Mar 29 23:38:51 2021 +0100", "commit_message": "bpo-43660: Fix crash when displaying exceptions with custom values for sys.stderr (GH-25075)", "files_name": ["Lib/test/test_sys.py", "Misc/NEWS.d/next/Core and Builtins/2021-03-29-19-50-34.bpo-43660.scTgag.rst", "Python/pythonrun.c"]}, {"commit_id": "92a02c1f7e2dcdc62913a4236589e7e5d96172b9", "commit_date": "Tue Mar 30 00:24:49 2021 +0100", "commit_message": "Fix tokenizer error when raw decoding null bytes (GH-25080)", "files_name": ["Parser/tokenizer.c"]}, {"commit_id": "a54fc683f237d8f0b6e999a63aa9b8c0a45b7fef", "commit_date": "Tue Mar 30 02:00:34 2021 +0200", "commit_message": "bpo-43631: Update to OpenSSL 1.1.1k (GH-25024)", "files_name": [".azure-pipelines/ci.yml", ".azure-pipelines/pr.yml", ".github/workflows/build.yml", ".github/workflows/coverage.yml", ".travis.yml", "Mac/BuildScript/build-installer.py", "Misc/NEWS.d/next/Build/2021-03-26-09-16-34.bpo-43631.msJyPi.rst", "PCbuild/get_externals.bat", "PCbuild/python.props", "PCbuild/readme.txt", "Tools/ssl/multissltests.py"]}, {"commit_id": "85b6b70589c187639aeebc560d67e9cc04abb4d8", "commit_date": "Mon Mar 29 19:51:15 2021 -0700", "commit_message": "bpo-37448: Use radix tree for pymalloc address_in_range(). (GH-14474)", "files_name": ["Misc/NEWS.d/next/Core and Builtins/2021-02-21-14-19-35.bpo-37448.btl7vO.rst", "Objects/obmalloc.c"]}, {"commit_id": "068ebf9729d440cef03e4c57e3db83c851146172", "commit_date": "Tue Mar 30 12:25:28 2021 +0900", "commit_message": "bpo-33164: blake2: Fix Coverity scan (GH-25060)", "files_name": ["Modules/_blake2/impl/blake2b-ref.c", "Modules/_blake2/impl/blake2b.c", "Modules/_blake2/impl/blake2s-ref.c", "Modules/_blake2/impl/blake2s.c"]}, {"commit_id": "dfeec347f21b86879ba8f27f567bb275b243f1bc", "commit_date": "Tue Mar 30 00:22:34 2021 -0600", "commit_message": "bpo-43637: Fix a possible memory leak in winreg.SetValueEx() (GH-25038)", "files_name": ["PC/winreg.c"]}, {"commit_id": "cf35e05f89bb008d6f4553f9875e0fe87fc02406", "commit_date": "Tue Mar 30 04:37:37 2021 -0400", "commit_message": "bpo-43125: Fix: return expected type (str), not original value (bytes) in email/base64mime.py::body_encode (GH-24476)", "files_name": ["Lib/email/base64mime.py", "Lib/test/test_email/test_email.py", "Misc/NEWS.d/next/Library/2021-02-07-19-13-30.bpo-43125.AqNoMa.rst"]}, {"commit_id": "a7ff6df60c05e1b69fca743573b1e118bebf121d", "commit_date": "Tue Mar 30 08:43:03 2021 -0700", "commit_message": "bpo-42134: Raise ImportWarning when calling find_module() in the import system (GH-25044)", "files_name": ["Doc/reference/import.rst", "Doc/whatsnew/3.10.rst", "Lib/importlib/_bootstrap.py", "Lib/importlib/_bootstrap_external.py", "Lib/test/test_importlib/import_/test_path.py", "Lib/test/test_importlib/test_api.py", "Misc/NEWS.d/next/Core and Builtins/2021-03-26-17-30-19.bpo-42134.G4Sjxg.rst", "Python/importlib.h", "Python/importlib_external.h"]}, {"commit_id": "73b20ae2fb7a5c1374aa5c3719f64c53d29fa0d2", "commit_date": "Tue Mar 30 18:11:06 2021 +0200", "commit_message": "bpo-41369: Finish updating the vendored libmpdec to version 2.5.1 (GH-24962)", "files_name": ["Misc/NEWS.d/next/Library/2021-03-21-17-50-42.bpo-41369.-fpmYZ.rst", "Modules/_decimal/_decimal.c", "Modules/_decimal/libmpdec/README.txt", "Modules/_decimal/libmpdec/bench.c", "Modules/_decimal/libmpdec/bench_full.c", "Modules/_decimal/libmpdec/constants.c", "Modules/_decimal/libmpdec/context.c", "Modules/_decimal/libmpdec/crt.c", "Modules/_decimal/libmpdec/crt.h", "Modules/_decimal/libmpdec/examples/README.txt", "Modules/_decimal/libmpdec/examples/compare.c", "Modules/_decimal/libmpdec/examples/div.c", "Modules/_decimal/libmpdec/examples/divmod.c", "Modules/_decimal/libmpdec/examples/multiply.c", "Modules/_decimal/libmpdec/examples/pow.c", "Modules/_decimal/libmpdec/examples/powmod.c", "Modules/_decimal/libmpdec/examples/shift.c", "Modules/_decimal/libmpdec/examples/sqrt.c", "Modules/_decimal/libmpdec/io.c", "Modules/_decimal/libmpdec/mpalloc.c", "Modules/_decimal/libmpdec/mpalloc.h", "Modules/_decimal/libmpdec/mpdecimal.c", "Modules/_decimal/libmpdec/mpdecimal.h", "Modules/_decimal/libmpdec/mpsignal.c", "Modules/_decimal/libmpdec/typearith.h", "setup.py"]}, {"commit_id": "51a85ddce8b336addcb61b96f04c9c5edef07296", "commit_date": "Tue Mar 30 23:11:29 2021 +0200", "commit_message": "bpo-43399: Fix ElementTree.extend not working on iterators (GH-24751)", "files_name": ["Lib/test/test_xml_etree.py", "Lib/xml/etree/ElementTree.py", "Misc/ACKS", "Misc/NEWS.d/next/Library/2021-03-04-17-53-46.bpo-43399.Wn95u-.rst"]}, {"commit_id": "b775106d940e3d77c8af7967545bb9a5b7b162df", "commit_date": "Tue Mar 30 21:17:26 2021 -0700", "commit_message": "bpo-40066: Enum: modify `repr()` and `str()` (GH-22392)", "files_name": ["Doc/howto/enum.rst", "Doc/howto/index.rst", "Doc/library/enum.rst", "Doc/library/http.rst", "Doc/library/socket.rst", "Doc/library/ssl.rst", "Doc/whatsnew/3.10.rst", "Lib/enum.py", "Lib/inspect.py", "Lib/plistlib.py", "Lib/re.py", "Lib/test/test_enum.py", "Lib/test/test_pydoc.py", "Lib/test/test_signal.py", "Lib/test/test_socket.py", "Lib/test/test_ssl.py", "Lib/test/test_unicode.py", "Misc/NEWS.d/next/Library/2020-09-23-21-58-34.bpo-40066.f1dr_5.rst", "Misc/NEWS.d/next/Library/2021-03-25-21-26-30.bpo-40066.7EBQ3_.rst"]}, {"commit_id": "1b4a9c7956d5dc64f8002f62bf0faae2d1892f90", "commit_date": "Wed Mar 31 01:19:38 2021 -0400", "commit_message": "bpo-42225: IDLE - document two unix-related problems. (#25078)", "files_name": ["Doc/library/idle.rst", "Lib/idlelib/help.html", "Misc/NEWS.d/next/IDLE/2021-03-29-16-22-27.bpo-42225.iIeiLg.rst"]}, {"commit_id": "ff3c9739bd69aa8b58007e63c9e40e6708b4761e", "commit_date": "Wed Mar 31 14:26:08 2021 +0900", "commit_message": "bpo-43510: PEP 597: Accept `encoding=\"locale\"` in binary mode (GH-25103)", "files_name": ["Lib/_pyio.py", "Lib/test/test_io.py", "Modules/_io/_iomodule.c"]}, {"commit_id": "cfa176685a5e788bafc7749d7a93f43ea3e4de9f", "commit_date": "Wed Mar 31 18:49:41 2021 +0900", "commit_message": "Revert \"bpo-43510: PEP 597: Accept `encoding=\"locale\"` in binary mode (GH-25103)\" (#25108)", "files_name": ["Lib/_pyio.py", "Lib/test/test_io.py", "Modules/_io/_iomodule.c"]}, {"commit_id": "dec075754960dd85972ce5170df76e862f966132", "commit_date": "Wed Mar 31 11:12:39 2021 +0100", "commit_message": "bpo-43179: Generalise alignment for optimised string routines (GH-24624)", "files_name": ["Objects/bytes_methods.c", "Objects/stringlib/codecs.h", "Objects/stringlib/find_max_char.h", "Objects/unicodeobject.c", "PC/pyconfig.h", "configure", "configure.ac", "pyconfig.h.in"]}, {"commit_id": "027d2cf1e5e2512888340b4cd5d2f1b5a3e8af94", "commit_date": "Wed Mar 31 12:22:03 2021 +0200", "commit_message": "Document GH-24624", "files_name": ["Misc/NEWS.d/next/Build/2021-03-31-12-20-23.bpo-43179.Qbe1OD.rst"]}, {"commit_id": "f3ab670fea75ebe177e3412a5ebe39263cd428e3", "commit_date": "Wed Mar 31 13:01:46 2021 +0200", "commit_message": "bpo-37945: Fix test_locale.test_getsetlocale_issue1813() (#25110)", "files_name": ["Lib/test/test_locale.py", "Misc/NEWS.d/next/Tests/2021-03-31-11-38-42.bpo-37945.HTUYhv.rst"]}, {"commit_id": "202b54644245afadf124d8043688a95d4d9c456d", "commit_date": "Wed Mar 31 14:31:38 2021 +0200", "commit_message": "Disambiguate that -m also terminates the option list in the manpage. (GH-25100)", "files_name": ["Misc/python.man"]}, {"commit_id": "49aec1a185bb2087fc4d846bd38d9150a357cfbd", "commit_date": "Wed Mar 31 09:20:08 2021 -0700", "commit_message": "Enum: add (re)import of Flag for doctests (GH-25118)", "files_name": ["Doc/library/enum.rst"]}, {"commit_id": "ad493edf5791e7abb2588852e876b8584945c653", "commit_date": "Thu Apr 1 02:28:23 2021 +0200", "commit_message": "bpo-42955: Add _overlapped to sys.stdlib_module_names (GH-25122)", "files_name": ["Python/stdlib_module_names.h", "Tools/scripts/generate_stdlib_module_names.py"]}, {"commit_id": "55f31be44b7e3ee24a67134f99543512a9b630e4", "commit_date": "Thu Apr 1 11:23:03 2021 +0900", "commit_message": "bpo-43651: Fix EncodingWarning in test_file and test_file_eintr (GH-25109)", "files_name": ["Lib/test/test_file.py", "Lib/test/test_file_eintr.py"]}, {"commit_id": "58cffba1874f0e9a9731b25a3e11a011bfbbf95f", "commit_date": "Thu Apr 1 11:25:04 2021 +0900", "commit_message": "bpo-43651: Fix EncodingWarning in test_io (GH-25097)", "files_name": ["Lib/test/test_io.py"]}, {"commit_id": "078a3433ebe4c211cd93c84cd9c2148c3aa23238", "commit_date": "Wed Mar 31 22:46:31 2021 -0500", "commit_message": "When printing stats, move radix tree info to its own section. (GH-25125)", "files_name": ["Objects/obmalloc.c"]}, {"commit_id": "18701a0608b66a8fa147b31243a95de8d828211c", "commit_date": "Wed Mar 31 23:00:30 2021 -0700", "commit_message": "Fix typos in 3.10 \"What's new\" (GH-25104)", "files_name": ["Doc/whatsnew/3.10.rst"]}, {"commit_id": "baf10da75072d1f8ec714d3c2c8550d34db343a9", "commit_date": "Thu Apr 1 11:29:46 2021 +0200", "commit_message": "bpo-43688: Run make regen-limited-abi (GH-25134)", "files_name": ["Doc/data/stable_abi.dat"]}, {"commit_id": "61092a99c4840f36dbde8457cb566fc3c012930f", "commit_date": "Thu Apr 1 14:13:42 2021 +0200", "commit_message": "bpo-43690: stable_abi.py no longer parses macros (GH-25136)", "files_name": ["Doc/data/stable_abi.dat", "Tools/scripts/stable_abi.py"]}, {"commit_id": "2ac0515027699b5694d9a6ff40f1ddaba82c74c2", "commit_date": "Thu Apr 1 15:09:33 2021 +0200", "commit_message": "bpo-43688: Fix Py_LIMITED_API version of xxlimited (GH-25135)", "files_name": ["Include/methodobject.h", "PCbuild/xxlimited.vcxproj", "setup.py"]}, {"commit_id": "fcb55c0037baab6f98f91ee38ce84b6f874f034a", "commit_date": "Thu Apr 1 16:00:31 2021 +0100", "commit_message": "bpo-27129: Use instruction offsets, not byte offsets, in bytecode and internally. (GH-25069)", "files_name": ["Lib/dis.py", "Lib/importlib/_bootstrap_external.py", "Lib/test/test_dis.py"]}], "parents": [{"commit_id_before": "4827483f47906fecee6b5d9097df2a69a293a85c", "url_before": "https://api.github.com/repos/python/cpython/commits/4827483f47906fecee6b5d9097df2a69a293a85c", "html_url_before": "https://github.com/python/cpython/commit/4827483f47906fecee6b5d9097df2a69a293a85c"}], "details": [{"raw_url": "https://github.com/python/cpython/raw/9b999479c0022edfc9835a8a1f06e046f3881048/Lib%2Fpydoc.py", "code": "#!/usr/bin/env python3\n\"\"\"Generate Python documentation in HTML or text for interactive use.\n\nAt the Python interactive prompt, calling help(thing) on a Python object\ndocuments the object, and calling help() starts up an interactive\nhelp session.\n\nOr, at the shell command line outside of Python:\n\nRun \"pydoc <name>\" to show documentation on something.  <name> may be\nthe name of a function, module, package, or a dotted reference to a\nclass or function within a module or module in a package.  If the\nargument contains a path segment delimiter (e.g. slash on Unix,\nbackslash on Windows) it is treated as the path to a Python source file.\n\nRun \"pydoc -k <keyword>\" to search for a keyword in the synopsis lines\nof all available modules.\n\nRun \"pydoc -n <hostname>\" to start an HTTP server with the given\nhostname (default: localhost) on the local machine.\n\nRun \"pydoc -p <port>\" to start an HTTP server on the given port on the\nlocal machine.  Port number 0 can be used to get an arbitrary unused port.\n\nRun \"pydoc -b\" to start an HTTP server on an arbitrary unused port and\nopen a Web browser to interactively browse documentation.  Combine with\nthe -n and -p options to control the hostname and port used.\n\nRun \"pydoc -w <name>\" to write out the HTML documentation for a module\nto a file named \"<name>.html\".\n\nModule docs for core modules are assumed to be in\n\n    https://docs.python.org/X.Y/library/\n\nThis can be overridden by setting the PYTHONDOCS environment variable\nto a different URL or to a local directory containing the Library\nReference Manual pages.\n\"\"\"\n__all__ = ['help']\n__author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n__date__ = \"26 February 2001\"\n\n__credits__ = \"\"\"Guido van Rossum, for an excellent programming language.\nTommy Burnette, the original creator of manpy.\nPaul Prescod, for all his work on onlinehelp.\nRichard Chamberlain, for the first implementation of textdoc.\n\"\"\"\n\n# Known bugs that can't be fixed here:\n#   - synopsis() cannot be prevented from clobbering existing\n#     loaded modules.\n#   - If the __file__ attribute on a module is a relative path and\n#     the current directory is changed with os.chdir(), an incorrect\n#     path will be displayed.\n\nimport builtins\nimport importlib._bootstrap\nimport importlib._bootstrap_external\nimport importlib.machinery\nimport importlib.util\nimport inspect\nimport io\nimport os\nimport pkgutil\nimport platform\nimport re\nimport sys\nimport sysconfig\nimport time\nimport tokenize\nimport urllib.parse\nimport warnings\nfrom collections import deque\nfrom reprlib import Repr\nfrom traceback import format_exception_only\n\n\n# --------------------------------------------------------- common routines\n\ndef pathdirs():\n    \"\"\"Convert sys.path into a list of absolute, existing, unique paths.\"\"\"\n    dirs = []\n    normdirs = []\n    for dir in sys.path:\n        dir = os.path.abspath(dir or '.')\n        normdir = os.path.normcase(dir)\n        if normdir not in normdirs and os.path.isdir(dir):\n            dirs.append(dir)\n            normdirs.append(normdir)\n    return dirs\n\ndef _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not inspect.isclass(cls):\n        return None\n    return cls\n\ndef _finddoc(obj):\n    if inspect.ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif inspect.isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.ismethoddescriptor(obj) or inspect.isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if inspect.ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = _getowndoc(getattr(base, name))\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None\n\ndef _getowndoc(obj):\n    \"\"\"Get the documentation string for an object if it is not\n    inherited from its class.\"\"\"\n    try:\n        doc = object.__getattribute__(obj, '__doc__')\n        if doc is None:\n            return None\n        if obj is not type:\n            typedoc = type(obj).__doc__\n            if isinstance(typedoc, str) and typedoc == doc:\n                return None\n        return doc\n    except AttributeError:\n        return None\n\ndef _getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    doc = _getowndoc(object)\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return inspect.cleandoc(doc)\n\ndef getdoc(object):\n    \"\"\"Get the doc string or comments for an object.\"\"\"\n    result = _getdoc(object) or inspect.getcomments(object)\n    return result and re.sub('^ *\\n', '', result.rstrip()) or ''\n\ndef splitdoc(doc):\n    \"\"\"Split a doc string into a synopsis line (if any) and the rest.\"\"\"\n    lines = doc.strip().split('\\n')\n    if len(lines) == 1:\n        return lines[0], ''\n    elif len(lines) >= 2 and not lines[1].rstrip():\n        return lines[0], '\\n'.join(lines[2:])\n    return '', '\\n'.join(lines)\n\ndef classname(object, modname):\n    \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\"\n    name = object.__name__\n    if object.__module__ != modname:\n        name = object.__module__ + '.' + name\n    return name\n\ndef isdata(object):\n    \"\"\"Check if an object is of a type that probably means it's data.\"\"\"\n    return not (inspect.ismodule(object) or inspect.isclass(object) or\n                inspect.isroutine(object) or inspect.isframe(object) or\n                inspect.istraceback(object) or inspect.iscode(object))\n\ndef replace(text, *pairs):\n    \"\"\"Do a series of global replacements on a string.\"\"\"\n    while pairs:\n        text = pairs[1].join(text.split(pairs[0]))\n        pairs = pairs[2:]\n    return text\n\ndef cram(text, maxlen):\n    \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\"\n    if len(text) > maxlen:\n        pre = max(0, (maxlen-3)//2)\n        post = max(0, maxlen-3-pre)\n        return text[:pre] + '...' + text[len(text)-post:]\n    return text\n\n_re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE)\ndef stripid(text):\n    \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\"\n    # The behaviour of %p is implementation-dependent in terms of case.\n    return _re_stripid.sub(r'\\1', text)\n\ndef _is_bound_method(fn):\n    \"\"\"\n    Returns True if fn is a bound method, regardless of whether\n    fn was implemented in Python or in C.\n    \"\"\"\n    if inspect.ismethod(fn):\n        return True\n    if inspect.isbuiltin(fn):\n        self = getattr(fn, '__self__', None)\n        return not (inspect.ismodule(self) or (self is None))\n    return False\n\n\ndef allmethods(cl):\n    methods = {}\n    for key, value in inspect.getmembers(cl, inspect.isroutine):\n        methods[key] = 1\n    for base in cl.__bases__:\n        methods.update(allmethods(base)) # all your base are belong to us\n    for key in methods.keys():\n        methods[key] = getattr(cl, key)\n    return methods\n\ndef _split_list(s, predicate):\n    \"\"\"Split sequence s via predicate, and return pair ([true], [false]).\n\n    The return value is a 2-tuple of lists,\n        ([x for x in s if predicate(x)],\n         [x for x in s if not predicate(x)])\n    \"\"\"\n\n    yes = []\n    no = []\n    for x in s:\n        if predicate(x):\n            yes.append(x)\n        else:\n            no.append(x)\n    return yes, no\n\ndef visiblename(name, all=None, obj=None):\n    \"\"\"Decide whether to show documentation on a variable.\"\"\"\n    # Certain special names are redundant or internal.\n    # XXX Remove __initializing__?\n    if name in {'__author__', '__builtins__', '__cached__', '__credits__',\n                '__date__', '__doc__', '__file__', '__spec__',\n                '__loader__', '__module__', '__name__', '__package__',\n                '__path__', '__qualname__', '__slots__', '__version__'}:\n        return 0\n    # Private names are hidden, but special names are displayed.\n    if name.startswith('__') and name.endswith('__'): return 1\n    # Namedtuples have public fields and methods with a single leading underscore\n    if name.startswith('_') and hasattr(obj, '_fields'):\n        return True\n    if all is not None:\n        # only document that which the programmer exported in __all__\n        return name in all\n    else:\n        return not name.startswith('_')\n\ndef classify_class_attrs(object):\n    \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\"\n    results = []\n    for (name, kind, cls, value) in inspect.classify_class_attrs(object):\n        if inspect.isdatadescriptor(value):\n            kind = 'data descriptor'\n            if isinstance(value, property) and value.fset is None:\n                kind = 'readonly property'\n        results.append((name, kind, cls, value))\n    return results\n\ndef sort_attributes(attrs, object):\n    'Sort the attrs list in-place by _fields and then alphabetically by name'\n    # This allows data descriptors to be ordered according\n    # to a _fields attribute if present.\n    fields = getattr(object, '_fields', [])\n    try:\n        field_order = {name : i-len(fields) for (i, name) in enumerate(fields)}\n    except TypeError:\n        field_order = {}\n    keyfunc = lambda attr: (field_order.get(attr[0], 0), attr[0])\n    attrs.sort(key=keyfunc)\n\n# ----------------------------------------------------- module manipulation\n\ndef ispackage(path):\n    \"\"\"Guess whether a path refers to a package directory.\"\"\"\n    if os.path.isdir(path):\n        for ext in ('.py', '.pyc'):\n            if os.path.isfile(os.path.join(path, '__init__' + ext)):\n                return True\n    return False\n\ndef source_synopsis(file):\n    line = file.readline()\n    while line[:1] == '#' or not line.strip():\n        line = file.readline()\n        if not line: break\n    line = line.strip()\n    if line[:4] == 'r\"\"\"': line = line[1:]\n    if line[:3] == '\"\"\"':\n        line = line[3:]\n        if line[-1:] == '\\\\': line = line[:-1]\n        while not line.strip():\n            line = file.readline()\n            if not line: break\n        result = line.split('\"\"\"')[0].strip()\n    else: result = None\n    return result\n\ndef synopsis(filename, cache={}):\n    \"\"\"Get the one-line summary out of a module file.\"\"\"\n    mtime = os.stat(filename).st_mtime\n    lastupdate, result = cache.get(filename, (None, None))\n    if lastupdate is None or lastupdate < mtime:\n        # Look for binary suffixes first, falling back to source.\n        if filename.endswith(tuple(importlib.machinery.BYTECODE_SUFFIXES)):\n            loader_cls = importlib.machinery.SourcelessFileLoader\n        elif filename.endswith(tuple(importlib.machinery.EXTENSION_SUFFIXES)):\n            loader_cls = importlib.machinery.ExtensionFileLoader\n        else:\n            loader_cls = None\n        # Now handle the choice.\n        if loader_cls is None:\n            # Must be a source file.\n            try:\n                file = tokenize.open(filename)\n            except OSError:\n                # module can't be opened, so skip it\n                return None\n            # text modules can be directly examined\n            with file:\n                result = source_synopsis(file)\n        else:\n            # Must be a binary module, which has to be imported.\n            loader = loader_cls('__temp__', filename)\n            # XXX We probably don't need to pass in the loader here.\n            spec = importlib.util.spec_from_file_location('__temp__', filename,\n                                                          loader=loader)\n            try:\n                module = importlib._bootstrap._load(spec)\n            except:\n                return None\n            del sys.modules['__temp__']\n            result = module.__doc__.splitlines()[0] if module.__doc__ else None\n        # Cache the result.\n        cache[filename] = (mtime, result)\n    return result\n\nclass ErrorDuringImport(Exception):\n    \"\"\"Errors that occurred while trying to import something to document it.\"\"\"\n    def __init__(self, filename, exc_info):\n        self.filename = filename\n        self.exc, self.value, self.tb = exc_info\n\n    def __str__(self):\n        exc = self.exc.__name__\n        return 'problem in %s - %s: %s' % (self.filename, exc, self.value)\n\ndef importfile(path):\n    \"\"\"Import a Python source file or compiled file given its path.\"\"\"\n    magic = importlib.util.MAGIC_NUMBER\n    with open(path, 'rb') as file:\n        is_bytecode = magic == file.read(len(magic))\n    filename = os.path.basename(path)\n    name, ext = os.path.splitext(filename)\n    if is_bytecode:\n        loader = importlib._bootstrap_external.SourcelessFileLoader(name, path)\n    else:\n        loader = importlib._bootstrap_external.SourceFileLoader(name, path)\n    # XXX We probably don't need to pass in the loader here.\n    spec = importlib.util.spec_from_file_location(name, path, loader=loader)\n    try:\n        return importlib._bootstrap._load(spec)\n    except:\n        raise ErrorDuringImport(path, sys.exc_info())\n\ndef safeimport(path, forceload=0, cache={}):\n    \"\"\"Import a module; handle errors; return None if the module isn't found.\n\n    If the module *is* found but an exception occurs, it's wrapped in an\n    ErrorDuringImport exception and reraised.  Unlike __import__, if a\n    package path is specified, the module at the end of the path is returned,\n    not the package at the beginning.  If the optional 'forceload' argument\n    is 1, we reload the module from disk (unless it's a dynamic extension).\"\"\"\n    try:\n        # If forceload is 1 and the module has been previously loaded from\n        # disk, we always have to reload the module.  Checking the file's\n        # mtime isn't good enough (e.g. the module could contain a class\n        # that inherits from another module that has changed).\n        if forceload and path in sys.modules:\n            if path not in sys.builtin_module_names:\n                # Remove the module from sys.modules and re-import to try\n                # and avoid problems with partially loaded modules.\n                # Also remove any submodules because they won't appear\n                # in the newly loaded module's namespace if they're already\n                # in sys.modules.\n                subs = [m for m in sys.modules if m.startswith(path + '.')]\n                for key in [path] + subs:\n                    # Prevent garbage collection.\n                    cache[key] = sys.modules[key]\n                    del sys.modules[key]\n        module = __import__(path)\n    except:\n        # Did the error occur before or after the module was found?\n        (exc, value, tb) = info = sys.exc_info()\n        if path in sys.modules:\n            # An error occurred while executing the imported module.\n            raise ErrorDuringImport(sys.modules[path].__file__, info)\n        elif exc is SyntaxError:\n            # A SyntaxError occurred before we could execute the module.\n            raise ErrorDuringImport(value.filename, info)\n        elif issubclass(exc, ImportError) and value.name == path:\n            # No such module in the path.\n            return None\n        else:\n            # Some other error occurred during the importing process.\n            raise ErrorDuringImport(path, sys.exc_info())\n    for part in path.split('.')[1:]:\n        try: module = getattr(module, part)\n        except AttributeError: return None\n    return module\n\n# ---------------------------------------------------- formatter base class\n\nclass Doc:\n\n    PYTHONDOCS = os.environ.get(\"PYTHONDOCS\",\n                                \"https://docs.python.org/%d.%d/library\"\n                                % sys.version_info[:2])\n\n    def document(self, object, name=None, *args):\n        \"\"\"Generate documentation for an object.\"\"\"\n        args = (object, name) + args\n        # 'try' clause is to attempt to handle the possibility that inspect\n        # identifies something in a way that pydoc itself has issues handling;\n        # think 'super' and how it is a descriptor (which raises the exception\n        # by lacking a __name__ attribute) and an instance.\n        try:\n            if inspect.ismodule(object): return self.docmodule(*args)\n            if inspect.isclass(object): return self.docclass(*args)\n            if inspect.isroutine(object): return self.docroutine(*args)\n        except AttributeError:\n            pass\n        if inspect.isdatadescriptor(object): return self.docdata(*args)\n        return self.docother(*args)\n\n    def fail(self, object, name=None, *args):\n        \"\"\"Raise an exception for unimplemented types.\"\"\"\n        message = \"don't know how to document object%s of type %s\" % (\n            name and ' ' + repr(name), type(object).__name__)\n        raise TypeError(message)\n\n    docmodule = docclass = docroutine = docother = docproperty = docdata = fail\n\n    def getdocloc(self, object, basedir=sysconfig.get_path('stdlib')):\n        \"\"\"Return the location of module docs or None\"\"\"\n\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n\n        docloc = os.environ.get(\"PYTHONDOCS\", self.PYTHONDOCS)\n\n        basedir = os.path.normcase(basedir)\n        if (isinstance(object, type(os)) and\n            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',\n                                 'marshal', 'posix', 'signal', 'sys',\n                                 '_thread', 'zipimport') or\n             (file.startswith(basedir) and\n              not file.startswith(os.path.join(basedir, 'site-packages')))) and\n            object.__name__ not in ('xml.etree', 'test.pydoc_mod')):\n            if docloc.startswith((\"http://\", \"https://\")):\n                docloc = \"{}/{}.html\".format(docloc.rstrip(\"/\"), object.__name__.lower())\n            else:\n                docloc = os.path.join(docloc, object.__name__.lower() + \".html\")\n        else:\n            docloc = None\n        return docloc\n\n# -------------------------------------------- HTML documentation generator\n\nclass HTMLRepr(Repr):\n    \"\"\"Class for safely making an HTML representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def escape(self, text):\n        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')\n\n    def repr(self, object):\n        return Repr.repr(self, object)\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return self.escape(cram(stripid(repr(x)), self.maxother))\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + self.escape(test) + testrepr[0]\n        return re.sub(r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)',\n                      r'<font color=\"#c040c0\">\\1</font>',\n                      self.escape(testrepr))\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return self.escape(cram(stripid(repr(x)), self.maxstring))\n        except:\n            return self.escape('<%s instance>' % x.__class__.__name__)\n\n    repr_unicode = repr_string\n\nclass HTMLDoc(Doc):\n    \"\"\"Formatter class for HTML documentation.\"\"\"\n\n    # ------------------------------------------- HTML formatting utilities\n\n    _repr_instance = HTMLRepr()\n    repr = _repr_instance.repr\n    escape = _repr_instance.escape\n\n    def page(self, title, contents):\n        \"\"\"Format an HTML page.\"\"\"\n        return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Python: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head><body bgcolor=\"#f0f0f8\">\n%s\n</body></html>''' % (title, contents)\n\n    def heading(self, title, fgcol, bgcol, extras=''):\n        \"\"\"Format a page heading.\"\"\"\n        return '''\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"%s\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">&nbsp;<br>%s</font></td\n><td align=right valign=bottom\n><font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr></table>\n    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')\n\n    def section(self, title, fgcol, bgcol, contents, width=6,\n                prelude='', marginalia=None, gap='&nbsp;'):\n        \"\"\"Format a section with a heading.\"\"\"\n        if marginalia is None:\n            marginalia = '<tt>' + '&nbsp;' * width + '</tt>'\n        result = '''<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"%s\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr>\n    ''' % (bgcol, fgcol, title)\n        if prelude:\n            result = result + '''\n<tr bgcolor=\"%s\"><td rowspan=2>%s</td>\n<td colspan=2>%s</td></tr>\n<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)\n        else:\n            result = result + '''\n<tr><td bgcolor=\"%s\">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)\n\n        return result + '\\n<td width=\"100%%\">%s</td></tr></table>' % contents\n\n    def bigsection(self, title, *args):\n        \"\"\"Format a section with a big heading.\"\"\"\n        title = '<big><strong>%s</strong></big>' % title\n        return self.section(title, *args)\n\n    def preformat(self, text):\n        \"\"\"Format literal preformatted text.\"\"\"\n        text = self.escape(text.expandtabs())\n        return replace(text, '\\n\\n', '\\n \\n', '\\n\\n', '\\n \\n',\n                             ' ', '&nbsp;', '\\n', '<br>\\n')\n\n    def multicolumn(self, list, format, cols=4):\n        \"\"\"Format a list of items into a multi-column list.\"\"\"\n        result = ''\n        rows = (len(list)+cols-1)//cols\n        for col in range(cols):\n            result = result + '<td width=\"%d%%\" valign=top>' % (100//cols)\n            for i in range(rows*col, rows*col+rows):\n                if i < len(list):\n                    result = result + format(list[i]) + '<br>\\n'\n            result = result + '</td>'\n        return '<table width=\"100%%\" summary=\"list\"><tr>%s</tr></table>' % result\n\n    def grey(self, text): return '<font color=\"#909090\">%s</font>' % text\n\n    def namelink(self, name, *dicts):\n        \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\"\n        for dict in dicts:\n            if name in dict:\n                return '<a href=\"%s\">%s</a>' % (dict[name], name)\n        return name\n\n    def classlink(self, object, modname):\n        \"\"\"Make a link for a class.\"\"\"\n        name, module = object.__name__, sys.modules.get(object.__module__)\n        if hasattr(module, name) and getattr(module, name) is object:\n            return '<a href=\"%s.html#%s\">%s</a>' % (\n                module.__name__, name, classname(object, modname))\n        return classname(object, modname)\n\n    def modulelink(self, object):\n        \"\"\"Make a link for a module.\"\"\"\n        return '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n\n    def modpkglink(self, modpkginfo):\n        \"\"\"Make a link for a module or package to display in an index.\"\"\"\n        name, path, ispackage, shadowed = modpkginfo\n        if shadowed:\n            return self.grey(name)\n        if path:\n            url = '%s.%s.html' % (path, name)\n        else:\n            url = '%s.html' % name\n        if ispackage:\n            text = '<strong>%s</strong>&nbsp;(package)' % name\n        else:\n            text = name\n        return '<a href=\"%s\">%s</a>' % (url, text)\n\n    def filelink(self, url, path):\n        \"\"\"Make a link to source file.\"\"\"\n        return '<a href=\"file:%s\">%s</a>' % (url, path)\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n        pattern = re.compile(r'\\b((http|https|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?(\\w+))')\n        while True:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif selfdot:\n                # Create a link for methods like 'self.method(...)'\n                # and use <strong> for attributes like 'self.attr'\n                if text[end:end+1] == '(':\n                    results.append('self.' + self.namelink(name, methods))\n                else:\n                    results.append('self.<strong>%s</strong>' % name)\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None):\n        \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + '<dt><font face=\"helvetica, arial\">'\n                result = result + self.classlink(c, modname)\n                if bases and bases != (parent,):\n                    parents = []\n                    for base in bases:\n                        parents.append(self.classlink(base, modname))\n                    result = result + '(' + ', '.join(parents) + ')'\n                result = result + '\\n</font></dt>'\n            elif type(entry) is type([]):\n                result = result + '<dd>\\n%s</dd>\\n' % self.formattree(\n                    entry, modname, c)\n        return '<dl>\\n%s</dl>\\n' % result\n\n    def docmodule(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        try:\n            all = object.__all__\n        except AttributeError:\n            all = None\n        parts = name.split('.')\n        links = []\n        for i in range(len(parts)-1):\n            links.append(\n                '<a href=\"%s.html\"><font color=\"#ffffff\">%s</font></a>' %\n                ('.'.join(parts[:i+1]), parts[i]))\n        linkedname = '.'.join(links + parts[-1:])\n        head = '<big><big><strong>%s</strong></big></big>' % linkedname\n        try:\n            path = inspect.getabsfile(object)\n            url = urllib.parse.quote(path)\n            filelink = self.filelink(url, path)\n        except TypeError:\n            filelink = '(built-in)'\n        info = []\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            info.append('version %s' % self.escape(version))\n        if hasattr(object, '__date__'):\n            info.append(self.escape(str(object.__date__)))\n        if info:\n            head = head + ' (%s)' % ', '.join(info)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            docloc = '<br><a href=\"%(docloc)s\">Module Reference</a>' % locals()\n        else:\n            docloc = ''\n        result = self.heading(\n            head, '#ffffff', '#7799ee',\n            '<a href=\".\">index</a><br>' + filelink + docloc)\n\n        modules = inspect.getmembers(object, inspect.ismodule)\n\n        classes, cdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n                    cdict[key] = cdict[value] = '#' + key\n        for key, value in classes:\n            for base in value.__bases__:\n                key, modname = base.__name__, base.__module__\n                module = sys.modules.get(modname)\n                if modname != name and module and hasattr(module, key):\n                    if getattr(module, key) is base:\n                        if not key in cdict:\n                            cdict[key] = cdict[base] = modname + '.html#' + key\n        funcs, fdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n                    fdict[key] = '#-' + key\n                    if inspect.isfunction(value): fdict[value] = fdict[key]\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        doc = self.markup(getdoc(object), self.preformat, fdict, cdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        if hasattr(object, '__path__'):\n            modpkgs = []\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs.append((modname, name, ispkg, 0))\n            modpkgs.sort()\n            contents = self.multicolumn(modpkgs, self.modpkglink)\n            result = result + self.bigsection(\n                'Package Contents', '#ffffff', '#aa55cc', contents)\n        elif modules:\n            contents = self.multicolumn(\n                modules, lambda t: self.modulelink(t[1]))\n            result = result + self.bigsection(\n                'Modules', '#ffffff', '#aa55cc', contents)\n\n        if classes:\n            classlist = [value for (key, value) in classes]\n            contents = [\n                self.formattree(inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Classes', '#ffffff', '#ee77aa', ' '.join(contents))\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Functions', '#ffffff', '#eeaa77', ' '.join(contents))\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.document(value, key))\n            result = result + self.bigsection(\n                'Data', '#ffffff', '#55aa55', '<br>\\n'.join(contents))\n        if hasattr(object, '__author__'):\n            contents = self.markup(str(object.__author__), self.preformat)\n            result = result + self.bigsection(\n                'Author', '#ffffff', '#7799ee', contents)\n        if hasattr(object, '__credits__'):\n            contents = self.markup(str(object.__credits__), self.preformat)\n            result = result + self.bigsection(\n                'Credits', '#ffffff', '#7799ee', contents)\n\n        return result\n\n    def docclass(self, object, name=None, mod=None, funcs={}, classes={},\n                 *ignored):\n        \"\"\"Produce HTML documentation for a class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        contents = []\n        push = contents.append\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('<hr>\\n')\n                self.needone = 1\n        hr = HorizontalRule()\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            hr.maybe()\n            push('<dl><dt>Method resolution order:</dt>\\n')\n            for base in mro:\n                push('<dd>%s</dd>\\n' % self.classlink(base,\n                                                      object.__module__))\n            push('</dl>\\n')\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value, name, mod,\n                                        funcs, classes, mdict, object))\n                    push('\\n')\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    base = self.docother(getattr(object, name), name, mod)\n                    doc = getdoc(value)\n                    if not doc:\n                        push('<dl><dt>%s</dl>\\n' % base)\n                    else:\n                        doc = self.markup(getdoc(value), self.preformat,\n                                          funcs, classes, mdict)\n                        doc = '<dd><tt>%s</tt>' % doc\n                        push('<dl><dt>%s%s</dl>\\n' % (base, doc))\n                    push('\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        mdict = {}\n        for key, kind, homecls, value in attrs:\n            mdict[key] = anchor = '#' + name + '-' + key\n            try:\n                value = getattr(object, name)\n            except Exception:\n                # Some descriptors may meet a failure in their __get__.\n                # (bug #1785)\n                pass\n            try:\n                # The value may not be hashable (e.g., a data attr with\n                # a dict or list value).\n                mdict[value] = anchor\n            except TypeError:\n                pass\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = 'defined here'\n            else:\n                tag = 'inherited from %s' % self.classlink(thisclass,\n                                                           object.__module__)\n            tag += ':<br>\\n'\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill('Methods %s' % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill('Class methods %s' % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill('Static methods %s' % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata('Data and other attributes %s' % tag, attrs,\n                              lambda t: t[1] == 'data')\n            assert attrs == []\n            attrs = inherited\n\n        contents = ''.join(contents)\n\n        if name == realname:\n            title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n                name, realname)\n        else:\n            title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n                name, name, realname)\n        if bases:\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, object.__module__))\n            title = title + '(%s)' % ', '.join(parents)\n\n        decl = ''\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                decl = name + self.escape(argspec) + '\\n\\n'\n\n        doc = getdoc(object)\n        if decl:\n            doc = decl + (doc or '')\n        doc = self.markup(doc, self.preformat, funcs, classes, mdict)\n        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n\n        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return self.grey('=' + self.repr(object))\n\n    def docroutine(self, object, name=None, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + self.classlink(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % self.classlink(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % self.classlink(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = '<a name=\"%s\"><strong>%s</strong></a>' % (anchor, realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                reallink = '<a href=\"#%s\">%s</a>' % (\n                    cl.__name__ + '-' + realname, realname)\n                skipdocs = 1\n            else:\n                reallink = realname\n            title = '<a name=\"%s\"><strong>%s</strong></a> = %s' % (\n                anchor, name, reallink)\n        argspec = None\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = '<strong>%s</strong> <em>lambda</em> ' % name\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n\n        decl = asyncqualifier + title + self.escape(argspec) + (note and\n               self.grey('<font face=\"helvetica, arial\">%s</font>' % note))\n\n        if skipdocs:\n            return '<dl><dt>%s</dt></dl>\\n' % decl\n        else:\n            doc = self.markup(\n                getdoc(object), self.preformat, funcs, classes, methods)\n            doc = doc and '<dd><tt>%s</tt></dd>' % doc\n            return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce html documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push('<dl><dt><strong>%s</strong></dt>\\n' % name)\n        doc = self.markup(getdoc(object), self.preformat)\n        if doc:\n            push('<dd><tt>%s</tt></dd>\\n' % doc)\n        push('</dl>\\n')\n\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a data object.\"\"\"\n        lhs = name and '<strong>%s</strong> = ' % name or ''\n        return lhs + self.repr(object)\n\n    def index(self, dir, shadowed=None):\n        \"\"\"Generate an HTML index for a directory of modules.\"\"\"\n        modpkgs = []\n        if shadowed is None: shadowed = {}\n        for importer, name, ispkg in pkgutil.iter_modules([dir]):\n            if any((0xD800 <= ord(ch) <= 0xDFFF) for ch in name):\n                # ignore a module if its name contains a surrogate character\n                continue\n            modpkgs.append((name, '', ispkg, name in shadowed))\n            shadowed[name] = 1\n\n        modpkgs.sort()\n        contents = self.multicolumn(modpkgs, self.modpkglink)\n        return self.bigsection(dir, '#ffffff', '#ee77aa', contents)\n\n# -------------------------------------------- text documentation generator\n\nclass TextRepr(Repr):\n    \"\"\"Class for safely making a text representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return cram(stripid(repr(x)), self.maxother)\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + test + testrepr[0]\n        return testrepr\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return cram(stripid(repr(x)), self.maxstring)\n        except:\n            return '<%s instance>' % x.__class__.__name__\n\nclass TextDoc(Doc):\n    \"\"\"Formatter class for text documentation.\"\"\"\n\n    # ------------------------------------------- text formatting utilities\n\n    _repr_instance = TextRepr()\n    repr = _repr_instance.repr\n\n    def bold(self, text):\n        \"\"\"Format a string in bold by overstriking.\"\"\"\n        return ''.join(ch + '\\b' + ch for ch in text)\n\n    def indent(self, text, prefix='    '):\n        \"\"\"Indent text by prepending a given prefix to each line.\"\"\"\n        if not text: return ''\n        lines = [prefix + line for line in text.split('\\n')]\n        if lines: lines[-1] = lines[-1].rstrip()\n        return '\\n'.join(lines)\n\n    def section(self, title, contents):\n        \"\"\"Format a section with a given heading.\"\"\"\n        clean_contents = self.indent(contents).rstrip()\n        return self.bold(title) + '\\n' + clean_contents + '\\n\\n'\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None, prefix=''):\n        \"\"\"Render in text a class tree as returned by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + prefix + classname(c, modname)\n                if bases and bases != (parent,):\n                    parents = (classname(c, modname) for c in bases)\n                    result = result + '(%s)' % ', '.join(parents)\n                result = result + '\\n'\n            elif type(entry) is type([]):\n                result = result + self.formattree(\n                    entry, modname, c, prefix + '    ')\n        return result\n\n    def docmodule(self, object, name=None, mod=None):\n        \"\"\"Produce text documentation for a given module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        synop, desc = splitdoc(getdoc(object))\n        result = self.section('NAME', name + (synop and ' - ' + synop))\n        all = getattr(object, '__all__', None)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            result = result + self.section('MODULE REFERENCE', docloc + \"\"\"\n\nThe following documentation is automatically generated from the Python\nsource files.  It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations.  When in doubt, consult the module reference at the\nlocation listed above.\n\"\"\")\n\n        if desc:\n            result = result + self.section('DESCRIPTION', desc)\n\n        classes = []\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None\n                or (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n        funcs = []\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        modpkgs = []\n        modpkgs_names = set()\n        if hasattr(object, '__path__'):\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs_names.add(modname)\n                if ispkg:\n                    modpkgs.append(modname + ' (package)')\n                else:\n                    modpkgs.append(modname)\n\n            modpkgs.sort()\n            result = result + self.section(\n                'PACKAGE CONTENTS', '\\n'.join(modpkgs))\n\n        # Detect submodules as sometimes created by C extensions\n        submodules = []\n        for key, value in inspect.getmembers(object, inspect.ismodule):\n            if value.__name__.startswith(name + '.') and key not in modpkgs_names:\n                submodules.append(key)\n        if submodules:\n            submodules.sort()\n            result = result + self.section(\n                'SUBMODULES', '\\n'.join(submodules))\n\n        if classes:\n            classlist = [value for key, value in classes]\n            contents = [self.formattree(\n                inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('CLASSES', '\\n'.join(contents))\n\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('FUNCTIONS', '\\n'.join(contents))\n\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.docother(value, key, name, maxlen=70))\n            result = result + self.section('DATA', '\\n'.join(contents))\n\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            result = result + self.section('VERSION', version)\n        if hasattr(object, '__date__'):\n            result = result + self.section('DATE', str(object.__date__))\n        if hasattr(object, '__author__'):\n            result = result + self.section('AUTHOR', str(object.__author__))\n        if hasattr(object, '__credits__'):\n            result = result + self.section('CREDITS', str(object.__credits__))\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n        result = result + self.section('FILE', file)\n        return result\n\n    def docclass(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce text documentation for a given class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        def makename(c, m=object.__module__):\n            return classname(c, m)\n\n        if name == realname:\n            title = 'class ' + self.bold(realname)\n        else:\n            title = self.bold(name) + ' = class ' + realname\n        if bases:\n            parents = map(makename, bases)\n            title = title + '(%s)' % ', '.join(parents)\n\n        contents = []\n        push = contents.append\n\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                push(name + argspec + '\\n')\n\n        doc = getdoc(object)\n        if doc:\n            push(doc + '\\n')\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            push(\"Method resolution order:\")\n            for base in mro:\n                push('    ' + makename(base))\n            push('')\n\n        # List the built-in subclasses, if any:\n        subclasses = sorted(\n            (str(cls.__name__) for cls in type.__subclasses__(object)\n             if not cls.__name__.startswith(\"_\") and cls.__module__ == \"builtins\"),\n            key=str.lower\n        )\n        no_of_subclasses = len(subclasses)\n        MAX_SUBCLASSES_TO_DISPLAY = 4\n        if subclasses:\n            push(\"Built-in subclasses:\")\n            for subclassname in subclasses[:MAX_SUBCLASSES_TO_DISPLAY]:\n                push('    ' + subclassname)\n            if no_of_subclasses > MAX_SUBCLASSES_TO_DISPLAY:\n                push('    ... and ' +\n                     str(no_of_subclasses - MAX_SUBCLASSES_TO_DISPLAY) +\n                     ' other subclasses')\n            push('')\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('-' * 70)\n                self.needone = 1\n        hr = HorizontalRule()\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value,\n                                        name, mod, object))\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    doc = getdoc(value)\n                    try:\n                        obj = getattr(object, name)\n                    except AttributeError:\n                        obj = homecls.__dict__[name]\n                    push(self.docother(obj, name, mod, maxlen=70, doc=doc) +\n                         '\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = \"defined here\"\n            else:\n                tag = \"inherited from %s\" % classname(thisclass,\n                                                      object.__module__)\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill(\"Methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill(\"Class methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill(\"Static methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors(\"Data descriptors %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata(\"Data and other attributes %s:\\n\" % tag, attrs,\n                              lambda t: t[1] == 'data')\n\n            assert attrs == []\n            attrs = inherited\n\n        contents = '\\n'.join(contents)\n        if not contents:\n            return title + '\\n'\n        return title + '\\n' + self.indent(contents.rstrip(), ' |  ') + '\\n'\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return '=' + self.repr(object)\n\n    def docroutine(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + classname(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % classname(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % classname(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = self.bold(realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                skipdocs = 1\n            title = self.bold(name) + ' = ' + realname\n        argspec = None\n\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = self.bold(name) + ' lambda '\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n        decl = asyncqualifier + title + argspec + note\n\n        if skipdocs:\n            return decl + '\\n'\n        else:\n            doc = getdoc(object) or ''\n            return decl + '\\n' + (doc and self.indent(doc).rstrip() + '\\n')\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push(self.bold(name))\n            push('\\n')\n        doc = getdoc(object) or ''\n        if doc:\n            push(self.indent(doc))\n            push('\\n')\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):\n        \"\"\"Produce text documentation for a data object.\"\"\"\n        repr = self.repr(object)\n        if maxlen:\n            line = (name and name + ' = ' or '') + repr\n            chop = maxlen - len(line)\n            if chop < 0: repr = repr[:chop] + '...'\n        line = (name and self.bold(name) + ' = ' or '') + repr\n        if not doc:\n            doc = getdoc(object)\n        if doc:\n            line += '\\n' + self.indent(str(doc)) + '\\n'\n        return line\n\nclass _PlainTextDoc(TextDoc):\n    \"\"\"Subclass of TextDoc which overrides string styling\"\"\"\n    def bold(self, text):\n        return text\n\n# --------------------------------------------------------- user interfaces\n\ndef pager(text):\n    \"\"\"The first time this is called, determine what kind of pager to use.\"\"\"\n    global pager\n    pager = getpager()\n    pager(text)\n\ndef getpager():\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    if not hasattr(sys.stdin, \"isatty\"):\n        return plainpager\n    if not hasattr(sys.stdout, \"isatty\"):\n        return plainpager\n    if not sys.stdin.isatty() or not sys.stdout.isatty():\n        return plainpager\n    use_pager = os.environ.get('MANPAGER') or os.environ.get('PAGER')\n    if use_pager:\n        if sys.platform == 'win32': # pipes completely broken in Windows\n            return lambda text: tempfilepager(plain(text), use_pager)\n        elif os.environ.get('TERM') in ('dumb', 'emacs'):\n            return lambda text: pipepager(plain(text), use_pager)\n        else:\n            return lambda text: pipepager(text, use_pager)\n    if os.environ.get('TERM') in ('dumb', 'emacs'):\n        return plainpager\n    if sys.platform == 'win32':\n        return lambda text: tempfilepager(plain(text), 'more <')\n    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n        return lambda text: pipepager(text, 'less')\n\n    import tempfile\n    (fd, filename) = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n            return lambda text: pipepager(text, 'more')\n        else:\n            return ttypager\n    finally:\n        os.unlink(filename)\n\ndef plain(text):\n    \"\"\"Remove boldface formatting from text.\"\"\"\n    return re.sub('.\\b', '', text)\n\ndef pipepager(text, cmd):\n    \"\"\"Page through text by feeding it to another program.\"\"\"\n    import subprocess\n    proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE)\n    try:\n        with io.TextIOWrapper(proc.stdin, errors='backslashreplace') as pipe:\n            try:\n                pipe.write(text)\n            except KeyboardInterrupt:\n                # We've hereby abandoned whatever text hasn't been written,\n                # but the pager is still in control of the terminal.\n                pass\n    except OSError:\n        pass # Ignore broken pipes caused by quitting the pager program.\n    while True:\n        try:\n            proc.wait()\n            break\n        except KeyboardInterrupt:\n            # Ignore ctl-c like the pager itself does.  Otherwise the pager is\n            # left running and the terminal is in raw mode and unusable.\n            pass\n\ndef tempfilepager(text, cmd):\n    \"\"\"Page through text by invoking a program on a temporary file.\"\"\"\n    import tempfile\n    filename = tempfile.mktemp()\n    with open(filename, 'w', errors='backslashreplace') as file:\n        file.write(text)\n    try:\n        os.system(cmd + ' \"' + filename + '\"')\n    finally:\n        os.unlink(filename)\n\ndef _escape_stdout(text):\n    # Escape non-encodable characters to avoid encoding errors later\n    encoding = getattr(sys.stdout, 'encoding', None) or 'utf-8'\n    return text.encode(encoding, 'backslashreplace').decode(encoding)\n\ndef ttypager(text):\n    \"\"\"Page through text on a text terminal.\"\"\"\n    lines = plain(_escape_stdout(text)).split('\\n')\n    try:\n        import tty\n        fd = sys.stdin.fileno()\n        old = tty.tcgetattr(fd)\n        tty.setcbreak(fd)\n        getchar = lambda: sys.stdin.read(1)\n    except (ImportError, AttributeError, io.UnsupportedOperation):\n        tty = None\n        getchar = lambda: sys.stdin.readline()[:-1][:1]\n\n    try:\n        try:\n            h = int(os.environ.get('LINES', 0))\n        except ValueError:\n            h = 0\n        if h <= 1:\n            h = 25\n        r = inc = h - 1\n        sys.stdout.write('\\n'.join(lines[:inc]) + '\\n')\n        while lines[r:]:\n            sys.stdout.write('-- more --')\n            sys.stdout.flush()\n            c = getchar()\n\n            if c in ('q', 'Q'):\n                sys.stdout.write('\\r          \\r')\n                break\n            elif c in ('\\r', '\\n'):\n                sys.stdout.write('\\r          \\r' + lines[r] + '\\n')\n                r = r + 1\n                continue\n            if c in ('b', 'B', '\\x1b'):\n                r = r - inc - inc\n                if r < 0: r = 0\n            sys.stdout.write('\\n' + '\\n'.join(lines[r:r+inc]) + '\\n')\n            r = r + inc\n\n    finally:\n        if tty:\n            tty.tcsetattr(fd, tty.TCSAFLUSH, old)\n\ndef plainpager(text):\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    sys.stdout.write(plain(_escape_stdout(text)))\n\ndef describe(thing):\n    \"\"\"Produce a short description of the given thing.\"\"\"\n    if inspect.ismodule(thing):\n        if thing.__name__ in sys.builtin_module_names:\n            return 'built-in module ' + thing.__name__\n        if hasattr(thing, '__path__'):\n            return 'package ' + thing.__name__\n        else:\n            return 'module ' + thing.__name__\n    if inspect.isbuiltin(thing):\n        return 'built-in function ' + thing.__name__\n    if inspect.isgetsetdescriptor(thing):\n        return 'getset descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.ismemberdescriptor(thing):\n        return 'member descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.isclass(thing):\n        return 'class ' + thing.__name__\n    if inspect.isfunction(thing):\n        return 'function ' + thing.__name__\n    if inspect.ismethod(thing):\n        return 'method ' + thing.__name__\n    return type(thing).__name__\n\ndef locate(path, forceload=0):\n    \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\"\n    parts = [part for part in path.split('.') if part]\n    module, n = None, 0\n    while n < len(parts):\n        nextmodule = safeimport('.'.join(parts[:n+1]), forceload)\n        if nextmodule: module, n = nextmodule, n + 1\n        else: break\n    if module:\n        object = module\n    else:\n        object = builtins\n    for part in parts[n:]:\n        try:\n            object = getattr(object, part)\n        except AttributeError:\n            return None\n    return object\n\n# --------------------------------------- interactive interpreter interface\n\ntext = TextDoc()\nplaintext = _PlainTextDoc()\nhtml = HTMLDoc()\n\ndef resolve(thing, forceload=0):\n    \"\"\"Given an object or a path to an object, get the object and its name.\"\"\"\n    if isinstance(thing, str):\n        object = locate(thing, forceload)\n        if object is None:\n            raise ImportError('''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.''' % thing)\n        return object, thing\n    else:\n        name = getattr(thing, '__name__', None)\n        return thing, name if isinstance(name, str) else None\n\ndef render_doc(thing, title='Python Library Documentation: %s', forceload=0,\n        renderer=None):\n    \"\"\"Render text documentation, given an object or a path to an object.\"\"\"\n    if renderer is None:\n        renderer = text\n    object, name = resolve(thing, forceload)\n    desc = describe(object)\n    module = inspect.getmodule(object)\n    if name and '.' in name:\n        desc += ' in ' + name[:name.rfind('.')]\n    elif module and module is not object:\n        desc += ' in module ' + module.__name__\n\n    if not (inspect.ismodule(object) or\n              inspect.isclass(object) or\n              inspect.isroutine(object) or\n              inspect.isdatadescriptor(object) or\n              _getdoc(object)):\n        # If the passed object is a piece of data or an instance,\n        # document its available methods instead of its value.\n        if hasattr(object, '__origin__'):\n            object = object.__origin__\n        else:\n            object = type(object)\n            desc += ' object'\n    return title % desc + '\\n\\n' + renderer.document(object, name)\n\ndef doc(thing, title='Python Library Documentation: %s', forceload=0,\n        output=None):\n    \"\"\"Display text documentation, given an object or a path to an object.\"\"\"\n    try:\n        if output is None:\n            pager(render_doc(thing, title, forceload))\n        else:\n            output.write(render_doc(thing, title, forceload, plaintext))\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)\n\ndef writedoc(thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\"\"\"\n    try:\n        object, name = resolve(thing, forceload)\n        page = html.page(describe(object), html.document(object, name))\n        with open(name + '.html', 'w', encoding='utf-8') as file:\n            file.write(page)\n        print('wrote', name + '.html')\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)\n\ndef writedocs(dir, pkgpath='', done=None):\n    \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\"\n    if done is None: done = {}\n    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):\n        writedoc(modname)\n    return\n\nclass Helper:\n\n    # These dictionaries map a topic name to either an alias, or a tuple\n    # (label, seealso-items).  The \"label\" is the label of the corresponding\n    # section in the .rst file under Doc/ and an index into the dictionary\n    # in pydoc_data/topics.py.\n    #\n    # CAUTION: if you change one of these dictionaries, be sure to adapt the\n    #          list of needed labels in Doc/tools/extensions/pyspecific.py and\n    #          regenerate the pydoc_data/topics.py file by running\n    #              make pydoc-topics\n    #          in Doc/ and copying the output file into the Lib/ directory.\n\n    keywords = {\n        'False': '',\n        'None': '',\n        'True': '',\n        'and': 'BOOLEAN',\n        'as': 'with',\n        'assert': ('assert', ''),\n        'async': ('async', ''),\n        'await': ('await', ''),\n        'break': ('break', 'while for'),\n        'class': ('class', 'CLASSES SPECIALMETHODS'),\n        'continue': ('continue', 'while for'),\n        'def': ('function', ''),\n        'del': ('del', 'BASICMETHODS'),\n        'elif': 'if',\n        'else': ('else', 'while for'),\n        'except': 'try',\n        'finally': 'try',\n        'for': ('for', 'break continue while'),\n        'from': 'import',\n        'global': ('global', 'nonlocal NAMESPACES'),\n        'if': ('if', 'TRUTHVALUE'),\n        'import': ('import', 'MODULES'),\n        'in': ('in', 'SEQUENCEMETHODS'),\n        'is': 'COMPARISON',\n        'lambda': ('lambda', 'FUNCTIONS'),\n        'nonlocal': ('nonlocal', 'global NAMESPACES'),\n        'not': 'BOOLEAN',\n        'or': 'BOOLEAN',\n        'pass': ('pass', ''),\n        'raise': ('raise', 'EXCEPTIONS'),\n        'return': ('return', 'FUNCTIONS'),\n        'try': ('try', 'EXCEPTIONS'),\n        'while': ('while', 'break continue if TRUTHVALUE'),\n        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),\n        'yield': ('yield', ''),\n    }\n    # Either add symbols to this dictionary or to the symbols dictionary\n    # directly: Whichever is easier. They are merged later.\n    _strprefixes = [p + q for p in ('b', 'f', 'r', 'u') for q in (\"'\", '\"')]\n    _symbols_inverse = {\n        'STRINGS' : (\"'\", \"'''\", '\"', '\"\"\"', *_strprefixes),\n        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',\n                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),\n        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),\n        'UNARY' : ('-', '~'),\n        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',\n                                '^=', '<<=', '>>=', '**=', '//='),\n        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),\n        'COMPLEX' : ('j', 'J')\n    }\n    symbols = {\n        '%': 'OPERATORS FORMATTING',\n        '**': 'POWER',\n        ',': 'TUPLES LISTS FUNCTIONS',\n        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',\n        '...': 'ELLIPSIS',\n        ':': 'SLICINGS DICTIONARYLITERALS',\n        '@': 'def class',\n        '\\\\': 'STRINGS',\n        '_': 'PRIVATENAMES',\n        '__': 'PRIVATENAMES SPECIALMETHODS',\n        '`': 'BACKQUOTES',\n        '(': 'TUPLES FUNCTIONS CALLS',\n        ')': 'TUPLES FUNCTIONS CALLS',\n        '[': 'LISTS SUBSCRIPTS SLICINGS',\n        ']': 'LISTS SUBSCRIPTS SLICINGS'\n    }\n    for topic, symbols_ in _symbols_inverse.items():\n        for symbol in symbols_:\n            topics = symbols.get(symbol, topic)\n            if topic not in topics:\n                topics = topics + ' ' + topic\n            symbols[symbol] = topics\n\n    topics = {\n        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '\n                  'FUNCTIONS CLASSES MODULES FILES inspect'),\n        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),\n        'FORMATTING': ('formatstrings', 'OPERATORS'),\n        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),\n        'INTEGER': ('integers', 'int range'),\n        'FLOAT': ('floating', 'float math'),\n        'COMPLEX': ('imaginary', 'complex cmath'),\n        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING range LISTS'),\n        'MAPPINGS': 'DICTIONARIES',\n        'FUNCTIONS': ('typesfunctions', 'def TYPES'),\n        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),\n        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),\n        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),\n        'FRAMEOBJECTS': 'TYPES',\n        'TRACEBACKS': 'TYPES',\n        'NONE': ('bltin-null-object', ''),\n        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),\n        'SPECIALATTRIBUTES': ('specialattrs', ''),\n        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),\n        'MODULES': ('typesmodules', 'import'),\n        'PACKAGES': 'import',\n        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '\n                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '\n                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '\n                        'LISTS DICTIONARIES'),\n        'OPERATORS': 'EXPRESSIONS',\n        'PRECEDENCE': 'EXPRESSIONS',\n        'OBJECTS': ('objects', 'TYPES'),\n        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '\n                           'CALLABLEMETHODS SEQUENCEMETHODS MAPPINGMETHODS '\n                           'NUMBERMETHODS CLASSES'),\n        'BASICMETHODS': ('customization', 'hash repr str SPECIALMETHODS'),\n        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),\n        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),\n        'SEQUENCEMETHODS': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS '\n                             'SPECIALMETHODS'),\n        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),\n        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '\n                          'SPECIALMETHODS'),\n        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),\n        'NAMESPACES': ('naming', 'global nonlocal ASSIGNMENT DELETION DYNAMICFEATURES'),\n        'DYNAMICFEATURES': ('dynamic-features', ''),\n        'SCOPING': 'NAMESPACES',\n        'FRAMES': 'NAMESPACES',\n        'EXCEPTIONS': ('exceptions', 'try except finally raise'),\n        'CONVERSIONS': ('conversions', ''),\n        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),\n        'SPECIALIDENTIFIERS': ('id-classes', ''),\n        'PRIVATENAMES': ('atom-identifiers', ''),\n        'LITERALS': ('atom-literals', 'STRINGS NUMBERS TUPLELITERALS '\n                     'LISTLITERALS DICTIONARYLITERALS'),\n        'TUPLES': 'SEQUENCES',\n        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),\n        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),\n        'LISTLITERALS': ('lists', 'LISTS LITERALS'),\n        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),\n        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),\n        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr ATTRIBUTEMETHODS'),\n        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS'),\n        'SLICINGS': ('slicings', 'SEQUENCEMETHODS'),\n        'CALLS': ('calls', 'EXPRESSIONS'),\n        'POWER': ('power', 'EXPRESSIONS'),\n        'UNARY': ('unary', 'EXPRESSIONS'),\n        'BINARY': ('binary', 'EXPRESSIONS'),\n        'SHIFTING': ('shifting', 'EXPRESSIONS'),\n        'BITWISE': ('bitwise', 'EXPRESSIONS'),\n        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),\n        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),\n        'ASSERTION': 'assert',\n        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),\n        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),\n        'DELETION': 'del',\n        'RETURNING': 'return',\n        'IMPORTING': 'import',\n        'CONDITIONAL': 'if',\n        'LOOPING': ('compound', 'for while break continue'),\n        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),\n        'DEBUGGING': ('debugger', 'pdb'),\n        'CONTEXTMANAGERS': ('context-managers', 'with'),\n    }\n\n    def __init__(self, input=None, output=None):\n        self._input = input\n        self._output = output\n\n    @property\n    def input(self):\n        return self._input or sys.stdin\n\n    @property\n    def output(self):\n        return self._output or sys.stdout\n\n    def __repr__(self):\n        if inspect.stack()[1][3] == '?':\n            self()\n            return ''\n        return '<%s.%s instance>' % (self.__class__.__module__,\n                                     self.__class__.__qualname__)\n\n    _GoInteractive = object()\n    def __call__(self, request=_GoInteractive):\n        if request is not self._GoInteractive:\n            self.help(request)\n        else:\n            self.intro()\n            self.interact()\n            self.output.write('''\nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help> prompt.\n''')\n\n    def interact(self):\n        self.output.write('\\n')\n        while True:\n            try:\n                request = self.getline('help> ')\n                if not request: break\n            except (KeyboardInterrupt, EOFError):\n                break\n            request = request.strip()\n\n            # Make sure significant trailing quoting marks of literals don't\n            # get deleted while cleaning input\n            if (len(request) > 2 and request[0] == request[-1] in (\"'\", '\"')\n                    and request[0] not in request[1:-1]):\n                request = request[1:-1]\n            if request.lower() in ('q', 'quit'): break\n            if request == 'help':\n                self.intro()\n            else:\n                self.help(request)\n\n    def getline(self, prompt):\n        \"\"\"Read one line, using input() when appropriate.\"\"\"\n        if self.input is sys.stdin:\n            return input(prompt)\n        else:\n            self.output.write(prompt)\n            self.output.flush()\n            return self.input.readline()\n\n    def help(self, request):\n        if type(request) is type(''):\n            request = request.strip()\n            if request == 'keywords': self.listkeywords()\n            elif request == 'symbols': self.listsymbols()\n            elif request == 'topics': self.listtopics()\n            elif request == 'modules': self.listmodules()\n            elif request[:8] == 'modules ':\n                self.listmodules(request.split()[1])\n            elif request in self.symbols: self.showsymbol(request)\n            elif request in ['True', 'False', 'None']:\n                # special case these keywords since they are objects too\n                doc(eval(request), 'Help on %s:')\n            elif request in self.keywords: self.showtopic(request)\n            elif request in self.topics: self.showtopic(request)\n            elif request: doc(request, 'Help on %s:', output=self._output)\n            else: doc(str, 'Help on %s:', output=self._output)\n        elif isinstance(request, Helper): self()\n        else: doc(request, 'Help on %s:', output=self._output)\n        self.output.write('\\n')\n\n    def intro(self):\n        self.output.write('''\nWelcome to Python {0}'s help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/{0}/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n\"modules\", \"keywords\", \"symbols\", or \"topics\".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as \"spam\", type \"modules spam\".\n'''.format('%d.%d' % sys.version_info[:2]))\n\n    def list(self, items, columns=4, width=80):\n        items = list(sorted(items))\n        colw = width // columns\n        rows = (len(items) + columns - 1) // columns\n        for row in range(rows):\n            for col in range(columns):\n                i = col * rows + row\n                if i < len(items):\n                    self.output.write(items[i])\n                    if col < columns - 1:\n                        self.output.write(' ' + ' ' * (colw - 1 - len(items[i])))\n            self.output.write('\\n')\n\n    def listkeywords(self):\n        self.output.write('''\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\n''')\n        self.list(self.keywords.keys())\n\n    def listsymbols(self):\n        self.output.write('''\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n''')\n        self.list(self.symbols.keys())\n\n    def listtopics(self):\n        self.output.write('''\nHere is a list of available topics.  Enter any topic name to get more help.\n\n''')\n        self.list(self.topics.keys())\n\n    def showtopic(self, topic, more_xrefs=''):\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            self.output.write('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''')\n            return\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        if type(target) is type(''):\n            return self.showtopic(target, more_xrefs)\n\n        label, xrefs = target\n        try:\n            doc = pydoc_data.topics.topics[label]\n        except KeyError:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        doc = doc.strip() + '\\n'\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        if xrefs:\n            import textwrap\n            text = 'Related help topics: ' + ', '.join(xrefs.split()) + '\\n'\n            wrapped_text = textwrap.wrap(text, 72)\n            doc += '\\n%s\\n' % '\\n'.join(wrapped_text)\n        pager(doc)\n\n    def _gettopic(self, topic, more_xrefs=''):\n        \"\"\"Return unbuffered tuple of (topic, xrefs).\n\n        If an error occurs here, the exception is caught and displayed by\n        the url handler.\n\n        This function duplicates the showtopic method but returns its\n        result directly so it can be formatted for display in an html page.\n        \"\"\"\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            return('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''' , '')\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            raise ValueError('could not find topic')\n        if isinstance(target, str):\n            return self._gettopic(target, more_xrefs)\n        label, xrefs = target\n        doc = pydoc_data.topics.topics[label]\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        return doc, xrefs\n\n    def showsymbol(self, symbol):\n        target = self.symbols[symbol]\n        topic, _, xrefs = target.partition(' ')\n        self.showtopic(topic, xrefs)\n\n    def listmodules(self, key=''):\n        if key:\n            self.output.write('''\nHere is a list of modules whose name or summary contains '{}'.\nIf there are any, enter a module name to get more help.\n\n'''.format(key))\n            apropos(key)\n        else:\n            self.output.write('''\nPlease wait a moment while I gather a list of all available modules...\n\n''')\n            modules = {}\n            def callback(path, modname, desc, modules=modules):\n                if modname and modname[-9:] == '.__init__':\n                    modname = modname[:-9] + ' (package)'\n                if modname.find('.') < 0:\n                    modules[modname] = 1\n            def onerror(modname):\n                callback(None, modname, None)\n            ModuleScanner().run(callback, onerror=onerror)\n            self.list(modules.keys())\n            self.output.write('''\nEnter any module name to get more help.  Or, type \"modules spam\" to search\nfor modules whose name or summary contain the string \"spam\".\n''')\n\nhelp = Helper()\n\nclass ModuleScanner:\n    \"\"\"An interruptible scanner that searches module synopses.\"\"\"\n\n    def run(self, callback, key=None, completer=None, onerror=None):\n        if key: key = key.lower()\n        self.quit = False\n        seen = {}\n\n        for modname in sys.builtin_module_names:\n            if modname != '__main__':\n                seen[modname] = 1\n                if key is None:\n                    callback(None, modname, '')\n                else:\n                    name = __import__(modname).__doc__ or ''\n                    desc = name.split('\\n')[0]\n                    name = modname + ' - ' + desc\n                    if name.lower().find(key) >= 0:\n                        callback(None, modname, desc)\n\n        for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):\n            if self.quit:\n                break\n\n            if key is None:\n                callback(None, modname, '')\n            else:\n                try:\n                    spec = pkgutil._get_spec(importer, modname)\n                except SyntaxError:\n                    # raised by tests for bad coding cookies or BOM\n                    continue\n                loader = spec.loader\n                if hasattr(loader, 'get_source'):\n                    try:\n                        source = loader.get_source(modname)\n                    except Exception:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = source_synopsis(io.StringIO(source)) or ''\n                    if hasattr(loader, 'get_filename'):\n                        path = loader.get_filename(modname)\n                    else:\n                        path = None\n                else:\n                    try:\n                        module = importlib._bootstrap._load(spec)\n                    except ImportError:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = module.__doc__.splitlines()[0] if module.__doc__ else ''\n                    path = getattr(module,'__file__',None)\n                name = modname + ' - ' + desc\n                if name.lower().find(key) >= 0:\n                    callback(path, modname, desc)\n\n        if completer:\n            completer()\n\ndef apropos(key):\n    \"\"\"Print all the one-line module summaries that contain a substring.\"\"\"\n    def callback(path, modname, desc):\n        if modname[-9:] == '.__init__':\n            modname = modname[:-9] + ' (package)'\n        print(modname, desc and '- ' + desc)\n    def onerror(modname):\n        pass\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore') # ignore problems during import\n        ModuleScanner().run(callback, key, onerror=onerror)\n\n# --------------------------------------- enhanced Web browser interface\n\ndef _start_server(urlhandler, hostname, port):\n    \"\"\"Start an HTTP server thread on a specific port.\n\n    Start an HTML/text server thread, so HTML or text documents can be\n    browsed dynamically and interactively with a Web browser.  Example use:\n\n        >>> import time\n        >>> import pydoc\n\n        Define a URL handler.  To determine what the client is asking\n        for, check the URL and content_type.\n\n        Then get or generate some text or HTML code and return it.\n\n        >>> def my_url_handler(url, content_type):\n        ...     text = 'the URL sent was: (%s, %s)' % (url, content_type)\n        ...     return text\n\n        Start server thread on port 0.\n        If you use port 0, the server will pick a random port number.\n        You can then use serverthread.port to get the port number.\n\n        >>> port = 0\n        >>> serverthread = pydoc._start_server(my_url_handler, port)\n\n        Check that the server is really started.  If it is, open browser\n        and get first page.  Use serverthread.url as the starting page.\n\n        >>> if serverthread.serving:\n        ...    import webbrowser\n\n        The next two lines are commented out so a browser doesn't open if\n        doctest is run on this module.\n\n        #...    webbrowser.open(serverthread.url)\n        #True\n\n        Let the server do its thing. We just need to monitor its status.\n        Use time.sleep so the loop doesn't hog the CPU.\n\n        >>> starttime = time.monotonic()\n        >>> timeout = 1                    #seconds\n\n        This is a short timeout for testing purposes.\n\n        >>> while serverthread.serving:\n        ...     time.sleep(.01)\n        ...     if serverthread.serving and time.monotonic() - starttime > timeout:\n        ...          serverthread.stop()\n        ...          break\n\n        Print any errors that may have occurred.\n\n        >>> print(serverthread.error)\n        None\n   \"\"\"\n    import http.server\n    import email.message\n    import select\n    import threading\n\n    class DocHandler(http.server.BaseHTTPRequestHandler):\n\n        def do_GET(self):\n            \"\"\"Process a request from an HTML browser.\n\n            The URL received is in self.path.\n            Get an HTML page from self.urlhandler and send it.\n            \"\"\"\n            if self.path.endswith('.css'):\n                content_type = 'text/css'\n            else:\n                content_type = 'text/html'\n            self.send_response(200)\n            self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)\n            self.end_headers()\n            self.wfile.write(self.urlhandler(\n                self.path, content_type).encode('utf-8'))\n\n        def log_message(self, *args):\n            # Don't log messages.\n            pass\n\n    class DocServer(http.server.HTTPServer):\n\n        def __init__(self, host, port, callback):\n            self.host = host\n            self.address = (self.host, port)\n            self.callback = callback\n            self.base.__init__(self, self.address, self.handler)\n            self.quit = False\n\n        def serve_until_quit(self):\n            while not self.quit:\n                rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)\n                if rd:\n                    self.handle_request()\n            self.server_close()\n\n        def server_activate(self):\n            self.base.server_activate(self)\n            if self.callback:\n                self.callback(self)\n\n    class ServerThread(threading.Thread):\n\n        def __init__(self, urlhandler, host, port):\n            self.urlhandler = urlhandler\n            self.host = host\n            self.port = int(port)\n            threading.Thread.__init__(self)\n            self.serving = False\n            self.error = None\n\n        def run(self):\n            \"\"\"Start the server.\"\"\"\n            try:\n                DocServer.base = http.server.HTTPServer\n                DocServer.handler = DocHandler\n                DocHandler.MessageClass = email.message.Message\n                DocHandler.urlhandler = staticmethod(self.urlhandler)\n                docsvr = DocServer(self.host, self.port, self.ready)\n                self.docserver = docsvr\n                docsvr.serve_until_quit()\n            except Exception as e:\n                self.error = e\n\n        def ready(self, server):\n            self.serving = True\n            self.host = server.host\n            self.port = server.server_port\n            self.url = 'http://%s:%d/' % (self.host, self.port)\n\n        def stop(self):\n            \"\"\"Stop the server and this thread nicely\"\"\"\n            self.docserver.quit = True\n            self.join()\n            # explicitly break a reference cycle: DocServer.callback\n            # has indirectly a reference to ServerThread.\n            self.docserver = None\n            self.serving = False\n            self.url = None\n\n    thread = ServerThread(urlhandler, hostname, port)\n    thread.start()\n    # Wait until thread.serving is True to make sure we are\n    # really up before returning.\n    while not thread.error and not thread.serving:\n        time.sleep(.01)\n    return thread\n\n\ndef _url_handler(url, content_type=\"text/html\"):\n    \"\"\"The pydoc url handler for use with the pydoc server.\n\n    If the content_type is 'text/css', the _pydoc.css style\n    sheet is read and returned if it exits.\n\n    If the content_type is 'text/html', then the result of\n    get_html_page(url) is returned.\n    \"\"\"\n    class _HTMLDoc(HTMLDoc):\n\n        def page(self, title, contents):\n            \"\"\"Format an HTML page.\"\"\"\n            css_path = \"pydoc_data/_pydoc.css\"\n            css_link = (\n                '<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n                css_path)\n            return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n</body></html>''' % (title, css_link, html_navbar(), contents)\n\n\n    html = _HTMLDoc()\n\n    def html_navbar():\n        version = html.escape(\"%s [%s, %s]\" % (platform.python_version(),\n                                               platform.python_build()[0],\n                                               platform.python_compiler()))\n        return \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:center'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div>\n                    <form action=\"get\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Get\">\n                    </form>&nbsp;\n                    <form action=\"search\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\" % (version, html.escape(platform.platform(terse=True)))\n\n    def html_index():\n        \"\"\"Module Index page.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>Index of Modules</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = [name for name in sys.builtin_module_names\n                 if name != '__main__']\n        contents = html.multicolumn(names, bltinlink)\n        contents = [heading, '<p>' + html.bigsection(\n            'Built-in Modules', '#ffffff', '#ee77aa', contents)]\n\n        seen = {}\n        for dir in sys.path:\n            contents.append(html.index(dir, seen))\n\n        contents.append(\n            '<p align=right><font color=\"#909090\" face=\"helvetica,'\n            'arial\"><strong>pydoc</strong> by Ka-Ping Yee'\n            '&lt;ping@lfw.org&gt;</font>')\n        return 'Index of Modules', ''.join(contents)\n\n    def html_search(key):\n        \"\"\"Search results page.\"\"\"\n        # scan for modules\n        search_result = []\n\n        def callback(path, modname, desc):\n            if modname[-9:] == '.__init__':\n                modname = modname[:-9] + ' (package)'\n            search_result.append((modname, desc and '- ' + desc))\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore') # ignore problems during import\n            def onerror(modname):\n                pass\n            ModuleScanner().run(callback, key, onerror=onerror)\n\n        # format page\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        results = []\n        heading = html.heading(\n            '<big><big><strong>Search Results</strong></big></big>',\n            '#ffffff', '#7799ee')\n        for name, desc in search_result:\n            results.append(bltinlink(name) + desc)\n        contents = heading + html.bigsection(\n            'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n        return 'Search Results', contents\n\n    def html_topics():\n        \"\"\"Index of topic texts available.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.topics.keys())\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Topics', '#ffffff', '#ee77aa', contents)\n        return 'Topics', contents\n\n    def html_keywords():\n        \"\"\"Index of keywords.\"\"\"\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.keywords.keys())\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Keywords', '#ffffff', '#ee77aa', contents)\n        return 'Keywords', contents\n\n    def html_topicpage(topic):\n        \"\"\"Topic or keyword help page.\"\"\"\n        buf = io.StringIO()\n        htmlhelp = Helper(buf, buf)\n        contents, xrefs = htmlhelp._gettopic(topic)\n        if topic in htmlhelp.keywords:\n            title = 'KEYWORD'\n        else:\n            title = 'TOPIC'\n        heading = html.heading(\n            '<big><big><strong>%s</strong></big></big>' % title,\n            '#ffffff', '#7799ee')\n        contents = '<pre>%s</pre>' % html.markup(contents)\n        contents = html.bigsection(topic , '#ffffff','#ee77aa', contents)\n        if xrefs:\n            xrefs = sorted(xrefs.split())\n\n            def bltinlink(name):\n                return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n            xrefs = html.multicolumn(xrefs, bltinlink)\n            xrefs = html.section('Related help topics: ',\n                                 '#ffffff', '#ee77aa', xrefs)\n        return ('%s %s' % (title, topic),\n                ''.join((heading, contents, xrefs)))\n\n    def html_getobj(url):\n        obj = locate(url, forceload=1)\n        if obj is None and url != 'None':\n            raise ValueError('could not find object')\n        title = describe(obj)\n        content = html.document(obj, url)\n        return title, content\n\n    def html_error(url, exc):\n        heading = html.heading(\n            '<big><big><strong>Error</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = '<br>'.join(html.escape(line) for line in\n                               format_exception_only(type(exc), exc))\n        contents = heading + html.bigsection(url, '#ffffff', '#bb0000',\n                                             contents)\n        return \"Error - %s\" % url, contents\n\n    def get_html_page(url):\n        \"\"\"Generate an HTML page for url.\"\"\"\n        complete_url = url\n        if url.endswith('.html'):\n            url = url[:-5]\n        try:\n            if url in (\"\", \"index\"):\n                title, content = html_index()\n            elif url == \"topics\":\n                title, content = html_topics()\n            elif url == \"keywords\":\n                title, content = html_keywords()\n            elif '=' in url:\n                op, _, url = url.partition('=')\n                if op == \"search?key\":\n                    title, content = html_search(url)\n                elif op == \"topic?key\":\n                    # try topics first, then objects.\n                    try:\n                        title, content = html_topicpage(url)\n                    except ValueError:\n                        title, content = html_getobj(url)\n                elif op == \"get?key\":\n                    # try objects first, then topics.\n                    if url in (\"\", \"index\"):\n                        title, content = html_index()\n                    else:\n                        try:\n                            title, content = html_getobj(url)\n                        except ValueError:\n                            title, content = html_topicpage(url)\n                else:\n                    raise ValueError('bad pydoc url')\n            else:\n                title, content = html_getobj(url)\n        except Exception as exc:\n            # Catch any errors and display them in an error page.\n            title, content = html_error(complete_url, exc)\n        return html.page(title, content)\n\n    if url.startswith('/'):\n        url = url[1:]\n    if content_type == 'text/css':\n        path_here = os.path.dirname(os.path.realpath(__file__))\n        css_path = os.path.join(path_here, url)\n        with open(css_path) as fp:\n            return ''.join(fp.readlines())\n    elif content_type == 'text/html':\n        return get_html_page(url)\n    # Errors outside the url handler are caught by the server.\n    raise TypeError('unknown content type %r for url %s' % (content_type, url))\n\n\ndef browse(port=0, *, open_browser=True, hostname='localhost'):\n    \"\"\"Start the enhanced pydoc Web server and open a Web browser.\n\n    Use port '0' to start the server on an arbitrary port.\n    Set open_browser to False to suppress opening a browser.\n    \"\"\"\n    import webbrowser\n    serverthread = _start_server(_url_handler, hostname, port)\n    if serverthread.error:\n        print(serverthread.error)\n        return\n    if serverthread.serving:\n        server_help_msg = 'Server commands: [b]rowser, [q]uit'\n        if open_browser:\n            webbrowser.open(serverthread.url)\n        try:\n            print('Server ready at', serverthread.url)\n            print(server_help_msg)\n            while serverthread.serving:\n                cmd = input('server> ')\n                cmd = cmd.lower()\n                if cmd == 'q':\n                    break\n                elif cmd == 'b':\n                    webbrowser.open(serverthread.url)\n                else:\n                    print(server_help_msg)\n        except (KeyboardInterrupt, EOFError):\n            print()\n        finally:\n            if serverthread.serving:\n                serverthread.stop()\n                print('Server stopped')\n\n\n# -------------------------------------------------- command-line interface\n\ndef ispath(x):\n    return isinstance(x, str) and x.find(os.sep) >= 0\n\ndef _get_revised_path(given_path, argv0):\n    \"\"\"Ensures current directory is on returned path, and argv0 directory is not\n\n    Exception: argv0 dir is left alone if it's also pydoc's directory.\n\n    Returns a new path entry list, or None if no adjustment is needed.\n    \"\"\"\n    # Scripts may get the current directory in their path by default if they're\n    # run with the -m switch, or directly from the current directory.\n    # The interactive prompt also allows imports from the current directory.\n\n    # Accordingly, if the current directory is already present, don't make\n    # any changes to the given_path\n    if '' in given_path or os.curdir in given_path or os.getcwd() in given_path:\n        return None\n\n    # Otherwise, add the current directory to the given path, and remove the\n    # script directory (as long as the latter isn't also pydoc's directory.\n    stdlib_dir = os.path.dirname(__file__)\n    script_dir = os.path.dirname(argv0)\n    revised_path = given_path.copy()\n    if script_dir in given_path and not os.path.samefile(script_dir, stdlib_dir):\n        revised_path.remove(script_dir)\n    revised_path.insert(0, os.getcwd())\n    return revised_path\n\n\n# Note: the tests only cover _get_revised_path, not _adjust_cli_path itself\ndef _adjust_cli_sys_path():\n    \"\"\"Ensures current directory is on sys.path, and __main__ directory is not.\n\n    Exception: __main__ dir is left alone if it's also pydoc's directory.\n    \"\"\"\n    revised_path = _get_revised_path(sys.path, sys.argv[0])\n    if revised_path is not None:\n        sys.path[:] = revised_path\n\n\ndef cli():\n    \"\"\"Command-line interface (looks at sys.argv to decide what to do).\"\"\"\n    import getopt\n    class BadUsage(Exception): pass\n\n    _adjust_cli_sys_path()\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'bk:n:p:w')\n        writing = False\n        start_server = False\n        open_browser = False\n        port = 0\n        hostname = 'localhost'\n        for opt, val in opts:\n            if opt == '-b':\n                start_server = True\n                open_browser = True\n            if opt == '-k':\n                apropos(val)\n                return\n            if opt == '-p':\n                start_server = True\n                port = val\n            if opt == '-w':\n                writing = True\n            if opt == '-n':\n                start_server = True\n                hostname = val\n\n        if start_server:\n            browse(port, hostname=hostname, open_browser=open_browser)\n            return\n\n        if not args: raise BadUsage\n        for arg in args:\n            if ispath(arg) and not os.path.exists(arg):\n                print('file %r does not exist' % arg)\n                break\n            try:\n                if ispath(arg) and os.path.isfile(arg):\n                    arg = importfile(arg)\n                if writing:\n                    if ispath(arg) and os.path.isdir(arg):\n                        writedocs(arg)\n                    else:\n                        writedoc(arg)\n                else:\n                    help.help(arg)\n            except ErrorDuringImport as value:\n                print(value)\n\n    except (getopt.error, BadUsage):\n        cmd = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n        print(\"\"\"pydoc - the Python documentation tool\n\n{cmd} <name> ...\n    Show text documentation on something.  <name> may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If <name> contains a '{sep}', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\n{cmd} -k <keyword>\n    Search for a keyword in the synopsis lines of all available modules.\n\n{cmd} -n <hostname>\n    Start an HTTP server with the given hostname (default: localhost).\n\n{cmd} -p <port>\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\n{cmd} -b\n    Start an HTTP server on an arbitrary unused port and open a Web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\n{cmd} -w <name> ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If <name> contains a '{sep}', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\"\"\".format(cmd=cmd, sep=os.sep))\n\nif __name__ == '__main__':\n    cli()\n", "code_before": "#!/usr/bin/env python3\n\"\"\"Generate Python documentation in HTML or text for interactive use.\n\nAt the Python interactive prompt, calling help(thing) on a Python object\ndocuments the object, and calling help() starts up an interactive\nhelp session.\n\nOr, at the shell command line outside of Python:\n\nRun \"pydoc <name>\" to show documentation on something.  <name> may be\nthe name of a function, module, package, or a dotted reference to a\nclass or function within a module or module in a package.  If the\nargument contains a path segment delimiter (e.g. slash on Unix,\nbackslash on Windows) it is treated as the path to a Python source file.\n\nRun \"pydoc -k <keyword>\" to search for a keyword in the synopsis lines\nof all available modules.\n\nRun \"pydoc -n <hostname>\" to start an HTTP server with the given\nhostname (default: localhost) on the local machine.\n\nRun \"pydoc -p <port>\" to start an HTTP server on the given port on the\nlocal machine.  Port number 0 can be used to get an arbitrary unused port.\n\nRun \"pydoc -b\" to start an HTTP server on an arbitrary unused port and\nopen a Web browser to interactively browse documentation.  Combine with\nthe -n and -p options to control the hostname and port used.\n\nRun \"pydoc -w <name>\" to write out the HTML documentation for a module\nto a file named \"<name>.html\".\n\nModule docs for core modules are assumed to be in\n\n    https://docs.python.org/X.Y/library/\n\nThis can be overridden by setting the PYTHONDOCS environment variable\nto a different URL or to a local directory containing the Library\nReference Manual pages.\n\"\"\"\n__all__ = ['help']\n__author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n__date__ = \"26 February 2001\"\n\n__credits__ = \"\"\"Guido van Rossum, for an excellent programming language.\nTommy Burnette, the original creator of manpy.\nPaul Prescod, for all his work on onlinehelp.\nRichard Chamberlain, for the first implementation of textdoc.\n\"\"\"\n\n# Known bugs that can't be fixed here:\n#   - synopsis() cannot be prevented from clobbering existing\n#     loaded modules.\n#   - If the __file__ attribute on a module is a relative path and\n#     the current directory is changed with os.chdir(), an incorrect\n#     path will be displayed.\n\nimport builtins\nimport importlib._bootstrap\nimport importlib._bootstrap_external\nimport importlib.machinery\nimport importlib.util\nimport inspect\nimport io\nimport os\nimport pkgutil\nimport platform\nimport re\nimport sys\nimport sysconfig\nimport time\nimport tokenize\nimport urllib.parse\nimport warnings\nfrom collections import deque\nfrom reprlib import Repr\nfrom traceback import format_exception_only\n\n\n# --------------------------------------------------------- common routines\n\ndef pathdirs():\n    \"\"\"Convert sys.path into a list of absolute, existing, unique paths.\"\"\"\n    dirs = []\n    normdirs = []\n    for dir in sys.path:\n        dir = os.path.abspath(dir or '.')\n        normdir = os.path.normcase(dir)\n        if normdir not in normdirs and os.path.isdir(dir):\n            dirs.append(dir)\n            normdirs.append(normdir)\n    return dirs\n\ndef _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not inspect.isclass(cls):\n        return None\n    return cls\n\ndef _finddoc(obj):\n    if inspect.ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif inspect.isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.ismethoddescriptor(obj) or inspect.isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if inspect.ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = _getowndoc(getattr(base, name))\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None\n\ndef _getowndoc(obj):\n    \"\"\"Get the documentation string for an object if it is not\n    inherited from its class.\"\"\"\n    try:\n        doc = object.__getattribute__(obj, '__doc__')\n        if doc is None:\n            return None\n        if obj is not type:\n            typedoc = type(obj).__doc__\n            if isinstance(typedoc, str) and typedoc == doc:\n                return None\n        return doc\n    except AttributeError:\n        return None\n\ndef _getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    doc = _getowndoc(object)\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return inspect.cleandoc(doc)\n\ndef getdoc(object):\n    \"\"\"Get the doc string or comments for an object.\"\"\"\n    result = _getdoc(object) or inspect.getcomments(object)\n    return result and re.sub('^ *\\n', '', result.rstrip()) or ''\n\ndef splitdoc(doc):\n    \"\"\"Split a doc string into a synopsis line (if any) and the rest.\"\"\"\n    lines = doc.strip().split('\\n')\n    if len(lines) == 1:\n        return lines[0], ''\n    elif len(lines) >= 2 and not lines[1].rstrip():\n        return lines[0], '\\n'.join(lines[2:])\n    return '', '\\n'.join(lines)\n\ndef classname(object, modname):\n    \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\"\n    name = object.__name__\n    if object.__module__ != modname:\n        name = object.__module__ + '.' + name\n    return name\n\ndef isdata(object):\n    \"\"\"Check if an object is of a type that probably means it's data.\"\"\"\n    return not (inspect.ismodule(object) or inspect.isclass(object) or\n                inspect.isroutine(object) or inspect.isframe(object) or\n                inspect.istraceback(object) or inspect.iscode(object))\n\ndef replace(text, *pairs):\n    \"\"\"Do a series of global replacements on a string.\"\"\"\n    while pairs:\n        text = pairs[1].join(text.split(pairs[0]))\n        pairs = pairs[2:]\n    return text\n\ndef cram(text, maxlen):\n    \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\"\n    if len(text) > maxlen:\n        pre = max(0, (maxlen-3)//2)\n        post = max(0, maxlen-3-pre)\n        return text[:pre] + '...' + text[len(text)-post:]\n    return text\n\n_re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE)\ndef stripid(text):\n    \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\"\n    # The behaviour of %p is implementation-dependent in terms of case.\n    return _re_stripid.sub(r'\\1', text)\n\ndef _is_bound_method(fn):\n    \"\"\"\n    Returns True if fn is a bound method, regardless of whether\n    fn was implemented in Python or in C.\n    \"\"\"\n    if inspect.ismethod(fn):\n        return True\n    if inspect.isbuiltin(fn):\n        self = getattr(fn, '__self__', None)\n        return not (inspect.ismodule(self) or (self is None))\n    return False\n\n\ndef allmethods(cl):\n    methods = {}\n    for key, value in inspect.getmembers(cl, inspect.isroutine):\n        methods[key] = 1\n    for base in cl.__bases__:\n        methods.update(allmethods(base)) # all your base are belong to us\n    for key in methods.keys():\n        methods[key] = getattr(cl, key)\n    return methods\n\ndef _split_list(s, predicate):\n    \"\"\"Split sequence s via predicate, and return pair ([true], [false]).\n\n    The return value is a 2-tuple of lists,\n        ([x for x in s if predicate(x)],\n         [x for x in s if not predicate(x)])\n    \"\"\"\n\n    yes = []\n    no = []\n    for x in s:\n        if predicate(x):\n            yes.append(x)\n        else:\n            no.append(x)\n    return yes, no\n\ndef visiblename(name, all=None, obj=None):\n    \"\"\"Decide whether to show documentation on a variable.\"\"\"\n    # Certain special names are redundant or internal.\n    # XXX Remove __initializing__?\n    if name in {'__author__', '__builtins__', '__cached__', '__credits__',\n                '__date__', '__doc__', '__file__', '__spec__',\n                '__loader__', '__module__', '__name__', '__package__',\n                '__path__', '__qualname__', '__slots__', '__version__'}:\n        return 0\n    # Private names are hidden, but special names are displayed.\n    if name.startswith('__') and name.endswith('__'): return 1\n    # Namedtuples have public fields and methods with a single leading underscore\n    if name.startswith('_') and hasattr(obj, '_fields'):\n        return True\n    if all is not None:\n        # only document that which the programmer exported in __all__\n        return name in all\n    else:\n        return not name.startswith('_')\n\ndef classify_class_attrs(object):\n    \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\"\n    results = []\n    for (name, kind, cls, value) in inspect.classify_class_attrs(object):\n        if inspect.isdatadescriptor(value):\n            kind = 'data descriptor'\n            if isinstance(value, property) and value.fset is None:\n                kind = 'readonly property'\n        results.append((name, kind, cls, value))\n    return results\n\ndef sort_attributes(attrs, object):\n    'Sort the attrs list in-place by _fields and then alphabetically by name'\n    # This allows data descriptors to be ordered according\n    # to a _fields attribute if present.\n    fields = getattr(object, '_fields', [])\n    try:\n        field_order = {name : i-len(fields) for (i, name) in enumerate(fields)}\n    except TypeError:\n        field_order = {}\n    keyfunc = lambda attr: (field_order.get(attr[0], 0), attr[0])\n    attrs.sort(key=keyfunc)\n\n# ----------------------------------------------------- module manipulation\n\ndef ispackage(path):\n    \"\"\"Guess whether a path refers to a package directory.\"\"\"\n    if os.path.isdir(path):\n        for ext in ('.py', '.pyc'):\n            if os.path.isfile(os.path.join(path, '__init__' + ext)):\n                return True\n    return False\n\ndef source_synopsis(file):\n    line = file.readline()\n    while line[:1] == '#' or not line.strip():\n        line = file.readline()\n        if not line: break\n    line = line.strip()\n    if line[:4] == 'r\"\"\"': line = line[1:]\n    if line[:3] == '\"\"\"':\n        line = line[3:]\n        if line[-1:] == '\\\\': line = line[:-1]\n        while not line.strip():\n            line = file.readline()\n            if not line: break\n        result = line.split('\"\"\"')[0].strip()\n    else: result = None\n    return result\n\ndef synopsis(filename, cache={}):\n    \"\"\"Get the one-line summary out of a module file.\"\"\"\n    mtime = os.stat(filename).st_mtime\n    lastupdate, result = cache.get(filename, (None, None))\n    if lastupdate is None or lastupdate < mtime:\n        # Look for binary suffixes first, falling back to source.\n        if filename.endswith(tuple(importlib.machinery.BYTECODE_SUFFIXES)):\n            loader_cls = importlib.machinery.SourcelessFileLoader\n        elif filename.endswith(tuple(importlib.machinery.EXTENSION_SUFFIXES)):\n            loader_cls = importlib.machinery.ExtensionFileLoader\n        else:\n            loader_cls = None\n        # Now handle the choice.\n        if loader_cls is None:\n            # Must be a source file.\n            try:\n                file = tokenize.open(filename)\n            except OSError:\n                # module can't be opened, so skip it\n                return None\n            # text modules can be directly examined\n            with file:\n                result = source_synopsis(file)\n        else:\n            # Must be a binary module, which has to be imported.\n            loader = loader_cls('__temp__', filename)\n            # XXX We probably don't need to pass in the loader here.\n            spec = importlib.util.spec_from_file_location('__temp__', filename,\n                                                          loader=loader)\n            try:\n                module = importlib._bootstrap._load(spec)\n            except:\n                return None\n            del sys.modules['__temp__']\n            result = module.__doc__.splitlines()[0] if module.__doc__ else None\n        # Cache the result.\n        cache[filename] = (mtime, result)\n    return result\n\nclass ErrorDuringImport(Exception):\n    \"\"\"Errors that occurred while trying to import something to document it.\"\"\"\n    def __init__(self, filename, exc_info):\n        self.filename = filename\n        self.exc, self.value, self.tb = exc_info\n\n    def __str__(self):\n        exc = self.exc.__name__\n        return 'problem in %s - %s: %s' % (self.filename, exc, self.value)\n\ndef importfile(path):\n    \"\"\"Import a Python source file or compiled file given its path.\"\"\"\n    magic = importlib.util.MAGIC_NUMBER\n    with open(path, 'rb') as file:\n        is_bytecode = magic == file.read(len(magic))\n    filename = os.path.basename(path)\n    name, ext = os.path.splitext(filename)\n    if is_bytecode:\n        loader = importlib._bootstrap_external.SourcelessFileLoader(name, path)\n    else:\n        loader = importlib._bootstrap_external.SourceFileLoader(name, path)\n    # XXX We probably don't need to pass in the loader here.\n    spec = importlib.util.spec_from_file_location(name, path, loader=loader)\n    try:\n        return importlib._bootstrap._load(spec)\n    except:\n        raise ErrorDuringImport(path, sys.exc_info())\n\ndef safeimport(path, forceload=0, cache={}):\n    \"\"\"Import a module; handle errors; return None if the module isn't found.\n\n    If the module *is* found but an exception occurs, it's wrapped in an\n    ErrorDuringImport exception and reraised.  Unlike __import__, if a\n    package path is specified, the module at the end of the path is returned,\n    not the package at the beginning.  If the optional 'forceload' argument\n    is 1, we reload the module from disk (unless it's a dynamic extension).\"\"\"\n    try:\n        # If forceload is 1 and the module has been previously loaded from\n        # disk, we always have to reload the module.  Checking the file's\n        # mtime isn't good enough (e.g. the module could contain a class\n        # that inherits from another module that has changed).\n        if forceload and path in sys.modules:\n            if path not in sys.builtin_module_names:\n                # Remove the module from sys.modules and re-import to try\n                # and avoid problems with partially loaded modules.\n                # Also remove any submodules because they won't appear\n                # in the newly loaded module's namespace if they're already\n                # in sys.modules.\n                subs = [m for m in sys.modules if m.startswith(path + '.')]\n                for key in [path] + subs:\n                    # Prevent garbage collection.\n                    cache[key] = sys.modules[key]\n                    del sys.modules[key]\n        module = __import__(path)\n    except:\n        # Did the error occur before or after the module was found?\n        (exc, value, tb) = info = sys.exc_info()\n        if path in sys.modules:\n            # An error occurred while executing the imported module.\n            raise ErrorDuringImport(sys.modules[path].__file__, info)\n        elif exc is SyntaxError:\n            # A SyntaxError occurred before we could execute the module.\n            raise ErrorDuringImport(value.filename, info)\n        elif issubclass(exc, ImportError) and value.name == path:\n            # No such module in the path.\n            return None\n        else:\n            # Some other error occurred during the importing process.\n            raise ErrorDuringImport(path, sys.exc_info())\n    for part in path.split('.')[1:]:\n        try: module = getattr(module, part)\n        except AttributeError: return None\n    return module\n\n# ---------------------------------------------------- formatter base class\n\nclass Doc:\n\n    PYTHONDOCS = os.environ.get(\"PYTHONDOCS\",\n                                \"https://docs.python.org/%d.%d/library\"\n                                % sys.version_info[:2])\n\n    def document(self, object, name=None, *args):\n        \"\"\"Generate documentation for an object.\"\"\"\n        args = (object, name) + args\n        # 'try' clause is to attempt to handle the possibility that inspect\n        # identifies something in a way that pydoc itself has issues handling;\n        # think 'super' and how it is a descriptor (which raises the exception\n        # by lacking a __name__ attribute) and an instance.\n        try:\n            if inspect.ismodule(object): return self.docmodule(*args)\n            if inspect.isclass(object): return self.docclass(*args)\n            if inspect.isroutine(object): return self.docroutine(*args)\n        except AttributeError:\n            pass\n        if inspect.isdatadescriptor(object): return self.docdata(*args)\n        return self.docother(*args)\n\n    def fail(self, object, name=None, *args):\n        \"\"\"Raise an exception for unimplemented types.\"\"\"\n        message = \"don't know how to document object%s of type %s\" % (\n            name and ' ' + repr(name), type(object).__name__)\n        raise TypeError(message)\n\n    docmodule = docclass = docroutine = docother = docproperty = docdata = fail\n\n    def getdocloc(self, object, basedir=sysconfig.get_path('stdlib')):\n        \"\"\"Return the location of module docs or None\"\"\"\n\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n\n        docloc = os.environ.get(\"PYTHONDOCS\", self.PYTHONDOCS)\n\n        basedir = os.path.normcase(basedir)\n        if (isinstance(object, type(os)) and\n            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',\n                                 'marshal', 'posix', 'signal', 'sys',\n                                 '_thread', 'zipimport') or\n             (file.startswith(basedir) and\n              not file.startswith(os.path.join(basedir, 'site-packages')))) and\n            object.__name__ not in ('xml.etree', 'test.pydoc_mod')):\n            if docloc.startswith((\"http://\", \"https://\")):\n                docloc = \"{}/{}.html\".format(docloc.rstrip(\"/\"), object.__name__.lower())\n            else:\n                docloc = os.path.join(docloc, object.__name__.lower() + \".html\")\n        else:\n            docloc = None\n        return docloc\n\n# -------------------------------------------- HTML documentation generator\n\nclass HTMLRepr(Repr):\n    \"\"\"Class for safely making an HTML representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def escape(self, text):\n        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')\n\n    def repr(self, object):\n        return Repr.repr(self, object)\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return self.escape(cram(stripid(repr(x)), self.maxother))\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + self.escape(test) + testrepr[0]\n        return re.sub(r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)',\n                      r'<font color=\"#c040c0\">\\1</font>',\n                      self.escape(testrepr))\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return self.escape(cram(stripid(repr(x)), self.maxstring))\n        except:\n            return self.escape('<%s instance>' % x.__class__.__name__)\n\n    repr_unicode = repr_string\n\nclass HTMLDoc(Doc):\n    \"\"\"Formatter class for HTML documentation.\"\"\"\n\n    # ------------------------------------------- HTML formatting utilities\n\n    _repr_instance = HTMLRepr()\n    repr = _repr_instance.repr\n    escape = _repr_instance.escape\n\n    def page(self, title, contents):\n        \"\"\"Format an HTML page.\"\"\"\n        return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Python: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head><body bgcolor=\"#f0f0f8\">\n%s\n</body></html>''' % (title, contents)\n\n    def heading(self, title, fgcol, bgcol, extras=''):\n        \"\"\"Format a page heading.\"\"\"\n        return '''\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"%s\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">&nbsp;<br>%s</font></td\n><td align=right valign=bottom\n><font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr></table>\n    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')\n\n    def section(self, title, fgcol, bgcol, contents, width=6,\n                prelude='', marginalia=None, gap='&nbsp;'):\n        \"\"\"Format a section with a heading.\"\"\"\n        if marginalia is None:\n            marginalia = '<tt>' + '&nbsp;' * width + '</tt>'\n        result = '''<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"%s\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr>\n    ''' % (bgcol, fgcol, title)\n        if prelude:\n            result = result + '''\n<tr bgcolor=\"%s\"><td rowspan=2>%s</td>\n<td colspan=2>%s</td></tr>\n<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)\n        else:\n            result = result + '''\n<tr><td bgcolor=\"%s\">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)\n\n        return result + '\\n<td width=\"100%%\">%s</td></tr></table>' % contents\n\n    def bigsection(self, title, *args):\n        \"\"\"Format a section with a big heading.\"\"\"\n        title = '<big><strong>%s</strong></big>' % title\n        return self.section(title, *args)\n\n    def preformat(self, text):\n        \"\"\"Format literal preformatted text.\"\"\"\n        text = self.escape(text.expandtabs())\n        return replace(text, '\\n\\n', '\\n \\n', '\\n\\n', '\\n \\n',\n                             ' ', '&nbsp;', '\\n', '<br>\\n')\n\n    def multicolumn(self, list, format, cols=4):\n        \"\"\"Format a list of items into a multi-column list.\"\"\"\n        result = ''\n        rows = (len(list)+cols-1)//cols\n        for col in range(cols):\n            result = result + '<td width=\"%d%%\" valign=top>' % (100//cols)\n            for i in range(rows*col, rows*col+rows):\n                if i < len(list):\n                    result = result + format(list[i]) + '<br>\\n'\n            result = result + '</td>'\n        return '<table width=\"100%%\" summary=\"list\"><tr>%s</tr></table>' % result\n\n    def grey(self, text): return '<font color=\"#909090\">%s</font>' % text\n\n    def namelink(self, name, *dicts):\n        \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\"\n        for dict in dicts:\n            if name in dict:\n                return '<a href=\"%s\">%s</a>' % (dict[name], name)\n        return name\n\n    def classlink(self, object, modname):\n        \"\"\"Make a link for a class.\"\"\"\n        name, module = object.__name__, sys.modules.get(object.__module__)\n        if hasattr(module, name) and getattr(module, name) is object:\n            return '<a href=\"%s.html#%s\">%s</a>' % (\n                module.__name__, name, classname(object, modname))\n        return classname(object, modname)\n\n    def modulelink(self, object):\n        \"\"\"Make a link for a module.\"\"\"\n        return '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n\n    def modpkglink(self, modpkginfo):\n        \"\"\"Make a link for a module or package to display in an index.\"\"\"\n        name, path, ispackage, shadowed = modpkginfo\n        if shadowed:\n            return self.grey(name)\n        if path:\n            url = '%s.%s.html' % (path, name)\n        else:\n            url = '%s.html' % name\n        if ispackage:\n            text = '<strong>%s</strong>&nbsp;(package)' % name\n        else:\n            text = name\n        return '<a href=\"%s\">%s</a>' % (url, text)\n\n    def filelink(self, url, path):\n        \"\"\"Make a link to source file.\"\"\"\n        return '<a href=\"file:%s\">%s</a>' % (url, path)\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n        pattern = re.compile(r'\\b((http|https|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?(\\w+))')\n        while True:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif selfdot:\n                # Create a link for methods like 'self.method(...)'\n                # and use <strong> for attributes like 'self.attr'\n                if text[end:end+1] == '(':\n                    results.append('self.' + self.namelink(name, methods))\n                else:\n                    results.append('self.<strong>%s</strong>' % name)\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None):\n        \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + '<dt><font face=\"helvetica, arial\">'\n                result = result + self.classlink(c, modname)\n                if bases and bases != (parent,):\n                    parents = []\n                    for base in bases:\n                        parents.append(self.classlink(base, modname))\n                    result = result + '(' + ', '.join(parents) + ')'\n                result = result + '\\n</font></dt>'\n            elif type(entry) is type([]):\n                result = result + '<dd>\\n%s</dd>\\n' % self.formattree(\n                    entry, modname, c)\n        return '<dl>\\n%s</dl>\\n' % result\n\n    def docmodule(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        try:\n            all = object.__all__\n        except AttributeError:\n            all = None\n        parts = name.split('.')\n        links = []\n        for i in range(len(parts)-1):\n            links.append(\n                '<a href=\"%s.html\"><font color=\"#ffffff\">%s</font></a>' %\n                ('.'.join(parts[:i+1]), parts[i]))\n        linkedname = '.'.join(links + parts[-1:])\n        head = '<big><big><strong>%s</strong></big></big>' % linkedname\n        try:\n            path = inspect.getabsfile(object)\n            url = urllib.parse.quote(path)\n            filelink = self.filelink(url, path)\n        except TypeError:\n            filelink = '(built-in)'\n        info = []\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            info.append('version %s' % self.escape(version))\n        if hasattr(object, '__date__'):\n            info.append(self.escape(str(object.__date__)))\n        if info:\n            head = head + ' (%s)' % ', '.join(info)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            docloc = '<br><a href=\"%(docloc)s\">Module Reference</a>' % locals()\n        else:\n            docloc = ''\n        result = self.heading(\n            head, '#ffffff', '#7799ee',\n            '<a href=\".\">index</a><br>' + filelink + docloc)\n\n        modules = inspect.getmembers(object, inspect.ismodule)\n\n        classes, cdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n                    cdict[key] = cdict[value] = '#' + key\n        for key, value in classes:\n            for base in value.__bases__:\n                key, modname = base.__name__, base.__module__\n                module = sys.modules.get(modname)\n                if modname != name and module and hasattr(module, key):\n                    if getattr(module, key) is base:\n                        if not key in cdict:\n                            cdict[key] = cdict[base] = modname + '.html#' + key\n        funcs, fdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n                    fdict[key] = '#-' + key\n                    if inspect.isfunction(value): fdict[value] = fdict[key]\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        doc = self.markup(getdoc(object), self.preformat, fdict, cdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        if hasattr(object, '__path__'):\n            modpkgs = []\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs.append((modname, name, ispkg, 0))\n            modpkgs.sort()\n            contents = self.multicolumn(modpkgs, self.modpkglink)\n            result = result + self.bigsection(\n                'Package Contents', '#ffffff', '#aa55cc', contents)\n        elif modules:\n            contents = self.multicolumn(\n                modules, lambda t: self.modulelink(t[1]))\n            result = result + self.bigsection(\n                'Modules', '#ffffff', '#aa55cc', contents)\n\n        if classes:\n            classlist = [value for (key, value) in classes]\n            contents = [\n                self.formattree(inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Classes', '#ffffff', '#ee77aa', ' '.join(contents))\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Functions', '#ffffff', '#eeaa77', ' '.join(contents))\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.document(value, key))\n            result = result + self.bigsection(\n                'Data', '#ffffff', '#55aa55', '<br>\\n'.join(contents))\n        if hasattr(object, '__author__'):\n            contents = self.markup(str(object.__author__), self.preformat)\n            result = result + self.bigsection(\n                'Author', '#ffffff', '#7799ee', contents)\n        if hasattr(object, '__credits__'):\n            contents = self.markup(str(object.__credits__), self.preformat)\n            result = result + self.bigsection(\n                'Credits', '#ffffff', '#7799ee', contents)\n\n        return result\n\n    def docclass(self, object, name=None, mod=None, funcs={}, classes={},\n                 *ignored):\n        \"\"\"Produce HTML documentation for a class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        contents = []\n        push = contents.append\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('<hr>\\n')\n                self.needone = 1\n        hr = HorizontalRule()\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            hr.maybe()\n            push('<dl><dt>Method resolution order:</dt>\\n')\n            for base in mro:\n                push('<dd>%s</dd>\\n' % self.classlink(base,\n                                                      object.__module__))\n            push('</dl>\\n')\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value, name, mod,\n                                        funcs, classes, mdict, object))\n                    push('\\n')\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    base = self.docother(getattr(object, name), name, mod)\n                    doc = getdoc(value)\n                    if not doc:\n                        push('<dl><dt>%s</dl>\\n' % base)\n                    else:\n                        doc = self.markup(getdoc(value), self.preformat,\n                                          funcs, classes, mdict)\n                        doc = '<dd><tt>%s</tt>' % doc\n                        push('<dl><dt>%s%s</dl>\\n' % (base, doc))\n                    push('\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        mdict = {}\n        for key, kind, homecls, value in attrs:\n            mdict[key] = anchor = '#' + name + '-' + key\n            try:\n                value = getattr(object, name)\n            except Exception:\n                # Some descriptors may meet a failure in their __get__.\n                # (bug #1785)\n                pass\n            try:\n                # The value may not be hashable (e.g., a data attr with\n                # a dict or list value).\n                mdict[value] = anchor\n            except TypeError:\n                pass\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = 'defined here'\n            else:\n                tag = 'inherited from %s' % self.classlink(thisclass,\n                                                           object.__module__)\n            tag += ':<br>\\n'\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill('Methods %s' % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill('Class methods %s' % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill('Static methods %s' % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata('Data and other attributes %s' % tag, attrs,\n                              lambda t: t[1] == 'data')\n            assert attrs == []\n            attrs = inherited\n\n        contents = ''.join(contents)\n\n        if name == realname:\n            title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n                name, realname)\n        else:\n            title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n                name, name, realname)\n        if bases:\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, object.__module__))\n            title = title + '(%s)' % ', '.join(parents)\n\n        decl = ''\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                decl = name + self.escape(argspec) + '\\n\\n'\n\n        doc = getdoc(object)\n        if decl:\n            doc = decl + (doc or '')\n        doc = self.markup(doc, self.preformat, funcs, classes, mdict)\n        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n\n        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return self.grey('=' + self.repr(object))\n\n    def docroutine(self, object, name=None, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + self.classlink(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % self.classlink(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % self.classlink(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = '<a name=\"%s\"><strong>%s</strong></a>' % (anchor, realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                reallink = '<a href=\"#%s\">%s</a>' % (\n                    cl.__name__ + '-' + realname, realname)\n                skipdocs = 1\n            else:\n                reallink = realname\n            title = '<a name=\"%s\"><strong>%s</strong></a> = %s' % (\n                anchor, name, reallink)\n        argspec = None\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = '<strong>%s</strong> <em>lambda</em> ' % name\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n\n        decl = asyncqualifier + title + self.escape(argspec) + (note and\n               self.grey('<font face=\"helvetica, arial\">%s</font>' % note))\n\n        if skipdocs:\n            return '<dl><dt>%s</dt></dl>\\n' % decl\n        else:\n            doc = self.markup(\n                getdoc(object), self.preformat, funcs, classes, methods)\n            doc = doc and '<dd><tt>%s</tt></dd>' % doc\n            return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce html documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push('<dl><dt><strong>%s</strong></dt>\\n' % name)\n        doc = self.markup(getdoc(object), self.preformat)\n        if doc:\n            push('<dd><tt>%s</tt></dd>\\n' % doc)\n        push('</dl>\\n')\n\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a data object.\"\"\"\n        lhs = name and '<strong>%s</strong> = ' % name or ''\n        return lhs + self.repr(object)\n\n    def index(self, dir, shadowed=None):\n        \"\"\"Generate an HTML index for a directory of modules.\"\"\"\n        modpkgs = []\n        if shadowed is None: shadowed = {}\n        for importer, name, ispkg in pkgutil.iter_modules([dir]):\n            if any((0xD800 <= ord(ch) <= 0xDFFF) for ch in name):\n                # ignore a module if its name contains a surrogate character\n                continue\n            modpkgs.append((name, '', ispkg, name in shadowed))\n            shadowed[name] = 1\n\n        modpkgs.sort()\n        contents = self.multicolumn(modpkgs, self.modpkglink)\n        return self.bigsection(dir, '#ffffff', '#ee77aa', contents)\n\n# -------------------------------------------- text documentation generator\n\nclass TextRepr(Repr):\n    \"\"\"Class for safely making a text representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return cram(stripid(repr(x)), self.maxother)\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + test + testrepr[0]\n        return testrepr\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return cram(stripid(repr(x)), self.maxstring)\n        except:\n            return '<%s instance>' % x.__class__.__name__\n\nclass TextDoc(Doc):\n    \"\"\"Formatter class for text documentation.\"\"\"\n\n    # ------------------------------------------- text formatting utilities\n\n    _repr_instance = TextRepr()\n    repr = _repr_instance.repr\n\n    def bold(self, text):\n        \"\"\"Format a string in bold by overstriking.\"\"\"\n        return ''.join(ch + '\\b' + ch for ch in text)\n\n    def indent(self, text, prefix='    '):\n        \"\"\"Indent text by prepending a given prefix to each line.\"\"\"\n        if not text: return ''\n        lines = [prefix + line for line in text.split('\\n')]\n        if lines: lines[-1] = lines[-1].rstrip()\n        return '\\n'.join(lines)\n\n    def section(self, title, contents):\n        \"\"\"Format a section with a given heading.\"\"\"\n        clean_contents = self.indent(contents).rstrip()\n        return self.bold(title) + '\\n' + clean_contents + '\\n\\n'\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None, prefix=''):\n        \"\"\"Render in text a class tree as returned by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + prefix + classname(c, modname)\n                if bases and bases != (parent,):\n                    parents = (classname(c, modname) for c in bases)\n                    result = result + '(%s)' % ', '.join(parents)\n                result = result + '\\n'\n            elif type(entry) is type([]):\n                result = result + self.formattree(\n                    entry, modname, c, prefix + '    ')\n        return result\n\n    def docmodule(self, object, name=None, mod=None):\n        \"\"\"Produce text documentation for a given module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        synop, desc = splitdoc(getdoc(object))\n        result = self.section('NAME', name + (synop and ' - ' + synop))\n        all = getattr(object, '__all__', None)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            result = result + self.section('MODULE REFERENCE', docloc + \"\"\"\n\nThe following documentation is automatically generated from the Python\nsource files.  It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations.  When in doubt, consult the module reference at the\nlocation listed above.\n\"\"\")\n\n        if desc:\n            result = result + self.section('DESCRIPTION', desc)\n\n        classes = []\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None\n                or (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n        funcs = []\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        modpkgs = []\n        modpkgs_names = set()\n        if hasattr(object, '__path__'):\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs_names.add(modname)\n                if ispkg:\n                    modpkgs.append(modname + ' (package)')\n                else:\n                    modpkgs.append(modname)\n\n            modpkgs.sort()\n            result = result + self.section(\n                'PACKAGE CONTENTS', '\\n'.join(modpkgs))\n\n        # Detect submodules as sometimes created by C extensions\n        submodules = []\n        for key, value in inspect.getmembers(object, inspect.ismodule):\n            if value.__name__.startswith(name + '.') and key not in modpkgs_names:\n                submodules.append(key)\n        if submodules:\n            submodules.sort()\n            result = result + self.section(\n                'SUBMODULES', '\\n'.join(submodules))\n\n        if classes:\n            classlist = [value for key, value in classes]\n            contents = [self.formattree(\n                inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('CLASSES', '\\n'.join(contents))\n\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('FUNCTIONS', '\\n'.join(contents))\n\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.docother(value, key, name, maxlen=70))\n            result = result + self.section('DATA', '\\n'.join(contents))\n\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            result = result + self.section('VERSION', version)\n        if hasattr(object, '__date__'):\n            result = result + self.section('DATE', str(object.__date__))\n        if hasattr(object, '__author__'):\n            result = result + self.section('AUTHOR', str(object.__author__))\n        if hasattr(object, '__credits__'):\n            result = result + self.section('CREDITS', str(object.__credits__))\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n        result = result + self.section('FILE', file)\n        return result\n\n    def docclass(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce text documentation for a given class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        def makename(c, m=object.__module__):\n            return classname(c, m)\n\n        if name == realname:\n            title = 'class ' + self.bold(realname)\n        else:\n            title = self.bold(name) + ' = class ' + realname\n        if bases:\n            parents = map(makename, bases)\n            title = title + '(%s)' % ', '.join(parents)\n\n        contents = []\n        push = contents.append\n\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                push(name + argspec + '\\n')\n\n        doc = getdoc(object)\n        if doc:\n            push(doc + '\\n')\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            push(\"Method resolution order:\")\n            for base in mro:\n                push('    ' + makename(base))\n            push('')\n\n        # List the built-in subclasses, if any:\n        subclasses = sorted(\n            (str(cls.__name__) for cls in type.__subclasses__(object)\n             if not cls.__name__.startswith(\"_\") and cls.__module__ == \"builtins\"),\n            key=str.lower\n        )\n        no_of_subclasses = len(subclasses)\n        MAX_SUBCLASSES_TO_DISPLAY = 4\n        if subclasses:\n            push(\"Built-in subclasses:\")\n            for subclassname in subclasses[:MAX_SUBCLASSES_TO_DISPLAY]:\n                push('    ' + subclassname)\n            if no_of_subclasses > MAX_SUBCLASSES_TO_DISPLAY:\n                push('    ... and ' +\n                     str(no_of_subclasses - MAX_SUBCLASSES_TO_DISPLAY) +\n                     ' other subclasses')\n            push('')\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('-' * 70)\n                self.needone = 1\n        hr = HorizontalRule()\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value,\n                                        name, mod, object))\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    doc = getdoc(value)\n                    try:\n                        obj = getattr(object, name)\n                    except AttributeError:\n                        obj = homecls.__dict__[name]\n                    push(self.docother(obj, name, mod, maxlen=70, doc=doc) +\n                         '\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = \"defined here\"\n            else:\n                tag = \"inherited from %s\" % classname(thisclass,\n                                                      object.__module__)\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill(\"Methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill(\"Class methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill(\"Static methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors(\"Data descriptors %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata(\"Data and other attributes %s:\\n\" % tag, attrs,\n                              lambda t: t[1] == 'data')\n\n            assert attrs == []\n            attrs = inherited\n\n        contents = '\\n'.join(contents)\n        if not contents:\n            return title + '\\n'\n        return title + '\\n' + self.indent(contents.rstrip(), ' |  ') + '\\n'\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return '=' + self.repr(object)\n\n    def docroutine(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + classname(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % classname(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % classname(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = self.bold(realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                skipdocs = 1\n            title = self.bold(name) + ' = ' + realname\n        argspec = None\n\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = self.bold(name) + ' lambda '\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n        decl = asyncqualifier + title + argspec + note\n\n        if skipdocs:\n            return decl + '\\n'\n        else:\n            doc = getdoc(object) or ''\n            return decl + '\\n' + (doc and self.indent(doc).rstrip() + '\\n')\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push(self.bold(name))\n            push('\\n')\n        doc = getdoc(object) or ''\n        if doc:\n            push(self.indent(doc))\n            push('\\n')\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):\n        \"\"\"Produce text documentation for a data object.\"\"\"\n        repr = self.repr(object)\n        if maxlen:\n            line = (name and name + ' = ' or '') + repr\n            chop = maxlen - len(line)\n            if chop < 0: repr = repr[:chop] + '...'\n        line = (name and self.bold(name) + ' = ' or '') + repr\n        if not doc:\n            doc = getdoc(object)\n        if doc:\n            line += '\\n' + self.indent(str(doc)) + '\\n'\n        return line\n\nclass _PlainTextDoc(TextDoc):\n    \"\"\"Subclass of TextDoc which overrides string styling\"\"\"\n    def bold(self, text):\n        return text\n\n# --------------------------------------------------------- user interfaces\n\ndef pager(text):\n    \"\"\"The first time this is called, determine what kind of pager to use.\"\"\"\n    global pager\n    pager = getpager()\n    pager(text)\n\ndef getpager():\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    if not hasattr(sys.stdin, \"isatty\"):\n        return plainpager\n    if not hasattr(sys.stdout, \"isatty\"):\n        return plainpager\n    if not sys.stdin.isatty() or not sys.stdout.isatty():\n        return plainpager\n    use_pager = os.environ.get('MANPAGER') or os.environ.get('PAGER')\n    if use_pager:\n        if sys.platform == 'win32': # pipes completely broken in Windows\n            return lambda text: tempfilepager(plain(text), use_pager)\n        elif os.environ.get('TERM') in ('dumb', 'emacs'):\n            return lambda text: pipepager(plain(text), use_pager)\n        else:\n            return lambda text: pipepager(text, use_pager)\n    if os.environ.get('TERM') in ('dumb', 'emacs'):\n        return plainpager\n    if sys.platform == 'win32':\n        return lambda text: tempfilepager(plain(text), 'more <')\n    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n        return lambda text: pipepager(text, 'less')\n\n    import tempfile\n    (fd, filename) = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n            return lambda text: pipepager(text, 'more')\n        else:\n            return ttypager\n    finally:\n        os.unlink(filename)\n\ndef plain(text):\n    \"\"\"Remove boldface formatting from text.\"\"\"\n    return re.sub('.\\b', '', text)\n\ndef pipepager(text, cmd):\n    \"\"\"Page through text by feeding it to another program.\"\"\"\n    import subprocess\n    proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE)\n    try:\n        with io.TextIOWrapper(proc.stdin, errors='backslashreplace') as pipe:\n            try:\n                pipe.write(text)\n            except KeyboardInterrupt:\n                # We've hereby abandoned whatever text hasn't been written,\n                # but the pager is still in control of the terminal.\n                pass\n    except OSError:\n        pass # Ignore broken pipes caused by quitting the pager program.\n    while True:\n        try:\n            proc.wait()\n            break\n        except KeyboardInterrupt:\n            # Ignore ctl-c like the pager itself does.  Otherwise the pager is\n            # left running and the terminal is in raw mode and unusable.\n            pass\n\ndef tempfilepager(text, cmd):\n    \"\"\"Page through text by invoking a program on a temporary file.\"\"\"\n    import tempfile\n    filename = tempfile.mktemp()\n    with open(filename, 'w', errors='backslashreplace') as file:\n        file.write(text)\n    try:\n        os.system(cmd + ' \"' + filename + '\"')\n    finally:\n        os.unlink(filename)\n\ndef _escape_stdout(text):\n    # Escape non-encodable characters to avoid encoding errors later\n    encoding = getattr(sys.stdout, 'encoding', None) or 'utf-8'\n    return text.encode(encoding, 'backslashreplace').decode(encoding)\n\ndef ttypager(text):\n    \"\"\"Page through text on a text terminal.\"\"\"\n    lines = plain(_escape_stdout(text)).split('\\n')\n    try:\n        import tty\n        fd = sys.stdin.fileno()\n        old = tty.tcgetattr(fd)\n        tty.setcbreak(fd)\n        getchar = lambda: sys.stdin.read(1)\n    except (ImportError, AttributeError, io.UnsupportedOperation):\n        tty = None\n        getchar = lambda: sys.stdin.readline()[:-1][:1]\n\n    try:\n        try:\n            h = int(os.environ.get('LINES', 0))\n        except ValueError:\n            h = 0\n        if h <= 1:\n            h = 25\n        r = inc = h - 1\n        sys.stdout.write('\\n'.join(lines[:inc]) + '\\n')\n        while lines[r:]:\n            sys.stdout.write('-- more --')\n            sys.stdout.flush()\n            c = getchar()\n\n            if c in ('q', 'Q'):\n                sys.stdout.write('\\r          \\r')\n                break\n            elif c in ('\\r', '\\n'):\n                sys.stdout.write('\\r          \\r' + lines[r] + '\\n')\n                r = r + 1\n                continue\n            if c in ('b', 'B', '\\x1b'):\n                r = r - inc - inc\n                if r < 0: r = 0\n            sys.stdout.write('\\n' + '\\n'.join(lines[r:r+inc]) + '\\n')\n            r = r + inc\n\n    finally:\n        if tty:\n            tty.tcsetattr(fd, tty.TCSAFLUSH, old)\n\ndef plainpager(text):\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    sys.stdout.write(plain(_escape_stdout(text)))\n\ndef describe(thing):\n    \"\"\"Produce a short description of the given thing.\"\"\"\n    if inspect.ismodule(thing):\n        if thing.__name__ in sys.builtin_module_names:\n            return 'built-in module ' + thing.__name__\n        if hasattr(thing, '__path__'):\n            return 'package ' + thing.__name__\n        else:\n            return 'module ' + thing.__name__\n    if inspect.isbuiltin(thing):\n        return 'built-in function ' + thing.__name__\n    if inspect.isgetsetdescriptor(thing):\n        return 'getset descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.ismemberdescriptor(thing):\n        return 'member descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.isclass(thing):\n        return 'class ' + thing.__name__\n    if inspect.isfunction(thing):\n        return 'function ' + thing.__name__\n    if inspect.ismethod(thing):\n        return 'method ' + thing.__name__\n    return type(thing).__name__\n\ndef locate(path, forceload=0):\n    \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\"\n    parts = [part for part in path.split('.') if part]\n    module, n = None, 0\n    while n < len(parts):\n        nextmodule = safeimport('.'.join(parts[:n+1]), forceload)\n        if nextmodule: module, n = nextmodule, n + 1\n        else: break\n    if module:\n        object = module\n    else:\n        object = builtins\n    for part in parts[n:]:\n        try:\n            object = getattr(object, part)\n        except AttributeError:\n            return None\n    return object\n\n# --------------------------------------- interactive interpreter interface\n\ntext = TextDoc()\nplaintext = _PlainTextDoc()\nhtml = HTMLDoc()\n\ndef resolve(thing, forceload=0):\n    \"\"\"Given an object or a path to an object, get the object and its name.\"\"\"\n    if isinstance(thing, str):\n        object = locate(thing, forceload)\n        if object is None:\n            raise ImportError('''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.''' % thing)\n        return object, thing\n    else:\n        name = getattr(thing, '__name__', None)\n        return thing, name if isinstance(name, str) else None\n\ndef render_doc(thing, title='Python Library Documentation: %s', forceload=0,\n        renderer=None):\n    \"\"\"Render text documentation, given an object or a path to an object.\"\"\"\n    if renderer is None:\n        renderer = text\n    object, name = resolve(thing, forceload)\n    desc = describe(object)\n    module = inspect.getmodule(object)\n    if name and '.' in name:\n        desc += ' in ' + name[:name.rfind('.')]\n    elif module and module is not object:\n        desc += ' in module ' + module.__name__\n\n    if not (inspect.ismodule(object) or\n              inspect.isclass(object) or\n              inspect.isroutine(object) or\n              inspect.isdatadescriptor(object) or\n              _getdoc(object)):\n        # If the passed object is a piece of data or an instance,\n        # document its available methods instead of its value.\n        if hasattr(object, '__origin__'):\n            object = object.__origin__\n        else:\n            object = type(object)\n            desc += ' object'\n    return title % desc + '\\n\\n' + renderer.document(object, name)\n\ndef doc(thing, title='Python Library Documentation: %s', forceload=0,\n        output=None):\n    \"\"\"Display text documentation, given an object or a path to an object.\"\"\"\n    try:\n        if output is None:\n            pager(render_doc(thing, title, forceload))\n        else:\n            output.write(render_doc(thing, title, forceload, plaintext))\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)\n\ndef writedoc(thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\"\"\"\n    try:\n        object, name = resolve(thing, forceload)\n        page = html.page(describe(object), html.document(object, name))\n        with open(name + '.html', 'w', encoding='utf-8') as file:\n            file.write(page)\n        print('wrote', name + '.html')\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)\n\ndef writedocs(dir, pkgpath='', done=None):\n    \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\"\n    if done is None: done = {}\n    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):\n        writedoc(modname)\n    return\n\nclass Helper:\n\n    # These dictionaries map a topic name to either an alias, or a tuple\n    # (label, seealso-items).  The \"label\" is the label of the corresponding\n    # section in the .rst file under Doc/ and an index into the dictionary\n    # in pydoc_data/topics.py.\n    #\n    # CAUTION: if you change one of these dictionaries, be sure to adapt the\n    #          list of needed labels in Doc/tools/extensions/pyspecific.py and\n    #          regenerate the pydoc_data/topics.py file by running\n    #              make pydoc-topics\n    #          in Doc/ and copying the output file into the Lib/ directory.\n\n    keywords = {\n        'False': '',\n        'None': '',\n        'True': '',\n        'and': 'BOOLEAN',\n        'as': 'with',\n        'assert': ('assert', ''),\n        'async': ('async', ''),\n        'await': ('await', ''),\n        'break': ('break', 'while for'),\n        'class': ('class', 'CLASSES SPECIALMETHODS'),\n        'continue': ('continue', 'while for'),\n        'def': ('function', ''),\n        'del': ('del', 'BASICMETHODS'),\n        'elif': 'if',\n        'else': ('else', 'while for'),\n        'except': 'try',\n        'finally': 'try',\n        'for': ('for', 'break continue while'),\n        'from': 'import',\n        'global': ('global', 'nonlocal NAMESPACES'),\n        'if': ('if', 'TRUTHVALUE'),\n        'import': ('import', 'MODULES'),\n        'in': ('in', 'SEQUENCEMETHODS'),\n        'is': 'COMPARISON',\n        'lambda': ('lambda', 'FUNCTIONS'),\n        'nonlocal': ('nonlocal', 'global NAMESPACES'),\n        'not': 'BOOLEAN',\n        'or': 'BOOLEAN',\n        'pass': ('pass', ''),\n        'raise': ('raise', 'EXCEPTIONS'),\n        'return': ('return', 'FUNCTIONS'),\n        'try': ('try', 'EXCEPTIONS'),\n        'while': ('while', 'break continue if TRUTHVALUE'),\n        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),\n        'yield': ('yield', ''),\n    }\n    # Either add symbols to this dictionary or to the symbols dictionary\n    # directly: Whichever is easier. They are merged later.\n    _strprefixes = [p + q for p in ('b', 'f', 'r', 'u') for q in (\"'\", '\"')]\n    _symbols_inverse = {\n        'STRINGS' : (\"'\", \"'''\", '\"', '\"\"\"', *_strprefixes),\n        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',\n                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),\n        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),\n        'UNARY' : ('-', '~'),\n        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',\n                                '^=', '<<=', '>>=', '**=', '//='),\n        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),\n        'COMPLEX' : ('j', 'J')\n    }\n    symbols = {\n        '%': 'OPERATORS FORMATTING',\n        '**': 'POWER',\n        ',': 'TUPLES LISTS FUNCTIONS',\n        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',\n        '...': 'ELLIPSIS',\n        ':': 'SLICINGS DICTIONARYLITERALS',\n        '@': 'def class',\n        '\\\\': 'STRINGS',\n        '_': 'PRIVATENAMES',\n        '__': 'PRIVATENAMES SPECIALMETHODS',\n        '`': 'BACKQUOTES',\n        '(': 'TUPLES FUNCTIONS CALLS',\n        ')': 'TUPLES FUNCTIONS CALLS',\n        '[': 'LISTS SUBSCRIPTS SLICINGS',\n        ']': 'LISTS SUBSCRIPTS SLICINGS'\n    }\n    for topic, symbols_ in _symbols_inverse.items():\n        for symbol in symbols_:\n            topics = symbols.get(symbol, topic)\n            if topic not in topics:\n                topics = topics + ' ' + topic\n            symbols[symbol] = topics\n\n    topics = {\n        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '\n                  'FUNCTIONS CLASSES MODULES FILES inspect'),\n        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),\n        'FORMATTING': ('formatstrings', 'OPERATORS'),\n        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),\n        'INTEGER': ('integers', 'int range'),\n        'FLOAT': ('floating', 'float math'),\n        'COMPLEX': ('imaginary', 'complex cmath'),\n        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING range LISTS'),\n        'MAPPINGS': 'DICTIONARIES',\n        'FUNCTIONS': ('typesfunctions', 'def TYPES'),\n        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),\n        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),\n        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),\n        'FRAMEOBJECTS': 'TYPES',\n        'TRACEBACKS': 'TYPES',\n        'NONE': ('bltin-null-object', ''),\n        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),\n        'SPECIALATTRIBUTES': ('specialattrs', ''),\n        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),\n        'MODULES': ('typesmodules', 'import'),\n        'PACKAGES': 'import',\n        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '\n                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '\n                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '\n                        'LISTS DICTIONARIES'),\n        'OPERATORS': 'EXPRESSIONS',\n        'PRECEDENCE': 'EXPRESSIONS',\n        'OBJECTS': ('objects', 'TYPES'),\n        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '\n                           'CALLABLEMETHODS SEQUENCEMETHODS MAPPINGMETHODS '\n                           'NUMBERMETHODS CLASSES'),\n        'BASICMETHODS': ('customization', 'hash repr str SPECIALMETHODS'),\n        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),\n        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),\n        'SEQUENCEMETHODS': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS '\n                             'SPECIALMETHODS'),\n        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),\n        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '\n                          'SPECIALMETHODS'),\n        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),\n        'NAMESPACES': ('naming', 'global nonlocal ASSIGNMENT DELETION DYNAMICFEATURES'),\n        'DYNAMICFEATURES': ('dynamic-features', ''),\n        'SCOPING': 'NAMESPACES',\n        'FRAMES': 'NAMESPACES',\n        'EXCEPTIONS': ('exceptions', 'try except finally raise'),\n        'CONVERSIONS': ('conversions', ''),\n        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),\n        'SPECIALIDENTIFIERS': ('id-classes', ''),\n        'PRIVATENAMES': ('atom-identifiers', ''),\n        'LITERALS': ('atom-literals', 'STRINGS NUMBERS TUPLELITERALS '\n                     'LISTLITERALS DICTIONARYLITERALS'),\n        'TUPLES': 'SEQUENCES',\n        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),\n        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),\n        'LISTLITERALS': ('lists', 'LISTS LITERALS'),\n        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),\n        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),\n        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr ATTRIBUTEMETHODS'),\n        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS'),\n        'SLICINGS': ('slicings', 'SEQUENCEMETHODS'),\n        'CALLS': ('calls', 'EXPRESSIONS'),\n        'POWER': ('power', 'EXPRESSIONS'),\n        'UNARY': ('unary', 'EXPRESSIONS'),\n        'BINARY': ('binary', 'EXPRESSIONS'),\n        'SHIFTING': ('shifting', 'EXPRESSIONS'),\n        'BITWISE': ('bitwise', 'EXPRESSIONS'),\n        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),\n        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),\n        'ASSERTION': 'assert',\n        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),\n        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),\n        'DELETION': 'del',\n        'RETURNING': 'return',\n        'IMPORTING': 'import',\n        'CONDITIONAL': 'if',\n        'LOOPING': ('compound', 'for while break continue'),\n        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),\n        'DEBUGGING': ('debugger', 'pdb'),\n        'CONTEXTMANAGERS': ('context-managers', 'with'),\n    }\n\n    def __init__(self, input=None, output=None):\n        self._input = input\n        self._output = output\n\n    @property\n    def input(self):\n        return self._input or sys.stdin\n\n    @property\n    def output(self):\n        return self._output or sys.stdout\n\n    def __repr__(self):\n        if inspect.stack()[1][3] == '?':\n            self()\n            return ''\n        return '<%s.%s instance>' % (self.__class__.__module__,\n                                     self.__class__.__qualname__)\n\n    _GoInteractive = object()\n    def __call__(self, request=_GoInteractive):\n        if request is not self._GoInteractive:\n            self.help(request)\n        else:\n            self.intro()\n            self.interact()\n            self.output.write('''\nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help> prompt.\n''')\n\n    def interact(self):\n        self.output.write('\\n')\n        while True:\n            try:\n                request = self.getline('help> ')\n                if not request: break\n            except (KeyboardInterrupt, EOFError):\n                break\n            request = request.strip()\n\n            # Make sure significant trailing quoting marks of literals don't\n            # get deleted while cleaning input\n            if (len(request) > 2 and request[0] == request[-1] in (\"'\", '\"')\n                    and request[0] not in request[1:-1]):\n                request = request[1:-1]\n            if request.lower() in ('q', 'quit'): break\n            if request == 'help':\n                self.intro()\n            else:\n                self.help(request)\n\n    def getline(self, prompt):\n        \"\"\"Read one line, using input() when appropriate.\"\"\"\n        if self.input is sys.stdin:\n            return input(prompt)\n        else:\n            self.output.write(prompt)\n            self.output.flush()\n            return self.input.readline()\n\n    def help(self, request):\n        if type(request) is type(''):\n            request = request.strip()\n            if request == 'keywords': self.listkeywords()\n            elif request == 'symbols': self.listsymbols()\n            elif request == 'topics': self.listtopics()\n            elif request == 'modules': self.listmodules()\n            elif request[:8] == 'modules ':\n                self.listmodules(request.split()[1])\n            elif request in self.symbols: self.showsymbol(request)\n            elif request in ['True', 'False', 'None']:\n                # special case these keywords since they are objects too\n                doc(eval(request), 'Help on %s:')\n            elif request in self.keywords: self.showtopic(request)\n            elif request in self.topics: self.showtopic(request)\n            elif request: doc(request, 'Help on %s:', output=self._output)\n            else: doc(str, 'Help on %s:', output=self._output)\n        elif isinstance(request, Helper): self()\n        else: doc(request, 'Help on %s:', output=self._output)\n        self.output.write('\\n')\n\n    def intro(self):\n        self.output.write('''\nWelcome to Python {0}'s help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/{0}/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n\"modules\", \"keywords\", \"symbols\", or \"topics\".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as \"spam\", type \"modules spam\".\n'''.format('%d.%d' % sys.version_info[:2]))\n\n    def list(self, items, columns=4, width=80):\n        items = list(sorted(items))\n        colw = width // columns\n        rows = (len(items) + columns - 1) // columns\n        for row in range(rows):\n            for col in range(columns):\n                i = col * rows + row\n                if i < len(items):\n                    self.output.write(items[i])\n                    if col < columns - 1:\n                        self.output.write(' ' + ' ' * (colw - 1 - len(items[i])))\n            self.output.write('\\n')\n\n    def listkeywords(self):\n        self.output.write('''\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\n''')\n        self.list(self.keywords.keys())\n\n    def listsymbols(self):\n        self.output.write('''\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n''')\n        self.list(self.symbols.keys())\n\n    def listtopics(self):\n        self.output.write('''\nHere is a list of available topics.  Enter any topic name to get more help.\n\n''')\n        self.list(self.topics.keys())\n\n    def showtopic(self, topic, more_xrefs=''):\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            self.output.write('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''')\n            return\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        if type(target) is type(''):\n            return self.showtopic(target, more_xrefs)\n\n        label, xrefs = target\n        try:\n            doc = pydoc_data.topics.topics[label]\n        except KeyError:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        doc = doc.strip() + '\\n'\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        if xrefs:\n            import textwrap\n            text = 'Related help topics: ' + ', '.join(xrefs.split()) + '\\n'\n            wrapped_text = textwrap.wrap(text, 72)\n            doc += '\\n%s\\n' % '\\n'.join(wrapped_text)\n        pager(doc)\n\n    def _gettopic(self, topic, more_xrefs=''):\n        \"\"\"Return unbuffered tuple of (topic, xrefs).\n\n        If an error occurs here, the exception is caught and displayed by\n        the url handler.\n\n        This function duplicates the showtopic method but returns its\n        result directly so it can be formatted for display in an html page.\n        \"\"\"\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            return('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''' , '')\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            raise ValueError('could not find topic')\n        if isinstance(target, str):\n            return self._gettopic(target, more_xrefs)\n        label, xrefs = target\n        doc = pydoc_data.topics.topics[label]\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        return doc, xrefs\n\n    def showsymbol(self, symbol):\n        target = self.symbols[symbol]\n        topic, _, xrefs = target.partition(' ')\n        self.showtopic(topic, xrefs)\n\n    def listmodules(self, key=''):\n        if key:\n            self.output.write('''\nHere is a list of modules whose name or summary contains '{}'.\nIf there are any, enter a module name to get more help.\n\n'''.format(key))\n            apropos(key)\n        else:\n            self.output.write('''\nPlease wait a moment while I gather a list of all available modules...\n\n''')\n            modules = {}\n            def callback(path, modname, desc, modules=modules):\n                if modname and modname[-9:] == '.__init__':\n                    modname = modname[:-9] + ' (package)'\n                if modname.find('.') < 0:\n                    modules[modname] = 1\n            def onerror(modname):\n                callback(None, modname, None)\n            ModuleScanner().run(callback, onerror=onerror)\n            self.list(modules.keys())\n            self.output.write('''\nEnter any module name to get more help.  Or, type \"modules spam\" to search\nfor modules whose name or summary contain the string \"spam\".\n''')\n\nhelp = Helper()\n\nclass ModuleScanner:\n    \"\"\"An interruptible scanner that searches module synopses.\"\"\"\n\n    def run(self, callback, key=None, completer=None, onerror=None):\n        if key: key = key.lower()\n        self.quit = False\n        seen = {}\n\n        for modname in sys.builtin_module_names:\n            if modname != '__main__':\n                seen[modname] = 1\n                if key is None:\n                    callback(None, modname, '')\n                else:\n                    name = __import__(modname).__doc__ or ''\n                    desc = name.split('\\n')[0]\n                    name = modname + ' - ' + desc\n                    if name.lower().find(key) >= 0:\n                        callback(None, modname, desc)\n\n        for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):\n            if self.quit:\n                break\n\n            if key is None:\n                callback(None, modname, '')\n            else:\n                try:\n                    spec = pkgutil._get_spec(importer, modname)\n                except SyntaxError:\n                    # raised by tests for bad coding cookies or BOM\n                    continue\n                loader = spec.loader\n                if hasattr(loader, 'get_source'):\n                    try:\n                        source = loader.get_source(modname)\n                    except Exception:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = source_synopsis(io.StringIO(source)) or ''\n                    if hasattr(loader, 'get_filename'):\n                        path = loader.get_filename(modname)\n                    else:\n                        path = None\n                else:\n                    try:\n                        module = importlib._bootstrap._load(spec)\n                    except ImportError:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = module.__doc__.splitlines()[0] if module.__doc__ else ''\n                    path = getattr(module,'__file__',None)\n                name = modname + ' - ' + desc\n                if name.lower().find(key) >= 0:\n                    callback(path, modname, desc)\n\n        if completer:\n            completer()\n\ndef apropos(key):\n    \"\"\"Print all the one-line module summaries that contain a substring.\"\"\"\n    def callback(path, modname, desc):\n        if modname[-9:] == '.__init__':\n            modname = modname[:-9] + ' (package)'\n        print(modname, desc and '- ' + desc)\n    def onerror(modname):\n        pass\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore') # ignore problems during import\n        ModuleScanner().run(callback, key, onerror=onerror)\n\n# --------------------------------------- enhanced Web browser interface\n\ndef _start_server(urlhandler, hostname, port):\n    \"\"\"Start an HTTP server thread on a specific port.\n\n    Start an HTML/text server thread, so HTML or text documents can be\n    browsed dynamically and interactively with a Web browser.  Example use:\n\n        >>> import time\n        >>> import pydoc\n\n        Define a URL handler.  To determine what the client is asking\n        for, check the URL and content_type.\n\n        Then get or generate some text or HTML code and return it.\n\n        >>> def my_url_handler(url, content_type):\n        ...     text = 'the URL sent was: (%s, %s)' % (url, content_type)\n        ...     return text\n\n        Start server thread on port 0.\n        If you use port 0, the server will pick a random port number.\n        You can then use serverthread.port to get the port number.\n\n        >>> port = 0\n        >>> serverthread = pydoc._start_server(my_url_handler, port)\n\n        Check that the server is really started.  If it is, open browser\n        and get first page.  Use serverthread.url as the starting page.\n\n        >>> if serverthread.serving:\n        ...    import webbrowser\n\n        The next two lines are commented out so a browser doesn't open if\n        doctest is run on this module.\n\n        #...    webbrowser.open(serverthread.url)\n        #True\n\n        Let the server do its thing. We just need to monitor its status.\n        Use time.sleep so the loop doesn't hog the CPU.\n\n        >>> starttime = time.monotonic()\n        >>> timeout = 1                    #seconds\n\n        This is a short timeout for testing purposes.\n\n        >>> while serverthread.serving:\n        ...     time.sleep(.01)\n        ...     if serverthread.serving and time.monotonic() - starttime > timeout:\n        ...          serverthread.stop()\n        ...          break\n\n        Print any errors that may have occurred.\n\n        >>> print(serverthread.error)\n        None\n   \"\"\"\n    import http.server\n    import email.message\n    import select\n    import threading\n\n    class DocHandler(http.server.BaseHTTPRequestHandler):\n\n        def do_GET(self):\n            \"\"\"Process a request from an HTML browser.\n\n            The URL received is in self.path.\n            Get an HTML page from self.urlhandler and send it.\n            \"\"\"\n            if self.path.endswith('.css'):\n                content_type = 'text/css'\n            else:\n                content_type = 'text/html'\n            self.send_response(200)\n            self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)\n            self.end_headers()\n            self.wfile.write(self.urlhandler(\n                self.path, content_type).encode('utf-8'))\n\n        def log_message(self, *args):\n            # Don't log messages.\n            pass\n\n    class DocServer(http.server.HTTPServer):\n\n        def __init__(self, host, port, callback):\n            self.host = host\n            self.address = (self.host, port)\n            self.callback = callback\n            self.base.__init__(self, self.address, self.handler)\n            self.quit = False\n\n        def serve_until_quit(self):\n            while not self.quit:\n                rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)\n                if rd:\n                    self.handle_request()\n            self.server_close()\n\n        def server_activate(self):\n            self.base.server_activate(self)\n            if self.callback:\n                self.callback(self)\n\n    class ServerThread(threading.Thread):\n\n        def __init__(self, urlhandler, host, port):\n            self.urlhandler = urlhandler\n            self.host = host\n            self.port = int(port)\n            threading.Thread.__init__(self)\n            self.serving = False\n            self.error = None\n\n        def run(self):\n            \"\"\"Start the server.\"\"\"\n            try:\n                DocServer.base = http.server.HTTPServer\n                DocServer.handler = DocHandler\n                DocHandler.MessageClass = email.message.Message\n                DocHandler.urlhandler = staticmethod(self.urlhandler)\n                docsvr = DocServer(self.host, self.port, self.ready)\n                self.docserver = docsvr\n                docsvr.serve_until_quit()\n            except Exception as e:\n                self.error = e\n\n        def ready(self, server):\n            self.serving = True\n            self.host = server.host\n            self.port = server.server_port\n            self.url = 'http://%s:%d/' % (self.host, self.port)\n\n        def stop(self):\n            \"\"\"Stop the server and this thread nicely\"\"\"\n            self.docserver.quit = True\n            self.join()\n            # explicitly break a reference cycle: DocServer.callback\n            # has indirectly a reference to ServerThread.\n            self.docserver = None\n            self.serving = False\n            self.url = None\n\n    thread = ServerThread(urlhandler, hostname, port)\n    thread.start()\n    # Wait until thread.serving is True to make sure we are\n    # really up before returning.\n    while not thread.error and not thread.serving:\n        time.sleep(.01)\n    return thread\n\n\ndef _url_handler(url, content_type=\"text/html\"):\n    \"\"\"The pydoc url handler for use with the pydoc server.\n\n    If the content_type is 'text/css', the _pydoc.css style\n    sheet is read and returned if it exits.\n\n    If the content_type is 'text/html', then the result of\n    get_html_page(url) is returned.\n    \"\"\"\n    class _HTMLDoc(HTMLDoc):\n\n        def page(self, title, contents):\n            \"\"\"Format an HTML page.\"\"\"\n            css_path = \"pydoc_data/_pydoc.css\"\n            css_link = (\n                '<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n                css_path)\n            return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n</body></html>''' % (title, css_link, html_navbar(), contents)\n\n        def filelink(self, url, path):\n            return '<a href=\"getfile?key=%s\">%s</a>' % (url, path)\n\n\n    html = _HTMLDoc()\n\n    def html_navbar():\n        version = html.escape(\"%s [%s, %s]\" % (platform.python_version(),\n                                               platform.python_build()[0],\n                                               platform.python_compiler()))\n        return \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:center'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div>\n                    <form action=\"get\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Get\">\n                    </form>&nbsp;\n                    <form action=\"search\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\" % (version, html.escape(platform.platform(terse=True)))\n\n    def html_index():\n        \"\"\"Module Index page.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>Index of Modules</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = [name for name in sys.builtin_module_names\n                 if name != '__main__']\n        contents = html.multicolumn(names, bltinlink)\n        contents = [heading, '<p>' + html.bigsection(\n            'Built-in Modules', '#ffffff', '#ee77aa', contents)]\n\n        seen = {}\n        for dir in sys.path:\n            contents.append(html.index(dir, seen))\n\n        contents.append(\n            '<p align=right><font color=\"#909090\" face=\"helvetica,'\n            'arial\"><strong>pydoc</strong> by Ka-Ping Yee'\n            '&lt;ping@lfw.org&gt;</font>')\n        return 'Index of Modules', ''.join(contents)\n\n    def html_search(key):\n        \"\"\"Search results page.\"\"\"\n        # scan for modules\n        search_result = []\n\n        def callback(path, modname, desc):\n            if modname[-9:] == '.__init__':\n                modname = modname[:-9] + ' (package)'\n            search_result.append((modname, desc and '- ' + desc))\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore') # ignore problems during import\n            def onerror(modname):\n                pass\n            ModuleScanner().run(callback, key, onerror=onerror)\n\n        # format page\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        results = []\n        heading = html.heading(\n            '<big><big><strong>Search Results</strong></big></big>',\n            '#ffffff', '#7799ee')\n        for name, desc in search_result:\n            results.append(bltinlink(name) + desc)\n        contents = heading + html.bigsection(\n            'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n        return 'Search Results', contents\n\n    def html_getfile(path):\n        \"\"\"Get and display a source file listing safely.\"\"\"\n        path = urllib.parse.unquote(path)\n        with tokenize.open(path) as fp:\n            lines = html.escape(fp.read())\n        body = '<pre>%s</pre>' % lines\n        heading = html.heading(\n            '<big><big><strong>File Listing</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = heading + html.bigsection(\n            'File: %s' % path, '#ffffff', '#ee77aa', body)\n        return 'getfile %s' % path, contents\n\n    def html_topics():\n        \"\"\"Index of topic texts available.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.topics.keys())\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Topics', '#ffffff', '#ee77aa', contents)\n        return 'Topics', contents\n\n    def html_keywords():\n        \"\"\"Index of keywords.\"\"\"\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.keywords.keys())\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Keywords', '#ffffff', '#ee77aa', contents)\n        return 'Keywords', contents\n\n    def html_topicpage(topic):\n        \"\"\"Topic or keyword help page.\"\"\"\n        buf = io.StringIO()\n        htmlhelp = Helper(buf, buf)\n        contents, xrefs = htmlhelp._gettopic(topic)\n        if topic in htmlhelp.keywords:\n            title = 'KEYWORD'\n        else:\n            title = 'TOPIC'\n        heading = html.heading(\n            '<big><big><strong>%s</strong></big></big>' % title,\n            '#ffffff', '#7799ee')\n        contents = '<pre>%s</pre>' % html.markup(contents)\n        contents = html.bigsection(topic , '#ffffff','#ee77aa', contents)\n        if xrefs:\n            xrefs = sorted(xrefs.split())\n\n            def bltinlink(name):\n                return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n            xrefs = html.multicolumn(xrefs, bltinlink)\n            xrefs = html.section('Related help topics: ',\n                                 '#ffffff', '#ee77aa', xrefs)\n        return ('%s %s' % (title, topic),\n                ''.join((heading, contents, xrefs)))\n\n    def html_getobj(url):\n        obj = locate(url, forceload=1)\n        if obj is None and url != 'None':\n            raise ValueError('could not find object')\n        title = describe(obj)\n        content = html.document(obj, url)\n        return title, content\n\n    def html_error(url, exc):\n        heading = html.heading(\n            '<big><big><strong>Error</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = '<br>'.join(html.escape(line) for line in\n                               format_exception_only(type(exc), exc))\n        contents = heading + html.bigsection(url, '#ffffff', '#bb0000',\n                                             contents)\n        return \"Error - %s\" % url, contents\n\n    def get_html_page(url):\n        \"\"\"Generate an HTML page for url.\"\"\"\n        complete_url = url\n        if url.endswith('.html'):\n            url = url[:-5]\n        try:\n            if url in (\"\", \"index\"):\n                title, content = html_index()\n            elif url == \"topics\":\n                title, content = html_topics()\n            elif url == \"keywords\":\n                title, content = html_keywords()\n            elif '=' in url:\n                op, _, url = url.partition('=')\n                if op == \"search?key\":\n                    title, content = html_search(url)\n                elif op == \"getfile?key\":\n                    title, content = html_getfile(url)\n                elif op == \"topic?key\":\n                    # try topics first, then objects.\n                    try:\n                        title, content = html_topicpage(url)\n                    except ValueError:\n                        title, content = html_getobj(url)\n                elif op == \"get?key\":\n                    # try objects first, then topics.\n                    if url in (\"\", \"index\"):\n                        title, content = html_index()\n                    else:\n                        try:\n                            title, content = html_getobj(url)\n                        except ValueError:\n                            title, content = html_topicpage(url)\n                else:\n                    raise ValueError('bad pydoc url')\n            else:\n                title, content = html_getobj(url)\n        except Exception as exc:\n            # Catch any errors and display them in an error page.\n            title, content = html_error(complete_url, exc)\n        return html.page(title, content)\n\n    if url.startswith('/'):\n        url = url[1:]\n    if content_type == 'text/css':\n        path_here = os.path.dirname(os.path.realpath(__file__))\n        css_path = os.path.join(path_here, url)\n        with open(css_path) as fp:\n            return ''.join(fp.readlines())\n    elif content_type == 'text/html':\n        return get_html_page(url)\n    # Errors outside the url handler are caught by the server.\n    raise TypeError('unknown content type %r for url %s' % (content_type, url))\n\n\ndef browse(port=0, *, open_browser=True, hostname='localhost'):\n    \"\"\"Start the enhanced pydoc Web server and open a Web browser.\n\n    Use port '0' to start the server on an arbitrary port.\n    Set open_browser to False to suppress opening a browser.\n    \"\"\"\n    import webbrowser\n    serverthread = _start_server(_url_handler, hostname, port)\n    if serverthread.error:\n        print(serverthread.error)\n        return\n    if serverthread.serving:\n        server_help_msg = 'Server commands: [b]rowser, [q]uit'\n        if open_browser:\n            webbrowser.open(serverthread.url)\n        try:\n            print('Server ready at', serverthread.url)\n            print(server_help_msg)\n            while serverthread.serving:\n                cmd = input('server> ')\n                cmd = cmd.lower()\n                if cmd == 'q':\n                    break\n                elif cmd == 'b':\n                    webbrowser.open(serverthread.url)\n                else:\n                    print(server_help_msg)\n        except (KeyboardInterrupt, EOFError):\n            print()\n        finally:\n            if serverthread.serving:\n                serverthread.stop()\n                print('Server stopped')\n\n\n# -------------------------------------------------- command-line interface\n\ndef ispath(x):\n    return isinstance(x, str) and x.find(os.sep) >= 0\n\ndef _get_revised_path(given_path, argv0):\n    \"\"\"Ensures current directory is on returned path, and argv0 directory is not\n\n    Exception: argv0 dir is left alone if it's also pydoc's directory.\n\n    Returns a new path entry list, or None if no adjustment is needed.\n    \"\"\"\n    # Scripts may get the current directory in their path by default if they're\n    # run with the -m switch, or directly from the current directory.\n    # The interactive prompt also allows imports from the current directory.\n\n    # Accordingly, if the current directory is already present, don't make\n    # any changes to the given_path\n    if '' in given_path or os.curdir in given_path or os.getcwd() in given_path:\n        return None\n\n    # Otherwise, add the current directory to the given path, and remove the\n    # script directory (as long as the latter isn't also pydoc's directory.\n    stdlib_dir = os.path.dirname(__file__)\n    script_dir = os.path.dirname(argv0)\n    revised_path = given_path.copy()\n    if script_dir in given_path and not os.path.samefile(script_dir, stdlib_dir):\n        revised_path.remove(script_dir)\n    revised_path.insert(0, os.getcwd())\n    return revised_path\n\n\n# Note: the tests only cover _get_revised_path, not _adjust_cli_path itself\ndef _adjust_cli_sys_path():\n    \"\"\"Ensures current directory is on sys.path, and __main__ directory is not.\n\n    Exception: __main__ dir is left alone if it's also pydoc's directory.\n    \"\"\"\n    revised_path = _get_revised_path(sys.path, sys.argv[0])\n    if revised_path is not None:\n        sys.path[:] = revised_path\n\n\ndef cli():\n    \"\"\"Command-line interface (looks at sys.argv to decide what to do).\"\"\"\n    import getopt\n    class BadUsage(Exception): pass\n\n    _adjust_cli_sys_path()\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'bk:n:p:w')\n        writing = False\n        start_server = False\n        open_browser = False\n        port = 0\n        hostname = 'localhost'\n        for opt, val in opts:\n            if opt == '-b':\n                start_server = True\n                open_browser = True\n            if opt == '-k':\n                apropos(val)\n                return\n            if opt == '-p':\n                start_server = True\n                port = val\n            if opt == '-w':\n                writing = True\n            if opt == '-n':\n                start_server = True\n                hostname = val\n\n        if start_server:\n            browse(port, hostname=hostname, open_browser=open_browser)\n            return\n\n        if not args: raise BadUsage\n        for arg in args:\n            if ispath(arg) and not os.path.exists(arg):\n                print('file %r does not exist' % arg)\n                break\n            try:\n                if ispath(arg) and os.path.isfile(arg):\n                    arg = importfile(arg)\n                if writing:\n                    if ispath(arg) and os.path.isdir(arg):\n                        writedocs(arg)\n                    else:\n                        writedoc(arg)\n                else:\n                    help.help(arg)\n            except ErrorDuringImport as value:\n                print(value)\n\n    except (getopt.error, BadUsage):\n        cmd = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n        print(\"\"\"pydoc - the Python documentation tool\n\n{cmd} <name> ...\n    Show text documentation on something.  <name> may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If <name> contains a '{sep}', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\n{cmd} -k <keyword>\n    Search for a keyword in the synopsis lines of all available modules.\n\n{cmd} -n <hostname>\n    Start an HTTP server with the given hostname (default: localhost).\n\n{cmd} -p <port>\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\n{cmd} -b\n    Start an HTTP server on an arbitrary unused port and open a Web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\n{cmd} -w <name> ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If <name> contains a '{sep}', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\"\"\".format(cmd=cmd, sep=os.sep))\n\nif __name__ == '__main__':\n    cli()\n", "patch": "@@ -2456,9 +2456,6 @@ def page(self, title, contents):\n %s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n </body></html>''' % (title, css_link, html_navbar(), contents)\n \n-        def filelink(self, url, path):\n-            return '<a href=\"getfile?key=%s\">%s</a>' % (url, path)\n-\n \n     html = _HTMLDoc()\n \n@@ -2544,19 +2541,6 @@ def bltinlink(name):\n             'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n         return 'Search Results', contents\n \n-    def html_getfile(path):\n-        \"\"\"Get and display a source file listing safely.\"\"\"\n-        path = urllib.parse.unquote(path)\n-        with tokenize.open(path) as fp:\n-            lines = html.escape(fp.read())\n-        body = '<pre>%s</pre>' % lines\n-        heading = html.heading(\n-            '<big><big><strong>File Listing</strong></big></big>',\n-            '#ffffff', '#7799ee')\n-        contents = heading + html.bigsection(\n-            'File: %s' % path, '#ffffff', '#ee77aa', body)\n-        return 'getfile %s' % path, contents\n-\n     def html_topics():\n         \"\"\"Index of topic texts available.\"\"\"\n \n@@ -2648,8 +2632,6 @@ def get_html_page(url):\n                 op, _, url = url.partition('=')\n                 if op == \"search?key\":\n                     title, content = html_search(url)\n-                elif op == \"getfile?key\":\n-                    title, content = html_getfile(url)\n                 elif op == \"topic?key\":\n                     # try topics first, then objects.\n                     try:", "file_path": "files/2021_5/363", "file_language": "py", "file_name": "Lib/pydoc.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "def pathdirs():\n    \"\"\"Convert sys.path into a list of absolute, existing, unique paths.\"\"\"\n    dirs = []\n    normdirs = []\n    for dir in sys.path:\n        dir = os.path.abspath(dir or '.')\n        normdir = os.path.normcase(dir)\n        if normdir not in normdirs and os.path.isdir(dir):\n            dirs.append(dir)\n            normdirs.append(normdir)\n    return dirs", "target": 0}, {"function": "def _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not inspect.isclass(cls):\n        return None\n    return cls", "target": 0}, {"function": "def _finddoc(obj):\n    if inspect.ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif inspect.isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.ismethoddescriptor(obj) or inspect.isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if inspect.ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = _getowndoc(getattr(base, name))\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None", "target": 0}, {"function": "def _getowndoc(obj):\n    \"\"\"Get the documentation string for an object if it is not\n    inherited from its class.\"\"\"\n    try:\n        doc = object.__getattribute__(obj, '__doc__')\n        if doc is None:\n            return None\n        if obj is not type:\n            typedoc = type(obj).__doc__\n            if isinstance(typedoc, str) and typedoc == doc:\n                return None\n        return doc\n    except AttributeError:\n        return None", "target": 0}, {"function": "def _getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    doc = _getowndoc(object)\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return inspect.cleandoc(doc)", "target": 0}, {"function": "def getdoc(object):\n    \"\"\"Get the doc string or comments for an object.\"\"\"\n    result = _getdoc(object) or inspect.getcomments(object)\n    return result and re.sub('^ *\\n', '', result.rstrip()) or ''", "target": 0}, {"function": "def splitdoc(doc):\n    \"\"\"Split a doc string into a synopsis line (if any) and the rest.\"\"\"\n    lines = doc.strip().split('\\n')\n    if len(lines) == 1:\n        return lines[0], ''\n    elif len(lines) >= 2 and not lines[1].rstrip():\n        return lines[0], '\\n'.join(lines[2:])\n    return '', '\\n'.join(lines)", "target": 0}, {"function": "def classname(object, modname):\n    \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\"\n    name = object.__name__\n    if object.__module__ != modname:\n        name = object.__module__ + '.' + name\n    return name", "target": 0}, {"function": "def isdata(object):\n    \"\"\"Check if an object is of a type that probably means it's data.\"\"\"\n    return not (inspect.ismodule(object) or inspect.isclass(object) or\n                inspect.isroutine(object) or inspect.isframe(object) or\n                inspect.istraceback(object) or inspect.iscode(object))", "target": 0}, {"function": "def replace(text, *pairs):\n    \"\"\"Do a series of global replacements on a string.\"\"\"\n    while pairs:\n        text = pairs[1].join(text.split(pairs[0]))\n        pairs = pairs[2:]\n    return text", "target": 0}, {"function": "def cram(text, maxlen):\n    \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\"\n    if len(text) > maxlen:\n        pre = max(0, (maxlen-3)//2)\n        post = max(0, maxlen-3-pre)\n        return text[:pre] + '...' + text[len(text)-post:]\n    return text", "target": 0}, {"function": "def stripid(text):\n    \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\"\n    # The behaviour of %p is implementation-dependent in terms of case.\n    return _re_stripid.sub(r'\\1', text)", "target": 0}, {"function": "def _is_bound_method(fn):\n    \"\"\"\n    Returns True if fn is a bound method, regardless of whether\n    fn was implemented in Python or in C.\n    \"\"\"\n    if inspect.ismethod(fn):\n        return True\n    if inspect.isbuiltin(fn):\n        self = getattr(fn, '__self__', None)\n        return not (inspect.ismodule(self) or (self is None))\n    return False", "target": 0}, {"function": "def allmethods(cl):\n    methods = {}\n    for key, value in inspect.getmembers(cl, inspect.isroutine):\n        methods[key] = 1\n    for base in cl.__bases__:\n        methods.update(allmethods(base)) # all your base are belong to us\n    for key in methods.keys():\n        methods[key] = getattr(cl, key)\n    return methods", "target": 0}, {"function": "def _split_list(s, predicate):\n    \"\"\"Split sequence s via predicate, and return pair ([true], [false]).\n\n    The return value is a 2-tuple of lists,\n        ([x for x in s if predicate(x)],\n         [x for x in s if not predicate(x)])\n    \"\"\"\n\n    yes = []\n    no = []\n    for x in s:\n        if predicate(x):\n            yes.append(x)\n        else:\n            no.append(x)\n    return yes, no", "target": 0}, {"function": "def visiblename(name, all=None, obj=None):\n    \"\"\"Decide whether to show documentation on a variable.\"\"\"\n    # Certain special names are redundant or internal.\n    # XXX Remove __initializing__?\n    if name in {'__author__', '__builtins__', '__cached__', '__credits__',\n                '__date__', '__doc__', '__file__', '__spec__',\n                '__loader__', '__module__', '__name__', '__package__',\n                '__path__', '__qualname__', '__slots__', '__version__'}:\n        return 0\n    # Private names are hidden, but special names are displayed.\n    if name.startswith('__') and name.endswith('__'): return 1\n    # Namedtuples have public fields and methods with a single leading underscore\n    if name.startswith('_') and hasattr(obj, '_fields'):\n        return True\n    if all is not None:\n        # only document that which the programmer exported in __all__\n        return name in all\n    else:\n        return not name.startswith('_')", "target": 0}, {"function": "def classify_class_attrs(object):\n    \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\"\n    results = []\n    for (name, kind, cls, value) in inspect.classify_class_attrs(object):\n        if inspect.isdatadescriptor(value):\n            kind = 'data descriptor'\n            if isinstance(value, property) and value.fset is None:\n                kind = 'readonly property'\n        results.append((name, kind, cls, value))\n    return results", "target": 0}, {"function": "def sort_attributes(attrs, object):\n    'Sort the attrs list in-place by _fields and then alphabetically by name'\n    # This allows data descriptors to be ordered according\n    # to a _fields attribute if present.\n    fields = getattr(object, '_fields', [])\n    try:\n        field_order = {name : i-len(fields) for (i, name) in enumerate(fields)}\n    except TypeError:\n        field_order = {}\n    keyfunc = lambda attr: (field_order.get(attr[0], 0), attr[0])\n    attrs.sort(key=keyfunc)", "target": 0}, {"function": "def ispackage(path):\n    \"\"\"Guess whether a path refers to a package directory.\"\"\"\n    if os.path.isdir(path):\n        for ext in ('.py', '.pyc'):\n            if os.path.isfile(os.path.join(path, '__init__' + ext)):\n                return True\n    return False", "target": 0}, {"function": "def source_synopsis(file):\n    line = file.readline()\n    while line[:1] == '#' or not line.strip():\n        line = file.readline()\n        if not line: break\n    line = line.strip()\n    if line[:4] == 'r\"\"\"': line = line[1:]\n    if line[:3] == '\"\"\"':\n        line = line[3:]\n        if line[-1:] == '\\\\': line = line[:-1]\n        while not line.strip():\n            line = file.readline()\n            if not line: break\n        result = line.split('\"\"\"')[0].strip()\n    else: result = None\n    return result", "target": 0}, {"function": "def synopsis(filename, cache={}):\n    \"\"\"Get the one-line summary out of a module file.\"\"\"\n    mtime = os.stat(filename).st_mtime\n    lastupdate, result = cache.get(filename, (None, None))\n    if lastupdate is None or lastupdate < mtime:\n        # Look for binary suffixes first, falling back to source.\n        if filename.endswith(tuple(importlib.machinery.BYTECODE_SUFFIXES)):\n            loader_cls = importlib.machinery.SourcelessFileLoader\n        elif filename.endswith(tuple(importlib.machinery.EXTENSION_SUFFIXES)):\n            loader_cls = importlib.machinery.ExtensionFileLoader\n        else:\n            loader_cls = None\n        # Now handle the choice.\n        if loader_cls is None:\n            # Must be a source file.\n            try:\n                file = tokenize.open(filename)\n            except OSError:\n                # module can't be opened, so skip it\n                return None\n            # text modules can be directly examined\n            with file:\n                result = source_synopsis(file)\n        else:\n            # Must be a binary module, which has to be imported.\n            loader = loader_cls('__temp__', filename)\n            # XXX We probably don't need to pass in the loader here.\n            spec = importlib.util.spec_from_file_location('__temp__', filename,\n                                                          loader=loader)\n            try:\n                module = importlib._bootstrap._load(spec)\n            except:\n                return None\n            del sys.modules['__temp__']\n            result = module.__doc__.splitlines()[0] if module.__doc__ else None\n        # Cache the result.\n        cache[filename] = (mtime, result)\n    return result", "target": 0}, {"function": "class ErrorDuringImport(Exception):\n    \"\"\"Errors that occurred while trying to import something to document it.\"\"\"\n    def __init__(self, filename, exc_info):\n        self.filename = filename\n        self.exc, self.value, self.tb = exc_info\n\n    def __str__(self):\n        exc = self.exc.__name__\n        return 'problem in %s - %s: %s' % (self.filename, exc, self.value)", "target": 0}, {"function": "def importfile(path):\n    \"\"\"Import a Python source file or compiled file given its path.\"\"\"\n    magic = importlib.util.MAGIC_NUMBER\n    with open(path, 'rb') as file:\n        is_bytecode = magic == file.read(len(magic))\n    filename = os.path.basename(path)\n    name, ext = os.path.splitext(filename)\n    if is_bytecode:\n        loader = importlib._bootstrap_external.SourcelessFileLoader(name, path)\n    else:\n        loader = importlib._bootstrap_external.SourceFileLoader(name, path)\n    # XXX We probably don't need to pass in the loader here.\n    spec = importlib.util.spec_from_file_location(name, path, loader=loader)\n    try:\n        return importlib._bootstrap._load(spec)\n    except:\n        raise ErrorDuringImport(path, sys.exc_info())", "target": 0}, {"function": "def safeimport(path, forceload=0, cache={}):\n    \"\"\"Import a module; handle errors; return None if the module isn't found.\n\n    If the module *is* found but an exception occurs, it's wrapped in an\n    ErrorDuringImport exception and reraised.  Unlike __import__, if a\n    package path is specified, the module at the end of the path is returned,\n    not the package at the beginning.  If the optional 'forceload' argument\n    is 1, we reload the module from disk (unless it's a dynamic extension).\"\"\"\n    try:\n        # If forceload is 1 and the module has been previously loaded from\n        # disk, we always have to reload the module.  Checking the file's\n        # mtime isn't good enough (e.g. the module could contain a class\n        # that inherits from another module that has changed).\n        if forceload and path in sys.modules:\n            if path not in sys.builtin_module_names:\n                # Remove the module from sys.modules and re-import to try\n                # and avoid problems with partially loaded modules.\n                # Also remove any submodules because they won't appear\n                # in the newly loaded module's namespace if they're already\n                # in sys.modules.\n                subs = [m for m in sys.modules if m.startswith(path + '.')]\n                for key in [path] + subs:\n                    # Prevent garbage collection.\n                    cache[key] = sys.modules[key]\n                    del sys.modules[key]\n        module = __import__(path)\n    except:\n        # Did the error occur before or after the module was found?\n        (exc, value, tb) = info = sys.exc_info()\n        if path in sys.modules:\n            # An error occurred while executing the imported module.\n            raise ErrorDuringImport(sys.modules[path].__file__, info)\n        elif exc is SyntaxError:\n            # A SyntaxError occurred before we could execute the module.\n            raise ErrorDuringImport(value.filename, info)\n        elif issubclass(exc, ImportError) and value.name == path:\n            # No such module in the path.\n            return None\n        else:\n            # Some other error occurred during the importing process.\n            raise ErrorDuringImport(path, sys.exc_info())\n    for part in path.split('.')[1:]:\n        try: module = getattr(module, part)\n        except AttributeError: return None\n    return module", "target": 0}, {"function": "class Doc:\n\n    PYTHONDOCS = os.environ.get(\"PYTHONDOCS\",\n                                \"https://docs.python.org/%d.%d/library\"\n                                % sys.version_info[:2])\n\n    def document(self, object, name=None, *args):\n        \"\"\"Generate documentation for an object.\"\"\"\n        args = (object, name) + args\n        # 'try' clause is to attempt to handle the possibility that inspect\n        # identifies something in a way that pydoc itself has issues handling;\n        # think 'super' and how it is a descriptor (which raises the exception\n        # by lacking a __name__ attribute) and an instance.\n        try:\n            if inspect.ismodule(object): return self.docmodule(*args)\n            if inspect.isclass(object): return self.docclass(*args)\n            if inspect.isroutine(object): return self.docroutine(*args)\n        except AttributeError:\n            pass\n        if inspect.isdatadescriptor(object): return self.docdata(*args)\n        return self.docother(*args)\n\n    def fail(self, object, name=None, *args):\n        \"\"\"Raise an exception for unimplemented types.\"\"\"\n        message = \"don't know how to document object%s of type %s\" % (\n            name and ' ' + repr(name), type(object).__name__)\n        raise TypeError(message)\n\n    docmodule = docclass = docroutine = docother = docproperty = docdata = fail\n\n    def getdocloc(self, object, basedir=sysconfig.get_path('stdlib')):\n        \"\"\"Return the location of module docs or None\"\"\"\n\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n\n        docloc = os.environ.get(\"PYTHONDOCS\", self.PYTHONDOCS)\n\n        basedir = os.path.normcase(basedir)\n        if (isinstance(object, type(os)) and\n            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',\n                                 'marshal', 'posix', 'signal', 'sys',\n                                 '_thread', 'zipimport') or\n             (file.startswith(basedir) and\n              not file.startswith(os.path.join(basedir, 'site-packages')))) and\n            object.__name__ not in ('xml.etree', 'test.pydoc_mod')):\n            if docloc.startswith((\"http://\", \"https://\")):\n                docloc = \"{}/{}.html\".format(docloc.rstrip(\"/\"), object.__name__.lower())\n            else:\n                docloc = os.path.join(docloc, object.__name__.lower() + \".html\")\n        else:\n            docloc = None\n        return docloc", "target": 0}, {"function": "class HTMLRepr(Repr):\n    \"\"\"Class for safely making an HTML representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def escape(self, text):\n        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')\n\n    def repr(self, object):\n        return Repr.repr(self, object)\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return self.escape(cram(stripid(repr(x)), self.maxother))\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + self.escape(test) + testrepr[0]\n        return re.sub(r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)',\n                      r'<font color=\"#c040c0\">\\1</font>',\n                      self.escape(testrepr))\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return self.escape(cram(stripid(repr(x)), self.maxstring))\n        except:\n            return self.escape('<%s instance>' % x.__class__.__name__)\n\n    repr_unicode = repr_string", "target": 0}, {"function": "class HTMLDoc(Doc):\n    \"\"\"Formatter class for HTML documentation.\"\"\"\n\n    # ------------------------------------------- HTML formatting utilities\n\n    _repr_instance = HTMLRepr()\n    repr = _repr_instance.repr\n    escape = _repr_instance.escape\n\n    def page(self, title, contents):\n        \"\"\"Format an HTML page.\"\"\"\n        return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Python: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head><body bgcolor=\"#f0f0f8\">\n%s\n</body></html>''' % (title, contents)\n\n    def heading(self, title, fgcol, bgcol, extras=''):\n        \"\"\"Format a page heading.\"\"\"\n        return '''\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"%s\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">&nbsp;<br>%s</font></td\n><td align=right valign=bottom\n><font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr></table>\n    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')\n\n    def section(self, title, fgcol, bgcol, contents, width=6,\n                prelude='', marginalia=None, gap='&nbsp;'):\n        \"\"\"Format a section with a heading.\"\"\"\n        if marginalia is None:\n            marginalia = '<tt>' + '&nbsp;' * width + '</tt>'\n        result = '''<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"%s\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr>\n    ''' % (bgcol, fgcol, title)\n        if prelude:\n            result = result + '''\n<tr bgcolor=\"%s\"><td rowspan=2>%s</td>\n<td colspan=2>%s</td></tr>\n<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)\n        else:\n            result = result + '''\n<tr><td bgcolor=\"%s\">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)\n\n        return result + '\\n<td width=\"100%%\">%s</td></tr></table>' % contents\n\n    def bigsection(self, title, *args):\n        \"\"\"Format a section with a big heading.\"\"\"\n        title = '<big><strong>%s</strong></big>' % title\n        return self.section(title, *args)\n\n    def preformat(self, text):\n        \"\"\"Format literal preformatted text.\"\"\"\n        text = self.escape(text.expandtabs())\n        return replace(text, '\\n\\n', '\\n \\n', '\\n\\n', '\\n \\n',\n                             ' ', '&nbsp;', '\\n', '<br>\\n')\n\n    def multicolumn(self, list, format, cols=4):\n        \"\"\"Format a list of items into a multi-column list.\"\"\"\n        result = ''\n        rows = (len(list)+cols-1)//cols\n        for col in range(cols):\n            result = result + '<td width=\"%d%%\" valign=top>' % (100//cols)\n            for i in range(rows*col, rows*col+rows):\n                if i < len(list):\n                    result = result + format(list[i]) + '<br>\\n'\n            result = result + '</td>'\n        return '<table width=\"100%%\" summary=\"list\"><tr>%s</tr></table>' % result\n\n    def grey(self, text): return '<font color=\"#909090\">%s</font>' % text\n\n    def namelink(self, name, *dicts):\n        \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\"\n        for dict in dicts:\n            if name in dict:\n                return '<a href=\"%s\">%s</a>' % (dict[name], name)\n        return name\n\n    def classlink(self, object, modname):\n        \"\"\"Make a link for a class.\"\"\"\n        name, module = object.__name__, sys.modules.get(object.__module__)\n        if hasattr(module, name) and getattr(module, name) is object:\n            return '<a href=\"%s.html#%s\">%s</a>' % (\n                module.__name__, name, classname(object, modname))\n        return classname(object, modname)\n\n    def modulelink(self, object):\n        \"\"\"Make a link for a module.\"\"\"\n        return '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n\n    def modpkglink(self, modpkginfo):\n        \"\"\"Make a link for a module or package to display in an index.\"\"\"\n        name, path, ispackage, shadowed = modpkginfo\n        if shadowed:\n            return self.grey(name)\n        if path:\n            url = '%s.%s.html' % (path, name)\n        else:\n            url = '%s.html' % name\n        if ispackage:\n            text = '<strong>%s</strong>&nbsp;(package)' % name\n        else:\n            text = name\n        return '<a href=\"%s\">%s</a>' % (url, text)\n\n    def filelink(self, url, path):\n        \"\"\"Make a link to source file.\"\"\"\n        return '<a href=\"file:%s\">%s</a>' % (url, path)\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n        pattern = re.compile(r'\\b((http|https|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?(\\w+))')\n        while True:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif selfdot:\n                # Create a link for methods like 'self.method(...)'\n                # and use <strong> for attributes like 'self.attr'\n                if text[end:end+1] == '(':\n                    results.append('self.' + self.namelink(name, methods))\n                else:\n                    results.append('self.<strong>%s</strong>' % name)\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None):\n        \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + '<dt><font face=\"helvetica, arial\">'\n                result = result + self.classlink(c, modname)\n                if bases and bases != (parent,):\n                    parents = []\n                    for base in bases:\n                        parents.append(self.classlink(base, modname))\n                    result = result + '(' + ', '.join(parents) + ')'\n                result = result + '\\n</font></dt>'\n            elif type(entry) is type([]):\n                result = result + '<dd>\\n%s</dd>\\n' % self.formattree(\n                    entry, modname, c)\n        return '<dl>\\n%s</dl>\\n' % result\n\n    def docmodule(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        try:\n            all = object.__all__\n        except AttributeError:\n            all = None\n        parts = name.split('.')\n        links = []\n        for i in range(len(parts)-1):\n            links.append(\n                '<a href=\"%s.html\"><font color=\"#ffffff\">%s</font></a>' %\n                ('.'.join(parts[:i+1]), parts[i]))\n        linkedname = '.'.join(links + parts[-1:])\n        head = '<big><big><strong>%s</strong></big></big>' % linkedname\n        try:\n            path = inspect.getabsfile(object)\n            url = urllib.parse.quote(path)\n            filelink = self.filelink(url, path)\n        except TypeError:\n            filelink = '(built-in)'\n        info = []\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            info.append('version %s' % self.escape(version))\n        if hasattr(object, '__date__'):\n            info.append(self.escape(str(object.__date__)))\n        if info:\n            head = head + ' (%s)' % ', '.join(info)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            docloc = '<br><a href=\"%(docloc)s\">Module Reference</a>' % locals()\n        else:\n            docloc = ''\n        result = self.heading(\n            head, '#ffffff', '#7799ee',\n            '<a href=\".\">index</a><br>' + filelink + docloc)\n\n        modules = inspect.getmembers(object, inspect.ismodule)\n\n        classes, cdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n                    cdict[key] = cdict[value] = '#' + key\n        for key, value in classes:\n            for base in value.__bases__:\n                key, modname = base.__name__, base.__module__\n                module = sys.modules.get(modname)\n                if modname != name and module and hasattr(module, key):\n                    if getattr(module, key) is base:\n                        if not key in cdict:\n                            cdict[key] = cdict[base] = modname + '.html#' + key\n        funcs, fdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n                    fdict[key] = '#-' + key\n                    if inspect.isfunction(value): fdict[value] = fdict[key]\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        doc = self.markup(getdoc(object), self.preformat, fdict, cdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        if hasattr(object, '__path__'):\n            modpkgs = []\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs.append((modname, name, ispkg, 0))\n            modpkgs.sort()\n            contents = self.multicolumn(modpkgs, self.modpkglink)\n            result = result + self.bigsection(\n                'Package Contents', '#ffffff', '#aa55cc', contents)\n        elif modules:\n            contents = self.multicolumn(\n                modules, lambda t: self.modulelink(t[1]))\n            result = result + self.bigsection(\n                'Modules', '#ffffff', '#aa55cc', contents)\n\n        if classes:\n            classlist = [value for (key, value) in classes]\n            contents = [\n                self.formattree(inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Classes', '#ffffff', '#ee77aa', ' '.join(contents))\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Functions', '#ffffff', '#eeaa77', ' '.join(contents))\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.document(value, key))\n            result = result + self.bigsection(\n                'Data', '#ffffff', '#55aa55', '<br>\\n'.join(contents))\n        if hasattr(object, '__author__'):\n            contents = self.markup(str(object.__author__), self.preformat)\n            result = result + self.bigsection(\n                'Author', '#ffffff', '#7799ee', contents)\n        if hasattr(object, '__credits__'):\n            contents = self.markup(str(object.__credits__), self.preformat)\n            result = result + self.bigsection(\n                'Credits', '#ffffff', '#7799ee', contents)\n\n        return result\n\n    def docclass(self, object, name=None, mod=None, funcs={}, classes={},\n                 *ignored):\n        \"\"\"Produce HTML documentation for a class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        contents = []\n        push = contents.append\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('<hr>\\n')\n                self.needone = 1\n        hr = HorizontalRule()\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            hr.maybe()\n            push('<dl><dt>Method resolution order:</dt>\\n')\n            for base in mro:\n                push('<dd>%s</dd>\\n' % self.classlink(base,\n                                                      object.__module__))\n            push('</dl>\\n')\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value, name, mod,\n                                        funcs, classes, mdict, object))\n                    push('\\n')\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    base = self.docother(getattr(object, name), name, mod)\n                    doc = getdoc(value)\n                    if not doc:\n                        push('<dl><dt>%s</dl>\\n' % base)\n                    else:\n                        doc = self.markup(getdoc(value), self.preformat,\n                                          funcs, classes, mdict)\n                        doc = '<dd><tt>%s</tt>' % doc\n                        push('<dl><dt>%s%s</dl>\\n' % (base, doc))\n                    push('\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        mdict = {}\n        for key, kind, homecls, value in attrs:\n            mdict[key] = anchor = '#' + name + '-' + key\n            try:\n                value = getattr(object, name)\n            except Exception:\n                # Some descriptors may meet a failure in their __get__.\n                # (bug #1785)\n                pass\n            try:\n                # The value may not be hashable (e.g., a data attr with\n                # a dict or list value).\n                mdict[value] = anchor\n            except TypeError:\n                pass\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = 'defined here'\n            else:\n                tag = 'inherited from %s' % self.classlink(thisclass,\n                                                           object.__module__)\n            tag += ':<br>\\n'\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill('Methods %s' % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill('Class methods %s' % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill('Static methods %s' % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata('Data and other attributes %s' % tag, attrs,\n                              lambda t: t[1] == 'data')\n            assert attrs == []\n            attrs = inherited\n\n        contents = ''.join(contents)\n\n        if name == realname:\n            title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n                name, realname)\n        else:\n            title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n                name, name, realname)\n        if bases:\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, object.__module__))\n            title = title + '(%s)' % ', '.join(parents)\n\n        decl = ''\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                decl = name + self.escape(argspec) + '\\n\\n'\n\n        doc = getdoc(object)\n        if decl:\n            doc = decl + (doc or '')\n        doc = self.markup(doc, self.preformat, funcs, classes, mdict)\n        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n\n        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return self.grey('=' + self.repr(object))\n\n    def docroutine(self, object, name=None, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + self.classlink(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % self.classlink(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % self.classlink(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = '<a name=\"%s\"><strong>%s</strong></a>' % (anchor, realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                reallink = '<a href=\"#%s\">%s</a>' % (\n                    cl.__name__ + '-' + realname, realname)\n                skipdocs = 1\n            else:\n                reallink = realname\n            title = '<a name=\"%s\"><strong>%s</strong></a> = %s' % (\n                anchor, name, reallink)\n        argspec = None\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = '<strong>%s</strong> <em>lambda</em> ' % name\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n\n        decl = asyncqualifier + title + self.escape(argspec) + (note and\n               self.grey('<font face=\"helvetica, arial\">%s</font>' % note))\n\n        if skipdocs:\n            return '<dl><dt>%s</dt></dl>\\n' % decl\n        else:\n            doc = self.markup(\n                getdoc(object), self.preformat, funcs, classes, methods)\n            doc = doc and '<dd><tt>%s</tt></dd>' % doc\n            return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce html documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push('<dl><dt><strong>%s</strong></dt>\\n' % name)\n        doc = self.markup(getdoc(object), self.preformat)\n        if doc:\n            push('<dd><tt>%s</tt></dd>\\n' % doc)\n        push('</dl>\\n')\n\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a data object.\"\"\"\n        lhs = name and '<strong>%s</strong> = ' % name or ''\n        return lhs + self.repr(object)\n\n    def index(self, dir, shadowed=None):\n        \"\"\"Generate an HTML index for a directory of modules.\"\"\"\n        modpkgs = []\n        if shadowed is None: shadowed = {}\n        for importer, name, ispkg in pkgutil.iter_modules([dir]):\n            if any((0xD800 <= ord(ch) <= 0xDFFF) for ch in name):\n                # ignore a module if its name contains a surrogate character\n                continue\n            modpkgs.append((name, '', ispkg, name in shadowed))\n            shadowed[name] = 1\n\n        modpkgs.sort()\n        contents = self.multicolumn(modpkgs, self.modpkglink)\n        return self.bigsection(dir, '#ffffff', '#ee77aa', contents)", "target": 0}, {"function": "class TextRepr(Repr):\n    \"\"\"Class for safely making a text representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return cram(stripid(repr(x)), self.maxother)\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + test + testrepr[0]\n        return testrepr\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return cram(stripid(repr(x)), self.maxstring)\n        except:\n            return '<%s instance>' % x.__class__.__name__", "target": 0}, {"function": "class TextDoc(Doc):\n    \"\"\"Formatter class for text documentation.\"\"\"\n\n    # ------------------------------------------- text formatting utilities\n\n    _repr_instance = TextRepr()\n    repr = _repr_instance.repr\n\n    def bold(self, text):\n        \"\"\"Format a string in bold by overstriking.\"\"\"\n        return ''.join(ch + '\\b' + ch for ch in text)\n\n    def indent(self, text, prefix='    '):\n        \"\"\"Indent text by prepending a given prefix to each line.\"\"\"\n        if not text: return ''\n        lines = [prefix + line for line in text.split('\\n')]\n        if lines: lines[-1] = lines[-1].rstrip()\n        return '\\n'.join(lines)\n\n    def section(self, title, contents):\n        \"\"\"Format a section with a given heading.\"\"\"\n        clean_contents = self.indent(contents).rstrip()\n        return self.bold(title) + '\\n' + clean_contents + '\\n\\n'\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None, prefix=''):\n        \"\"\"Render in text a class tree as returned by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + prefix + classname(c, modname)\n                if bases and bases != (parent,):\n                    parents = (classname(c, modname) for c in bases)\n                    result = result + '(%s)' % ', '.join(parents)\n                result = result + '\\n'\n            elif type(entry) is type([]):\n                result = result + self.formattree(\n                    entry, modname, c, prefix + '    ')\n        return result\n\n    def docmodule(self, object, name=None, mod=None):\n        \"\"\"Produce text documentation for a given module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        synop, desc = splitdoc(getdoc(object))\n        result = self.section('NAME', name + (synop and ' - ' + synop))\n        all = getattr(object, '__all__', None)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            result = result + self.section('MODULE REFERENCE', docloc + \"\"\"\n\nThe following documentation is automatically generated from the Python\nsource files.  It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations.  When in doubt, consult the module reference at the\nlocation listed above.\n\"\"\")\n\n        if desc:\n            result = result + self.section('DESCRIPTION', desc)\n\n        classes = []\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None\n                or (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n        funcs = []\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        modpkgs = []\n        modpkgs_names = set()\n        if hasattr(object, '__path__'):\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs_names.add(modname)\n                if ispkg:\n                    modpkgs.append(modname + ' (package)')\n                else:\n                    modpkgs.append(modname)\n\n            modpkgs.sort()\n            result = result + self.section(\n                'PACKAGE CONTENTS', '\\n'.join(modpkgs))\n\n        # Detect submodules as sometimes created by C extensions\n        submodules = []\n        for key, value in inspect.getmembers(object, inspect.ismodule):\n            if value.__name__.startswith(name + '.') and key not in modpkgs_names:\n                submodules.append(key)\n        if submodules:\n            submodules.sort()\n            result = result + self.section(\n                'SUBMODULES', '\\n'.join(submodules))\n\n        if classes:\n            classlist = [value for key, value in classes]\n            contents = [self.formattree(\n                inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('CLASSES', '\\n'.join(contents))\n\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('FUNCTIONS', '\\n'.join(contents))\n\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.docother(value, key, name, maxlen=70))\n            result = result + self.section('DATA', '\\n'.join(contents))\n\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            result = result + self.section('VERSION', version)\n        if hasattr(object, '__date__'):\n            result = result + self.section('DATE', str(object.__date__))\n        if hasattr(object, '__author__'):\n            result = result + self.section('AUTHOR', str(object.__author__))\n        if hasattr(object, '__credits__'):\n            result = result + self.section('CREDITS', str(object.__credits__))\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n        result = result + self.section('FILE', file)\n        return result\n\n    def docclass(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce text documentation for a given class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        def makename(c, m=object.__module__):\n            return classname(c, m)\n\n        if name == realname:\n            title = 'class ' + self.bold(realname)\n        else:\n            title = self.bold(name) + ' = class ' + realname\n        if bases:\n            parents = map(makename, bases)\n            title = title + '(%s)' % ', '.join(parents)\n\n        contents = []\n        push = contents.append\n\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                push(name + argspec + '\\n')\n\n        doc = getdoc(object)\n        if doc:\n            push(doc + '\\n')\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            push(\"Method resolution order:\")\n            for base in mro:\n                push('    ' + makename(base))\n            push('')\n\n        # List the built-in subclasses, if any:\n        subclasses = sorted(\n            (str(cls.__name__) for cls in type.__subclasses__(object)\n             if not cls.__name__.startswith(\"_\") and cls.__module__ == \"builtins\"),\n            key=str.lower\n        )\n        no_of_subclasses = len(subclasses)\n        MAX_SUBCLASSES_TO_DISPLAY = 4\n        if subclasses:\n            push(\"Built-in subclasses:\")\n            for subclassname in subclasses[:MAX_SUBCLASSES_TO_DISPLAY]:\n                push('    ' + subclassname)\n            if no_of_subclasses > MAX_SUBCLASSES_TO_DISPLAY:\n                push('    ... and ' +\n                     str(no_of_subclasses - MAX_SUBCLASSES_TO_DISPLAY) +\n                     ' other subclasses')\n            push('')\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('-' * 70)\n                self.needone = 1\n        hr = HorizontalRule()\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value,\n                                        name, mod, object))\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    doc = getdoc(value)\n                    try:\n                        obj = getattr(object, name)\n                    except AttributeError:\n                        obj = homecls.__dict__[name]\n                    push(self.docother(obj, name, mod, maxlen=70, doc=doc) +\n                         '\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = \"defined here\"\n            else:\n                tag = \"inherited from %s\" % classname(thisclass,\n                                                      object.__module__)\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill(\"Methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill(\"Class methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill(\"Static methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors(\"Data descriptors %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata(\"Data and other attributes %s:\\n\" % tag, attrs,\n                              lambda t: t[1] == 'data')\n\n            assert attrs == []\n            attrs = inherited\n\n        contents = '\\n'.join(contents)\n        if not contents:\n            return title + '\\n'\n        return title + '\\n' + self.indent(contents.rstrip(), ' |  ') + '\\n'\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return '=' + self.repr(object)\n\n    def docroutine(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + classname(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % classname(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % classname(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = self.bold(realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                skipdocs = 1\n            title = self.bold(name) + ' = ' + realname\n        argspec = None\n\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = self.bold(name) + ' lambda '\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n        decl = asyncqualifier + title + argspec + note\n\n        if skipdocs:\n            return decl + '\\n'\n        else:\n            doc = getdoc(object) or ''\n            return decl + '\\n' + (doc and self.indent(doc).rstrip() + '\\n')\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push(self.bold(name))\n            push('\\n')\n        doc = getdoc(object) or ''\n        if doc:\n            push(self.indent(doc))\n            push('\\n')\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):\n        \"\"\"Produce text documentation for a data object.\"\"\"\n        repr = self.repr(object)\n        if maxlen:\n            line = (name and name + ' = ' or '') + repr\n            chop = maxlen - len(line)\n            if chop < 0: repr = repr[:chop] + '...'\n        line = (name and self.bold(name) + ' = ' or '') + repr\n        if not doc:\n            doc = getdoc(object)\n        if doc:\n            line += '\\n' + self.indent(str(doc)) + '\\n'\n        return line", "target": 0}, {"function": "class _PlainTextDoc(TextDoc):\n    \"\"\"Subclass of TextDoc which overrides string styling\"\"\"\n    def bold(self, text):\n        return text", "target": 0}, {"function": "def pager(text):\n    \"\"\"The first time this is called, determine what kind of pager to use.\"\"\"\n    global pager\n    pager = getpager()\n    pager(text)", "target": 0}, {"function": "def getpager():\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    if not hasattr(sys.stdin, \"isatty\"):\n        return plainpager\n    if not hasattr(sys.stdout, \"isatty\"):\n        return plainpager\n    if not sys.stdin.isatty() or not sys.stdout.isatty():\n        return plainpager\n    use_pager = os.environ.get('MANPAGER') or os.environ.get('PAGER')\n    if use_pager:\n        if sys.platform == 'win32': # pipes completely broken in Windows\n            return lambda text: tempfilepager(plain(text), use_pager)\n        elif os.environ.get('TERM') in ('dumb', 'emacs'):\n            return lambda text: pipepager(plain(text), use_pager)\n        else:\n            return lambda text: pipepager(text, use_pager)\n    if os.environ.get('TERM') in ('dumb', 'emacs'):\n        return plainpager\n    if sys.platform == 'win32':\n        return lambda text: tempfilepager(plain(text), 'more <')\n    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n        return lambda text: pipepager(text, 'less')\n\n    import tempfile\n    (fd, filename) = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n            return lambda text: pipepager(text, 'more')\n        else:\n            return ttypager\n    finally:\n        os.unlink(filename)", "target": 0}, {"function": "def plain(text):\n    \"\"\"Remove boldface formatting from text.\"\"\"\n    return re.sub('.\\b', '', text)", "target": 0}, {"function": "def pipepager(text, cmd):\n    \"\"\"Page through text by feeding it to another program.\"\"\"\n    import subprocess\n    proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE)\n    try:\n        with io.TextIOWrapper(proc.stdin, errors='backslashreplace') as pipe:\n            try:\n                pipe.write(text)\n            except KeyboardInterrupt:\n                # We've hereby abandoned whatever text hasn't been written,\n                # but the pager is still in control of the terminal.\n                pass\n    except OSError:\n        pass # Ignore broken pipes caused by quitting the pager program.\n    while True:\n        try:\n            proc.wait()\n            break\n        except KeyboardInterrupt:\n            # Ignore ctl-c like the pager itself does.  Otherwise the pager is\n            # left running and the terminal is in raw mode and unusable.\n            pass", "target": 0}, {"function": "def tempfilepager(text, cmd):\n    \"\"\"Page through text by invoking a program on a temporary file.\"\"\"\n    import tempfile\n    filename = tempfile.mktemp()\n    with open(filename, 'w', errors='backslashreplace') as file:\n        file.write(text)\n    try:\n        os.system(cmd + ' \"' + filename + '\"')\n    finally:\n        os.unlink(filename)", "target": 0}, {"function": "def _escape_stdout(text):\n    # Escape non-encodable characters to avoid encoding errors later\n    encoding = getattr(sys.stdout, 'encoding', None) or 'utf-8'\n    return text.encode(encoding, 'backslashreplace').decode(encoding)", "target": 0}, {"function": "def ttypager(text):\n    \"\"\"Page through text on a text terminal.\"\"\"\n    lines = plain(_escape_stdout(text)).split('\\n')\n    try:\n        import tty\n        fd = sys.stdin.fileno()\n        old = tty.tcgetattr(fd)\n        tty.setcbreak(fd)\n        getchar = lambda: sys.stdin.read(1)\n    except (ImportError, AttributeError, io.UnsupportedOperation):\n        tty = None\n        getchar = lambda: sys.stdin.readline()[:-1][:1]\n\n    try:\n        try:\n            h = int(os.environ.get('LINES', 0))\n        except ValueError:\n            h = 0\n        if h <= 1:\n            h = 25\n        r = inc = h - 1\n        sys.stdout.write('\\n'.join(lines[:inc]) + '\\n')\n        while lines[r:]:\n            sys.stdout.write('-- more --')\n            sys.stdout.flush()\n            c = getchar()\n\n            if c in ('q', 'Q'):\n                sys.stdout.write('\\r          \\r')\n                break\n            elif c in ('\\r', '\\n'):\n                sys.stdout.write('\\r          \\r' + lines[r] + '\\n')\n                r = r + 1\n                continue\n            if c in ('b', 'B', '\\x1b'):\n                r = r - inc - inc\n                if r < 0: r = 0\n            sys.stdout.write('\\n' + '\\n'.join(lines[r:r+inc]) + '\\n')\n            r = r + inc\n\n    finally:\n        if tty:\n            tty.tcsetattr(fd, tty.TCSAFLUSH, old)", "target": 0}, {"function": "def plainpager(text):\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    sys.stdout.write(plain(_escape_stdout(text)))", "target": 0}, {"function": "def describe(thing):\n    \"\"\"Produce a short description of the given thing.\"\"\"\n    if inspect.ismodule(thing):\n        if thing.__name__ in sys.builtin_module_names:\n            return 'built-in module ' + thing.__name__\n        if hasattr(thing, '__path__'):\n            return 'package ' + thing.__name__\n        else:\n            return 'module ' + thing.__name__\n    if inspect.isbuiltin(thing):\n        return 'built-in function ' + thing.__name__\n    if inspect.isgetsetdescriptor(thing):\n        return 'getset descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.ismemberdescriptor(thing):\n        return 'member descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.isclass(thing):\n        return 'class ' + thing.__name__\n    if inspect.isfunction(thing):\n        return 'function ' + thing.__name__\n    if inspect.ismethod(thing):\n        return 'method ' + thing.__name__\n    return type(thing).__name__", "target": 0}, {"function": "def locate(path, forceload=0):\n    \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\"\n    parts = [part for part in path.split('.') if part]\n    module, n = None, 0\n    while n < len(parts):\n        nextmodule = safeimport('.'.join(parts[:n+1]), forceload)\n        if nextmodule: module, n = nextmodule, n + 1\n        else: break\n    if module:\n        object = module\n    else:\n        object = builtins\n    for part in parts[n:]:\n        try:\n            object = getattr(object, part)\n        except AttributeError:\n            return None\n    return object", "target": 0}, {"function": "def resolve(thing, forceload=0):\n    \"\"\"Given an object or a path to an object, get the object and its name.\"\"\"\n    if isinstance(thing, str):\n        object = locate(thing, forceload)\n        if object is None:\n            raise ImportError('''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.''' % thing)\n        return object, thing\n    else:\n        name = getattr(thing, '__name__', None)\n        return thing, name if isinstance(name, str) else None", "target": 0}, {"function": "def render_doc(thing, title='Python Library Documentation: %s', forceload=0,\n        renderer=None):\n    \"\"\"Render text documentation, given an object or a path to an object.\"\"\"\n    if renderer is None:\n        renderer = text\n    object, name = resolve(thing, forceload)\n    desc = describe(object)\n    module = inspect.getmodule(object)\n    if name and '.' in name:\n        desc += ' in ' + name[:name.rfind('.')]\n    elif module and module is not object:\n        desc += ' in module ' + module.__name__\n\n    if not (inspect.ismodule(object) or\n              inspect.isclass(object) or\n              inspect.isroutine(object) or\n              inspect.isdatadescriptor(object) or\n              _getdoc(object)):\n        # If the passed object is a piece of data or an instance,\n        # document its available methods instead of its value.\n        if hasattr(object, '__origin__'):\n            object = object.__origin__\n        else:\n            object = type(object)\n            desc += ' object'\n    return title % desc + '\\n\\n' + renderer.document(object, name)", "target": 0}, {"function": "def doc(thing, title='Python Library Documentation: %s', forceload=0,\n        output=None):\n    \"\"\"Display text documentation, given an object or a path to an object.\"\"\"\n    try:\n        if output is None:\n            pager(render_doc(thing, title, forceload))\n        else:\n            output.write(render_doc(thing, title, forceload, plaintext))\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)", "target": 0}, {"function": "def writedoc(thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\"\"\"\n    try:\n        object, name = resolve(thing, forceload)\n        page = html.page(describe(object), html.document(object, name))\n        with open(name + '.html', 'w', encoding='utf-8') as file:\n            file.write(page)\n        print('wrote', name + '.html')\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)", "target": 0}, {"function": "def writedocs(dir, pkgpath='', done=None):\n    \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\"\n    if done is None: done = {}\n    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):\n        writedoc(modname)\n    return", "target": 0}, {"function": "class Helper:\n\n    # These dictionaries map a topic name to either an alias, or a tuple\n    # (label, seealso-items).  The \"label\" is the label of the corresponding\n    # section in the .rst file under Doc/ and an index into the dictionary\n    # in pydoc_data/topics.py.\n    #\n    # CAUTION: if you change one of these dictionaries, be sure to adapt the\n    #          list of needed labels in Doc/tools/extensions/pyspecific.py and\n    #          regenerate the pydoc_data/topics.py file by running\n    #              make pydoc-topics\n    #          in Doc/ and copying the output file into the Lib/ directory.\n\n    keywords = {\n        'False': '',\n        'None': '',\n        'True': '',\n        'and': 'BOOLEAN',\n        'as': 'with',\n        'assert': ('assert', ''),\n        'async': ('async', ''),\n        'await': ('await', ''),\n        'break': ('break', 'while for'),\n        'class': ('class', 'CLASSES SPECIALMETHODS'),\n        'continue': ('continue', 'while for'),\n        'def': ('function', ''),\n        'del': ('del', 'BASICMETHODS'),\n        'elif': 'if',\n        'else': ('else', 'while for'),\n        'except': 'try',\n        'finally': 'try',\n        'for': ('for', 'break continue while'),\n        'from': 'import',\n        'global': ('global', 'nonlocal NAMESPACES'),\n        'if': ('if', 'TRUTHVALUE'),\n        'import': ('import', 'MODULES'),\n        'in': ('in', 'SEQUENCEMETHODS'),\n        'is': 'COMPARISON',\n        'lambda': ('lambda', 'FUNCTIONS'),\n        'nonlocal': ('nonlocal', 'global NAMESPACES'),\n        'not': 'BOOLEAN',\n        'or': 'BOOLEAN',\n        'pass': ('pass', ''),\n        'raise': ('raise', 'EXCEPTIONS'),\n        'return': ('return', 'FUNCTIONS'),\n        'try': ('try', 'EXCEPTIONS'),\n        'while': ('while', 'break continue if TRUTHVALUE'),\n        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),\n        'yield': ('yield', ''),\n    }\n    # Either add symbols to this dictionary or to the symbols dictionary\n    # directly: Whichever is easier. They are merged later.\n    _strprefixes = [p + q for p in ('b', 'f', 'r', 'u') for q in (\"'\", '\"')]\n    _symbols_inverse = {\n        'STRINGS' : (\"'\", \"'''\", '\"', '\"\"\"', *_strprefixes),\n        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',\n                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),\n        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),\n        'UNARY' : ('-', '~'),\n        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',\n                                '^=', '<<=', '>>=', '**=', '//='),\n        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),\n        'COMPLEX' : ('j', 'J')\n    }\n    symbols = {\n        '%': 'OPERATORS FORMATTING',\n        '**': 'POWER',\n        ',': 'TUPLES LISTS FUNCTIONS',\n        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',\n        '...': 'ELLIPSIS',\n        ':': 'SLICINGS DICTIONARYLITERALS',\n        '@': 'def class',\n        '\\\\': 'STRINGS',\n        '_': 'PRIVATENAMES',\n        '__': 'PRIVATENAMES SPECIALMETHODS',\n        '`': 'BACKQUOTES',\n        '(': 'TUPLES FUNCTIONS CALLS',\n        ')': 'TUPLES FUNCTIONS CALLS',\n        '[': 'LISTS SUBSCRIPTS SLICINGS',\n        ']': 'LISTS SUBSCRIPTS SLICINGS'\n    }\n    for topic, symbols_ in _symbols_inverse.items():\n        for symbol in symbols_:\n            topics = symbols.get(symbol, topic)\n            if topic not in topics:\n                topics = topics + ' ' + topic\n            symbols[symbol] = topics\n\n    topics = {\n        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '\n                  'FUNCTIONS CLASSES MODULES FILES inspect'),\n        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),\n        'FORMATTING': ('formatstrings', 'OPERATORS'),\n        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),\n        'INTEGER': ('integers', 'int range'),\n        'FLOAT': ('floating', 'float math'),\n        'COMPLEX': ('imaginary', 'complex cmath'),\n        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING range LISTS'),\n        'MAPPINGS': 'DICTIONARIES',\n        'FUNCTIONS': ('typesfunctions', 'def TYPES'),\n        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),\n        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),\n        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),\n        'FRAMEOBJECTS': 'TYPES',\n        'TRACEBACKS': 'TYPES',\n        'NONE': ('bltin-null-object', ''),\n        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),\n        'SPECIALATTRIBUTES': ('specialattrs', ''),\n        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),\n        'MODULES': ('typesmodules', 'import'),\n        'PACKAGES': 'import',\n        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '\n                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '\n                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '\n                        'LISTS DICTIONARIES'),\n        'OPERATORS': 'EXPRESSIONS',\n        'PRECEDENCE': 'EXPRESSIONS',\n        'OBJECTS': ('objects', 'TYPES'),\n        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '\n                           'CALLABLEMETHODS SEQUENCEMETHODS MAPPINGMETHODS '\n                           'NUMBERMETHODS CLASSES'),\n        'BASICMETHODS': ('customization', 'hash repr str SPECIALMETHODS'),\n        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),\n        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),\n        'SEQUENCEMETHODS': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS '\n                             'SPECIALMETHODS'),\n        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),\n        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '\n                          'SPECIALMETHODS'),\n        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),\n        'NAMESPACES': ('naming', 'global nonlocal ASSIGNMENT DELETION DYNAMICFEATURES'),\n        'DYNAMICFEATURES': ('dynamic-features', ''),\n        'SCOPING': 'NAMESPACES',\n        'FRAMES': 'NAMESPACES',\n        'EXCEPTIONS': ('exceptions', 'try except finally raise'),\n        'CONVERSIONS': ('conversions', ''),\n        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),\n        'SPECIALIDENTIFIERS': ('id-classes', ''),\n        'PRIVATENAMES': ('atom-identifiers', ''),\n        'LITERALS': ('atom-literals', 'STRINGS NUMBERS TUPLELITERALS '\n                     'LISTLITERALS DICTIONARYLITERALS'),\n        'TUPLES': 'SEQUENCES',\n        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),\n        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),\n        'LISTLITERALS': ('lists', 'LISTS LITERALS'),\n        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),\n        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),\n        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr ATTRIBUTEMETHODS'),\n        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS'),\n        'SLICINGS': ('slicings', 'SEQUENCEMETHODS'),\n        'CALLS': ('calls', 'EXPRESSIONS'),\n        'POWER': ('power', 'EXPRESSIONS'),\n        'UNARY': ('unary', 'EXPRESSIONS'),\n        'BINARY': ('binary', 'EXPRESSIONS'),\n        'SHIFTING': ('shifting', 'EXPRESSIONS'),\n        'BITWISE': ('bitwise', 'EXPRESSIONS'),\n        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),\n        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),\n        'ASSERTION': 'assert',\n        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),\n        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),\n        'DELETION': 'del',\n        'RETURNING': 'return',\n        'IMPORTING': 'import',\n        'CONDITIONAL': 'if',\n        'LOOPING': ('compound', 'for while break continue'),\n        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),\n        'DEBUGGING': ('debugger', 'pdb'),\n        'CONTEXTMANAGERS': ('context-managers', 'with'),\n    }\n\n    def __init__(self, input=None, output=None):\n        self._input = input\n        self._output = output\n\n    @property\n    def input(self):\n        return self._input or sys.stdin\n\n    @property\n    def output(self):\n        return self._output or sys.stdout\n\n    def __repr__(self):\n        if inspect.stack()[1][3] == '?':\n            self()\n            return ''\n        return '<%s.%s instance>' % (self.__class__.__module__,\n                                     self.__class__.__qualname__)\n\n    _GoInteractive = object()\n    def __call__(self, request=_GoInteractive):\n        if request is not self._GoInteractive:\n            self.help(request)\n        else:\n            self.intro()\n            self.interact()\n            self.output.write('''\nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help> prompt.\n''')\n\n    def interact(self):\n        self.output.write('\\n')\n        while True:\n            try:\n                request = self.getline('help> ')\n                if not request: break\n            except (KeyboardInterrupt, EOFError):\n                break\n            request = request.strip()\n\n            # Make sure significant trailing quoting marks of literals don't\n            # get deleted while cleaning input\n            if (len(request) > 2 and request[0] == request[-1] in (\"'\", '\"')\n                    and request[0] not in request[1:-1]):\n                request = request[1:-1]\n            if request.lower() in ('q', 'quit'): break\n            if request == 'help':\n                self.intro()\n            else:\n                self.help(request)\n\n    def getline(self, prompt):\n        \"\"\"Read one line, using input() when appropriate.\"\"\"\n        if self.input is sys.stdin:\n            return input(prompt)\n        else:\n            self.output.write(prompt)\n            self.output.flush()\n            return self.input.readline()\n\n    def help(self, request):\n        if type(request) is type(''):\n            request = request.strip()\n            if request == 'keywords': self.listkeywords()\n            elif request == 'symbols': self.listsymbols()\n            elif request == 'topics': self.listtopics()\n            elif request == 'modules': self.listmodules()\n            elif request[:8] == 'modules ':\n                self.listmodules(request.split()[1])\n            elif request in self.symbols: self.showsymbol(request)\n            elif request in ['True', 'False', 'None']:\n                # special case these keywords since they are objects too\n                doc(eval(request), 'Help on %s:')\n            elif request in self.keywords: self.showtopic(request)\n            elif request in self.topics: self.showtopic(request)\n            elif request: doc(request, 'Help on %s:', output=self._output)\n            else: doc(str, 'Help on %s:', output=self._output)\n        elif isinstance(request, Helper): self()\n        else: doc(request, 'Help on %s:', output=self._output)\n        self.output.write('\\n')\n\n    def intro(self):\n        self.output.write('''\nWelcome to Python {0}'s help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/{0}/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n\"modules\", \"keywords\", \"symbols\", or \"topics\".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as \"spam\", type \"modules spam\".\n'''.format('%d.%d' % sys.version_info[:2]))\n\n    def list(self, items, columns=4, width=80):\n        items = list(sorted(items))\n        colw = width // columns\n        rows = (len(items) + columns - 1) // columns\n        for row in range(rows):\n            for col in range(columns):\n                i = col * rows + row\n                if i < len(items):\n                    self.output.write(items[i])\n                    if col < columns - 1:\n                        self.output.write(' ' + ' ' * (colw - 1 - len(items[i])))\n            self.output.write('\\n')\n\n    def listkeywords(self):\n        self.output.write('''\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\n''')\n        self.list(self.keywords.keys())\n\n    def listsymbols(self):\n        self.output.write('''\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n''')\n        self.list(self.symbols.keys())\n\n    def listtopics(self):\n        self.output.write('''\nHere is a list of available topics.  Enter any topic name to get more help.\n\n''')\n        self.list(self.topics.keys())\n\n    def showtopic(self, topic, more_xrefs=''):\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            self.output.write('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''')\n            return\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        if type(target) is type(''):\n            return self.showtopic(target, more_xrefs)\n\n        label, xrefs = target\n        try:\n            doc = pydoc_data.topics.topics[label]\n        except KeyError:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        doc = doc.strip() + '\\n'\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        if xrefs:\n            import textwrap\n            text = 'Related help topics: ' + ', '.join(xrefs.split()) + '\\n'\n            wrapped_text = textwrap.wrap(text, 72)\n            doc += '\\n%s\\n' % '\\n'.join(wrapped_text)\n        pager(doc)\n\n    def _gettopic(self, topic, more_xrefs=''):\n        \"\"\"Return unbuffered tuple of (topic, xrefs).\n\n        If an error occurs here, the exception is caught and displayed by\n        the url handler.\n\n        This function duplicates the showtopic method but returns its\n        result directly so it can be formatted for display in an html page.\n        \"\"\"\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            return('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''' , '')\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            raise ValueError('could not find topic')\n        if isinstance(target, str):\n            return self._gettopic(target, more_xrefs)\n        label, xrefs = target\n        doc = pydoc_data.topics.topics[label]\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        return doc, xrefs\n\n    def showsymbol(self, symbol):\n        target = self.symbols[symbol]\n        topic, _, xrefs = target.partition(' ')\n        self.showtopic(topic, xrefs)\n\n    def listmodules(self, key=''):\n        if key:\n            self.output.write('''\nHere is a list of modules whose name or summary contains '{}'.\nIf there are any, enter a module name to get more help.\n\n'''.format(key))\n            apropos(key)\n        else:\n            self.output.write('''\nPlease wait a moment while I gather a list of all available modules...\n\n''')\n            modules = {}\n            def callback(path, modname, desc, modules=modules):\n                if modname and modname[-9:] == '.__init__':\n                    modname = modname[:-9] + ' (package)'\n                if modname.find('.') < 0:\n                    modules[modname] = 1\n            def onerror(modname):\n                callback(None, modname, None)\n            ModuleScanner().run(callback, onerror=onerror)\n            self.list(modules.keys())\n            self.output.write('''\nEnter any module name to get more help.  Or, type \"modules spam\" to search\nfor modules whose name or summary contain the string \"spam\".\n''')", "target": 0}, {"function": "class ModuleScanner:\n    \"\"\"An interruptible scanner that searches module synopses.\"\"\"\n\n    def run(self, callback, key=None, completer=None, onerror=None):\n        if key: key = key.lower()\n        self.quit = False\n        seen = {}\n\n        for modname in sys.builtin_module_names:\n            if modname != '__main__':\n                seen[modname] = 1\n                if key is None:\n                    callback(None, modname, '')\n                else:\n                    name = __import__(modname).__doc__ or ''\n                    desc = name.split('\\n')[0]\n                    name = modname + ' - ' + desc\n                    if name.lower().find(key) >= 0:\n                        callback(None, modname, desc)\n\n        for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):\n            if self.quit:\n                break\n\n            if key is None:\n                callback(None, modname, '')\n            else:\n                try:\n                    spec = pkgutil._get_spec(importer, modname)\n                except SyntaxError:\n                    # raised by tests for bad coding cookies or BOM\n                    continue\n                loader = spec.loader\n                if hasattr(loader, 'get_source'):\n                    try:\n                        source = loader.get_source(modname)\n                    except Exception:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = source_synopsis(io.StringIO(source)) or ''\n                    if hasattr(loader, 'get_filename'):\n                        path = loader.get_filename(modname)\n                    else:\n                        path = None\n                else:\n                    try:\n                        module = importlib._bootstrap._load(spec)\n                    except ImportError:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = module.__doc__.splitlines()[0] if module.__doc__ else ''\n                    path = getattr(module,'__file__',None)\n                name = modname + ' - ' + desc\n                if name.lower().find(key) >= 0:\n                    callback(path, modname, desc)\n\n        if completer:\n            completer()", "target": 0}, {"function": "def apropos(key):\n    \"\"\"Print all the one-line module summaries that contain a substring.\"\"\"\n    def callback(path, modname, desc):\n        if modname[-9:] == '.__init__':\n            modname = modname[:-9] + ' (package)'\n        print(modname, desc and '- ' + desc)\n    def onerror(modname):\n        pass\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore') # ignore problems during import\n        ModuleScanner().run(callback, key, onerror=onerror)", "target": 0}, {"function": "def _start_server(urlhandler, hostname, port):\n    \"\"\"Start an HTTP server thread on a specific port.\n\n    Start an HTML/text server thread, so HTML or text documents can be\n    browsed dynamically and interactively with a Web browser.  Example use:\n\n        >>> import time\n        >>> import pydoc\n\n        Define a URL handler.  To determine what the client is asking\n        for, check the URL and content_type.\n\n        Then get or generate some text or HTML code and return it.\n\n        >>> def my_url_handler(url, content_type):\n        ...     text = 'the URL sent was: (%s, %s)' % (url, content_type)\n        ...     return text\n\n        Start server thread on port 0.\n        If you use port 0, the server will pick a random port number.\n        You can then use serverthread.port to get the port number.\n\n        >>> port = 0\n        >>> serverthread = pydoc._start_server(my_url_handler, port)\n\n        Check that the server is really started.  If it is, open browser\n        and get first page.  Use serverthread.url as the starting page.\n\n        >>> if serverthread.serving:\n        ...    import webbrowser\n\n        The next two lines are commented out so a browser doesn't open if\n        doctest is run on this module.\n\n        #...    webbrowser.open(serverthread.url)\n        #True\n\n        Let the server do its thing. We just need to monitor its status.\n        Use time.sleep so the loop doesn't hog the CPU.\n\n        >>> starttime = time.monotonic()\n        >>> timeout = 1                    #seconds\n\n        This is a short timeout for testing purposes.\n\n        >>> while serverthread.serving:\n        ...     time.sleep(.01)\n        ...     if serverthread.serving and time.monotonic() - starttime > timeout:\n        ...          serverthread.stop()\n        ...          break\n\n        Print any errors that may have occurred.\n\n        >>> print(serverthread.error)\n        None\n   \"\"\"\n    import http.server\n    import email.message\n    import select\n    import threading\n\n    class DocHandler(http.server.BaseHTTPRequestHandler):\n\n        def do_GET(self):\n            \"\"\"Process a request from an HTML browser.\n\n            The URL received is in self.path.\n            Get an HTML page from self.urlhandler and send it.\n            \"\"\"\n            if self.path.endswith('.css'):\n                content_type = 'text/css'\n            else:\n                content_type = 'text/html'\n            self.send_response(200)\n            self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)\n            self.end_headers()\n            self.wfile.write(self.urlhandler(\n                self.path, content_type).encode('utf-8'))\n\n        def log_message(self, *args):\n            # Don't log messages.\n            pass\n\n    class DocServer(http.server.HTTPServer):\n\n        def __init__(self, host, port, callback):\n            self.host = host\n            self.address = (self.host, port)\n            self.callback = callback\n            self.base.__init__(self, self.address, self.handler)\n            self.quit = False\n\n        def serve_until_quit(self):\n            while not self.quit:\n                rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)\n                if rd:\n                    self.handle_request()\n            self.server_close()\n\n        def server_activate(self):\n            self.base.server_activate(self)\n            if self.callback:\n                self.callback(self)\n\n    class ServerThread(threading.Thread):\n\n        def __init__(self, urlhandler, host, port):\n            self.urlhandler = urlhandler\n            self.host = host\n            self.port = int(port)\n            threading.Thread.__init__(self)\n            self.serving = False\n            self.error = None\n\n        def run(self):\n            \"\"\"Start the server.\"\"\"\n            try:\n                DocServer.base = http.server.HTTPServer\n                DocServer.handler = DocHandler\n                DocHandler.MessageClass = email.message.Message\n                DocHandler.urlhandler = staticmethod(self.urlhandler)\n                docsvr = DocServer(self.host, self.port, self.ready)\n                self.docserver = docsvr\n                docsvr.serve_until_quit()\n            except Exception as e:\n                self.error = e\n\n        def ready(self, server):\n            self.serving = True\n            self.host = server.host\n            self.port = server.server_port\n            self.url = 'http://%s:%d/' % (self.host, self.port)\n\n        def stop(self):\n            \"\"\"Stop the server and this thread nicely\"\"\"\n            self.docserver.quit = True\n            self.join()\n            # explicitly break a reference cycle: DocServer.callback\n            # has indirectly a reference to ServerThread.\n            self.docserver = None\n            self.serving = False\n            self.url = None\n\n    thread = ServerThread(urlhandler, hostname, port)\n    thread.start()\n    # Wait until thread.serving is True to make sure we are\n    # really up before returning.\n    while not thread.error and not thread.serving:\n        time.sleep(.01)\n    return thread", "target": 0}, {"function": "def _url_handler(url, content_type=\"text/html\"):\n    \"\"\"The pydoc url handler for use with the pydoc server.\n\n    If the content_type is 'text/css', the _pydoc.css style\n    sheet is read and returned if it exits.\n\n    If the content_type is 'text/html', then the result of\n    get_html_page(url) is returned.\n    \"\"\"\n    class _HTMLDoc(HTMLDoc):\n\n        def page(self, title, contents):\n            \"\"\"Format an HTML page.\"\"\"\n            css_path = \"pydoc_data/_pydoc.css\"\n            css_link = (\n                '<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n                css_path)\n            return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n</body></html>''' % (title, css_link, html_navbar(), contents)\n\n        def filelink(self, url, path):\n            return '<a href=\"getfile?key=%s\">%s</a>' % (url, path)\n\n\n    html = _HTMLDoc()\n\n    def html_navbar():\n        version = html.escape(\"%s [%s, %s]\" % (platform.python_version(),\n                                               platform.python_build()[0],\n                                               platform.python_compiler()))\n        return \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:center'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div>\n                    <form action=\"get\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Get\">\n                    </form>&nbsp;\n                    <form action=\"search\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\" % (version, html.escape(platform.platform(terse=True)))\n\n    def html_index():\n        \"\"\"Module Index page.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>Index of Modules</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = [name for name in sys.builtin_module_names\n                 if name != '__main__']\n        contents = html.multicolumn(names, bltinlink)\n        contents = [heading, '<p>' + html.bigsection(\n            'Built-in Modules', '#ffffff', '#ee77aa', contents)]\n\n        seen = {}\n        for dir in sys.path:\n            contents.append(html.index(dir, seen))\n\n        contents.append(\n            '<p align=right><font color=\"#909090\" face=\"helvetica,'\n            'arial\"><strong>pydoc</strong> by Ka-Ping Yee'\n            '&lt;ping@lfw.org&gt;</font>')\n        return 'Index of Modules', ''.join(contents)\n\n    def html_search(key):\n        \"\"\"Search results page.\"\"\"\n        # scan for modules\n        search_result = []\n\n        def callback(path, modname, desc):\n            if modname[-9:] == '.__init__':\n                modname = modname[:-9] + ' (package)'\n            search_result.append((modname, desc and '- ' + desc))\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore') # ignore problems during import\n            def onerror(modname):\n                pass\n            ModuleScanner().run(callback, key, onerror=onerror)\n\n        # format page\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        results = []\n        heading = html.heading(\n            '<big><big><strong>Search Results</strong></big></big>',\n            '#ffffff', '#7799ee')\n        for name, desc in search_result:\n            results.append(bltinlink(name) + desc)\n        contents = heading + html.bigsection(\n            'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n        return 'Search Results', contents\n\n    def html_getfile(path):\n        \"\"\"Get and display a source file listing safely.\"\"\"\n        path = urllib.parse.unquote(path)\n        with tokenize.open(path) as fp:\n            lines = html.escape(fp.read())\n        body = '<pre>%s</pre>' % lines\n        heading = html.heading(\n            '<big><big><strong>File Listing</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = heading + html.bigsection(\n            'File: %s' % path, '#ffffff', '#ee77aa', body)\n        return 'getfile %s' % path, contents\n\n    def html_topics():\n        \"\"\"Index of topic texts available.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.topics.keys())\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Topics', '#ffffff', '#ee77aa', contents)\n        return 'Topics', contents\n\n    def html_keywords():\n        \"\"\"Index of keywords.\"\"\"\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.keywords.keys())\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Keywords', '#ffffff', '#ee77aa', contents)\n        return 'Keywords', contents\n\n    def html_topicpage(topic):\n        \"\"\"Topic or keyword help page.\"\"\"\n        buf = io.StringIO()\n        htmlhelp = Helper(buf, buf)\n        contents, xrefs = htmlhelp._gettopic(topic)\n        if topic in htmlhelp.keywords:\n            title = 'KEYWORD'\n        else:\n            title = 'TOPIC'\n        heading = html.heading(\n            '<big><big><strong>%s</strong></big></big>' % title,\n            '#ffffff', '#7799ee')\n        contents = '<pre>%s</pre>' % html.markup(contents)\n        contents = html.bigsection(topic , '#ffffff','#ee77aa', contents)\n        if xrefs:\n            xrefs = sorted(xrefs.split())\n\n            def bltinlink(name):\n                return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n            xrefs = html.multicolumn(xrefs, bltinlink)\n            xrefs = html.section('Related help topics: ',\n                                 '#ffffff', '#ee77aa', xrefs)\n        return ('%s %s' % (title, topic),\n                ''.join((heading, contents, xrefs)))\n\n    def html_getobj(url):\n        obj = locate(url, forceload=1)\n        if obj is None and url != 'None':\n            raise ValueError('could not find object')\n        title = describe(obj)\n        content = html.document(obj, url)\n        return title, content\n\n    def html_error(url, exc):\n        heading = html.heading(\n            '<big><big><strong>Error</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = '<br>'.join(html.escape(line) for line in\n                               format_exception_only(type(exc), exc))\n        contents = heading + html.bigsection(url, '#ffffff', '#bb0000',\n                                             contents)\n        return \"Error - %s\" % url, contents\n\n    def get_html_page(url):\n        \"\"\"Generate an HTML page for url.\"\"\"\n        complete_url = url\n        if url.endswith('.html'):\n            url = url[:-5]\n        try:\n            if url in (\"\", \"index\"):\n                title, content = html_index()\n            elif url == \"topics\":\n                title, content = html_topics()\n            elif url == \"keywords\":\n                title, content = html_keywords()\n            elif '=' in url:\n                op, _, url = url.partition('=')\n                if op == \"search?key\":\n                    title, content = html_search(url)\n                elif op == \"getfile?key\":\n                    title, content = html_getfile(url)\n                elif op == \"topic?key\":\n                    # try topics first, then objects.\n                    try:\n                        title, content = html_topicpage(url)\n                    except ValueError:\n                        title, content = html_getobj(url)\n                elif op == \"get?key\":\n                    # try objects first, then topics.\n                    if url in (\"\", \"index\"):\n                        title, content = html_index()\n                    else:\n                        try:\n                            title, content = html_getobj(url)\n                        except ValueError:\n                            title, content = html_topicpage(url)\n                else:\n                    raise ValueError('bad pydoc url')\n            else:\n                title, content = html_getobj(url)\n        except Exception as exc:\n            # Catch any errors and display them in an error page.\n            title, content = html_error(complete_url, exc)\n        return html.page(title, content)\n\n    if url.startswith('/'):\n        url = url[1:]\n    if content_type == 'text/css':\n        path_here = os.path.dirname(os.path.realpath(__file__))\n        css_path = os.path.join(path_here, url)\n        with open(css_path) as fp:\n            return ''.join(fp.readlines())\n    elif content_type == 'text/html':\n        return get_html_page(url)\n    # Errors outside the url handler are caught by the server.\n    raise TypeError('unknown content type %r for url %s' % (content_type, url))", "target": 0}, {"function": "def browse(port=0, *, open_browser=True, hostname='localhost'):\n    \"\"\"Start the enhanced pydoc Web server and open a Web browser.\n\n    Use port '0' to start the server on an arbitrary port.\n    Set open_browser to False to suppress opening a browser.\n    \"\"\"\n    import webbrowser\n    serverthread = _start_server(_url_handler, hostname, port)\n    if serverthread.error:\n        print(serverthread.error)\n        return\n    if serverthread.serving:\n        server_help_msg = 'Server commands: [b]rowser, [q]uit'\n        if open_browser:\n            webbrowser.open(serverthread.url)\n        try:\n            print('Server ready at', serverthread.url)\n            print(server_help_msg)\n            while serverthread.serving:\n                cmd = input('server> ')\n                cmd = cmd.lower()\n                if cmd == 'q':\n                    break\n                elif cmd == 'b':\n                    webbrowser.open(serverthread.url)\n                else:\n                    print(server_help_msg)\n        except (KeyboardInterrupt, EOFError):\n            print()\n        finally:\n            if serverthread.serving:\n                serverthread.stop()\n                print('Server stopped')", "target": 0}, {"function": "def ispath(x):\n    return isinstance(x, str) and x.find(os.sep) >= 0", "target": 0}, {"function": "def _get_revised_path(given_path, argv0):\n    \"\"\"Ensures current directory is on returned path, and argv0 directory is not\n\n    Exception: argv0 dir is left alone if it's also pydoc's directory.\n\n    Returns a new path entry list, or None if no adjustment is needed.\n    \"\"\"\n    # Scripts may get the current directory in their path by default if they're\n    # run with the -m switch, or directly from the current directory.\n    # The interactive prompt also allows imports from the current directory.\n\n    # Accordingly, if the current directory is already present, don't make\n    # any changes to the given_path\n    if '' in given_path or os.curdir in given_path or os.getcwd() in given_path:\n        return None\n\n    # Otherwise, add the current directory to the given path, and remove the\n    # script directory (as long as the latter isn't also pydoc's directory.\n    stdlib_dir = os.path.dirname(__file__)\n    script_dir = os.path.dirname(argv0)\n    revised_path = given_path.copy()\n    if script_dir in given_path and not os.path.samefile(script_dir, stdlib_dir):\n        revised_path.remove(script_dir)\n    revised_path.insert(0, os.getcwd())\n    return revised_path", "target": 0}, {"function": "def _adjust_cli_sys_path():\n    \"\"\"Ensures current directory is on sys.path, and __main__ directory is not.\n\n    Exception: __main__ dir is left alone if it's also pydoc's directory.\n    \"\"\"\n    revised_path = _get_revised_path(sys.path, sys.argv[0])\n    if revised_path is not None:\n        sys.path[:] = revised_path", "target": 0}, {"function": "def cli():\n    \"\"\"Command-line interface (looks at sys.argv to decide what to do).\"\"\"\n    import getopt\n    class BadUsage(Exception): pass\n\n    _adjust_cli_sys_path()\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'bk:n:p:w')\n        writing = False\n        start_server = False\n        open_browser = False\n        port = 0\n        hostname = 'localhost'\n        for opt, val in opts:\n            if opt == '-b':\n                start_server = True\n                open_browser = True\n            if opt == '-k':\n                apropos(val)\n                return\n            if opt == '-p':\n                start_server = True\n                port = val\n            if opt == '-w':\n                writing = True\n            if opt == '-n':\n                start_server = True\n                hostname = val\n\n        if start_server:\n            browse(port, hostname=hostname, open_browser=open_browser)\n            return\n\n        if not args: raise BadUsage\n        for arg in args:\n            if ispath(arg) and not os.path.exists(arg):\n                print('file %r does not exist' % arg)\n                break\n            try:\n                if ispath(arg) and os.path.isfile(arg):\n                    arg = importfile(arg)\n                if writing:\n                    if ispath(arg) and os.path.isdir(arg):\n                        writedocs(arg)\n                    else:\n                        writedoc(arg)\n                else:\n                    help.help(arg)\n            except ErrorDuringImport as value:\n                print(value)\n\n    except (getopt.error, BadUsage):\n        cmd = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n        print(\"\"\"pydoc - the Python documentation tool\n\n{cmd} <name> ...\n    Show text documentation on something.  <name> may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If <name> contains a '{sep}', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\n{cmd} -k <keyword>\n    Search for a keyword in the synopsis lines of all available modules.\n\n{cmd} -n <hostname>\n    Start an HTTP server with the given hostname (default: localhost).\n\n{cmd} -p <port>\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\n{cmd} -b\n    Start an HTTP server on an arbitrary unused port and open a Web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\n{cmd} -w <name> ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If <name> contains a '{sep}', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\"\"\".format(cmd=cmd, sep=os.sep))", "target": 0}], "function_after": [{"function": "def pathdirs():\n    \"\"\"Convert sys.path into a list of absolute, existing, unique paths.\"\"\"\n    dirs = []\n    normdirs = []\n    for dir in sys.path:\n        dir = os.path.abspath(dir or '.')\n        normdir = os.path.normcase(dir)\n        if normdir not in normdirs and os.path.isdir(dir):\n            dirs.append(dir)\n            normdirs.append(normdir)\n    return dirs", "target": 0}, {"function": "def _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not inspect.isclass(cls):\n        return None\n    return cls", "target": 0}, {"function": "def _finddoc(obj):\n    if inspect.ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif inspect.isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (inspect.isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif inspect.ismethoddescriptor(obj) or inspect.isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if inspect.ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = _getowndoc(getattr(base, name))\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None", "target": 0}, {"function": "def _getowndoc(obj):\n    \"\"\"Get the documentation string for an object if it is not\n    inherited from its class.\"\"\"\n    try:\n        doc = object.__getattribute__(obj, '__doc__')\n        if doc is None:\n            return None\n        if obj is not type:\n            typedoc = type(obj).__doc__\n            if isinstance(typedoc, str) and typedoc == doc:\n                return None\n        return doc\n    except AttributeError:\n        return None", "target": 0}, {"function": "def _getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    doc = _getowndoc(object)\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return inspect.cleandoc(doc)", "target": 0}, {"function": "def getdoc(object):\n    \"\"\"Get the doc string or comments for an object.\"\"\"\n    result = _getdoc(object) or inspect.getcomments(object)\n    return result and re.sub('^ *\\n', '', result.rstrip()) or ''", "target": 0}, {"function": "def splitdoc(doc):\n    \"\"\"Split a doc string into a synopsis line (if any) and the rest.\"\"\"\n    lines = doc.strip().split('\\n')\n    if len(lines) == 1:\n        return lines[0], ''\n    elif len(lines) >= 2 and not lines[1].rstrip():\n        return lines[0], '\\n'.join(lines[2:])\n    return '', '\\n'.join(lines)", "target": 0}, {"function": "def classname(object, modname):\n    \"\"\"Get a class name and qualify it with a module name if necessary.\"\"\"\n    name = object.__name__\n    if object.__module__ != modname:\n        name = object.__module__ + '.' + name\n    return name", "target": 0}, {"function": "def isdata(object):\n    \"\"\"Check if an object is of a type that probably means it's data.\"\"\"\n    return not (inspect.ismodule(object) or inspect.isclass(object) or\n                inspect.isroutine(object) or inspect.isframe(object) or\n                inspect.istraceback(object) or inspect.iscode(object))", "target": 0}, {"function": "def replace(text, *pairs):\n    \"\"\"Do a series of global replacements on a string.\"\"\"\n    while pairs:\n        text = pairs[1].join(text.split(pairs[0]))\n        pairs = pairs[2:]\n    return text", "target": 0}, {"function": "def cram(text, maxlen):\n    \"\"\"Omit part of a string if needed to make it fit in a maximum length.\"\"\"\n    if len(text) > maxlen:\n        pre = max(0, (maxlen-3)//2)\n        post = max(0, maxlen-3-pre)\n        return text[:pre] + '...' + text[len(text)-post:]\n    return text", "target": 0}, {"function": "def stripid(text):\n    \"\"\"Remove the hexadecimal id from a Python object representation.\"\"\"\n    # The behaviour of %p is implementation-dependent in terms of case.\n    return _re_stripid.sub(r'\\1', text)", "target": 0}, {"function": "def _is_bound_method(fn):\n    \"\"\"\n    Returns True if fn is a bound method, regardless of whether\n    fn was implemented in Python or in C.\n    \"\"\"\n    if inspect.ismethod(fn):\n        return True\n    if inspect.isbuiltin(fn):\n        self = getattr(fn, '__self__', None)\n        return not (inspect.ismodule(self) or (self is None))\n    return False", "target": 0}, {"function": "def allmethods(cl):\n    methods = {}\n    for key, value in inspect.getmembers(cl, inspect.isroutine):\n        methods[key] = 1\n    for base in cl.__bases__:\n        methods.update(allmethods(base)) # all your base are belong to us\n    for key in methods.keys():\n        methods[key] = getattr(cl, key)\n    return methods", "target": 0}, {"function": "def _split_list(s, predicate):\n    \"\"\"Split sequence s via predicate, and return pair ([true], [false]).\n\n    The return value is a 2-tuple of lists,\n        ([x for x in s if predicate(x)],\n         [x for x in s if not predicate(x)])\n    \"\"\"\n\n    yes = []\n    no = []\n    for x in s:\n        if predicate(x):\n            yes.append(x)\n        else:\n            no.append(x)\n    return yes, no", "target": 0}, {"function": "def visiblename(name, all=None, obj=None):\n    \"\"\"Decide whether to show documentation on a variable.\"\"\"\n    # Certain special names are redundant or internal.\n    # XXX Remove __initializing__?\n    if name in {'__author__', '__builtins__', '__cached__', '__credits__',\n                '__date__', '__doc__', '__file__', '__spec__',\n                '__loader__', '__module__', '__name__', '__package__',\n                '__path__', '__qualname__', '__slots__', '__version__'}:\n        return 0\n    # Private names are hidden, but special names are displayed.\n    if name.startswith('__') and name.endswith('__'): return 1\n    # Namedtuples have public fields and methods with a single leading underscore\n    if name.startswith('_') and hasattr(obj, '_fields'):\n        return True\n    if all is not None:\n        # only document that which the programmer exported in __all__\n        return name in all\n    else:\n        return not name.startswith('_')", "target": 0}, {"function": "def classify_class_attrs(object):\n    \"\"\"Wrap inspect.classify_class_attrs, with fixup for data descriptors.\"\"\"\n    results = []\n    for (name, kind, cls, value) in inspect.classify_class_attrs(object):\n        if inspect.isdatadescriptor(value):\n            kind = 'data descriptor'\n            if isinstance(value, property) and value.fset is None:\n                kind = 'readonly property'\n        results.append((name, kind, cls, value))\n    return results", "target": 0}, {"function": "def sort_attributes(attrs, object):\n    'Sort the attrs list in-place by _fields and then alphabetically by name'\n    # This allows data descriptors to be ordered according\n    # to a _fields attribute if present.\n    fields = getattr(object, '_fields', [])\n    try:\n        field_order = {name : i-len(fields) for (i, name) in enumerate(fields)}\n    except TypeError:\n        field_order = {}\n    keyfunc = lambda attr: (field_order.get(attr[0], 0), attr[0])\n    attrs.sort(key=keyfunc)", "target": 0}, {"function": "def ispackage(path):\n    \"\"\"Guess whether a path refers to a package directory.\"\"\"\n    if os.path.isdir(path):\n        for ext in ('.py', '.pyc'):\n            if os.path.isfile(os.path.join(path, '__init__' + ext)):\n                return True\n    return False", "target": 0}, {"function": "def source_synopsis(file):\n    line = file.readline()\n    while line[:1] == '#' or not line.strip():\n        line = file.readline()\n        if not line: break\n    line = line.strip()\n    if line[:4] == 'r\"\"\"': line = line[1:]\n    if line[:3] == '\"\"\"':\n        line = line[3:]\n        if line[-1:] == '\\\\': line = line[:-1]\n        while not line.strip():\n            line = file.readline()\n            if not line: break\n        result = line.split('\"\"\"')[0].strip()\n    else: result = None\n    return result", "target": 0}, {"function": "def synopsis(filename, cache={}):\n    \"\"\"Get the one-line summary out of a module file.\"\"\"\n    mtime = os.stat(filename).st_mtime\n    lastupdate, result = cache.get(filename, (None, None))\n    if lastupdate is None or lastupdate < mtime:\n        # Look for binary suffixes first, falling back to source.\n        if filename.endswith(tuple(importlib.machinery.BYTECODE_SUFFIXES)):\n            loader_cls = importlib.machinery.SourcelessFileLoader\n        elif filename.endswith(tuple(importlib.machinery.EXTENSION_SUFFIXES)):\n            loader_cls = importlib.machinery.ExtensionFileLoader\n        else:\n            loader_cls = None\n        # Now handle the choice.\n        if loader_cls is None:\n            # Must be a source file.\n            try:\n                file = tokenize.open(filename)\n            except OSError:\n                # module can't be opened, so skip it\n                return None\n            # text modules can be directly examined\n            with file:\n                result = source_synopsis(file)\n        else:\n            # Must be a binary module, which has to be imported.\n            loader = loader_cls('__temp__', filename)\n            # XXX We probably don't need to pass in the loader here.\n            spec = importlib.util.spec_from_file_location('__temp__', filename,\n                                                          loader=loader)\n            try:\n                module = importlib._bootstrap._load(spec)\n            except:\n                return None\n            del sys.modules['__temp__']\n            result = module.__doc__.splitlines()[0] if module.__doc__ else None\n        # Cache the result.\n        cache[filename] = (mtime, result)\n    return result", "target": 0}, {"function": "class ErrorDuringImport(Exception):\n    \"\"\"Errors that occurred while trying to import something to document it.\"\"\"\n    def __init__(self, filename, exc_info):\n        self.filename = filename\n        self.exc, self.value, self.tb = exc_info\n\n    def __str__(self):\n        exc = self.exc.__name__\n        return 'problem in %s - %s: %s' % (self.filename, exc, self.value)", "target": 0}, {"function": "def importfile(path):\n    \"\"\"Import a Python source file or compiled file given its path.\"\"\"\n    magic = importlib.util.MAGIC_NUMBER\n    with open(path, 'rb') as file:\n        is_bytecode = magic == file.read(len(magic))\n    filename = os.path.basename(path)\n    name, ext = os.path.splitext(filename)\n    if is_bytecode:\n        loader = importlib._bootstrap_external.SourcelessFileLoader(name, path)\n    else:\n        loader = importlib._bootstrap_external.SourceFileLoader(name, path)\n    # XXX We probably don't need to pass in the loader here.\n    spec = importlib.util.spec_from_file_location(name, path, loader=loader)\n    try:\n        return importlib._bootstrap._load(spec)\n    except:\n        raise ErrorDuringImport(path, sys.exc_info())", "target": 0}, {"function": "def safeimport(path, forceload=0, cache={}):\n    \"\"\"Import a module; handle errors; return None if the module isn't found.\n\n    If the module *is* found but an exception occurs, it's wrapped in an\n    ErrorDuringImport exception and reraised.  Unlike __import__, if a\n    package path is specified, the module at the end of the path is returned,\n    not the package at the beginning.  If the optional 'forceload' argument\n    is 1, we reload the module from disk (unless it's a dynamic extension).\"\"\"\n    try:\n        # If forceload is 1 and the module has been previously loaded from\n        # disk, we always have to reload the module.  Checking the file's\n        # mtime isn't good enough (e.g. the module could contain a class\n        # that inherits from another module that has changed).\n        if forceload and path in sys.modules:\n            if path not in sys.builtin_module_names:\n                # Remove the module from sys.modules and re-import to try\n                # and avoid problems with partially loaded modules.\n                # Also remove any submodules because they won't appear\n                # in the newly loaded module's namespace if they're already\n                # in sys.modules.\n                subs = [m for m in sys.modules if m.startswith(path + '.')]\n                for key in [path] + subs:\n                    # Prevent garbage collection.\n                    cache[key] = sys.modules[key]\n                    del sys.modules[key]\n        module = __import__(path)\n    except:\n        # Did the error occur before or after the module was found?\n        (exc, value, tb) = info = sys.exc_info()\n        if path in sys.modules:\n            # An error occurred while executing the imported module.\n            raise ErrorDuringImport(sys.modules[path].__file__, info)\n        elif exc is SyntaxError:\n            # A SyntaxError occurred before we could execute the module.\n            raise ErrorDuringImport(value.filename, info)\n        elif issubclass(exc, ImportError) and value.name == path:\n            # No such module in the path.\n            return None\n        else:\n            # Some other error occurred during the importing process.\n            raise ErrorDuringImport(path, sys.exc_info())\n    for part in path.split('.')[1:]:\n        try: module = getattr(module, part)\n        except AttributeError: return None\n    return module", "target": 0}, {"function": "class Doc:\n\n    PYTHONDOCS = os.environ.get(\"PYTHONDOCS\",\n                                \"https://docs.python.org/%d.%d/library\"\n                                % sys.version_info[:2])\n\n    def document(self, object, name=None, *args):\n        \"\"\"Generate documentation for an object.\"\"\"\n        args = (object, name) + args\n        # 'try' clause is to attempt to handle the possibility that inspect\n        # identifies something in a way that pydoc itself has issues handling;\n        # think 'super' and how it is a descriptor (which raises the exception\n        # by lacking a __name__ attribute) and an instance.\n        try:\n            if inspect.ismodule(object): return self.docmodule(*args)\n            if inspect.isclass(object): return self.docclass(*args)\n            if inspect.isroutine(object): return self.docroutine(*args)\n        except AttributeError:\n            pass\n        if inspect.isdatadescriptor(object): return self.docdata(*args)\n        return self.docother(*args)\n\n    def fail(self, object, name=None, *args):\n        \"\"\"Raise an exception for unimplemented types.\"\"\"\n        message = \"don't know how to document object%s of type %s\" % (\n            name and ' ' + repr(name), type(object).__name__)\n        raise TypeError(message)\n\n    docmodule = docclass = docroutine = docother = docproperty = docdata = fail\n\n    def getdocloc(self, object, basedir=sysconfig.get_path('stdlib')):\n        \"\"\"Return the location of module docs or None\"\"\"\n\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n\n        docloc = os.environ.get(\"PYTHONDOCS\", self.PYTHONDOCS)\n\n        basedir = os.path.normcase(basedir)\n        if (isinstance(object, type(os)) and\n            (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',\n                                 'marshal', 'posix', 'signal', 'sys',\n                                 '_thread', 'zipimport') or\n             (file.startswith(basedir) and\n              not file.startswith(os.path.join(basedir, 'site-packages')))) and\n            object.__name__ not in ('xml.etree', 'test.pydoc_mod')):\n            if docloc.startswith((\"http://\", \"https://\")):\n                docloc = \"{}/{}.html\".format(docloc.rstrip(\"/\"), object.__name__.lower())\n            else:\n                docloc = os.path.join(docloc, object.__name__.lower() + \".html\")\n        else:\n            docloc = None\n        return docloc", "target": 0}, {"function": "class HTMLRepr(Repr):\n    \"\"\"Class for safely making an HTML representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def escape(self, text):\n        return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')\n\n    def repr(self, object):\n        return Repr.repr(self, object)\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return self.escape(cram(stripid(repr(x)), self.maxother))\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + self.escape(test) + testrepr[0]\n        return re.sub(r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)',\n                      r'<font color=\"#c040c0\">\\1</font>',\n                      self.escape(testrepr))\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return self.escape(cram(stripid(repr(x)), self.maxstring))\n        except:\n            return self.escape('<%s instance>' % x.__class__.__name__)\n\n    repr_unicode = repr_string", "target": 0}, {"function": "class HTMLDoc(Doc):\n    \"\"\"Formatter class for HTML documentation.\"\"\"\n\n    # ------------------------------------------- HTML formatting utilities\n\n    _repr_instance = HTMLRepr()\n    repr = _repr_instance.repr\n    escape = _repr_instance.escape\n\n    def page(self, title, contents):\n        \"\"\"Format an HTML page.\"\"\"\n        return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Python: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head><body bgcolor=\"#f0f0f8\">\n%s\n</body></html>''' % (title, contents)\n\n    def heading(self, title, fgcol, bgcol, extras=''):\n        \"\"\"Format a page heading.\"\"\"\n        return '''\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"%s\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">&nbsp;<br>%s</font></td\n><td align=right valign=bottom\n><font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr></table>\n    ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')\n\n    def section(self, title, fgcol, bgcol, contents, width=6,\n                prelude='', marginalia=None, gap='&nbsp;'):\n        \"\"\"Format a section with a heading.\"\"\"\n        if marginalia is None:\n            marginalia = '<tt>' + '&nbsp;' * width + '</tt>'\n        result = '''<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"%s\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr>\n    ''' % (bgcol, fgcol, title)\n        if prelude:\n            result = result + '''\n<tr bgcolor=\"%s\"><td rowspan=2>%s</td>\n<td colspan=2>%s</td></tr>\n<tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)\n        else:\n            result = result + '''\n<tr><td bgcolor=\"%s\">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)\n\n        return result + '\\n<td width=\"100%%\">%s</td></tr></table>' % contents\n\n    def bigsection(self, title, *args):\n        \"\"\"Format a section with a big heading.\"\"\"\n        title = '<big><strong>%s</strong></big>' % title\n        return self.section(title, *args)\n\n    def preformat(self, text):\n        \"\"\"Format literal preformatted text.\"\"\"\n        text = self.escape(text.expandtabs())\n        return replace(text, '\\n\\n', '\\n \\n', '\\n\\n', '\\n \\n',\n                             ' ', '&nbsp;', '\\n', '<br>\\n')\n\n    def multicolumn(self, list, format, cols=4):\n        \"\"\"Format a list of items into a multi-column list.\"\"\"\n        result = ''\n        rows = (len(list)+cols-1)//cols\n        for col in range(cols):\n            result = result + '<td width=\"%d%%\" valign=top>' % (100//cols)\n            for i in range(rows*col, rows*col+rows):\n                if i < len(list):\n                    result = result + format(list[i]) + '<br>\\n'\n            result = result + '</td>'\n        return '<table width=\"100%%\" summary=\"list\"><tr>%s</tr></table>' % result\n\n    def grey(self, text): return '<font color=\"#909090\">%s</font>' % text\n\n    def namelink(self, name, *dicts):\n        \"\"\"Make a link for an identifier, given name-to-URL mappings.\"\"\"\n        for dict in dicts:\n            if name in dict:\n                return '<a href=\"%s\">%s</a>' % (dict[name], name)\n        return name\n\n    def classlink(self, object, modname):\n        \"\"\"Make a link for a class.\"\"\"\n        name, module = object.__name__, sys.modules.get(object.__module__)\n        if hasattr(module, name) and getattr(module, name) is object:\n            return '<a href=\"%s.html#%s\">%s</a>' % (\n                module.__name__, name, classname(object, modname))\n        return classname(object, modname)\n\n    def modulelink(self, object):\n        \"\"\"Make a link for a module.\"\"\"\n        return '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n\n    def modpkglink(self, modpkginfo):\n        \"\"\"Make a link for a module or package to display in an index.\"\"\"\n        name, path, ispackage, shadowed = modpkginfo\n        if shadowed:\n            return self.grey(name)\n        if path:\n            url = '%s.%s.html' % (path, name)\n        else:\n            url = '%s.html' % name\n        if ispackage:\n            text = '<strong>%s</strong>&nbsp;(package)' % name\n        else:\n            text = name\n        return '<a href=\"%s\">%s</a>' % (url, text)\n\n    def filelink(self, url, path):\n        \"\"\"Make a link to source file.\"\"\"\n        return '<a href=\"file:%s\">%s</a>' % (url, path)\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n        pattern = re.compile(r'\\b((http|https|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?(\\w+))')\n        while True:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif selfdot:\n                # Create a link for methods like 'self.method(...)'\n                # and use <strong> for attributes like 'self.attr'\n                if text[end:end+1] == '(':\n                    results.append('self.' + self.namelink(name, methods))\n                else:\n                    results.append('self.<strong>%s</strong>' % name)\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None):\n        \"\"\"Produce HTML for a class tree as given by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + '<dt><font face=\"helvetica, arial\">'\n                result = result + self.classlink(c, modname)\n                if bases and bases != (parent,):\n                    parents = []\n                    for base in bases:\n                        parents.append(self.classlink(base, modname))\n                    result = result + '(' + ', '.join(parents) + ')'\n                result = result + '\\n</font></dt>'\n            elif type(entry) is type([]):\n                result = result + '<dd>\\n%s</dd>\\n' % self.formattree(\n                    entry, modname, c)\n        return '<dl>\\n%s</dl>\\n' % result\n\n    def docmodule(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        try:\n            all = object.__all__\n        except AttributeError:\n            all = None\n        parts = name.split('.')\n        links = []\n        for i in range(len(parts)-1):\n            links.append(\n                '<a href=\"%s.html\"><font color=\"#ffffff\">%s</font></a>' %\n                ('.'.join(parts[:i+1]), parts[i]))\n        linkedname = '.'.join(links + parts[-1:])\n        head = '<big><big><strong>%s</strong></big></big>' % linkedname\n        try:\n            path = inspect.getabsfile(object)\n            url = urllib.parse.quote(path)\n            filelink = self.filelink(url, path)\n        except TypeError:\n            filelink = '(built-in)'\n        info = []\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            info.append('version %s' % self.escape(version))\n        if hasattr(object, '__date__'):\n            info.append(self.escape(str(object.__date__)))\n        if info:\n            head = head + ' (%s)' % ', '.join(info)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            docloc = '<br><a href=\"%(docloc)s\">Module Reference</a>' % locals()\n        else:\n            docloc = ''\n        result = self.heading(\n            head, '#ffffff', '#7799ee',\n            '<a href=\".\">index</a><br>' + filelink + docloc)\n\n        modules = inspect.getmembers(object, inspect.ismodule)\n\n        classes, cdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n                    cdict[key] = cdict[value] = '#' + key\n        for key, value in classes:\n            for base in value.__bases__:\n                key, modname = base.__name__, base.__module__\n                module = sys.modules.get(modname)\n                if modname != name and module and hasattr(module, key):\n                    if getattr(module, key) is base:\n                        if not key in cdict:\n                            cdict[key] = cdict[base] = modname + '.html#' + key\n        funcs, fdict = [], {}\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n                    fdict[key] = '#-' + key\n                    if inspect.isfunction(value): fdict[value] = fdict[key]\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        doc = self.markup(getdoc(object), self.preformat, fdict, cdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        if hasattr(object, '__path__'):\n            modpkgs = []\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs.append((modname, name, ispkg, 0))\n            modpkgs.sort()\n            contents = self.multicolumn(modpkgs, self.modpkglink)\n            result = result + self.bigsection(\n                'Package Contents', '#ffffff', '#aa55cc', contents)\n        elif modules:\n            contents = self.multicolumn(\n                modules, lambda t: self.modulelink(t[1]))\n            result = result + self.bigsection(\n                'Modules', '#ffffff', '#aa55cc', contents)\n\n        if classes:\n            classlist = [value for (key, value) in classes]\n            contents = [\n                self.formattree(inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Classes', '#ffffff', '#ee77aa', ' '.join(contents))\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name, fdict, cdict))\n            result = result + self.bigsection(\n                'Functions', '#ffffff', '#eeaa77', ' '.join(contents))\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.document(value, key))\n            result = result + self.bigsection(\n                'Data', '#ffffff', '#55aa55', '<br>\\n'.join(contents))\n        if hasattr(object, '__author__'):\n            contents = self.markup(str(object.__author__), self.preformat)\n            result = result + self.bigsection(\n                'Author', '#ffffff', '#7799ee', contents)\n        if hasattr(object, '__credits__'):\n            contents = self.markup(str(object.__credits__), self.preformat)\n            result = result + self.bigsection(\n                'Credits', '#ffffff', '#7799ee', contents)\n\n        return result\n\n    def docclass(self, object, name=None, mod=None, funcs={}, classes={},\n                 *ignored):\n        \"\"\"Produce HTML documentation for a class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        contents = []\n        push = contents.append\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('<hr>\\n')\n                self.needone = 1\n        hr = HorizontalRule()\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            hr.maybe()\n            push('<dl><dt>Method resolution order:</dt>\\n')\n            for base in mro:\n                push('<dd>%s</dd>\\n' % self.classlink(base,\n                                                      object.__module__))\n            push('</dl>\\n')\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value, name, mod,\n                                        funcs, classes, mdict, object))\n                    push('\\n')\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    base = self.docother(getattr(object, name), name, mod)\n                    doc = getdoc(value)\n                    if not doc:\n                        push('<dl><dt>%s</dl>\\n' % base)\n                    else:\n                        doc = self.markup(getdoc(value), self.preformat,\n                                          funcs, classes, mdict)\n                        doc = '<dd><tt>%s</tt>' % doc\n                        push('<dl><dt>%s%s</dl>\\n' % (base, doc))\n                    push('\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        mdict = {}\n        for key, kind, homecls, value in attrs:\n            mdict[key] = anchor = '#' + name + '-' + key\n            try:\n                value = getattr(object, name)\n            except Exception:\n                # Some descriptors may meet a failure in their __get__.\n                # (bug #1785)\n                pass\n            try:\n                # The value may not be hashable (e.g., a data attr with\n                # a dict or list value).\n                mdict[value] = anchor\n            except TypeError:\n                pass\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = 'defined here'\n            else:\n                tag = 'inherited from %s' % self.classlink(thisclass,\n                                                           object.__module__)\n            tag += ':<br>\\n'\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill('Methods %s' % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill('Class methods %s' % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill('Static methods %s' % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors('Data descriptors %s' % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata('Data and other attributes %s' % tag, attrs,\n                              lambda t: t[1] == 'data')\n            assert attrs == []\n            attrs = inherited\n\n        contents = ''.join(contents)\n\n        if name == realname:\n            title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n                name, realname)\n        else:\n            title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n                name, name, realname)\n        if bases:\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, object.__module__))\n            title = title + '(%s)' % ', '.join(parents)\n\n        decl = ''\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                decl = name + self.escape(argspec) + '\\n\\n'\n\n        doc = getdoc(object)\n        if decl:\n            doc = decl + (doc or '')\n        doc = self.markup(doc, self.preformat, funcs, classes, mdict)\n        doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n\n        return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return self.grey('=' + self.repr(object))\n\n    def docroutine(self, object, name=None, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + self.classlink(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % self.classlink(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % self.classlink(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = '<a name=\"%s\"><strong>%s</strong></a>' % (anchor, realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                reallink = '<a href=\"#%s\">%s</a>' % (\n                    cl.__name__ + '-' + realname, realname)\n                skipdocs = 1\n            else:\n                reallink = realname\n            title = '<a name=\"%s\"><strong>%s</strong></a> = %s' % (\n                anchor, name, reallink)\n        argspec = None\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = '<strong>%s</strong> <em>lambda</em> ' % name\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n\n        decl = asyncqualifier + title + self.escape(argspec) + (note and\n               self.grey('<font face=\"helvetica, arial\">%s</font>' % note))\n\n        if skipdocs:\n            return '<dl><dt>%s</dt></dl>\\n' % decl\n        else:\n            doc = self.markup(\n                getdoc(object), self.preformat, funcs, classes, methods)\n            doc = doc and '<dd><tt>%s</tt></dd>' % doc\n            return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce html documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push('<dl><dt><strong>%s</strong></dt>\\n' % name)\n        doc = self.markup(getdoc(object), self.preformat)\n        if doc:\n            push('<dd><tt>%s</tt></dd>\\n' % doc)\n        push('</dl>\\n')\n\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce HTML documentation for a data object.\"\"\"\n        lhs = name and '<strong>%s</strong> = ' % name or ''\n        return lhs + self.repr(object)\n\n    def index(self, dir, shadowed=None):\n        \"\"\"Generate an HTML index for a directory of modules.\"\"\"\n        modpkgs = []\n        if shadowed is None: shadowed = {}\n        for importer, name, ispkg in pkgutil.iter_modules([dir]):\n            if any((0xD800 <= ord(ch) <= 0xDFFF) for ch in name):\n                # ignore a module if its name contains a surrogate character\n                continue\n            modpkgs.append((name, '', ispkg, name in shadowed))\n            shadowed[name] = 1\n\n        modpkgs.sort()\n        contents = self.multicolumn(modpkgs, self.modpkglink)\n        return self.bigsection(dir, '#ffffff', '#ee77aa', contents)", "target": 0}, {"function": "class TextRepr(Repr):\n    \"\"\"Class for safely making a text representation of a Python object.\"\"\"\n    def __init__(self):\n        Repr.__init__(self)\n        self.maxlist = self.maxtuple = 20\n        self.maxdict = 10\n        self.maxstring = self.maxother = 100\n\n    def repr1(self, x, level):\n        if hasattr(type(x), '__name__'):\n            methodname = 'repr_' + '_'.join(type(x).__name__.split())\n            if hasattr(self, methodname):\n                return getattr(self, methodname)(x, level)\n        return cram(stripid(repr(x)), self.maxother)\n\n    def repr_string(self, x, level):\n        test = cram(x, self.maxstring)\n        testrepr = repr(test)\n        if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n            # Backslashes are only literal in the string and are never\n            # needed to make any special characters, so show a raw string.\n            return 'r' + testrepr[0] + test + testrepr[0]\n        return testrepr\n\n    repr_str = repr_string\n\n    def repr_instance(self, x, level):\n        try:\n            return cram(stripid(repr(x)), self.maxstring)\n        except:\n            return '<%s instance>' % x.__class__.__name__", "target": 0}, {"function": "class TextDoc(Doc):\n    \"\"\"Formatter class for text documentation.\"\"\"\n\n    # ------------------------------------------- text formatting utilities\n\n    _repr_instance = TextRepr()\n    repr = _repr_instance.repr\n\n    def bold(self, text):\n        \"\"\"Format a string in bold by overstriking.\"\"\"\n        return ''.join(ch + '\\b' + ch for ch in text)\n\n    def indent(self, text, prefix='    '):\n        \"\"\"Indent text by prepending a given prefix to each line.\"\"\"\n        if not text: return ''\n        lines = [prefix + line for line in text.split('\\n')]\n        if lines: lines[-1] = lines[-1].rstrip()\n        return '\\n'.join(lines)\n\n    def section(self, title, contents):\n        \"\"\"Format a section with a given heading.\"\"\"\n        clean_contents = self.indent(contents).rstrip()\n        return self.bold(title) + '\\n' + clean_contents + '\\n\\n'\n\n    # ---------------------------------------------- type-specific routines\n\n    def formattree(self, tree, modname, parent=None, prefix=''):\n        \"\"\"Render in text a class tree as returned by inspect.getclasstree().\"\"\"\n        result = ''\n        for entry in tree:\n            if type(entry) is type(()):\n                c, bases = entry\n                result = result + prefix + classname(c, modname)\n                if bases and bases != (parent,):\n                    parents = (classname(c, modname) for c in bases)\n                    result = result + '(%s)' % ', '.join(parents)\n                result = result + '\\n'\n            elif type(entry) is type([]):\n                result = result + self.formattree(\n                    entry, modname, c, prefix + '    ')\n        return result\n\n    def docmodule(self, object, name=None, mod=None):\n        \"\"\"Produce text documentation for a given module object.\"\"\"\n        name = object.__name__ # ignore the passed-in name\n        synop, desc = splitdoc(getdoc(object))\n        result = self.section('NAME', name + (synop and ' - ' + synop))\n        all = getattr(object, '__all__', None)\n        docloc = self.getdocloc(object)\n        if docloc is not None:\n            result = result + self.section('MODULE REFERENCE', docloc + \"\"\"\n\nThe following documentation is automatically generated from the Python\nsource files.  It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations.  When in doubt, consult the module reference at the\nlocation listed above.\n\"\"\")\n\n        if desc:\n            result = result + self.section('DESCRIPTION', desc)\n\n        classes = []\n        for key, value in inspect.getmembers(object, inspect.isclass):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None\n                or (inspect.getmodule(value) or object) is object):\n                if visiblename(key, all, object):\n                    classes.append((key, value))\n        funcs = []\n        for key, value in inspect.getmembers(object, inspect.isroutine):\n            # if __all__ exists, believe it.  Otherwise use old heuristic.\n            if (all is not None or\n                inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n                if visiblename(key, all, object):\n                    funcs.append((key, value))\n        data = []\n        for key, value in inspect.getmembers(object, isdata):\n            if visiblename(key, all, object):\n                data.append((key, value))\n\n        modpkgs = []\n        modpkgs_names = set()\n        if hasattr(object, '__path__'):\n            for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n                modpkgs_names.add(modname)\n                if ispkg:\n                    modpkgs.append(modname + ' (package)')\n                else:\n                    modpkgs.append(modname)\n\n            modpkgs.sort()\n            result = result + self.section(\n                'PACKAGE CONTENTS', '\\n'.join(modpkgs))\n\n        # Detect submodules as sometimes created by C extensions\n        submodules = []\n        for key, value in inspect.getmembers(object, inspect.ismodule):\n            if value.__name__.startswith(name + '.') and key not in modpkgs_names:\n                submodules.append(key)\n        if submodules:\n            submodules.sort()\n            result = result + self.section(\n                'SUBMODULES', '\\n'.join(submodules))\n\n        if classes:\n            classlist = [value for key, value in classes]\n            contents = [self.formattree(\n                inspect.getclasstree(classlist, 1), name)]\n            for key, value in classes:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('CLASSES', '\\n'.join(contents))\n\n        if funcs:\n            contents = []\n            for key, value in funcs:\n                contents.append(self.document(value, key, name))\n            result = result + self.section('FUNCTIONS', '\\n'.join(contents))\n\n        if data:\n            contents = []\n            for key, value in data:\n                contents.append(self.docother(value, key, name, maxlen=70))\n            result = result + self.section('DATA', '\\n'.join(contents))\n\n        if hasattr(object, '__version__'):\n            version = str(object.__version__)\n            if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n                version = version[11:-1].strip()\n            result = result + self.section('VERSION', version)\n        if hasattr(object, '__date__'):\n            result = result + self.section('DATE', str(object.__date__))\n        if hasattr(object, '__author__'):\n            result = result + self.section('AUTHOR', str(object.__author__))\n        if hasattr(object, '__credits__'):\n            result = result + self.section('CREDITS', str(object.__credits__))\n        try:\n            file = inspect.getabsfile(object)\n        except TypeError:\n            file = '(built-in)'\n        result = result + self.section('FILE', file)\n        return result\n\n    def docclass(self, object, name=None, mod=None, *ignored):\n        \"\"\"Produce text documentation for a given class object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        bases = object.__bases__\n\n        def makename(c, m=object.__module__):\n            return classname(c, m)\n\n        if name == realname:\n            title = 'class ' + self.bold(realname)\n        else:\n            title = self.bold(name) + ' = class ' + realname\n        if bases:\n            parents = map(makename, bases)\n            title = title + '(%s)' % ', '.join(parents)\n\n        contents = []\n        push = contents.append\n\n        try:\n            signature = inspect.signature(object)\n        except (ValueError, TypeError):\n            signature = None\n        if signature:\n            argspec = str(signature)\n            if argspec and argspec != '()':\n                push(name + argspec + '\\n')\n\n        doc = getdoc(object)\n        if doc:\n            push(doc + '\\n')\n\n        # List the mro, if non-trivial.\n        mro = deque(inspect.getmro(object))\n        if len(mro) > 2:\n            push(\"Method resolution order:\")\n            for base in mro:\n                push('    ' + makename(base))\n            push('')\n\n        # List the built-in subclasses, if any:\n        subclasses = sorted(\n            (str(cls.__name__) for cls in type.__subclasses__(object)\n             if not cls.__name__.startswith(\"_\") and cls.__module__ == \"builtins\"),\n            key=str.lower\n        )\n        no_of_subclasses = len(subclasses)\n        MAX_SUBCLASSES_TO_DISPLAY = 4\n        if subclasses:\n            push(\"Built-in subclasses:\")\n            for subclassname in subclasses[:MAX_SUBCLASSES_TO_DISPLAY]:\n                push('    ' + subclassname)\n            if no_of_subclasses > MAX_SUBCLASSES_TO_DISPLAY:\n                push('    ... and ' +\n                     str(no_of_subclasses - MAX_SUBCLASSES_TO_DISPLAY) +\n                     ' other subclasses')\n            push('')\n\n        # Cute little class to pump out a horizontal rule between sections.\n        class HorizontalRule:\n            def __init__(self):\n                self.needone = 0\n            def maybe(self):\n                if self.needone:\n                    push('-' * 70)\n                self.needone = 1\n        hr = HorizontalRule()\n\n        def spill(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    try:\n                        value = getattr(object, name)\n                    except Exception:\n                        # Some descriptors may meet a failure in their __get__.\n                        # (bug #1785)\n                        push(self.docdata(value, name, mod))\n                    else:\n                        push(self.document(value,\n                                        name, mod, object))\n            return attrs\n\n        def spilldescriptors(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    push(self.docdata(value, name, mod))\n            return attrs\n\n        def spilldata(msg, attrs, predicate):\n            ok, attrs = _split_list(attrs, predicate)\n            if ok:\n                hr.maybe()\n                push(msg)\n                for name, kind, homecls, value in ok:\n                    doc = getdoc(value)\n                    try:\n                        obj = getattr(object, name)\n                    except AttributeError:\n                        obj = homecls.__dict__[name]\n                    push(self.docother(obj, name, mod, maxlen=70, doc=doc) +\n                         '\\n')\n            return attrs\n\n        attrs = [(name, kind, cls, value)\n                 for name, kind, cls, value in classify_class_attrs(object)\n                 if visiblename(name, obj=object)]\n\n        while attrs:\n            if mro:\n                thisclass = mro.popleft()\n            else:\n                thisclass = attrs[0][2]\n            attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n\n            if object is not builtins.object and thisclass is builtins.object:\n                attrs = inherited\n                continue\n            elif thisclass is object:\n                tag = \"defined here\"\n            else:\n                tag = \"inherited from %s\" % classname(thisclass,\n                                                      object.__module__)\n\n            sort_attributes(attrs, object)\n\n            # Pump out the attrs, segregated by kind.\n            attrs = spill(\"Methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'method')\n            attrs = spill(\"Class methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'class method')\n            attrs = spill(\"Static methods %s:\\n\" % tag, attrs,\n                          lambda t: t[1] == 'static method')\n            attrs = spilldescriptors(\"Readonly properties %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'readonly property')\n            attrs = spilldescriptors(\"Data descriptors %s:\\n\" % tag, attrs,\n                                     lambda t: t[1] == 'data descriptor')\n            attrs = spilldata(\"Data and other attributes %s:\\n\" % tag, attrs,\n                              lambda t: t[1] == 'data')\n\n            assert attrs == []\n            attrs = inherited\n\n        contents = '\\n'.join(contents)\n        if not contents:\n            return title + '\\n'\n        return title + '\\n' + self.indent(contents.rstrip(), ' |  ') + '\\n'\n\n    def formatvalue(self, object):\n        \"\"\"Format an argument default value as text.\"\"\"\n        return '=' + self.repr(object)\n\n    def docroutine(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a function or method object.\"\"\"\n        realname = object.__name__\n        name = name or realname\n        note = ''\n        skipdocs = 0\n        if _is_bound_method(object):\n            imclass = object.__self__.__class__\n            if cl:\n                if imclass is not cl:\n                    note = ' from ' + classname(imclass, mod)\n            else:\n                if object.__self__ is not None:\n                    note = ' method of %s instance' % classname(\n                        object.__self__.__class__, mod)\n                else:\n                    note = ' unbound %s method' % classname(imclass,mod)\n\n        if (inspect.iscoroutinefunction(object) or\n                inspect.isasyncgenfunction(object)):\n            asyncqualifier = 'async '\n        else:\n            asyncqualifier = ''\n\n        if name == realname:\n            title = self.bold(realname)\n        else:\n            if cl and inspect.getattr_static(cl, realname, []) is object:\n                skipdocs = 1\n            title = self.bold(name) + ' = ' + realname\n        argspec = None\n\n        if inspect.isroutine(object):\n            try:\n                signature = inspect.signature(object)\n            except (ValueError, TypeError):\n                signature = None\n            if signature:\n                argspec = str(signature)\n                if realname == '<lambda>':\n                    title = self.bold(name) + ' lambda '\n                    # XXX lambda's won't usually have func_annotations['return']\n                    # since the syntax doesn't support but it is possible.\n                    # So removing parentheses isn't truly safe.\n                    argspec = argspec[1:-1] # remove parentheses\n        if not argspec:\n            argspec = '(...)'\n        decl = asyncqualifier + title + argspec + note\n\n        if skipdocs:\n            return decl + '\\n'\n        else:\n            doc = getdoc(object) or ''\n            return decl + '\\n' + (doc and self.indent(doc).rstrip() + '\\n')\n\n    def docdata(self, object, name=None, mod=None, cl=None):\n        \"\"\"Produce text documentation for a data descriptor.\"\"\"\n        results = []\n        push = results.append\n\n        if name:\n            push(self.bold(name))\n            push('\\n')\n        doc = getdoc(object) or ''\n        if doc:\n            push(self.indent(doc))\n            push('\\n')\n        return ''.join(results)\n\n    docproperty = docdata\n\n    def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):\n        \"\"\"Produce text documentation for a data object.\"\"\"\n        repr = self.repr(object)\n        if maxlen:\n            line = (name and name + ' = ' or '') + repr\n            chop = maxlen - len(line)\n            if chop < 0: repr = repr[:chop] + '...'\n        line = (name and self.bold(name) + ' = ' or '') + repr\n        if not doc:\n            doc = getdoc(object)\n        if doc:\n            line += '\\n' + self.indent(str(doc)) + '\\n'\n        return line", "target": 0}, {"function": "class _PlainTextDoc(TextDoc):\n    \"\"\"Subclass of TextDoc which overrides string styling\"\"\"\n    def bold(self, text):\n        return text", "target": 0}, {"function": "def pager(text):\n    \"\"\"The first time this is called, determine what kind of pager to use.\"\"\"\n    global pager\n    pager = getpager()\n    pager(text)", "target": 0}, {"function": "def getpager():\n    \"\"\"Decide what method to use for paging through text.\"\"\"\n    if not hasattr(sys.stdin, \"isatty\"):\n        return plainpager\n    if not hasattr(sys.stdout, \"isatty\"):\n        return plainpager\n    if not sys.stdin.isatty() or not sys.stdout.isatty():\n        return plainpager\n    use_pager = os.environ.get('MANPAGER') or os.environ.get('PAGER')\n    if use_pager:\n        if sys.platform == 'win32': # pipes completely broken in Windows\n            return lambda text: tempfilepager(plain(text), use_pager)\n        elif os.environ.get('TERM') in ('dumb', 'emacs'):\n            return lambda text: pipepager(plain(text), use_pager)\n        else:\n            return lambda text: pipepager(text, use_pager)\n    if os.environ.get('TERM') in ('dumb', 'emacs'):\n        return plainpager\n    if sys.platform == 'win32':\n        return lambda text: tempfilepager(plain(text), 'more <')\n    if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n        return lambda text: pipepager(text, 'less')\n\n    import tempfile\n    (fd, filename) = tempfile.mkstemp()\n    os.close(fd)\n    try:\n        if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n            return lambda text: pipepager(text, 'more')\n        else:\n            return ttypager\n    finally:\n        os.unlink(filename)", "target": 0}, {"function": "def plain(text):\n    \"\"\"Remove boldface formatting from text.\"\"\"\n    return re.sub('.\\b', '', text)", "target": 0}, {"function": "def pipepager(text, cmd):\n    \"\"\"Page through text by feeding it to another program.\"\"\"\n    import subprocess\n    proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE)\n    try:\n        with io.TextIOWrapper(proc.stdin, errors='backslashreplace') as pipe:\n            try:\n                pipe.write(text)\n            except KeyboardInterrupt:\n                # We've hereby abandoned whatever text hasn't been written,\n                # but the pager is still in control of the terminal.\n                pass\n    except OSError:\n        pass # Ignore broken pipes caused by quitting the pager program.\n    while True:\n        try:\n            proc.wait()\n            break\n        except KeyboardInterrupt:\n            # Ignore ctl-c like the pager itself does.  Otherwise the pager is\n            # left running and the terminal is in raw mode and unusable.\n            pass", "target": 0}, {"function": "def tempfilepager(text, cmd):\n    \"\"\"Page through text by invoking a program on a temporary file.\"\"\"\n    import tempfile\n    filename = tempfile.mktemp()\n    with open(filename, 'w', errors='backslashreplace') as file:\n        file.write(text)\n    try:\n        os.system(cmd + ' \"' + filename + '\"')\n    finally:\n        os.unlink(filename)", "target": 0}, {"function": "def _escape_stdout(text):\n    # Escape non-encodable characters to avoid encoding errors later\n    encoding = getattr(sys.stdout, 'encoding', None) or 'utf-8'\n    return text.encode(encoding, 'backslashreplace').decode(encoding)", "target": 0}, {"function": "def ttypager(text):\n    \"\"\"Page through text on a text terminal.\"\"\"\n    lines = plain(_escape_stdout(text)).split('\\n')\n    try:\n        import tty\n        fd = sys.stdin.fileno()\n        old = tty.tcgetattr(fd)\n        tty.setcbreak(fd)\n        getchar = lambda: sys.stdin.read(1)\n    except (ImportError, AttributeError, io.UnsupportedOperation):\n        tty = None\n        getchar = lambda: sys.stdin.readline()[:-1][:1]\n\n    try:\n        try:\n            h = int(os.environ.get('LINES', 0))\n        except ValueError:\n            h = 0\n        if h <= 1:\n            h = 25\n        r = inc = h - 1\n        sys.stdout.write('\\n'.join(lines[:inc]) + '\\n')\n        while lines[r:]:\n            sys.stdout.write('-- more --')\n            sys.stdout.flush()\n            c = getchar()\n\n            if c in ('q', 'Q'):\n                sys.stdout.write('\\r          \\r')\n                break\n            elif c in ('\\r', '\\n'):\n                sys.stdout.write('\\r          \\r' + lines[r] + '\\n')\n                r = r + 1\n                continue\n            if c in ('b', 'B', '\\x1b'):\n                r = r - inc - inc\n                if r < 0: r = 0\n            sys.stdout.write('\\n' + '\\n'.join(lines[r:r+inc]) + '\\n')\n            r = r + inc\n\n    finally:\n        if tty:\n            tty.tcsetattr(fd, tty.TCSAFLUSH, old)", "target": 0}, {"function": "def plainpager(text):\n    \"\"\"Simply print unformatted text.  This is the ultimate fallback.\"\"\"\n    sys.stdout.write(plain(_escape_stdout(text)))", "target": 0}, {"function": "def describe(thing):\n    \"\"\"Produce a short description of the given thing.\"\"\"\n    if inspect.ismodule(thing):\n        if thing.__name__ in sys.builtin_module_names:\n            return 'built-in module ' + thing.__name__\n        if hasattr(thing, '__path__'):\n            return 'package ' + thing.__name__\n        else:\n            return 'module ' + thing.__name__\n    if inspect.isbuiltin(thing):\n        return 'built-in function ' + thing.__name__\n    if inspect.isgetsetdescriptor(thing):\n        return 'getset descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.ismemberdescriptor(thing):\n        return 'member descriptor %s.%s.%s' % (\n            thing.__objclass__.__module__, thing.__objclass__.__name__,\n            thing.__name__)\n    if inspect.isclass(thing):\n        return 'class ' + thing.__name__\n    if inspect.isfunction(thing):\n        return 'function ' + thing.__name__\n    if inspect.ismethod(thing):\n        return 'method ' + thing.__name__\n    return type(thing).__name__", "target": 0}, {"function": "def locate(path, forceload=0):\n    \"\"\"Locate an object by name or dotted path, importing as necessary.\"\"\"\n    parts = [part for part in path.split('.') if part]\n    module, n = None, 0\n    while n < len(parts):\n        nextmodule = safeimport('.'.join(parts[:n+1]), forceload)\n        if nextmodule: module, n = nextmodule, n + 1\n        else: break\n    if module:\n        object = module\n    else:\n        object = builtins\n    for part in parts[n:]:\n        try:\n            object = getattr(object, part)\n        except AttributeError:\n            return None\n    return object", "target": 0}, {"function": "def resolve(thing, forceload=0):\n    \"\"\"Given an object or a path to an object, get the object and its name.\"\"\"\n    if isinstance(thing, str):\n        object = locate(thing, forceload)\n        if object is None:\n            raise ImportError('''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.''' % thing)\n        return object, thing\n    else:\n        name = getattr(thing, '__name__', None)\n        return thing, name if isinstance(name, str) else None", "target": 0}, {"function": "def render_doc(thing, title='Python Library Documentation: %s', forceload=0,\n        renderer=None):\n    \"\"\"Render text documentation, given an object or a path to an object.\"\"\"\n    if renderer is None:\n        renderer = text\n    object, name = resolve(thing, forceload)\n    desc = describe(object)\n    module = inspect.getmodule(object)\n    if name and '.' in name:\n        desc += ' in ' + name[:name.rfind('.')]\n    elif module and module is not object:\n        desc += ' in module ' + module.__name__\n\n    if not (inspect.ismodule(object) or\n              inspect.isclass(object) or\n              inspect.isroutine(object) or\n              inspect.isdatadescriptor(object) or\n              _getdoc(object)):\n        # If the passed object is a piece of data or an instance,\n        # document its available methods instead of its value.\n        if hasattr(object, '__origin__'):\n            object = object.__origin__\n        else:\n            object = type(object)\n            desc += ' object'\n    return title % desc + '\\n\\n' + renderer.document(object, name)", "target": 0}, {"function": "def doc(thing, title='Python Library Documentation: %s', forceload=0,\n        output=None):\n    \"\"\"Display text documentation, given an object or a path to an object.\"\"\"\n    try:\n        if output is None:\n            pager(render_doc(thing, title, forceload))\n        else:\n            output.write(render_doc(thing, title, forceload, plaintext))\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)", "target": 0}, {"function": "def writedoc(thing, forceload=0):\n    \"\"\"Write HTML documentation to a file in the current directory.\"\"\"\n    try:\n        object, name = resolve(thing, forceload)\n        page = html.page(describe(object), html.document(object, name))\n        with open(name + '.html', 'w', encoding='utf-8') as file:\n            file.write(page)\n        print('wrote', name + '.html')\n    except (ImportError, ErrorDuringImport) as value:\n        print(value)", "target": 0}, {"function": "def writedocs(dir, pkgpath='', done=None):\n    \"\"\"Write out HTML documentation for all modules in a directory tree.\"\"\"\n    if done is None: done = {}\n    for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):\n        writedoc(modname)\n    return", "target": 0}, {"function": "class Helper:\n\n    # These dictionaries map a topic name to either an alias, or a tuple\n    # (label, seealso-items).  The \"label\" is the label of the corresponding\n    # section in the .rst file under Doc/ and an index into the dictionary\n    # in pydoc_data/topics.py.\n    #\n    # CAUTION: if you change one of these dictionaries, be sure to adapt the\n    #          list of needed labels in Doc/tools/extensions/pyspecific.py and\n    #          regenerate the pydoc_data/topics.py file by running\n    #              make pydoc-topics\n    #          in Doc/ and copying the output file into the Lib/ directory.\n\n    keywords = {\n        'False': '',\n        'None': '',\n        'True': '',\n        'and': 'BOOLEAN',\n        'as': 'with',\n        'assert': ('assert', ''),\n        'async': ('async', ''),\n        'await': ('await', ''),\n        'break': ('break', 'while for'),\n        'class': ('class', 'CLASSES SPECIALMETHODS'),\n        'continue': ('continue', 'while for'),\n        'def': ('function', ''),\n        'del': ('del', 'BASICMETHODS'),\n        'elif': 'if',\n        'else': ('else', 'while for'),\n        'except': 'try',\n        'finally': 'try',\n        'for': ('for', 'break continue while'),\n        'from': 'import',\n        'global': ('global', 'nonlocal NAMESPACES'),\n        'if': ('if', 'TRUTHVALUE'),\n        'import': ('import', 'MODULES'),\n        'in': ('in', 'SEQUENCEMETHODS'),\n        'is': 'COMPARISON',\n        'lambda': ('lambda', 'FUNCTIONS'),\n        'nonlocal': ('nonlocal', 'global NAMESPACES'),\n        'not': 'BOOLEAN',\n        'or': 'BOOLEAN',\n        'pass': ('pass', ''),\n        'raise': ('raise', 'EXCEPTIONS'),\n        'return': ('return', 'FUNCTIONS'),\n        'try': ('try', 'EXCEPTIONS'),\n        'while': ('while', 'break continue if TRUTHVALUE'),\n        'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),\n        'yield': ('yield', ''),\n    }\n    # Either add symbols to this dictionary or to the symbols dictionary\n    # directly: Whichever is easier. They are merged later.\n    _strprefixes = [p + q for p in ('b', 'f', 'r', 'u') for q in (\"'\", '\"')]\n    _symbols_inverse = {\n        'STRINGS' : (\"'\", \"'''\", '\"', '\"\"\"', *_strprefixes),\n        'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',\n                       '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),\n        'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),\n        'UNARY' : ('-', '~'),\n        'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',\n                                '^=', '<<=', '>>=', '**=', '//='),\n        'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),\n        'COMPLEX' : ('j', 'J')\n    }\n    symbols = {\n        '%': 'OPERATORS FORMATTING',\n        '**': 'POWER',\n        ',': 'TUPLES LISTS FUNCTIONS',\n        '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',\n        '...': 'ELLIPSIS',\n        ':': 'SLICINGS DICTIONARYLITERALS',\n        '@': 'def class',\n        '\\\\': 'STRINGS',\n        '_': 'PRIVATENAMES',\n        '__': 'PRIVATENAMES SPECIALMETHODS',\n        '`': 'BACKQUOTES',\n        '(': 'TUPLES FUNCTIONS CALLS',\n        ')': 'TUPLES FUNCTIONS CALLS',\n        '[': 'LISTS SUBSCRIPTS SLICINGS',\n        ']': 'LISTS SUBSCRIPTS SLICINGS'\n    }\n    for topic, symbols_ in _symbols_inverse.items():\n        for symbol in symbols_:\n            topics = symbols.get(symbol, topic)\n            if topic not in topics:\n                topics = topics + ' ' + topic\n            symbols[symbol] = topics\n\n    topics = {\n        'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '\n                  'FUNCTIONS CLASSES MODULES FILES inspect'),\n        'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),\n        'FORMATTING': ('formatstrings', 'OPERATORS'),\n        'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '\n                    'FORMATTING TYPES'),\n        'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),\n        'INTEGER': ('integers', 'int range'),\n        'FLOAT': ('floating', 'float math'),\n        'COMPLEX': ('imaginary', 'complex cmath'),\n        'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING range LISTS'),\n        'MAPPINGS': 'DICTIONARIES',\n        'FUNCTIONS': ('typesfunctions', 'def TYPES'),\n        'METHODS': ('typesmethods', 'class def CLASSES TYPES'),\n        'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),\n        'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),\n        'FRAMEOBJECTS': 'TYPES',\n        'TRACEBACKS': 'TYPES',\n        'NONE': ('bltin-null-object', ''),\n        'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),\n        'SPECIALATTRIBUTES': ('specialattrs', ''),\n        'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),\n        'MODULES': ('typesmodules', 'import'),\n        'PACKAGES': 'import',\n        'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '\n                        'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '\n                        'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '\n                        'LISTS DICTIONARIES'),\n        'OPERATORS': 'EXPRESSIONS',\n        'PRECEDENCE': 'EXPRESSIONS',\n        'OBJECTS': ('objects', 'TYPES'),\n        'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '\n                           'CALLABLEMETHODS SEQUENCEMETHODS MAPPINGMETHODS '\n                           'NUMBERMETHODS CLASSES'),\n        'BASICMETHODS': ('customization', 'hash repr str SPECIALMETHODS'),\n        'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),\n        'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),\n        'SEQUENCEMETHODS': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS '\n                             'SPECIALMETHODS'),\n        'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),\n        'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '\n                          'SPECIALMETHODS'),\n        'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),\n        'NAMESPACES': ('naming', 'global nonlocal ASSIGNMENT DELETION DYNAMICFEATURES'),\n        'DYNAMICFEATURES': ('dynamic-features', ''),\n        'SCOPING': 'NAMESPACES',\n        'FRAMES': 'NAMESPACES',\n        'EXCEPTIONS': ('exceptions', 'try except finally raise'),\n        'CONVERSIONS': ('conversions', ''),\n        'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),\n        'SPECIALIDENTIFIERS': ('id-classes', ''),\n        'PRIVATENAMES': ('atom-identifiers', ''),\n        'LITERALS': ('atom-literals', 'STRINGS NUMBERS TUPLELITERALS '\n                     'LISTLITERALS DICTIONARYLITERALS'),\n        'TUPLES': 'SEQUENCES',\n        'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),\n        'LISTS': ('typesseq-mutable', 'LISTLITERALS'),\n        'LISTLITERALS': ('lists', 'LISTS LITERALS'),\n        'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),\n        'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),\n        'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr ATTRIBUTEMETHODS'),\n        'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS'),\n        'SLICINGS': ('slicings', 'SEQUENCEMETHODS'),\n        'CALLS': ('calls', 'EXPRESSIONS'),\n        'POWER': ('power', 'EXPRESSIONS'),\n        'UNARY': ('unary', 'EXPRESSIONS'),\n        'BINARY': ('binary', 'EXPRESSIONS'),\n        'SHIFTING': ('shifting', 'EXPRESSIONS'),\n        'BITWISE': ('bitwise', 'EXPRESSIONS'),\n        'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),\n        'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),\n        'ASSERTION': 'assert',\n        'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),\n        'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),\n        'DELETION': 'del',\n        'RETURNING': 'return',\n        'IMPORTING': 'import',\n        'CONDITIONAL': 'if',\n        'LOOPING': ('compound', 'for while break continue'),\n        'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),\n        'DEBUGGING': ('debugger', 'pdb'),\n        'CONTEXTMANAGERS': ('context-managers', 'with'),\n    }\n\n    def __init__(self, input=None, output=None):\n        self._input = input\n        self._output = output\n\n    @property\n    def input(self):\n        return self._input or sys.stdin\n\n    @property\n    def output(self):\n        return self._output or sys.stdout\n\n    def __repr__(self):\n        if inspect.stack()[1][3] == '?':\n            self()\n            return ''\n        return '<%s.%s instance>' % (self.__class__.__module__,\n                                     self.__class__.__qualname__)\n\n    _GoInteractive = object()\n    def __call__(self, request=_GoInteractive):\n        if request is not self._GoInteractive:\n            self.help(request)\n        else:\n            self.intro()\n            self.interact()\n            self.output.write('''\nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help> prompt.\n''')\n\n    def interact(self):\n        self.output.write('\\n')\n        while True:\n            try:\n                request = self.getline('help> ')\n                if not request: break\n            except (KeyboardInterrupt, EOFError):\n                break\n            request = request.strip()\n\n            # Make sure significant trailing quoting marks of literals don't\n            # get deleted while cleaning input\n            if (len(request) > 2 and request[0] == request[-1] in (\"'\", '\"')\n                    and request[0] not in request[1:-1]):\n                request = request[1:-1]\n            if request.lower() in ('q', 'quit'): break\n            if request == 'help':\n                self.intro()\n            else:\n                self.help(request)\n\n    def getline(self, prompt):\n        \"\"\"Read one line, using input() when appropriate.\"\"\"\n        if self.input is sys.stdin:\n            return input(prompt)\n        else:\n            self.output.write(prompt)\n            self.output.flush()\n            return self.input.readline()\n\n    def help(self, request):\n        if type(request) is type(''):\n            request = request.strip()\n            if request == 'keywords': self.listkeywords()\n            elif request == 'symbols': self.listsymbols()\n            elif request == 'topics': self.listtopics()\n            elif request == 'modules': self.listmodules()\n            elif request[:8] == 'modules ':\n                self.listmodules(request.split()[1])\n            elif request in self.symbols: self.showsymbol(request)\n            elif request in ['True', 'False', 'None']:\n                # special case these keywords since they are objects too\n                doc(eval(request), 'Help on %s:')\n            elif request in self.keywords: self.showtopic(request)\n            elif request in self.topics: self.showtopic(request)\n            elif request: doc(request, 'Help on %s:', output=self._output)\n            else: doc(str, 'Help on %s:', output=self._output)\n        elif isinstance(request, Helper): self()\n        else: doc(request, 'Help on %s:', output=self._output)\n        self.output.write('\\n')\n\n    def intro(self):\n        self.output.write('''\nWelcome to Python {0}'s help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/{0}/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n\"modules\", \"keywords\", \"symbols\", or \"topics\".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as \"spam\", type \"modules spam\".\n'''.format('%d.%d' % sys.version_info[:2]))\n\n    def list(self, items, columns=4, width=80):\n        items = list(sorted(items))\n        colw = width // columns\n        rows = (len(items) + columns - 1) // columns\n        for row in range(rows):\n            for col in range(columns):\n                i = col * rows + row\n                if i < len(items):\n                    self.output.write(items[i])\n                    if col < columns - 1:\n                        self.output.write(' ' + ' ' * (colw - 1 - len(items[i])))\n            self.output.write('\\n')\n\n    def listkeywords(self):\n        self.output.write('''\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\n''')\n        self.list(self.keywords.keys())\n\n    def listsymbols(self):\n        self.output.write('''\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n''')\n        self.list(self.symbols.keys())\n\n    def listtopics(self):\n        self.output.write('''\nHere is a list of available topics.  Enter any topic name to get more help.\n\n''')\n        self.list(self.topics.keys())\n\n    def showtopic(self, topic, more_xrefs=''):\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            self.output.write('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''')\n            return\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        if type(target) is type(''):\n            return self.showtopic(target, more_xrefs)\n\n        label, xrefs = target\n        try:\n            doc = pydoc_data.topics.topics[label]\n        except KeyError:\n            self.output.write('no documentation found for %s\\n' % repr(topic))\n            return\n        doc = doc.strip() + '\\n'\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        if xrefs:\n            import textwrap\n            text = 'Related help topics: ' + ', '.join(xrefs.split()) + '\\n'\n            wrapped_text = textwrap.wrap(text, 72)\n            doc += '\\n%s\\n' % '\\n'.join(wrapped_text)\n        pager(doc)\n\n    def _gettopic(self, topic, more_xrefs=''):\n        \"\"\"Return unbuffered tuple of (topic, xrefs).\n\n        If an error occurs here, the exception is caught and displayed by\n        the url handler.\n\n        This function duplicates the showtopic method but returns its\n        result directly so it can be formatted for display in an html page.\n        \"\"\"\n        try:\n            import pydoc_data.topics\n        except ImportError:\n            return('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n''' , '')\n        target = self.topics.get(topic, self.keywords.get(topic))\n        if not target:\n            raise ValueError('could not find topic')\n        if isinstance(target, str):\n            return self._gettopic(target, more_xrefs)\n        label, xrefs = target\n        doc = pydoc_data.topics.topics[label]\n        if more_xrefs:\n            xrefs = (xrefs or '') + ' ' + more_xrefs\n        return doc, xrefs\n\n    def showsymbol(self, symbol):\n        target = self.symbols[symbol]\n        topic, _, xrefs = target.partition(' ')\n        self.showtopic(topic, xrefs)\n\n    def listmodules(self, key=''):\n        if key:\n            self.output.write('''\nHere is a list of modules whose name or summary contains '{}'.\nIf there are any, enter a module name to get more help.\n\n'''.format(key))\n            apropos(key)\n        else:\n            self.output.write('''\nPlease wait a moment while I gather a list of all available modules...\n\n''')\n            modules = {}\n            def callback(path, modname, desc, modules=modules):\n                if modname and modname[-9:] == '.__init__':\n                    modname = modname[:-9] + ' (package)'\n                if modname.find('.') < 0:\n                    modules[modname] = 1\n            def onerror(modname):\n                callback(None, modname, None)\n            ModuleScanner().run(callback, onerror=onerror)\n            self.list(modules.keys())\n            self.output.write('''\nEnter any module name to get more help.  Or, type \"modules spam\" to search\nfor modules whose name or summary contain the string \"spam\".\n''')", "target": 0}, {"function": "class ModuleScanner:\n    \"\"\"An interruptible scanner that searches module synopses.\"\"\"\n\n    def run(self, callback, key=None, completer=None, onerror=None):\n        if key: key = key.lower()\n        self.quit = False\n        seen = {}\n\n        for modname in sys.builtin_module_names:\n            if modname != '__main__':\n                seen[modname] = 1\n                if key is None:\n                    callback(None, modname, '')\n                else:\n                    name = __import__(modname).__doc__ or ''\n                    desc = name.split('\\n')[0]\n                    name = modname + ' - ' + desc\n                    if name.lower().find(key) >= 0:\n                        callback(None, modname, desc)\n\n        for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):\n            if self.quit:\n                break\n\n            if key is None:\n                callback(None, modname, '')\n            else:\n                try:\n                    spec = pkgutil._get_spec(importer, modname)\n                except SyntaxError:\n                    # raised by tests for bad coding cookies or BOM\n                    continue\n                loader = spec.loader\n                if hasattr(loader, 'get_source'):\n                    try:\n                        source = loader.get_source(modname)\n                    except Exception:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = source_synopsis(io.StringIO(source)) or ''\n                    if hasattr(loader, 'get_filename'):\n                        path = loader.get_filename(modname)\n                    else:\n                        path = None\n                else:\n                    try:\n                        module = importlib._bootstrap._load(spec)\n                    except ImportError:\n                        if onerror:\n                            onerror(modname)\n                        continue\n                    desc = module.__doc__.splitlines()[0] if module.__doc__ else ''\n                    path = getattr(module,'__file__',None)\n                name = modname + ' - ' + desc\n                if name.lower().find(key) >= 0:\n                    callback(path, modname, desc)\n\n        if completer:\n            completer()", "target": 0}, {"function": "def apropos(key):\n    \"\"\"Print all the one-line module summaries that contain a substring.\"\"\"\n    def callback(path, modname, desc):\n        if modname[-9:] == '.__init__':\n            modname = modname[:-9] + ' (package)'\n        print(modname, desc and '- ' + desc)\n    def onerror(modname):\n        pass\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore') # ignore problems during import\n        ModuleScanner().run(callback, key, onerror=onerror)", "target": 0}, {"function": "def _start_server(urlhandler, hostname, port):\n    \"\"\"Start an HTTP server thread on a specific port.\n\n    Start an HTML/text server thread, so HTML or text documents can be\n    browsed dynamically and interactively with a Web browser.  Example use:\n\n        >>> import time\n        >>> import pydoc\n\n        Define a URL handler.  To determine what the client is asking\n        for, check the URL and content_type.\n\n        Then get or generate some text or HTML code and return it.\n\n        >>> def my_url_handler(url, content_type):\n        ...     text = 'the URL sent was: (%s, %s)' % (url, content_type)\n        ...     return text\n\n        Start server thread on port 0.\n        If you use port 0, the server will pick a random port number.\n        You can then use serverthread.port to get the port number.\n\n        >>> port = 0\n        >>> serverthread = pydoc._start_server(my_url_handler, port)\n\n        Check that the server is really started.  If it is, open browser\n        and get first page.  Use serverthread.url as the starting page.\n\n        >>> if serverthread.serving:\n        ...    import webbrowser\n\n        The next two lines are commented out so a browser doesn't open if\n        doctest is run on this module.\n\n        #...    webbrowser.open(serverthread.url)\n        #True\n\n        Let the server do its thing. We just need to monitor its status.\n        Use time.sleep so the loop doesn't hog the CPU.\n\n        >>> starttime = time.monotonic()\n        >>> timeout = 1                    #seconds\n\n        This is a short timeout for testing purposes.\n\n        >>> while serverthread.serving:\n        ...     time.sleep(.01)\n        ...     if serverthread.serving and time.monotonic() - starttime > timeout:\n        ...          serverthread.stop()\n        ...          break\n\n        Print any errors that may have occurred.\n\n        >>> print(serverthread.error)\n        None\n   \"\"\"\n    import http.server\n    import email.message\n    import select\n    import threading\n\n    class DocHandler(http.server.BaseHTTPRequestHandler):\n\n        def do_GET(self):\n            \"\"\"Process a request from an HTML browser.\n\n            The URL received is in self.path.\n            Get an HTML page from self.urlhandler and send it.\n            \"\"\"\n            if self.path.endswith('.css'):\n                content_type = 'text/css'\n            else:\n                content_type = 'text/html'\n            self.send_response(200)\n            self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)\n            self.end_headers()\n            self.wfile.write(self.urlhandler(\n                self.path, content_type).encode('utf-8'))\n\n        def log_message(self, *args):\n            # Don't log messages.\n            pass\n\n    class DocServer(http.server.HTTPServer):\n\n        def __init__(self, host, port, callback):\n            self.host = host\n            self.address = (self.host, port)\n            self.callback = callback\n            self.base.__init__(self, self.address, self.handler)\n            self.quit = False\n\n        def serve_until_quit(self):\n            while not self.quit:\n                rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)\n                if rd:\n                    self.handle_request()\n            self.server_close()\n\n        def server_activate(self):\n            self.base.server_activate(self)\n            if self.callback:\n                self.callback(self)\n\n    class ServerThread(threading.Thread):\n\n        def __init__(self, urlhandler, host, port):\n            self.urlhandler = urlhandler\n            self.host = host\n            self.port = int(port)\n            threading.Thread.__init__(self)\n            self.serving = False\n            self.error = None\n\n        def run(self):\n            \"\"\"Start the server.\"\"\"\n            try:\n                DocServer.base = http.server.HTTPServer\n                DocServer.handler = DocHandler\n                DocHandler.MessageClass = email.message.Message\n                DocHandler.urlhandler = staticmethod(self.urlhandler)\n                docsvr = DocServer(self.host, self.port, self.ready)\n                self.docserver = docsvr\n                docsvr.serve_until_quit()\n            except Exception as e:\n                self.error = e\n\n        def ready(self, server):\n            self.serving = True\n            self.host = server.host\n            self.port = server.server_port\n            self.url = 'http://%s:%d/' % (self.host, self.port)\n\n        def stop(self):\n            \"\"\"Stop the server and this thread nicely\"\"\"\n            self.docserver.quit = True\n            self.join()\n            # explicitly break a reference cycle: DocServer.callback\n            # has indirectly a reference to ServerThread.\n            self.docserver = None\n            self.serving = False\n            self.url = None\n\n    thread = ServerThread(urlhandler, hostname, port)\n    thread.start()\n    # Wait until thread.serving is True to make sure we are\n    # really up before returning.\n    while not thread.error and not thread.serving:\n        time.sleep(.01)\n    return thread", "target": 0}, {"function": "def _url_handler(url, content_type=\"text/html\"):\n    \"\"\"The pydoc url handler for use with the pydoc server.\n\n    If the content_type is 'text/css', the _pydoc.css style\n    sheet is read and returned if it exits.\n\n    If the content_type is 'text/html', then the result of\n    get_html_page(url) is returned.\n    \"\"\"\n    class _HTMLDoc(HTMLDoc):\n\n        def page(self, title, contents):\n            \"\"\"Format an HTML page.\"\"\"\n            css_path = \"pydoc_data/_pydoc.css\"\n            css_link = (\n                '<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n                css_path)\n            return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n</body></html>''' % (title, css_link, html_navbar(), contents)\n\n\n    html = _HTMLDoc()\n\n    def html_navbar():\n        version = html.escape(\"%s [%s, %s]\" % (platform.python_version(),\n                                               platform.python_build()[0],\n                                               platform.python_compiler()))\n        return \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:center'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div>\n                    <form action=\"get\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Get\">\n                    </form>&nbsp;\n                    <form action=\"search\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\" % (version, html.escape(platform.platform(terse=True)))\n\n    def html_index():\n        \"\"\"Module Index page.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>Index of Modules</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = [name for name in sys.builtin_module_names\n                 if name != '__main__']\n        contents = html.multicolumn(names, bltinlink)\n        contents = [heading, '<p>' + html.bigsection(\n            'Built-in Modules', '#ffffff', '#ee77aa', contents)]\n\n        seen = {}\n        for dir in sys.path:\n            contents.append(html.index(dir, seen))\n\n        contents.append(\n            '<p align=right><font color=\"#909090\" face=\"helvetica,'\n            'arial\"><strong>pydoc</strong> by Ka-Ping Yee'\n            '&lt;ping@lfw.org&gt;</font>')\n        return 'Index of Modules', ''.join(contents)\n\n    def html_search(key):\n        \"\"\"Search results page.\"\"\"\n        # scan for modules\n        search_result = []\n\n        def callback(path, modname, desc):\n            if modname[-9:] == '.__init__':\n                modname = modname[:-9] + ' (package)'\n            search_result.append((modname, desc and '- ' + desc))\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore') # ignore problems during import\n            def onerror(modname):\n                pass\n            ModuleScanner().run(callback, key, onerror=onerror)\n\n        # format page\n        def bltinlink(name):\n            return '<a href=\"%s.html\">%s</a>' % (name, name)\n\n        results = []\n        heading = html.heading(\n            '<big><big><strong>Search Results</strong></big></big>',\n            '#ffffff', '#7799ee')\n        for name, desc in search_result:\n            results.append(bltinlink(name) + desc)\n        contents = heading + html.bigsection(\n            'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n        return 'Search Results', contents\n\n    def html_topics():\n        \"\"\"Index of topic texts available.\"\"\"\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.topics.keys())\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Topics', '#ffffff', '#ee77aa', contents)\n        return 'Topics', contents\n\n    def html_keywords():\n        \"\"\"Index of keywords.\"\"\"\n        heading = html.heading(\n            '<big><big><strong>INDEX</strong></big></big>',\n            '#ffffff', '#7799ee')\n        names = sorted(Helper.keywords.keys())\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n        contents = html.multicolumn(names, bltinlink)\n        contents = heading + html.bigsection(\n            'Keywords', '#ffffff', '#ee77aa', contents)\n        return 'Keywords', contents\n\n    def html_topicpage(topic):\n        \"\"\"Topic or keyword help page.\"\"\"\n        buf = io.StringIO()\n        htmlhelp = Helper(buf, buf)\n        contents, xrefs = htmlhelp._gettopic(topic)\n        if topic in htmlhelp.keywords:\n            title = 'KEYWORD'\n        else:\n            title = 'TOPIC'\n        heading = html.heading(\n            '<big><big><strong>%s</strong></big></big>' % title,\n            '#ffffff', '#7799ee')\n        contents = '<pre>%s</pre>' % html.markup(contents)\n        contents = html.bigsection(topic , '#ffffff','#ee77aa', contents)\n        if xrefs:\n            xrefs = sorted(xrefs.split())\n\n            def bltinlink(name):\n                return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n\n            xrefs = html.multicolumn(xrefs, bltinlink)\n            xrefs = html.section('Related help topics: ',\n                                 '#ffffff', '#ee77aa', xrefs)\n        return ('%s %s' % (title, topic),\n                ''.join((heading, contents, xrefs)))\n\n    def html_getobj(url):\n        obj = locate(url, forceload=1)\n        if obj is None and url != 'None':\n            raise ValueError('could not find object')\n        title = describe(obj)\n        content = html.document(obj, url)\n        return title, content\n\n    def html_error(url, exc):\n        heading = html.heading(\n            '<big><big><strong>Error</strong></big></big>',\n            '#ffffff', '#7799ee')\n        contents = '<br>'.join(html.escape(line) for line in\n                               format_exception_only(type(exc), exc))\n        contents = heading + html.bigsection(url, '#ffffff', '#bb0000',\n                                             contents)\n        return \"Error - %s\" % url, contents\n\n    def get_html_page(url):\n        \"\"\"Generate an HTML page for url.\"\"\"\n        complete_url = url\n        if url.endswith('.html'):\n            url = url[:-5]\n        try:\n            if url in (\"\", \"index\"):\n                title, content = html_index()\n            elif url == \"topics\":\n                title, content = html_topics()\n            elif url == \"keywords\":\n                title, content = html_keywords()\n            elif '=' in url:\n                op, _, url = url.partition('=')\n                if op == \"search?key\":\n                    title, content = html_search(url)\n                elif op == \"topic?key\":\n                    # try topics first, then objects.\n                    try:\n                        title, content = html_topicpage(url)\n                    except ValueError:\n                        title, content = html_getobj(url)\n                elif op == \"get?key\":\n                    # try objects first, then topics.\n                    if url in (\"\", \"index\"):\n                        title, content = html_index()\n                    else:\n                        try:\n                            title, content = html_getobj(url)\n                        except ValueError:\n                            title, content = html_topicpage(url)\n                else:\n                    raise ValueError('bad pydoc url')\n            else:\n                title, content = html_getobj(url)\n        except Exception as exc:\n            # Catch any errors and display them in an error page.\n            title, content = html_error(complete_url, exc)\n        return html.page(title, content)\n\n    if url.startswith('/'):\n        url = url[1:]\n    if content_type == 'text/css':\n        path_here = os.path.dirname(os.path.realpath(__file__))\n        css_path = os.path.join(path_here, url)\n        with open(css_path) as fp:\n            return ''.join(fp.readlines())\n    elif content_type == 'text/html':\n        return get_html_page(url)\n    # Errors outside the url handler are caught by the server.\n    raise TypeError('unknown content type %r for url %s' % (content_type, url))", "target": 0}, {"function": "def browse(port=0, *, open_browser=True, hostname='localhost'):\n    \"\"\"Start the enhanced pydoc Web server and open a Web browser.\n\n    Use port '0' to start the server on an arbitrary port.\n    Set open_browser to False to suppress opening a browser.\n    \"\"\"\n    import webbrowser\n    serverthread = _start_server(_url_handler, hostname, port)\n    if serverthread.error:\n        print(serverthread.error)\n        return\n    if serverthread.serving:\n        server_help_msg = 'Server commands: [b]rowser, [q]uit'\n        if open_browser:\n            webbrowser.open(serverthread.url)\n        try:\n            print('Server ready at', serverthread.url)\n            print(server_help_msg)\n            while serverthread.serving:\n                cmd = input('server> ')\n                cmd = cmd.lower()\n                if cmd == 'q':\n                    break\n                elif cmd == 'b':\n                    webbrowser.open(serverthread.url)\n                else:\n                    print(server_help_msg)\n        except (KeyboardInterrupt, EOFError):\n            print()\n        finally:\n            if serverthread.serving:\n                serverthread.stop()\n                print('Server stopped')", "target": 0}, {"function": "def ispath(x):\n    return isinstance(x, str) and x.find(os.sep) >= 0", "target": 0}, {"function": "def _get_revised_path(given_path, argv0):\n    \"\"\"Ensures current directory is on returned path, and argv0 directory is not\n\n    Exception: argv0 dir is left alone if it's also pydoc's directory.\n\n    Returns a new path entry list, or None if no adjustment is needed.\n    \"\"\"\n    # Scripts may get the current directory in their path by default if they're\n    # run with the -m switch, or directly from the current directory.\n    # The interactive prompt also allows imports from the current directory.\n\n    # Accordingly, if the current directory is already present, don't make\n    # any changes to the given_path\n    if '' in given_path or os.curdir in given_path or os.getcwd() in given_path:\n        return None\n\n    # Otherwise, add the current directory to the given path, and remove the\n    # script directory (as long as the latter isn't also pydoc's directory.\n    stdlib_dir = os.path.dirname(__file__)\n    script_dir = os.path.dirname(argv0)\n    revised_path = given_path.copy()\n    if script_dir in given_path and not os.path.samefile(script_dir, stdlib_dir):\n        revised_path.remove(script_dir)\n    revised_path.insert(0, os.getcwd())\n    return revised_path", "target": 0}, {"function": "def _adjust_cli_sys_path():\n    \"\"\"Ensures current directory is on sys.path, and __main__ directory is not.\n\n    Exception: __main__ dir is left alone if it's also pydoc's directory.\n    \"\"\"\n    revised_path = _get_revised_path(sys.path, sys.argv[0])\n    if revised_path is not None:\n        sys.path[:] = revised_path", "target": 0}, {"function": "def cli():\n    \"\"\"Command-line interface (looks at sys.argv to decide what to do).\"\"\"\n    import getopt\n    class BadUsage(Exception): pass\n\n    _adjust_cli_sys_path()\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], 'bk:n:p:w')\n        writing = False\n        start_server = False\n        open_browser = False\n        port = 0\n        hostname = 'localhost'\n        for opt, val in opts:\n            if opt == '-b':\n                start_server = True\n                open_browser = True\n            if opt == '-k':\n                apropos(val)\n                return\n            if opt == '-p':\n                start_server = True\n                port = val\n            if opt == '-w':\n                writing = True\n            if opt == '-n':\n                start_server = True\n                hostname = val\n\n        if start_server:\n            browse(port, hostname=hostname, open_browser=open_browser)\n            return\n\n        if not args: raise BadUsage\n        for arg in args:\n            if ispath(arg) and not os.path.exists(arg):\n                print('file %r does not exist' % arg)\n                break\n            try:\n                if ispath(arg) and os.path.isfile(arg):\n                    arg = importfile(arg)\n                if writing:\n                    if ispath(arg) and os.path.isdir(arg):\n                        writedocs(arg)\n                    else:\n                        writedoc(arg)\n                else:\n                    help.help(arg)\n            except ErrorDuringImport as value:\n                print(value)\n\n    except (getopt.error, BadUsage):\n        cmd = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n        print(\"\"\"pydoc - the Python documentation tool\n\n{cmd} <name> ...\n    Show text documentation on something.  <name> may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If <name> contains a '{sep}', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\n{cmd} -k <keyword>\n    Search for a keyword in the synopsis lines of all available modules.\n\n{cmd} -n <hostname>\n    Start an HTTP server with the given hostname (default: localhost).\n\n{cmd} -p <port>\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\n{cmd} -b\n    Start an HTTP server on an arbitrary unused port and open a Web browser\n    to interactively browse documentation.  This option can be used in\n    combination with -n and/or -p.\n\n{cmd} -w <name> ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If <name> contains a '{sep}', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\"\"\".format(cmd=cmd, sep=os.sep))", "target": 0}]}, {"raw_url": "https://github.com/python/cpython/raw/9b999479c0022edfc9835a8a1f06e046f3881048/Lib%2Ftest%2Ftest_pydoc.py", "code": "import os\nimport sys\nimport contextlib\nimport importlib.util\nimport inspect\nimport pydoc\nimport py_compile\nimport keyword\nimport _pickle\nimport pkgutil\nimport re\nimport stat\nimport string\nimport tempfile\nimport test.support\nimport time\nimport types\nimport typing\nimport unittest\nimport urllib.parse\nimport xml.etree\nimport xml.etree.ElementTree\nimport textwrap\nfrom io import StringIO\nfrom collections import namedtuple\nfrom test.support import os_helper\nfrom test.support.script_helper import assert_python_ok\nfrom test.support import threading_helper\nfrom test.support import (reap_children, captured_output, captured_stdout,\n                          captured_stderr, requires_docstrings)\nfrom test.support.os_helper import (TESTFN, rmtree, unlink)\nfrom test import pydoc_mod\n\n\nclass nonascii:\n    '\u0426\u0435 \u043d\u0435 \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044f'\n    pass\n\nif test.support.HAVE_DOCSTRINGS:\n    expected_data_docstrings = (\n        'dictionary for instance variables (if defined)',\n        'list of weak references to the object (if defined)',\n        ) * 2\nelse:\n    expected_data_docstrings = ('', '', '', '')\n\nexpected_text_pattern = \"\"\"\nNAME\n    test.pydoc_mod - This is a test module for test_pydoc\n%s\nCLASSES\n    builtins.object\n        A\n        B\n        C\n\\x20\\x20\\x20\\x20\n    class A(builtins.object)\n     |  Hello and goodbye\n     |\\x20\\x20\n     |  Methods defined here:\n     |\\x20\\x20\n     |  __init__()\n     |      Wow, I have no function!\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__%s\n     |\\x20\\x20\n     |  __weakref__%s\n\\x20\\x20\\x20\\x20\n    class B(builtins.object)\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__%s\n     |\\x20\\x20\n     |  __weakref__%s\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |\\x20\\x20\n     |  NO_MEANING = 'eggs'\n     |\\x20\\x20\n     |  __annotations__ = {'NO_MEANING': 'str'}\n\\x20\\x20\\x20\\x20\n    class C(builtins.object)\n     |  Methods defined here:\n     |\\x20\\x20\n     |  get_answer(self)\n     |      Return say_no()\n     |\\x20\\x20\n     |  is_it_true(self)\n     |      Return self.get_answer()\n     |\\x20\\x20\n     |  say_no(self)\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |\\x20\\x20\n     |  __weakref__\n     |      list of weak references to the object (if defined)\n\nFUNCTIONS\n    doc_func()\n        This function solves all of the world's problems:\n        hunger\n        lack of Python\n        war\n\\x20\\x20\\x20\\x20\n    nodoc_func()\n\nDATA\n    __xyz__ = 'X, Y and Z'\n\nVERSION\n    1.2.3.4\n\nAUTHOR\n    Benjamin Peterson\n\nCREDITS\n    Nobody\n\nFILE\n    %s\n\"\"\".strip()\n\nexpected_text_data_docstrings = tuple('\\n     |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n\nexpected_html_pattern = \"\"\"\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"#7799ee\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\">&nbsp;<br><big><big><strong><a href=\"test.html\"><font color=\"#ffffff\">test</font></a>.pydoc_mod</strong></big></big> (version 1.2.3.4)</font></td\n><td align=right valign=bottom\n><font color=\"#ffffff\" face=\"helvetica, arial\"><a href=\".\">index</a><br><a href=\"file:%s\">%s</a>%s</font></td></tr></table>\n    <p><tt>This&nbsp;is&nbsp;a&nbsp;test&nbsp;module&nbsp;for&nbsp;test_pydoc</tt></p>\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ee77aa\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Classes</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ee77aa\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl>\n<dt><font face=\"helvetica, arial\"><a href=\"builtins.html#object\">builtins.object</a>\n</font></dt><dd>\n<dl>\n<dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#A\">A</a>\n</font></dt><dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#B\">B</a>\n</font></dt><dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#C\">C</a>\n</font></dt></dl>\n</dd>\n</dl>\n <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"A\">class <strong>A</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr bgcolor=\"#ffc8d8\"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>\n<td colspan=2><tt>Hello&nbsp;and&nbsp;goodbye<br>&nbsp;</tt></td></tr>\n<tr><td>&nbsp;</td>\n<td width=\"100%%\">Methods defined here:<br>\n<dl><dt><a name=\"A-__init__\"><strong>__init__</strong></a>()</dt><dd><tt>Wow,&nbsp;I&nbsp;have&nbsp;no&nbsp;function!</tt></dd></dl>\n\n<hr>\nData descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n</td></tr></table> <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Data descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<hr>\nData and other attributes defined here:<br>\n<dl><dt><strong>NO_MEANING</strong> = 'eggs'</dl>\n\n<dl><dt><strong>__annotations__</strong> = {'NO_MEANING': 'str'}</dl>\n\n</td></tr></table> <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"C\">class <strong>C</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Methods defined here:<br>\n<dl><dt><a name=\"C-get_answer\"><strong>get_answer</strong></a>(self)</dt><dd><tt>Return&nbsp;<a href=\"#C-say_no\">say_no</a>()</tt></dd></dl>\n\n<dl><dt><a name=\"C-is_it_true\"><strong>is_it_true</strong></a>(self)</dt><dd><tt>Return&nbsp;self.<a href=\"#C-get_answer\">get_answer</a>()</tt></dd></dl>\n\n<dl><dt><a name=\"C-say_no\"><strong>say_no</strong></a>(self)</dt></dl>\n\n<hr>\nData descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table></td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#eeaa77\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Functions</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#eeaa77\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt><a name=\"-doc_func\"><strong>doc_func</strong></a>()</dt><dd><tt>This&nbsp;function&nbsp;solves&nbsp;all&nbsp;of&nbsp;the&nbsp;world's&nbsp;problems:<br>\nhunger<br>\nlack&nbsp;of&nbsp;Python<br>\nwar</tt></dd></dl>\n <dl><dt><a name=\"-nodoc_func\"><strong>nodoc_func</strong></a>()</dt></dl>\n</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#55aa55\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Data</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#55aa55\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><strong>__xyz__</strong> = 'X, Y and Z'</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#7799ee\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Author</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#7799ee\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Benjamin&nbsp;Peterson</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#7799ee\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Credits</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#7799ee\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Nobody</td></tr></table>\n\"\"\".strip() # ' <- emacs turd\n\nexpected_html_data_docstrings = tuple(s.replace(' ', '&nbsp;')\n                                      for s in expected_data_docstrings)\n\n# output pattern for missing module\nmissing_pattern = '''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.'''.replace('\\n', os.linesep)\n\n# output pattern for module with bad imports\nbadimport_pattern = \"problem in %s - ModuleNotFoundError: No module named %r\"\n\nexpected_dynamicattribute_pattern = \"\"\"\nHelp on class DA in module %s:\n\nclass DA(builtins.object)\n |  Data descriptors defined here:\n |\\x20\\x20\n |  __dict__%s\n |\\x20\\x20\n |  __weakref__%s\n |\\x20\\x20\n |  ham\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta:\n |\\x20\\x20\n |  ham = 'spam'\n\"\"\".strip()\n\nexpected_virtualattribute_pattern1 = \"\"\"\nHelp on class Class in module %s:\n\nclass Class(builtins.object)\n |  Data and other attributes inherited from Meta:\n |\\x20\\x20\n |  LIFE = 42\n\"\"\".strip()\n\nexpected_virtualattribute_pattern2 = \"\"\"\nHelp on class Class1 in module %s:\n\nclass Class1(builtins.object)\n |  Data and other attributes inherited from Meta1:\n |\\x20\\x20\n |  one = 1\n\"\"\".strip()\n\nexpected_virtualattribute_pattern3 = \"\"\"\nHelp on class Class2 in module %s:\n\nclass Class2(Class1)\n |  Method resolution order:\n |      Class2\n |      Class1\n |      builtins.object\n |\\x20\\x20\n |  Data and other attributes inherited from Meta1:\n |\\x20\\x20\n |  one = 1\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta3:\n |\\x20\\x20\n |  three = 3\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta2:\n |\\x20\\x20\n |  two = 2\n\"\"\".strip()\n\nexpected_missingattribute_pattern = \"\"\"\nHelp on class C in module %s:\n\nclass C(builtins.object)\n |  Data and other attributes defined here:\n |\\x20\\x20\n |  here = 'present!'\n\"\"\".strip()\n\ndef run_pydoc(module_name, *args, **env):\n    \"\"\"\n    Runs pydoc on the specified module. Returns the stripped\n    output of pydoc.\n    \"\"\"\n    args = args + (module_name,)\n    # do not write bytecode files to avoid caching errors\n    rc, out, err = assert_python_ok('-B', pydoc.__file__, *args, **env)\n    return out.strip()\n\ndef get_pydoc_html(module):\n    \"Returns pydoc generated output as html\"\n    doc = pydoc.HTMLDoc()\n    output = doc.docmodule(module)\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"<br><a href=\\\"\" + loc + \"\\\">Module Docs</a>\"\n    return output.strip(), loc\n\ndef get_pydoc_link(module):\n    \"Returns a documentation web link of a module\"\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    basedir = dirname(dirname(abspath(__file__)))\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(module, basedir=basedir)\n    return loc\n\ndef get_pydoc_text(module):\n    \"Returns pydoc generated output as text\"\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"\\nMODULE DOCS\\n    \" + loc + \"\\n\"\n\n    output = doc.docmodule(module)\n\n    # clean up the extra text formatting that pydoc performs\n    patt = re.compile('\\b.')\n    output = patt.sub('', output)\n    return output.strip(), loc\n\ndef get_html_title(text):\n    # Bit of hack, but good enough for test purposes\n    header, _, _ = text.partition(\"</head>\")\n    _, _, title = header.partition(\"<title>\")\n    title, _, _ = title.partition(\"</title>\")\n    return title\n\n\nclass PydocBaseTest(unittest.TestCase):\n\n    def _restricted_walk_packages(self, walk_packages, path=None):\n        \"\"\"\n        A version of pkgutil.walk_packages() that will restrict itself to\n        a given path.\n        \"\"\"\n        default_path = path or [os.path.dirname(__file__)]\n        def wrapper(path=None, prefix='', onerror=None):\n            return walk_packages(path or default_path, prefix, onerror)\n        return wrapper\n\n    @contextlib.contextmanager\n    def restrict_walk_packages(self, path=None):\n        walk_packages = pkgutil.walk_packages\n        pkgutil.walk_packages = self._restricted_walk_packages(walk_packages,\n                                                               path)\n        try:\n            yield\n        finally:\n            pkgutil.walk_packages = walk_packages\n\n    def call_url_handler(self, url, expected_title):\n        text = pydoc._url_handler(url, \"text/html\")\n        result = get_html_title(text)\n        # Check the title to ensure an unexpected error page was not returned\n        self.assertEqual(result, expected_title, text)\n        return text\n\n\nclass PydocDocTest(unittest.TestCase):\n    maxDiff = None\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_html_doc(self):\n        result, doc_loc = get_pydoc_html(pydoc_mod)\n        mod_file = inspect.getabsfile(pydoc_mod)\n        mod_url = urllib.parse.quote(mod_file)\n        expected_html = expected_html_pattern % (\n                        (mod_url, mod_file, doc_loc) +\n                        expected_html_data_docstrings)\n        self.assertEqual(result, expected_html)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_text_doc(self):\n        result, doc_loc = get_pydoc_text(pydoc_mod)\n        expected_text = expected_text_pattern % (\n                        (doc_loc,) +\n                        expected_text_data_docstrings +\n                        (inspect.getabsfile(pydoc_mod),))\n        self.assertEqual(expected_text, result)\n\n    def test_text_enum_member_with_value_zero(self):\n        # Test issue #20654 to ensure enum member with value 0 can be\n        # displayed. It used to throw KeyError: 'zero'.\n        import enum\n        class BinaryInteger(enum.IntEnum):\n            zero = 0\n            one = 1\n        doc = pydoc.render_doc(BinaryInteger)\n        self.assertIn('<BinaryInteger.zero: 0>', doc)\n\n    def test_mixed_case_module_names_are_lower_cased(self):\n        # issue16484\n        doc_link = get_pydoc_link(xml.etree.ElementTree)\n        self.assertIn('xml.etree.elementtree', doc_link)\n\n    def test_issue8225(self):\n        # Test issue8225 to ensure no doc link appears for xml.etree\n        result, doc_loc = get_pydoc_text(xml.etree)\n        self.assertEqual(doc_loc, \"\", \"MODULE DOCS incorrectly includes a link\")\n\n    def test_getpager_with_stdin_none(self):\n        previous_stdin = sys.stdin\n        try:\n            sys.stdin = None\n            pydoc.getpager() # Shouldn't fail.\n        finally:\n            sys.stdin = previous_stdin\n\n    def test_non_str_name(self):\n        # issue14638\n        # Treat illegal (non-str) name like no name\n\n        class A:\n            __name__ = 42\n        class B:\n            pass\n        adoc = pydoc.render_doc(A())\n        bdoc = pydoc.render_doc(B())\n        self.assertEqual(adoc.replace(\"A\", \"B\"), bdoc)\n\n    def test_not_here(self):\n        missing_module = \"test.i_am_not_here\"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module\n        self.assertEqual(expected, result,\n            \"documentation for missing module found\")\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_not_ascii(self):\n        result = run_pydoc('test.test_pydoc.nonascii', PYTHONIOENCODING='ascii')\n        encoded = nonascii.__doc__.encode('ascii', 'backslashreplace')\n        self.assertIn(encoded, result)\n\n    def test_input_strip(self):\n        missing_module = \" test.i_am_not_here \"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module.strip()\n        self.assertEqual(expected, result)\n\n    def test_stripid(self):\n        # test with strings, other implementations might have different repr()\n        stripid = pydoc.stripid\n        # strip the id\n        self.assertEqual(stripid('<function stripid at 0x88dcee4>'),\n                         '<function stripid>')\n        self.assertEqual(stripid('<function stripid at 0x01F65390>'),\n                         '<function stripid>')\n        # nothing to strip, return the same text\n        self.assertEqual(stripid('42'), '42')\n        self.assertEqual(stripid(\"<type 'exceptions.Exception'>\"),\n                         \"<type 'exceptions.Exception'>\")\n\n    def test_builtin_with_more_than_four_children(self):\n        \"\"\"Tests help on builtin object which have more than four child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section and only 4 classes\n        should be displayed with a hint on how many more subclasses are present.\n        For example:\n\n        >>> help(object)\n        Help on class object in module builtins:\n\n        class object\n         |  The most base type\n         |\n         |  Built-in subclasses:\n         |      async_generator\n         |      BaseException\n         |      builtin_function_or_method\n         |      bytearray\n         |      ... and 82 other subclasses\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(object)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      async_generator\\n\"\n                \" |      BaseException\\n\"\n                \" |      builtin_function_or_method\\n\"\n                \" |      bytearray\\n\"\n                \" |      ... and \\\\d+ other subclasses\")\n        self.assertRegex(text, snip)\n\n    def test_builtin_with_child(self):\n        \"\"\"Tests help on builtin object which have only child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. For example:\n\n        >>> help(ArithmeticError)\n        Help on class ArithmeticError in module builtins:\n\n        class ArithmeticError(Exception)\n         |  Base class for arithmetic errors.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      FloatingPointError\n         |      OverflowError\n         |      ZeroDivisionError\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ArithmeticError)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      FloatingPointError\\n\"\n                \" |      OverflowError\\n\"\n                \" |      ZeroDivisionError\")\n        self.assertIn(snip, text)\n\n    def test_builtin_with_grandchild(self):\n        \"\"\"Tests help on builtin classes which have grandchild classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. However, if it also has\n        grandchildren, these should not show up on the subclasses section.\n        For example:\n\n        >>> help(Exception)\n        Help on class Exception in module builtins:\n\n        class Exception(BaseException)\n         |  Common base class for all non-exit exceptions.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      ArithmeticError\n         |      AssertionError\n         |      AttributeError\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(Exception)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      ArithmeticError\\n\"\n                \" |      AssertionError\\n\"\n                \" |      AttributeError\")\n        self.assertIn(snip, text)\n        # Testing that the grandchild ZeroDivisionError does not show up\n        self.assertNotIn('ZeroDivisionError', text)\n\n    def test_builtin_no_child(self):\n        \"\"\"Tests help on builtin object which have no child classes.\n\n        When running help() on a builtin class which has no child classes, it\n        should not contain any \"Built-in subclasses\" section. For example:\n\n        >>> help(ZeroDivisionError)\n\n        Help on class ZeroDivisionError in module builtins:\n\n        class ZeroDivisionError(ArithmeticError)\n         |  Second argument to a division or modulo operation was zero.\n         |\n         |  Method resolution order:\n         |      ZeroDivisionError\n         |      ArithmeticError\n         |      Exception\n         |      BaseException\n         |      object\n         |\n         |  Methods defined here:\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ZeroDivisionError)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    def test_builtin_on_metaclasses(self):\n        \"\"\"Tests help on metaclasses.\n\n        When running help() on a metaclasses such as type, it\n        should not contain any \"Built-in subclasses\" section.\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(type)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -O2 and above')\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_help_output_redirect(self):\n        # issue 940286, if output is set in Helper, then all output from\n        # Helper.help should be redirected\n        old_pattern = expected_text_pattern\n        getpager_old = pydoc.getpager\n        getpager_new = lambda: (lambda x: x)\n        self.maxDiff = None\n\n        buf = StringIO()\n        helper = pydoc.Helper(output=buf)\n        unused, doc_loc = get_pydoc_text(pydoc_mod)\n        module = \"test.pydoc_mod\"\n        help_header = \"\"\"\n        Help on module test.pydoc_mod in test:\n\n        \"\"\".lstrip()\n        help_header = textwrap.dedent(help_header)\n        expected_help_pattern = help_header + expected_text_pattern\n\n        pydoc.getpager = getpager_new\n        try:\n            with captured_output('stdout') as output, \\\n                 captured_output('stderr') as err:\n                helper.help(module)\n                result = buf.getvalue().strip()\n                expected_text = expected_help_pattern % (\n                                (doc_loc,) +\n                                expected_text_data_docstrings +\n                                (inspect.getabsfile(pydoc_mod),))\n                self.assertEqual('', output.getvalue())\n                self.assertEqual('', err.getvalue())\n                self.assertEqual(expected_text, result)\n        finally:\n            pydoc.getpager = getpager_old\n\n    def test_namedtuple_fields(self):\n        Person = namedtuple('Person', ['nickname', 'firstname'])\n        with captured_stdout() as help_io:\n            pydoc.help(Person)\n        helptext = help_io.getvalue()\n        self.assertIn(\"nickname\", helptext)\n        self.assertIn(\"firstname\", helptext)\n        self.assertIn(\"Alias for field number 0\", helptext)\n        self.assertIn(\"Alias for field number 1\", helptext)\n\n    def test_namedtuple_public_underscore(self):\n        NT = namedtuple('NT', ['abc', 'def'], rename=True)\n        with captured_stdout() as help_io:\n            pydoc.help(NT)\n        helptext = help_io.getvalue()\n        self.assertIn('_1', helptext)\n        self.assertIn('_replace', helptext)\n        self.assertIn('_asdict', helptext)\n\n    def test_synopsis(self):\n        self.addCleanup(unlink, TESTFN)\n        for encoding in ('ISO-8859-1', 'UTF-8'):\n            with open(TESTFN, 'w', encoding=encoding) as script:\n                if encoding != 'UTF-8':\n                    print('#coding: {}'.format(encoding), file=script)\n                print('\"\"\"line 1: h\\xe9', file=script)\n                print('line 2: hi\"\"\"', file=script)\n            synopsis = pydoc.synopsis(TESTFN, {})\n            self.assertEqual(synopsis, 'line 1: h\\xe9')\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_synopsis_sourceless(self):\n        expected = os.__doc__.splitlines()[0]\n        filename = os.__cached__\n        synopsis = pydoc.synopsis(filename)\n\n        self.assertEqual(synopsis, expected)\n\n    def test_synopsis_sourceless_empty_doc(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, 'foomod42.py')\n            cached_path = importlib.util.cache_from_source(init_path)\n            with open(init_path, 'w') as fobj:\n                fobj.write(\"foo = 1\")\n            py_compile.compile(init_path)\n            synopsis = pydoc.synopsis(init_path, {})\n            self.assertIsNone(synopsis)\n            synopsis_cached = pydoc.synopsis(cached_path, {})\n            self.assertIsNone(synopsis_cached)\n\n    def test_splitdoc_with_description(self):\n        example_string = \"I Am A Doc\\n\\n\\nHere is my description\"\n        self.assertEqual(pydoc.splitdoc(example_string),\n                         ('I Am A Doc', '\\nHere is my description'))\n\n    def test_is_package_when_not_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            self.assertFalse(pydoc.ispackage(test_dir))\n\n    def test_is_package_when_is_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, '__init__.py')\n            open(init_path, 'w').close()\n            self.assertTrue(pydoc.ispackage(test_dir))\n            os.remove(init_path)\n\n    def test_allmethods(self):\n        # issue 17476: allmethods was no longer returning unbound methods.\n        # This test is a bit fragile in the face of changes to object and type,\n        # but I can't think of a better way to do it without duplicating the\n        # logic of the function under test.\n\n        class TestClass(object):\n            def method_returning_true(self):\n                return True\n\n        # What we expect to get back: everything on object...\n        expected = dict(vars(object))\n        # ...plus our unbound method...\n        expected['method_returning_true'] = TestClass.method_returning_true\n        # ...but not the non-methods on object.\n        del expected['__doc__']\n        del expected['__class__']\n        # inspect resolves descriptors on type into methods, but vars doesn't,\n        # so we need to update __subclasshook__ and __init_subclass__.\n        expected['__subclasshook__'] = TestClass.__subclasshook__\n        expected['__init_subclass__'] = TestClass.__init_subclass__\n\n        methods = pydoc.allmethods(TestClass)\n        self.assertDictEqual(methods, expected)\n\n    def test_method_aliases(self):\n        class A:\n            def tkraise(self, aboveThis=None):\n                \"\"\"Raise this widget in the stacking order.\"\"\"\n            lift = tkraise\n            def a_size(self):\n                \"\"\"Return size\"\"\"\n        class B(A):\n            def itemconfigure(self, tagOrId, cnf=None, **kw):\n                \"\"\"Configure resources of an item TAGORID.\"\"\"\n            itemconfig = itemconfigure\n            b_size = A.a_size\n\n        doc = pydoc.render_doc(B)\n        # clean up the extra text formatting that pydoc performs\n        doc = re.sub('\\b.', '', doc)\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\nclass B(A)\n |  Method resolution order:\n |      B\n |      A\n |      builtins.object\n |\\x20\\x20\n |  Methods defined here:\n |\\x20\\x20\n |  b_size = a_size(self)\n |\\x20\\x20\n |  itemconfig = itemconfigure(self, tagOrId, cnf=None, **kw)\n |\\x20\\x20\n |  itemconfigure(self, tagOrId, cnf=None, **kw)\n |      Configure resources of an item TAGORID.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Methods inherited from A:\n |\\x20\\x20\n |  a_size(self)\n |      Return size\n |\\x20\\x20\n |  lift = tkraise(self, aboveThis=None)\n |\\x20\\x20\n |  tkraise(self, aboveThis=None)\n |      Raise this widget in the stacking order.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from A:\n |\\x20\\x20\n |  __dict__\n |      dictionary for instance variables (if defined)\n |\\x20\\x20\n |  __weakref__\n |      list of weak references to the object (if defined)\n''' % __name__)\n\n        doc = pydoc.render_doc(B, renderer=pydoc.HTMLDoc())\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(A)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt>Method resolution order:</dt>\n<dd>B</dd>\n<dd>A</dd>\n<dd><a href=\"builtins.html#object\">builtins.object</a></dd>\n</dl>\n<hr>\nMethods defined here:<br>\n<dl><dt><a name=\"B-b_size\"><strong>b_size</strong></a> = <a href=\"#B-a_size\">a_size</a>(self)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfig\"><strong>itemconfig</strong></a> = <a href=\"#B-itemconfigure\">itemconfigure</a>(self, tagOrId, cnf=None, **kw)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfigure\"><strong>itemconfigure</strong></a>(self, tagOrId, cnf=None, **kw)</dt><dd><tt>Configure&nbsp;resources&nbsp;of&nbsp;an&nbsp;item&nbsp;TAGORID.</tt></dd></dl>\n\n<hr>\nMethods inherited from A:<br>\n<dl><dt><a name=\"B-a_size\"><strong>a_size</strong></a>(self)</dt><dd><tt>Return&nbsp;size</tt></dd></dl>\n\n<dl><dt><a name=\"B-lift\"><strong>lift</strong></a> = <a href=\"#B-tkraise\">tkraise</a>(self, aboveThis=None)</dt></dl>\n\n<dl><dt><a name=\"B-tkraise\"><strong>tkraise</strong></a>(self, aboveThis=None)</dt><dd><tt>Raise&nbsp;this&nbsp;widget&nbsp;in&nbsp;the&nbsp;stacking&nbsp;order.</tt></dd></dl>\n\n<hr>\nData descriptors inherited from A:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table>\\\n''' % __name__)\n\n\nclass PydocImportTest(PydocBaseTest):\n\n    def setUp(self):\n        self.test_dir = os.mkdir(TESTFN)\n        self.addCleanup(rmtree, TESTFN)\n        importlib.invalidate_caches()\n\n    def test_badimport(self):\n        # This tests the fix for issue 5230, where if pydoc found the module\n        # but the module had an internal import error pydoc would report no doc\n        # found.\n        modname = 'testmod_xyzzy'\n        testpairs = (\n            ('i_am_not_here', 'i_am_not_here'),\n            ('test.i_am_not_here_either', 'test.i_am_not_here_either'),\n            ('test.i_am_not_here.neither_am_i', 'test.i_am_not_here'),\n            ('i_am_not_here.{}'.format(modname), 'i_am_not_here'),\n            ('test.{}'.format(modname), 'test.{}'.format(modname)),\n            )\n\n        sourcefn = os.path.join(TESTFN, modname) + os.extsep + \"py\"\n        for importstring, expectedinmsg in testpairs:\n            with open(sourcefn, 'w') as f:\n                f.write(\"import {}\\n\".format(importstring))\n            result = run_pydoc(modname, PYTHONPATH=TESTFN).decode(\"ascii\")\n            expected = badimport_pattern % (modname, expectedinmsg)\n            self.assertEqual(expected, result)\n\n    def test_apropos_with_bad_package(self):\n        # Issue 7425 - pydoc -k failed when bad package on path\n        pkgdir = os.path.join(TESTFN, \"syntaxerr\")\n        os.mkdir(pkgdir)\n        badsyntax = os.path.join(pkgdir, \"__init__\") + os.extsep + \"py\"\n        with open(badsyntax, 'w') as f:\n            f.write(\"invalid python syntax = $1\\n\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('xyzzy')\n            # No result, no error\n            self.assertEqual(out.getvalue(), '')\n            self.assertEqual(err.getvalue(), '')\n            # The package name is still matched\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('syntaxerr')\n            self.assertEqual(out.getvalue().strip(), 'syntaxerr')\n            self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_with_unreadable_dir(self):\n        # Issue 7367 - pydoc -k failed when unreadable dir on path\n        self.unreadable_dir = os.path.join(TESTFN, \"unreadable\")\n        os.mkdir(self.unreadable_dir, 0)\n        self.addCleanup(os.rmdir, self.unreadable_dir)\n        # Note, on Windows the directory appears to be still\n        #   readable so this is not really testing the issue there\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('SOMEKEY')\n        # No result, no error\n        self.assertEqual(out.getvalue(), '')\n        self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_empty_doc(self):\n        pkgdir = os.path.join(TESTFN, 'walkpkg')\n        os.mkdir(pkgdir)\n        self.addCleanup(rmtree, pkgdir)\n        init_path = os.path.join(pkgdir, '__init__.py')\n        with open(init_path, 'w') as fobj:\n            fobj.write(\"foo = 1\")\n        current_mode = stat.S_IMODE(os.stat(pkgdir).st_mode)\n        try:\n            os.chmod(pkgdir, current_mode & ~stat.S_IEXEC)\n            with self.restrict_walk_packages(path=[TESTFN]), captured_stdout() as stdout:\n                pydoc.apropos('')\n            self.assertIn('walkpkg', stdout.getvalue())\n        finally:\n            os.chmod(pkgdir, current_mode)\n\n    def test_url_search_package_error(self):\n        # URL handler search should cope with packages that raise exceptions\n        pkgdir = os.path.join(TESTFN, \"test_error_package\")\n        os.mkdir(pkgdir)\n        init = os.path.join(pkgdir, \"__init__.py\")\n        with open(init, \"wt\", encoding=\"ascii\") as f:\n            f.write(\"\"\"raise ValueError(\"ouch\")\\n\"\"\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            # Package has to be importable for the error to have any effect\n            saved_paths = tuple(sys.path)\n            sys.path.insert(0, TESTFN)\n            try:\n                with self.assertRaisesRegex(ValueError, \"ouch\"):\n                    import test_error_package  # Sanity check\n\n                text = self.call_url_handler(\"search?key=test_error_package\",\n                    \"Pydoc: Search Results\")\n                found = ('<a href=\"test_error_package.html\">'\n                    'test_error_package</a>')\n                self.assertIn(found, text)\n            finally:\n                sys.path[:] = saved_paths\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules(self):\n        # See Helper.listmodules().\n        num_header_lines = 2\n        num_module_lines_min = 5  # Playing it safe.\n        num_footer_lines = 3\n        expected = num_header_lines + num_module_lines_min + num_footer_lines\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper('modules')\n        result = output.getvalue().strip()\n        num_lines = len(result.splitlines())\n\n        self.assertGreaterEqual(num_lines, expected)\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules_search(self):\n        # See Helper.listmodules().\n        expected = 'pydoc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules pydoc')\n        result = help_io.getvalue()\n\n        self.assertIn(expected, result)\n\n    @unittest.skip('some buildbots are not cooperating (#20128)')\n    def test_modules_search_builtin(self):\n        expected = 'gc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules garbage')\n        result = help_io.getvalue()\n\n        self.assertTrue(result.startswith(expected))\n\n    def test_importfile(self):\n        loaded_pydoc = pydoc.importfile(pydoc.__file__)\n\n        self.assertIsNot(loaded_pydoc, pydoc)\n        self.assertEqual(loaded_pydoc.__name__, 'pydoc')\n        self.assertEqual(loaded_pydoc.__file__, pydoc.__file__)\n        self.assertEqual(loaded_pydoc.__spec__, pydoc.__spec__)\n\n\nclass TestDescriptions(unittest.TestCase):\n\n    def test_module(self):\n        # Check that pydocfodder module can be described\n        from test import pydocfodder\n        doc = pydoc.render_doc(pydocfodder)\n        self.assertIn(\"pydocfodder\", doc)\n\n    def test_class(self):\n        class C: \"New-style class\"\n        c = C()\n\n        self.assertEqual(pydoc.describe(C), 'class C')\n        self.assertEqual(pydoc.describe(c), 'C')\n        expected = 'C in module %s object' % __name__\n        self.assertIn(expected, pydoc.render_doc(c))\n\n    def test_typing_pydoc(self):\n        def foo(data: typing.List[typing.Any],\n                x: int) -> typing.Iterator[typing.Tuple[int, typing.Any]]:\n            ...\n        T = typing.TypeVar('T')\n        class C(typing.Generic[T], typing.Mapping[int, str]): ...\n        self.assertEqual(pydoc.render_doc(foo).splitlines()[-1],\n                         'f\\x08fo\\x08oo\\x08o(data: List[Any], x: int)'\n                         ' -> Iterator[Tuple[int, Any]]')\n        self.assertEqual(pydoc.render_doc(C).splitlines()[2],\n                         'class C\\x08C(collections.abc.Mapping, typing.Generic)')\n\n    def test_builtin(self):\n        for name in ('str', 'str.translate', 'builtins.str',\n                     'builtins.str.translate'):\n            # test low-level function\n            self.assertIsNotNone(pydoc.locate(name))\n            # test high-level function\n            try:\n                pydoc.render_doc(name)\n            except ImportError:\n                self.fail('finding the doc of {!r} failed'.format(name))\n\n        for name in ('notbuiltins', 'strrr', 'strr.translate',\n                     'str.trrrranslate', 'builtins.strrr',\n                     'builtins.str.trrranslate'):\n            self.assertIsNone(pydoc.locate(name))\n            self.assertRaises(ImportError, pydoc.render_doc, name)\n\n    @staticmethod\n    def _get_summary_line(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        assert len(lines) >= 2\n        return lines[2]\n\n    @staticmethod\n    def _get_summary_lines(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        return '\\n'.join(lines[2:])\n\n    # these should include \"self\"\n    def test_unbound_python_method(self):\n        self.assertEqual(self._get_summary_line(textwrap.TextWrapper.wrap),\n            \"wrap(self, text)\")\n\n    @requires_docstrings\n    def test_unbound_builtin_method(self):\n        self.assertEqual(self._get_summary_line(_pickle.Pickler.dump),\n            \"dump(self, obj, /)\")\n\n    # these no longer include \"self\"\n    def test_bound_python_method(self):\n        t = textwrap.TextWrapper()\n        self.assertEqual(self._get_summary_line(t.wrap),\n            \"wrap(text) method of textwrap.TextWrapper instance\")\n    def test_field_order_for_named_tuples(self):\n        Person = namedtuple('Person', ['nickname', 'firstname', 'agegroup'])\n        s = pydoc.render_doc(Person)\n        self.assertLess(s.index('nickname'), s.index('firstname'))\n        self.assertLess(s.index('firstname'), s.index('agegroup'))\n\n        class NonIterableFields:\n            _fields = None\n\n        class NonHashableFields:\n            _fields = [[]]\n\n        # Make sure these doesn't fail\n        pydoc.render_doc(NonIterableFields)\n        pydoc.render_doc(NonHashableFields)\n\n    @requires_docstrings\n    def test_bound_builtin_method(self):\n        s = StringIO()\n        p = _pickle.Pickler(s)\n        self.assertEqual(self._get_summary_line(p.dump),\n            \"dump(obj, /) method of _pickle.Pickler instance\")\n\n    # this should *never* include self!\n    @requires_docstrings\n    def test_module_level_callable(self):\n        self.assertEqual(self._get_summary_line(os.stat),\n            \"stat(path, *, dir_fd=None, follow_symlinks=True)\")\n\n    @requires_docstrings\n    def test_staticmethod(self):\n        class X:\n            @staticmethod\n            def sm(x, y):\n                '''A static method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['sm']),\n                         \"<staticmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.sm), \"\"\"\\\nsm(x, y)\n    A static method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Static methods defined here:\n |\\x20\\x20\n |  sm(x, y)\n |      A static method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_classmethod(self):\n        class X:\n            @classmethod\n            def cm(cls, x):\n                '''A class method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['cm']),\n                         \"<classmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.cm), \"\"\"\\\ncm(x) method of builtins.type instance\n    A class method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Class methods defined here:\n |\\x20\\x20\n |  cm(x) from builtins.type\n |      A class method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_getset_descriptor(self):\n        # Currently these attributes are implemented as getset descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(int.numerator), \"numerator\")\n        self.assertEqual(self._get_summary_line(float.real), \"real\")\n        self.assertEqual(self._get_summary_line(Exception.args), \"args\")\n        self.assertEqual(self._get_summary_line(memoryview.obj), \"obj\")\n\n    @requires_docstrings\n    def test_member_descriptor(self):\n        # Currently these attributes are implemented as member descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(complex.real), \"real\")\n        self.assertEqual(self._get_summary_line(range.start), \"start\")\n        self.assertEqual(self._get_summary_line(slice.start), \"start\")\n        self.assertEqual(self._get_summary_line(property.fget), \"fget\")\n        self.assertEqual(self._get_summary_line(StopIteration.value), \"value\")\n\n    @requires_docstrings\n    def test_slot_descriptor(self):\n        class Point:\n            __slots__ = 'x', 'y'\n        self.assertEqual(self._get_summary_line(Point.x), \"x\")\n\n    @requires_docstrings\n    def test_dict_attr_descriptor(self):\n        class NS:\n            pass\n        self.assertEqual(self._get_summary_line(NS.__dict__['__dict__']),\n                         \"__dict__\")\n\n    @requires_docstrings\n    def test_structseq_member_descriptor(self):\n        self.assertEqual(self._get_summary_line(type(sys.hash_info).width),\n                         \"width\")\n        self.assertEqual(self._get_summary_line(type(sys.flags).debug),\n                         \"debug\")\n        self.assertEqual(self._get_summary_line(type(sys.version_info).major),\n                         \"major\")\n        self.assertEqual(self._get_summary_line(type(sys.float_info).max),\n                         \"max\")\n\n    @requires_docstrings\n    def test_namedtuple_field_descriptor(self):\n        Box = namedtuple('Box', ('width', 'height'))\n        self.assertEqual(self._get_summary_lines(Box.width), \"\"\"\\\n    Alias for field number 0\n\"\"\")\n\n    @requires_docstrings\n    def test_property(self):\n        class Rect:\n            @property\n            def area(self):\n                '''Area of the rect'''\n                return self.w * self.h\n\n        self.assertEqual(self._get_summary_lines(Rect.area), \"\"\"\\\n    Area of the rect\n\"\"\")\n        self.assertIn(\"\"\"\n |  area\n |      Area of the rect\n\"\"\", pydoc.plain(pydoc.render_doc(Rect)))\n\n    @requires_docstrings\n    def test_custom_non_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\"\"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo(...)\n    Custom descriptor\n\"\"\")\n\n    @requires_docstrings\n    def test_custom_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n            def __set__(self, obj, cls):\n                1/0\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo\n    Custom descriptor\n\"\"\")\n\n    def test_async_annotation(self):\n        async def coro_function(ign) -> int:\n            return 1\n\n        text = pydoc.plain(pydoc.plaintext.document(coro_function))\n        self.assertIn('async coro_function', text)\n\n        html = pydoc.HTMLDoc().document(coro_function)\n        self.assertIn(\n            'async <a name=\"-coro_function\"><strong>coro_function',\n            html)\n\n    def test_async_generator_annotation(self):\n        async def an_async_generator():\n            yield 1\n\n        text = pydoc.plain(pydoc.plaintext.document(an_async_generator))\n        self.assertIn('async an_async_generator', text)\n\n        html = pydoc.HTMLDoc().document(an_async_generator)\n        self.assertIn(\n            'async <a name=\"-an_async_generator\"><strong>an_async_generator',\n            html)\n\n    def test_html_for_https_links(self):\n        def a_fn_with_https_link():\n            \"\"\"a link https://localhost/\"\"\"\n            pass\n\n        html = pydoc.HTMLDoc().document(a_fn_with_https_link)\n        self.assertIn(\n            '<a href=\"https://localhost/\">https://localhost/</a>',\n            html\n        )\n\nclass PydocServerTest(unittest.TestCase):\n    \"\"\"Tests for pydoc._start_server\"\"\"\n\n    def test_server(self):\n\n        # Minimal test that starts the server, then stops it.\n        def my_url_handler(url, content_type):\n            text = 'the URL sent was: (%s, %s)' % (url, content_type)\n            return text\n\n        serverthread = pydoc._start_server(my_url_handler, hostname='0.0.0.0', port=0)\n        self.assertIn('0.0.0.0', serverthread.docserver.address)\n\n        starttime = time.monotonic()\n        timeout = test.support.SHORT_TIMEOUT\n\n        while serverthread.serving:\n            time.sleep(.01)\n            if serverthread.serving and time.monotonic() - starttime > timeout:\n                serverthread.stop()\n                break\n\n        self.assertEqual(serverthread.error, None)\n\n\nclass PydocUrlHandlerTest(PydocBaseTest):\n    \"\"\"Tests for pydoc._url_handler\"\"\"\n\n    def test_content_type_err(self):\n        f = pydoc._url_handler\n        self.assertRaises(TypeError, f, 'A', '')\n        self.assertRaises(TypeError, f, 'B', 'foobar')\n\n    def test_url_requests(self):\n        # Test for the correct title in the html pages returned.\n        # This tests the different parts of the URL handler without\n        # getting too picky about the exact html.\n        requests = [\n            (\"\", \"Pydoc: Index of Modules\"),\n            (\"get?key=\", \"Pydoc: Index of Modules\"),\n            (\"index\", \"Pydoc: Index of Modules\"),\n            (\"topics\", \"Pydoc: Topics\"),\n            (\"keywords\", \"Pydoc: Keywords\"),\n            (\"pydoc\", \"Pydoc: module pydoc\"),\n            (\"get?key=pydoc\", \"Pydoc: module pydoc\"),\n            (\"search?key=pydoc\", \"Pydoc: Search Results\"),\n            (\"topic?key=def\", \"Pydoc: KEYWORD def\"),\n            (\"topic?key=STRINGS\", \"Pydoc: TOPIC STRINGS\"),\n            (\"foobar\", \"Pydoc: Error - foobar\"),\n            ]\n\n        with self.restrict_walk_packages():\n            for url, title in requests:\n                self.call_url_handler(url, title)\n\n\nclass TestHelper(unittest.TestCase):\n    def test_keywords(self):\n        self.assertEqual(sorted(pydoc.Helper.keywords),\n                         sorted(keyword.kwlist))\n\nclass PydocWithMetaClasses(unittest.TestCase):\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_DynamicClassAttribute(self):\n        class Meta(type):\n            def __getattr__(self, name):\n                if name == 'ham':\n                    return 'spam'\n                return super().__getattr__(name)\n        class DA(metaclass=Meta):\n            @types.DynamicClassAttribute\n            def ham(self):\n                return 'eggs'\n        expected_text_data_docstrings = tuple('\\n |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(DA)\n        expected_text = expected_dynamicattribute_pattern % (\n                (__name__,) + expected_text_data_docstrings[:2])\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithOneMeta(self):\n        class Meta(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'LIFE']\n            def __getattr__(self, name):\n                if name =='LIFE':\n                    return 42\n                return super().__getattr(name)\n        class Class(metaclass=Meta):\n            pass\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class)\n        expected_text = expected_virtualattribute_pattern1 % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithTwoMeta(self):\n        class Meta1(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'one']\n            def __getattr__(self, name):\n                if name =='one':\n                    return 1\n                return super().__getattr__(name)\n        class Meta2(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'two']\n            def __getattr__(self, name):\n                if name =='two':\n                    return 2\n                return super().__getattr__(name)\n        class Meta3(Meta1, Meta2):\n            def __dir__(cls):\n                return list(sorted(set(\n                    ['__class__', '__module__', '__name__', 'three'] +\n                    Meta1.__dir__(cls) + Meta2.__dir__(cls))))\n            def __getattr__(self, name):\n                if name =='three':\n                    return 3\n                return super().__getattr__(name)\n        class Class1(metaclass=Meta1):\n            pass\n        class Class2(Class1, metaclass=Meta3):\n            pass\n        fail1 = fail2 = False\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class1)\n        expected_text1 = expected_virtualattribute_pattern2 % __name__\n        result1 = output.getvalue().strip()\n        self.assertEqual(expected_text1, result1)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class2)\n        expected_text2 = expected_virtualattribute_pattern3 % __name__\n        result2 = output.getvalue().strip()\n        self.assertEqual(expected_text2, result2)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_buggy_dir(self):\n        class M(type):\n            def __dir__(cls):\n                return ['__class__', '__name__', 'missing', 'here']\n        class C(metaclass=M):\n            here = 'present!'\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(C)\n        expected_text = expected_missingattribute_pattern % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    def test_resolve_false(self):\n        # Issue #23008: pydoc enum.{,Int}Enum failed\n        # because bool(enum.Enum) is False.\n        with captured_stdout() as help_io:\n            pydoc.help('enum.Enum')\n        helptext = help_io.getvalue()\n        self.assertIn('class Enum', helptext)\n\n\nclass TestInternalUtilities(unittest.TestCase):\n\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.argv0dir = tmpdir.name\n        self.argv0 = os.path.join(tmpdir.name, \"nonexistent\")\n        self.addCleanup(tmpdir.cleanup)\n        self.abs_curdir = abs_curdir = os.getcwd()\n        self.curdir_spellings = [\"\", os.curdir, abs_curdir]\n\n    def _get_revised_path(self, given_path, argv0=None):\n        # Checking that pydoc.cli() actually calls pydoc._get_revised_path()\n        # is handled via code review (at least for now).\n        if argv0 is None:\n            argv0 = self.argv0\n        return pydoc._get_revised_path(given_path, argv0)\n\n    def _get_starting_path(self):\n        # Get a copy of sys.path without the current directory.\n        clean_path = sys.path.copy()\n        for spelling in self.curdir_spellings:\n            for __ in range(clean_path.count(spelling)):\n                clean_path.remove(spelling)\n        return clean_path\n\n    def test_sys_path_adjustment_adds_missing_curdir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        self.assertEqual(self._get_revised_path(clean_path), expected_path)\n\n    def test_sys_path_adjustment_removes_argv0_dir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        leading_argv0dir = [self.argv0dir] + clean_path\n        self.assertEqual(self._get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        self.assertEqual(self._get_revised_path(trailing_argv0dir), expected_path)\n\n\n    def test_sys_path_adjustment_protects_pydoc_dir(self):\n        def _get_revised_path(given_path):\n            return self._get_revised_path(given_path, argv0=pydoc.__file__)\n        clean_path = self._get_starting_path()\n        leading_argv0dir = [self.argv0dir] + clean_path\n        expected_path = [self.abs_curdir] + leading_argv0dir\n        self.assertEqual(_get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        expected_path = [self.abs_curdir] + trailing_argv0dir\n        self.assertEqual(_get_revised_path(trailing_argv0dir), expected_path)\n\n    def test_sys_path_adjustment_when_curdir_already_included(self):\n        clean_path = self._get_starting_path()\n        for spelling in self.curdir_spellings:\n            with self.subTest(curdir_spelling=spelling):\n                # If curdir is already present, no alterations are made at all\n                leading_curdir = [spelling] + clean_path\n                self.assertIsNone(self._get_revised_path(leading_curdir))\n                trailing_curdir = clean_path + [spelling]\n                self.assertIsNone(self._get_revised_path(trailing_curdir))\n                leading_argv0dir = [self.argv0dir] + leading_curdir\n                self.assertIsNone(self._get_revised_path(leading_argv0dir))\n                trailing_argv0dir = trailing_curdir + [self.argv0dir]\n                self.assertIsNone(self._get_revised_path(trailing_argv0dir))\n\n\n@threading_helper.reap_threads\ndef test_main():\n    try:\n        test.support.run_unittest(PydocDocTest,\n                                  PydocImportTest,\n                                  TestDescriptions,\n                                  PydocServerTest,\n                                  PydocUrlHandlerTest,\n                                  TestHelper,\n                                  PydocWithMetaClasses,\n                                  TestInternalUtilities,\n                                  )\n    finally:\n        reap_children()\n\nif __name__ == \"__main__\":\n    test_main()\n", "code_before": "import os\nimport sys\nimport contextlib\nimport importlib.util\nimport inspect\nimport pydoc\nimport py_compile\nimport keyword\nimport _pickle\nimport pkgutil\nimport re\nimport stat\nimport string\nimport tempfile\nimport test.support\nimport time\nimport types\nimport typing\nimport unittest\nimport urllib.parse\nimport xml.etree\nimport xml.etree.ElementTree\nimport textwrap\nfrom io import StringIO\nfrom collections import namedtuple\nfrom test.support import os_helper\nfrom test.support.script_helper import assert_python_ok\nfrom test.support import threading_helper\nfrom test.support import (reap_children, captured_output, captured_stdout,\n                          captured_stderr, requires_docstrings)\nfrom test.support.os_helper import (TESTFN, rmtree, unlink)\nfrom test import pydoc_mod\n\n\nclass nonascii:\n    '\u0426\u0435 \u043d\u0435 \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044f'\n    pass\n\nif test.support.HAVE_DOCSTRINGS:\n    expected_data_docstrings = (\n        'dictionary for instance variables (if defined)',\n        'list of weak references to the object (if defined)',\n        ) * 2\nelse:\n    expected_data_docstrings = ('', '', '', '')\n\nexpected_text_pattern = \"\"\"\nNAME\n    test.pydoc_mod - This is a test module for test_pydoc\n%s\nCLASSES\n    builtins.object\n        A\n        B\n        C\n\\x20\\x20\\x20\\x20\n    class A(builtins.object)\n     |  Hello and goodbye\n     |\\x20\\x20\n     |  Methods defined here:\n     |\\x20\\x20\n     |  __init__()\n     |      Wow, I have no function!\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__%s\n     |\\x20\\x20\n     |  __weakref__%s\n\\x20\\x20\\x20\\x20\n    class B(builtins.object)\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__%s\n     |\\x20\\x20\n     |  __weakref__%s\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |\\x20\\x20\n     |  NO_MEANING = 'eggs'\n     |\\x20\\x20\n     |  __annotations__ = {'NO_MEANING': 'str'}\n\\x20\\x20\\x20\\x20\n    class C(builtins.object)\n     |  Methods defined here:\n     |\\x20\\x20\n     |  get_answer(self)\n     |      Return say_no()\n     |\\x20\\x20\n     |  is_it_true(self)\n     |      Return self.get_answer()\n     |\\x20\\x20\n     |  say_no(self)\n     |\\x20\\x20\n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |\\x20\\x20\n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |\\x20\\x20\n     |  __weakref__\n     |      list of weak references to the object (if defined)\n\nFUNCTIONS\n    doc_func()\n        This function solves all of the world's problems:\n        hunger\n        lack of Python\n        war\n\\x20\\x20\\x20\\x20\n    nodoc_func()\n\nDATA\n    __xyz__ = 'X, Y and Z'\n\nVERSION\n    1.2.3.4\n\nAUTHOR\n    Benjamin Peterson\n\nCREDITS\n    Nobody\n\nFILE\n    %s\n\"\"\".strip()\n\nexpected_text_data_docstrings = tuple('\\n     |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n\nexpected_html_pattern = \"\"\"\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"#7799ee\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\">&nbsp;<br><big><big><strong><a href=\"test.html\"><font color=\"#ffffff\">test</font></a>.pydoc_mod</strong></big></big> (version 1.2.3.4)</font></td\n><td align=right valign=bottom\n><font color=\"#ffffff\" face=\"helvetica, arial\"><a href=\".\">index</a><br><a href=\"file:%s\">%s</a>%s</font></td></tr></table>\n    <p><tt>This&nbsp;is&nbsp;a&nbsp;test&nbsp;module&nbsp;for&nbsp;test_pydoc</tt></p>\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ee77aa\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Classes</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ee77aa\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl>\n<dt><font face=\"helvetica, arial\"><a href=\"builtins.html#object\">builtins.object</a>\n</font></dt><dd>\n<dl>\n<dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#A\">A</a>\n</font></dt><dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#B\">B</a>\n</font></dt><dt><font face=\"helvetica, arial\"><a href=\"test.pydoc_mod.html#C\">C</a>\n</font></dt></dl>\n</dd>\n</dl>\n <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"A\">class <strong>A</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr bgcolor=\"#ffc8d8\"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>\n<td colspan=2><tt>Hello&nbsp;and&nbsp;goodbye<br>&nbsp;</tt></td></tr>\n<tr><td>&nbsp;</td>\n<td width=\"100%%\">Methods defined here:<br>\n<dl><dt><a name=\"A-__init__\"><strong>__init__</strong></a>()</dt><dd><tt>Wow,&nbsp;I&nbsp;have&nbsp;no&nbsp;function!</tt></dd></dl>\n\n<hr>\nData descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n</td></tr></table> <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Data descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>%s</tt></dd>\n</dl>\n<hr>\nData and other attributes defined here:<br>\n<dl><dt><strong>NO_MEANING</strong> = 'eggs'</dl>\n\n<dl><dt><strong>__annotations__</strong> = {'NO_MEANING': 'str'}</dl>\n\n</td></tr></table> <p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"C\">class <strong>C</strong></a>(<a href=\"builtins.html#object\">builtins.object</a>)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Methods defined here:<br>\n<dl><dt><a name=\"C-get_answer\"><strong>get_answer</strong></a>(self)</dt><dd><tt>Return&nbsp;<a href=\"#C-say_no\">say_no</a>()</tt></dd></dl>\n\n<dl><dt><a name=\"C-is_it_true\"><strong>is_it_true</strong></a>(self)</dt><dd><tt>Return&nbsp;self.<a href=\"#C-get_answer\">get_answer</a>()</tt></dd></dl>\n\n<dl><dt><a name=\"C-say_no\"><strong>say_no</strong></a>(self)</dt></dl>\n\n<hr>\nData descriptors defined here:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table></td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#eeaa77\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Functions</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#eeaa77\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt><a name=\"-doc_func\"><strong>doc_func</strong></a>()</dt><dd><tt>This&nbsp;function&nbsp;solves&nbsp;all&nbsp;of&nbsp;the&nbsp;world's&nbsp;problems:<br>\nhunger<br>\nlack&nbsp;of&nbsp;Python<br>\nwar</tt></dd></dl>\n <dl><dt><a name=\"-nodoc_func\"><strong>nodoc_func</strong></a>()</dt></dl>\n</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#55aa55\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Data</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#55aa55\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><strong>__xyz__</strong> = 'X, Y and Z'</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#7799ee\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Author</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#7799ee\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Benjamin&nbsp;Peterson</td></tr></table><p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#7799ee\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#ffffff\" face=\"helvetica, arial\"><big><strong>Credits</strong></big></font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#7799ee\"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\">Nobody</td></tr></table>\n\"\"\".strip() # ' <- emacs turd\n\nexpected_html_data_docstrings = tuple(s.replace(' ', '&nbsp;')\n                                      for s in expected_data_docstrings)\n\n# output pattern for missing module\nmissing_pattern = '''\\\nNo Python documentation found for %r.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.'''.replace('\\n', os.linesep)\n\n# output pattern for module with bad imports\nbadimport_pattern = \"problem in %s - ModuleNotFoundError: No module named %r\"\n\nexpected_dynamicattribute_pattern = \"\"\"\nHelp on class DA in module %s:\n\nclass DA(builtins.object)\n |  Data descriptors defined here:\n |\\x20\\x20\n |  __dict__%s\n |\\x20\\x20\n |  __weakref__%s\n |\\x20\\x20\n |  ham\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta:\n |\\x20\\x20\n |  ham = 'spam'\n\"\"\".strip()\n\nexpected_virtualattribute_pattern1 = \"\"\"\nHelp on class Class in module %s:\n\nclass Class(builtins.object)\n |  Data and other attributes inherited from Meta:\n |\\x20\\x20\n |  LIFE = 42\n\"\"\".strip()\n\nexpected_virtualattribute_pattern2 = \"\"\"\nHelp on class Class1 in module %s:\n\nclass Class1(builtins.object)\n |  Data and other attributes inherited from Meta1:\n |\\x20\\x20\n |  one = 1\n\"\"\".strip()\n\nexpected_virtualattribute_pattern3 = \"\"\"\nHelp on class Class2 in module %s:\n\nclass Class2(Class1)\n |  Method resolution order:\n |      Class2\n |      Class1\n |      builtins.object\n |\\x20\\x20\n |  Data and other attributes inherited from Meta1:\n |\\x20\\x20\n |  one = 1\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta3:\n |\\x20\\x20\n |  three = 3\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data and other attributes inherited from Meta2:\n |\\x20\\x20\n |  two = 2\n\"\"\".strip()\n\nexpected_missingattribute_pattern = \"\"\"\nHelp on class C in module %s:\n\nclass C(builtins.object)\n |  Data and other attributes defined here:\n |\\x20\\x20\n |  here = 'present!'\n\"\"\".strip()\n\ndef run_pydoc(module_name, *args, **env):\n    \"\"\"\n    Runs pydoc on the specified module. Returns the stripped\n    output of pydoc.\n    \"\"\"\n    args = args + (module_name,)\n    # do not write bytecode files to avoid caching errors\n    rc, out, err = assert_python_ok('-B', pydoc.__file__, *args, **env)\n    return out.strip()\n\ndef get_pydoc_html(module):\n    \"Returns pydoc generated output as html\"\n    doc = pydoc.HTMLDoc()\n    output = doc.docmodule(module)\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"<br><a href=\\\"\" + loc + \"\\\">Module Docs</a>\"\n    return output.strip(), loc\n\ndef get_pydoc_link(module):\n    \"Returns a documentation web link of a module\"\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    basedir = dirname(dirname(abspath(__file__)))\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(module, basedir=basedir)\n    return loc\n\ndef get_pydoc_text(module):\n    \"Returns pydoc generated output as text\"\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"\\nMODULE DOCS\\n    \" + loc + \"\\n\"\n\n    output = doc.docmodule(module)\n\n    # clean up the extra text formatting that pydoc performs\n    patt = re.compile('\\b.')\n    output = patt.sub('', output)\n    return output.strip(), loc\n\ndef get_html_title(text):\n    # Bit of hack, but good enough for test purposes\n    header, _, _ = text.partition(\"</head>\")\n    _, _, title = header.partition(\"<title>\")\n    title, _, _ = title.partition(\"</title>\")\n    return title\n\n\nclass PydocBaseTest(unittest.TestCase):\n\n    def _restricted_walk_packages(self, walk_packages, path=None):\n        \"\"\"\n        A version of pkgutil.walk_packages() that will restrict itself to\n        a given path.\n        \"\"\"\n        default_path = path or [os.path.dirname(__file__)]\n        def wrapper(path=None, prefix='', onerror=None):\n            return walk_packages(path or default_path, prefix, onerror)\n        return wrapper\n\n    @contextlib.contextmanager\n    def restrict_walk_packages(self, path=None):\n        walk_packages = pkgutil.walk_packages\n        pkgutil.walk_packages = self._restricted_walk_packages(walk_packages,\n                                                               path)\n        try:\n            yield\n        finally:\n            pkgutil.walk_packages = walk_packages\n\n    def call_url_handler(self, url, expected_title):\n        text = pydoc._url_handler(url, \"text/html\")\n        result = get_html_title(text)\n        # Check the title to ensure an unexpected error page was not returned\n        self.assertEqual(result, expected_title, text)\n        return text\n\n\nclass PydocDocTest(unittest.TestCase):\n    maxDiff = None\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_html_doc(self):\n        result, doc_loc = get_pydoc_html(pydoc_mod)\n        mod_file = inspect.getabsfile(pydoc_mod)\n        mod_url = urllib.parse.quote(mod_file)\n        expected_html = expected_html_pattern % (\n                        (mod_url, mod_file, doc_loc) +\n                        expected_html_data_docstrings)\n        self.assertEqual(result, expected_html)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_text_doc(self):\n        result, doc_loc = get_pydoc_text(pydoc_mod)\n        expected_text = expected_text_pattern % (\n                        (doc_loc,) +\n                        expected_text_data_docstrings +\n                        (inspect.getabsfile(pydoc_mod),))\n        self.assertEqual(expected_text, result)\n\n    def test_text_enum_member_with_value_zero(self):\n        # Test issue #20654 to ensure enum member with value 0 can be\n        # displayed. It used to throw KeyError: 'zero'.\n        import enum\n        class BinaryInteger(enum.IntEnum):\n            zero = 0\n            one = 1\n        doc = pydoc.render_doc(BinaryInteger)\n        self.assertIn('<BinaryInteger.zero: 0>', doc)\n\n    def test_mixed_case_module_names_are_lower_cased(self):\n        # issue16484\n        doc_link = get_pydoc_link(xml.etree.ElementTree)\n        self.assertIn('xml.etree.elementtree', doc_link)\n\n    def test_issue8225(self):\n        # Test issue8225 to ensure no doc link appears for xml.etree\n        result, doc_loc = get_pydoc_text(xml.etree)\n        self.assertEqual(doc_loc, \"\", \"MODULE DOCS incorrectly includes a link\")\n\n    def test_getpager_with_stdin_none(self):\n        previous_stdin = sys.stdin\n        try:\n            sys.stdin = None\n            pydoc.getpager() # Shouldn't fail.\n        finally:\n            sys.stdin = previous_stdin\n\n    def test_non_str_name(self):\n        # issue14638\n        # Treat illegal (non-str) name like no name\n\n        class A:\n            __name__ = 42\n        class B:\n            pass\n        adoc = pydoc.render_doc(A())\n        bdoc = pydoc.render_doc(B())\n        self.assertEqual(adoc.replace(\"A\", \"B\"), bdoc)\n\n    def test_not_here(self):\n        missing_module = \"test.i_am_not_here\"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module\n        self.assertEqual(expected, result,\n            \"documentation for missing module found\")\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_not_ascii(self):\n        result = run_pydoc('test.test_pydoc.nonascii', PYTHONIOENCODING='ascii')\n        encoded = nonascii.__doc__.encode('ascii', 'backslashreplace')\n        self.assertIn(encoded, result)\n\n    def test_input_strip(self):\n        missing_module = \" test.i_am_not_here \"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module.strip()\n        self.assertEqual(expected, result)\n\n    def test_stripid(self):\n        # test with strings, other implementations might have different repr()\n        stripid = pydoc.stripid\n        # strip the id\n        self.assertEqual(stripid('<function stripid at 0x88dcee4>'),\n                         '<function stripid>')\n        self.assertEqual(stripid('<function stripid at 0x01F65390>'),\n                         '<function stripid>')\n        # nothing to strip, return the same text\n        self.assertEqual(stripid('42'), '42')\n        self.assertEqual(stripid(\"<type 'exceptions.Exception'>\"),\n                         \"<type 'exceptions.Exception'>\")\n\n    def test_builtin_with_more_than_four_children(self):\n        \"\"\"Tests help on builtin object which have more than four child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section and only 4 classes\n        should be displayed with a hint on how many more subclasses are present.\n        For example:\n\n        >>> help(object)\n        Help on class object in module builtins:\n\n        class object\n         |  The most base type\n         |\n         |  Built-in subclasses:\n         |      async_generator\n         |      BaseException\n         |      builtin_function_or_method\n         |      bytearray\n         |      ... and 82 other subclasses\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(object)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      async_generator\\n\"\n                \" |      BaseException\\n\"\n                \" |      builtin_function_or_method\\n\"\n                \" |      bytearray\\n\"\n                \" |      ... and \\\\d+ other subclasses\")\n        self.assertRegex(text, snip)\n\n    def test_builtin_with_child(self):\n        \"\"\"Tests help on builtin object which have only child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. For example:\n\n        >>> help(ArithmeticError)\n        Help on class ArithmeticError in module builtins:\n\n        class ArithmeticError(Exception)\n         |  Base class for arithmetic errors.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      FloatingPointError\n         |      OverflowError\n         |      ZeroDivisionError\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ArithmeticError)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      FloatingPointError\\n\"\n                \" |      OverflowError\\n\"\n                \" |      ZeroDivisionError\")\n        self.assertIn(snip, text)\n\n    def test_builtin_with_grandchild(self):\n        \"\"\"Tests help on builtin classes which have grandchild classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. However, if it also has\n        grandchildren, these should not show up on the subclasses section.\n        For example:\n\n        >>> help(Exception)\n        Help on class Exception in module builtins:\n\n        class Exception(BaseException)\n         |  Common base class for all non-exit exceptions.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      ArithmeticError\n         |      AssertionError\n         |      AttributeError\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(Exception)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      ArithmeticError\\n\"\n                \" |      AssertionError\\n\"\n                \" |      AttributeError\")\n        self.assertIn(snip, text)\n        # Testing that the grandchild ZeroDivisionError does not show up\n        self.assertNotIn('ZeroDivisionError', text)\n\n    def test_builtin_no_child(self):\n        \"\"\"Tests help on builtin object which have no child classes.\n\n        When running help() on a builtin class which has no child classes, it\n        should not contain any \"Built-in subclasses\" section. For example:\n\n        >>> help(ZeroDivisionError)\n\n        Help on class ZeroDivisionError in module builtins:\n\n        class ZeroDivisionError(ArithmeticError)\n         |  Second argument to a division or modulo operation was zero.\n         |\n         |  Method resolution order:\n         |      ZeroDivisionError\n         |      ArithmeticError\n         |      Exception\n         |      BaseException\n         |      object\n         |\n         |  Methods defined here:\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ZeroDivisionError)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    def test_builtin_on_metaclasses(self):\n        \"\"\"Tests help on metaclasses.\n\n        When running help() on a metaclasses such as type, it\n        should not contain any \"Built-in subclasses\" section.\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(type)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -O2 and above')\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_help_output_redirect(self):\n        # issue 940286, if output is set in Helper, then all output from\n        # Helper.help should be redirected\n        old_pattern = expected_text_pattern\n        getpager_old = pydoc.getpager\n        getpager_new = lambda: (lambda x: x)\n        self.maxDiff = None\n\n        buf = StringIO()\n        helper = pydoc.Helper(output=buf)\n        unused, doc_loc = get_pydoc_text(pydoc_mod)\n        module = \"test.pydoc_mod\"\n        help_header = \"\"\"\n        Help on module test.pydoc_mod in test:\n\n        \"\"\".lstrip()\n        help_header = textwrap.dedent(help_header)\n        expected_help_pattern = help_header + expected_text_pattern\n\n        pydoc.getpager = getpager_new\n        try:\n            with captured_output('stdout') as output, \\\n                 captured_output('stderr') as err:\n                helper.help(module)\n                result = buf.getvalue().strip()\n                expected_text = expected_help_pattern % (\n                                (doc_loc,) +\n                                expected_text_data_docstrings +\n                                (inspect.getabsfile(pydoc_mod),))\n                self.assertEqual('', output.getvalue())\n                self.assertEqual('', err.getvalue())\n                self.assertEqual(expected_text, result)\n        finally:\n            pydoc.getpager = getpager_old\n\n    def test_namedtuple_fields(self):\n        Person = namedtuple('Person', ['nickname', 'firstname'])\n        with captured_stdout() as help_io:\n            pydoc.help(Person)\n        helptext = help_io.getvalue()\n        self.assertIn(\"nickname\", helptext)\n        self.assertIn(\"firstname\", helptext)\n        self.assertIn(\"Alias for field number 0\", helptext)\n        self.assertIn(\"Alias for field number 1\", helptext)\n\n    def test_namedtuple_public_underscore(self):\n        NT = namedtuple('NT', ['abc', 'def'], rename=True)\n        with captured_stdout() as help_io:\n            pydoc.help(NT)\n        helptext = help_io.getvalue()\n        self.assertIn('_1', helptext)\n        self.assertIn('_replace', helptext)\n        self.assertIn('_asdict', helptext)\n\n    def test_synopsis(self):\n        self.addCleanup(unlink, TESTFN)\n        for encoding in ('ISO-8859-1', 'UTF-8'):\n            with open(TESTFN, 'w', encoding=encoding) as script:\n                if encoding != 'UTF-8':\n                    print('#coding: {}'.format(encoding), file=script)\n                print('\"\"\"line 1: h\\xe9', file=script)\n                print('line 2: hi\"\"\"', file=script)\n            synopsis = pydoc.synopsis(TESTFN, {})\n            self.assertEqual(synopsis, 'line 1: h\\xe9')\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_synopsis_sourceless(self):\n        expected = os.__doc__.splitlines()[0]\n        filename = os.__cached__\n        synopsis = pydoc.synopsis(filename)\n\n        self.assertEqual(synopsis, expected)\n\n    def test_synopsis_sourceless_empty_doc(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, 'foomod42.py')\n            cached_path = importlib.util.cache_from_source(init_path)\n            with open(init_path, 'w') as fobj:\n                fobj.write(\"foo = 1\")\n            py_compile.compile(init_path)\n            synopsis = pydoc.synopsis(init_path, {})\n            self.assertIsNone(synopsis)\n            synopsis_cached = pydoc.synopsis(cached_path, {})\n            self.assertIsNone(synopsis_cached)\n\n    def test_splitdoc_with_description(self):\n        example_string = \"I Am A Doc\\n\\n\\nHere is my description\"\n        self.assertEqual(pydoc.splitdoc(example_string),\n                         ('I Am A Doc', '\\nHere is my description'))\n\n    def test_is_package_when_not_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            self.assertFalse(pydoc.ispackage(test_dir))\n\n    def test_is_package_when_is_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, '__init__.py')\n            open(init_path, 'w').close()\n            self.assertTrue(pydoc.ispackage(test_dir))\n            os.remove(init_path)\n\n    def test_allmethods(self):\n        # issue 17476: allmethods was no longer returning unbound methods.\n        # This test is a bit fragile in the face of changes to object and type,\n        # but I can't think of a better way to do it without duplicating the\n        # logic of the function under test.\n\n        class TestClass(object):\n            def method_returning_true(self):\n                return True\n\n        # What we expect to get back: everything on object...\n        expected = dict(vars(object))\n        # ...plus our unbound method...\n        expected['method_returning_true'] = TestClass.method_returning_true\n        # ...but not the non-methods on object.\n        del expected['__doc__']\n        del expected['__class__']\n        # inspect resolves descriptors on type into methods, but vars doesn't,\n        # so we need to update __subclasshook__ and __init_subclass__.\n        expected['__subclasshook__'] = TestClass.__subclasshook__\n        expected['__init_subclass__'] = TestClass.__init_subclass__\n\n        methods = pydoc.allmethods(TestClass)\n        self.assertDictEqual(methods, expected)\n\n    def test_method_aliases(self):\n        class A:\n            def tkraise(self, aboveThis=None):\n                \"\"\"Raise this widget in the stacking order.\"\"\"\n            lift = tkraise\n            def a_size(self):\n                \"\"\"Return size\"\"\"\n        class B(A):\n            def itemconfigure(self, tagOrId, cnf=None, **kw):\n                \"\"\"Configure resources of an item TAGORID.\"\"\"\n            itemconfig = itemconfigure\n            b_size = A.a_size\n\n        doc = pydoc.render_doc(B)\n        # clean up the extra text formatting that pydoc performs\n        doc = re.sub('\\b.', '', doc)\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\nclass B(A)\n |  Method resolution order:\n |      B\n |      A\n |      builtins.object\n |\\x20\\x20\n |  Methods defined here:\n |\\x20\\x20\n |  b_size = a_size(self)\n |\\x20\\x20\n |  itemconfig = itemconfigure(self, tagOrId, cnf=None, **kw)\n |\\x20\\x20\n |  itemconfigure(self, tagOrId, cnf=None, **kw)\n |      Configure resources of an item TAGORID.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Methods inherited from A:\n |\\x20\\x20\n |  a_size(self)\n |      Return size\n |\\x20\\x20\n |  lift = tkraise(self, aboveThis=None)\n |\\x20\\x20\n |  tkraise(self, aboveThis=None)\n |      Raise this widget in the stacking order.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from A:\n |\\x20\\x20\n |  __dict__\n |      dictionary for instance variables (if defined)\n |\\x20\\x20\n |  __weakref__\n |      list of weak references to the object (if defined)\n''' % __name__)\n\n        doc = pydoc.render_doc(B, renderer=pydoc.HTMLDoc())\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(A)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt>Method resolution order:</dt>\n<dd>B</dd>\n<dd>A</dd>\n<dd><a href=\"builtins.html#object\">builtins.object</a></dd>\n</dl>\n<hr>\nMethods defined here:<br>\n<dl><dt><a name=\"B-b_size\"><strong>b_size</strong></a> = <a href=\"#B-a_size\">a_size</a>(self)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfig\"><strong>itemconfig</strong></a> = <a href=\"#B-itemconfigure\">itemconfigure</a>(self, tagOrId, cnf=None, **kw)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfigure\"><strong>itemconfigure</strong></a>(self, tagOrId, cnf=None, **kw)</dt><dd><tt>Configure&nbsp;resources&nbsp;of&nbsp;an&nbsp;item&nbsp;TAGORID.</tt></dd></dl>\n\n<hr>\nMethods inherited from A:<br>\n<dl><dt><a name=\"B-a_size\"><strong>a_size</strong></a>(self)</dt><dd><tt>Return&nbsp;size</tt></dd></dl>\n\n<dl><dt><a name=\"B-lift\"><strong>lift</strong></a> = <a href=\"#B-tkraise\">tkraise</a>(self, aboveThis=None)</dt></dl>\n\n<dl><dt><a name=\"B-tkraise\"><strong>tkraise</strong></a>(self, aboveThis=None)</dt><dd><tt>Raise&nbsp;this&nbsp;widget&nbsp;in&nbsp;the&nbsp;stacking&nbsp;order.</tt></dd></dl>\n\n<hr>\nData descriptors inherited from A:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table>\\\n''' % __name__)\n\n\nclass PydocImportTest(PydocBaseTest):\n\n    def setUp(self):\n        self.test_dir = os.mkdir(TESTFN)\n        self.addCleanup(rmtree, TESTFN)\n        importlib.invalidate_caches()\n\n    def test_badimport(self):\n        # This tests the fix for issue 5230, where if pydoc found the module\n        # but the module had an internal import error pydoc would report no doc\n        # found.\n        modname = 'testmod_xyzzy'\n        testpairs = (\n            ('i_am_not_here', 'i_am_not_here'),\n            ('test.i_am_not_here_either', 'test.i_am_not_here_either'),\n            ('test.i_am_not_here.neither_am_i', 'test.i_am_not_here'),\n            ('i_am_not_here.{}'.format(modname), 'i_am_not_here'),\n            ('test.{}'.format(modname), 'test.{}'.format(modname)),\n            )\n\n        sourcefn = os.path.join(TESTFN, modname) + os.extsep + \"py\"\n        for importstring, expectedinmsg in testpairs:\n            with open(sourcefn, 'w') as f:\n                f.write(\"import {}\\n\".format(importstring))\n            result = run_pydoc(modname, PYTHONPATH=TESTFN).decode(\"ascii\")\n            expected = badimport_pattern % (modname, expectedinmsg)\n            self.assertEqual(expected, result)\n\n    def test_apropos_with_bad_package(self):\n        # Issue 7425 - pydoc -k failed when bad package on path\n        pkgdir = os.path.join(TESTFN, \"syntaxerr\")\n        os.mkdir(pkgdir)\n        badsyntax = os.path.join(pkgdir, \"__init__\") + os.extsep + \"py\"\n        with open(badsyntax, 'w') as f:\n            f.write(\"invalid python syntax = $1\\n\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('xyzzy')\n            # No result, no error\n            self.assertEqual(out.getvalue(), '')\n            self.assertEqual(err.getvalue(), '')\n            # The package name is still matched\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('syntaxerr')\n            self.assertEqual(out.getvalue().strip(), 'syntaxerr')\n            self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_with_unreadable_dir(self):\n        # Issue 7367 - pydoc -k failed when unreadable dir on path\n        self.unreadable_dir = os.path.join(TESTFN, \"unreadable\")\n        os.mkdir(self.unreadable_dir, 0)\n        self.addCleanup(os.rmdir, self.unreadable_dir)\n        # Note, on Windows the directory appears to be still\n        #   readable so this is not really testing the issue there\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('SOMEKEY')\n        # No result, no error\n        self.assertEqual(out.getvalue(), '')\n        self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_empty_doc(self):\n        pkgdir = os.path.join(TESTFN, 'walkpkg')\n        os.mkdir(pkgdir)\n        self.addCleanup(rmtree, pkgdir)\n        init_path = os.path.join(pkgdir, '__init__.py')\n        with open(init_path, 'w') as fobj:\n            fobj.write(\"foo = 1\")\n        current_mode = stat.S_IMODE(os.stat(pkgdir).st_mode)\n        try:\n            os.chmod(pkgdir, current_mode & ~stat.S_IEXEC)\n            with self.restrict_walk_packages(path=[TESTFN]), captured_stdout() as stdout:\n                pydoc.apropos('')\n            self.assertIn('walkpkg', stdout.getvalue())\n        finally:\n            os.chmod(pkgdir, current_mode)\n\n    def test_url_search_package_error(self):\n        # URL handler search should cope with packages that raise exceptions\n        pkgdir = os.path.join(TESTFN, \"test_error_package\")\n        os.mkdir(pkgdir)\n        init = os.path.join(pkgdir, \"__init__.py\")\n        with open(init, \"wt\", encoding=\"ascii\") as f:\n            f.write(\"\"\"raise ValueError(\"ouch\")\\n\"\"\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            # Package has to be importable for the error to have any effect\n            saved_paths = tuple(sys.path)\n            sys.path.insert(0, TESTFN)\n            try:\n                with self.assertRaisesRegex(ValueError, \"ouch\"):\n                    import test_error_package  # Sanity check\n\n                text = self.call_url_handler(\"search?key=test_error_package\",\n                    \"Pydoc: Search Results\")\n                found = ('<a href=\"test_error_package.html\">'\n                    'test_error_package</a>')\n                self.assertIn(found, text)\n            finally:\n                sys.path[:] = saved_paths\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules(self):\n        # See Helper.listmodules().\n        num_header_lines = 2\n        num_module_lines_min = 5  # Playing it safe.\n        num_footer_lines = 3\n        expected = num_header_lines + num_module_lines_min + num_footer_lines\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper('modules')\n        result = output.getvalue().strip()\n        num_lines = len(result.splitlines())\n\n        self.assertGreaterEqual(num_lines, expected)\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules_search(self):\n        # See Helper.listmodules().\n        expected = 'pydoc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules pydoc')\n        result = help_io.getvalue()\n\n        self.assertIn(expected, result)\n\n    @unittest.skip('some buildbots are not cooperating (#20128)')\n    def test_modules_search_builtin(self):\n        expected = 'gc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules garbage')\n        result = help_io.getvalue()\n\n        self.assertTrue(result.startswith(expected))\n\n    def test_importfile(self):\n        loaded_pydoc = pydoc.importfile(pydoc.__file__)\n\n        self.assertIsNot(loaded_pydoc, pydoc)\n        self.assertEqual(loaded_pydoc.__name__, 'pydoc')\n        self.assertEqual(loaded_pydoc.__file__, pydoc.__file__)\n        self.assertEqual(loaded_pydoc.__spec__, pydoc.__spec__)\n\n\nclass TestDescriptions(unittest.TestCase):\n\n    def test_module(self):\n        # Check that pydocfodder module can be described\n        from test import pydocfodder\n        doc = pydoc.render_doc(pydocfodder)\n        self.assertIn(\"pydocfodder\", doc)\n\n    def test_class(self):\n        class C: \"New-style class\"\n        c = C()\n\n        self.assertEqual(pydoc.describe(C), 'class C')\n        self.assertEqual(pydoc.describe(c), 'C')\n        expected = 'C in module %s object' % __name__\n        self.assertIn(expected, pydoc.render_doc(c))\n\n    def test_typing_pydoc(self):\n        def foo(data: typing.List[typing.Any],\n                x: int) -> typing.Iterator[typing.Tuple[int, typing.Any]]:\n            ...\n        T = typing.TypeVar('T')\n        class C(typing.Generic[T], typing.Mapping[int, str]): ...\n        self.assertEqual(pydoc.render_doc(foo).splitlines()[-1],\n                         'f\\x08fo\\x08oo\\x08o(data: List[Any], x: int)'\n                         ' -> Iterator[Tuple[int, Any]]')\n        self.assertEqual(pydoc.render_doc(C).splitlines()[2],\n                         'class C\\x08C(collections.abc.Mapping, typing.Generic)')\n\n    def test_builtin(self):\n        for name in ('str', 'str.translate', 'builtins.str',\n                     'builtins.str.translate'):\n            # test low-level function\n            self.assertIsNotNone(pydoc.locate(name))\n            # test high-level function\n            try:\n                pydoc.render_doc(name)\n            except ImportError:\n                self.fail('finding the doc of {!r} failed'.format(name))\n\n        for name in ('notbuiltins', 'strrr', 'strr.translate',\n                     'str.trrrranslate', 'builtins.strrr',\n                     'builtins.str.trrranslate'):\n            self.assertIsNone(pydoc.locate(name))\n            self.assertRaises(ImportError, pydoc.render_doc, name)\n\n    @staticmethod\n    def _get_summary_line(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        assert len(lines) >= 2\n        return lines[2]\n\n    @staticmethod\n    def _get_summary_lines(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        return '\\n'.join(lines[2:])\n\n    # these should include \"self\"\n    def test_unbound_python_method(self):\n        self.assertEqual(self._get_summary_line(textwrap.TextWrapper.wrap),\n            \"wrap(self, text)\")\n\n    @requires_docstrings\n    def test_unbound_builtin_method(self):\n        self.assertEqual(self._get_summary_line(_pickle.Pickler.dump),\n            \"dump(self, obj, /)\")\n\n    # these no longer include \"self\"\n    def test_bound_python_method(self):\n        t = textwrap.TextWrapper()\n        self.assertEqual(self._get_summary_line(t.wrap),\n            \"wrap(text) method of textwrap.TextWrapper instance\")\n    def test_field_order_for_named_tuples(self):\n        Person = namedtuple('Person', ['nickname', 'firstname', 'agegroup'])\n        s = pydoc.render_doc(Person)\n        self.assertLess(s.index('nickname'), s.index('firstname'))\n        self.assertLess(s.index('firstname'), s.index('agegroup'))\n\n        class NonIterableFields:\n            _fields = None\n\n        class NonHashableFields:\n            _fields = [[]]\n\n        # Make sure these doesn't fail\n        pydoc.render_doc(NonIterableFields)\n        pydoc.render_doc(NonHashableFields)\n\n    @requires_docstrings\n    def test_bound_builtin_method(self):\n        s = StringIO()\n        p = _pickle.Pickler(s)\n        self.assertEqual(self._get_summary_line(p.dump),\n            \"dump(obj, /) method of _pickle.Pickler instance\")\n\n    # this should *never* include self!\n    @requires_docstrings\n    def test_module_level_callable(self):\n        self.assertEqual(self._get_summary_line(os.stat),\n            \"stat(path, *, dir_fd=None, follow_symlinks=True)\")\n\n    @requires_docstrings\n    def test_staticmethod(self):\n        class X:\n            @staticmethod\n            def sm(x, y):\n                '''A static method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['sm']),\n                         \"<staticmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.sm), \"\"\"\\\nsm(x, y)\n    A static method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Static methods defined here:\n |\\x20\\x20\n |  sm(x, y)\n |      A static method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_classmethod(self):\n        class X:\n            @classmethod\n            def cm(cls, x):\n                '''A class method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['cm']),\n                         \"<classmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.cm), \"\"\"\\\ncm(x) method of builtins.type instance\n    A class method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Class methods defined here:\n |\\x20\\x20\n |  cm(x) from builtins.type\n |      A class method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_getset_descriptor(self):\n        # Currently these attributes are implemented as getset descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(int.numerator), \"numerator\")\n        self.assertEqual(self._get_summary_line(float.real), \"real\")\n        self.assertEqual(self._get_summary_line(Exception.args), \"args\")\n        self.assertEqual(self._get_summary_line(memoryview.obj), \"obj\")\n\n    @requires_docstrings\n    def test_member_descriptor(self):\n        # Currently these attributes are implemented as member descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(complex.real), \"real\")\n        self.assertEqual(self._get_summary_line(range.start), \"start\")\n        self.assertEqual(self._get_summary_line(slice.start), \"start\")\n        self.assertEqual(self._get_summary_line(property.fget), \"fget\")\n        self.assertEqual(self._get_summary_line(StopIteration.value), \"value\")\n\n    @requires_docstrings\n    def test_slot_descriptor(self):\n        class Point:\n            __slots__ = 'x', 'y'\n        self.assertEqual(self._get_summary_line(Point.x), \"x\")\n\n    @requires_docstrings\n    def test_dict_attr_descriptor(self):\n        class NS:\n            pass\n        self.assertEqual(self._get_summary_line(NS.__dict__['__dict__']),\n                         \"__dict__\")\n\n    @requires_docstrings\n    def test_structseq_member_descriptor(self):\n        self.assertEqual(self._get_summary_line(type(sys.hash_info).width),\n                         \"width\")\n        self.assertEqual(self._get_summary_line(type(sys.flags).debug),\n                         \"debug\")\n        self.assertEqual(self._get_summary_line(type(sys.version_info).major),\n                         \"major\")\n        self.assertEqual(self._get_summary_line(type(sys.float_info).max),\n                         \"max\")\n\n    @requires_docstrings\n    def test_namedtuple_field_descriptor(self):\n        Box = namedtuple('Box', ('width', 'height'))\n        self.assertEqual(self._get_summary_lines(Box.width), \"\"\"\\\n    Alias for field number 0\n\"\"\")\n\n    @requires_docstrings\n    def test_property(self):\n        class Rect:\n            @property\n            def area(self):\n                '''Area of the rect'''\n                return self.w * self.h\n\n        self.assertEqual(self._get_summary_lines(Rect.area), \"\"\"\\\n    Area of the rect\n\"\"\")\n        self.assertIn(\"\"\"\n |  area\n |      Area of the rect\n\"\"\", pydoc.plain(pydoc.render_doc(Rect)))\n\n    @requires_docstrings\n    def test_custom_non_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\"\"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo(...)\n    Custom descriptor\n\"\"\")\n\n    @requires_docstrings\n    def test_custom_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n            def __set__(self, obj, cls):\n                1/0\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo\n    Custom descriptor\n\"\"\")\n\n    def test_async_annotation(self):\n        async def coro_function(ign) -> int:\n            return 1\n\n        text = pydoc.plain(pydoc.plaintext.document(coro_function))\n        self.assertIn('async coro_function', text)\n\n        html = pydoc.HTMLDoc().document(coro_function)\n        self.assertIn(\n            'async <a name=\"-coro_function\"><strong>coro_function',\n            html)\n\n    def test_async_generator_annotation(self):\n        async def an_async_generator():\n            yield 1\n\n        text = pydoc.plain(pydoc.plaintext.document(an_async_generator))\n        self.assertIn('async an_async_generator', text)\n\n        html = pydoc.HTMLDoc().document(an_async_generator)\n        self.assertIn(\n            'async <a name=\"-an_async_generator\"><strong>an_async_generator',\n            html)\n\n    def test_html_for_https_links(self):\n        def a_fn_with_https_link():\n            \"\"\"a link https://localhost/\"\"\"\n            pass\n\n        html = pydoc.HTMLDoc().document(a_fn_with_https_link)\n        self.assertIn(\n            '<a href=\"https://localhost/\">https://localhost/</a>',\n            html\n        )\n\nclass PydocServerTest(unittest.TestCase):\n    \"\"\"Tests for pydoc._start_server\"\"\"\n\n    def test_server(self):\n\n        # Minimal test that starts the server, then stops it.\n        def my_url_handler(url, content_type):\n            text = 'the URL sent was: (%s, %s)' % (url, content_type)\n            return text\n\n        serverthread = pydoc._start_server(my_url_handler, hostname='0.0.0.0', port=0)\n        self.assertIn('0.0.0.0', serverthread.docserver.address)\n\n        starttime = time.monotonic()\n        timeout = test.support.SHORT_TIMEOUT\n\n        while serverthread.serving:\n            time.sleep(.01)\n            if serverthread.serving and time.monotonic() - starttime > timeout:\n                serverthread.stop()\n                break\n\n        self.assertEqual(serverthread.error, None)\n\n\nclass PydocUrlHandlerTest(PydocBaseTest):\n    \"\"\"Tests for pydoc._url_handler\"\"\"\n\n    def test_content_type_err(self):\n        f = pydoc._url_handler\n        self.assertRaises(TypeError, f, 'A', '')\n        self.assertRaises(TypeError, f, 'B', 'foobar')\n\n    def test_url_requests(self):\n        # Test for the correct title in the html pages returned.\n        # This tests the different parts of the URL handler without\n        # getting too picky about the exact html.\n        requests = [\n            (\"\", \"Pydoc: Index of Modules\"),\n            (\"get?key=\", \"Pydoc: Index of Modules\"),\n            (\"index\", \"Pydoc: Index of Modules\"),\n            (\"topics\", \"Pydoc: Topics\"),\n            (\"keywords\", \"Pydoc: Keywords\"),\n            (\"pydoc\", \"Pydoc: module pydoc\"),\n            (\"get?key=pydoc\", \"Pydoc: module pydoc\"),\n            (\"search?key=pydoc\", \"Pydoc: Search Results\"),\n            (\"topic?key=def\", \"Pydoc: KEYWORD def\"),\n            (\"topic?key=STRINGS\", \"Pydoc: TOPIC STRINGS\"),\n            (\"foobar\", \"Pydoc: Error - foobar\"),\n            (\"getfile?key=foobar\", \"Pydoc: Error - getfile?key=foobar\"),\n            ]\n\n        with self.restrict_walk_packages():\n            for url, title in requests:\n                self.call_url_handler(url, title)\n\n            path = string.__file__\n            title = \"Pydoc: getfile \" + path\n            url = \"getfile?key=\" + path\n            self.call_url_handler(url, title)\n\n\nclass TestHelper(unittest.TestCase):\n    def test_keywords(self):\n        self.assertEqual(sorted(pydoc.Helper.keywords),\n                         sorted(keyword.kwlist))\n\nclass PydocWithMetaClasses(unittest.TestCase):\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_DynamicClassAttribute(self):\n        class Meta(type):\n            def __getattr__(self, name):\n                if name == 'ham':\n                    return 'spam'\n                return super().__getattr__(name)\n        class DA(metaclass=Meta):\n            @types.DynamicClassAttribute\n            def ham(self):\n                return 'eggs'\n        expected_text_data_docstrings = tuple('\\n |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(DA)\n        expected_text = expected_dynamicattribute_pattern % (\n                (__name__,) + expected_text_data_docstrings[:2])\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithOneMeta(self):\n        class Meta(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'LIFE']\n            def __getattr__(self, name):\n                if name =='LIFE':\n                    return 42\n                return super().__getattr(name)\n        class Class(metaclass=Meta):\n            pass\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class)\n        expected_text = expected_virtualattribute_pattern1 % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithTwoMeta(self):\n        class Meta1(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'one']\n            def __getattr__(self, name):\n                if name =='one':\n                    return 1\n                return super().__getattr__(name)\n        class Meta2(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'two']\n            def __getattr__(self, name):\n                if name =='two':\n                    return 2\n                return super().__getattr__(name)\n        class Meta3(Meta1, Meta2):\n            def __dir__(cls):\n                return list(sorted(set(\n                    ['__class__', '__module__', '__name__', 'three'] +\n                    Meta1.__dir__(cls) + Meta2.__dir__(cls))))\n            def __getattr__(self, name):\n                if name =='three':\n                    return 3\n                return super().__getattr__(name)\n        class Class1(metaclass=Meta1):\n            pass\n        class Class2(Class1, metaclass=Meta3):\n            pass\n        fail1 = fail2 = False\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class1)\n        expected_text1 = expected_virtualattribute_pattern2 % __name__\n        result1 = output.getvalue().strip()\n        self.assertEqual(expected_text1, result1)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class2)\n        expected_text2 = expected_virtualattribute_pattern3 % __name__\n        result2 = output.getvalue().strip()\n        self.assertEqual(expected_text2, result2)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_buggy_dir(self):\n        class M(type):\n            def __dir__(cls):\n                return ['__class__', '__name__', 'missing', 'here']\n        class C(metaclass=M):\n            here = 'present!'\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(C)\n        expected_text = expected_missingattribute_pattern % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    def test_resolve_false(self):\n        # Issue #23008: pydoc enum.{,Int}Enum failed\n        # because bool(enum.Enum) is False.\n        with captured_stdout() as help_io:\n            pydoc.help('enum.Enum')\n        helptext = help_io.getvalue()\n        self.assertIn('class Enum', helptext)\n\n\nclass TestInternalUtilities(unittest.TestCase):\n\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.argv0dir = tmpdir.name\n        self.argv0 = os.path.join(tmpdir.name, \"nonexistent\")\n        self.addCleanup(tmpdir.cleanup)\n        self.abs_curdir = abs_curdir = os.getcwd()\n        self.curdir_spellings = [\"\", os.curdir, abs_curdir]\n\n    def _get_revised_path(self, given_path, argv0=None):\n        # Checking that pydoc.cli() actually calls pydoc._get_revised_path()\n        # is handled via code review (at least for now).\n        if argv0 is None:\n            argv0 = self.argv0\n        return pydoc._get_revised_path(given_path, argv0)\n\n    def _get_starting_path(self):\n        # Get a copy of sys.path without the current directory.\n        clean_path = sys.path.copy()\n        for spelling in self.curdir_spellings:\n            for __ in range(clean_path.count(spelling)):\n                clean_path.remove(spelling)\n        return clean_path\n\n    def test_sys_path_adjustment_adds_missing_curdir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        self.assertEqual(self._get_revised_path(clean_path), expected_path)\n\n    def test_sys_path_adjustment_removes_argv0_dir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        leading_argv0dir = [self.argv0dir] + clean_path\n        self.assertEqual(self._get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        self.assertEqual(self._get_revised_path(trailing_argv0dir), expected_path)\n\n\n    def test_sys_path_adjustment_protects_pydoc_dir(self):\n        def _get_revised_path(given_path):\n            return self._get_revised_path(given_path, argv0=pydoc.__file__)\n        clean_path = self._get_starting_path()\n        leading_argv0dir = [self.argv0dir] + clean_path\n        expected_path = [self.abs_curdir] + leading_argv0dir\n        self.assertEqual(_get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        expected_path = [self.abs_curdir] + trailing_argv0dir\n        self.assertEqual(_get_revised_path(trailing_argv0dir), expected_path)\n\n    def test_sys_path_adjustment_when_curdir_already_included(self):\n        clean_path = self._get_starting_path()\n        for spelling in self.curdir_spellings:\n            with self.subTest(curdir_spelling=spelling):\n                # If curdir is already present, no alterations are made at all\n                leading_curdir = [spelling] + clean_path\n                self.assertIsNone(self._get_revised_path(leading_curdir))\n                trailing_curdir = clean_path + [spelling]\n                self.assertIsNone(self._get_revised_path(trailing_curdir))\n                leading_argv0dir = [self.argv0dir] + leading_curdir\n                self.assertIsNone(self._get_revised_path(leading_argv0dir))\n                trailing_argv0dir = trailing_curdir + [self.argv0dir]\n                self.assertIsNone(self._get_revised_path(trailing_argv0dir))\n\n\n@threading_helper.reap_threads\ndef test_main():\n    try:\n        test.support.run_unittest(PydocDocTest,\n                                  PydocImportTest,\n                                  TestDescriptions,\n                                  PydocServerTest,\n                                  PydocUrlHandlerTest,\n                                  TestHelper,\n                                  PydocWithMetaClasses,\n                                  TestInternalUtilities,\n                                  )\n    finally:\n        reap_children()\n\nif __name__ == \"__main__\":\n    test_main()\n", "patch": "@@ -1374,18 +1374,12 @@ def test_url_requests(self):\n             (\"topic?key=def\", \"Pydoc: KEYWORD def\"),\n             (\"topic?key=STRINGS\", \"Pydoc: TOPIC STRINGS\"),\n             (\"foobar\", \"Pydoc: Error - foobar\"),\n-            (\"getfile?key=foobar\", \"Pydoc: Error - getfile?key=foobar\"),\n             ]\n \n         with self.restrict_walk_packages():\n             for url, title in requests:\n                 self.call_url_handler(url, title)\n \n-            path = string.__file__\n-            title = \"Pydoc: getfile \" + path\n-            url = \"getfile?key=\" + path\n-            self.call_url_handler(url, title)\n-\n \n class TestHelper(unittest.TestCase):\n     def test_keywords(self):", "file_path": "files/2021_5/364", "file_language": "py", "file_name": "Lib/test/test_pydoc.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class nonascii:\n    '\u0426\u0435 \u043d\u0435 \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044f'\n    pass", "target": 0}, {"function": "def run_pydoc(module_name, *args, **env):\n    \"\"\"\n    Runs pydoc on the specified module. Returns the stripped\n    output of pydoc.\n    \"\"\"\n    args = args + (module_name,)\n    # do not write bytecode files to avoid caching errors\n    rc, out, err = assert_python_ok('-B', pydoc.__file__, *args, **env)\n    return out.strip()", "target": 0}, {"function": "def get_pydoc_html(module):\n    \"Returns pydoc generated output as html\"\n    doc = pydoc.HTMLDoc()\n    output = doc.docmodule(module)\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"<br><a href=\\\"\" + loc + \"\\\">Module Docs</a>\"\n    return output.strip(), loc", "target": 0}, {"function": "def get_pydoc_link(module):\n    \"Returns a documentation web link of a module\"\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    basedir = dirname(dirname(abspath(__file__)))\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(module, basedir=basedir)\n    return loc", "target": 0}, {"function": "def get_pydoc_text(module):\n    \"Returns pydoc generated output as text\"\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"\\nMODULE DOCS\\n    \" + loc + \"\\n\"\n\n    output = doc.docmodule(module)\n\n    # clean up the extra text formatting that pydoc performs\n    patt = re.compile('\\b.')\n    output = patt.sub('', output)\n    return output.strip(), loc", "target": 0}, {"function": "def get_html_title(text):\n    # Bit of hack, but good enough for test purposes\n    header, _, _ = text.partition(\"</head>\")\n    _, _, title = header.partition(\"<title>\")\n    title, _, _ = title.partition(\"</title>\")\n    return title", "target": 0}, {"function": "class PydocBaseTest(unittest.TestCase):\n\n    def _restricted_walk_packages(self, walk_packages, path=None):\n        \"\"\"\n        A version of pkgutil.walk_packages() that will restrict itself to\n        a given path.\n        \"\"\"\n        default_path = path or [os.path.dirname(__file__)]\n        def wrapper(path=None, prefix='', onerror=None):\n            return walk_packages(path or default_path, prefix, onerror)\n        return wrapper\n\n    @contextlib.contextmanager\n    def restrict_walk_packages(self, path=None):\n        walk_packages = pkgutil.walk_packages\n        pkgutil.walk_packages = self._restricted_walk_packages(walk_packages,\n                                                               path)\n        try:\n            yield\n        finally:\n            pkgutil.walk_packages = walk_packages\n\n    def call_url_handler(self, url, expected_title):\n        text = pydoc._url_handler(url, \"text/html\")\n        result = get_html_title(text)\n        # Check the title to ensure an unexpected error page was not returned\n        self.assertEqual(result, expected_title, text)\n        return text", "target": 0}, {"function": "class PydocDocTest(unittest.TestCase):\n    maxDiff = None\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_html_doc(self):\n        result, doc_loc = get_pydoc_html(pydoc_mod)\n        mod_file = inspect.getabsfile(pydoc_mod)\n        mod_url = urllib.parse.quote(mod_file)\n        expected_html = expected_html_pattern % (\n                        (mod_url, mod_file, doc_loc) +\n                        expected_html_data_docstrings)\n        self.assertEqual(result, expected_html)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_text_doc(self):\n        result, doc_loc = get_pydoc_text(pydoc_mod)\n        expected_text = expected_text_pattern % (\n                        (doc_loc,) +\n                        expected_text_data_docstrings +\n                        (inspect.getabsfile(pydoc_mod),))\n        self.assertEqual(expected_text, result)\n\n    def test_text_enum_member_with_value_zero(self):\n        # Test issue #20654 to ensure enum member with value 0 can be\n        # displayed. It used to throw KeyError: 'zero'.\n        import enum\n        class BinaryInteger(enum.IntEnum):\n            zero = 0\n            one = 1\n        doc = pydoc.render_doc(BinaryInteger)\n        self.assertIn('<BinaryInteger.zero: 0>', doc)\n\n    def test_mixed_case_module_names_are_lower_cased(self):\n        # issue16484\n        doc_link = get_pydoc_link(xml.etree.ElementTree)\n        self.assertIn('xml.etree.elementtree', doc_link)\n\n    def test_issue8225(self):\n        # Test issue8225 to ensure no doc link appears for xml.etree\n        result, doc_loc = get_pydoc_text(xml.etree)\n        self.assertEqual(doc_loc, \"\", \"MODULE DOCS incorrectly includes a link\")\n\n    def test_getpager_with_stdin_none(self):\n        previous_stdin = sys.stdin\n        try:\n            sys.stdin = None\n            pydoc.getpager() # Shouldn't fail.\n        finally:\n            sys.stdin = previous_stdin\n\n    def test_non_str_name(self):\n        # issue14638\n        # Treat illegal (non-str) name like no name\n\n        class A:\n            __name__ = 42\n        class B:\n            pass\n        adoc = pydoc.render_doc(A())\n        bdoc = pydoc.render_doc(B())\n        self.assertEqual(adoc.replace(\"A\", \"B\"), bdoc)\n\n    def test_not_here(self):\n        missing_module = \"test.i_am_not_here\"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module\n        self.assertEqual(expected, result,\n            \"documentation for missing module found\")\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_not_ascii(self):\n        result = run_pydoc('test.test_pydoc.nonascii', PYTHONIOENCODING='ascii')\n        encoded = nonascii.__doc__.encode('ascii', 'backslashreplace')\n        self.assertIn(encoded, result)\n\n    def test_input_strip(self):\n        missing_module = \" test.i_am_not_here \"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module.strip()\n        self.assertEqual(expected, result)\n\n    def test_stripid(self):\n        # test with strings, other implementations might have different repr()\n        stripid = pydoc.stripid\n        # strip the id\n        self.assertEqual(stripid('<function stripid at 0x88dcee4>'),\n                         '<function stripid>')\n        self.assertEqual(stripid('<function stripid at 0x01F65390>'),\n                         '<function stripid>')\n        # nothing to strip, return the same text\n        self.assertEqual(stripid('42'), '42')\n        self.assertEqual(stripid(\"<type 'exceptions.Exception'>\"),\n                         \"<type 'exceptions.Exception'>\")\n\n    def test_builtin_with_more_than_four_children(self):\n        \"\"\"Tests help on builtin object which have more than four child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section and only 4 classes\n        should be displayed with a hint on how many more subclasses are present.\n        For example:\n\n        >>> help(object)\n        Help on class object in module builtins:\n\n        class object\n         |  The most base type\n         |\n         |  Built-in subclasses:\n         |      async_generator\n         |      BaseException\n         |      builtin_function_or_method\n         |      bytearray\n         |      ... and 82 other subclasses\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(object)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      async_generator\\n\"\n                \" |      BaseException\\n\"\n                \" |      builtin_function_or_method\\n\"\n                \" |      bytearray\\n\"\n                \" |      ... and \\\\d+ other subclasses\")\n        self.assertRegex(text, snip)\n\n    def test_builtin_with_child(self):\n        \"\"\"Tests help on builtin object which have only child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. For example:\n\n        >>> help(ArithmeticError)\n        Help on class ArithmeticError in module builtins:\n\n        class ArithmeticError(Exception)\n         |  Base class for arithmetic errors.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      FloatingPointError\n         |      OverflowError\n         |      ZeroDivisionError\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ArithmeticError)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      FloatingPointError\\n\"\n                \" |      OverflowError\\n\"\n                \" |      ZeroDivisionError\")\n        self.assertIn(snip, text)\n\n    def test_builtin_with_grandchild(self):\n        \"\"\"Tests help on builtin classes which have grandchild classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. However, if it also has\n        grandchildren, these should not show up on the subclasses section.\n        For example:\n\n        >>> help(Exception)\n        Help on class Exception in module builtins:\n\n        class Exception(BaseException)\n         |  Common base class for all non-exit exceptions.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      ArithmeticError\n         |      AssertionError\n         |      AttributeError\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(Exception)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      ArithmeticError\\n\"\n                \" |      AssertionError\\n\"\n                \" |      AttributeError\")\n        self.assertIn(snip, text)\n        # Testing that the grandchild ZeroDivisionError does not show up\n        self.assertNotIn('ZeroDivisionError', text)\n\n    def test_builtin_no_child(self):\n        \"\"\"Tests help on builtin object which have no child classes.\n\n        When running help() on a builtin class which has no child classes, it\n        should not contain any \"Built-in subclasses\" section. For example:\n\n        >>> help(ZeroDivisionError)\n\n        Help on class ZeroDivisionError in module builtins:\n\n        class ZeroDivisionError(ArithmeticError)\n         |  Second argument to a division or modulo operation was zero.\n         |\n         |  Method resolution order:\n         |      ZeroDivisionError\n         |      ArithmeticError\n         |      Exception\n         |      BaseException\n         |      object\n         |\n         |  Methods defined here:\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ZeroDivisionError)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    def test_builtin_on_metaclasses(self):\n        \"\"\"Tests help on metaclasses.\n\n        When running help() on a metaclasses such as type, it\n        should not contain any \"Built-in subclasses\" section.\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(type)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -O2 and above')\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_help_output_redirect(self):\n        # issue 940286, if output is set in Helper, then all output from\n        # Helper.help should be redirected\n        old_pattern = expected_text_pattern\n        getpager_old = pydoc.getpager\n        getpager_new = lambda: (lambda x: x)\n        self.maxDiff = None\n\n        buf = StringIO()\n        helper = pydoc.Helper(output=buf)\n        unused, doc_loc = get_pydoc_text(pydoc_mod)\n        module = \"test.pydoc_mod\"\n        help_header = \"\"\"\n        Help on module test.pydoc_mod in test:\n\n        \"\"\".lstrip()\n        help_header = textwrap.dedent(help_header)\n        expected_help_pattern = help_header + expected_text_pattern\n\n        pydoc.getpager = getpager_new\n        try:\n            with captured_output('stdout') as output, \\\n                 captured_output('stderr') as err:\n                helper.help(module)\n                result = buf.getvalue().strip()\n                expected_text = expected_help_pattern % (\n                                (doc_loc,) +\n                                expected_text_data_docstrings +\n                                (inspect.getabsfile(pydoc_mod),))\n                self.assertEqual('', output.getvalue())\n                self.assertEqual('', err.getvalue())\n                self.assertEqual(expected_text, result)\n        finally:\n            pydoc.getpager = getpager_old\n\n    def test_namedtuple_fields(self):\n        Person = namedtuple('Person', ['nickname', 'firstname'])\n        with captured_stdout() as help_io:\n            pydoc.help(Person)\n        helptext = help_io.getvalue()\n        self.assertIn(\"nickname\", helptext)\n        self.assertIn(\"firstname\", helptext)\n        self.assertIn(\"Alias for field number 0\", helptext)\n        self.assertIn(\"Alias for field number 1\", helptext)\n\n    def test_namedtuple_public_underscore(self):\n        NT = namedtuple('NT', ['abc', 'def'], rename=True)\n        with captured_stdout() as help_io:\n            pydoc.help(NT)\n        helptext = help_io.getvalue()\n        self.assertIn('_1', helptext)\n        self.assertIn('_replace', helptext)\n        self.assertIn('_asdict', helptext)\n\n    def test_synopsis(self):\n        self.addCleanup(unlink, TESTFN)\n        for encoding in ('ISO-8859-1', 'UTF-8'):\n            with open(TESTFN, 'w', encoding=encoding) as script:\n                if encoding != 'UTF-8':\n                    print('#coding: {}'.format(encoding), file=script)\n                print('\"\"\"line 1: h\\xe9', file=script)\n                print('line 2: hi\"\"\"', file=script)\n            synopsis = pydoc.synopsis(TESTFN, {})\n            self.assertEqual(synopsis, 'line 1: h\\xe9')\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_synopsis_sourceless(self):\n        expected = os.__doc__.splitlines()[0]\n        filename = os.__cached__\n        synopsis = pydoc.synopsis(filename)\n\n        self.assertEqual(synopsis, expected)\n\n    def test_synopsis_sourceless_empty_doc(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, 'foomod42.py')\n            cached_path = importlib.util.cache_from_source(init_path)\n            with open(init_path, 'w') as fobj:\n                fobj.write(\"foo = 1\")\n            py_compile.compile(init_path)\n            synopsis = pydoc.synopsis(init_path, {})\n            self.assertIsNone(synopsis)\n            synopsis_cached = pydoc.synopsis(cached_path, {})\n            self.assertIsNone(synopsis_cached)\n\n    def test_splitdoc_with_description(self):\n        example_string = \"I Am A Doc\\n\\n\\nHere is my description\"\n        self.assertEqual(pydoc.splitdoc(example_string),\n                         ('I Am A Doc', '\\nHere is my description'))\n\n    def test_is_package_when_not_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            self.assertFalse(pydoc.ispackage(test_dir))\n\n    def test_is_package_when_is_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, '__init__.py')\n            open(init_path, 'w').close()\n            self.assertTrue(pydoc.ispackage(test_dir))\n            os.remove(init_path)\n\n    def test_allmethods(self):\n        # issue 17476: allmethods was no longer returning unbound methods.\n        # This test is a bit fragile in the face of changes to object and type,\n        # but I can't think of a better way to do it without duplicating the\n        # logic of the function under test.\n\n        class TestClass(object):\n            def method_returning_true(self):\n                return True\n\n        # What we expect to get back: everything on object...\n        expected = dict(vars(object))\n        # ...plus our unbound method...\n        expected['method_returning_true'] = TestClass.method_returning_true\n        # ...but not the non-methods on object.\n        del expected['__doc__']\n        del expected['__class__']\n        # inspect resolves descriptors on type into methods, but vars doesn't,\n        # so we need to update __subclasshook__ and __init_subclass__.\n        expected['__subclasshook__'] = TestClass.__subclasshook__\n        expected['__init_subclass__'] = TestClass.__init_subclass__\n\n        methods = pydoc.allmethods(TestClass)\n        self.assertDictEqual(methods, expected)\n\n    def test_method_aliases(self):\n        class A:\n            def tkraise(self, aboveThis=None):\n                \"\"\"Raise this widget in the stacking order.\"\"\"\n            lift = tkraise\n            def a_size(self):\n                \"\"\"Return size\"\"\"\n        class B(A):\n            def itemconfigure(self, tagOrId, cnf=None, **kw):\n                \"\"\"Configure resources of an item TAGORID.\"\"\"\n            itemconfig = itemconfigure\n            b_size = A.a_size\n\n        doc = pydoc.render_doc(B)\n        # clean up the extra text formatting that pydoc performs\n        doc = re.sub('\\b.', '', doc)\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\nclass B(A)\n |  Method resolution order:\n |      B\n |      A\n |      builtins.object\n |\\x20\\x20\n |  Methods defined here:\n |\\x20\\x20\n |  b_size = a_size(self)\n |\\x20\\x20\n |  itemconfig = itemconfigure(self, tagOrId, cnf=None, **kw)\n |\\x20\\x20\n |  itemconfigure(self, tagOrId, cnf=None, **kw)\n |      Configure resources of an item TAGORID.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Methods inherited from A:\n |\\x20\\x20\n |  a_size(self)\n |      Return size\n |\\x20\\x20\n |  lift = tkraise(self, aboveThis=None)\n |\\x20\\x20\n |  tkraise(self, aboveThis=None)\n |      Raise this widget in the stacking order.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from A:\n |\\x20\\x20\n |  __dict__\n |      dictionary for instance variables (if defined)\n |\\x20\\x20\n |  __weakref__\n |      list of weak references to the object (if defined)\n''' % __name__)\n\n        doc = pydoc.render_doc(B, renderer=pydoc.HTMLDoc())\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(A)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt>Method resolution order:</dt>\n<dd>B</dd>\n<dd>A</dd>\n<dd><a href=\"builtins.html#object\">builtins.object</a></dd>\n</dl>\n<hr>\nMethods defined here:<br>\n<dl><dt><a name=\"B-b_size\"><strong>b_size</strong></a> = <a href=\"#B-a_size\">a_size</a>(self)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfig\"><strong>itemconfig</strong></a> = <a href=\"#B-itemconfigure\">itemconfigure</a>(self, tagOrId, cnf=None, **kw)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfigure\"><strong>itemconfigure</strong></a>(self, tagOrId, cnf=None, **kw)</dt><dd><tt>Configure&nbsp;resources&nbsp;of&nbsp;an&nbsp;item&nbsp;TAGORID.</tt></dd></dl>\n\n<hr>\nMethods inherited from A:<br>\n<dl><dt><a name=\"B-a_size\"><strong>a_size</strong></a>(self)</dt><dd><tt>Return&nbsp;size</tt></dd></dl>\n\n<dl><dt><a name=\"B-lift\"><strong>lift</strong></a> = <a href=\"#B-tkraise\">tkraise</a>(self, aboveThis=None)</dt></dl>\n\n<dl><dt><a name=\"B-tkraise\"><strong>tkraise</strong></a>(self, aboveThis=None)</dt><dd><tt>Raise&nbsp;this&nbsp;widget&nbsp;in&nbsp;the&nbsp;stacking&nbsp;order.</tt></dd></dl>\n\n<hr>\nData descriptors inherited from A:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table>\\\n''' % __name__)", "target": 0}, {"function": "class PydocImportTest(PydocBaseTest):\n\n    def setUp(self):\n        self.test_dir = os.mkdir(TESTFN)\n        self.addCleanup(rmtree, TESTFN)\n        importlib.invalidate_caches()\n\n    def test_badimport(self):\n        # This tests the fix for issue 5230, where if pydoc found the module\n        # but the module had an internal import error pydoc would report no doc\n        # found.\n        modname = 'testmod_xyzzy'\n        testpairs = (\n            ('i_am_not_here', 'i_am_not_here'),\n            ('test.i_am_not_here_either', 'test.i_am_not_here_either'),\n            ('test.i_am_not_here.neither_am_i', 'test.i_am_not_here'),\n            ('i_am_not_here.{}'.format(modname), 'i_am_not_here'),\n            ('test.{}'.format(modname), 'test.{}'.format(modname)),\n            )\n\n        sourcefn = os.path.join(TESTFN, modname) + os.extsep + \"py\"\n        for importstring, expectedinmsg in testpairs:\n            with open(sourcefn, 'w') as f:\n                f.write(\"import {}\\n\".format(importstring))\n            result = run_pydoc(modname, PYTHONPATH=TESTFN).decode(\"ascii\")\n            expected = badimport_pattern % (modname, expectedinmsg)\n            self.assertEqual(expected, result)\n\n    def test_apropos_with_bad_package(self):\n        # Issue 7425 - pydoc -k failed when bad package on path\n        pkgdir = os.path.join(TESTFN, \"syntaxerr\")\n        os.mkdir(pkgdir)\n        badsyntax = os.path.join(pkgdir, \"__init__\") + os.extsep + \"py\"\n        with open(badsyntax, 'w') as f:\n            f.write(\"invalid python syntax = $1\\n\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('xyzzy')\n            # No result, no error\n            self.assertEqual(out.getvalue(), '')\n            self.assertEqual(err.getvalue(), '')\n            # The package name is still matched\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('syntaxerr')\n            self.assertEqual(out.getvalue().strip(), 'syntaxerr')\n            self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_with_unreadable_dir(self):\n        # Issue 7367 - pydoc -k failed when unreadable dir on path\n        self.unreadable_dir = os.path.join(TESTFN, \"unreadable\")\n        os.mkdir(self.unreadable_dir, 0)\n        self.addCleanup(os.rmdir, self.unreadable_dir)\n        # Note, on Windows the directory appears to be still\n        #   readable so this is not really testing the issue there\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('SOMEKEY')\n        # No result, no error\n        self.assertEqual(out.getvalue(), '')\n        self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_empty_doc(self):\n        pkgdir = os.path.join(TESTFN, 'walkpkg')\n        os.mkdir(pkgdir)\n        self.addCleanup(rmtree, pkgdir)\n        init_path = os.path.join(pkgdir, '__init__.py')\n        with open(init_path, 'w') as fobj:\n            fobj.write(\"foo = 1\")\n        current_mode = stat.S_IMODE(os.stat(pkgdir).st_mode)\n        try:\n            os.chmod(pkgdir, current_mode & ~stat.S_IEXEC)\n            with self.restrict_walk_packages(path=[TESTFN]), captured_stdout() as stdout:\n                pydoc.apropos('')\n            self.assertIn('walkpkg', stdout.getvalue())\n        finally:\n            os.chmod(pkgdir, current_mode)\n\n    def test_url_search_package_error(self):\n        # URL handler search should cope with packages that raise exceptions\n        pkgdir = os.path.join(TESTFN, \"test_error_package\")\n        os.mkdir(pkgdir)\n        init = os.path.join(pkgdir, \"__init__.py\")\n        with open(init, \"wt\", encoding=\"ascii\") as f:\n            f.write(\"\"\"raise ValueError(\"ouch\")\\n\"\"\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            # Package has to be importable for the error to have any effect\n            saved_paths = tuple(sys.path)\n            sys.path.insert(0, TESTFN)\n            try:\n                with self.assertRaisesRegex(ValueError, \"ouch\"):\n                    import test_error_package  # Sanity check\n\n                text = self.call_url_handler(\"search?key=test_error_package\",\n                    \"Pydoc: Search Results\")\n                found = ('<a href=\"test_error_package.html\">'\n                    'test_error_package</a>')\n                self.assertIn(found, text)\n            finally:\n                sys.path[:] = saved_paths\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules(self):\n        # See Helper.listmodules().\n        num_header_lines = 2\n        num_module_lines_min = 5  # Playing it safe.\n        num_footer_lines = 3\n        expected = num_header_lines + num_module_lines_min + num_footer_lines\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper('modules')\n        result = output.getvalue().strip()\n        num_lines = len(result.splitlines())\n\n        self.assertGreaterEqual(num_lines, expected)\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules_search(self):\n        # See Helper.listmodules().\n        expected = 'pydoc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules pydoc')\n        result = help_io.getvalue()\n\n        self.assertIn(expected, result)\n\n    @unittest.skip('some buildbots are not cooperating (#20128)')\n    def test_modules_search_builtin(self):\n        expected = 'gc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules garbage')\n        result = help_io.getvalue()\n\n        self.assertTrue(result.startswith(expected))\n\n    def test_importfile(self):\n        loaded_pydoc = pydoc.importfile(pydoc.__file__)\n\n        self.assertIsNot(loaded_pydoc, pydoc)\n        self.assertEqual(loaded_pydoc.__name__, 'pydoc')\n        self.assertEqual(loaded_pydoc.__file__, pydoc.__file__)\n        self.assertEqual(loaded_pydoc.__spec__, pydoc.__spec__)", "target": 0}, {"function": "class TestDescriptions(unittest.TestCase):\n\n    def test_module(self):\n        # Check that pydocfodder module can be described\n        from test import pydocfodder\n        doc = pydoc.render_doc(pydocfodder)\n        self.assertIn(\"pydocfodder\", doc)\n\n    def test_class(self):\n        class C: \"New-style class\"\n        c = C()\n\n        self.assertEqual(pydoc.describe(C), 'class C')\n        self.assertEqual(pydoc.describe(c), 'C')\n        expected = 'C in module %s object' % __name__\n        self.assertIn(expected, pydoc.render_doc(c))\n\n    def test_typing_pydoc(self):\n        def foo(data: typing.List[typing.Any],\n                x: int) -> typing.Iterator[typing.Tuple[int, typing.Any]]:\n            ...\n        T = typing.TypeVar('T')\n        class C(typing.Generic[T], typing.Mapping[int, str]): ...\n        self.assertEqual(pydoc.render_doc(foo).splitlines()[-1],\n                         'f\\x08fo\\x08oo\\x08o(data: List[Any], x: int)'\n                         ' -> Iterator[Tuple[int, Any]]')\n        self.assertEqual(pydoc.render_doc(C).splitlines()[2],\n                         'class C\\x08C(collections.abc.Mapping, typing.Generic)')\n\n    def test_builtin(self):\n        for name in ('str', 'str.translate', 'builtins.str',\n                     'builtins.str.translate'):\n            # test low-level function\n            self.assertIsNotNone(pydoc.locate(name))\n            # test high-level function\n            try:\n                pydoc.render_doc(name)\n            except ImportError:\n                self.fail('finding the doc of {!r} failed'.format(name))\n\n        for name in ('notbuiltins', 'strrr', 'strr.translate',\n                     'str.trrrranslate', 'builtins.strrr',\n                     'builtins.str.trrranslate'):\n            self.assertIsNone(pydoc.locate(name))\n            self.assertRaises(ImportError, pydoc.render_doc, name)\n\n    @staticmethod\n    def _get_summary_line(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        assert len(lines) >= 2\n        return lines[2]\n\n    @staticmethod\n    def _get_summary_lines(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        return '\\n'.join(lines[2:])\n\n    # these should include \"self\"\n    def test_unbound_python_method(self):\n        self.assertEqual(self._get_summary_line(textwrap.TextWrapper.wrap),\n            \"wrap(self, text)\")\n\n    @requires_docstrings\n    def test_unbound_builtin_method(self):\n        self.assertEqual(self._get_summary_line(_pickle.Pickler.dump),\n            \"dump(self, obj, /)\")\n\n    # these no longer include \"self\"\n    def test_bound_python_method(self):\n        t = textwrap.TextWrapper()\n        self.assertEqual(self._get_summary_line(t.wrap),\n            \"wrap(text) method of textwrap.TextWrapper instance\")\n    def test_field_order_for_named_tuples(self):\n        Person = namedtuple('Person', ['nickname', 'firstname', 'agegroup'])\n        s = pydoc.render_doc(Person)\n        self.assertLess(s.index('nickname'), s.index('firstname'))\n        self.assertLess(s.index('firstname'), s.index('agegroup'))\n\n        class NonIterableFields:\n            _fields = None\n\n        class NonHashableFields:\n            _fields = [[]]\n\n        # Make sure these doesn't fail\n        pydoc.render_doc(NonIterableFields)\n        pydoc.render_doc(NonHashableFields)\n\n    @requires_docstrings\n    def test_bound_builtin_method(self):\n        s = StringIO()\n        p = _pickle.Pickler(s)\n        self.assertEqual(self._get_summary_line(p.dump),\n            \"dump(obj, /) method of _pickle.Pickler instance\")\n\n    # this should *never* include self!\n    @requires_docstrings\n    def test_module_level_callable(self):\n        self.assertEqual(self._get_summary_line(os.stat),\n            \"stat(path, *, dir_fd=None, follow_symlinks=True)\")\n\n    @requires_docstrings\n    def test_staticmethod(self):\n        class X:\n            @staticmethod\n            def sm(x, y):\n                '''A static method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['sm']),\n                         \"<staticmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.sm), \"\"\"\\\nsm(x, y)\n    A static method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Static methods defined here:\n |\\x20\\x20\n |  sm(x, y)\n |      A static method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_classmethod(self):\n        class X:\n            @classmethod\n            def cm(cls, x):\n                '''A class method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['cm']),\n                         \"<classmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.cm), \"\"\"\\\ncm(x) method of builtins.type instance\n    A class method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Class methods defined here:\n |\\x20\\x20\n |  cm(x) from builtins.type\n |      A class method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_getset_descriptor(self):\n        # Currently these attributes are implemented as getset descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(int.numerator), \"numerator\")\n        self.assertEqual(self._get_summary_line(float.real), \"real\")\n        self.assertEqual(self._get_summary_line(Exception.args), \"args\")\n        self.assertEqual(self._get_summary_line(memoryview.obj), \"obj\")\n\n    @requires_docstrings\n    def test_member_descriptor(self):\n        # Currently these attributes are implemented as member descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(complex.real), \"real\")\n        self.assertEqual(self._get_summary_line(range.start), \"start\")\n        self.assertEqual(self._get_summary_line(slice.start), \"start\")\n        self.assertEqual(self._get_summary_line(property.fget), \"fget\")\n        self.assertEqual(self._get_summary_line(StopIteration.value), \"value\")\n\n    @requires_docstrings\n    def test_slot_descriptor(self):\n        class Point:\n            __slots__ = 'x', 'y'\n        self.assertEqual(self._get_summary_line(Point.x), \"x\")\n\n    @requires_docstrings\n    def test_dict_attr_descriptor(self):\n        class NS:\n            pass\n        self.assertEqual(self._get_summary_line(NS.__dict__['__dict__']),\n                         \"__dict__\")\n\n    @requires_docstrings\n    def test_structseq_member_descriptor(self):\n        self.assertEqual(self._get_summary_line(type(sys.hash_info).width),\n                         \"width\")\n        self.assertEqual(self._get_summary_line(type(sys.flags).debug),\n                         \"debug\")\n        self.assertEqual(self._get_summary_line(type(sys.version_info).major),\n                         \"major\")\n        self.assertEqual(self._get_summary_line(type(sys.float_info).max),\n                         \"max\")\n\n    @requires_docstrings\n    def test_namedtuple_field_descriptor(self):\n        Box = namedtuple('Box', ('width', 'height'))\n        self.assertEqual(self._get_summary_lines(Box.width), \"\"\"\\\n    Alias for field number 0\n\"\"\")\n\n    @requires_docstrings\n    def test_property(self):\n        class Rect:\n            @property\n            def area(self):\n                '''Area of the rect'''\n                return self.w * self.h\n\n        self.assertEqual(self._get_summary_lines(Rect.area), \"\"\"\\\n    Area of the rect\n\"\"\")\n        self.assertIn(\"\"\"\n |  area\n |      Area of the rect\n\"\"\", pydoc.plain(pydoc.render_doc(Rect)))\n\n    @requires_docstrings\n    def test_custom_non_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\"\"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo(...)\n    Custom descriptor\n\"\"\")\n\n    @requires_docstrings\n    def test_custom_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n            def __set__(self, obj, cls):\n                1/0\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo\n    Custom descriptor\n\"\"\")\n\n    def test_async_annotation(self):\n        async def coro_function(ign) -> int:\n            return 1\n\n        text = pydoc.plain(pydoc.plaintext.document(coro_function))\n        self.assertIn('async coro_function', text)\n\n        html = pydoc.HTMLDoc().document(coro_function)\n        self.assertIn(\n            'async <a name=\"-coro_function\"><strong>coro_function',\n            html)\n\n    def test_async_generator_annotation(self):\n        async def an_async_generator():\n            yield 1\n\n        text = pydoc.plain(pydoc.plaintext.document(an_async_generator))\n        self.assertIn('async an_async_generator', text)\n\n        html = pydoc.HTMLDoc().document(an_async_generator)\n        self.assertIn(\n            'async <a name=\"-an_async_generator\"><strong>an_async_generator',\n            html)\n\n    def test_html_for_https_links(self):\n        def a_fn_with_https_link():\n            \"\"\"a link https://localhost/\"\"\"\n            pass\n\n        html = pydoc.HTMLDoc().document(a_fn_with_https_link)\n        self.assertIn(\n            '<a href=\"https://localhost/\">https://localhost/</a>',\n            html\n        )", "target": 0}, {"function": "class PydocServerTest(unittest.TestCase):\n    \"\"\"Tests for pydoc._start_server\"\"\"\n\n    def test_server(self):\n\n        # Minimal test that starts the server, then stops it.\n        def my_url_handler(url, content_type):\n            text = 'the URL sent was: (%s, %s)' % (url, content_type)\n            return text\n\n        serverthread = pydoc._start_server(my_url_handler, hostname='0.0.0.0', port=0)\n        self.assertIn('0.0.0.0', serverthread.docserver.address)\n\n        starttime = time.monotonic()\n        timeout = test.support.SHORT_TIMEOUT\n\n        while serverthread.serving:\n            time.sleep(.01)\n            if serverthread.serving and time.monotonic() - starttime > timeout:\n                serverthread.stop()\n                break\n\n        self.assertEqual(serverthread.error, None)", "target": 0}, {"function": "class PydocUrlHandlerTest(PydocBaseTest):\n    \"\"\"Tests for pydoc._url_handler\"\"\"\n\n    def test_content_type_err(self):\n        f = pydoc._url_handler\n        self.assertRaises(TypeError, f, 'A', '')\n        self.assertRaises(TypeError, f, 'B', 'foobar')\n\n    def test_url_requests(self):\n        # Test for the correct title in the html pages returned.\n        # This tests the different parts of the URL handler without\n        # getting too picky about the exact html.\n        requests = [\n            (\"\", \"Pydoc: Index of Modules\"),\n            (\"get?key=\", \"Pydoc: Index of Modules\"),\n            (\"index\", \"Pydoc: Index of Modules\"),\n            (\"topics\", \"Pydoc: Topics\"),\n            (\"keywords\", \"Pydoc: Keywords\"),\n            (\"pydoc\", \"Pydoc: module pydoc\"),\n            (\"get?key=pydoc\", \"Pydoc: module pydoc\"),\n            (\"search?key=pydoc\", \"Pydoc: Search Results\"),\n            (\"topic?key=def\", \"Pydoc: KEYWORD def\"),\n            (\"topic?key=STRINGS\", \"Pydoc: TOPIC STRINGS\"),\n            (\"foobar\", \"Pydoc: Error - foobar\"),\n            (\"getfile?key=foobar\", \"Pydoc: Error - getfile?key=foobar\"),\n            ]\n\n        with self.restrict_walk_packages():\n            for url, title in requests:\n                self.call_url_handler(url, title)\n\n            path = string.__file__\n            title = \"Pydoc: getfile \" + path\n            url = \"getfile?key=\" + path\n            self.call_url_handler(url, title)", "target": 0}, {"function": "class TestHelper(unittest.TestCase):\n    def test_keywords(self):\n        self.assertEqual(sorted(pydoc.Helper.keywords),\n                         sorted(keyword.kwlist))", "target": 0}, {"function": "class PydocWithMetaClasses(unittest.TestCase):\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_DynamicClassAttribute(self):\n        class Meta(type):\n            def __getattr__(self, name):\n                if name == 'ham':\n                    return 'spam'\n                return super().__getattr__(name)\n        class DA(metaclass=Meta):\n            @types.DynamicClassAttribute\n            def ham(self):\n                return 'eggs'\n        expected_text_data_docstrings = tuple('\\n |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(DA)\n        expected_text = expected_dynamicattribute_pattern % (\n                (__name__,) + expected_text_data_docstrings[:2])\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithOneMeta(self):\n        class Meta(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'LIFE']\n            def __getattr__(self, name):\n                if name =='LIFE':\n                    return 42\n                return super().__getattr(name)\n        class Class(metaclass=Meta):\n            pass\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class)\n        expected_text = expected_virtualattribute_pattern1 % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithTwoMeta(self):\n        class Meta1(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'one']\n            def __getattr__(self, name):\n                if name =='one':\n                    return 1\n                return super().__getattr__(name)\n        class Meta2(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'two']\n            def __getattr__(self, name):\n                if name =='two':\n                    return 2\n                return super().__getattr__(name)\n        class Meta3(Meta1, Meta2):\n            def __dir__(cls):\n                return list(sorted(set(\n                    ['__class__', '__module__', '__name__', 'three'] +\n                    Meta1.__dir__(cls) + Meta2.__dir__(cls))))\n            def __getattr__(self, name):\n                if name =='three':\n                    return 3\n                return super().__getattr__(name)\n        class Class1(metaclass=Meta1):\n            pass\n        class Class2(Class1, metaclass=Meta3):\n            pass\n        fail1 = fail2 = False\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class1)\n        expected_text1 = expected_virtualattribute_pattern2 % __name__\n        result1 = output.getvalue().strip()\n        self.assertEqual(expected_text1, result1)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class2)\n        expected_text2 = expected_virtualattribute_pattern3 % __name__\n        result2 = output.getvalue().strip()\n        self.assertEqual(expected_text2, result2)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_buggy_dir(self):\n        class M(type):\n            def __dir__(cls):\n                return ['__class__', '__name__', 'missing', 'here']\n        class C(metaclass=M):\n            here = 'present!'\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(C)\n        expected_text = expected_missingattribute_pattern % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    def test_resolve_false(self):\n        # Issue #23008: pydoc enum.{,Int}Enum failed\n        # because bool(enum.Enum) is False.\n        with captured_stdout() as help_io:\n            pydoc.help('enum.Enum')\n        helptext = help_io.getvalue()\n        self.assertIn('class Enum', helptext)", "target": 0}, {"function": "class TestInternalUtilities(unittest.TestCase):\n\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.argv0dir = tmpdir.name\n        self.argv0 = os.path.join(tmpdir.name, \"nonexistent\")\n        self.addCleanup(tmpdir.cleanup)\n        self.abs_curdir = abs_curdir = os.getcwd()\n        self.curdir_spellings = [\"\", os.curdir, abs_curdir]\n\n    def _get_revised_path(self, given_path, argv0=None):\n        # Checking that pydoc.cli() actually calls pydoc._get_revised_path()\n        # is handled via code review (at least for now).\n        if argv0 is None:\n            argv0 = self.argv0\n        return pydoc._get_revised_path(given_path, argv0)\n\n    def _get_starting_path(self):\n        # Get a copy of sys.path without the current directory.\n        clean_path = sys.path.copy()\n        for spelling in self.curdir_spellings:\n            for __ in range(clean_path.count(spelling)):\n                clean_path.remove(spelling)\n        return clean_path\n\n    def test_sys_path_adjustment_adds_missing_curdir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        self.assertEqual(self._get_revised_path(clean_path), expected_path)\n\n    def test_sys_path_adjustment_removes_argv0_dir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        leading_argv0dir = [self.argv0dir] + clean_path\n        self.assertEqual(self._get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        self.assertEqual(self._get_revised_path(trailing_argv0dir), expected_path)\n\n\n    def test_sys_path_adjustment_protects_pydoc_dir(self):\n        def _get_revised_path(given_path):\n            return self._get_revised_path(given_path, argv0=pydoc.__file__)\n        clean_path = self._get_starting_path()\n        leading_argv0dir = [self.argv0dir] + clean_path\n        expected_path = [self.abs_curdir] + leading_argv0dir\n        self.assertEqual(_get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        expected_path = [self.abs_curdir] + trailing_argv0dir\n        self.assertEqual(_get_revised_path(trailing_argv0dir), expected_path)\n\n    def test_sys_path_adjustment_when_curdir_already_included(self):\n        clean_path = self._get_starting_path()\n        for spelling in self.curdir_spellings:\n            with self.subTest(curdir_spelling=spelling):\n                # If curdir is already present, no alterations are made at all\n                leading_curdir = [spelling] + clean_path\n                self.assertIsNone(self._get_revised_path(leading_curdir))\n                trailing_curdir = clean_path + [spelling]\n                self.assertIsNone(self._get_revised_path(trailing_curdir))\n                leading_argv0dir = [self.argv0dir] + leading_curdir\n                self.assertIsNone(self._get_revised_path(leading_argv0dir))\n                trailing_argv0dir = trailing_curdir + [self.argv0dir]\n                self.assertIsNone(self._get_revised_path(trailing_argv0dir))", "target": 0}], "function_after": [{"function": "class nonascii:\n    '\u0426\u0435 \u043d\u0435 \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044f'\n    pass", "target": 0}, {"function": "def run_pydoc(module_name, *args, **env):\n    \"\"\"\n    Runs pydoc on the specified module. Returns the stripped\n    output of pydoc.\n    \"\"\"\n    args = args + (module_name,)\n    # do not write bytecode files to avoid caching errors\n    rc, out, err = assert_python_ok('-B', pydoc.__file__, *args, **env)\n    return out.strip()", "target": 0}, {"function": "def get_pydoc_html(module):\n    \"Returns pydoc generated output as html\"\n    doc = pydoc.HTMLDoc()\n    output = doc.docmodule(module)\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"<br><a href=\\\"\" + loc + \"\\\">Module Docs</a>\"\n    return output.strip(), loc", "target": 0}, {"function": "def get_pydoc_link(module):\n    \"Returns a documentation web link of a module\"\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    basedir = dirname(dirname(abspath(__file__)))\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(module, basedir=basedir)\n    return loc", "target": 0}, {"function": "def get_pydoc_text(module):\n    \"Returns pydoc generated output as text\"\n    doc = pydoc.TextDoc()\n    loc = doc.getdocloc(pydoc_mod) or \"\"\n    if loc:\n        loc = \"\\nMODULE DOCS\\n    \" + loc + \"\\n\"\n\n    output = doc.docmodule(module)\n\n    # clean up the extra text formatting that pydoc performs\n    patt = re.compile('\\b.')\n    output = patt.sub('', output)\n    return output.strip(), loc", "target": 0}, {"function": "def get_html_title(text):\n    # Bit of hack, but good enough for test purposes\n    header, _, _ = text.partition(\"</head>\")\n    _, _, title = header.partition(\"<title>\")\n    title, _, _ = title.partition(\"</title>\")\n    return title", "target": 0}, {"function": "class PydocBaseTest(unittest.TestCase):\n\n    def _restricted_walk_packages(self, walk_packages, path=None):\n        \"\"\"\n        A version of pkgutil.walk_packages() that will restrict itself to\n        a given path.\n        \"\"\"\n        default_path = path or [os.path.dirname(__file__)]\n        def wrapper(path=None, prefix='', onerror=None):\n            return walk_packages(path or default_path, prefix, onerror)\n        return wrapper\n\n    @contextlib.contextmanager\n    def restrict_walk_packages(self, path=None):\n        walk_packages = pkgutil.walk_packages\n        pkgutil.walk_packages = self._restricted_walk_packages(walk_packages,\n                                                               path)\n        try:\n            yield\n        finally:\n            pkgutil.walk_packages = walk_packages\n\n    def call_url_handler(self, url, expected_title):\n        text = pydoc._url_handler(url, \"text/html\")\n        result = get_html_title(text)\n        # Check the title to ensure an unexpected error page was not returned\n        self.assertEqual(result, expected_title, text)\n        return text", "target": 0}, {"function": "class PydocDocTest(unittest.TestCase):\n    maxDiff = None\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_html_doc(self):\n        result, doc_loc = get_pydoc_html(pydoc_mod)\n        mod_file = inspect.getabsfile(pydoc_mod)\n        mod_url = urllib.parse.quote(mod_file)\n        expected_html = expected_html_pattern % (\n                        (mod_url, mod_file, doc_loc) +\n                        expected_html_data_docstrings)\n        self.assertEqual(result, expected_html)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_text_doc(self):\n        result, doc_loc = get_pydoc_text(pydoc_mod)\n        expected_text = expected_text_pattern % (\n                        (doc_loc,) +\n                        expected_text_data_docstrings +\n                        (inspect.getabsfile(pydoc_mod),))\n        self.assertEqual(expected_text, result)\n\n    def test_text_enum_member_with_value_zero(self):\n        # Test issue #20654 to ensure enum member with value 0 can be\n        # displayed. It used to throw KeyError: 'zero'.\n        import enum\n        class BinaryInteger(enum.IntEnum):\n            zero = 0\n            one = 1\n        doc = pydoc.render_doc(BinaryInteger)\n        self.assertIn('<BinaryInteger.zero: 0>', doc)\n\n    def test_mixed_case_module_names_are_lower_cased(self):\n        # issue16484\n        doc_link = get_pydoc_link(xml.etree.ElementTree)\n        self.assertIn('xml.etree.elementtree', doc_link)\n\n    def test_issue8225(self):\n        # Test issue8225 to ensure no doc link appears for xml.etree\n        result, doc_loc = get_pydoc_text(xml.etree)\n        self.assertEqual(doc_loc, \"\", \"MODULE DOCS incorrectly includes a link\")\n\n    def test_getpager_with_stdin_none(self):\n        previous_stdin = sys.stdin\n        try:\n            sys.stdin = None\n            pydoc.getpager() # Shouldn't fail.\n        finally:\n            sys.stdin = previous_stdin\n\n    def test_non_str_name(self):\n        # issue14638\n        # Treat illegal (non-str) name like no name\n\n        class A:\n            __name__ = 42\n        class B:\n            pass\n        adoc = pydoc.render_doc(A())\n        bdoc = pydoc.render_doc(B())\n        self.assertEqual(adoc.replace(\"A\", \"B\"), bdoc)\n\n    def test_not_here(self):\n        missing_module = \"test.i_am_not_here\"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module\n        self.assertEqual(expected, result,\n            \"documentation for missing module found\")\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_not_ascii(self):\n        result = run_pydoc('test.test_pydoc.nonascii', PYTHONIOENCODING='ascii')\n        encoded = nonascii.__doc__.encode('ascii', 'backslashreplace')\n        self.assertIn(encoded, result)\n\n    def test_input_strip(self):\n        missing_module = \" test.i_am_not_here \"\n        result = str(run_pydoc(missing_module), 'ascii')\n        expected = missing_pattern % missing_module.strip()\n        self.assertEqual(expected, result)\n\n    def test_stripid(self):\n        # test with strings, other implementations might have different repr()\n        stripid = pydoc.stripid\n        # strip the id\n        self.assertEqual(stripid('<function stripid at 0x88dcee4>'),\n                         '<function stripid>')\n        self.assertEqual(stripid('<function stripid at 0x01F65390>'),\n                         '<function stripid>')\n        # nothing to strip, return the same text\n        self.assertEqual(stripid('42'), '42')\n        self.assertEqual(stripid(\"<type 'exceptions.Exception'>\"),\n                         \"<type 'exceptions.Exception'>\")\n\n    def test_builtin_with_more_than_four_children(self):\n        \"\"\"Tests help on builtin object which have more than four child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section and only 4 classes\n        should be displayed with a hint on how many more subclasses are present.\n        For example:\n\n        >>> help(object)\n        Help on class object in module builtins:\n\n        class object\n         |  The most base type\n         |\n         |  Built-in subclasses:\n         |      async_generator\n         |      BaseException\n         |      builtin_function_or_method\n         |      bytearray\n         |      ... and 82 other subclasses\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(object)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      async_generator\\n\"\n                \" |      BaseException\\n\"\n                \" |      builtin_function_or_method\\n\"\n                \" |      bytearray\\n\"\n                \" |      ... and \\\\d+ other subclasses\")\n        self.assertRegex(text, snip)\n\n    def test_builtin_with_child(self):\n        \"\"\"Tests help on builtin object which have only child classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. For example:\n\n        >>> help(ArithmeticError)\n        Help on class ArithmeticError in module builtins:\n\n        class ArithmeticError(Exception)\n         |  Base class for arithmetic errors.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      FloatingPointError\n         |      OverflowError\n         |      ZeroDivisionError\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ArithmeticError)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      FloatingPointError\\n\"\n                \" |      OverflowError\\n\"\n                \" |      ZeroDivisionError\")\n        self.assertIn(snip, text)\n\n    def test_builtin_with_grandchild(self):\n        \"\"\"Tests help on builtin classes which have grandchild classes.\n\n        When running help() on a builtin class which has child classes, it\n        should contain a \"Built-in subclasses\" section. However, if it also has\n        grandchildren, these should not show up on the subclasses section.\n        For example:\n\n        >>> help(Exception)\n        Help on class Exception in module builtins:\n\n        class Exception(BaseException)\n         |  Common base class for all non-exit exceptions.\n         |\n         ...\n         |\n         |  Built-in subclasses:\n         |      ArithmeticError\n         |      AssertionError\n         |      AttributeError\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(Exception)\n        snip = (\" |  Built-in subclasses:\\n\"\n                \" |      ArithmeticError\\n\"\n                \" |      AssertionError\\n\"\n                \" |      AttributeError\")\n        self.assertIn(snip, text)\n        # Testing that the grandchild ZeroDivisionError does not show up\n        self.assertNotIn('ZeroDivisionError', text)\n\n    def test_builtin_no_child(self):\n        \"\"\"Tests help on builtin object which have no child classes.\n\n        When running help() on a builtin class which has no child classes, it\n        should not contain any \"Built-in subclasses\" section. For example:\n\n        >>> help(ZeroDivisionError)\n\n        Help on class ZeroDivisionError in module builtins:\n\n        class ZeroDivisionError(ArithmeticError)\n         |  Second argument to a division or modulo operation was zero.\n         |\n         |  Method resolution order:\n         |      ZeroDivisionError\n         |      ArithmeticError\n         |      Exception\n         |      BaseException\n         |      object\n         |\n         |  Methods defined here:\n         ...\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(ZeroDivisionError)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    def test_builtin_on_metaclasses(self):\n        \"\"\"Tests help on metaclasses.\n\n        When running help() on a metaclasses such as type, it\n        should not contain any \"Built-in subclasses\" section.\n        \"\"\"\n        doc = pydoc.TextDoc()\n        text = doc.docclass(type)\n        # Testing that the subclasses section does not appear\n        self.assertNotIn('Built-in subclasses', text)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -O2 and above')\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    @requires_docstrings\n    def test_help_output_redirect(self):\n        # issue 940286, if output is set in Helper, then all output from\n        # Helper.help should be redirected\n        old_pattern = expected_text_pattern\n        getpager_old = pydoc.getpager\n        getpager_new = lambda: (lambda x: x)\n        self.maxDiff = None\n\n        buf = StringIO()\n        helper = pydoc.Helper(output=buf)\n        unused, doc_loc = get_pydoc_text(pydoc_mod)\n        module = \"test.pydoc_mod\"\n        help_header = \"\"\"\n        Help on module test.pydoc_mod in test:\n\n        \"\"\".lstrip()\n        help_header = textwrap.dedent(help_header)\n        expected_help_pattern = help_header + expected_text_pattern\n\n        pydoc.getpager = getpager_new\n        try:\n            with captured_output('stdout') as output, \\\n                 captured_output('stderr') as err:\n                helper.help(module)\n                result = buf.getvalue().strip()\n                expected_text = expected_help_pattern % (\n                                (doc_loc,) +\n                                expected_text_data_docstrings +\n                                (inspect.getabsfile(pydoc_mod),))\n                self.assertEqual('', output.getvalue())\n                self.assertEqual('', err.getvalue())\n                self.assertEqual(expected_text, result)\n        finally:\n            pydoc.getpager = getpager_old\n\n    def test_namedtuple_fields(self):\n        Person = namedtuple('Person', ['nickname', 'firstname'])\n        with captured_stdout() as help_io:\n            pydoc.help(Person)\n        helptext = help_io.getvalue()\n        self.assertIn(\"nickname\", helptext)\n        self.assertIn(\"firstname\", helptext)\n        self.assertIn(\"Alias for field number 0\", helptext)\n        self.assertIn(\"Alias for field number 1\", helptext)\n\n    def test_namedtuple_public_underscore(self):\n        NT = namedtuple('NT', ['abc', 'def'], rename=True)\n        with captured_stdout() as help_io:\n            pydoc.help(NT)\n        helptext = help_io.getvalue()\n        self.assertIn('_1', helptext)\n        self.assertIn('_replace', helptext)\n        self.assertIn('_asdict', helptext)\n\n    def test_synopsis(self):\n        self.addCleanup(unlink, TESTFN)\n        for encoding in ('ISO-8859-1', 'UTF-8'):\n            with open(TESTFN, 'w', encoding=encoding) as script:\n                if encoding != 'UTF-8':\n                    print('#coding: {}'.format(encoding), file=script)\n                print('\"\"\"line 1: h\\xe9', file=script)\n                print('line 2: hi\"\"\"', file=script)\n            synopsis = pydoc.synopsis(TESTFN, {})\n            self.assertEqual(synopsis, 'line 1: h\\xe9')\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     'Docstrings are omitted with -OO and above')\n    def test_synopsis_sourceless(self):\n        expected = os.__doc__.splitlines()[0]\n        filename = os.__cached__\n        synopsis = pydoc.synopsis(filename)\n\n        self.assertEqual(synopsis, expected)\n\n    def test_synopsis_sourceless_empty_doc(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, 'foomod42.py')\n            cached_path = importlib.util.cache_from_source(init_path)\n            with open(init_path, 'w') as fobj:\n                fobj.write(\"foo = 1\")\n            py_compile.compile(init_path)\n            synopsis = pydoc.synopsis(init_path, {})\n            self.assertIsNone(synopsis)\n            synopsis_cached = pydoc.synopsis(cached_path, {})\n            self.assertIsNone(synopsis_cached)\n\n    def test_splitdoc_with_description(self):\n        example_string = \"I Am A Doc\\n\\n\\nHere is my description\"\n        self.assertEqual(pydoc.splitdoc(example_string),\n                         ('I Am A Doc', '\\nHere is my description'))\n\n    def test_is_package_when_not_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            self.assertFalse(pydoc.ispackage(test_dir))\n\n    def test_is_package_when_is_package(self):\n        with os_helper.temp_cwd() as test_dir:\n            init_path = os.path.join(test_dir, '__init__.py')\n            open(init_path, 'w').close()\n            self.assertTrue(pydoc.ispackage(test_dir))\n            os.remove(init_path)\n\n    def test_allmethods(self):\n        # issue 17476: allmethods was no longer returning unbound methods.\n        # This test is a bit fragile in the face of changes to object and type,\n        # but I can't think of a better way to do it without duplicating the\n        # logic of the function under test.\n\n        class TestClass(object):\n            def method_returning_true(self):\n                return True\n\n        # What we expect to get back: everything on object...\n        expected = dict(vars(object))\n        # ...plus our unbound method...\n        expected['method_returning_true'] = TestClass.method_returning_true\n        # ...but not the non-methods on object.\n        del expected['__doc__']\n        del expected['__class__']\n        # inspect resolves descriptors on type into methods, but vars doesn't,\n        # so we need to update __subclasshook__ and __init_subclass__.\n        expected['__subclasshook__'] = TestClass.__subclasshook__\n        expected['__init_subclass__'] = TestClass.__init_subclass__\n\n        methods = pydoc.allmethods(TestClass)\n        self.assertDictEqual(methods, expected)\n\n    def test_method_aliases(self):\n        class A:\n            def tkraise(self, aboveThis=None):\n                \"\"\"Raise this widget in the stacking order.\"\"\"\n            lift = tkraise\n            def a_size(self):\n                \"\"\"Return size\"\"\"\n        class B(A):\n            def itemconfigure(self, tagOrId, cnf=None, **kw):\n                \"\"\"Configure resources of an item TAGORID.\"\"\"\n            itemconfig = itemconfigure\n            b_size = A.a_size\n\n        doc = pydoc.render_doc(B)\n        # clean up the extra text formatting that pydoc performs\n        doc = re.sub('\\b.', '', doc)\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\nclass B(A)\n |  Method resolution order:\n |      B\n |      A\n |      builtins.object\n |\\x20\\x20\n |  Methods defined here:\n |\\x20\\x20\n |  b_size = a_size(self)\n |\\x20\\x20\n |  itemconfig = itemconfigure(self, tagOrId, cnf=None, **kw)\n |\\x20\\x20\n |  itemconfigure(self, tagOrId, cnf=None, **kw)\n |      Configure resources of an item TAGORID.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Methods inherited from A:\n |\\x20\\x20\n |  a_size(self)\n |      Return size\n |\\x20\\x20\n |  lift = tkraise(self, aboveThis=None)\n |\\x20\\x20\n |  tkraise(self, aboveThis=None)\n |      Raise this widget in the stacking order.\n |\\x20\\x20\n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from A:\n |\\x20\\x20\n |  __dict__\n |      dictionary for instance variables (if defined)\n |\\x20\\x20\n |  __weakref__\n |      list of weak references to the object (if defined)\n''' % __name__)\n\n        doc = pydoc.render_doc(B, renderer=pydoc.HTMLDoc())\n        self.assertEqual(doc, '''\\\nPython Library Documentation: class B in module %s\n\n<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"#ffc8d8\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"#000000\" face=\"helvetica, arial\"><a name=\"B\">class <strong>B</strong></a>(A)</font></td></tr>\n\\x20\\x20\\x20\\x20\n<tr><td bgcolor=\"#ffc8d8\"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>\n<td width=\"100%%\"><dl><dt>Method resolution order:</dt>\n<dd>B</dd>\n<dd>A</dd>\n<dd><a href=\"builtins.html#object\">builtins.object</a></dd>\n</dl>\n<hr>\nMethods defined here:<br>\n<dl><dt><a name=\"B-b_size\"><strong>b_size</strong></a> = <a href=\"#B-a_size\">a_size</a>(self)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfig\"><strong>itemconfig</strong></a> = <a href=\"#B-itemconfigure\">itemconfigure</a>(self, tagOrId, cnf=None, **kw)</dt></dl>\n\n<dl><dt><a name=\"B-itemconfigure\"><strong>itemconfigure</strong></a>(self, tagOrId, cnf=None, **kw)</dt><dd><tt>Configure&nbsp;resources&nbsp;of&nbsp;an&nbsp;item&nbsp;TAGORID.</tt></dd></dl>\n\n<hr>\nMethods inherited from A:<br>\n<dl><dt><a name=\"B-a_size\"><strong>a_size</strong></a>(self)</dt><dd><tt>Return&nbsp;size</tt></dd></dl>\n\n<dl><dt><a name=\"B-lift\"><strong>lift</strong></a> = <a href=\"#B-tkraise\">tkraise</a>(self, aboveThis=None)</dt></dl>\n\n<dl><dt><a name=\"B-tkraise\"><strong>tkraise</strong></a>(self, aboveThis=None)</dt><dd><tt>Raise&nbsp;this&nbsp;widget&nbsp;in&nbsp;the&nbsp;stacking&nbsp;order.</tt></dd></dl>\n\n<hr>\nData descriptors inherited from A:<br>\n<dl><dt><strong>__dict__</strong></dt>\n<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n<dl><dt><strong>__weakref__</strong></dt>\n<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>\n</dl>\n</td></tr></table>\\\n''' % __name__)", "target": 0}, {"function": "class PydocImportTest(PydocBaseTest):\n\n    def setUp(self):\n        self.test_dir = os.mkdir(TESTFN)\n        self.addCleanup(rmtree, TESTFN)\n        importlib.invalidate_caches()\n\n    def test_badimport(self):\n        # This tests the fix for issue 5230, where if pydoc found the module\n        # but the module had an internal import error pydoc would report no doc\n        # found.\n        modname = 'testmod_xyzzy'\n        testpairs = (\n            ('i_am_not_here', 'i_am_not_here'),\n            ('test.i_am_not_here_either', 'test.i_am_not_here_either'),\n            ('test.i_am_not_here.neither_am_i', 'test.i_am_not_here'),\n            ('i_am_not_here.{}'.format(modname), 'i_am_not_here'),\n            ('test.{}'.format(modname), 'test.{}'.format(modname)),\n            )\n\n        sourcefn = os.path.join(TESTFN, modname) + os.extsep + \"py\"\n        for importstring, expectedinmsg in testpairs:\n            with open(sourcefn, 'w') as f:\n                f.write(\"import {}\\n\".format(importstring))\n            result = run_pydoc(modname, PYTHONPATH=TESTFN).decode(\"ascii\")\n            expected = badimport_pattern % (modname, expectedinmsg)\n            self.assertEqual(expected, result)\n\n    def test_apropos_with_bad_package(self):\n        # Issue 7425 - pydoc -k failed when bad package on path\n        pkgdir = os.path.join(TESTFN, \"syntaxerr\")\n        os.mkdir(pkgdir)\n        badsyntax = os.path.join(pkgdir, \"__init__\") + os.extsep + \"py\"\n        with open(badsyntax, 'w') as f:\n            f.write(\"invalid python syntax = $1\\n\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('xyzzy')\n            # No result, no error\n            self.assertEqual(out.getvalue(), '')\n            self.assertEqual(err.getvalue(), '')\n            # The package name is still matched\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('syntaxerr')\n            self.assertEqual(out.getvalue().strip(), 'syntaxerr')\n            self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_with_unreadable_dir(self):\n        # Issue 7367 - pydoc -k failed when unreadable dir on path\n        self.unreadable_dir = os.path.join(TESTFN, \"unreadable\")\n        os.mkdir(self.unreadable_dir, 0)\n        self.addCleanup(os.rmdir, self.unreadable_dir)\n        # Note, on Windows the directory appears to be still\n        #   readable so this is not really testing the issue there\n        with self.restrict_walk_packages(path=[TESTFN]):\n            with captured_stdout() as out:\n                with captured_stderr() as err:\n                    pydoc.apropos('SOMEKEY')\n        # No result, no error\n        self.assertEqual(out.getvalue(), '')\n        self.assertEqual(err.getvalue(), '')\n\n    def test_apropos_empty_doc(self):\n        pkgdir = os.path.join(TESTFN, 'walkpkg')\n        os.mkdir(pkgdir)\n        self.addCleanup(rmtree, pkgdir)\n        init_path = os.path.join(pkgdir, '__init__.py')\n        with open(init_path, 'w') as fobj:\n            fobj.write(\"foo = 1\")\n        current_mode = stat.S_IMODE(os.stat(pkgdir).st_mode)\n        try:\n            os.chmod(pkgdir, current_mode & ~stat.S_IEXEC)\n            with self.restrict_walk_packages(path=[TESTFN]), captured_stdout() as stdout:\n                pydoc.apropos('')\n            self.assertIn('walkpkg', stdout.getvalue())\n        finally:\n            os.chmod(pkgdir, current_mode)\n\n    def test_url_search_package_error(self):\n        # URL handler search should cope with packages that raise exceptions\n        pkgdir = os.path.join(TESTFN, \"test_error_package\")\n        os.mkdir(pkgdir)\n        init = os.path.join(pkgdir, \"__init__.py\")\n        with open(init, \"wt\", encoding=\"ascii\") as f:\n            f.write(\"\"\"raise ValueError(\"ouch\")\\n\"\"\")\n        with self.restrict_walk_packages(path=[TESTFN]):\n            # Package has to be importable for the error to have any effect\n            saved_paths = tuple(sys.path)\n            sys.path.insert(0, TESTFN)\n            try:\n                with self.assertRaisesRegex(ValueError, \"ouch\"):\n                    import test_error_package  # Sanity check\n\n                text = self.call_url_handler(\"search?key=test_error_package\",\n                    \"Pydoc: Search Results\")\n                found = ('<a href=\"test_error_package.html\">'\n                    'test_error_package</a>')\n                self.assertIn(found, text)\n            finally:\n                sys.path[:] = saved_paths\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules(self):\n        # See Helper.listmodules().\n        num_header_lines = 2\n        num_module_lines_min = 5  # Playing it safe.\n        num_footer_lines = 3\n        expected = num_header_lines + num_module_lines_min + num_footer_lines\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper('modules')\n        result = output.getvalue().strip()\n        num_lines = len(result.splitlines())\n\n        self.assertGreaterEqual(num_lines, expected)\n\n    @unittest.skip('causes undesirable side-effects (#20128)')\n    def test_modules_search(self):\n        # See Helper.listmodules().\n        expected = 'pydoc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules pydoc')\n        result = help_io.getvalue()\n\n        self.assertIn(expected, result)\n\n    @unittest.skip('some buildbots are not cooperating (#20128)')\n    def test_modules_search_builtin(self):\n        expected = 'gc - '\n\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        with captured_stdout() as help_io:\n            helper('modules garbage')\n        result = help_io.getvalue()\n\n        self.assertTrue(result.startswith(expected))\n\n    def test_importfile(self):\n        loaded_pydoc = pydoc.importfile(pydoc.__file__)\n\n        self.assertIsNot(loaded_pydoc, pydoc)\n        self.assertEqual(loaded_pydoc.__name__, 'pydoc')\n        self.assertEqual(loaded_pydoc.__file__, pydoc.__file__)\n        self.assertEqual(loaded_pydoc.__spec__, pydoc.__spec__)", "target": 0}, {"function": "class TestDescriptions(unittest.TestCase):\n\n    def test_module(self):\n        # Check that pydocfodder module can be described\n        from test import pydocfodder\n        doc = pydoc.render_doc(pydocfodder)\n        self.assertIn(\"pydocfodder\", doc)\n\n    def test_class(self):\n        class C: \"New-style class\"\n        c = C()\n\n        self.assertEqual(pydoc.describe(C), 'class C')\n        self.assertEqual(pydoc.describe(c), 'C')\n        expected = 'C in module %s object' % __name__\n        self.assertIn(expected, pydoc.render_doc(c))\n\n    def test_typing_pydoc(self):\n        def foo(data: typing.List[typing.Any],\n                x: int) -> typing.Iterator[typing.Tuple[int, typing.Any]]:\n            ...\n        T = typing.TypeVar('T')\n        class C(typing.Generic[T], typing.Mapping[int, str]): ...\n        self.assertEqual(pydoc.render_doc(foo).splitlines()[-1],\n                         'f\\x08fo\\x08oo\\x08o(data: List[Any], x: int)'\n                         ' -> Iterator[Tuple[int, Any]]')\n        self.assertEqual(pydoc.render_doc(C).splitlines()[2],\n                         'class C\\x08C(collections.abc.Mapping, typing.Generic)')\n\n    def test_builtin(self):\n        for name in ('str', 'str.translate', 'builtins.str',\n                     'builtins.str.translate'):\n            # test low-level function\n            self.assertIsNotNone(pydoc.locate(name))\n            # test high-level function\n            try:\n                pydoc.render_doc(name)\n            except ImportError:\n                self.fail('finding the doc of {!r} failed'.format(name))\n\n        for name in ('notbuiltins', 'strrr', 'strr.translate',\n                     'str.trrrranslate', 'builtins.strrr',\n                     'builtins.str.trrranslate'):\n            self.assertIsNone(pydoc.locate(name))\n            self.assertRaises(ImportError, pydoc.render_doc, name)\n\n    @staticmethod\n    def _get_summary_line(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        assert len(lines) >= 2\n        return lines[2]\n\n    @staticmethod\n    def _get_summary_lines(o):\n        text = pydoc.plain(pydoc.render_doc(o))\n        lines = text.split('\\n')\n        return '\\n'.join(lines[2:])\n\n    # these should include \"self\"\n    def test_unbound_python_method(self):\n        self.assertEqual(self._get_summary_line(textwrap.TextWrapper.wrap),\n            \"wrap(self, text)\")\n\n    @requires_docstrings\n    def test_unbound_builtin_method(self):\n        self.assertEqual(self._get_summary_line(_pickle.Pickler.dump),\n            \"dump(self, obj, /)\")\n\n    # these no longer include \"self\"\n    def test_bound_python_method(self):\n        t = textwrap.TextWrapper()\n        self.assertEqual(self._get_summary_line(t.wrap),\n            \"wrap(text) method of textwrap.TextWrapper instance\")\n    def test_field_order_for_named_tuples(self):\n        Person = namedtuple('Person', ['nickname', 'firstname', 'agegroup'])\n        s = pydoc.render_doc(Person)\n        self.assertLess(s.index('nickname'), s.index('firstname'))\n        self.assertLess(s.index('firstname'), s.index('agegroup'))\n\n        class NonIterableFields:\n            _fields = None\n\n        class NonHashableFields:\n            _fields = [[]]\n\n        # Make sure these doesn't fail\n        pydoc.render_doc(NonIterableFields)\n        pydoc.render_doc(NonHashableFields)\n\n    @requires_docstrings\n    def test_bound_builtin_method(self):\n        s = StringIO()\n        p = _pickle.Pickler(s)\n        self.assertEqual(self._get_summary_line(p.dump),\n            \"dump(obj, /) method of _pickle.Pickler instance\")\n\n    # this should *never* include self!\n    @requires_docstrings\n    def test_module_level_callable(self):\n        self.assertEqual(self._get_summary_line(os.stat),\n            \"stat(path, *, dir_fd=None, follow_symlinks=True)\")\n\n    @requires_docstrings\n    def test_staticmethod(self):\n        class X:\n            @staticmethod\n            def sm(x, y):\n                '''A static method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['sm']),\n                         \"<staticmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.sm), \"\"\"\\\nsm(x, y)\n    A static method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Static methods defined here:\n |\\x20\\x20\n |  sm(x, y)\n |      A static method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_classmethod(self):\n        class X:\n            @classmethod\n            def cm(cls, x):\n                '''A class method'''\n                ...\n        self.assertEqual(self._get_summary_lines(X.__dict__['cm']),\n                         \"<classmethod object>\")\n        self.assertEqual(self._get_summary_lines(X.cm), \"\"\"\\\ncm(x) method of builtins.type instance\n    A class method\n\"\"\")\n        self.assertIn(\"\"\"\n |  Class methods defined here:\n |\\x20\\x20\n |  cm(x) from builtins.type\n |      A class method\n\"\"\", pydoc.plain(pydoc.render_doc(X)))\n\n    @requires_docstrings\n    def test_getset_descriptor(self):\n        # Currently these attributes are implemented as getset descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(int.numerator), \"numerator\")\n        self.assertEqual(self._get_summary_line(float.real), \"real\")\n        self.assertEqual(self._get_summary_line(Exception.args), \"args\")\n        self.assertEqual(self._get_summary_line(memoryview.obj), \"obj\")\n\n    @requires_docstrings\n    def test_member_descriptor(self):\n        # Currently these attributes are implemented as member descriptors\n        # in CPython.\n        self.assertEqual(self._get_summary_line(complex.real), \"real\")\n        self.assertEqual(self._get_summary_line(range.start), \"start\")\n        self.assertEqual(self._get_summary_line(slice.start), \"start\")\n        self.assertEqual(self._get_summary_line(property.fget), \"fget\")\n        self.assertEqual(self._get_summary_line(StopIteration.value), \"value\")\n\n    @requires_docstrings\n    def test_slot_descriptor(self):\n        class Point:\n            __slots__ = 'x', 'y'\n        self.assertEqual(self._get_summary_line(Point.x), \"x\")\n\n    @requires_docstrings\n    def test_dict_attr_descriptor(self):\n        class NS:\n            pass\n        self.assertEqual(self._get_summary_line(NS.__dict__['__dict__']),\n                         \"__dict__\")\n\n    @requires_docstrings\n    def test_structseq_member_descriptor(self):\n        self.assertEqual(self._get_summary_line(type(sys.hash_info).width),\n                         \"width\")\n        self.assertEqual(self._get_summary_line(type(sys.flags).debug),\n                         \"debug\")\n        self.assertEqual(self._get_summary_line(type(sys.version_info).major),\n                         \"major\")\n        self.assertEqual(self._get_summary_line(type(sys.float_info).max),\n                         \"max\")\n\n    @requires_docstrings\n    def test_namedtuple_field_descriptor(self):\n        Box = namedtuple('Box', ('width', 'height'))\n        self.assertEqual(self._get_summary_lines(Box.width), \"\"\"\\\n    Alias for field number 0\n\"\"\")\n\n    @requires_docstrings\n    def test_property(self):\n        class Rect:\n            @property\n            def area(self):\n                '''Area of the rect'''\n                return self.w * self.h\n\n        self.assertEqual(self._get_summary_lines(Rect.area), \"\"\"\\\n    Area of the rect\n\"\"\")\n        self.assertIn(\"\"\"\n |  area\n |      Area of the rect\n\"\"\", pydoc.plain(pydoc.render_doc(Rect)))\n\n    @requires_docstrings\n    def test_custom_non_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\"\"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n<test.test_pydoc.TestDescriptions.test_custom_non_data_descriptor.<locals>.Descr object>\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo(...)\n    Custom descriptor\n\"\"\")\n\n    @requires_docstrings\n    def test_custom_data_descriptor(self):\n        class Descr:\n            def __get__(self, obj, cls):\n                if obj is None:\n                    return self\n                return 42\n            def __set__(self, obj, cls):\n                1/0\n        class X:\n            attr = Descr()\n\n        self.assertEqual(self._get_summary_lines(X.attr), \"\")\n\n        X.attr.__doc__ = 'Custom descriptor'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\n    Custom descriptor\n\"\"\")\n\n        X.attr.__name__ = 'foo'\n        self.assertEqual(self._get_summary_lines(X.attr), \"\"\"\\\nfoo\n    Custom descriptor\n\"\"\")\n\n    def test_async_annotation(self):\n        async def coro_function(ign) -> int:\n            return 1\n\n        text = pydoc.plain(pydoc.plaintext.document(coro_function))\n        self.assertIn('async coro_function', text)\n\n        html = pydoc.HTMLDoc().document(coro_function)\n        self.assertIn(\n            'async <a name=\"-coro_function\"><strong>coro_function',\n            html)\n\n    def test_async_generator_annotation(self):\n        async def an_async_generator():\n            yield 1\n\n        text = pydoc.plain(pydoc.plaintext.document(an_async_generator))\n        self.assertIn('async an_async_generator', text)\n\n        html = pydoc.HTMLDoc().document(an_async_generator)\n        self.assertIn(\n            'async <a name=\"-an_async_generator\"><strong>an_async_generator',\n            html)\n\n    def test_html_for_https_links(self):\n        def a_fn_with_https_link():\n            \"\"\"a link https://localhost/\"\"\"\n            pass\n\n        html = pydoc.HTMLDoc().document(a_fn_with_https_link)\n        self.assertIn(\n            '<a href=\"https://localhost/\">https://localhost/</a>',\n            html\n        )", "target": 0}, {"function": "class PydocServerTest(unittest.TestCase):\n    \"\"\"Tests for pydoc._start_server\"\"\"\n\n    def test_server(self):\n\n        # Minimal test that starts the server, then stops it.\n        def my_url_handler(url, content_type):\n            text = 'the URL sent was: (%s, %s)' % (url, content_type)\n            return text\n\n        serverthread = pydoc._start_server(my_url_handler, hostname='0.0.0.0', port=0)\n        self.assertIn('0.0.0.0', serverthread.docserver.address)\n\n        starttime = time.monotonic()\n        timeout = test.support.SHORT_TIMEOUT\n\n        while serverthread.serving:\n            time.sleep(.01)\n            if serverthread.serving and time.monotonic() - starttime > timeout:\n                serverthread.stop()\n                break\n\n        self.assertEqual(serverthread.error, None)", "target": 0}, {"function": "class PydocUrlHandlerTest(PydocBaseTest):\n    \"\"\"Tests for pydoc._url_handler\"\"\"\n\n    def test_content_type_err(self):\n        f = pydoc._url_handler\n        self.assertRaises(TypeError, f, 'A', '')\n        self.assertRaises(TypeError, f, 'B', 'foobar')\n\n    def test_url_requests(self):\n        # Test for the correct title in the html pages returned.\n        # This tests the different parts of the URL handler without\n        # getting too picky about the exact html.\n        requests = [\n            (\"\", \"Pydoc: Index of Modules\"),\n            (\"get?key=\", \"Pydoc: Index of Modules\"),\n            (\"index\", \"Pydoc: Index of Modules\"),\n            (\"topics\", \"Pydoc: Topics\"),\n            (\"keywords\", \"Pydoc: Keywords\"),\n            (\"pydoc\", \"Pydoc: module pydoc\"),\n            (\"get?key=pydoc\", \"Pydoc: module pydoc\"),\n            (\"search?key=pydoc\", \"Pydoc: Search Results\"),\n            (\"topic?key=def\", \"Pydoc: KEYWORD def\"),\n            (\"topic?key=STRINGS\", \"Pydoc: TOPIC STRINGS\"),\n            (\"foobar\", \"Pydoc: Error - foobar\"),\n            ]\n\n        with self.restrict_walk_packages():\n            for url, title in requests:\n                self.call_url_handler(url, title)", "target": 0}, {"function": "class TestHelper(unittest.TestCase):\n    def test_keywords(self):\n        self.assertEqual(sorted(pydoc.Helper.keywords),\n                         sorted(keyword.kwlist))", "target": 0}, {"function": "class PydocWithMetaClasses(unittest.TestCase):\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_DynamicClassAttribute(self):\n        class Meta(type):\n            def __getattr__(self, name):\n                if name == 'ham':\n                    return 'spam'\n                return super().__getattr__(name)\n        class DA(metaclass=Meta):\n            @types.DynamicClassAttribute\n            def ham(self):\n                return 'eggs'\n        expected_text_data_docstrings = tuple('\\n |      ' + s if s else ''\n                                      for s in expected_data_docstrings)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(DA)\n        expected_text = expected_dynamicattribute_pattern % (\n                (__name__,) + expected_text_data_docstrings[:2])\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithOneMeta(self):\n        class Meta(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'LIFE']\n            def __getattr__(self, name):\n                if name =='LIFE':\n                    return 42\n                return super().__getattr(name)\n        class Class(metaclass=Meta):\n            pass\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class)\n        expected_text = expected_virtualattribute_pattern1 % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_virtualClassAttributeWithTwoMeta(self):\n        class Meta1(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'one']\n            def __getattr__(self, name):\n                if name =='one':\n                    return 1\n                return super().__getattr__(name)\n        class Meta2(type):\n            def __dir__(cls):\n                return ['__class__', '__module__', '__name__', 'two']\n            def __getattr__(self, name):\n                if name =='two':\n                    return 2\n                return super().__getattr__(name)\n        class Meta3(Meta1, Meta2):\n            def __dir__(cls):\n                return list(sorted(set(\n                    ['__class__', '__module__', '__name__', 'three'] +\n                    Meta1.__dir__(cls) + Meta2.__dir__(cls))))\n            def __getattr__(self, name):\n                if name =='three':\n                    return 3\n                return super().__getattr__(name)\n        class Class1(metaclass=Meta1):\n            pass\n        class Class2(Class1, metaclass=Meta3):\n            pass\n        fail1 = fail2 = False\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class1)\n        expected_text1 = expected_virtualattribute_pattern2 % __name__\n        result1 = output.getvalue().strip()\n        self.assertEqual(expected_text1, result1)\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(Class2)\n        expected_text2 = expected_virtualattribute_pattern3 % __name__\n        result2 = output.getvalue().strip()\n        self.assertEqual(expected_text2, result2)\n\n    @unittest.skipIf(sys.flags.optimize >= 2,\n                     \"Docstrings are omitted with -O2 and above\")\n    @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),\n                     'trace function introduces __locals__ unexpectedly')\n    def test_buggy_dir(self):\n        class M(type):\n            def __dir__(cls):\n                return ['__class__', '__name__', 'missing', 'here']\n        class C(metaclass=M):\n            here = 'present!'\n        output = StringIO()\n        helper = pydoc.Helper(output=output)\n        helper(C)\n        expected_text = expected_missingattribute_pattern % __name__\n        result = output.getvalue().strip()\n        self.assertEqual(expected_text, result)\n\n    def test_resolve_false(self):\n        # Issue #23008: pydoc enum.{,Int}Enum failed\n        # because bool(enum.Enum) is False.\n        with captured_stdout() as help_io:\n            pydoc.help('enum.Enum')\n        helptext = help_io.getvalue()\n        self.assertIn('class Enum', helptext)", "target": 0}, {"function": "class TestInternalUtilities(unittest.TestCase):\n\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.argv0dir = tmpdir.name\n        self.argv0 = os.path.join(tmpdir.name, \"nonexistent\")\n        self.addCleanup(tmpdir.cleanup)\n        self.abs_curdir = abs_curdir = os.getcwd()\n        self.curdir_spellings = [\"\", os.curdir, abs_curdir]\n\n    def _get_revised_path(self, given_path, argv0=None):\n        # Checking that pydoc.cli() actually calls pydoc._get_revised_path()\n        # is handled via code review (at least for now).\n        if argv0 is None:\n            argv0 = self.argv0\n        return pydoc._get_revised_path(given_path, argv0)\n\n    def _get_starting_path(self):\n        # Get a copy of sys.path without the current directory.\n        clean_path = sys.path.copy()\n        for spelling in self.curdir_spellings:\n            for __ in range(clean_path.count(spelling)):\n                clean_path.remove(spelling)\n        return clean_path\n\n    def test_sys_path_adjustment_adds_missing_curdir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        self.assertEqual(self._get_revised_path(clean_path), expected_path)\n\n    def test_sys_path_adjustment_removes_argv0_dir(self):\n        clean_path = self._get_starting_path()\n        expected_path = [self.abs_curdir] + clean_path\n        leading_argv0dir = [self.argv0dir] + clean_path\n        self.assertEqual(self._get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        self.assertEqual(self._get_revised_path(trailing_argv0dir), expected_path)\n\n\n    def test_sys_path_adjustment_protects_pydoc_dir(self):\n        def _get_revised_path(given_path):\n            return self._get_revised_path(given_path, argv0=pydoc.__file__)\n        clean_path = self._get_starting_path()\n        leading_argv0dir = [self.argv0dir] + clean_path\n        expected_path = [self.abs_curdir] + leading_argv0dir\n        self.assertEqual(_get_revised_path(leading_argv0dir), expected_path)\n        trailing_argv0dir = clean_path + [self.argv0dir]\n        expected_path = [self.abs_curdir] + trailing_argv0dir\n        self.assertEqual(_get_revised_path(trailing_argv0dir), expected_path)\n\n    def test_sys_path_adjustment_when_curdir_already_included(self):\n        clean_path = self._get_starting_path()\n        for spelling in self.curdir_spellings:\n            with self.subTest(curdir_spelling=spelling):\n                # If curdir is already present, no alterations are made at all\n                leading_curdir = [spelling] + clean_path\n                self.assertIsNone(self._get_revised_path(leading_curdir))\n                trailing_curdir = clean_path + [spelling]\n                self.assertIsNone(self._get_revised_path(trailing_curdir))\n                leading_argv0dir = [self.argv0dir] + leading_curdir\n                self.assertIsNone(self._get_revised_path(leading_argv0dir))\n                trailing_argv0dir = trailing_curdir + [self.argv0dir]\n                self.assertIsNone(self._get_revised_path(trailing_argv0dir))", "target": 0}]}, {"raw_url": "https://github.com/python/cpython/raw/9b999479c0022edfc9835a8a1f06e046f3881048/Misc%2FNEWS.d%2Fnext%2FSecurity%2F2021-03-24-14-16-56.bpo-42988.P2aNco.rst", "code": "CVE-2021-3426: Remove the ``getfile`` feature of the :mod:`pydoc` module which\ncould be abused to read arbitrary files on the disk (directory traversal\nvulnerability). Moreover, even source code of Python modules can contain\nsensitive data like passwords. Vulnerability reported by David Schw\u00f6rer.\n", "code_before": "", "patch": "@@ -0,0 +1,4 @@\n+CVE-2021-3426: Remove the ``getfile`` feature of the :mod:`pydoc` module which\n+could be abused to read arbitrary files on the disk (directory traversal\n+vulnerability). Moreover, even source code of Python modules can contain\n+sensitive data like passwords. Vulnerability reported by David Schw\u00f6rer.", "file_path": "files/2021_5/365", "file_language": "rst", "file_name": "Misc/NEWS.d/next/Security/2021-03-24-14-16-56.bpo-42988.P2aNco.rst", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
