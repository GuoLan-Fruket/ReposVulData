{"index": 8592, "cve_id": "CVE-2022-31506", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "The cmusatyalab/opendiamond repository through 10.1.1 on GitHub allows absolute path traversal because the Flask send_file function is used unsafely.", "cvss": "9.3", "publish_date": "July 10, 2022", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "CHANGED", "C": "HIGH", "I": "NONE", "A": "LOW", "commit_id": "398049c187ee644beabab44d6fece82251c1ea56", "commit_message": "Fix path traversal issues in all dataretriever backends", "commit_date": "2022-05-04T13:57:21Z", "project": "cmusatyalab/opendiamond", "url": "https://api.github.com/repos/cmusatyalab/opendiamond/commits/398049c187ee644beabab44d6fece82251c1ea56", "html_url": "https://github.com/cmusatyalab/opendiamond/commit/398049c187ee644beabab44d6fece82251c1ea56", "windows_before": [{"commit_id": "d2f20ffff793f88335f2c0244679d7193295abe2", "commit_date": "Wed May 4 09:27:27 2022 -0400", "commit_message": "Merge pull request #53 from porcupineyhairs/FixPathInjection", "files_name": ["744e345c078a20b7e8bc5bc34debcf7c7b1f7d4c - Wed May 4 00:19:18 2022 +0530 : # Absolute Path Traversal due to incorrect use of `send_file` call", "opendiamond/dataretriever/augment_store.py"]}, {"commit_id": "7ded6b5d243fee3f56c978fc37638f9691e8dfec", "commit_date": "Mon Aug 10 14:13:12 2020 -0400", "commit_message": "Bump version for opendiamond-10.1.1", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "14016c6d02625ecb9a9a7b8a3c394b429080b559", "commit_date": "Wed Aug 5 14:12:03 2020 -0400", "commit_message": "bound client queue and only return once all connections are done", "files_name": ["opendiamond/client/search.py"]}, {"commit_id": "23748b1d04f172ce7a64322fe83c12bc74e6ab88", "commit_date": "Fri Jul 31 17:09:37 2020 -0400", "commit_message": "fix search stats when no filters specified", "files_name": ["opendiamond/protocol.py"]}, {"commit_id": "df7a85a9cc33cf11e0bab4c90804d34c0ecf2560", "commit_date": "Thu Jul 30 17:37:26 2020 -0400", "commit_message": "Bump dev version", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "d2ba9c2cbd71c5b46c2b54e7d84b226ddda1d126", "commit_date": "Thu Jul 30 17:35:13 2020 -0400", "commit_message": "Bump version for opendiamond 10.1.0", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "8e623ce550e414ed642d4f8ee9a5e0ec1efb6e2d", "commit_date": "Thu Jul 30 17:23:15 2020 -0400", "commit_message": "allow for searching without filters", "files_name": ["opendiamond/server/search.py"]}, {"commit_id": "848968c696222417ef37a303556f29ae00c2220c", "commit_date": "Thu Jul 30 17:22:57 2020 -0400", "commit_message": "remove unused parameter", "files_name": ["opendiamond/protocol.py"]}, {"commit_id": "03930dc3a6e7945c6eb28b932ad9b5215d02594f", "commit_date": "Thu Jul 30 14:39:15 2020 -0400", "commit_message": "bump psutil in environment.yml", "files_name": ["environment.yml"]}, {"commit_id": "c19fb5d089189f0d6a46bfbc44cd0e6561a3bb35", "commit_date": "Wed Jul 29 21:35:15 2020 -0400", "commit_message": "Install m2crypto with conda so we don't have to recompile.", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "a49cd149a8bb88720a4eb1dac3e2583e3ba2a0d9", "commit_date": "Wed Jul 29 21:27:44 2020 -0400", "commit_message": "Tweak for the multiline commands in gitlab-ci.", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "161bd1917fdad4dd6d64191bb94cd4bed2f3c1af", "commit_date": "Wed Jul 29 21:20:36 2020 -0400", "commit_message": "We don't need to explicitly copy extract-filters", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial", "setup.py", "tools/extract-filters"]}, {"commit_id": "9d015855e7b02c571d7399a4d8869cbd9df01a43", "commit_date": "Wed Jul 29 21:19:13 2020 -0400", "commit_message": "Reorganize gitlab-ci file to reduce duplication.", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "37f313a9acfa33fdc06e5f8538d5d542b19750f7", "commit_date": "Wed Jul 29 21:14:35 2020 -0400", "commit_message": "Pass pip caching proxy environment during docker builds", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "9a76c8aeb4033688e46485b272d19f2f169cc5f3", "commit_date": "Wed Jul 29 17:01:25 2020 -0400", "commit_message": "Try to pass caching proxy host by IP address.", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "28f715ad97cde75416a6f483dc48de7bd1ce7fdc", "commit_date": "Wed Jul 29 16:50:20 2020 -0400", "commit_message": "Pass PIP_INDEX_URL and PIP_TRUSTED_HOST into docker build container", "files_name": [".gitlab-ci.yml", "docker/Dockerfile.buster"]}, {"commit_id": "84935856e66a6e65108764a5a0df31ef881930c9", "commit_date": "Wed Jul 29 16:18:31 2020 -0400", "commit_message": "Try to use pip install instead of setuptools/easy_install", "files_name": ["docker/Dockerfile.buster"]}, {"commit_id": "d63923b7f294674f7345b75f8c6342ba2d17f23d", "commit_date": "Wed Jul 29 12:30:13 2020 -0400", "commit_message": "Merge branch 'ht/optionally-unpack-attrs' into 'dev'", "files_name": ["38525a3f65929d1a720c5936ef08f74e1982aabf - Wed Jul 29 11:00:26 2020 -0400 : make unpacking of attributes on client configurable", "opendiamond/client/search.py", "opendiamond/proxy/search.py"]}, {"commit_id": "cfaf22d1f148c5858f7cbb49b2d670a9b1d91225", "commit_date": "Tue Jul 28 22:51:37 2020 -0400", "commit_message": "Another try, drop down to the docker version on the host", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "385f0bcbee39b98c4a69493c3f91b0d6abb16ec8", "commit_date": "Tue Jul 28 22:19:10 2020 -0400", "commit_message": "Try to fix docker-in-docker CI builds", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "ef6f13becaf104a572e43244d803e66c5327c801", "commit_date": "Tue Jul 28 19:50:46 2020 -0400", "commit_message": "client: don't assume attrs are strings. server: don't calculate attr sig if redis cache is disabled.", "files_name": ["opendiamond/client/search.py", "opendiamond/server/object_.py", "opendiamond/server/scopelist.py"]}, {"commit_id": "009e2a230625e2d526fa44074f1b960e66c39a77", "commit_date": "Mon Jul 27 09:30:32 2020 -0400", "commit_message": "Bump version to 10.0.3-dev", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "74518c05bc1ce25bebe7e0e218f60644dc358629", "commit_date": "Mon Jul 27 09:28:14 2020 -0400", "commit_message": "Bump version to 10.0.2", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "2f9cd134f6924bd469312c1cf4d39bd75734add5", "commit_date": "Sun Jul 26 16:59:47 2020 -0400", "commit_message": "Add pyyaml to core dependencies. Removed some useless code", "files_name": ["opendiamond/dataretriever/carbon_v1_store.py", "opendiamond/server/filter.py", "setup.py"]}, {"commit_id": "6f0809a50c6d5ee6d0ac9e1eb8362811b6c39875", "commit_date": "Sat Jul 25 15:14:40 2020 -0400", "commit_message": "Bump version to 10.0.2-dev", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "c390635e53819885015f99ca3290a8065522ed87", "commit_date": "Sat Jul 25 15:10:13 2020 -0400", "commit_message": "Bump version to 10.0.1", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "be490f3a5ce3fc0d70bffb43fc9d9e2ec8aebb67", "commit_date": "Sat Jul 25 13:36:14 2020 -0400", "commit_message": "Add extract-filters script to python package", "files_name": ["setup.py"]}, {"commit_id": "bec50a3010183ac208bd11307c4e82bc46dc8073", "commit_date": "Thu Jul 9 13:43:23 2020 -0400", "commit_message": "Reduce number of times we refetch Debian/Ubuntu package lists.", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.xenial"]}, {"commit_id": "7fa83c2777dc2f50b082123f4ae7c61fd3d13782", "commit_date": "Wed Jul 8 22:34:10 2020 -0400", "commit_message": "Bump version to 10.0.1~dev", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "5d82fbfec616c7acb10c23b8ac5712135eb537ed", "commit_date": "Wed Jul 8 21:59:11 2020 -0400", "commit_message": "Bump version to opendiamond-10.0.0", "files_name": ["configure.ac", "opendiamond/__init__.py"]}, {"commit_id": "26512cec0244e663853a953639b06a36d06930ed", "commit_date": "Wed Jul 8 21:25:04 2020 -0400", "commit_message": "xml2rfc seems to use -f instead of -o for output file", "files_name": ["Makefile.am"]}, {"commit_id": "fc7fb86c1d57e38cd638dc3cbc39f6081ea52dc5", "commit_date": "Wed Jul 8 18:51:51 2020 -0400", "commit_message": "Packaging related fixed", "files_name": ["Makefile.am", "setup.py"]}, {"commit_id": "3061b0106860c67cede6d6ea5588983cea97a589", "commit_date": "Wed Jul 8 17:39:02 2020 -0400", "commit_message": "Update Django, Pillow and psutil dependencies.", "files_name": ["setup.py"]}, {"commit_id": "580d5a37a202ac3858d0ea7ac86f73c83a049a84", "commit_date": "Wed Jul 8 17:20:25 2020 -0400", "commit_message": "Add Haithem to CREDITS", "files_name": ["CREDITS"]}, {"commit_id": "718e1f09f6b224023644a5357ba64b1879827b3c", "commit_date": "Sun Apr 12 01:04:58 2020 -0400", "commit_message": "adding dataretriever augmentation", "files_name": ["opendiamond/dataretriever/test_store.py"]}, {"commit_id": "a6c5ebbee5c9ac35e895ddc34feb9dd70737a76d", "commit_date": "Sun Apr 12 01:03:06 2020 -0400", "commit_message": "adding dataretriever augmentation", "files_name": ["opendiamond/dataretriever/augment_store.py", "opendiamond/dataretriever/util.py"]}, {"commit_id": "e20e04481824d6eef480de245ed7ef0d12023832", "commit_date": "Sun Mar 29 22:01:40 2020 -0400", "commit_message": "Never mind all that, pypi.org doesn't work over non-SSL (anymore?)", "files_name": [".gitlab-ci.yml", "docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "a68c7e2e270d6f02b1eb6579e809e582fb7bf736", "commit_date": "Sun Mar 29 21:44:35 2020 -0400", "commit_message": "Need to specify pypi.org is considered trusted", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "47e8e97bd0b0516971b0d3b6428bb9b24e87dd30", "commit_date": "Sun Mar 29 21:33:19 2020 -0400", "commit_message": "Try to use non-http access to pypi", "files_name": [".gitlab-ci.yml", "docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "1a20a7de1f35effd506fb3e24d20fa4ba6fc6b2d", "commit_date": "Sun Mar 29 00:04:48 2020 -0400", "commit_message": "Try to force pip to use non-ssl requests", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "ef2d3bb0e23b84d1848f1a8e8609f0e348b171d2", "commit_date": "Sat Mar 28 23:46:20 2020 -0400", "commit_message": "Add missing ca-certificates", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.xenial"]}, {"commit_id": "964eca726d84bcc115dc883576ebfcb092a57df4", "commit_date": "Sat Mar 28 23:35:15 2020 -0400", "commit_message": "Fix incorrect ARG usage in Dockerfiles", "files_name": ["docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial"]}, {"commit_id": "2d91cf4f2fc1397cf0dd4342fb1448e918e75edb", "commit_date": "Sat Mar 28 23:11:24 2020 -0400", "commit_message": "Simplify CI builds", "files_name": [".gitlab-ci.yml", "docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7", "docker/Dockerfile.xenial", "docker/Makefile"]}, {"commit_id": "86e97f5f6477fdb84101ccb50814f67fdd3f9d3a", "commit_date": "Sat Mar 28 00:01:07 2020 -0400", "commit_message": "Forgot to add miniconda.sh to cached artifacts", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "0ff71ecae711d49265bebeb27d1d4c92f641d190", "commit_date": "Fri Mar 27 23:59:55 2020 -0400", "commit_message": "Trying to fix setup cache CI step", "files_name": [".gitlab-ci.yml"]}, {"commit_id": "b99dbc3beb20912aa874fb7054ec5eec26ee6e4a", "commit_date": "Fri Mar 27 23:29:21 2020 -0400", "commit_message": "Fix docker image builds", "files_name": [".gitignore", ".gitlab-ci.yml", "docker/Dockerfile.buster", "docker/Dockerfile.centos6", "docker/Dockerfile.centos7"]}], "windows_after": [{"commit_id": "c0a1d4951f689a4a77dd70b05bb063a94e0a9d9b", "commit_date": "Wed May 4 10:40:44 2022 -0400", "commit_message": "Fix for Centos build failures", "files_name": [".gitlab-ci.yml", "doc/diamond-protocol.xml"]}, {"commit_id": "fd7f56948c2810c0a29d15e2eb2fad71765b9f53", "commit_date": "Wed May 4 10:55:06 2022 -0400", "commit_message": "Adding ipr broke xml2rfc everywhere.", "files_name": [".gitlab-ci.yml", "doc/diamond-protocol.xml"]}], "parents": [{"commit_id_before": "d2f20ffff793f88335f2c0244679d7193295abe2", "url_before": "https://api.github.com/repos/cmusatyalab/opendiamond/commits/d2f20ffff793f88335f2c0244679d7193295abe2", "html_url_before": "https://github.com/cmusatyalab/opendiamond/commit/d2f20ffff793f88335f2c0244679d7193295abe2"}], "details": [{"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Faugment_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\nfrom opendiamond.dataretriever.util import read_file_list, write_data\n\n\nBASEURL = 'augment'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\nKEYWORD = 'yellowthroat'\n\n\"\"\"\n    Example url:\n        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\\n            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>\n\n        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = 'STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('augment_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +\n                        '/start/<int:start>/limit/<int:limit>')\ndef get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):\n    global KEYWORD\n    if rootdir == \"0\":\n        rootdir = INDEXDIR\n\n    rootdir = _get_obj_absolute_path(rootdir)\n    seed = None\n    percentage = 0.\n    seed, percentage = decode_params(params)\n\n    # Assuming the same positive list is present in all the servers\n    # Always create a new index file\n    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)\n    total_entries = len(base_list)\n\n    start = start if start > 0 else 0\n    end = min(total_entries, start + limit) if limit > 0 else total_entries\n    base_list = base_list[start:end]\n    total_entries = end - start\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        for path in base_list:\n            path = path.strip()\n            yield _get_object_element(object_path=path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    \"\"\"\n    Decodes the params which are '_' seperated\n    <[d]eterminant/[r]andom>_<random_seed>_<baserate>\n    \"\"\"\n    keywords = params.split('_')\n    mix_type = keywords[0]\n    seed = None\n    if len(keywords) > 1:\n        seed = int(keywords[1])\n    if mix_type == 'r' or seed is None:\n        seed = random.randrange(10000)\n    percentage = 0.1 # default base_rate = 0.1%\n    if len(keywords) > 2:\n        percentage = float(keywords[2])\n    return seed, round(percentage, 4)\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    meta = {'_gt_label': KEYWORD}\n    if KEYWORD in path:\n        return '<object id={} src={} meta={} />' \\\n                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                        quoteattr(_get_object_src_uri(object_path)),\n                        quoteattr(url_for('.get_object_meta', present=True)))\n\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\n@scope_blueprint.route('/meta/<path:present>')\ndef get_object_meta(present=False):\n    attrs = dict()\n    if present:\n        attrs['_gt_label'] = KEYWORD\n\n    return jsonify(attrs)\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n\ndef create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):\n    \"\"\"\n    Creates Index List File:\n    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE\n    \"\"\"\n\n    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]\n    filepath = '_'.join(filepath_split)\n    filepath = os.path.join(base_dir, filepath)\n    positive_path = os.path.join(base_dir, 'POSITIVE')\n    negative_path = os.path.join(base_dir, 'NEGATIVE')\n    positive_firstline = open(positive_path).readline().rstrip()\n    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir\n\n    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))\n    sys.stdout.flush()\n\n    if not os.path.exists(filepath):\n        positive_data = read_file_list(positive_path) # same across servers\n        negative_data = read_file_list(negative_path) # different across servers\n        random.Random(seed).shuffle(positive_data)\n        random.Random(seed).shuffle(negative_data)\n        len_positive = len(positive_data)\n        start_idx = int(rank * (1.0 / total_servers) * len_positive)\n        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)\n        positive_data = positive_data[start_idx:end_idx]\n        len_positive = len(positive_data)\n        negative_sample = int(len_positive * (100./base_rate -1))\n        negative_data = negative_data[:negative_sample]\n        return write_data(filepath, [negative_data, positive_data], seed), keyword\n\n    return read_file_list(filepath), keyword\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.utils import safe_join\nfrom opendiamond.dataretriever.util import read_file_list, write_data\n\n\nBASEURL = 'augment'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\nKEYWORD = 'yellowthroat'\n\n\"\"\"\n    Example url:\n        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\\n            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>\n\n        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = 'STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('augment_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>')\n@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +\n                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +\n                        '/start/<int:start>/limit/<int:limit>')\ndef get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):\n    global KEYWORD\n    if rootdir == \"0\":\n        rootdir = INDEXDIR\n\n    rootdir = _get_obj_absolute_path(rootdir)\n    seed = None\n    percentage = 0.\n    seed, percentage = decode_params(params)\n\n    # Assuming the same positive list is present in all the servers\n    # Always create a new index file\n    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)\n    total_entries = len(base_list)\n\n    start = start if start > 0 else 0\n    end = min(total_entries, start + limit) if limit > 0 else total_entries\n    base_list = base_list[start:end]\n    total_entries = end - start\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        for path in base_list:\n            path = path.strip()\n            yield _get_object_element(object_path=path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    \"\"\"\n    Decodes the params which are '_' seperated\n    <[d]eterminant/[r]andom>_<random_seed>_<baserate>\n    \"\"\"\n    keywords = params.split('_')\n    mix_type = keywords[0]\n    seed = None\n    if len(keywords) > 1:\n        seed = int(keywords[1])\n    if mix_type == 'r' or seed is None:\n        seed = random.randrange(10000)\n    percentage = 0.1 # default base_rate = 0.1%\n    if len(keywords) > 2:\n        percentage = float(keywords[2])\n    return seed, round(percentage, 4)\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    meta = {'_gt_label': KEYWORD}\n    if KEYWORD in path:\n        return '<object id={} src={} meta={} />' \\\n                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                        quoteattr(_get_object_src_uri(object_path)),\n                        quoteattr(url_for('.get_object_meta', present=True)))\n\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\n@scope_blueprint.route('/meta/<path:present>')\ndef get_object_meta(present=False):\n    attrs = dict()\n    if present:\n        attrs['_gt_label'] = KEYWORD\n\n    return jsonify(attrs)\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n\ndef create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):\n    \"\"\"\n    Creates Index List File:\n    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE\n    \"\"\"\n\n    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]\n    filepath = '_'.join(filepath_split)\n    filepath = os.path.join(base_dir, filepath)\n    positive_path = os.path.join(base_dir, 'POSITIVE')\n    negative_path = os.path.join(base_dir, 'NEGATIVE')\n    positive_firstline = open(positive_path).readline().rstrip()\n    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir\n\n    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))\n    sys.stdout.flush()\n\n    if not os.path.exists(filepath):\n        positive_data = read_file_list(positive_path) # same across servers\n        negative_data = read_file_list(negative_path) # different across servers\n        random.Random(seed).shuffle(positive_data)\n        random.Random(seed).shuffle(negative_data)\n        len_positive = len(positive_data)\n        start_idx = int(rank * (1.0 / total_servers) * len_positive)\n        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)\n        positive_data = positive_data[start_idx:end_idx]\n        len_positive = len(positive_data)\n        negative_sample = int(len_positive * (100./base_rate -1))\n        negative_data = negative_data[:negative_sample]\n        return write_data(filepath, [negative_data, positive_data], seed), keyword\n\n    return read_file_list(filepath), keyword\n", "patch": "@@ -24,7 +24,7 @@\n from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n     jsonify\n from werkzeug.datastructures import Headers\n-from werkzeug.utils import safe_join\n+from werkzeug.security import safe_join\n from opendiamond.dataretriever.util import read_file_list, write_data\n \n ", "file_path": "files/2022_7/295", "file_language": "py", "file_name": "opendiamond/dataretriever/augment_store.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Fdiamond_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\n\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nfrom opendiamond.dataretriever.util import ATTR_SUFFIX\n\nBASEURL = 'collection'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('diamond_store', __name__)\n\n\n@scope_blueprint.route('/<gididx>')\n@scope_blueprint.route('/<gididx>/limit/<int:limit>')\ndef get_scope(gididx, limit=None):\n    index = 'GIDIDX' + gididx.upper()\n    index = _get_index_absolute_path(index)\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n        num_entries = 0\n        with open(index, 'r') as f:\n            for _ in f.readlines():\n                num_entries += 1\n                if limit is not None and num_entries >= limit:\n                    break\n\n        with open(index, 'r') as f:\n            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n            if STYLE:\n                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)\n            \n            count = 0\n            for path in f.readlines():\n                path = path.strip()\n                yield _get_object_element(object_path=path) + '\\n'\n                count += 1\n                if limit is not None and count >= limit:\n                    break\n\n            yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        with DiamondTextAttr(path, 'r') as attributes:\n            for key, value in attributes:\n                attrs[key] = value\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n\n    if os.path.isfile(path + ATTR_SUFFIX):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    else:\n        return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n    else:\n        return url_for('.get_object_src_http', obj_path=object_path)\n\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\n\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\n\nfrom opendiamond.dataretriever.util import ATTR_SUFFIX\n\nBASEURL = 'collection'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('diamond_store', __name__)\n\n\n@scope_blueprint.route('/<gididx>')\n@scope_blueprint.route('/<gididx>/limit/<int:limit>')\ndef get_scope(gididx, limit=None):\n    index = 'GIDIDX' + gididx.upper()\n    index = _get_index_absolute_path(index)\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n        num_entries = 0\n        with open(index, 'r') as f:\n            for _ in f.readlines():\n                num_entries += 1\n                if limit is not None and num_entries >= limit:\n                    break\n\n        with open(index, 'r') as f:\n            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n            if STYLE:\n                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)\n            \n            count = 0\n            for path in f.readlines():\n                path = path.strip()\n                yield _get_object_element(object_path=path) + '\\n'\n                count += 1\n                if limit is not None and count >= limit:\n                    break\n\n            yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        with DiamondTextAttr(path, 'r') as attributes:\n            for key, value in attributes:\n                attrs[key] = value\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n\n    if os.path.isfile(path + ATTR_SUFFIX):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    else:\n        return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n    else:\n        return url_for('.get_object_src_http', obj_path=object_path)\n\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "patch": "@@ -17,6 +17,7 @@\n from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n     jsonify\n from werkzeug.datastructures import Headers\n+from werkzeug.security import safe_join\n \n from opendiamond.dataretriever.util import ATTR_SUFFIX\n \n@@ -120,11 +121,11 @@ def _get_object_src_uri(object_path):\n \n \n def _get_obj_absolute_path(obj_path):\n-    return os.path.join(DATAROOT, obj_path)\n+    return safe_join(DATAROOT, obj_path)\n \n \n def _get_index_absolute_path(index):\n-    return os.path.join(INDEXDIR, index)\n+    return safe_join(INDEXDIR, index)\n \n \n @scope_blueprint.route('/obj/<path:obj_path>')", "file_path": "files/2022_7/296", "file_language": "py", "file_name": "opendiamond/dataretriever/diamond_store.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Fmixer_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nBASEURL = 'cocktail'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('mixer_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    print(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    print(\"Enter Scope\")\n    sys.stdout.flush()\n    base_list = []\n    seed, percentage = decode_params(params)\n    if baseidx != \"0\":\n        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if limit > 0:\n            base_list = base_list[start:start+limit]\n        elif start > 0:\n            base_list = base_list[start:]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.0001\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    print(\"Class paths : {}\".format(class_paths))\n    sys.stdout.flush()\n\n    if class_paths:\n        for path in class_paths:\n            print(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n\n            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\n\nBASEURL = 'cocktail'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('mixer_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    print(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    print(\"Enter Scope\")\n    sys.stdout.flush()\n    base_list = []\n    seed, percentage = decode_params(params)\n    if baseidx != \"0\":\n        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if limit > 0:\n            base_list = base_list[start:start+limit]\n        elif start > 0:\n            base_list = base_list[start:]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.0001\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    print(\"Class paths : {}\".format(class_paths))\n    sys.stdout.flush()\n\n    if class_paths:\n        for path in class_paths:\n            print(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n\n            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "patch": "@@ -24,6 +24,7 @@\n from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n     jsonify\n from werkzeug.datastructures import Headers\n+from werkzeug.security import safe_join\n \n BASEURL = 'cocktail'\n STYLE = False\n@@ -249,11 +250,11 @@ def _get_obj_path(obj_path):\n     return obj_path.replace(DATAROOT+'/', '')\n \n def _get_obj_absolute_path(obj_path):\n-    return os.path.join(DATAROOT, obj_path)\n+    return safe_join(DATAROOT, obj_path)\n \n \n def _get_index_absolute_path(index):\n-    return os.path.join(INDEXDIR, index)\n+    return safe_join(INDEXDIR, index)\n \n \n @scope_blueprint.route('/obj/<path:obj_path>')", "file_path": "files/2022_7/297", "file_language": "py", "file_name": "opendiamond/dataretriever/mixer_store.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Ftest_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\nfrom opendiamond.dataretriever.test_utils import *\n\n\nBASEURL = 'cocktailtest'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = '/srv/diamond/STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('test_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    _log.info(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))\n    sys.stdout.flush()\n    base_list = []\n    seed = None\n    percentage = 0.\n    if params:\n        seed, percentage = decode_params(params)\n    s_seed = seed\n    if s_seed == None:\n        s_seed = random.randrange(10000)\n    if baseidx != \"0\":\n        # format of baseidx: stream_inat \n        # format of base file: stream_{int: seed}_{float(.2f): baserate} \n        base_index = _get_index_absolute_path(baseidx)\n        data_type, pos_file = base_index.split('_')\n        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places\n        # if seed != s_seed:\n        #     index[1] = str(s_seed)\n        #     base_index = '_'.join(index)\n        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]\n        base_index = '_'.join(base_list)\n        print(base_index)\n        if not os.path.exists(base_index):\n            split_data(INDEXDIR, percentage, s_seed)\n        #base_index = base_index.replace(str(seed),str(s_seed))\n\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if start > 0:\n            base_list = base_list[start:]\n        if limit > 0:\n            end_ = len(base_list)\n            if limit > end_:\n                limit = end_\n            base_list = base_list[:limit]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.1\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2]) #float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n\n    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')\n\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    _log.info(\"Class paths : {}\".format(class_paths))\n\n    if class_paths:\n        for path in class_paths:\n            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n            file_list = []\n            for ext in image_types:\n                file_list.extend(glob.glob(os.path.join(path, ext)))\n            mixer_list.extend(sorted(file_list))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2009-2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\nfrom builtins import next\nfrom builtins import range\nimport os\nimport datetime\nfrom xml.sax.saxutils import quoteattr\nimport sys\n\nimport logging\nimport random\nimport glob\nfrom itertools import cycle\nfrom flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n    jsonify\nfrom werkzeug.datastructures import Headers\nfrom opendiamond.dataretriever.test_utils import *\n\n\nBASEURL = 'cocktailtest'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.\nINDEXDIR = DATAROOT = None\nITEMS_PER_ITERATION = int(1e4)\n\n\"\"\"\n    Example cocktail url:\n        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\\n            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal\n        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0\n        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0\n\"\"\"\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = '/srv/diamond/STREAM'\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('test_store', __name__)\n\n_log = logging.getLogger(__name__)\n\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>')\n@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +\n                        'classes/<classes>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +\n                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')\ndef get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, \n                      classes=None, start=0, limit=-1):\n\n    mixer_list = get_mixer_list(mixeridx, classes)\n    start_idx = int((index-1)*(1.0/total)*len(mixer_list))\n    end_idx = int(index*(1.0/total)*len(mixer_list))\n    mixer_list = mixer_list[start_idx:end_idx]\n    _log.info(\"Mixer Size {}\".format(len(mixer_list)))\n    sys.stdout.flush()\n\n    return get_scope(baseidx, params, mixer_list, start, limit)\n\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>')\n@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')\n@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')\ndef get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):\n    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))\n    sys.stdout.flush()\n    base_list = []\n    seed = None\n    percentage = 0.\n    if params:\n        seed, percentage = decode_params(params)\n    s_seed = seed\n    if s_seed == None:\n        s_seed = random.randrange(10000)\n    if baseidx != \"0\":\n        # format of baseidx: stream_inat \n        # format of base file: stream_{int: seed}_{float(.2f): baserate} \n        base_index = _get_index_absolute_path(baseidx)\n        data_type, pos_file = base_index.split('_')\n        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places\n        # if seed != s_seed:\n        #     index[1] = str(s_seed)\n        #     base_index = '_'.join(index)\n        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]\n        base_index = '_'.join(base_list)\n        print(base_index)\n        if not os.path.exists(base_index):\n            split_data(INDEXDIR, percentage, s_seed)\n        #base_index = base_index.replace(str(seed),str(s_seed))\n\n        with open(base_index, 'r') as f:\n            base_list = list(f.readlines())\n        if start > 0:\n            base_list = base_list[start:]\n        if limit > 0:\n            end_ = len(base_list)\n            if limit > end_:\n                limit = end_\n            base_list = base_list[:limit]\n        total_entries = len(base_list)\n\n\n    make_cocktail = bool(mixer_list and base_list)\n        \n    if base_list:\n        total_entries = len(base_list)  #base_entries\n    else:\n        total_entries = len(mixer_list)\n        base_list = mixer_list.copy()\n        del mixer_list\n\n    random.seed(seed)\n    #random.Random(seed).shuffle(base_list)\n\n    total_sample = 0 \n    if make_cocktail:\n        random.Random(seed).shuffle(mixer_list)\n        total_sample = int(percentage*total_entries)\n        total_entries = total_entries + total_sample\n\n    # Streaming response:\n    # http://flask.pocoo.org/docs/0.12/patterns/streaming/\n    def generate():\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)\n\n        mix_per_iteration = 0\n        iteration_count = 0\n        if make_cocktail:\n            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)\n            pool = cycle(mixer_list)\n\n        mix_indices = []\n\n        def generate_mix_indices():\n            random.seed(seed)\n            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,\n                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))\n\n        for count in range(total_entries):\n            if not count % ITEMS_PER_ITERATION and make_cocktail:\n                mix_indices = generate_mix_indices()\n                iteration_count += 1\n\n            if count in mix_indices:\n                obj_path = next(pool).strip()\n            else:\n                obj_path = base_list.pop(0).strip()\n            yield _get_object_element(object_path=obj_path) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\ndef decode_params(params):\n    keywords = params.split('_')\n    m_type = keywords[0]\n    seed = int(keywords[1])\n    percentage = 0.1\n    if m_type == 'r':\n        seed = None\n    if len(keywords) > 2:\n        percentage = float(keywords[2]) #float(keywords[2])/100.\n    return seed, round(percentage, 4)\n\ndef get_mixer_list(idx, classes=None):\n    \"\"\"\n    Return list of file paths present in given classes of mixer set\n    If class list is None or incorrect then return list of entire mixer set.\n\n    Args:\n        classes (str): Comma seperated classes of interest\n        idx     (str): Index of mixer collection\n\n    Returns:\n    \"\"\"\n    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())\n\n    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')\n\n    classes_list = []\n    if classes:\n        classes.replace('%2C', ',')\n        classes.replace('%20', ' ')\n        classes_list = classes.split(',')\n\n    def get_class_path():\n        with open(mixer_index, 'r') as f:\n            dataset_path = f.readline()\n        dataset_path = '/'.join(dataset_path.split('/')[:-2])\n        class_paths = []\n        for c in classes_list:\n            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))\n        return class_paths\n\n    mixer_list = []\n    class_paths = get_class_path()\n    _log.info(\"Class paths : {}\".format(class_paths))\n\n    if class_paths:\n        for path in class_paths:\n            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))\n            sys.stdout.flush()\n            file_list = []\n            for ext in image_types:\n                file_list.extend(glob.glob(os.path.join(path, ext)))\n            mixer_list.extend(sorted(file_list))\n        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]\n    else:\n        with open(mixer_index, 'r') as f:\n            mixer_list = list(f.readlines())\n\n    return mixer_list\n\n@scope_blueprint.route('/id/<path:object_path>')\ndef get_object_id(object_path):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(object_path=object_path),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/meta/<path:object_path>')\ndef get_object_meta(object_path):\n    path = _get_obj_absolute_path(object_path)\n    attrs = dict()\n\n    try:\n        attrs['_gt_label'] = path.split('/')[-2]\n    except IOError:\n        pass\n\n    return jsonify(attrs)\n\n\ndef _get_object_element(object_path):\n    path = _get_obj_absolute_path(object_path)\n    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'\n    if os.path.isfile(class_text):\n        return '<object id={} src={} meta={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)),\n                    quoteattr(url_for('.get_object_meta', object_path=object_path)))\n    return '<object id={} src={} />' \\\n            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),\n                    quoteattr(_get_object_src_uri(object_path)))\n\n\ndef _get_object_src_uri(object_path):\n    if LOCAL_OBJ_URI:\n        return 'file://' + _get_obj_absolute_path(object_path)\n\n    return url_for('.get_object_src_http', obj_path=object_path)\n\ndef _get_obj_path(obj_path):\n    return obj_path.replace(DATAROOT+'/', '')\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\n@scope_blueprint.route('/obj/<path:obj_path>')\ndef get_object_src_http(obj_path):\n    path = _get_obj_absolute_path(obj_path)\n\n    headers = Headers()\n    # With add_etags=True, conditional=True\n    # Flask should be smart enough to do 304 Not Modified\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    response.headers.extend(headers)\n    return response\n", "patch": "@@ -24,6 +24,8 @@\n from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\\n     jsonify\n from werkzeug.datastructures import Headers\n+from werkzeug.security import safe_join\n+\n from opendiamond.dataretriever.test_utils import *\n \n \n@@ -279,11 +281,11 @@ def _get_obj_path(obj_path):\n     return obj_path.replace(DATAROOT+'/', '')\n \n def _get_obj_absolute_path(obj_path):\n-    return os.path.join(DATAROOT, obj_path)\n+    return safe_join(DATAROOT, obj_path)\n \n \n def _get_index_absolute_path(index):\n-    return os.path.join(INDEXDIR, index)\n+    return safe_join(INDEXDIR, index)\n \n \n @scope_blueprint.route('/obj/<path:obj_path>')", "file_path": "files/2022_7/298", "file_language": "py", "file_name": "opendiamond/dataretriever/test_store.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Fvideo_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\nfrom builtins import range, str\n\nimport datetime\nimport json\nimport os\nimport subprocess\nimport sys\nfrom math import ceil\n\nfrom flask import Blueprint, Response, request, stream_with_context, url_for\nfrom opendiamond.dataretriever.util import DiamondTextAttr\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\n\n# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.\n\nBASEURL = 'video'\nSTYLE = False\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('video_store', __name__)\n\n@scope_blueprint.route('/scope/<gididx>')\n@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')\ndef get_scope(gididx, stride=5, span=5):\n    index = 'GIDIDX' + gididx.upper()\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n\n        with open(_get_index_absolute_path(index), 'rt') as f:\n            for line in f:\n                video = line.strip()\n                video_path = str(_get_obj_absolute_path(video))\n                try:\n                    video_meta = _ffprobe(video_path)\n                    length_sec = float(video_meta['format']['duration'])\n                    num_clips = int(ceil(length_sec / stride))\n                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)\n                    for clip in range(num_clips):\n                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'\n                except Exception as e:\n                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)\n                    pass\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object_id(start, span, video):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(start, span, video),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object(start, span, video):\n    # Reference:\n    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py\n    video_path = str(_get_obj_absolute_path(video))\n    proc = _create_ffmpeg_segment_proc(video_path,\n                                       start_sec=start,\n                                       duration_sec=span)\n\n    def generate():\n        while True:\n            data = proc.stdout.read(4096)\n            if not data:\n                break\n            yield data\n\n    headers = Headers([('Content-Type', 'video/mp4')])\n    response = Response(stream_with_context(generate()),\n                        status=\"200 OK\",\n                        headers=headers)\n    # Cache control\n    stat = os.stat(video_path)\n    last_modified = stat.st_mtime\n    size = stat.st_size\n    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)\n    response.last_modified = last_modified\n    response.set_etag(etag=etag)\n    response.cache_control.public = True\n    response.cache_control.max_age = \\\n        datetime.timedelta(days=365).total_seconds()\n    response.make_conditional(request)\n\n    return response\n\n\ndef _get_object_element(start, span, video):\n    return '<object id=\"{}\" src=\"{}\" />'.format(\n        url_for('.get_object_id', start=start, span=span, video=video),\n        url_for('.get_object', start=start, span=span, video=video))\n\n\ndef _get_obj_absolute_path(obj_path):\n    return safe_join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return safe_join(INDEXDIR, index)\n\n\ndef _ffprobe(video_path):\n    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',\n                '-show_format', video_path]\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    data = json.load(proc.stdout)\n    \n    return data\n\n\ndef _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):\n    \"\"\"\n    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.\n    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.\n    Reference: http://trac.ffmpeg.org/wiki/Seeking\n    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable\n    :param video_path:\n    :param start_sec:\n    :param duration_sec:\n    :return: the subprocess\n    \"\"\"\n    cmd_l = ['ffmpeg', '-v', 'quiet',\n             '-ss', str(start_sec),\n             '-t', str(duration_sec),\n             '-i', str(video_path),\n             '-movflags', 'frag_keyframe+empty_moov',\n             '-c', 'copy',\n             '-f', 'mp4',\n             'pipe:1']\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    return proc\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\nfrom builtins import range, str\n\nimport datetime\nimport json\nimport os\nimport subprocess\nimport sys\nfrom math import ceil\n\nfrom flask import Blueprint, Response, request, stream_with_context, url_for\nfrom opendiamond.dataretriever.util import DiamondTextAttr\nfrom werkzeug.datastructures import Headers\n\n# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.\n\nBASEURL = 'video'\nSTYLE = False\nINDEXDIR = DATAROOT = None\n\n\ndef init(config):\n    global INDEXDIR, DATAROOT  # pylint: disable=global-statement\n    INDEXDIR = config.indexdir\n    DATAROOT = config.dataroot\n\n\nscope_blueprint = Blueprint('video_store', __name__)\n\n@scope_blueprint.route('/scope/<gididx>')\n@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')\ndef get_scope(gididx, stride=5, span=5):\n    index = 'GIDIDX' + gididx.upper()\n\n    def generate():\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n\n        with open(_get_index_absolute_path(index), 'rt') as f:\n            for line in f:\n                video = line.strip()\n                video_path = str(_get_obj_absolute_path(video))\n                try:\n                    video_meta = _ffprobe(video_path)\n                    length_sec = float(video_meta['format']['duration'])\n                    num_clips = int(ceil(length_sec / stride))\n                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)\n                    for clip in range(num_clips):\n                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'\n                except Exception as e:\n                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)\n                    pass\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object_id(start, span, video):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(start, span, video),\n                    \"200 OK\",\n                    headers=headers)\n\n\n@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')\ndef get_object(start, span, video):\n    # Reference:\n    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py\n    video_path = str(_get_obj_absolute_path(video))\n    proc = _create_ffmpeg_segment_proc(video_path,\n                                       start_sec=start,\n                                       duration_sec=span)\n\n    def generate():\n        while True:\n            data = proc.stdout.read(4096)\n            if not data:\n                break\n            yield data\n\n    headers = Headers([('Content-Type', 'video/mp4')])\n    response = Response(stream_with_context(generate()),\n                        status=\"200 OK\",\n                        headers=headers)\n    # Cache control\n    stat = os.stat(video_path)\n    last_modified = stat.st_mtime\n    size = stat.st_size\n    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)\n    response.last_modified = last_modified\n    response.set_etag(etag=etag)\n    response.cache_control.public = True\n    response.cache_control.max_age = \\\n        datetime.timedelta(days=365).total_seconds()\n    response.make_conditional(request)\n\n    return response\n\n\ndef _get_object_element(start, span, video):\n    return '<object id=\"{}\" src=\"{}\" />'.format(\n        url_for('.get_object_id', start=start, span=span, video=video),\n        url_for('.get_object', start=start, span=span, video=video))\n\n\ndef _get_obj_absolute_path(obj_path):\n    return os.path.join(DATAROOT, obj_path)\n\n\ndef _get_index_absolute_path(index):\n    return os.path.join(INDEXDIR, index)\n\n\ndef _ffprobe(video_path):\n    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',\n                '-show_format', video_path]\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    data = json.load(proc.stdout)\n    \n    return data\n\n\ndef _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):\n    \"\"\"\n    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.\n    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.\n    Reference: http://trac.ffmpeg.org/wiki/Seeking\n    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable\n    :param video_path:\n    :param start_sec:\n    :param duration_sec:\n    :return: the subprocess\n    \"\"\"\n    cmd_l = ['ffmpeg', '-v', 'quiet',\n             '-ss', str(start_sec),\n             '-t', str(duration_sec),\n             '-i', str(video_path),\n             '-movflags', 'frag_keyframe+empty_moov',\n             '-c', 'copy',\n             '-f', 'mp4',\n             'pipe:1']\n\n    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)\n    return proc\n", "patch": "@@ -21,6 +21,7 @@\n from flask import Blueprint, Response, request, stream_with_context, url_for\n from opendiamond.dataretriever.util import DiamondTextAttr\n from werkzeug.datastructures import Headers\n+from werkzeug.security import safe_join\n \n # IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.\n \n@@ -122,11 +123,11 @@ def _get_object_element(start, span, video):\n \n \n def _get_obj_absolute_path(obj_path):\n-    return os.path.join(DATAROOT, obj_path)\n+    return safe_join(DATAROOT, obj_path)\n \n \n def _get_index_absolute_path(index):\n-    return os.path.join(INDEXDIR, index)\n+    return safe_join(INDEXDIR, index)\n \n \n def _ffprobe(video_path):", "file_path": "files/2022_7/299", "file_language": "py", "file_name": "opendiamond/dataretriever/video_store.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/cmusatyalab/opendiamond/raw/398049c187ee644beabab44d6fece82251c1ea56/opendiamond%2Fdataretriever%2Fyfcc100m_mysql_store.py", "code": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\"\"\"\nPre-conditions:\nMetadata of a data set is stored in a table <dataset> in a MySQL database.\nFiles (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.\nMySQL table stores relative path to the above directory.\nTable provides keyword search to get list of objects.\nDatabase login info is obtained from DiamondConfig.\nMySQL table is indexed with:\n FULLTEXT (title, keywords, description)\n\nRequires:\npip install mysql-connector-python==8.0.6\n\"\"\"\nimport datetime\nimport os\nfrom flask import Blueprint, url_for, Response, \\\n    stream_with_context, abort, jsonify, send_file\nimport logging\nimport mysql.connector\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import safe_join\nfrom xml.sax.saxutils import quoteattr\n\nBASEURL = 'yfcc100m_mysql'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local path, otherwise http.\nDATAROOT = None\nDB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None\n\n_log = logging.getLogger(__name__)\n\nyfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'\n\n\ndef init(config):\n    global DATAROOT  # pylint: disable=global-statement\n    DATAROOT = config.dataroot\n    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT\n    DB_HOST = config.yfcc100m_db_host\n    DB_DBNAME = config.yfcc100m_db_dbname\n    DB_USER = config.yfcc100m_db_user\n    DB_PASSWORD = config.yfcc100m_db_password\n    DB_PORT = config.yfcc100m_db_port\n\n\nscope_blueprint = Blueprint('mysql_store', __name__)\n\n\n@scope_blueprint.route('/scope/<dataset>')\n@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')\n@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')\n@scope_blueprint.route(\n    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')\ndef get_scope(dataset, keywords=None, divisor=None, expression=None):\n    \"\"\"\n\n    :param expression: Can be \"<3\", \"=3\", \">3\", etc.\n    :param dataset:\n    :param keywords: a string of comma-separated keywords\n    :param divisor: positive int\n    :return:\n    \"\"\"\n    # cursor.execute() can't substitute table name\n    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset\n    conditions = []\n    substitutes = []\n    if keywords:\n        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")\n        substitutes.append(keywords)\n\n    if divisor:\n        # TODO sanity check expression\n        conditions.append(\"(sequence_no % %s) \" + expression)\n        substitutes.extend([divisor])\n\n    if conditions:\n        query += \" WHERE \" + ' AND '.join(conditions)\n\n    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)\n\n    def generate():\n        cnx = mysql.connector.connect(user=DB_USER,\n                                      password=DB_PASSWORD,\n                                      host=DB_HOST,\n                                      database=DB_DBNAME,\n                                      port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, substitutes)\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n        for seq_no, rel_path, download_link in cursor:\n            yield '<count adjust=\"1\"/>\\n'\n            yield _get_object_element(dataset, seq_no, rel_path,\n                                      download_link) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/id/<dataset>/<int:seq_no>')\ndef get_object_id(dataset, seq_no):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(dataset, seq_no, None, None),\n                    \"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')\ndef get_object_src_http(dataset, rel_path):\n    path = _get_obj_absolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n\n\ndef _get_obj_absolute_path(dataset, rel_path):\n    return safe_join(DATAROOT, dataset, rel_path)\n\n\ndef _get_object_element(dataset, seq_no, rel_path, download_link):\n    \"\"\"If rel_path and download_link are not None, we are called from scope.\n    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"\n\n    if rel_path is None:\n        query = \"SELECT rel_path, download_link FROM \" + \\\n        dataset + \\\n        \" WHERE sequence_no = %s\"\n\n        cnx = mysql.connector.connect(user=DB_USER,\n                                    password=DB_PASSWORD,\n                                    host=DB_HOST,\n                                    database=DB_DBNAME,\n                                    port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, (seq_no,))\n\n        row = cursor.fetchone()\n\n        if not row:\n            return None\n\n        rel_path, download_link = row[0], row[1]\n\n    if LOCAL_OBJ_URI:\n        src_uri = 'file://' + _get_obj_absolute_path(dataset, rel_path)\n    else:\n        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)\n\n    return '<object id={} src={} hyperfind.external-link={} />' \\\n        .format(\n        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),\n        quoteattr(src_uri),\n        quoteattr(download_link))\n", "code_before": "#\n#  The OpenDiamond Platform for Interactive Search\n#\n#  Copyright (c) 2018 Carnegie Mellon University\n#  All rights reserved.\n#\n#  This software is distributed under the terms of the Eclipse Public\n#  License, Version 1.0 which can be found in the file named LICENSE.\n#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES\n#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT\n#\n\"\"\"\nPre-conditions:\nMetadata of a data set is stored in a table <dataset> in a MySQL database.\nFiles (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.\nMySQL table stores relative path to the above directory.\nTable provides keyword search to get list of objects.\nDatabase login info is obtained from DiamondConfig.\nMySQL table is indexed with:\n FULLTEXT (title, keywords, description)\n\nRequires:\npip install mysql-connector-python==8.0.6\n\"\"\"\nimport datetime\nimport os\nfrom flask import Blueprint, url_for, Response, \\\n    stream_with_context, abort, jsonify, send_file\nimport logging\nimport mysql.connector\nfrom werkzeug.datastructures import Headers\nfrom xml.sax.saxutils import quoteattr\n\nBASEURL = 'yfcc100m_mysql'\nSTYLE = False\nLOCAL_OBJ_URI = True  # if true, return local path, otherwise http.\nDATAROOT = None\nDB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None\n\n_log = logging.getLogger(__name__)\n\nyfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'\n\n\ndef init(config):\n    global DATAROOT  # pylint: disable=global-statement\n    DATAROOT = config.dataroot\n    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT\n    DB_HOST = config.yfcc100m_db_host\n    DB_DBNAME = config.yfcc100m_db_dbname\n    DB_USER = config.yfcc100m_db_user\n    DB_PASSWORD = config.yfcc100m_db_password\n    DB_PORT = config.yfcc100m_db_port\n\n\nscope_blueprint = Blueprint('mysql_store', __name__)\n\n\n@scope_blueprint.route('/scope/<dataset>')\n@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')\n@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')\n@scope_blueprint.route(\n    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')\ndef get_scope(dataset, keywords=None, divisor=None, expression=None):\n    \"\"\"\n\n    :param expression: Can be \"<3\", \"=3\", \">3\", etc.\n    :param dataset:\n    :param keywords: a string of comma-separated keywords\n    :param divisor: positive int\n    :return:\n    \"\"\"\n    # cursor.execute() can't substitute table name\n    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset\n    conditions = []\n    substitutes = []\n    if keywords:\n        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")\n        substitutes.append(keywords)\n\n    if divisor:\n        # TODO sanity check expression\n        conditions.append(\"(sequence_no % %s) \" + expression)\n        substitutes.extend([divisor])\n\n    if conditions:\n        query += \" WHERE \" + ' AND '.join(conditions)\n\n    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)\n\n    def generate():\n        cnx = mysql.connector.connect(user=DB_USER,\n                                      password=DB_PASSWORD,\n                                      host=DB_HOST,\n                                      database=DB_DBNAME,\n                                      port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, substitutes)\n\n        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n        if STYLE:\n            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'\n\n        yield '<objectlist>\\n'\n        for seq_no, rel_path, download_link in cursor:\n            yield '<count adjust=\"1\"/>\\n'\n            yield _get_object_element(dataset, seq_no, rel_path,\n                                      download_link) + '\\n'\n\n        yield '</objectlist>\\n'\n\n    headers = Headers([('Content-Type', 'text/xml')])\n\n    return Response(stream_with_context(generate()),\n                    status=\"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/id/<dataset>/<int:seq_no>')\ndef get_object_id(dataset, seq_no):\n    headers = Headers([('Content-Type', 'text/xml')])\n    return Response(_get_object_element(dataset, seq_no, None, None),\n                    \"200 OK\",\n                    headers=headers)\n\n@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')\ndef get_object_src_http(dataset, rel_path):\n    path = _get_obj_abosolute_path(dataset, rel_path)\n    response = send_file(path,\n                         cache_timeout=datetime.timedelta(\n                             days=365).total_seconds(),\n                         add_etags=True,\n                         conditional=True)\n    return response\n\n\ndef _get_obj_abosolute_path(dataset, rel_path):\n    return os.path.join(DATAROOT, dataset, rel_path)\n\n\ndef _get_object_element(dataset, seq_no, rel_path, download_link):\n    \"\"\"If rel_path and download_link are not None, we are called from scope.\n    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"\n\n    if rel_path is None:\n        query = \"SELECT rel_path, download_link FROM \" + \\\n        dataset + \\\n        \" WHERE sequence_no = %s\"\n\n        cnx = mysql.connector.connect(user=DB_USER,\n                                    password=DB_PASSWORD,\n                                    host=DB_HOST,\n                                    database=DB_DBNAME,\n                                    port=DB_PORT)\n        cursor = cnx.cursor()\n        cursor.execute(query, (seq_no,))\n\n        row = cursor.fetchone()\n\n        if not row:\n            return None\n\n        rel_path, download_link = row[0], row[1]\n\n    if LOCAL_OBJ_URI:\n        src_uri = 'file://' + os.path.join(DATAROOT, dataset, rel_path)\n    else:\n        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)\n\n    return '<object id={} src={} hyperfind.external-link={} />' \\\n        .format(\n        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),\n        quoteattr(src_uri),\n        quoteattr(download_link))\n", "patch": "@@ -29,6 +29,7 @@\n import logging\n import mysql.connector\n from werkzeug.datastructures import Headers\n+from werkzeug.security import safe_join\n from xml.sax.saxutils import quoteattr\n \n BASEURL = 'yfcc100m_mysql'\n@@ -124,7 +125,7 @@ def get_object_id(dataset, seq_no):\n \n @scope_blueprint.route('/obj/<dataset>/<path:rel_path>')\n def get_object_src_http(dataset, rel_path):\n-    path = _get_obj_abosolute_path(dataset, rel_path)\n+    path = _get_obj_absolute_path(dataset, rel_path)\n     response = send_file(path,\n                          cache_timeout=datetime.timedelta(\n                              days=365).total_seconds(),\n@@ -133,8 +134,8 @@ def get_object_src_http(dataset, rel_path):\n     return response\n \n \n-def _get_obj_abosolute_path(dataset, rel_path):\n-    return os.path.join(DATAROOT, dataset, rel_path)\n+def _get_obj_absolute_path(dataset, rel_path):\n+    return safe_join(DATAROOT, dataset, rel_path)\n \n \n def _get_object_element(dataset, seq_no, rel_path, download_link):\n@@ -162,7 +163,7 @@ def _get_object_element(dataset, seq_no, rel_path, download_link):\n         rel_path, download_link = row[0], row[1]\n \n     if LOCAL_OBJ_URI:\n-        src_uri = 'file://' + os.path.join(DATAROOT, dataset, rel_path)\n+        src_uri = 'file://' + _get_obj_absolute_path(dataset, rel_path)\n     else:\n         src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)\n ", "file_path": "files/2022_7/300", "file_language": "py", "file_name": "opendiamond/dataretriever/yfcc100m_mysql_store.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
