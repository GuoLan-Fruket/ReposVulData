{"index": 36, "cve_id": "CVE-2011-4596", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Multiple directory traversal vulnerabilities in OpenStack Nova before 2011.3.1, when the EC2 API and the S3/RegisterImage image-registration method are enabled, allow remote authenticated users to overwrite arbitrary files via a crafted (1) tarball or (2) manifest.", "cvss": "5.0", "publish_date": "December 23, 2011", "AV": "NETWORK", "AC": "NETWORK", "PR": "LOW", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "LOW", "A": "LOW", "commit_id": "76363226bd8533256f7795bba358d7f4b8a6c9e6", "commit_message": "Sanitize EC2 manifests and image tarballs\n\nPrevent potential directory traversal with malicious EC2 image tarballs,\nby making sure the tarfile is safe before unpacking it. Fixes bug 894755\n\nPrevent potential directory traversal with malicious file names in\nEC2 image manifests. Fixes bug 885167\n\n(cherry picked from commit ad3241929ea00569c74505ed002208ce360c667e)\n\nChange-Id: If6109047307bd6e654ee9d1254f0d7f31cf741c1", "commit_date": "2011-12-13T15:13:07Z", "project": "openstack/nova", "url": "https://api.github.com/repos/openstack/nova/commits/76363226bd8533256f7795bba358d7f4b8a6c9e6", "html_url": "https://github.com/openstack/nova/commit/76363226bd8533256f7795bba358d7f4b8a6c9e6", "windows_before": [{"commit_id": "ad3241929ea00569c74505ed002208ce360c667e", "commit_date": "Thu Dec 1 17:54:16 2011 +0100", "commit_message": "Sanitize EC2 manifests and image tarballs", "files_name": ["MANIFEST.in", "nova/image/s3.py", "nova/tests/image/abs.tar.gz", "nova/tests/image/rel.tar.gz", "nova/tests/image/test_s3.py"]}, {"commit_id": "9ba6beda437faac138cfea4e0ae21656c08ea394", "commit_date": "Mon Dec 12 16:02:36 2011 +0100", "commit_message": "floating-ip: return UUID of instance rather than ID", "files_name": ["nova/api/openstack/v2/contrib/floating_ips.py", "nova/tests/api/openstack/v2/contrib/test_floating_ips.py"]}, {"commit_id": "88b1d7739b5d0fabc613f85f64741321f67bf719", "commit_date": "Tue Dec 6 16:56:12 2011 -0500", "commit_message": "Renaming instance_actions.instance_id column to instance_uuid. blueprint: internal-uuids", "files_name": ["nova/compute/api.py", "nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/db/sqlalchemy/migrate_repo/versions/064_change_instance_id_to_uuid_in_instance_actions.py", "nova/db/sqlalchemy/models.py", "nova/tests/vmwareapi/db_fakes.py", "nova/tests/xenapi/stubs.py", "nova/virt/vmwareapi/vmops.py", "nova/virt/vmwareapi_conn.py", "nova/virt/xenapi/vm_utils.py", "nova/virt/xenapi/vmops.py", "nova/virt/xenapi_conn.py"]}, {"commit_id": "724e5e7a5bc065be239b3ededf0609de386c1d6f", "commit_date": "Mon Dec 12 18:24:26 2011 +0000", "commit_message": "Fix for bug 902175", "files_name": ["nova/network/quantum/manager.py", "nova/network/quantum/quantum_connection.py", "nova/tests/test_quantum.py"]}, {"commit_id": "1c0859283f4e497cc9abea06039f5595406208ef", "commit_date": "Mon Dec 12 17:46:36 2011 -0500", "commit_message": "fixed typos. removed an unused import", "files_name": ["Authors", "nova/manager.py"]}, {"commit_id": "ff753cd608973f5d72a80aef0f9fb8a646fccc3f", "commit_date": "Wed Nov 16 17:31:29 2011 +0000", "commit_message": "Vm state management and error states", "files_name": ["nova/compute/api.py", "nova/compute/manager.py", "nova/compute/state_checker.py", "nova/compute/task_states.py", "nova/compute/vm_states.py", "nova/exception.py", "nova/scheduler/manager.py", "nova/tests/api/ec2/test_cloud.py", "nova/tests/api/openstack/v2/test_servers.py", "nova/tests/scheduler/test_scheduler.py", "nova/tests/test_compute.py"]}, {"commit_id": "bfefe6317fde87f8ca7a4d28bed11d99f7029186", "commit_date": "Sat Oct 29 17:20:08 2011 -0700", "commit_message": "Added support for creating nova volume snapshots using OS API.", "files_name": ["Authors", "nova/api/openstack/v2/contrib/volumes.py", "nova/tests/api/openstack/v2/contrib/test_snapshots.py", "nova/tests/api/openstack/v2/contrib/test_volumes.py", "nova/tests/api/openstack/v2/contrib/test_vsa.py"]}, {"commit_id": "d3b75b75aa937380f04b5320b70c8673821af203", "commit_date": "Mon Dec 12 23:09:06 2011 +0000", "commit_message": "Merge \"Fixing snapshot failure task_state\"", "files_name": ["c032f4588f30d04b6868456fb557daab7986142a - Mon Dec 12 21:23:47 2011 +0000 : Fix error when subnet doesn't have a cidr set", "nova/network/quantum/manager.py"]}, {"commit_id": "b4a2d19aeab547cf1e917beef49ca24019389243", "commit_date": "Mon Dec 12 20:44:54 2011 +0000", "commit_message": "Merge \"Imported Translations from Launchpad\"", "files_name": ["6b6633521c57422dfcdd1c0fbd8004c01bbe99cc - Mon Dec 12 10:34:33 2011 -0800 : bug 899767: fix vif-plugging with live migration", "nova/compute/manager.py", "nova/tests/test_compute.py", "nova/virt/driver.py", "nova/virt/fake.py", "nova/virt/hyperv.py", "nova/virt/libvirt/connection.py", "nova/virt/vmwareapi_conn.py", "nova/virt/xenapi/vmops.py", "nova/virt/xenapi_conn.py"]}, {"commit_id": "b43fa8b590850fd50a85f36da8c3046c3a1c19a0", "commit_date": "Mon Dec 12 16:39:34 2011 +0000", "commit_message": "Merge \"fixed_ips by vif does not raise\"", "files_name": ["b69e89f60c635f1e0fb5e25696e3b5ad26416b56 - Wed Nov 30 09:45:23 2011 +0000 : Fixing snapshot failure task_state", "nova/compute/manager.py", "nova/tests/test_compute.py"]}, {"commit_id": "1b4a0f859e76de4c6e5cb7b51a12e9bf2fb3e295", "commit_date": "Mon Dec 12 00:54:38 2011 +0000", "commit_message": "Merge \"Add preparation for asynchronous instance faults\"", "files_name": ["a4e2ed8cb9ba71e96dfadb96f8171054a0d30914 - Mon Dec 12 00:45:28 2011 +0000 : Merge \"Add templates for selected resource extensions.\"", "5abbbd8726f03cccd280d7eb66f5c56eda228acb - Sun Dec 11 23:02:45 2011 +0000 : Imported Translations from Launchpad", "po/es.po", "po/ko.po", "po/zh_CN.po"]}, {"commit_id": "ce2d62f95cd9b62858c9b4ef37b418881ceaef07", "commit_date": "Sat Dec 10 14:01:17 2011 -0800", "commit_message": "Moves find config to utils because it is useful", "files_name": ["nova/exception.py", "nova/tests/test_wsgi.py", "nova/utils.py", "nova/wsgi.py"]}, {"commit_id": "1e35236519239ef2b4acbb78249502b7bd8ce9b8", "commit_date": "Fri Dec 9 17:53:15 2011 -0600", "commit_message": "fixed_ips by vif does not raise", "files_name": ["nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/exception.py", "nova/network/quantum/nova_ipam_lib.py"]}, {"commit_id": "a33b4d616d8bb877f295383e8649df14c1e19b3c", "commit_date": "Fri Dec 9 15:53:58 2011 -0600", "commit_message": "Add templates for selected resource extensions.", "files_name": ["nova/api/openstack/v2/contrib/virtual_storage_arrays.py", "nova/tests/api/openstack/v2/contrib/test_vsa.py"]}, {"commit_id": "b822159de88e3ec30f85aa4e981dfcd93a582dc9", "commit_date": "Thu Dec 8 04:57:38 2011 +0000", "commit_message": "Fix network forwarding rule initialization in QuantumManager", "files_name": ["nova/network/linux_net.py", "nova/network/quantum/manager.py"]}, {"commit_id": "0c6c7700299e225aee2c86fbe725c8e146b9f0d4", "commit_date": "Fri Dec 9 19:55:12 2011 +0000", "commit_message": "Merge \"_check_image_size returns are consistent\"", "files_name": ["de6a37a7966aff79ec7b0e6f3c9b12235811e122 - Fri Dec 9 19:13:45 2011 +0000 : Merge \"Port nova.flags to cfg\"", "525ff432f8c6584015d0e7255d7b1083e0778e33 - Fri Dec 9 13:06:31 2011 -0600 : _check_image_size returns are consistent", "nova/compute/manager.py"]}, {"commit_id": "02b06b6ee535fd6dbb9b959cf26bf820802ea3c6", "commit_date": "Fri Dec 9 19:05:37 2011 +0000", "commit_message": "Merge \"Fixed the perms on the linux test case file so that nose will run it.\"", "files_name": ["9c34c82cf0e4f3e40b37b7cab37b2d1c88432d5f - Fri Dec 9 18:57:06 2011 +0000 : Merge \"Handle the 'instance' half of blueprint public-and-private-dns\"", "6a3d814d46db9f1eff7b0971cce783653e5bf93d - Fri Dec 9 10:42:30 2011 -0800 : Fixed the perms on the linux test case file so that nose will run it.", "nova/tests/test_linux_net.py"]}, {"commit_id": "2aadaba580f0253d64a69a5cf4127e50346a34fb", "commit_date": "Fri Dec 9 17:31:34 2011 +0000", "commit_message": "Merge \"Add templates for selected resource extensions.\"", "files_name": ["cfe6fe374fa04b9c6150256c9a760b6b340ce697 - Thu Dec 8 14:00:45 2011 -0500 : Add preparation for asynchronous instance faults", "nova/compute/manager.py", "nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/db/sqlalchemy/migrate_repo/versions/063_add_instance_faults_table.py", "nova/db/sqlalchemy/models.py", "nova/tests/test_compute.py", "nova/tests/test_db_api.py"]}, {"commit_id": "f7df18f22715e958510805db42df818ac0f0d243", "commit_date": "Fri Dec 9 10:45:27 2011 -0600", "commit_message": "Add templates for selected resource extensions.", "files_name": ["nova/api/openstack/v2/contrib/security_groups.py", "nova/api/openstack/v2/contrib/simple_tenant_usage.py", "nova/api/openstack/v2/contrib/virtual_interfaces.py", "nova/api/openstack/v2/contrib/volumes.py", "nova/api/openstack/v2/contrib/volumetypes.py", "nova/tests/api/openstack/v2/contrib/test_security_groups.py", "nova/tests/api/openstack/v2/contrib/test_simple_tenant_usage.py", "nova/tests/api/openstack/v2/contrib/test_virtual_interfaces.py", "nova/tests/api/openstack/v2/contrib/test_volume_types.py", "nova/tests/api/openstack/v2/contrib/test_volume_types_extra_specs.py", "nova/tests/api/openstack/v2/contrib/test_volumes.py"]}, {"commit_id": "8920181a0d8cfb4f78af0fa0b868e864d8971744", "commit_date": "Fri Dec 9 11:16:04 2011 -0500", "commit_message": "Use more informative message when violating quota", "files_name": ["nova/api/openstack/v2/servers.py"]}, {"commit_id": "fb479f31c8aa284e6cb739dfb50affed0e0ad564", "commit_date": "Fri Dec 9 16:16:06 2011 +0000", "commit_message": "Merge \"Adds network model and network info cache.\"", "files_name": ["79def336d980a808cdfba5721761cc1b36ce54f9 - Fri Dec 9 15:51:25 2011 +0000 : Merge \"Log it when we get a lock\"", "44a34a288d0ee3c0593c9f2a830c8cc1cba4ae4a - Fri Dec 9 15:36:32 2011 +0000 : Merge \"removing TODO as we support Windows+XenServer and have no plans to support quiesce or VSS at the moment\"", "2562e29d0116661bd5921460b971693ce0cbe863 - Fri Dec 9 14:43:38 2011 +0100 : Log it when we get a lock", "nova/utils.py"]}, {"commit_id": "aa7ca15fc1a7ca28de93ee194870fe6d5e77631b", "commit_date": "Fri Dec 9 06:15:48 2011 +0000", "commit_message": "Merge \"Make QuantumManager no longer depend on the projects table\"", "files_name": ["c64c7691127702131959e57f830c1cd977954e24 - Thu Dec 8 17:51:22 2011 -0600 : removing TODO as we support Windows+XenServer and have no plans to support quiesce or VSS at the moment", ".mailmap", "nova/virt/xenapi/vm_utils.py"]}, {"commit_id": "435d6d8bb5d156eda65a502a610743e569f86173", "commit_date": "Fri Dec 9 00:53:27 2011 +0000", "commit_message": "Merge \"Rename .nova-venv to .venv.\"", "files_name": ["9550ca832c02a72d7877af5c9e60b0e1e8837cf1 - Fri Dec 9 00:35:05 2011 +0000 : Merge \"Make cfg work on python 2.6\"", "d8e84937c19169e3de73e7ad6b7382d954d753ac - Thu Dec 1 16:54:40 2011 -0600 : Adds network model and network info cache.", "nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/db/sqlalchemy/migrate_repo/versions/062_add_instance_info_cache_table.py", "nova/db/sqlalchemy/models.py", "nova/exception.py", "nova/network/model.py", "nova/tests/fake_network_cache_model.py", "nova/tests/test_network_info.py"]}, {"commit_id": "5235106e95681a2942a083aff7c00d385bd10489", "commit_date": "Thu Dec 8 15:14:48 2011 -0800", "commit_message": "Rename .nova-venv to .venv.", "files_name": [".gitignore", ".mailmap", "Authors", "doc/source/devref/development.environment.rst", "run_tests.sh", "tools/install_venv.py", "tools/with_venv.sh"]}, {"commit_id": "0c9a9be3c0297f82990e572fc68c0f1734d79514", "commit_date": "Thu Dec 8 15:12:58 2011 -0800", "commit_message": "revert using git for novaclient", "files_name": ["tools/pip-requires"]}, {"commit_id": "10c829ff39500d68f1e3493f5fa1a4e2f5bc26d6", "commit_date": "Thu Dec 8 23:01:27 2011 +0000", "commit_message": "Merge \"Add ability to see deleted and active records.\"", "files_name": ["51ff598cc8621855e1dbf106d1d68e40ffb865c7 - Mon Nov 28 14:38:35 2011 +0000 : Port nova.flags to cfg", "nova/flags.py", "nova/tests/test_service.py"]}, {"commit_id": "6916c0aed933d200fa8bda02f04d26ef61db1410", "commit_date": "Thu Dec 8 22:43:41 2011 +0000", "commit_message": "Make cfg work on python 2.6", "files_name": ["nova/common/cfg.py", "nova/tests/test_cfg.py"]}, {"commit_id": "20c8d89dbac24b1edadb25becb5065ec735b8643", "commit_date": "Thu Dec 8 13:56:09 2011 -0800", "commit_message": "Relax novaclient and remove redis dependency", "files_name": ["tools/pip-requires"]}, {"commit_id": "d06da5d652ececcefcd0ff1c1dd3fe4cb0cf712b", "commit_date": "Thu Dec 8 11:14:39 2011 -0800", "commit_message": "Relax dependency on boto 1.9b and nova-adminclient", "files_name": ["nova/tests/test_api.py", "smoketests/test_admin.py", "tools/pip-requires"]}, {"commit_id": "bca56ddb3dc931880fa32e23cff35debf7ab365c", "commit_date": "Thu Dec 8 04:30:45 2011 +0000", "commit_message": "Make QuantumManager no longer depend on the projects table", "files_name": ["nova/network/quantum/manager.py", "nova/network/quantum/melange_ipam_lib.py", "nova/network/quantum/nova_ipam_lib.py", "nova/tests/test_quantum.py"]}, {"commit_id": "5a84fd66db675d6ce99254f7c242d02a059a9024", "commit_date": "Thu Dec 8 17:09:08 2011 +0000", "commit_message": "Merge \"Imported Translations from Launchpad\"", "files_name": ["50a195bcca4ecf9313f28fbcd78ad5360d64c711 - Thu Dec 8 15:34:52 2011 +0000 : Merge \"Updated the test runner module with a sys.path insert so that tests run in and outside a virtual environment.\"", "b855336b1351dcffc1bc9690f86563de8c33e656 - Thu Dec 8 15:26:51 2011 +0000 : Merge \"Add new cfg module\"", "4bdee9eb9627093c3f4d42431ed997a30af6a56c - Thu Dec 8 14:51:29 2011 +0000 : Merge \"A more secure root-wrapper alternative\""]}], "windows_after": [{"commit_id": "c9796562a2a25917bc91f7b3cb63c01b2034127b", "commit_date": "Tue Dec 13 17:48:12 2011 +0000", "commit_message": "Merge \"Fix network forwarding rule initialization in QuantumManager\"", "files_name": ["f597dc5548d66530e68ff5809ac2c56b7edbc6d8 - Tue Dec 13 18:05:39 2011 +0000 : Merge \"Fix for bug 902175\"", "15cc877cc2af71135b896974f17cb4a63291a08c - Tue Dec 13 13:45:43 2011 -0500 : Fix tgtadm off by one error. Fixes bug #871278", "nova/virt/libvirt/volume.py", "nova/volume/driver.py"]}, {"commit_id": "073f629d7878078f6294de3771f23b85d72d0286", "commit_date": "Sun Dec 11 20:14:16 2011 +0000", "commit_message": "Fix some errors found by pychecker", "files_name": ["nova/network/quantum/client.py", "nova/network/quantum/melange_ipam_lib.py", "nova/network/quantum/nova_ipam_lib.py", "nova/network/quantum/quantum_connection.py"]}, {"commit_id": "736583fd9f5d166f0c7b0ed9d8556d332cf2bd5b", "commit_date": "Tue Dec 13 14:43:51 2011 -0600", "commit_message": "Make sure the rxtx_cap is used to set qos info", "files_name": ["nova/network/quantum/manager.py", "nova/tests/test_xenapi.py", "nova/virt/xenapi/vif.py"]}, {"commit_id": "bfee1661f6e3d2ef842a8bd347726a09ba25f9df", "commit_date": "Mon Dec 12 19:40:55 2011 -0600", "commit_message": "Follow-on to I665f402f to convert rxtx_quota to rxtx_factor in nova-manage and a couple of tests.", "files_name": ["bin/nova-manage", "nova/tests/test_compute.py", "nova/tests/test_libvirt.py"]}, {"commit_id": "ceb575d70d9e9acd414d29bb7cc9b93523fabd79", "commit_date": "Tue Dec 13 21:32:18 2011 +0000", "commit_message": "Merge \"bug 899767: fix vif-plugging with live migration\"", "files_name": ["9737f407e338ce7154a2acd493405426a7e33076 - Tue Dec 13 21:41:23 2011 +0000 : Merge \"Fix some errors found by pychecker\"", "fd9e0e92af785d1e48ce42ce7eb4501595aabe3c - Tue Dec 13 21:58:30 2011 +0000 : Merge \"Renaming instance_actions.instance_id column to instance_uuid. blueprint: internal-uuids\"", "67490c6b50174a89bce6719dd1b89fee8faa8ab2 - Tue Dec 13 22:08:47 2011 +0000 : Merge \"Fix error when subnet doesn't have a cidr set\"", "6090313757d3fb08cbfad878870537ce56b8def9 - Tue Dec 13 16:34:06 2011 -0600 : Updates OVS rules applied to IPv4 VIFs", "plugins/xenserver/networking/etc/xensource/scripts/ovs_configure_vif_flows.py"]}, {"commit_id": "0514bc9d5e92ed0eb6671349e8ff37d7f58aab85", "commit_date": "Tue Dec 13 23:34:18 2011 +0000", "commit_message": "Refactor vm_state and task_state checking", "files_name": ["nova/compute/api.py", "nova/compute/state_checker.py", "nova/compute/task_states.py", "nova/compute/vm_states.py", "nova/exception.py", "nova/tests/api/ec2/test_cloud.py", "nova/tests/api/openstack/v2/test_servers.py", "nova/tests/integrated/test_servers.py", "nova/tests/test_compute.py"]}, {"commit_id": "5815efb158d8dc7f9f435ce96ab4f4caa599a640", "commit_date": "Sun Dec 11 19:56:39 2011 +0000", "commit_message": "Pass additional information from nova to Quantum", "files_name": ["nova/network/quantum/manager.py", "nova/network/quantum/quantum_connection.py", "nova/tests/test_quantum.py"]}, {"commit_id": "5e6ae0822097f379ee2ee623c4e6213f1d930bf8", "commit_date": "Wed Dec 14 00:54:47 2011 +0000", "commit_message": "Merge \"Follow-on to I665f402f to convert rxtx_quota to rxtx_factor in nova-manage and a couple of tests.\"", "files_name": ["4419badf187acfc100dff1ba05bb1543eab60ba7 - Wed Dec 14 08:42:22 2011 +0000 : Merge \"Fix tgtadm off by one error. Fixes bug #871278\"", "af54e79b7815c233c6e800bc79e428fe23f92eb7 - Wed Dec 14 09:15:10 2011 +0000 : Merge \"Added support for creating nova volume snapshots using OS API.\"", "a04a5fa0cc0f87193502da2e68efe5102aef55b3 - Wed Dec 14 14:41:03 2011 +0100 : Make various methods static", "nova/virt/fake.py", "nova/virt/libvirt/connection.py", "nova/virt/xenapi_conn.py"]}, {"commit_id": "c178043d3021548111a7d7ae4a53210fd96cc1bf", "commit_date": "Wed Dec 14 20:08:24 2011 +0000", "commit_message": "Merge \"Pass additional information from nova to Quantum\"", "files_name": ["7e7abf832316168a01b0f0f10eda9a2ae79074ce - Wed Dec 14 20:44:50 2011 +0000 : Merge \"Make sure the rxtx_cap is used to set qos info\"", "369050f3a3f82460825edd23079f8f35334bdf14 - Wed Dec 14 16:04:46 2011 -0800 : Bug 902626", "nova/db/sqlalchemy/api.py"]}, {"commit_id": "ed1b801a2cc3691cdab6ca2ae95f7299a964d00f", "commit_date": "Tue Dec 13 19:05:21 2011 -0600", "commit_message": "Fixes bug 887402", "files_name": ["nova/utils.py", "nova/virt/libvirt/volume.py"]}, {"commit_id": "31a7924ecfae0b9c9fea0edc344f0e3ca2fe78a5", "commit_date": "Wed Dec 14 14:03:04 2011 -0800", "commit_message": "Refactors handling of detach volume", "files_name": ["nova/compute/manager.py"]}, {"commit_id": "8480d74fa17370fec740fe710f07b1ebc64e2ec2", "commit_date": "Wed Dec 14 20:31:16 2011 -0600", "commit_message": "Making pep8 output less verbose.", "files_name": ["run_tests.sh"]}, {"commit_id": "6b962d16144afa14e2b9fe6cc3f7dc522548a027", "commit_date": "Thu Dec 15 03:02:51 2011 +0000", "commit_message": "Merge \"Make various methods static\"", "files_name": ["8d4208c9a171d2a26a8b1eaf9695d986f7ce7a1c - Thu Dec 15 03:11:41 2011 +0000 : Merge \"floating-ip: return UUID of instance rather than ID\"", "548ae0bdbf70e425dd4aca65f98038c2ae65d1f4 - Thu Dec 15 04:07:19 2011 +0000 : Merge \"Making pep8 output less verbose.\"", "076317047802d3ed393c5467223abd6f613291ba - Thu Dec 15 06:16:18 2011 +0000 : Merge \"Refactors handling of detach volume\"", "ed3b282793ca1675820ff344720cee0c5c8c19ab - Wed Dec 14 11:38:42 2011 +0100 : Make libvirt_uri a property", "nova/tests/test_libvirt.py", "nova/virt/libvirt/connection.py"]}, {"commit_id": "596d433ffa952d79d558c35f32020b5affc72ade", "commit_date": "Thu Dec 15 12:35:25 2011 +0100", "commit_message": "Rename libvirt_uri to uri", "files_name": ["nova/tests/test_libvirt.py", "nova/virt/libvirt/connection.py"]}, {"commit_id": "de815b7f4426134c93ce5910b3401bf036df211d", "commit_date": "Wed Dec 14 22:16:25 2011 -0500", "commit_message": "Update utils.execute so that check_exit_code handles booleans. Fixes LP bug #904560.", "files_name": ["nova/tests/test_utils.py", "nova/utils.py"]}, {"commit_id": "6447e767c7f4bdd95a81b7a3ca276551d89dd163", "commit_date": "Thu Dec 15 14:54:49 2011 +0000", "commit_message": "Merge \"Make libvirt_uri a property\"", "files_name": ["c421328c5697698adfaacdf053efe715646d069a - Thu Dec 15 15:03:39 2011 +0000 : Merge \"Rename libvirt_uri to uri\"", "a72a66c206cd80aa4b392eb42c29e4a1cd4463f9 - Thu Dec 15 15:21:11 2011 +0000 : Switch disk_config extension to use one DB query", "nova/api/openstack/v2/contrib/disk_config.py", "nova/tests/api/openstack/v2/contrib/test_disk_config.py"]}, {"commit_id": "d58c2d2bae97c9193e54056405a8f851051fdada", "commit_date": "Mon Dec 12 18:01:54 2011 +0000", "commit_message": "Make XenAPI agent configuration synchronous", "files_name": ["nova/tests/test_xenapi.py", "nova/virt/xenapi/vmops.py"]}, {"commit_id": "e2875bfadfe78dc2c54be549a0472eefc95b96e4", "commit_date": "Thu Dec 15 16:27:59 2011 +0100", "commit_message": "Remove useless input_chain flags.", "files_name": ["nova/network/linux_net.py"]}, {"commit_id": "36791875b599da16d90578b1b53759f82f8e04bb", "commit_date": "Thu Dec 15 17:04:27 2011 +0100", "commit_message": "Remove useless flags declaration", "files_name": ["bin/nova-dhcpbridge"]}, {"commit_id": "605dfa9dee912eabfb81536031770ad93c0d4389", "commit_date": "Thu Dec 15 17:22:17 2011 +0100", "commit_message": "Fix nova-manage flags declaration", "files_name": ["bin/nova-manage"]}, {"commit_id": "0d71f29583c68c2488d5917f3fdaa7b7011186a1", "commit_date": "Tue Dec 13 15:57:37 2011 -0500", "commit_message": "Expose Asynchronous Fault entity in the OSAPI", "files_name": ["nova/api/openstack/v2/schemas/v1.1/server.rng", "nova/api/openstack/v2/servers.py", "nova/api/openstack/v2/views/servers.py", "nova/compute/api.py", "nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/tests/api/openstack/v2/test_servers.py", "nova/tests/test_compute.py", "nova/tests/test_db_api.py"]}, {"commit_id": "274fd4945546b60be94acb5c7836b362623bd244", "commit_date": "Thu Dec 15 12:59:23 2011 +0100", "commit_message": "nova.virt.libvirt.firewall: set static methods", "files_name": ["nova/virt/libvirt/firewall.py"]}, {"commit_id": "f68abf9b0e3e2ba206c560c19db321c6f88670f1", "commit_date": "Fri Dec 2 14:18:38 2011 +0100", "commit_message": "Fixes bug 723235", "files_name": ["nova/tests/test_utils.py", "nova/utils.py", "nova/virt/libvirt/connection.py"]}, {"commit_id": "ab2f3729360c14ea68cb57181ab5f83a2de53b26", "commit_date": "Thu Dec 15 17:13:16 2011 +0000", "commit_message": "Merge \"Make XenAPI agent configuration synchronous\"", "files_name": ["22040a57b0d5f004025f7b61343c3177a94a7ff7 - Thu Dec 15 17:22:11 2011 +0000 : Merge \"Switch disk_config extension to use one DB query\"", "8eeb132f80acdf3f05edd5594bce54dde5fb789c - Thu Dec 15 18:05:56 2011 +0000 : Merge \"Updates OVS rules applied to IPv4 VIFs\"", "cce41ac10df9aa978e1202f5947d698cd30d9d62 - Thu Dec 15 19:07:35 2011 +0000 : Merge \"Expose Asynchronous Fault entity in the OSAPI\"", "78f4a185bf48cc3366cc4c618ba865a1ae14b9ca - Thu Dec 15 19:33:46 2011 +0000 : Merge \"nova.virt.libvirt.firewall: set static methods\"", "8b52505df5d6f62e3a31a3457832288fd9e450d0 - Thu Dec 15 21:54:07 2011 +0100 : Ensure fkey is dropped before removing instance_id", "nova/db/sqlalchemy/migrate_repo/versions/064_change_instance_id_to_uuid_in_instance_actions.py"]}, {"commit_id": "2fabb67e3c3569a06692c131dec735133a7bb08e", "commit_date": "Thu Dec 15 15:41:32 2011 -0600", "commit_message": "Bugfix for lp904932", "files_name": ["nova/network/linux_net.py", "nova/tests/test_linux_net.py"]}, {"commit_id": "3f7353d14183a93099c99dc2fc72614265f1c72c", "commit_date": "Thu Dec 15 22:55:59 2011 +0000", "commit_message": "Starting work on exposing service functionality.", "files_name": ["nova/db/api.py", "nova/db/sqlalchemy/api.py", "nova/manager.py"]}, {"commit_id": "baf7e02f29600e79eacb6c0f747075afeb74fdd5", "commit_date": "Thu Dec 15 14:16:42 2011 -0800", "commit_message": "Fix scheduler error handler", "files_name": ["nova/compute/api.py", "nova/scheduler/chance.py", "nova/scheduler/distributed_scheduler.py", "nova/scheduler/driver.py", "nova/scheduler/manager.py", "nova/scheduler/simple.py", "nova/tests/scheduler/test_scheduler.py"]}, {"commit_id": "bfd5819ab41bbb240a62fdc702077d053d505b75", "commit_date": "Thu Dec 15 17:19:17 2011 -0800", "commit_message": "use env to find 'false'. Fix for OS X", "files_name": ["nova/tests/test_utils.py"]}, {"commit_id": "d6881c25bdea4ac63c4be1b6f13d77dd159d8910", "commit_date": "Mon Dec 12 16:01:56 2011 +0100", "commit_message": "IPAM drivers aren't homogenous bug 903230", "files_name": ["nova/network/quantum/melange_ipam_lib.py"]}, {"commit_id": "5bec325dca4601c878ffeed70e72bd4611fd3f02", "commit_date": "Fri Dec 16 16:23:05 2011 +0000", "commit_message": "Merge \"Bugfix for lp904932\"", "files_name": ["874a20131856ec4e96664f0a4980d5b8ae6f9f5e - Fri Dec 16 17:35:10 2011 +0000 : Merge \"Fix scheduler error handler\"", "baf05561c4a43a3c361e6e0e9f68767150165244 - Fri Dec 16 11:46:15 2011 -0600 : Pull resource extensions into APIRouter", "nova/api/openstack/v2/__init__.py", "nova/api/openstack/v2/extensions.py", "nova/tests/api/openstack/v2/test_extensions.py", "nova/tests/integrated/test_extensions.py"]}, {"commit_id": "47dccc4b485a948d5b4b95f9c1b1326230cf0e34", "commit_date": "Fri Dec 16 17:51:20 2011 +0000", "commit_message": "Merge \"Fixes bug 723235\"", "files_name": ["e57e4086ae399762ca4a9486afd76b0dc758d027 - Fri Dec 16 18:20:45 2011 +0000 : Merge \"Remove useless input_chain flags.\"", "6bfd2c7990650475cf10d0903ae79cf8fb67dfff - Fri Dec 16 19:11:12 2011 +0000 : Merge \"use env to find 'false'. Fix for OS X\"", "ee34849f091658dbb9adb73b7a31ad3ca85b4a01 - Fri Dec 16 20:04:57 2011 +0000 : Merge \"Pull resource extensions into APIRouter\"", "9b9b6d3076a13f762e0152b8399875e7fbad30db - Fri Dec 16 12:01:59 2011 -0800 : missing comments about extensions to ec2", "nova/api/ec2/cloud.py"]}, {"commit_id": "2f76cd502fcc434b33af8963ac01c2ff6b8c723e", "commit_date": "Fri Dec 16 13:08:56 2011 -0800", "commit_message": "Adds missing joinedload for vif loading.", "files_name": ["nova/db/sqlalchemy/api.py"]}, {"commit_id": "2ea74bab8425338e33e8455f95d9ed208b1166de", "commit_date": "Fri Dec 16 21:10:59 2011 +0000", "commit_message": "Merge \"Fix nova-manage flags declaration\"", "files_name": ["59193f110875026453b69ba0fc51f10692268875 - Fri Dec 16 19:07:30 2011 +0000 : Call get_instance_nw_info with elevated context, as documented in nova/network/manager.py", "nova/compute/api.py", "nova/tests/test_compute.py"]}, {"commit_id": "effb5a38333598877e7f54a8ac1b110fffadae4c", "commit_date": "Fri Dec 16 21:51:27 2011 +0000", "commit_message": "Merge \"Adds missing joinedload for vif loading.\"", "files_name": ["106ea5eda8458b44846207a3df69cf1837789828 - Fri Dec 16 22:46:48 2011 +0000 : Merge \"Call get_instance_nw_info with elevated context, as documented in nova/network/manager.py\"", "fb6850a5b9d7d61a4bb96af8d1cd516fd139c1f8 - Fri Dec 16 16:02:54 2011 -0800 : Makes disassociate by timeout work with multi-host", "nova/db/sqlalchemy/api.py"]}, {"commit_id": "a135c8ecd16bb6a97743e4be1b060daff874879e", "commit_date": "Fri Dec 16 13:40:38 2011 -0800", "commit_message": "Properly passes arg to run_iscsiadm to fix logout", "files_name": ["nova/compute/manager.py", "nova/tests/test_libvirt.py", "nova/virt/libvirt/volume.py"]}, {"commit_id": "f4368e5cdf286d065742e0da1977a3e48c091123", "commit_date": "Tue Dec 13 16:48:05 2011 -0500", "commit_message": "avoid error and trace on dom.vcpus() in lxc", "files_name": ["nova/virt/libvirt/connection.py"]}, {"commit_id": "dc6de5d7dc6f5d923a0fba8a88c2a1a7bbc5599b", "commit_date": "Sun Dec 18 23:03:27 2011 +0000", "commit_message": "Imported Translations from Launchpad", "files_name": ["po/ko.po", "po/tr.po"]}, {"commit_id": "b60fcb547c228b989e20ea1d97b1192af96df3ee", "commit_date": "Mon Dec 19 02:41:22 2011 +0000", "commit_message": "Merge \"IPAM drivers aren't homogenous bug 903230\"", "files_name": ["1314ee08a68e929d87ab5fdbf4cb8c4882bd5bb0 - Sun Dec 18 19:26:37 2011 -0800 : create_export and ensure_export should pass up the return value, to update the database", "nova/volume/san.py"]}, {"commit_id": "de62e9087d55a9c89c9beb132408bf8ff1e57dcd", "commit_date": "Sun Dec 18 19:50:34 2011 -0800", "commit_message": "Specify -t rsa when calling ssh-keygen.", "files_name": ["nova/crypto.py"]}], "parents": [{"commit_id_before": "899277303450d1d96dd835e80c0a076ad5e89c18", "url_before": "https://api.github.com/repos/openstack/nova/commits/899277303450d1d96dd835e80c0a076ad5e89c18", "html_url_before": "https://github.com/openstack/nova/commit/899277303450d1d96dd835e80c0a076ad5e89c18"}], "details": [{"raw_url": "https://github.com/openstack/nova/raw/76363226bd8533256f7795bba358d7f4b8a6c9e6/MANIFEST.in", "code": "include HACKING LICENSE run_tests.py run_tests.sh\ninclude README builddeb.sh exercise_rsapi.py\ninclude ChangeLog MANIFEST.in pylintrc Authors\ngraft nova/CA\ngraft doc\ngraft smoketests\ngraft tools\ngraft etc\ngraft bzrplugins\ngraft contrib\ngraft po\ngraft plugins\ngraft nova/api/openstack/schemas\ninclude nova/api/openstack/notes.txt\ninclude nova/auth/*.schema\ninclude nova/auth/novarc.template\ninclude nova/auth/opendj.sh\ninclude nova/auth/slap.sh\ninclude nova/cloudpipe/bootscript.sh\ninclude nova/cloudpipe/client.ovpn.template\ninclude nova/cloudpipe/bootscript.template\ninclude nova/compute/fakevirtinstance.xml\ninclude nova/compute/interfaces.template\ninclude nova/console/xvp.conf.template\ninclude nova/db/sqlalchemy/migrate_repo/migrate.cfg\ninclude nova/db/sqlalchemy/migrate_repo/README\ninclude nova/db/sqlalchemy/migrate_repo/versions/*.sql\ninclude nova/virt/interfaces.template\ninclude nova/virt/libvirt*.xml.template\ninclude nova/virt/cpuinfo.xml.template\ninclude nova/tests/CA/\ninclude nova/tests/CA/cacert.pem\ninclude nova/tests/CA/private/\ninclude nova/tests/CA/private/cakey.pem\ninclude nova/tests/bundle/\ninclude nova/tests/bundle/1mb.manifest.xml\ninclude nova/tests/bundle/1mb.no_kernel_or_ramdisk.manifest.xml\ninclude nova/tests/bundle/1mb.part.0\ninclude nova/tests/bundle/1mb.part.1\ninclude nova/tests/public_key/*\ninclude nova/tests/db/nova.austin.sqlite\ninclude nova/tests/image/*.tar.gz\ninclude plugins/xenapi/README\ninclude plugins/xenapi/etc/xapi.d/plugins/objectstore\ninclude plugins/xenapi/etc/xapi.d/plugins/pluginlib_nova.py\nglobal-exclude *.pyc\n", "code_before": "include HACKING LICENSE run_tests.py run_tests.sh\ninclude README builddeb.sh exercise_rsapi.py\ninclude ChangeLog MANIFEST.in pylintrc Authors\ngraft nova/CA\ngraft doc\ngraft smoketests\ngraft tools\ngraft etc\ngraft bzrplugins\ngraft contrib\ngraft po\ngraft plugins\ngraft nova/api/openstack/schemas\ninclude nova/api/openstack/notes.txt\ninclude nova/auth/*.schema\ninclude nova/auth/novarc.template\ninclude nova/auth/opendj.sh\ninclude nova/auth/slap.sh\ninclude nova/cloudpipe/bootscript.sh\ninclude nova/cloudpipe/client.ovpn.template\ninclude nova/cloudpipe/bootscript.template\ninclude nova/compute/fakevirtinstance.xml\ninclude nova/compute/interfaces.template\ninclude nova/console/xvp.conf.template\ninclude nova/db/sqlalchemy/migrate_repo/migrate.cfg\ninclude nova/db/sqlalchemy/migrate_repo/README\ninclude nova/db/sqlalchemy/migrate_repo/versions/*.sql\ninclude nova/virt/interfaces.template\ninclude nova/virt/libvirt*.xml.template\ninclude nova/virt/cpuinfo.xml.template\ninclude nova/tests/CA/\ninclude nova/tests/CA/cacert.pem\ninclude nova/tests/CA/private/\ninclude nova/tests/CA/private/cakey.pem\ninclude nova/tests/bundle/\ninclude nova/tests/bundle/1mb.manifest.xml\ninclude nova/tests/bundle/1mb.no_kernel_or_ramdisk.manifest.xml\ninclude nova/tests/bundle/1mb.part.0\ninclude nova/tests/bundle/1mb.part.1\ninclude nova/tests/public_key/*\ninclude nova/tests/db/nova.austin.sqlite\ninclude plugins/xenapi/README\ninclude plugins/xenapi/etc/xapi.d/plugins/objectstore\ninclude plugins/xenapi/etc/xapi.d/plugins/pluginlib_nova.py\nglobal-exclude *.pyc\n", "patch": "@@ -39,6 +39,7 @@ include nova/tests/bundle/1mb.part.0\n include nova/tests/bundle/1mb.part.1\n include nova/tests/public_key/*\n include nova/tests/db/nova.austin.sqlite\n+include nova/tests/image/*.tar.gz\n include plugins/xenapi/README\n include plugins/xenapi/etc/xapi.d/plugins/objectstore\n include plugins/xenapi/etc/xapi.d/plugins/pluginlib_nova.py", "file_path": "files/2011_12/1", "file_language": "in", "file_name": "MANIFEST.in", "outdated_file_modify": 1, "outdated_file_before": 1, "outdated_file_after": 0}, {"raw_url": "https://github.com/openstack/nova/raw/76363226bd8533256f7795bba358d7f4b8a6c9e6/nova%2Fimage%2Fs3.py", "code": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Proxy AMI-related calls from cloud controller to objectstore service.\"\"\"\n\nimport binascii\nimport os\nimport shutil\nimport tarfile\nimport tempfile\nfrom xml.etree import ElementTree\n\nimport boto.s3.connection\nimport eventlet\n\nfrom nova import crypto\nfrom nova import exception\nfrom nova import flags\nfrom nova import image\nfrom nova import log as logging\nfrom nova import utils\nfrom nova.image import service\nfrom nova.api.ec2 import ec2utils\n\n\nLOG = logging.getLogger(\"nova.image.s3\")\nFLAGS = flags.FLAGS\nflags.DEFINE_string('image_decryption_dir', '/tmp',\n                    'parent dir for tempdir used for image decryption')\nflags.DEFINE_string('s3_access_key', 'notchecked',\n                    'access key to use for s3 server for images')\nflags.DEFINE_string('s3_secret_key', 'notchecked',\n                    'secret key to use for s3 server for images')\n\n\nclass S3ImageService(service.BaseImageService):\n    \"\"\"Wraps an existing image service to support s3 based register.\"\"\"\n\n    def __init__(self, service=None, *args, **kwargs):\n        self.service = service or image.get_default_image_service()\n        self.service.__init__(*args, **kwargs)\n\n    def create(self, context, metadata, data=None):\n        \"\"\"Create an image.\n\n        metadata['properties'] should contain image_location.\n\n        \"\"\"\n        image = self._s3_create(context, metadata)\n        return image\n\n    def delete(self, context, image_id):\n        self.service.delete(context, image_id)\n\n    def update(self, context, image_id, metadata, data=None):\n        image = self.service.update(context, image_id, metadata, data)\n        return image\n\n    def index(self, context):\n        return self.service.index(context)\n\n    def detail(self, context):\n        return self.service.detail(context)\n\n    def show(self, context, image_id):\n        return self.service.show(context, image_id)\n\n    def show_by_name(self, context, name):\n        return self.service.show_by_name(context, name)\n\n    @staticmethod\n    def _conn(context):\n        # NOTE(vish): access and secret keys for s3 server are not\n        #             checked in nova-objectstore\n        access = FLAGS.s3_access_key\n        secret = FLAGS.s3_secret_key\n        calling = boto.s3.connection.OrdinaryCallingFormat()\n        return boto.s3.connection.S3Connection(aws_access_key_id=access,\n                                               aws_secret_access_key=secret,\n                                               is_secure=False,\n                                               calling_format=calling,\n                                               port=FLAGS.s3_port,\n                                               host=FLAGS.s3_host)\n\n    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, os.path.basename(filename))\n        key.get_contents_to_filename(local_filename)\n        return local_filename\n\n    def _s3_parse_manifest(self, context, metadata, manifest):\n        manifest = ElementTree.fromstring(manifest)\n        image_format = 'ami'\n        image_type = 'machine'\n\n        try:\n            kernel_id = manifest.find('machine_configuration/kernel_id').text\n            if kernel_id == 'true':\n                image_format = 'aki'\n                image_type = 'kernel'\n                kernel_id = None\n        except Exception:\n            kernel_id = None\n\n        try:\n            ramdisk_id = manifest.find('machine_configuration/ramdisk_id').text\n            if ramdisk_id == 'true':\n                image_format = 'ari'\n                image_type = 'ramdisk'\n                ramdisk_id = None\n        except Exception:\n            ramdisk_id = None\n\n        try:\n            arch = manifest.find('machine_configuration/architecture').text\n        except Exception:\n            arch = 'x86_64'\n\n        # NOTE(yamahata):\n        # EC2 ec2-budlne-image --block-device-mapping accepts\n        # <virtual name>=<device name> where\n        # virtual name = {ami, root, swap, ephemeral<N>}\n        #                where N is no negative integer\n        # device name = the device name seen by guest kernel.\n        # They are converted into\n        # block_device_mapping/mapping/{virtual, device}\n        #\n        # Do NOT confuse this with ec2-register's block device mapping\n        # argument.\n        mappings = []\n        try:\n            block_device_mapping = manifest.findall('machine_configuration/'\n                                                    'block_device_mapping/'\n                                                    'mapping')\n            for bdm in block_device_mapping:\n                mappings.append({'virtual': bdm.find('virtual').text,\n                                 'device': bdm.find('device').text})\n        except Exception:\n            mappings = []\n\n        properties = metadata['properties']\n        properties['project_id'] = context.project_id\n        properties['architecture'] = arch\n\n        if kernel_id:\n            properties['kernel_id'] = ec2utils.ec2_id_to_id(kernel_id)\n\n        if ramdisk_id:\n            properties['ramdisk_id'] = ec2utils.ec2_id_to_id(ramdisk_id)\n\n        if mappings:\n            properties['mappings'] = mappings\n\n        metadata.update({'disk_format': image_format,\n                         'container_format': image_format,\n                         'status': 'queued',\n                         'is_public': False,\n                         'properties': properties})\n        metadata['properties']['image_state'] = 'pending'\n        image = self.service.create(context, metadata)\n        return manifest, image\n\n    def _s3_create(self, context, metadata):\n        \"\"\"Gets a manifext from s3 and makes an image.\"\"\"\n\n        image_path = tempfile.mkdtemp(dir=FLAGS.image_decryption_dir)\n\n        image_location = metadata['properties']['image_location']\n        bucket_name = image_location.split('/')[0]\n        manifest_path = image_location[len(bucket_name) + 1:]\n        bucket = self._conn(context).get_bucket(bucket_name)\n        key = bucket.get_key(manifest_path)\n        manifest = key.get_contents_as_string()\n\n        manifest, image = self._s3_parse_manifest(context, metadata, manifest)\n        image_id = image['id']\n\n        def delayed_create():\n            \"\"\"This handles the fetching and decrypting of the part files.\"\"\"\n            log_vars = {'image_location': image_location,\n                        'image_path': image_path}\n            metadata['properties']['image_state'] = 'downloading'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                parts = []\n                elements = manifest.find('image').getiterator('filename')\n                for fn_element in elements:\n                    part = self._download_file(bucket,\n                                               fn_element.text,\n                                               image_path)\n                    parts.append(part)\n\n                # NOTE(vish): this may be suboptimal, should we use cat?\n                enc_filename = os.path.join(image_path, 'image.encrypted')\n                with open(enc_filename, 'w') as combined:\n                    for filename in parts:\n                        with open(filename) as part:\n                            shutil.copyfileobj(part, combined)\n\n            except Exception:\n                LOG.exception(_(\"Failed to download %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_download'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'decrypting'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                hex_key = manifest.find('image/ec2_encrypted_key').text\n                encrypted_key = binascii.a2b_hex(hex_key)\n                hex_iv = manifest.find('image/ec2_encrypted_iv').text\n                encrypted_iv = binascii.a2b_hex(hex_iv)\n\n                # FIXME(vish): grab key from common service so this can run on\n                #              any host.\n                cloud_pk = crypto.key_path(context.project_id)\n\n                dec_filename = os.path.join(image_path, 'image.tar.gz')\n                self._decrypt_image(enc_filename, encrypted_key,\n                                    encrypted_iv, cloud_pk,\n                                    dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to decrypt %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_decrypt'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'untarring'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                unz_filename = self._untarzip_image(image_path, dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to untar %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_untar'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'uploading'\n            self.service.update(context, image_id, metadata)\n            try:\n                with open(unz_filename) as image_file:\n                    self.service.update(context, image_id,\n                                        metadata, image_file)\n            except Exception:\n                LOG.exception(_(\"Failed to upload %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_upload'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'available'\n            metadata['status'] = 'active'\n            self.service.update(context, image_id, metadata)\n\n            shutil.rmtree(image_path)\n\n        eventlet.spawn_n(delayed_create)\n\n        return image\n\n    @staticmethod\n    def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                       cloud_private_key, decrypted_filename):\n        key, err = utils.execute('openssl',\n                                 'rsautl',\n                                 '-decrypt',\n                                 '-inkey', '%s' % cloud_private_key,\n                                 process_input=encrypted_key,\n                                 check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt private key: %s')\n                                  % err)\n        iv, err = utils.execute('openssl',\n                                'rsautl',\n                                '-decrypt',\n                                '-inkey', '%s' % cloud_private_key,\n                                process_input=encrypted_iv,\n                                check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt initialization '\n                                    'vector: %s') % err)\n\n        _out, err = utils.execute('openssl', 'enc',\n                                  '-d', '-aes-128-cbc',\n                                  '-in', '%s' % (encrypted_filename,),\n                                  '-K', '%s' % (key,),\n                                  '-iv', '%s' % (iv,),\n                                  '-out', '%s' % (decrypted_filename,),\n                                  check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt image file '\n                                    '%(image_file)s: %(err)s') %\n                                    {'image_file': encrypted_filename,\n                                     'err': err})\n\n    @staticmethod\n    def _test_for_malicious_tarball(path, filename):\n        \"\"\"Raises exception if extracting tarball would escape extract path\"\"\"\n        tar_file = tarfile.open(filename, 'r|gz')\n        for n in tar_file.getnames():\n            if not os.path.abspath(os.path.join(path, n)).startswith(path):\n                tar_file.close()\n                raise exception.Error(_('Unsafe filenames in image'))\n        tar_file.close()\n\n    @staticmethod\n    def _untarzip_image(path, filename):\n        S3ImageService._test_for_malicious_tarball(path, filename)\n        tar_file = tarfile.open(filename, 'r|gz')\n        tar_file.extractall(path)\n        image_file = tar_file.getnames()[0]\n        tar_file.close()\n        return os.path.join(path, image_file)\n", "code_before": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Proxy AMI-related calls from cloud controller to objectstore service.\"\"\"\n\nimport binascii\nimport os\nimport shutil\nimport tarfile\nimport tempfile\nfrom xml.etree import ElementTree\n\nimport boto.s3.connection\nimport eventlet\n\nfrom nova import crypto\nfrom nova import exception\nfrom nova import flags\nfrom nova import image\nfrom nova import log as logging\nfrom nova import utils\nfrom nova.image import service\nfrom nova.api.ec2 import ec2utils\n\n\nLOG = logging.getLogger(\"nova.image.s3\")\nFLAGS = flags.FLAGS\nflags.DEFINE_string('image_decryption_dir', '/tmp',\n                    'parent dir for tempdir used for image decryption')\nflags.DEFINE_string('s3_access_key', 'notchecked',\n                    'access key to use for s3 server for images')\nflags.DEFINE_string('s3_secret_key', 'notchecked',\n                    'secret key to use for s3 server for images')\n\n\nclass S3ImageService(service.BaseImageService):\n    \"\"\"Wraps an existing image service to support s3 based register.\"\"\"\n\n    def __init__(self, service=None, *args, **kwargs):\n        self.service = service or image.get_default_image_service()\n        self.service.__init__(*args, **kwargs)\n\n    def create(self, context, metadata, data=None):\n        \"\"\"Create an image.\n\n        metadata['properties'] should contain image_location.\n\n        \"\"\"\n        image = self._s3_create(context, metadata)\n        return image\n\n    def delete(self, context, image_id):\n        self.service.delete(context, image_id)\n\n    def update(self, context, image_id, metadata, data=None):\n        image = self.service.update(context, image_id, metadata, data)\n        return image\n\n    def index(self, context):\n        return self.service.index(context)\n\n    def detail(self, context):\n        return self.service.detail(context)\n\n    def show(self, context, image_id):\n        return self.service.show(context, image_id)\n\n    def show_by_name(self, context, name):\n        return self.service.show_by_name(context, name)\n\n    @staticmethod\n    def _conn(context):\n        # NOTE(vish): access and secret keys for s3 server are not\n        #             checked in nova-objectstore\n        access = FLAGS.s3_access_key\n        secret = FLAGS.s3_secret_key\n        calling = boto.s3.connection.OrdinaryCallingFormat()\n        return boto.s3.connection.S3Connection(aws_access_key_id=access,\n                                               aws_secret_access_key=secret,\n                                               is_secure=False,\n                                               calling_format=calling,\n                                               port=FLAGS.s3_port,\n                                               host=FLAGS.s3_host)\n\n    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, filename)\n        key.get_contents_to_filename(local_filename)\n        return local_filename\n\n    def _s3_parse_manifest(self, context, metadata, manifest):\n        manifest = ElementTree.fromstring(manifest)\n        image_format = 'ami'\n        image_type = 'machine'\n\n        try:\n            kernel_id = manifest.find('machine_configuration/kernel_id').text\n            if kernel_id == 'true':\n                image_format = 'aki'\n                image_type = 'kernel'\n                kernel_id = None\n        except Exception:\n            kernel_id = None\n\n        try:\n            ramdisk_id = manifest.find('machine_configuration/ramdisk_id').text\n            if ramdisk_id == 'true':\n                image_format = 'ari'\n                image_type = 'ramdisk'\n                ramdisk_id = None\n        except Exception:\n            ramdisk_id = None\n\n        try:\n            arch = manifest.find('machine_configuration/architecture').text\n        except Exception:\n            arch = 'x86_64'\n\n        # NOTE(yamahata):\n        # EC2 ec2-budlne-image --block-device-mapping accepts\n        # <virtual name>=<device name> where\n        # virtual name = {ami, root, swap, ephemeral<N>}\n        #                where N is no negative integer\n        # device name = the device name seen by guest kernel.\n        # They are converted into\n        # block_device_mapping/mapping/{virtual, device}\n        #\n        # Do NOT confuse this with ec2-register's block device mapping\n        # argument.\n        mappings = []\n        try:\n            block_device_mapping = manifest.findall('machine_configuration/'\n                                                    'block_device_mapping/'\n                                                    'mapping')\n            for bdm in block_device_mapping:\n                mappings.append({'virtual': bdm.find('virtual').text,\n                                 'device': bdm.find('device').text})\n        except Exception:\n            mappings = []\n\n        properties = metadata['properties']\n        properties['project_id'] = context.project_id\n        properties['architecture'] = arch\n\n        if kernel_id:\n            properties['kernel_id'] = ec2utils.ec2_id_to_id(kernel_id)\n\n        if ramdisk_id:\n            properties['ramdisk_id'] = ec2utils.ec2_id_to_id(ramdisk_id)\n\n        if mappings:\n            properties['mappings'] = mappings\n\n        metadata.update({'disk_format': image_format,\n                         'container_format': image_format,\n                         'status': 'queued',\n                         'is_public': False,\n                         'properties': properties})\n        metadata['properties']['image_state'] = 'pending'\n        image = self.service.create(context, metadata)\n        return manifest, image\n\n    def _s3_create(self, context, metadata):\n        \"\"\"Gets a manifext from s3 and makes an image.\"\"\"\n\n        image_path = tempfile.mkdtemp(dir=FLAGS.image_decryption_dir)\n\n        image_location = metadata['properties']['image_location']\n        bucket_name = image_location.split('/')[0]\n        manifest_path = image_location[len(bucket_name) + 1:]\n        bucket = self._conn(context).get_bucket(bucket_name)\n        key = bucket.get_key(manifest_path)\n        manifest = key.get_contents_as_string()\n\n        manifest, image = self._s3_parse_manifest(context, metadata, manifest)\n        image_id = image['id']\n\n        def delayed_create():\n            \"\"\"This handles the fetching and decrypting of the part files.\"\"\"\n            log_vars = {'image_location': image_location,\n                        'image_path': image_path}\n            metadata['properties']['image_state'] = 'downloading'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                parts = []\n                elements = manifest.find('image').getiterator('filename')\n                for fn_element in elements:\n                    part = self._download_file(bucket,\n                                               fn_element.text,\n                                               image_path)\n                    parts.append(part)\n\n                # NOTE(vish): this may be suboptimal, should we use cat?\n                enc_filename = os.path.join(image_path, 'image.encrypted')\n                with open(enc_filename, 'w') as combined:\n                    for filename in parts:\n                        with open(filename) as part:\n                            shutil.copyfileobj(part, combined)\n\n            except Exception:\n                LOG.exception(_(\"Failed to download %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_download'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'decrypting'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                hex_key = manifest.find('image/ec2_encrypted_key').text\n                encrypted_key = binascii.a2b_hex(hex_key)\n                hex_iv = manifest.find('image/ec2_encrypted_iv').text\n                encrypted_iv = binascii.a2b_hex(hex_iv)\n\n                # FIXME(vish): grab key from common service so this can run on\n                #              any host.\n                cloud_pk = crypto.key_path(context.project_id)\n\n                dec_filename = os.path.join(image_path, 'image.tar.gz')\n                self._decrypt_image(enc_filename, encrypted_key,\n                                    encrypted_iv, cloud_pk,\n                                    dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to decrypt %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_decrypt'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'untarring'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                unz_filename = self._untarzip_image(image_path, dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to untar %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_untar'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'uploading'\n            self.service.update(context, image_id, metadata)\n            try:\n                with open(unz_filename) as image_file:\n                    self.service.update(context, image_id,\n                                        metadata, image_file)\n            except Exception:\n                LOG.exception(_(\"Failed to upload %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_upload'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'available'\n            metadata['status'] = 'active'\n            self.service.update(context, image_id, metadata)\n\n            shutil.rmtree(image_path)\n\n        eventlet.spawn_n(delayed_create)\n\n        return image\n\n    @staticmethod\n    def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                       cloud_private_key, decrypted_filename):\n        key, err = utils.execute('openssl',\n                                 'rsautl',\n                                 '-decrypt',\n                                 '-inkey', '%s' % cloud_private_key,\n                                 process_input=encrypted_key,\n                                 check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt private key: %s')\n                                  % err)\n        iv, err = utils.execute('openssl',\n                                'rsautl',\n                                '-decrypt',\n                                '-inkey', '%s' % cloud_private_key,\n                                process_input=encrypted_iv,\n                                check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt initialization '\n                                    'vector: %s') % err)\n\n        _out, err = utils.execute('openssl', 'enc',\n                                  '-d', '-aes-128-cbc',\n                                  '-in', '%s' % (encrypted_filename,),\n                                  '-K', '%s' % (key,),\n                                  '-iv', '%s' % (iv,),\n                                  '-out', '%s' % (decrypted_filename,),\n                                  check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt image file '\n                                    '%(image_file)s: %(err)s') %\n                                    {'image_file': encrypted_filename,\n                                     'err': err})\n\n    @staticmethod\n    def _untarzip_image(path, filename):\n        tar_file = tarfile.open(filename, 'r|gz')\n        tar_file.extractall(path)\n        image_file = tar_file.getnames()[0]\n        tar_file.close()\n        return os.path.join(path, image_file)\n", "patch": "@@ -100,7 +100,7 @@ def _conn(context):\n     @staticmethod\n     def _download_file(bucket, filename, local_dir):\n         key = bucket.get_key(filename)\n-        local_filename = os.path.join(local_dir, filename)\n+        local_filename = os.path.join(local_dir, os.path.basename(filename))\n         key.get_contents_to_filename(local_filename)\n         return local_filename\n \n@@ -315,8 +315,19 @@ def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                                     {'image_file': encrypted_filename,\n                                      'err': err})\n \n+    @staticmethod\n+    def _test_for_malicious_tarball(path, filename):\n+        \"\"\"Raises exception if extracting tarball would escape extract path\"\"\"\n+        tar_file = tarfile.open(filename, 'r|gz')\n+        for n in tar_file.getnames():\n+            if not os.path.abspath(os.path.join(path, n)).startswith(path):\n+                tar_file.close()\n+                raise exception.Error(_('Unsafe filenames in image'))\n+        tar_file.close()\n+\n     @staticmethod\n     def _untarzip_image(path, filename):\n+        S3ImageService._test_for_malicious_tarball(path, filename)\n         tar_file = tarfile.open(filename, 'r|gz')\n         tar_file.extractall(path)\n         image_file = tar_file.getnames()[0]", "file_path": "files/2011_12/2", "file_language": "py", "file_name": "nova/image/s3.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 1, "static": {"rats": [false, []], "semgrep": [true, ["       trailofbits.python.tarfile-extractall-traversal.tarfile-extractall-traversal              \n          Possible path traversal through `tarfile.open($PATH).extractall()` if the source tar is\n          controlled by an attacker                                                              \n          Details: https://sg.run/2RLD                                                           \n\n          320\u2506 tar_file = tarfile.open(filename, 'r|gz')          321\u2506 tar_file.extractall(path)"]]}, "target": 1, "function_before": [{"function": "class S3ImageService(service.BaseImageService):\n    \"\"\"Wraps an existing image service to support s3 based register.\"\"\"\n\n    def __init__(self, service=None, *args, **kwargs):\n        self.service = service or image.get_default_image_service()\n        self.service.__init__(*args, **kwargs)\n\n    def create(self, context, metadata, data=None):\n        \"\"\"Create an image.\n\n        metadata['properties'] should contain image_location.\n\n        \"\"\"\n        image = self._s3_create(context, metadata)\n        return image\n\n    def delete(self, context, image_id):\n        self.service.delete(context, image_id)\n\n    def update(self, context, image_id, metadata, data=None):\n        image = self.service.update(context, image_id, metadata, data)\n        return image\n\n    def index(self, context):\n        return self.service.index(context)\n\n    def detail(self, context):\n        return self.service.detail(context)\n\n    def show(self, context, image_id):\n        return self.service.show(context, image_id)\n\n    def show_by_name(self, context, name):\n        return self.service.show_by_name(context, name)\n\n    @staticmethod\n    def _conn(context):\n        # NOTE(vish): access and secret keys for s3 server are not\n        #             checked in nova-objectstore\n        access = FLAGS.s3_access_key\n        secret = FLAGS.s3_secret_key\n        calling = boto.s3.connection.OrdinaryCallingFormat()\n        return boto.s3.connection.S3Connection(aws_access_key_id=access,\n                                               aws_secret_access_key=secret,\n                                               is_secure=False,\n                                               calling_format=calling,\n                                               port=FLAGS.s3_port,\n                                               host=FLAGS.s3_host)\n\n    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, filename)\n        key.get_contents_to_filename(local_filename)\n        return local_filename\n\n    def _s3_parse_manifest(self, context, metadata, manifest):\n        manifest = ElementTree.fromstring(manifest)\n        image_format = 'ami'\n        image_type = 'machine'\n\n        try:\n            kernel_id = manifest.find('machine_configuration/kernel_id').text\n            if kernel_id == 'true':\n                image_format = 'aki'\n                image_type = 'kernel'\n                kernel_id = None\n        except Exception:\n            kernel_id = None\n\n        try:\n            ramdisk_id = manifest.find('machine_configuration/ramdisk_id').text\n            if ramdisk_id == 'true':\n                image_format = 'ari'\n                image_type = 'ramdisk'\n                ramdisk_id = None\n        except Exception:\n            ramdisk_id = None\n\n        try:\n            arch = manifest.find('machine_configuration/architecture').text\n        except Exception:\n            arch = 'x86_64'\n\n        # NOTE(yamahata):\n        # EC2 ec2-budlne-image --block-device-mapping accepts\n        # <virtual name>=<device name> where\n        # virtual name = {ami, root, swap, ephemeral<N>}\n        #                where N is no negative integer\n        # device name = the device name seen by guest kernel.\n        # They are converted into\n        # block_device_mapping/mapping/{virtual, device}\n        #\n        # Do NOT confuse this with ec2-register's block device mapping\n        # argument.\n        mappings = []\n        try:\n            block_device_mapping = manifest.findall('machine_configuration/'\n                                                    'block_device_mapping/'\n                                                    'mapping')\n            for bdm in block_device_mapping:\n                mappings.append({'virtual': bdm.find('virtual').text,\n                                 'device': bdm.find('device').text})\n        except Exception:\n            mappings = []\n\n        properties = metadata['properties']\n        properties['project_id'] = context.project_id\n        properties['architecture'] = arch\n\n        if kernel_id:\n            properties['kernel_id'] = ec2utils.ec2_id_to_id(kernel_id)\n\n        if ramdisk_id:\n            properties['ramdisk_id'] = ec2utils.ec2_id_to_id(ramdisk_id)\n\n        if mappings:\n            properties['mappings'] = mappings\n\n        metadata.update({'disk_format': image_format,\n                         'container_format': image_format,\n                         'status': 'queued',\n                         'is_public': False,\n                         'properties': properties})\n        metadata['properties']['image_state'] = 'pending'\n        image = self.service.create(context, metadata)\n        return manifest, image\n\n    def _s3_create(self, context, metadata):\n        \"\"\"Gets a manifext from s3 and makes an image.\"\"\"\n\n        image_path = tempfile.mkdtemp(dir=FLAGS.image_decryption_dir)\n\n        image_location = metadata['properties']['image_location']\n        bucket_name = image_location.split('/')[0]\n        manifest_path = image_location[len(bucket_name) + 1:]\n        bucket = self._conn(context).get_bucket(bucket_name)\n        key = bucket.get_key(manifest_path)\n        manifest = key.get_contents_as_string()\n\n        manifest, image = self._s3_parse_manifest(context, metadata, manifest)\n        image_id = image['id']\n\n        def delayed_create():\n            \"\"\"This handles the fetching and decrypting of the part files.\"\"\"\n            log_vars = {'image_location': image_location,\n                        'image_path': image_path}\n            metadata['properties']['image_state'] = 'downloading'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                parts = []\n                elements = manifest.find('image').getiterator('filename')\n                for fn_element in elements:\n                    part = self._download_file(bucket,\n                                               fn_element.text,\n                                               image_path)\n                    parts.append(part)\n\n                # NOTE(vish): this may be suboptimal, should we use cat?\n                enc_filename = os.path.join(image_path, 'image.encrypted')\n                with open(enc_filename, 'w') as combined:\n                    for filename in parts:\n                        with open(filename) as part:\n                            shutil.copyfileobj(part, combined)\n\n            except Exception:\n                LOG.exception(_(\"Failed to download %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_download'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'decrypting'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                hex_key = manifest.find('image/ec2_encrypted_key').text\n                encrypted_key = binascii.a2b_hex(hex_key)\n                hex_iv = manifest.find('image/ec2_encrypted_iv').text\n                encrypted_iv = binascii.a2b_hex(hex_iv)\n\n                # FIXME(vish): grab key from common service so this can run on\n                #              any host.\n                cloud_pk = crypto.key_path(context.project_id)\n\n                dec_filename = os.path.join(image_path, 'image.tar.gz')\n                self._decrypt_image(enc_filename, encrypted_key,\n                                    encrypted_iv, cloud_pk,\n                                    dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to decrypt %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_decrypt'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'untarring'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                unz_filename = self._untarzip_image(image_path, dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to untar %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_untar'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'uploading'\n            self.service.update(context, image_id, metadata)\n            try:\n                with open(unz_filename) as image_file:\n                    self.service.update(context, image_id,\n                                        metadata, image_file)\n            except Exception:\n                LOG.exception(_(\"Failed to upload %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_upload'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'available'\n            metadata['status'] = 'active'\n            self.service.update(context, image_id, metadata)\n\n            shutil.rmtree(image_path)\n\n        eventlet.spawn_n(delayed_create)\n\n        return image\n\n    @staticmethod\n    def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                       cloud_private_key, decrypted_filename):\n        key, err = utils.execute('openssl',\n                                 'rsautl',\n                                 '-decrypt',\n                                 '-inkey', '%s' % cloud_private_key,\n                                 process_input=encrypted_key,\n                                 check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt private key: %s')\n                                  % err)\n        iv, err = utils.execute('openssl',\n                                'rsautl',\n                                '-decrypt',\n                                '-inkey', '%s' % cloud_private_key,\n                                process_input=encrypted_iv,\n                                check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt initialization '\n                                    'vector: %s') % err)\n\n        _out, err = utils.execute('openssl', 'enc',\n                                  '-d', '-aes-128-cbc',\n                                  '-in', '%s' % (encrypted_filename,),\n                                  '-K', '%s' % (key,),\n                                  '-iv', '%s' % (iv,),\n                                  '-out', '%s' % (decrypted_filename,),\n                                  check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt image file '\n                                    '%(image_file)s: %(err)s') %\n                                    {'image_file': encrypted_filename,\n                                     'err': err})\n\n    @staticmethod\n    def _untarzip_image(path, filename):\n        tar_file = tarfile.open(filename, 'r|gz')\n        tar_file.extractall(path)\n        image_file = tar_file.getnames()[0]\n        tar_file.close()\n        return os.path.join(path, image_file)", "target": 1, "line": "@@  -100,7 +100,7  @@ def _conn(context):\n     @staticmethod\n     def _download_file(bucket, filename, local_dir):\n         key = bucket.get_key(filename)\n-        local_filename = os.path.join(local_dir, filename)\n+        local_filename = os.path.join(local_dir, os.path.basename(filename))\n         key.get_contents_to_filename(local_filename)\n         return local_filename\n \n@@  -315,8 +315,19  @@ def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                                     {'image_file': encrypted_filename,\n                                      'err': err})\n \n+    @staticmethod\n+    def _test_for_malicious_tarball(path, filename):\n+        \"\"\"Raises exception if extracting tarball would escape extract path\"\"\"\n+        tar_file = tarfile.open(filename, 'r|gz')\n+        for n in tar_file.getnames():\n+            if not os.path.abspath(os.path.join(path, n)).startswith(path):\n+                tar_file.close()\n+                raise exception.Error(_('Unsafe filenames in image'))\n+        tar_file.close()\n+\n     @staticmethod\n     def _untarzip_image(path, filename):\n+        S3ImageService._test_for_malicious_tarball(path, filename)\n         tar_file = tarfile.open(filename, 'r|gz')\n         tar_file.extractall(path)\n         image_file = tar_file.getnames()[0]"}], "function_after": [{"function": "class S3ImageService(service.BaseImageService):\n    \"\"\"Wraps an existing image service to support s3 based register.\"\"\"\n\n    def __init__(self, service=None, *args, **kwargs):\n        self.service = service or image.get_default_image_service()\n        self.service.__init__(*args, **kwargs)\n\n    def create(self, context, metadata, data=None):\n        \"\"\"Create an image.\n\n        metadata['properties'] should contain image_location.\n\n        \"\"\"\n        image = self._s3_create(context, metadata)\n        return image\n\n    def delete(self, context, image_id):\n        self.service.delete(context, image_id)\n\n    def update(self, context, image_id, metadata, data=None):\n        image = self.service.update(context, image_id, metadata, data)\n        return image\n\n    def index(self, context):\n        return self.service.index(context)\n\n    def detail(self, context):\n        return self.service.detail(context)\n\n    def show(self, context, image_id):\n        return self.service.show(context, image_id)\n\n    def show_by_name(self, context, name):\n        return self.service.show_by_name(context, name)\n\n    @staticmethod\n    def _conn(context):\n        # NOTE(vish): access and secret keys for s3 server are not\n        #             checked in nova-objectstore\n        access = FLAGS.s3_access_key\n        secret = FLAGS.s3_secret_key\n        calling = boto.s3.connection.OrdinaryCallingFormat()\n        return boto.s3.connection.S3Connection(aws_access_key_id=access,\n                                               aws_secret_access_key=secret,\n                                               is_secure=False,\n                                               calling_format=calling,\n                                               port=FLAGS.s3_port,\n                                               host=FLAGS.s3_host)\n\n    @staticmethod\n    def _download_file(bucket, filename, local_dir):\n        key = bucket.get_key(filename)\n        local_filename = os.path.join(local_dir, os.path.basename(filename))\n        key.get_contents_to_filename(local_filename)\n        return local_filename\n\n    def _s3_parse_manifest(self, context, metadata, manifest):\n        manifest = ElementTree.fromstring(manifest)\n        image_format = 'ami'\n        image_type = 'machine'\n\n        try:\n            kernel_id = manifest.find('machine_configuration/kernel_id').text\n            if kernel_id == 'true':\n                image_format = 'aki'\n                image_type = 'kernel'\n                kernel_id = None\n        except Exception:\n            kernel_id = None\n\n        try:\n            ramdisk_id = manifest.find('machine_configuration/ramdisk_id').text\n            if ramdisk_id == 'true':\n                image_format = 'ari'\n                image_type = 'ramdisk'\n                ramdisk_id = None\n        except Exception:\n            ramdisk_id = None\n\n        try:\n            arch = manifest.find('machine_configuration/architecture').text\n        except Exception:\n            arch = 'x86_64'\n\n        # NOTE(yamahata):\n        # EC2 ec2-budlne-image --block-device-mapping accepts\n        # <virtual name>=<device name> where\n        # virtual name = {ami, root, swap, ephemeral<N>}\n        #                where N is no negative integer\n        # device name = the device name seen by guest kernel.\n        # They are converted into\n        # block_device_mapping/mapping/{virtual, device}\n        #\n        # Do NOT confuse this with ec2-register's block device mapping\n        # argument.\n        mappings = []\n        try:\n            block_device_mapping = manifest.findall('machine_configuration/'\n                                                    'block_device_mapping/'\n                                                    'mapping')\n            for bdm in block_device_mapping:\n                mappings.append({'virtual': bdm.find('virtual').text,\n                                 'device': bdm.find('device').text})\n        except Exception:\n            mappings = []\n\n        properties = metadata['properties']\n        properties['project_id'] = context.project_id\n        properties['architecture'] = arch\n\n        if kernel_id:\n            properties['kernel_id'] = ec2utils.ec2_id_to_id(kernel_id)\n\n        if ramdisk_id:\n            properties['ramdisk_id'] = ec2utils.ec2_id_to_id(ramdisk_id)\n\n        if mappings:\n            properties['mappings'] = mappings\n\n        metadata.update({'disk_format': image_format,\n                         'container_format': image_format,\n                         'status': 'queued',\n                         'is_public': False,\n                         'properties': properties})\n        metadata['properties']['image_state'] = 'pending'\n        image = self.service.create(context, metadata)\n        return manifest, image\n\n    def _s3_create(self, context, metadata):\n        \"\"\"Gets a manifext from s3 and makes an image.\"\"\"\n\n        image_path = tempfile.mkdtemp(dir=FLAGS.image_decryption_dir)\n\n        image_location = metadata['properties']['image_location']\n        bucket_name = image_location.split('/')[0]\n        manifest_path = image_location[len(bucket_name) + 1:]\n        bucket = self._conn(context).get_bucket(bucket_name)\n        key = bucket.get_key(manifest_path)\n        manifest = key.get_contents_as_string()\n\n        manifest, image = self._s3_parse_manifest(context, metadata, manifest)\n        image_id = image['id']\n\n        def delayed_create():\n            \"\"\"This handles the fetching and decrypting of the part files.\"\"\"\n            log_vars = {'image_location': image_location,\n                        'image_path': image_path}\n            metadata['properties']['image_state'] = 'downloading'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                parts = []\n                elements = manifest.find('image').getiterator('filename')\n                for fn_element in elements:\n                    part = self._download_file(bucket,\n                                               fn_element.text,\n                                               image_path)\n                    parts.append(part)\n\n                # NOTE(vish): this may be suboptimal, should we use cat?\n                enc_filename = os.path.join(image_path, 'image.encrypted')\n                with open(enc_filename, 'w') as combined:\n                    for filename in parts:\n                        with open(filename) as part:\n                            shutil.copyfileobj(part, combined)\n\n            except Exception:\n                LOG.exception(_(\"Failed to download %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_download'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'decrypting'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                hex_key = manifest.find('image/ec2_encrypted_key').text\n                encrypted_key = binascii.a2b_hex(hex_key)\n                hex_iv = manifest.find('image/ec2_encrypted_iv').text\n                encrypted_iv = binascii.a2b_hex(hex_iv)\n\n                # FIXME(vish): grab key from common service so this can run on\n                #              any host.\n                cloud_pk = crypto.key_path(context.project_id)\n\n                dec_filename = os.path.join(image_path, 'image.tar.gz')\n                self._decrypt_image(enc_filename, encrypted_key,\n                                    encrypted_iv, cloud_pk,\n                                    dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to decrypt %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_decrypt'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'untarring'\n            self.service.update(context, image_id, metadata)\n\n            try:\n                unz_filename = self._untarzip_image(image_path, dec_filename)\n            except Exception:\n                LOG.exception(_(\"Failed to untar %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_untar'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'uploading'\n            self.service.update(context, image_id, metadata)\n            try:\n                with open(unz_filename) as image_file:\n                    self.service.update(context, image_id,\n                                        metadata, image_file)\n            except Exception:\n                LOG.exception(_(\"Failed to upload %(image_location)s \"\n                                \"to %(image_path)s\"), log_vars)\n                metadata['properties']['image_state'] = 'failed_upload'\n                self.service.update(context, image_id, metadata)\n                return\n\n            metadata['properties']['image_state'] = 'available'\n            metadata['status'] = 'active'\n            self.service.update(context, image_id, metadata)\n\n            shutil.rmtree(image_path)\n\n        eventlet.spawn_n(delayed_create)\n\n        return image\n\n    @staticmethod\n    def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,\n                       cloud_private_key, decrypted_filename):\n        key, err = utils.execute('openssl',\n                                 'rsautl',\n                                 '-decrypt',\n                                 '-inkey', '%s' % cloud_private_key,\n                                 process_input=encrypted_key,\n                                 check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt private key: %s')\n                                  % err)\n        iv, err = utils.execute('openssl',\n                                'rsautl',\n                                '-decrypt',\n                                '-inkey', '%s' % cloud_private_key,\n                                process_input=encrypted_iv,\n                                check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt initialization '\n                                    'vector: %s') % err)\n\n        _out, err = utils.execute('openssl', 'enc',\n                                  '-d', '-aes-128-cbc',\n                                  '-in', '%s' % (encrypted_filename,),\n                                  '-K', '%s' % (key,),\n                                  '-iv', '%s' % (iv,),\n                                  '-out', '%s' % (decrypted_filename,),\n                                  check_exit_code=False)\n        if err:\n            raise exception.Error(_('Failed to decrypt image file '\n                                    '%(image_file)s: %(err)s') %\n                                    {'image_file': encrypted_filename,\n                                     'err': err})\n\n    @staticmethod\n    def _test_for_malicious_tarball(path, filename):\n        \"\"\"Raises exception if extracting tarball would escape extract path\"\"\"\n        tar_file = tarfile.open(filename, 'r|gz')\n        for n in tar_file.getnames():\n            if not os.path.abspath(os.path.join(path, n)).startswith(path):\n                tar_file.close()\n                raise exception.Error(_('Unsafe filenames in image'))\n        tar_file.close()\n\n    @staticmethod\n    def _untarzip_image(path, filename):\n        S3ImageService._test_for_malicious_tarball(path, filename)\n        tar_file = tarfile.open(filename, 'r|gz')\n        tar_file.extractall(path)\n        image_file = tar_file.getnames()[0]\n        tar_file.close()\n        return os.path.join(path, image_file)", "target": 0}]}, {"raw_url": "https://github.com/openstack/nova/raw/76363226bd8533256f7795bba358d7f4b8a6c9e6/nova%2Ftests%2Fimage%2Ftest_s3.py", "code": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport os\n\nfrom nova import context\nfrom nova import test\nfrom nova.image import s3\n\n\nami_manifest_xml = \"\"\"<?xml version=\"1.0\" ?>\n<manifest>\n        <version>2011-06-17</version>\n        <bundler>\n                <name>test-s3</name>\n                <version>0</version>\n                <release>0</release>\n        </bundler>\n        <machine_configuration>\n                <architecture>x86_64</architecture>\n                <block_device_mapping>\n                        <mapping>\n                                <virtual>ami</virtual>\n                                <device>sda1</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>root</virtual>\n                                <device>/dev/sda1</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>ephemeral0</virtual>\n                                <device>sda2</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>swap</virtual>\n                                <device>sda3</device>\n                        </mapping>\n                </block_device_mapping>\n        </machine_configuration>\n</manifest>\n\"\"\"\n\n\nclass TestS3ImageService(test.TestCase):\n    def setUp(self):\n        super(TestS3ImageService, self).setUp()\n        self.flags(image_service='nova.image.fake.FakeImageService')\n        self.image_service = s3.S3ImageService()\n        self.context = context.RequestContext(None, None)\n\n    def _assertEqualList(self, list0, list1, keys):\n        self.assertEqual(len(list0), len(list1))\n        key = keys[0]\n        for x in list0:\n            self.assertEqual(len(x), len(keys))\n            self.assertTrue(key in x)\n            for y in list1:\n                self.assertTrue(key in y)\n                if x[key] == y[key]:\n                    for k in keys:\n                        self.assertEqual(x[k], y[k])\n\n    def test_s3_create(self):\n        metadata = {'properties': {\n            'root_device_name': '/dev/sda1',\n            'block_device_mapping': [\n                {'device_name': '/dev/sda1',\n                 'snapshot_id': 'snap-12345678',\n                 'delete_on_termination': True},\n                {'device_name': '/dev/sda2',\n                 'virutal_name': 'ephemeral0'},\n                {'device_name': '/dev/sdb0',\n                 'no_device': True}]}}\n        _manifest, image = self.image_service._s3_parse_manifest(\n            self.context, metadata, ami_manifest_xml)\n        image_id = image['id']\n\n        ret_image = self.image_service.show(self.context, image_id)\n        self.assertTrue('properties' in ret_image)\n        properties = ret_image['properties']\n\n        self.assertTrue('mappings' in properties)\n        mappings = properties['mappings']\n        expected_mappings = [\n            {\"device\": \"sda1\", \"virtual\": \"ami\"},\n            {\"device\": \"/dev/sda1\", \"virtual\": \"root\"},\n            {\"device\": \"sda2\", \"virtual\": \"ephemeral0\"},\n            {\"device\": \"sda3\", \"virtual\": \"swap\"}]\n        self._assertEqualList(mappings, expected_mappings,\n            ['device', 'virtual'])\n\n        self.assertTrue('block_device_mapping', properties)\n        block_device_mapping = properties['block_device_mapping']\n        expected_bdm = [\n            {'device_name': '/dev/sda1',\n             'snapshot_id': 'snap-12345678',\n             'delete_on_termination': True},\n            {'device_name': '/dev/sda2',\n             'virutal_name': 'ephemeral0'},\n            {'device_name': '/dev/sdb0',\n             'no_device': True}]\n        self.assertEqual(block_device_mapping, expected_bdm)\n\n    def test_s3_malicious_tarballs(self):\n        self.assertRaises(exception.Error,\n            self.image_service._test_for_malicious_tarball,\n            \"/unused\", os.path.join(os.path.dirname(__file__), 'abs.tar.gz'))\n        self.assertRaises(exception.Error,\n            self.image_service._test_for_malicious_tarball,\n            \"/unused\", os.path.join(os.path.dirname(__file__), 'rel.tar.gz'))\n", "code_before": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom nova import context\nfrom nova import test\nfrom nova.image import s3\n\n\nami_manifest_xml = \"\"\"<?xml version=\"1.0\" ?>\n<manifest>\n        <version>2011-06-17</version>\n        <bundler>\n                <name>test-s3</name>\n                <version>0</version>\n                <release>0</release>\n        </bundler>\n        <machine_configuration>\n                <architecture>x86_64</architecture>\n                <block_device_mapping>\n                        <mapping>\n                                <virtual>ami</virtual>\n                                <device>sda1</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>root</virtual>\n                                <device>/dev/sda1</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>ephemeral0</virtual>\n                                <device>sda2</device>\n                        </mapping>\n                        <mapping>\n                                <virtual>swap</virtual>\n                                <device>sda3</device>\n                        </mapping>\n                </block_device_mapping>\n        </machine_configuration>\n</manifest>\n\"\"\"\n\n\nclass TestS3ImageService(test.TestCase):\n    def setUp(self):\n        super(TestS3ImageService, self).setUp()\n        self.flags(image_service='nova.image.fake.FakeImageService')\n        self.image_service = s3.S3ImageService()\n        self.context = context.RequestContext(None, None)\n\n    def _assertEqualList(self, list0, list1, keys):\n        self.assertEqual(len(list0), len(list1))\n        key = keys[0]\n        for x in list0:\n            self.assertEqual(len(x), len(keys))\n            self.assertTrue(key in x)\n            for y in list1:\n                self.assertTrue(key in y)\n                if x[key] == y[key]:\n                    for k in keys:\n                        self.assertEqual(x[k], y[k])\n\n    def test_s3_create(self):\n        metadata = {'properties': {\n            'root_device_name': '/dev/sda1',\n            'block_device_mapping': [\n                {'device_name': '/dev/sda1',\n                 'snapshot_id': 'snap-12345678',\n                 'delete_on_termination': True},\n                {'device_name': '/dev/sda2',\n                 'virutal_name': 'ephemeral0'},\n                {'device_name': '/dev/sdb0',\n                 'no_device': True}]}}\n        _manifest, image = self.image_service._s3_parse_manifest(\n            self.context, metadata, ami_manifest_xml)\n        image_id = image['id']\n\n        ret_image = self.image_service.show(self.context, image_id)\n        self.assertTrue('properties' in ret_image)\n        properties = ret_image['properties']\n\n        self.assertTrue('mappings' in properties)\n        mappings = properties['mappings']\n        expected_mappings = [\n            {\"device\": \"sda1\", \"virtual\": \"ami\"},\n            {\"device\": \"/dev/sda1\", \"virtual\": \"root\"},\n            {\"device\": \"sda2\", \"virtual\": \"ephemeral0\"},\n            {\"device\": \"sda3\", \"virtual\": \"swap\"}]\n        self._assertEqualList(mappings, expected_mappings,\n            ['device', 'virtual'])\n\n        self.assertTrue('block_device_mapping', properties)\n        block_device_mapping = properties['block_device_mapping']\n        expected_bdm = [\n            {'device_name': '/dev/sda1',\n             'snapshot_id': 'snap-12345678',\n             'delete_on_termination': True},\n            {'device_name': '/dev/sda2',\n             'virutal_name': 'ephemeral0'},\n            {'device_name': '/dev/sdb0',\n             'no_device': True}]\n        self.assertEqual(block_device_mapping, expected_bdm)\n", "patch": "@@ -15,6 +15,8 @@\n #    License for the specific language governing permissions and limitations\n #    under the License.\n \n+import os\n+\n from nova import context\n from nova import test\n from nova.image import s3\n@@ -112,3 +114,11 @@ def test_s3_create(self):\n             {'device_name': '/dev/sdb0',\n              'no_device': True}]\n         self.assertEqual(block_device_mapping, expected_bdm)\n+\n+    def test_s3_malicious_tarballs(self):\n+        self.assertRaises(exception.Error,\n+            self.image_service._test_for_malicious_tarball,\n+            \"/unused\", os.path.join(os.path.dirname(__file__), 'abs.tar.gz'))\n+        self.assertRaises(exception.Error,\n+            self.image_service._test_for_malicious_tarball,\n+            \"/unused\", os.path.join(os.path.dirname(__file__), 'rel.tar.gz'))", "file_path": "files/2011_12/5", "file_language": "py", "file_name": "nova/tests/image/test_s3.py", "outdated_file_modify": 0, "outdated_file_before": 1, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 1, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
