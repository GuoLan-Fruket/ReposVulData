{"index": 12065, "cve_id": "CVE-2023-40587", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Pyramid is an open source Python web framework. A path traversal vulnerability in Pyramid versions 2.0.0 and 2.0.1 impacts users of Python 3.11 that are using a Pyramid static view with a full filesystem path and have a `index.html` file that is located exactly one directory above the location of the static view's file system path. No further path traversal exists, and the only file that could be disclosed accidentally is `index.html`. Pyramid version 2.0.2 rejects any path that contains a null-byte out of caution. While valid in directory/file names, we would strongly consider it a mistake to use null-bytes in naming files/directories. Secondly, Python 3.11, and 3.12 has fixed the underlying issue in `os.path.normpath` to no longer truncate on the first `0x00` found, returning the behavior to pre-3.11 Python, un an as of yet unreleased version. Fixes will be available in:Python 3.12.0rc2 and 3.11.5. Some workarounds are available. Use a version of Python 3 that is not affected, downgrade to Python 3.10 series temporarily, or wait until Python 3.11.5 is released and upgrade to the latest version of Python 3.11 series.", "cvss": "5.3", "publish_date": "August 25, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "LOW", "I": "NONE", "A": "NONE", "commit_id": "347d7750da6f45c7436dd0c31468885cc9343c85", "commit_message": "fix: reject NUL character as path element\n\nSee: https://github.com/Pylons/pyramid/security/advisories/GHSA-j8g2-6fc7-q8f8", "commit_date": "2023-08-25T05:42:43Z", "project": "pylons/pyramid", "url": "https://api.github.com/repos/Pylons/pyramid/commits/347d7750da6f45c7436dd0c31468885cc9343c85", "html_url": "https://github.com/Pylons/pyramid/commit/347d7750da6f45c7436dd0c31468885cc9343c85", "windows_before": [{"commit_id": "6726314834d0de9e29c45dcb3d6f3ce9118a956d", "commit_date": "Wed Aug 23 14:42:14 2023 -0600", "commit_message": "Update CHANGES for exploit mitigation", "files_name": ["CHANGES.rst"]}, {"commit_id": "0919da5326ef65fb6569bc045ee0c0f033185f1c", "commit_date": "Mon Aug 21 19:41:50 2023 -0400", "commit_message": "Update for tox changes.", "files_name": [".github/workflows/ci-tests.yml"]}, {"commit_id": "c4530ac2671de1f04d95e7f9bda7dc369031ef81", "commit_date": "Mon Aug 21 19:41:22 2023 -0400", "commit_message": "Update for tox changes.", "files_name": [".github/workflows/ci-tests.yml"]}, {"commit_id": "f1233a65c3d53aaac0d5fe732b8a25cf2971fbea", "commit_date": "Mon Aug 21 19:22:30 2023 -0400", "commit_message": "Coverage reports in tests based on Python 3.11 instead of Python 3.8 to fix bogus coverage failures under Python 3.8", "files_name": ["CHANGES.rst", "tox.ini"]}, {"commit_id": "fe4de1da370a373a788116727849bab585edaf02", "commit_date": "Mon Aug 21 18:44:48 2023 -0400", "commit_message": "appease linter", "files_name": ["tests/pkgs/static_assetspec_nulbyte/__init__.py"]}, {"commit_id": "bf998f3b0064a9c342f114120d069ec8251e2ff8", "commit_date": "Mon Aug 21 18:43:33 2023 -0400", "commit_message": "appease linter", "files_name": ["tests/test_integration.py"]}, {"commit_id": "d4a821c7b134b983e72e653b17b5a25507552620", "commit_date": "Mon Aug 21 18:27:04 2023 -0400", "commit_message": "re-add integration tests (bad merge) and add integration test for nulbyte check when asset spec override exists", "files_name": ["tests/pkgs/static_abspath_nulbyte/__init__.py", "tests/pkgs/static_assetspec_nulbyte/__init__.py", "tests/test_integration.py"]}, {"commit_id": "2af309223d6050feff3f85701a93166f3d4b5fee", "commit_date": "Mon Aug 21 18:06:29 2023 -0400", "commit_message": "add integration tests", "files_name": ["tests/pkgs/static_abspath_nulbyte/__init__.py", "tests/pkgs/static_assetspec_nulbyte/__init__.py", "tests/test_integration.py"]}, {"commit_id": "021eb504a7d3d2aeeb0781a5f89a5467f90b13da", "commit_date": "Mon Aug 21 14:53:38 2023 -0400", "commit_message": "chore: back out unintended change", "files_name": ["src/pyramid/static.py"]}, {"commit_id": "d1dc3789e30c5ffa3e75df39033b9bd9752aebd5", "commit_date": "Mon Aug 21 14:50:34 2023 -0400", "commit_message": "chore: appease lint, better varname", "files_name": ["tests/test_static.py"]}, {"commit_id": "354d69a7b397571e3845de13ecabbfeb9d7f100b", "commit_date": "Mon Aug 21 14:43:12 2023 -0400", "commit_message": "fix: reject NUL character as path element", "files_name": ["src/pyramid/static.py", "tests/fixtures/index.html", "tests/test_static.py"]}, {"commit_id": "f1941759ee9dedf5f800fc4c9a0c9c51028e06f5", "commit_date": "Thu Aug 10 14:28:53 2023 -0500", "commit_message": "Merge pull request #3730 from leocosta-io/main", "files_name": ["7c175a662f547968e913f938fa82191cbfd0434d - Wed Aug 9 20:17:41 2023 -0300 : Fix a small mistake in definingmodels.rst", "docs/tutorials/wiki2/definingmodels.rst"]}, {"commit_id": "c2f7853bca61841ed9121202f1f8ddf38b37c54b", "commit_date": "Wed May 10 23:49:29 2023 -0700", "commit_message": "Merge pull request #3728 from skywalk163/doc", "files_name": ["34afa5c69884bcb8aefcb724b98f9d95c847b341 - Thu May 11 12:14:54 2023 +0800 : Update conf.py", "docs/conf.py"]}, {"commit_id": "0a33c474ffff8c9c82bb373a638b21de41d82d02", "commit_date": "Thu Feb 16 07:50:59 2023 -0600", "commit_message": "Merge pull request #3724 from Pylons/wikipedia-update", "files_name": ["7e46d7893b6faee5964afc7264f2e19ff3024318 - Sun Jan 29 22:56:42 2023 -0600 : update tox -e build", "tox.ini"]}, {"commit_id": "eaf6000f6c3386e92850b864507f52ba0be3cec5", "commit_date": "Sun Jan 29 20:46:41 2023 -0800", "commit_message": "Update process to update wikipedia data on wikidata.org", "files_name": ["RELEASING.txt"]}, {"commit_id": "73453bf91f1ea809716b10ff9b46a1b613caeb67", "commit_date": "Sun Jan 29 12:16:05 2023 -0600", "commit_message": "add changelog entry for #3667", "files_name": ["CHANGES.rst"]}, {"commit_id": "ea657230b3f23b42d1cf27eebd61e65efc4e2f0e", "commit_date": "Fri Dec 30 18:58:19 2022 -0600", "commit_message": "Merge pull request #3721 from Pylons/wiki-sqlite-tables", "files_name": ["7198460b885b795ea1477307e8e3ff7aa0b742bd - Fri Dec 30 14:41:11 2022 -0800 : Fix English grammar and syntax in wiki installation.rst", "docs/tutorials/wiki2/installation.rst"]}, {"commit_id": "d3fc4f97e8d5b8553c2a40da535a4b82d41d8ea1", "commit_date": "Fri Dec 30 11:18:04 2022 -0600", "commit_message": "Merge pull request #3713 from jvanasco/main", "files_name": ["068555acbd102694bd83c2fe11b5b125ca8649f8 - Fri Dec 30 11:10:09 2022 -0600 : Update docs/tutorials/wiki2/installation.rst", "docs/tutorials/wiki2/installation.rst"]}, {"commit_id": "240f34a18cde2473922bcc139ee92ee8b6978ce2", "commit_date": "Fri Dec 30 11:09:07 2022 -0600", "commit_message": "Merge pull request #3717 from stefanor/py311", "files_name": ["93a69202dc225dc5ae659824751f59c2d33f6373 - Fri Dec 30 11:08:44 2022 -0600 : Merge branch 'master' into py311", "dc4e2e282d60a8387e60ac5fd2b1813b9df3535d - Thu Dec 29 16:45:48 2022 -0600 : Merge branch 'master' into main", "4703e60eb7ddb870bf2cc69eaafd8e12fa966636 - Thu Dec 29 16:41:23 2022 -0600 : Merge pull request #3707 from ckaipf/update_quick_tutorial", "7ecd8d6f75d9d21f3f7b10e4c84958cf3aa8fb17 - Thu Dec 29 14:55:08 2022 -0400 : Drop l*gettext() from pyramid.i18n", "CHANGES.rst", "src/pyramid/i18n.py", "tests/test_i18n.py"]}, {"commit_id": "109345ccc7779bb5eda68d2c6f6f8808065666bc", "commit_date": "Thu Dec 29 14:52:23 2022 -0400", "commit_message": "Sign CONTRIBUTORS.txt", "files_name": ["CONTRIBUTORS.txt"]}, {"commit_id": "453c7737c83417b7034939168b6e6c7ac76fef8a", "commit_date": "Tue Dec 27 19:22:19 2022 +0100", "commit_message": "Merge pull request #3720 from Pylons/bugfix/update-docs-ref-sql", "files_name": ["e11c95b8f37b0eff61c1b11931e307468226ed5e - Tue Dec 27 19:07:42 2022 +0100 : Update reference to ORM in sqlalchemy", "docs/quick_tutorial/databases.rst"]}, {"commit_id": "5a3c3c9ddc221c0dfec02c91da466e6b26acd903", "commit_date": "Tue Dec 27 15:13:29 2022 +0100", "commit_message": "Merge pull request #3719 from Pylons/dependabot/github_actions/actions/setup-python-4", "files_name": ["1ca233b0eb269df62c68f60c6be0fcc7463642d4 - Tue Dec 27 15:13:19 2022 +0100 : Merge pull request #3718 from Pylons/dependabot/github_actions/actions/checkout-3", "f01ff60ceae1caa25271bd9f2616b80f54761130 - Tue Dec 27 14:10:12 2022 +0000 : Bump actions/setup-python from 2 to 4", ".github/workflows/ci-tests.yml"]}, {"commit_id": "763258441f78e58a2c07143734a67a2856ea6eca", "commit_date": "Tue Dec 27 14:09:24 2022 +0000", "commit_message": "Bump actions/checkout from 2 to 3", "files_name": [".github/workflows/ci-tests.yml"]}, {"commit_id": "5bc32e59fdb89569be23de1b7f851a169587362a", "commit_date": "Tue Dec 27 15:04:43 2022 +0100", "commit_message": "Chase rename to allowlist in tox", "files_name": ["tox.ini"]}, {"commit_id": "d62fc1a0af0f13eacf25611e5c36604c4ea4948d", "commit_date": "Tue Dec 27 15:04:06 2022 +0100", "commit_message": "Add dependabot to update github action versions", "files_name": [".github/dependabot.yml"]}, {"commit_id": "ce639190b4a61b4d51c5cacbe634451cddfd6c39", "commit_date": "Sun Dec 25 13:40:47 2022 -0400", "commit_message": "Declare support for python 3.11", "files_name": ["CHANGES.rst", "docs/narr/upgrading.rst", "setup.py"]}, {"commit_id": "aa25fbc378cd4d48fd2eb2c0d55ae488e2d6c9a0", "commit_date": "Sun Dec 25 13:40:27 2022 -0400", "commit_message": "Run tests on Python 3.11", "files_name": [".github/workflows/ci-tests.yml", "HACKING.txt", "docs/narr/install.rst", "tox.ini"]}, {"commit_id": "b52916545c1decc1b1d09a51fa95cdd3dd161cc4", "commit_date": "Sun Dec 25 13:38:54 2022 -0400", "commit_message": "Update links to Python Support schedule", "files_name": ["docs/narr/upgrading.rst"]}, {"commit_id": "13df6badcf97ad379dc88bb9773bdabc1520a71d", "commit_date": "Thu Nov 17 16:27:20 2022 -0500", "commit_message": "Updated link to SQLAlchemy docs, as the old link was removed in 2.0 release", "files_name": ["docs/quick_tutorial/databases.rst"]}, {"commit_id": "b7aecfe6aaff9ea50f657ae2d6638e33addc07c6", "commit_date": "Mon Nov 14 15:27:33 2022 -0500", "commit_message": "rename \"master\" to \"main\"", "files_name": [".github/workflows/ci-tests.yml", "README.rst", "RELEASING.txt", "contributing.md", "docs/conf.py", "docs/narr/cookiecutters.rst", "docs/narr/project.rst", "docs/quick_tour.rst", "docs/quick_tutorial/cookiecutters.rst", "docs/tutorials/modwsgi/index.rst", "docs/tutorials/wiki/installation.rst", "docs/tutorials/wiki2/installation.rst"]}, {"commit_id": "51a731c690b2644df206722767a74fee9339fb87", "commit_date": "Thu Sep 29 18:22:56 2022 -0500", "commit_message": "Merge pull request #3701 from Pylons/pyupgrade-3.7", "files_name": ["97481ac5f713306e398ea2ffd283004a485df114 - Thu Sep 29 18:21:12 2022 -0500 : Merge pull request #3708 from stevepiercy/fix-lint-setup-check", "327473f90e81eb53a8486a36df8e30a7e18511db - Thu Sep 29 18:20:38 2022 -0500 : Merge pull request #3704 from ztane/patch-3", "339af3d0f5615e2f78e19bf7b34d07c55937a4f9 - Fri Aug 12 07:18:57 2022 -0700 : Remove duplicate implicit target errors for `pyramid` when running `python setup.py -r -s -m`", "README.rst"]}, {"commit_id": "604ed286f5c44f7dc8bee1ad855efe8c57058a1c", "commit_date": "Fri Aug 12 07:13:59 2022 -0700", "commit_message": "Fix ImportError: cannot import name '_unicodefun' from 'click'", "files_name": ["tox.ini"]}, {"commit_id": "bdbb8c408566f1a4009d7a8dd32f72719c1f3849", "commit_date": "Fri Aug 12 06:26:51 2022 -0700", "commit_message": "Merge branch 'master' of https://github.com/Pylons/pyramid", "files_name": ["763ad1a4fe0799ff449ef117859f07a557d949c1 - Fri Aug 12 14:52:40 2022 +0200 : signed CONTRIBUTORS.txt", "CONTRIBUTORS.txt"]}, {"commit_id": "5f5954c1923058031b07dda2e0898164a3554318", "commit_date": "Fri Aug 12 13:39:47 2022 +0200", "commit_message": "update SQLAlchemy logger in quick tutorial fixes #3706", "files_name": ["docs/quick_tutorial/databases.rst", "docs/quick_tutorial/databases/development.ini"]}, {"commit_id": "a3b3f701a13c62d98e46d37cdd62d566bc5459f8", "commit_date": "Tue Jun 7 23:53:12 2022 +0300", "commit_message": "Change != to is not in pshell initialization", "files_name": ["src/pyramid/scripts/pshell.py"]}, {"commit_id": "d9a49e0afeb773d80ee6f6a60ad4936d433dc4f4", "commit_date": "Thu May 26 10:31:41 2022 -0600", "commit_message": "Remove extra comment left behind after removing the coding stanza", "files_name": ["docs/conf.py"]}, {"commit_id": "1f8e290a7b287c5d8aaafd0ff91692d1343ce1a9", "commit_date": "Sun Mar 13 18:23:15 2022 -0500", "commit_message": "pyupgrade --py37-plus", "files_name": ["docs/conf.py", "src/pyramid/asset.py", "src/pyramid/authentication.py", "src/pyramid/config/__init__.py", "src/pyramid/config/actions.py", "src/pyramid/config/assets.py", "src/pyramid/config/predicates.py", "src/pyramid/config/routes.py", "src/pyramid/config/tweens.py", "src/pyramid/config/views.py", "src/pyramid/csrf.py", "src/pyramid/encode.py", "src/pyramid/exceptions.py", "src/pyramid/httpexceptions.py", "src/pyramid/i18n.py", "src/pyramid/path.py", "src/pyramid/predicates.py", "src/pyramid/registry.py", "src/pyramid/renderers.py", "src/pyramid/scripts/prequest.py", "src/pyramid/scripts/proutes.py", "src/pyramid/scripts/pserve.py", "src/pyramid/scripts/pshell.py", "src/pyramid/scripts/pviews.py", "src/pyramid/security.py", "src/pyramid/static.py", "src/pyramid/traversal.py", "src/pyramid/url.py", "src/pyramid/urldispatch.py", "src/pyramid/util.py", "src/pyramid/viewderivers.py", "tests/pkgs/eventonly/__init__.py", "tests/pkgs/subrequestapp/__init__.py", "tests/test_authentication.py", "tests/test_config/test_views.py", "tests/test_csrf.py", "tests/test_integration.py", "tests/test_path.py", "tests/test_response.py", "tests/test_scripts/test_proutes.py", "tests/test_session.py", "tests/test_static.py", "tests/test_traversal.py", "tests/test_viewderivers.py"]}, {"commit_id": "1e439035e41da3767acbcae79689fb05dfdeb317", "commit_date": "Sun Mar 13 17:49:13 2022 -0500", "commit_message": "Merge pull request #3698 from Pylons/fix-action-method", "files_name": ["9531d37e843efcae676fd6cafe697fefd7bc5f7d - Sun Mar 13 17:49:00 2022 -0500 : Merge pull request #3696 from Pylons/replace-getargspec", "90e4de273506e8fd6b66e18517e98eaa61f5e268 - Sun Mar 13 12:32:20 2022 -0500 : remove obsolete hack required on unsupported version 3.5.0", "src/pyramid/config/actions.py"]}], "windows_after": [{"commit_id": "b4e78bd14f7bbfce76399510a78b5346f9bd73e1", "commit_date": "Thu Aug 24 23:49:50 2023 -0600", "commit_message": "Merge branch 'tseaver-jp_exploit_fix'", "files_name": ["8a4f6ebe38d7cea9ea7845b10437604cdb4ed489 - Fri Aug 25 00:35:16 2023 -0600 : upgrade to readthedocs.yaml", ".readthedocs.yaml", "MANIFEST.in", "rtd.txt"]}, {"commit_id": "bc574889088d22d8a172bb0d7567bdb1549b2d8e", "commit_date": "Tue Sep 5 08:58:03 2023 +0000", "commit_message": "Bump actions/checkout from 3 to 4", "files_name": [".github/workflows/ci-tests.yml"]}, {"commit_id": "156c8c8d8a99fe062ecc4a4cbf08ccf45ff8c498", "commit_date": "Tue Sep 5 11:44:54 2023 -0500", "commit_message": "Merge pull request #3732 from Pylons/dependabot/github_actions/actions/checkout-4", "files_name": ["5bd08edee613cf68916c8fc6a3c1204cfba9ba49 - Thu Sep 14 17:29:26 2023 -0400 : Fix broken links", "docs/narr/templates.rst"]}, {"commit_id": "3739a7790ba92c34098df3d804f27a1d8429f9fe", "commit_date": "Thu Sep 14 17:55:43 2023 -0400", "commit_message": "Merge pull request #3733 from miketheman/patch-1", "files_name": []}], "parents": [{"commit_id_before": "9cd83a205057d2c4ae06571f369852feac567c49", "url_before": "https://api.github.com/repos/Pylons/pyramid/commits/9cd83a205057d2c4ae06571f369852feac567c49", "html_url_before": "https://github.com/Pylons/pyramid/commit/9cd83a205057d2c4ae06571f369852feac567c49"}], "details": [{"raw_url": "https://github.com/Pylons/pyramid/raw/347d7750da6f45c7436dd0c31468885cc9343c85/src%2Fpyramid%2Fstatic.py", "code": "from functools import lru_cache\nimport json\nimport mimetypes\nimport os\nfrom os.path import exists, getmtime, getsize, isdir, join, normcase, normpath\nfrom pkg_resources import resource_exists, resource_filename, resource_isdir\n\nfrom pyramid.asset import abspath_from_asset_spec, resolve_asset_spec\nfrom pyramid.httpexceptions import HTTPMovedPermanently, HTTPNotFound\nfrom pyramid.path import caller_package\nfrom pyramid.response import FileResponse, _guess_type\nfrom pyramid.traversal import traversal_path_info\n\n\nclass static_view:\n    \"\"\"An instance of this class is a callable which can act as a\n    :app:`Pyramid` :term:`view callable`; this view will serve\n    static files from a directory on disk based on the ``root_dir``\n    you provide to its constructor.\n\n    The directory may contain subdirectories (recursively); the static\n    view implementation will descend into these directories as\n    necessary based on the components of the URL in order to resolve a\n    path into a response.\n\n    You may pass an absolute or relative filesystem path or a\n    :term:`asset specification` representing the directory\n    containing static files as the ``root_dir`` argument to this\n    class' constructor.\n\n    If the ``root_dir`` path is relative, and the ``package_name``\n    argument is ``None``, ``root_dir`` will be considered relative to\n    the directory in which the Python file which *calls* ``static``\n    resides.  If the ``package_name`` name argument is provided, and a\n    relative ``root_dir`` is provided, the ``root_dir`` will be\n    considered relative to the Python :term:`package` specified by\n    ``package_name`` (a dotted path to a Python package).\n\n    ``cache_max_age`` influences the ``Expires`` and ``Max-Age``\n    response headers returned by the view (default is 3600 seconds or\n    one hour).\n\n    ``use_subpath`` influences whether ``request.subpath`` will be used as\n    ``PATH_INFO`` when calling the underlying WSGI application which actually\n    serves the static files.  If it is ``True``, the static application will\n    consider ``request.subpath`` as ``PATH_INFO`` input.  If it is ``False``,\n    the static application will consider request.environ[``PATH_INFO``] as\n    ``PATH_INFO`` input. By default, this is ``False``.\n\n    ``reload`` controls whether a cache of files is maintained or the asset\n    subsystem is queried per-request to determine what files are available.\n    By default, this is ``False`` and new files added while the process is\n    running are not recognized.\n\n    ``content_encodings`` is a list of alternative file encodings supported\n    in the ``Accept-Encoding`` HTTP Header. Alternative files are found using\n    file extensions defined in :attr:`mimetypes.encodings_map`. An encoded\n    asset will be returned with the ``Content-Encoding`` header set to the\n    selected encoding. If the asset contains alternative encodings then the\n    ``Accept-Encoding`` value will be added to the response's ``Vary`` header.\n    By default, the list is empty and no alternatives will be supported.\n\n    .. note::\n\n       If the ``root_dir`` is relative to a :term:`package`, or is a\n       :term:`asset specification` the :app:`Pyramid`\n       :class:`pyramid.config.Configurator` method can be used to override\n       assets within the named ``root_dir`` package-relative directory.\n       However, if the ``root_dir`` is absolute, configuration will not be able\n       to override the assets it contains.\n\n    .. versionchanged:: 2.0\n\n       Added ``reload`` and ``content_encodings`` options.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        root_dir,\n        cache_max_age=3600,\n        package_name=None,\n        use_subpath=False,\n        index='index.html',\n        reload=False,\n        content_encodings=(),\n    ):\n        # package_name is for bw compat; it is preferred to pass in a\n        # package-relative path as root_dir\n        # (e.g. ``anotherpackage:foo/static``).\n        self.cache_max_age = cache_max_age\n        if package_name is None:\n            package_name = caller_package().__name__\n        package_name, docroot = resolve_asset_spec(root_dir, package_name)\n        self.use_subpath = use_subpath\n        self.package_name = package_name\n        self.docroot = docroot\n        self.norm_docroot = normcase(normpath(docroot))\n        self.index = index\n        self.reload = reload\n        self.content_encodings = _compile_content_encodings(content_encodings)\n        self.filemap = {}\n\n    def __call__(self, context, request):\n        resource_name = self.get_resource_name(request)\n        files = self.get_possible_files(resource_name)\n        filepath, content_encoding = self.find_best_match(request, files)\n        if filepath is None:\n            raise HTTPNotFound(request.url)\n\n        content_type, _ = _guess_type(resource_name)\n        response = FileResponse(\n            filepath,\n            request,\n            self.cache_max_age,\n            content_type,\n            content_encoding,\n        )\n        if len(files) > 1:\n            _add_vary(response, 'Accept-Encoding')\n        return response\n\n    def get_resource_name(self, request):\n        \"\"\"\n        Return the computed name of the requested resource.\n\n        The returned file is not guaranteed to exist.\n\n        \"\"\"\n        if self.use_subpath:\n            path_tuple = request.subpath\n        else:\n            path_tuple = traversal_path_info(request.path_info)\n        path = _secure_path(path_tuple)\n\n        if path is None:\n            raise HTTPNotFound('Out of bounds: %s' % request.url)\n\n        # normalize asset spec or fs path into resource_path\n        if self.package_name:  # package resource\n            resource_path = '%s/%s' % (self.docroot.rstrip('/'), path)\n            if resource_isdir(self.package_name, resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = '%s/%s' % (\n                    resource_path.rstrip('/'),\n                    self.index,\n                )\n\n        else:  # filesystem file\n            # os.path.normpath converts / to \\ on windows\n            resource_path = normcase(normpath(join(self.norm_docroot, path)))\n            if isdir(resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = join(resource_path, self.index)\n\n        return resource_path\n\n    def find_resource_path(self, name):\n        \"\"\"\n        Return the absolute path to the resource or ``None`` if it doesn't\n        exist.\n\n        \"\"\"\n        if self.package_name:\n            if resource_exists(self.package_name, name):\n                return resource_filename(self.package_name, name)\n\n        elif exists(name):\n            return name\n\n    def get_possible_files(self, resource_name):\n        \"\"\"Return a sorted list of ``(size, encoding, path)`` entries.\"\"\"\n        result = self.filemap.get(resource_name)\n        if result is not None:\n            return result\n\n        # XXX we could put a lock around this work but worst case scenario a\n        # couple requests scan the disk for files at the same time and then\n        # the cache is set going forward so do not bother\n        result = []\n\n        # add the identity\n        path = self.find_resource_path(resource_name)\n        if path:\n            result.append((path, None))\n\n        # add each file we find for the supported encodings\n        # we don't mind adding multiple files for the same encoding if there\n        # are copies with different extensions because we sort by size so the\n        # smallest is always found first and the rest ignored\n        for encoding, extensions in self.content_encodings.items():\n            for ext in extensions:\n                encoded_name = resource_name + ext\n                path = self.find_resource_path(encoded_name)\n                if path:\n                    result.append((path, encoding))\n\n        # sort the files by size, smallest first\n        result.sort(key=lambda x: getsize(x[0]))\n\n        # only cache the results if reload is disabled\n        if not self.reload:\n            self.filemap[resource_name] = result\n        return result\n\n    def find_best_match(self, request, files):\n        \"\"\"Return ``(path | None, encoding)``.\"\"\"\n        # if the client did not specify encodings then assume only the\n        # identity is acceptable\n        if not request.accept_encoding:\n            identity_path = next(\n                (path for path, encoding in files if encoding is None),\n                None,\n            )\n            return identity_path, None\n\n        # find encodings the client will accept\n        acceptable_encodings = {\n            x[0]\n            for x in request.accept_encoding.acceptable_offers(\n                [encoding for path, encoding in files if encoding is not None]\n            )\n        }\n        acceptable_encodings.add(None)\n\n        # return the smallest file from the acceptable encodings\n        # we know that files is sorted by size, smallest first\n        for path, encoding in files:\n            if encoding in acceptable_encodings:\n                return path, encoding\n        return None, None\n\n    def add_slash_redirect(self, request):\n        url = request.path_url + '/'\n        qs = request.query_string\n        if qs:\n            url = url + '?' + qs\n        return HTTPMovedPermanently(url)\n\n\ndef _compile_content_encodings(encodings):\n    \"\"\"\n    Convert mimetypes.encodings_map into a dict of\n    ``(encoding) -> [file extensions]``.\n\n    \"\"\"\n    result = {}\n    for ext, encoding in mimetypes.encodings_map.items():\n        if encoding in encodings:\n            result.setdefault(encoding, []).append(ext)\n    return result\n\n\ndef _add_vary(response, option):\n    vary = response.vary or []\n    if not any(x.lower() == option.lower() for x in vary):\n        vary.append(option)\n    response.vary = vary\n\n\n_invalid_element_chars = {'/', os.sep, '\\x00'}\n\n\ndef _contains_invalid_element_char(item):\n    for invalid_element_char in _invalid_element_chars:\n        if invalid_element_char in item:\n            return True\n\n\n_has_insecure_pathelement = {'..', '.', ''}.intersection\n\n\n@lru_cache(1000)\ndef _secure_path(path_tuple):\n    if _has_insecure_pathelement(path_tuple):\n        # belt-and-suspenders security; this should never be true\n        # unless someone screws up the traversal_path code\n        # (request.subpath is computed via traversal_path too)\n        return None\n    if any([_contains_invalid_element_char(item) for item in path_tuple]):\n        return None\n    encoded = '/'.join(path_tuple)  # will be unicode\n    return encoded\n\n\nclass QueryStringCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    a token for cache busting in the query string of an asset URL.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    To use this class, subclass it and provide a ``tokenize`` method which\n    accepts ``request, pathspec, kw`` and returns a token.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, param='x'):\n        self.param = param\n\n    def __call__(self, request, subpath, kw):\n        token = self.tokenize(request, subpath, kw)\n        query = kw.setdefault('_query', {})\n        if isinstance(query, dict):\n            query[self.param] = token\n        else:\n            kw['_query'] = tuple(query) + ((self.param, token),)\n        return subpath, kw\n\n\nclass QueryStringConstantCacheBuster(QueryStringCacheBuster):\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    an arbitrary token for cache busting in the query string of an asset URL.\n\n    The ``token`` parameter is the token string to use for cache busting and\n    will be the same for every request.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, token, param='x'):\n        super().__init__(param=param)\n        self._token = token\n\n    def tokenize(self, request, subpath, kw):\n        return self._token\n\n\nclass ManifestCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which\n    uses a supplied manifest file to map an asset path to a cache-busted\n    version of the path.\n\n    The ``manifest_spec`` can be an absolute path or a :term:`asset\n    specification` pointing to a package-relative file.\n\n    The manifest file is expected to conform to the following simple JSON\n    format:\n\n    .. code-block:: json\n\n       {\n           \"css/main.css\": \"css/main-678b7c80.css\",\n           \"images/background.png\": \"images/background-a8169106.png\",\n       }\n\n    By default, it is a JSON-serialized dictionary where the keys are the\n    source asset paths used in calls to\n    :meth:`~pyramid.request.Request.static_url`. For example:\n\n    .. code-block:: pycon\n\n       >>> request.static_url('myapp:static/css/main.css')\n       \"http://www.example.com/static/css/main-678b7c80.css\"\n\n    The file format and location can be changed by subclassing and overriding\n    :meth:`.parse_manifest`.\n\n    If a path is not found in the manifest it will pass through unchanged.\n\n    If ``reload`` is ``True`` then the manifest file will be reloaded when\n    changed. It is not recommended to leave this enabled in production.\n\n    If the manifest file cannot be found on disk it will be treated as\n    an empty mapping unless ``reload`` is ``False``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    exists = staticmethod(exists)  # testing\n    getmtime = staticmethod(getmtime)  # testing\n\n    def __init__(self, manifest_spec, reload=False):\n        package_name = caller_package().__name__\n        self.manifest_path = abspath_from_asset_spec(\n            manifest_spec, package_name\n        )\n        self.reload = reload\n\n        self._mtime = None\n        if not reload:\n            self._manifest = self.get_manifest()\n\n    def get_manifest(self):\n        with open(self.manifest_path, 'rb') as fp:\n            return self.parse_manifest(fp.read())\n\n    def parse_manifest(self, content):\n        \"\"\"\n        Parse the ``content`` read from the ``manifest_path`` into a\n        dictionary mapping.\n\n        Subclasses may override this method to use something other than\n        ``json.loads`` to load any type of file format and return a conforming\n        dictionary.\n\n        \"\"\"\n        return json.loads(content.decode('utf-8'))\n\n    @property\n    def manifest(self):\n        \"\"\"The current manifest dictionary.\"\"\"\n        if self.reload:\n            if not self.exists(self.manifest_path):\n                return {}\n            mtime = self.getmtime(self.manifest_path)\n            if self._mtime is None or mtime > self._mtime:\n                self._manifest = self.get_manifest()\n                self._mtime = mtime\n        return self._manifest\n\n    def __call__(self, request, subpath, kw):\n        subpath = self.manifest.get(subpath, subpath)\n        return (subpath, kw)\n", "code_before": "from functools import lru_cache\nimport json\nimport mimetypes\nimport os\nfrom os.path import exists, getmtime, getsize, isdir, join, normcase, normpath\nfrom pkg_resources import resource_exists, resource_filename, resource_isdir\n\nfrom pyramid.asset import abspath_from_asset_spec, resolve_asset_spec\nfrom pyramid.httpexceptions import HTTPMovedPermanently, HTTPNotFound\nfrom pyramid.path import caller_package\nfrom pyramid.response import FileResponse, _guess_type\nfrom pyramid.traversal import traversal_path_info\n\n\nclass static_view:\n    \"\"\"An instance of this class is a callable which can act as a\n    :app:`Pyramid` :term:`view callable`; this view will serve\n    static files from a directory on disk based on the ``root_dir``\n    you provide to its constructor.\n\n    The directory may contain subdirectories (recursively); the static\n    view implementation will descend into these directories as\n    necessary based on the components of the URL in order to resolve a\n    path into a response.\n\n    You may pass an absolute or relative filesystem path or a\n    :term:`asset specification` representing the directory\n    containing static files as the ``root_dir`` argument to this\n    class' constructor.\n\n    If the ``root_dir`` path is relative, and the ``package_name``\n    argument is ``None``, ``root_dir`` will be considered relative to\n    the directory in which the Python file which *calls* ``static``\n    resides.  If the ``package_name`` name argument is provided, and a\n    relative ``root_dir`` is provided, the ``root_dir`` will be\n    considered relative to the Python :term:`package` specified by\n    ``package_name`` (a dotted path to a Python package).\n\n    ``cache_max_age`` influences the ``Expires`` and ``Max-Age``\n    response headers returned by the view (default is 3600 seconds or\n    one hour).\n\n    ``use_subpath`` influences whether ``request.subpath`` will be used as\n    ``PATH_INFO`` when calling the underlying WSGI application which actually\n    serves the static files.  If it is ``True``, the static application will\n    consider ``request.subpath`` as ``PATH_INFO`` input.  If it is ``False``,\n    the static application will consider request.environ[``PATH_INFO``] as\n    ``PATH_INFO`` input. By default, this is ``False``.\n\n    ``reload`` controls whether a cache of files is maintained or the asset\n    subsystem is queried per-request to determine what files are available.\n    By default, this is ``False`` and new files added while the process is\n    running are not recognized.\n\n    ``content_encodings`` is a list of alternative file encodings supported\n    in the ``Accept-Encoding`` HTTP Header. Alternative files are found using\n    file extensions defined in :attr:`mimetypes.encodings_map`. An encoded\n    asset will be returned with the ``Content-Encoding`` header set to the\n    selected encoding. If the asset contains alternative encodings then the\n    ``Accept-Encoding`` value will be added to the response's ``Vary`` header.\n    By default, the list is empty and no alternatives will be supported.\n\n    .. note::\n\n       If the ``root_dir`` is relative to a :term:`package`, or is a\n       :term:`asset specification` the :app:`Pyramid`\n       :class:`pyramid.config.Configurator` method can be used to override\n       assets within the named ``root_dir`` package-relative directory.\n       However, if the ``root_dir`` is absolute, configuration will not be able\n       to override the assets it contains.\n\n    .. versionchanged:: 2.0\n\n       Added ``reload`` and ``content_encodings`` options.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        root_dir,\n        cache_max_age=3600,\n        package_name=None,\n        use_subpath=False,\n        index='index.html',\n        reload=False,\n        content_encodings=(),\n    ):\n        # package_name is for bw compat; it is preferred to pass in a\n        # package-relative path as root_dir\n        # (e.g. ``anotherpackage:foo/static``).\n        self.cache_max_age = cache_max_age\n        if package_name is None:\n            package_name = caller_package().__name__\n        package_name, docroot = resolve_asset_spec(root_dir, package_name)\n        self.use_subpath = use_subpath\n        self.package_name = package_name\n        self.docroot = docroot\n        self.norm_docroot = normcase(normpath(docroot))\n        self.index = index\n        self.reload = reload\n        self.content_encodings = _compile_content_encodings(content_encodings)\n        self.filemap = {}\n\n    def __call__(self, context, request):\n        resource_name = self.get_resource_name(request)\n        files = self.get_possible_files(resource_name)\n        filepath, content_encoding = self.find_best_match(request, files)\n        if filepath is None:\n            raise HTTPNotFound(request.url)\n\n        content_type, _ = _guess_type(resource_name)\n        response = FileResponse(\n            filepath,\n            request,\n            self.cache_max_age,\n            content_type,\n            content_encoding,\n        )\n        if len(files) > 1:\n            _add_vary(response, 'Accept-Encoding')\n        return response\n\n    def get_resource_name(self, request):\n        \"\"\"\n        Return the computed name of the requested resource.\n\n        The returned file is not guaranteed to exist.\n\n        \"\"\"\n        if self.use_subpath:\n            path_tuple = request.subpath\n        else:\n            path_tuple = traversal_path_info(request.path_info)\n        path = _secure_path(path_tuple)\n\n        if path is None:\n            raise HTTPNotFound('Out of bounds: %s' % request.url)\n\n        # normalize asset spec or fs path into resource_path\n        if self.package_name:  # package resource\n            resource_path = '%s/%s' % (self.docroot.rstrip('/'), path)\n            if resource_isdir(self.package_name, resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = '%s/%s' % (\n                    resource_path.rstrip('/'),\n                    self.index,\n                )\n\n        else:  # filesystem file\n            # os.path.normpath converts / to \\ on windows\n            resource_path = normcase(normpath(join(self.norm_docroot, path)))\n            if isdir(resource_path):\n                if not request.path_url.endswith('/'):\n                    raise self.add_slash_redirect(request)\n                resource_path = join(resource_path, self.index)\n\n        return resource_path\n\n    def find_resource_path(self, name):\n        \"\"\"\n        Return the absolute path to the resource or ``None`` if it doesn't\n        exist.\n\n        \"\"\"\n        if self.package_name:\n            if resource_exists(self.package_name, name):\n                return resource_filename(self.package_name, name)\n\n        elif exists(name):\n            return name\n\n    def get_possible_files(self, resource_name):\n        \"\"\"Return a sorted list of ``(size, encoding, path)`` entries.\"\"\"\n        result = self.filemap.get(resource_name)\n        if result is not None:\n            return result\n\n        # XXX we could put a lock around this work but worst case scenario a\n        # couple requests scan the disk for files at the same time and then\n        # the cache is set going forward so do not bother\n        result = []\n\n        # add the identity\n        path = self.find_resource_path(resource_name)\n        if path:\n            result.append((path, None))\n\n        # add each file we find for the supported encodings\n        # we don't mind adding multiple files for the same encoding if there\n        # are copies with different extensions because we sort by size so the\n        # smallest is always found first and the rest ignored\n        for encoding, extensions in self.content_encodings.items():\n            for ext in extensions:\n                encoded_name = resource_name + ext\n                path = self.find_resource_path(encoded_name)\n                if path:\n                    result.append((path, encoding))\n\n        # sort the files by size, smallest first\n        result.sort(key=lambda x: getsize(x[0]))\n\n        # only cache the results if reload is disabled\n        if not self.reload:\n            self.filemap[resource_name] = result\n        return result\n\n    def find_best_match(self, request, files):\n        \"\"\"Return ``(path | None, encoding)``.\"\"\"\n        # if the client did not specify encodings then assume only the\n        # identity is acceptable\n        if not request.accept_encoding:\n            identity_path = next(\n                (path for path, encoding in files if encoding is None),\n                None,\n            )\n            return identity_path, None\n\n        # find encodings the client will accept\n        acceptable_encodings = {\n            x[0]\n            for x in request.accept_encoding.acceptable_offers(\n                [encoding for path, encoding in files if encoding is not None]\n            )\n        }\n        acceptable_encodings.add(None)\n\n        # return the smallest file from the acceptable encodings\n        # we know that files is sorted by size, smallest first\n        for path, encoding in files:\n            if encoding in acceptable_encodings:\n                return path, encoding\n        return None, None\n\n    def add_slash_redirect(self, request):\n        url = request.path_url + '/'\n        qs = request.query_string\n        if qs:\n            url = url + '?' + qs\n        return HTTPMovedPermanently(url)\n\n\ndef _compile_content_encodings(encodings):\n    \"\"\"\n    Convert mimetypes.encodings_map into a dict of\n    ``(encoding) -> [file extensions]``.\n\n    \"\"\"\n    result = {}\n    for ext, encoding in mimetypes.encodings_map.items():\n        if encoding in encodings:\n            result.setdefault(encoding, []).append(ext)\n    return result\n\n\ndef _add_vary(response, option):\n    vary = response.vary or []\n    if not any(x.lower() == option.lower() for x in vary):\n        vary.append(option)\n    response.vary = vary\n\n\n_seps = {'/', os.sep}\n\n\ndef _contains_slash(item):\n    for sep in _seps:\n        if sep in item:\n            return True\n\n\n_has_insecure_pathelement = {'..', '.', ''}.intersection\n\n\n@lru_cache(1000)\ndef _secure_path(path_tuple):\n    if _has_insecure_pathelement(path_tuple):\n        # belt-and-suspenders security; this should never be true\n        # unless someone screws up the traversal_path code\n        # (request.subpath is computed via traversal_path too)\n        return None\n    if any([_contains_slash(item) for item in path_tuple]):\n        return None\n    encoded = '/'.join(path_tuple)  # will be unicode\n    return encoded\n\n\nclass QueryStringCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    a token for cache busting in the query string of an asset URL.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    To use this class, subclass it and provide a ``tokenize`` method which\n    accepts ``request, pathspec, kw`` and returns a token.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, param='x'):\n        self.param = param\n\n    def __call__(self, request, subpath, kw):\n        token = self.tokenize(request, subpath, kw)\n        query = kw.setdefault('_query', {})\n        if isinstance(query, dict):\n            query[self.param] = token\n        else:\n            kw['_query'] = tuple(query) + ((self.param, token),)\n        return subpath, kw\n\n\nclass QueryStringConstantCacheBuster(QueryStringCacheBuster):\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which adds\n    an arbitrary token for cache busting in the query string of an asset URL.\n\n    The ``token`` parameter is the token string to use for cache busting and\n    will be the same for every request.\n\n    The optional ``param`` argument determines the name of the parameter added\n    to the query string and defaults to ``'x'``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    def __init__(self, token, param='x'):\n        super().__init__(param=param)\n        self._token = token\n\n    def tokenize(self, request, subpath, kw):\n        return self._token\n\n\nclass ManifestCacheBuster:\n    \"\"\"\n    An implementation of :class:`~pyramid.interfaces.ICacheBuster` which\n    uses a supplied manifest file to map an asset path to a cache-busted\n    version of the path.\n\n    The ``manifest_spec`` can be an absolute path or a :term:`asset\n    specification` pointing to a package-relative file.\n\n    The manifest file is expected to conform to the following simple JSON\n    format:\n\n    .. code-block:: json\n\n       {\n           \"css/main.css\": \"css/main-678b7c80.css\",\n           \"images/background.png\": \"images/background-a8169106.png\",\n       }\n\n    By default, it is a JSON-serialized dictionary where the keys are the\n    source asset paths used in calls to\n    :meth:`~pyramid.request.Request.static_url`. For example:\n\n    .. code-block:: pycon\n\n       >>> request.static_url('myapp:static/css/main.css')\n       \"http://www.example.com/static/css/main-678b7c80.css\"\n\n    The file format and location can be changed by subclassing and overriding\n    :meth:`.parse_manifest`.\n\n    If a path is not found in the manifest it will pass through unchanged.\n\n    If ``reload`` is ``True`` then the manifest file will be reloaded when\n    changed. It is not recommended to leave this enabled in production.\n\n    If the manifest file cannot be found on disk it will be treated as\n    an empty mapping unless ``reload`` is ``False``.\n\n    .. versionadded:: 1.6\n    \"\"\"\n\n    exists = staticmethod(exists)  # testing\n    getmtime = staticmethod(getmtime)  # testing\n\n    def __init__(self, manifest_spec, reload=False):\n        package_name = caller_package().__name__\n        self.manifest_path = abspath_from_asset_spec(\n            manifest_spec, package_name\n        )\n        self.reload = reload\n\n        self._mtime = None\n        if not reload:\n            self._manifest = self.get_manifest()\n\n    def get_manifest(self):\n        with open(self.manifest_path, 'rb') as fp:\n            return self.parse_manifest(fp.read())\n\n    def parse_manifest(self, content):\n        \"\"\"\n        Parse the ``content`` read from the ``manifest_path`` into a\n        dictionary mapping.\n\n        Subclasses may override this method to use something other than\n        ``json.loads`` to load any type of file format and return a conforming\n        dictionary.\n\n        \"\"\"\n        return json.loads(content.decode('utf-8'))\n\n    @property\n    def manifest(self):\n        \"\"\"The current manifest dictionary.\"\"\"\n        if self.reload:\n            if not self.exists(self.manifest_path):\n                return {}\n            mtime = self.getmtime(self.manifest_path)\n            if self._mtime is None or mtime > self._mtime:\n                self._manifest = self.get_manifest()\n                self._mtime = mtime\n        return self._manifest\n\n    def __call__(self, request, subpath, kw):\n        subpath = self.manifest.get(subpath, subpath)\n        return (subpath, kw)\n", "patch": "@@ -260,12 +260,12 @@ def _add_vary(response, option):\n     response.vary = vary\n \n \n-_seps = {'/', os.sep}\n+_invalid_element_chars = {'/', os.sep, '\\x00'}\n \n \n-def _contains_slash(item):\n-    for sep in _seps:\n-        if sep in item:\n+def _contains_invalid_element_char(item):\n+    for invalid_element_char in _invalid_element_chars:\n+        if invalid_element_char in item:\n             return True\n \n \n@@ -279,7 +279,7 @@ def _secure_path(path_tuple):\n         # unless someone screws up the traversal_path code\n         # (request.subpath is computed via traversal_path too)\n         return None\n-    if any([_contains_slash(item) for item in path_tuple]):\n+    if any([_contains_invalid_element_char(item) for item in path_tuple]):\n         return None\n     encoded = '/'.join(path_tuple)  # will be unicode\n     return encoded", "file_path": "files/2023_8/124", "file_language": "py", "file_name": "src/pyramid/static.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/Pylons/pyramid/raw/347d7750da6f45c7436dd0c31468885cc9343c85/tests%2Ffixtures%2Findex.html", "code": "<h1>DON'T GO HERE</h1>\n", "code_before": "", "patch": "@@ -0,0 +1 @@\n+<h1>DON'T GO HERE</h1>", "file_path": "files/2023_8/125", "file_language": "html", "file_name": "tests/fixtures/index.html", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/Pylons/pyramid/raw/347d7750da6f45c7436dd0c31468885cc9343c85/tests%2Ftest_static.py", "code": "import datetime\nimport os.path\nimport unittest\n\nhere = os.path.dirname(__file__)\n\n# 5 years from now (more or less)\nfiveyrsfuture = datetime.datetime.utcnow() + datetime.timedelta(5 * 365)\n\n\nclass Test_static_view_use_subpath_False(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_ctor_defaultargs(self):\n        inst = self._makeOne('package:resource_name')\n        self.assertEqual(inst.package_name, 'package')\n        self.assertEqual(inst.docroot, 'resource_name')\n        self.assertEqual(inst.cache_max_age, 3600)\n        self.assertEqual(inst.index, 'index.html')\n        self.assertEqual(inst.reload, False)\n        self.assertEqual(inst.content_encodings, {})\n\n    def test_call_adds_slash_path_info_empty(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': ''})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPMovedPermanently\n\n        self.assertRaises(HTTPMovedPermanently, inst, context, request)\n\n    def test_path_info_slash_means_index_html(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_singledot(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/./index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_emptyelement(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '//index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_dotdotslash(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/subdir/../../minimal.pt'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash_encoded(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest(\n            {'PATH_INFO': '/subdir/%2E%2E%2F%2E%2E/minimal.pt'}\n        )\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_os_sep(self):\n        import os\n\n        inst = self._makeOne('tests:fixtures/static')\n        dds = '..' + os.sep\n        request = self._makeRequest(\n            {'PATH_INFO': '/subdir/%s%sminimal.pt' % (dds, dds)}\n        )\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_nul_char(self):\n        import os\n\n        inst = self._makeOne(f'{os.getcwd()}/tests/fixtures/static')\n        dds = '..\\x00/'\n        request = self._makeRequest(\n            {'PATH_INFO': f'/{dds}'}\n        )\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_doesnt_exist(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/notthere'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_isdir(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/subdir/'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>subdir</html>' in response.body)\n\n    def test_resource_is_file(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_resource_is_file_with_wsgi_file_wrapper(self):\n        from pyramid.response import _BLOCK_SIZE\n\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n\n        class _Wrapper:\n            def __init__(self, file, block_size=None):\n                self.file = file\n                self.block_size = block_size\n\n        request.environ['wsgi.file_wrapper'] = _Wrapper\n        context = DummyContext()\n        response = inst(context, request)\n        app_iter = response.app_iter\n        self.assertTrue(isinstance(app_iter, _Wrapper))\n        self.assertTrue(b'<html>static</html>' in app_iter.file.read())\n        self.assertEqual(app_iter.block_size, _BLOCK_SIZE)\n        app_iter.file.close()\n\n    def test_resource_is_file_with_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=600)\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 5)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names,\n            [\n                'Cache-Control',\n                'Content-Length',\n                'Content-Type',\n                'Expires',\n                'Last-Modified',\n            ],\n        )\n\n    def test_resource_is_file_with_no_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=None)\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 3)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names, ['Content-Length', 'Content-Type', 'Last-Modified']\n        )\n\n    def test_resource_notmodified(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        request.if_modified_since = fiveyrsfuture\n        context = DummyContext()\n        response = inst(context, request)\n        start_response = DummyStartResponse()\n        app_iter = response(request.environ, start_response)\n        try:\n            self.assertEqual(start_response.status, '304 Not Modified')\n            self.assertEqual(list(app_iter), [])\n        finally:\n            app_iter.close()\n\n    def test_not_found(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/notthere.html'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_gz_resource_no_content_encoding(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/arcs.svg.tgz'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertEqual(response.content_type, 'application/x-tar')\n        self.assertEqual(response.content_encoding, None)\n        response.app_iter.close()\n\n    def test_resource_no_content_encoding(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertEqual(response.content_type, 'text/html')\n        self.assertEqual(response.content_encoding, None)\n        response.app_iter.close()\n\n\nclass Test_static_view_use_subpath_True(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        kw['use_subpath'] = True\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_ctor_defaultargs(self):\n        inst = self._makeOne('package:resource_name')\n        self.assertEqual(inst.package_name, 'package')\n        self.assertEqual(inst.docroot, 'resource_name')\n        self.assertEqual(inst.cache_max_age, 3600)\n        self.assertEqual(inst.index, 'index.html')\n        self.assertEqual(inst.reload, False)\n        self.assertEqual(inst.content_encodings, {})\n\n    def test_call_adds_slash_path_info_empty(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': ''})\n        request.subpath = ()\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPMovedPermanently\n\n        self.assertRaises(HTTPMovedPermanently, inst, context, request)\n\n    def test_path_info_slash_means_index_html(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ()\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_singledot(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('.', 'index.html')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_emptyelement(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('', 'index.html')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir', '..', '..', 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash_encoded(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir', '%2E%2E', '%2E%2E', 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_os_sep(self):\n        import os\n\n        inst = self._makeOne('tests:fixtures/static')\n        dds = '..' + os.sep\n        request = self._makeRequest()\n        request.subpath = ('subdir', dds, dds, 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_doesnt_exist(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = 'notthere,'\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_isdir(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>subdir</html>' in response.body)\n\n    def test_resource_is_file(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_resource_is_file_with_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=600)\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 5)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names,\n            [\n                'Cache-Control',\n                'Content-Length',\n                'Content-Type',\n                'Expires',\n                'Last-Modified',\n            ],\n        )\n\n    def test_resource_is_file_with_no_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=None)\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 3)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names, ['Content-Length', 'Content-Type', 'Last-Modified']\n        )\n\n    def test_resource_notmodified(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.if_modified_since = fiveyrsfuture\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        start_response = DummyStartResponse()\n        app_iter = response(request.environ, start_response)\n        try:\n            self.assertEqual(start_response.status, '304 Not Modified')\n            self.assertEqual(list(app_iter), [])\n        finally:\n            app_iter.close()\n\n    def test_not_found(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('notthere.html',)\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n\nclass Test_static_view_content_encodings(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_call_without_accept(self):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/encoded.html'})\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 221)\n\n    def test_call_with_accept_gzip(self):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {'PATH_INFO': '/encoded.html', 'HTTP_ACCEPT_ENCODING': 'gzip'}\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_encoded_variant_without_unencoded_variant_no_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/only_encoded.html.gz'})\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_encoded_variant_without_unencoded_variant_with_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {\n                'PATH_INFO': '/only_encoded.html.gz',\n                'HTTP_ACCEPT_ENCODING': 'gzip',\n            }\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_no_accept(\n        self,\n    ):\n        from pyramid.httpexceptions import HTTPNotFound\n\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/only_encoded.html'})\n        context = DummyContext()\n\n        self.assertRaises(HTTPNotFound, lambda: inst(context, request))\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_with_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {\n                'PATH_INFO': '/only_encoded.html',\n                'HTTP_ACCEPT_ENCODING': 'gzip',\n            }\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_bad_accept(\n        self,\n    ):\n        from pyramid.httpexceptions import HTTPNotFound\n\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {'PATH_INFO': '/only_encoded.html', 'HTTP_ACCEPT_ENCODING': 'br'}\n        )\n        context = DummyContext()\n\n        self.assertRaises(HTTPNotFound, lambda: inst(context, request))\n\n    def test_call_get_possible_files_is_cached(self):\n        inst = self._makeOne('tests:fixtures/static')\n        result1 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        result2 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        self.assertIs(result1, result2)\n\n    def test_call_get_possible_files_is_not_cached(self):\n        inst = self._makeOne('tests:fixtures/static', reload=True)\n        result1 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        result2 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        self.assertIsNot(result1, result2)\n\n\nclass TestQueryStringConstantCacheBuster(unittest.TestCase):\n    def _makeOne(self, param=None):\n        from pyramid.static import QueryStringConstantCacheBuster as cls\n\n        if param:\n            inst = cls('foo', param)\n        else:\n            inst = cls('foo')\n        return inst\n\n    def test_token(self):\n        fut = self._makeOne().tokenize\n        self.assertEqual(fut(None, 'whatever', None), 'foo')\n\n    def test_it(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {}), ('bar', {'_query': {'x': 'foo'}})\n        )\n\n    def test_change_param(self):\n        fut = self._makeOne('y')\n        self.assertEqual(\n            fut('foo', 'bar', {}), ('bar', {'_query': {'y': 'foo'}})\n        )\n\n    def test_query_is_already_tuples(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {'_query': [('a', 'b')]}),\n            ('bar', {'_query': (('a', 'b'), ('x', 'foo'))}),\n        )\n\n    def test_query_is_tuple_of_tuples(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {'_query': (('a', 'b'),)}),\n            ('bar', {'_query': (('a', 'b'), ('x', 'foo'))}),\n        )\n\n\nclass TestManifestCacheBuster(unittest.TestCase):\n    def _makeOne(self, path, **kw):\n        from pyramid.static import ManifestCacheBuster as cls\n\n        return cls(path, **kw)\n\n    def test_it(self):\n        manifest_path = os.path.join(here, 'fixtures', 'manifest.json')\n        fut = self._makeOne(manifest_path)\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_it_with_relspec(self):\n        fut = self._makeOne('fixtures/manifest.json')\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_it_with_absspec(self):\n        fut = self._makeOne('tests:fixtures/manifest.json')\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_reload(self):\n        manifest_path = os.path.join(here, 'fixtures', 'manifest.json')\n        new_manifest_path = os.path.join(here, 'fixtures', 'manifest2.json')\n        inst = self._makeOne('foo', reload=True)\n        inst.getmtime = lambda *args, **kwargs: 0\n        fut = inst\n\n        # test without a valid manifest\n        self.assertEqual(fut('foo', 'css/main.css', {}), ('css/main.css', {}))\n\n        # swap to a real manifest, setting mtime to 0\n        inst.manifest_path = manifest_path\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n        # ensure switching the path doesn't change the result\n        inst.manifest_path = new_manifest_path\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n        # update mtime, should cause a reload\n        inst.getmtime = lambda *args, **kwargs: 1\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-678b7c80.css', {})\n        )\n\n    def test_invalid_manifest(self):\n        self.assertRaises(IOError, lambda: self._makeOne('foo'))\n\n    def test_invalid_manifest_with_reload(self):\n        inst = self._makeOne('foo', reload=True)\n        self.assertEqual(inst.manifest, {})\n\n\nclass DummyContext:\n    pass\n\n\nclass DummyStartResponse:\n    status = ()\n    headers = ()\n\n    def __call__(self, status, headers):\n        self.status = status\n        self.headers = headers\n", "code_before": "import datetime\nimport os.path\nimport unittest\n\nhere = os.path.dirname(__file__)\n\n# 5 years from now (more or less)\nfiveyrsfuture = datetime.datetime.utcnow() + datetime.timedelta(5 * 365)\n\n\nclass Test_static_view_use_subpath_False(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_ctor_defaultargs(self):\n        inst = self._makeOne('package:resource_name')\n        self.assertEqual(inst.package_name, 'package')\n        self.assertEqual(inst.docroot, 'resource_name')\n        self.assertEqual(inst.cache_max_age, 3600)\n        self.assertEqual(inst.index, 'index.html')\n        self.assertEqual(inst.reload, False)\n        self.assertEqual(inst.content_encodings, {})\n\n    def test_call_adds_slash_path_info_empty(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': ''})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPMovedPermanently\n\n        self.assertRaises(HTTPMovedPermanently, inst, context, request)\n\n    def test_path_info_slash_means_index_html(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_singledot(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/./index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_emptyelement(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '//index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_dotdotslash(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/subdir/../../minimal.pt'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash_encoded(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest(\n            {'PATH_INFO': '/subdir/%2E%2E%2F%2E%2E/minimal.pt'}\n        )\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_os_sep(self):\n        import os\n\n        inst = self._makeOne('tests:fixtures/static')\n        dds = '..' + os.sep\n        request = self._makeRequest(\n            {'PATH_INFO': '/subdir/%s%sminimal.pt' % (dds, dds)}\n        )\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_doesnt_exist(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/notthere'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_isdir(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/subdir/'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>subdir</html>' in response.body)\n\n    def test_resource_is_file(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_resource_is_file_with_wsgi_file_wrapper(self):\n        from pyramid.response import _BLOCK_SIZE\n\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n\n        class _Wrapper:\n            def __init__(self, file, block_size=None):\n                self.file = file\n                self.block_size = block_size\n\n        request.environ['wsgi.file_wrapper'] = _Wrapper\n        context = DummyContext()\n        response = inst(context, request)\n        app_iter = response.app_iter\n        self.assertTrue(isinstance(app_iter, _Wrapper))\n        self.assertTrue(b'<html>static</html>' in app_iter.file.read())\n        self.assertEqual(app_iter.block_size, _BLOCK_SIZE)\n        app_iter.file.close()\n\n    def test_resource_is_file_with_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=600)\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 5)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names,\n            [\n                'Cache-Control',\n                'Content-Length',\n                'Content-Type',\n                'Expires',\n                'Last-Modified',\n            ],\n        )\n\n    def test_resource_is_file_with_no_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=None)\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 3)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names, ['Content-Length', 'Content-Type', 'Last-Modified']\n        )\n\n    def test_resource_notmodified(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        request.if_modified_since = fiveyrsfuture\n        context = DummyContext()\n        response = inst(context, request)\n        start_response = DummyStartResponse()\n        app_iter = response(request.environ, start_response)\n        try:\n            self.assertEqual(start_response.status, '304 Not Modified')\n            self.assertEqual(list(app_iter), [])\n        finally:\n            app_iter.close()\n\n    def test_not_found(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/notthere.html'})\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_gz_resource_no_content_encoding(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/arcs.svg.tgz'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertEqual(response.content_type, 'application/x-tar')\n        self.assertEqual(response.content_encoding, None)\n        response.app_iter.close()\n\n    def test_resource_no_content_encoding(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': '/index.html'})\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertEqual(response.status, '200 OK')\n        self.assertEqual(response.content_type, 'text/html')\n        self.assertEqual(response.content_encoding, None)\n        response.app_iter.close()\n\n\nclass Test_static_view_use_subpath_True(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        kw['use_subpath'] = True\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_ctor_defaultargs(self):\n        inst = self._makeOne('package:resource_name')\n        self.assertEqual(inst.package_name, 'package')\n        self.assertEqual(inst.docroot, 'resource_name')\n        self.assertEqual(inst.cache_max_age, 3600)\n        self.assertEqual(inst.index, 'index.html')\n        self.assertEqual(inst.reload, False)\n        self.assertEqual(inst.content_encodings, {})\n\n    def test_call_adds_slash_path_info_empty(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest({'PATH_INFO': ''})\n        request.subpath = ()\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPMovedPermanently\n\n        self.assertRaises(HTTPMovedPermanently, inst, context, request)\n\n    def test_path_info_slash_means_index_html(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ()\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_oob_singledot(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('.', 'index.html')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_emptyelement(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('', 'index.html')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir', '..', '..', 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_dotdotslash_encoded(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir', '%2E%2E', '%2E%2E', 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_oob_os_sep(self):\n        import os\n\n        inst = self._makeOne('tests:fixtures/static')\n        dds = '..' + os.sep\n        request = self._makeRequest()\n        request.subpath = ('subdir', dds, dds, 'minimal.pt')\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_doesnt_exist(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = 'notthere,'\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n    def test_resource_isdir(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('subdir',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>subdir</html>' in response.body)\n\n    def test_resource_is_file(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n\n    def test_resource_is_file_with_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=600)\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 5)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names,\n            [\n                'Cache-Control',\n                'Content-Length',\n                'Content-Type',\n                'Expires',\n                'Last-Modified',\n            ],\n        )\n\n    def test_resource_is_file_with_no_cache_max_age(self):\n        inst = self._makeOne('tests:fixtures/static', cache_max_age=None)\n        request = self._makeRequest()\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        self.assertTrue(b'<html>static</html>' in response.body)\n        self.assertEqual(len(response.headerlist), 3)\n        header_names = [x[0] for x in response.headerlist]\n        header_names.sort()\n        self.assertEqual(\n            header_names, ['Content-Length', 'Content-Type', 'Last-Modified']\n        )\n\n    def test_resource_notmodified(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.if_modified_since = fiveyrsfuture\n        request.subpath = ('index.html',)\n        context = DummyContext()\n        response = inst(context, request)\n        start_response = DummyStartResponse()\n        app_iter = response(request.environ, start_response)\n        try:\n            self.assertEqual(start_response.status, '304 Not Modified')\n            self.assertEqual(list(app_iter), [])\n        finally:\n            app_iter.close()\n\n    def test_not_found(self):\n        inst = self._makeOne('tests:fixtures/static')\n        request = self._makeRequest()\n        request.subpath = ('notthere.html',)\n        context = DummyContext()\n        from pyramid.httpexceptions import HTTPNotFound\n\n        self.assertRaises(HTTPNotFound, inst, context, request)\n\n\nclass Test_static_view_content_encodings(unittest.TestCase):\n    def _getTargetClass(self):\n        from pyramid.static import static_view\n\n        return static_view\n\n    def _makeOne(self, *arg, **kw):\n        return self._getTargetClass()(*arg, **kw)\n\n    def _makeRequest(self, kw=None):\n        from pyramid.request import Request\n\n        environ = {\n            'wsgi.url_scheme': 'http',\n            'wsgi.version': (1, 0),\n            'SERVER_NAME': 'example.com',\n            'SERVER_PORT': '6543',\n            'PATH_INFO': '/',\n            'SCRIPT_NAME': '',\n            'REQUEST_METHOD': 'GET',\n        }\n        if kw is not None:\n            environ.update(kw)\n        return Request(environ=environ)\n\n    def test_call_without_accept(self):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/encoded.html'})\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 221)\n\n    def test_call_with_accept_gzip(self):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {'PATH_INFO': '/encoded.html', 'HTTP_ACCEPT_ENCODING': 'gzip'}\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertEqual(res.headers['Vary'], 'Accept-Encoding')\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_encoded_variant_without_unencoded_variant_no_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/only_encoded.html.gz'})\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_encoded_variant_without_unencoded_variant_with_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {\n                'PATH_INFO': '/only_encoded.html.gz',\n                'HTTP_ACCEPT_ENCODING': 'gzip',\n            }\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertNotIn('Content-Encoding', res.headers)\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_no_accept(\n        self,\n    ):\n        from pyramid.httpexceptions import HTTPNotFound\n\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest({'PATH_INFO': '/only_encoded.html'})\n        context = DummyContext()\n\n        self.assertRaises(HTTPNotFound, lambda: inst(context, request))\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_with_accept(\n        self,\n    ):\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {\n                'PATH_INFO': '/only_encoded.html',\n                'HTTP_ACCEPT_ENCODING': 'gzip',\n            }\n        )\n        context = DummyContext()\n\n        res = inst(context, request)\n        self.assertNotIn('Vary', res.headers)\n        self.assertEqual(res.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(len(res.body), 187)\n\n    def test_call_for_unencoded_variant_with_only_encoded_variant_bad_accept(\n        self,\n    ):\n        from pyramid.httpexceptions import HTTPNotFound\n\n        inst = self._makeOne(\n            'tests:fixtures/static', content_encodings=['gzip']\n        )\n        request = self._makeRequest(\n            {'PATH_INFO': '/only_encoded.html', 'HTTP_ACCEPT_ENCODING': 'br'}\n        )\n        context = DummyContext()\n\n        self.assertRaises(HTTPNotFound, lambda: inst(context, request))\n\n    def test_call_get_possible_files_is_cached(self):\n        inst = self._makeOne('tests:fixtures/static')\n        result1 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        result2 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        self.assertIs(result1, result2)\n\n    def test_call_get_possible_files_is_not_cached(self):\n        inst = self._makeOne('tests:fixtures/static', reload=True)\n        result1 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        result2 = inst.get_possible_files('tests:fixtures/static/encoded.html')\n        self.assertIsNot(result1, result2)\n\n\nclass TestQueryStringConstantCacheBuster(unittest.TestCase):\n    def _makeOne(self, param=None):\n        from pyramid.static import QueryStringConstantCacheBuster as cls\n\n        if param:\n            inst = cls('foo', param)\n        else:\n            inst = cls('foo')\n        return inst\n\n    def test_token(self):\n        fut = self._makeOne().tokenize\n        self.assertEqual(fut(None, 'whatever', None), 'foo')\n\n    def test_it(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {}), ('bar', {'_query': {'x': 'foo'}})\n        )\n\n    def test_change_param(self):\n        fut = self._makeOne('y')\n        self.assertEqual(\n            fut('foo', 'bar', {}), ('bar', {'_query': {'y': 'foo'}})\n        )\n\n    def test_query_is_already_tuples(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {'_query': [('a', 'b')]}),\n            ('bar', {'_query': (('a', 'b'), ('x', 'foo'))}),\n        )\n\n    def test_query_is_tuple_of_tuples(self):\n        fut = self._makeOne()\n        self.assertEqual(\n            fut('foo', 'bar', {'_query': (('a', 'b'),)}),\n            ('bar', {'_query': (('a', 'b'), ('x', 'foo'))}),\n        )\n\n\nclass TestManifestCacheBuster(unittest.TestCase):\n    def _makeOne(self, path, **kw):\n        from pyramid.static import ManifestCacheBuster as cls\n\n        return cls(path, **kw)\n\n    def test_it(self):\n        manifest_path = os.path.join(here, 'fixtures', 'manifest.json')\n        fut = self._makeOne(manifest_path)\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_it_with_relspec(self):\n        fut = self._makeOne('fixtures/manifest.json')\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_it_with_absspec(self):\n        fut = self._makeOne('tests:fixtures/manifest.json')\n        self.assertEqual(fut('foo', 'bar', {}), ('bar', {}))\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n    def test_reload(self):\n        manifest_path = os.path.join(here, 'fixtures', 'manifest.json')\n        new_manifest_path = os.path.join(here, 'fixtures', 'manifest2.json')\n        inst = self._makeOne('foo', reload=True)\n        inst.getmtime = lambda *args, **kwargs: 0\n        fut = inst\n\n        # test without a valid manifest\n        self.assertEqual(fut('foo', 'css/main.css', {}), ('css/main.css', {}))\n\n        # swap to a real manifest, setting mtime to 0\n        inst.manifest_path = manifest_path\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n        # ensure switching the path doesn't change the result\n        inst.manifest_path = new_manifest_path\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-test.css', {})\n        )\n\n        # update mtime, should cause a reload\n        inst.getmtime = lambda *args, **kwargs: 1\n        self.assertEqual(\n            fut('foo', 'css/main.css', {}), ('css/main-678b7c80.css', {})\n        )\n\n    def test_invalid_manifest(self):\n        self.assertRaises(IOError, lambda: self._makeOne('foo'))\n\n    def test_invalid_manifest_with_reload(self):\n        inst = self._makeOne('foo', reload=True)\n        self.assertEqual(inst.manifest, {})\n\n\nclass DummyContext:\n    pass\n\n\nclass DummyStartResponse:\n    status = ()\n    headers = ()\n\n    def __call__(self, status, headers):\n        self.status = status\n        self.headers = headers\n", "patch": "@@ -104,6 +104,19 @@ def test_oob_os_sep(self):\n \n         self.assertRaises(HTTPNotFound, inst, context, request)\n \n+    def test_oob_nul_char(self):\n+        import os\n+\n+        inst = self._makeOne(f'{os.getcwd()}/tests/fixtures/static')\n+        dds = '..\\x00/'\n+        request = self._makeRequest(\n+            {'PATH_INFO': f'/{dds}'}\n+        )\n+        context = DummyContext()\n+        from pyramid.httpexceptions import HTTPNotFound\n+\n+        self.assertRaises(HTTPNotFound, inst, context, request)\n+\n     def test_resource_doesnt_exist(self):\n         inst = self._makeOne('tests:fixtures/static')\n         request = self._makeRequest({'PATH_INFO': '/notthere'})", "file_path": "files/2023_8/126", "file_language": "py", "file_name": "tests/test_static.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
