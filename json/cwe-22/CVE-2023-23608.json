{"index": 10203, "cve_id": "CVE-2023-23608", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Spotipy is a light weight Python library for the Spotify Web API. In versions prior to 2.22.1, if a malicious URI is passed to the library, the library can be tricked into performing an operation on a different API endpoint than intended. The code Spotipy uses to parse URIs and URLs allows an attacker to insert arbitrary characters into the path that is used for API requests. Because it is possible to include \"..\", an attacker can redirect for example a track lookup via spotifyApi.track() to an arbitrary API endpoint like playlists, but this is possible for other endpoints as well. The impact of this vulnerability depends heavily on what operations a client application performs when it handles a URI from a user and how it uses the responses it receives from the API. This issue is patched in version 2.22.1.", "cvss": "4.3", "publish_date": "January 26, 2023", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "REQUIRED", "S": "UNCHANGED", "C": "NONE", "I": "LOW", "A": "NONE", "commit_id": "b1db0b63d90eae40af32d7ee4c760c2fd581a1b4", "commit_message": "Merge pull request from GHSA-q764-g6fm-555v\n\n* Improve URL and URI handling\n\n* Back to SpotifyException for backward-compatibility\n\n* fix copy paste typo\n\n* TODO v3 comments\n\nCo-authored-by: Stephane Bruckert <stephane.bruckert@gmail.com>", "commit_date": "2023-01-23T18:50:07Z", "project": "spotipy-dev/spotipy", "url": "https://api.github.com/repos/spotipy-dev/spotipy/commits/b1db0b63d90eae40af32d7ee4c760c2fd581a1b4", "html_url": "https://github.com/spotipy-dev/spotipy/commit/b1db0b63d90eae40af32d7ee4c760c2fd581a1b4", "windows_before": [{"commit_id": "262e7a0443ece48ce6825f97ad9a3ed205ceb725", "commit_date": "Mon Jan 23 13:48:37 2023 +0100", "commit_message": "Rename simple files (#933)", "files_name": ["examples/simple_artist_albums.py", "examples/simple_artist_top_tracks.py", "examples/simple_me.py", "examples/simple_search_artist.py", "examples/simple_search_artist_image_url.py"]}, {"commit_id": "d884ae13c24a28ff090576139a6b103bee6d0e8c", "commit_date": "Sun Jan 15 23:30:37 2023 +0000", "commit_message": "Fix typo in start_playback function (#930)", "files_name": ["spotipy/client.py"]}, {"commit_id": "f669966a7221a25051e84d8e9eb5933ac4772aa4", "commit_date": "Sat Jan 7 08:27:58 2023 +0000", "commit_message": "Update SECURITY.md", "files_name": [".github/SECURITY.md"]}, {"commit_id": "0b9062726c079958afd5c641ed7175c5c83a7b66", "commit_date": "Sat Jan 7 08:26:17 2023 +0000", "commit_message": "Create SECURITY.md", "files_name": [".github/SECURITY.md"]}, {"commit_id": "d0bbe67302cb89e0d071e3319fbcdd75d414936b", "commit_date": "Tue Dec 27 06:27:17 2022 -0800", "commit_message": "Add additional video tutorial reference to documentation. (#921)", "files_name": ["docs/index.rst"]}, {"commit_id": "922d51df02536171db2087f562695bc7884652f2", "commit_date": "Fri Dec 16 14:17:37 2022 -0500", "commit_message": "modified docstring for playlist_add_items to no longer accept IDs", "files_name": ["CHANGELOG.md", "docs/conf.py", "examples/add_tracks_to_playlist.py", "examples/app.py", "examples/artist_discography.py", "examples/follow_playlist.py", "examples/headless.py", "examples/multiple_accounts.py", "examples/my_playlists.py", "examples/my_top_tracks.py", "examples/playlist_add_items.py", "examples/playlist_tracks.py", "examples/simple3.py", "examples/user_playlists.py", "spotipy/client.py"]}, {"commit_id": "edd3f29a2c6dacd7d5358968ab48584fa47d96af", "commit_date": "Sat Dec 10 10:27:29 2022 -0600", "commit_message": "Getting Started Clarifications and  Example Code File (#904)", "files_name": ["CHANGELOG.md", "README.md", "examples/playlist_add_items.py", "examples/show_artist_top_tracks.py"]}, {"commit_id": "1377879972f5ee94a9ae35f9948bf1b701515555", "commit_date": "Sat Dec 10 16:02:03 2022 +0000", "commit_message": "Update contributing.md", "files_name": ["CHANGELOG.md", "CONTRIBUTING.md"]}, {"commit_id": "1e840b652666108ac233b9bfde38487553a3dbaa", "commit_date": "Sat Dec 10 15:31:47 2022 +0000", "commit_message": "Bump to 2.22.0", "files_name": ["CHANGELOG.md", "setup.py"]}, {"commit_id": "d2384c1c33519feed544adc6feb44c58118a5159", "commit_date": "Sat Dec 10 08:22:45 2022 -0600", "commit_message": "Add CODE_OF_CONDUCT.md (#897)", "files_name": ["CHANGELOG.md", "CODE_OF_CONDUCT.md"]}, {"commit_id": "5201f58247f863dbe5eb8048684fa2f9e8e0a849", "commit_date": "Sat Nov 26 01:29:53 2022 -0800", "commit_message": "Add tests for global categories, releases, fix bugged tests (#893)", "files_name": ["CHANGELOG.md", "tests/integration/non_user_endpoints/test.py", "tests/integration/user_endpoints/test.py"]}, {"commit_id": "edcd3228454e9d61a7d751e5a8e0240c7a3d17d6", "commit_date": "Sat Nov 26 08:40:49 2022 +0000", "commit_message": "Pin Github Actions Runner to Ubuntu 20 for Py27 (#894)", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md"]}, {"commit_id": "6f56504c2c516e7f6da2133ce5907611dc0162c2", "commit_date": "Sun Nov 13 02:42:25 2022 -0800", "commit_message": "Update category tests to fix 1 failing and 1 error test results (#886)", "files_name": ["CHANGELOG.md", "tests/integration/user_endpoints/test.py"]}, {"commit_id": "1265d7b9155536a305c2f6dbebeb5c13e042e110", "commit_date": "Tue Nov 1 21:57:40 2022 +0000", "commit_message": "GHA integration tests (#876)", "files_name": ["CHANGELOG.md", "tests/integration/non_user_endpoints/__init__.py", "tests/integration/non_user_endpoints/test.py", "tests/integration/user_endpoints/__init__.py", "tests/integration/user_endpoints/test.py"]}, {"commit_id": "e9fd81ce21fb0938e9f219f0890dd2a446abfa2e", "commit_date": "Tue Nov 1 21:52:01 2022 +0000", "commit_message": "Update integration_tests.yml", "files_name": [".github/workflows/integration_tests.yml"]}, {"commit_id": "459be3d400c7030ca6137516ba23e2aee70fd70e", "commit_date": "Tue Nov 1 21:36:43 2022 +0000", "commit_message": "Integration tests workflow (2)", "files_name": [".github/workflows/integration_tests.yml"]}, {"commit_id": "0c32cd74d987e4a65042baaa9d023c1652baae13", "commit_date": "Tue Nov 1 21:26:01 2022 +0000", "commit_message": "Integration tests workflow", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md"]}, {"commit_id": "9bf5e342c2230744c178072459ef2d9072030001", "commit_date": "Tue Nov 1 20:52:25 2022 +0000", "commit_message": "Add secrets to GHA workflow (#877)", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md"]}, {"commit_id": "cc5eaca191fd74f98dfb3df1436b5e24b2e31884", "commit_date": "Sat Oct 29 16:50:56 2022 +0200", "commit_message": "Fix linting in test_non_user_endpoints (#841)", "files_name": ["fa44fed76d7aecb70f9ee6cde14da5e2ce1e17d7 - Sat Oct 29 14:23:43 2022 +0100 : Fix a few typos in comments & strings (#866)", "spotipy/client.py", "spotipy/oauth2.py", "spotipy/util.py", "tests/integration/test_non_user_endpoints.py"]}, {"commit_id": "dd69a4865962c080635eccafd0b67b9732f55323", "commit_date": "Sat Oct 29 10:20:50 2022 -0300", "commit_message": "Create tutorial for beginners (#872)", "files_name": ["TUTORIAL.md"]}, {"commit_id": "be759d3f50f12bcdfdd861af138ba02352b04a29", "commit_date": "Sat Oct 29 14:01:25 2022 +0200", "commit_message": "Implement get-queue endpoint (#854)", "files_name": ["spotipy/client.py"]}, {"commit_id": "5a7e5c5a4359ed3dc72b84fdc22866337d90cf16", "commit_date": "Wed Oct 26 23:03:42 2022 +0100", "commit_message": "Bump to 2.21.0, closes #836", "files_name": ["CHANGELOG.md", "setup.py"]}, {"commit_id": "fd8f97d46a8614e07546a63499ddabdfcdae3a0f", "commit_date": "Wed Oct 26 23:59:10 2022 +0200", "commit_message": "Add python 3.10 to GitHub Actions (#863)", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md"]}, {"commit_id": "06765c4f5a07587378e9c9d57433e271805f53c7", "commit_date": "Wed Oct 26 22:56:38 2022 +0100", "commit_message": "Fix flake8", "files_name": ["tests/integration/test_non_user_endpoints.py"]}, {"commit_id": "be2739146138a0d5717967cc62927c15ecc9a7c3", "commit_date": "Tue Aug 30 18:16:38 2022 -0400", "commit_message": "Add missing step to CONTRIBUTING.md to activate virtualenv (#848)", "files_name": ["CONTRIBUTING.md"]}, {"commit_id": "7fc08809f0289ebff229819b02d10e5631d6dee1", "commit_date": "Sat Jun 25 14:00:08 2022 -0500", "commit_message": "Add FlaskSessionCacheHandler (#833)", "files_name": ["CHANGELOG.md", "docs/index.rst", "examples/app.py", "spotipy/cache_handler.py"]}, {"commit_id": "7337bf935273ac438f3e6ba346ce19c4e74ba159", "commit_date": "Sun Jun 19 09:03:13 2022 +0100", "commit_message": "Fix readthedocs", "files_name": ["CHANGELOG.md", "setup.py"]}, {"commit_id": "eab3c37b89c9d9027670ad8c928caf9f5d89bb32", "commit_date": "Sat Jun 18 15:34:36 2022 -0700", "commit_message": "Updated documentation (#826)", "files_name": ["CHANGELOG.md", "docs/index.rst"]}, {"commit_id": "ca73420248194dc483625c973cbf58012c73537f", "commit_date": "Sat Jun 18 15:30:07 2022 -0700", "commit_message": "Added documentation for windows users attempting to set environment variables (#822)", "files_name": ["CONTRIBUTING.md", "docs/index.rst"]}, {"commit_id": "36ea3d93190dd6c1c4d0e551b4cacc3416f669d3", "commit_date": "Sat Jun 18 23:29:12 2022 +0100", "commit_message": "Fix lint", "files_name": ["tests/integration/test_user_endpoints.py"]}, {"commit_id": "1b0c426984f4beee2129ef854e2537c18288122c", "commit_date": "Sat Jun 18 15:28:08 2022 -0700", "commit_message": "Addition of Test Cases (#818)", "files_name": ["tests/integration/test_user_endpoints.py"]}, {"commit_id": "a4cfd839464460d262e7dc219c7568490f05166b", "commit_date": "Sat Jun 18 15:26:43 2022 -0700", "commit_message": "show_featured_artists.py and update publishing docs (#821)", "files_name": ["CHANGELOG.md", "examples/show_featured_artists.py"]}, {"commit_id": "61c8cda00608828e83b0148781252bd3666e7d67", "commit_date": "Sat Jun 18 23:24:49 2022 +0100", "commit_message": "Fix lint", "files_name": ["spotipy/client.py"]}, {"commit_id": "6164dbb628364ec3a9190292bc14d0adc5223f6e", "commit_date": "Sat Jun 18 15:20:37 2022 -0700", "commit_message": "Fixed and clarified docstrings for client.py  (#820)", "files_name": ["spotipy/client.py"]}, {"commit_id": "c6b56a658a88c9d644453037ed72e4f8b4749422", "commit_date": "Sat Jun 18 15:20:11 2022 -0700", "commit_message": "Add YT video URL to doc (#816)", "files_name": ["docs/index.rst"]}, {"commit_id": "13593c54cb6921510cbe2ce94a3846e5776dc00b", "commit_date": "Sat Jun 18 18:19:27 2022 -0400", "commit_message": "Added a new example: follow_playlist.py (#804)", "files_name": ["examples/follow_playlist.py"]}, {"commit_id": "5175f19851a1c377ea818f00538fc5b98355b2e1", "commit_date": "Sat Jun 18 15:18:59 2022 -0700", "commit_message": "Updated documentation about ISO-639 language codes and address issue #753 (#800)", "files_name": ["CHANGELOG.md", "spotipy/client.py"]}, {"commit_id": "14ee53eacd63916d75b7e0186e82f25cc337ef6c", "commit_date": "Sun Jun 19 01:18:20 2022 +0300", "commit_message": "Add GitHub URL for PyPi (#787)", "files_name": ["setup.py"]}, {"commit_id": "72a6cd9190b9cd3919479b4ebeb30483a6943969", "commit_date": "Sun Jun 19 02:47:58 2022 +0430", "commit_message": "Fix text attribute for Response object (#811)", "files_name": ["CHANGELOG.md", "spotipy/oauth2.py"]}, {"commit_id": "c1a85f146962c3c58aa9fc0d92060e236626f217", "commit_date": "Sat Jun 18 22:59:37 2022 +0100", "commit_message": "Bump to 2.20.0, closes #806", "files_name": ["CHANGELOG.md", "setup.py"]}, {"commit_id": "98f0f7623879ad3dfdfa911a0144fc639c49c6b1", "commit_date": "Sat Jun 18 22:56:42 2022 +0100", "commit_message": "Removed Python 3.5 and added Python 3.9 in Github Action (#831)", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md"]}, {"commit_id": "9a627e88f422927822ce39ae9919cc7ab9813dde", "commit_date": "Mon Jan 3 19:33:13 2022 +0100", "commit_message": "Simplify check for existing token (#765)", "files_name": ["CHANGELOG.md", "spotipy/cache_handler.py"]}, {"commit_id": "08411b9031d5ce90c55f6083665b8412691e741a", "commit_date": "Wed Dec 22 15:44:38 2021 +0100", "commit_message": "Allow to set custom key in RedisCacheHandler (#761)", "files_name": ["CHANGELOG.md", "spotipy/cache_handler.py"]}, {"commit_id": "0464f4f483f7f60eed71278f13f5182dc249c4aa", "commit_date": "Fri Dec 17 17:20:47 2021 -0500", "commit_message": "Remove query parameters from URI (#758)", "files_name": ["CHANGELOG.md", "spotipy/client.py"]}, {"commit_id": "2aeda6a2c2f9dfc743decd455558c6cc430ba883", "commit_date": "Tue Nov 23 13:48:53 2021 -0800", "commit_message": "Adding example for unfollowing/deleting a playlist (#746)", "files_name": ["examples/unfollow_playlist.py"]}, {"commit_id": "7d23fc327723443c2c413da81758195ac54fc2b5", "commit_date": "Tue Nov 23 04:31:58 2021 +0900", "commit_message": "Add RedisCacheHandler (#747)", "files_name": ["CHANGELOG.md", "docs/index.rst", "setup.py", "spotipy/cache_handler.py"]}, {"commit_id": "0a9270f3853774d60210a66da66496684422b559", "commit_date": "Sat Oct 30 22:22:21 2021 +0200", "commit_message": "Update link to usage scopes (#738)", "files_name": []}], "windows_after": [{"commit_id": "beec3dad1f886f1ad68502b619f40329cf766dc9", "commit_date": "Mon Jan 23 18:54:40 2023 +0000", "commit_message": "Fix flake8", "files_name": ["spotipy/client.py"]}, {"commit_id": "c53511bbbe87f89c2aeaa65bef584539db440f97", "commit_date": "Mon Jan 23 19:00:55 2023 +0000", "commit_message": "Bump to 2.22.1", "files_name": ["CHANGELOG.md", "setup.py"]}, {"commit_id": "b3f308d2894d0d90538d5dc604a648ad1a9ca849", "commit_date": "Sun Feb 12 17:58:55 2023 -0500", "commit_message": "Add encoder_cls argument to CacheFileHandler (#941)", "files_name": ["CHANGELOG.md", "spotipy/cache_handler.py"]}, {"commit_id": "572195617b3d63f05f4083a4067fe6eb0dfe448b", "commit_date": "Tue Feb 14 15:00:59 2023 +0100", "commit_message": "Fix SpotifyPKCE docstring (#942)", "files_name": ["spotipy/oauth2.py"]}, {"commit_id": "ca332a538ec7e23e74b73a7faf73e489527c6cfc", "commit_date": "Tue Feb 28 13:11:22 2023 +0530", "commit_message": "Fixing a typo in the docs (#945)", "files_name": ["docs/index.rst"]}, {"commit_id": "f2d23e2219cd490c880a64ead419f67dd37e2ee3", "commit_date": "Wed Mar 15 23:17:02 2023 +0800", "commit_message": "Fix regex to support detailed URI #947 (#949)", "files_name": ["CHANGELOG.md", "spotipy/client.py"]}, {"commit_id": "fe438c0432b962e5f95aa463c3bba23522fd2a2b", "commit_date": "Wed Mar 15 16:46:08 2023 -0700", "commit_message": "Update search_markets method to apply the total parameter to all types, add tests (#901)", "files_name": ["CHANGELOG.md", "spotipy/client.py", "tests/integration/non_user_endpoints/test.py"]}, {"commit_id": "b7baaabf7403b1e6c5daf57f4bb6a7ca64cdfef1", "commit_date": "Thu Mar 30 13:12:41 2023 -0400", "commit_message": "fixed contributing.md (#955)", "files_name": ["CHANGELOG.md", "CONTRIBUTING.md"]}, {"commit_id": "3bac7250ec6dd91398887e3ee6d7d7709a688e89", "commit_date": "Fri Apr 7 12:33:32 2023 +0100", "commit_message": "Publish to PyPI action (#958)", "files_name": [".github/workflows/publish.yml", "CHANGELOG.md"]}, {"commit_id": "796c03338f3dd4896133b36fcf4bd7dce395052e", "commit_date": "Fri Apr 7 18:36:17 2023 +0100", "commit_message": "Bump to 2.23.0 (#959)", "files_name": [".github/workflows/publish.yml", "CHANGELOG.md", "CONTRIBUTING.md", "setup.py"]}, {"commit_id": "612b30efa3168008e7b092ba1f1b17802d5aed49", "commit_date": "Sun Apr 9 15:52:22 2023 +0100", "commit_message": "Create .github/dependabot.yml", "files_name": [".github/dependabot.yml"]}, {"commit_id": "45f78ce7a6861f6f43832b93fbf844756db11632", "commit_date": "Sun Apr 9 15:53:17 2023 +0100", "commit_message": "Update dependabot.yml", "files_name": [".github/dependabot.yml"]}, {"commit_id": "3b6d14404e4c51226cbd2ed9ed704f701d8eaedb", "commit_date": "Mon Apr 24 05:21:19 2023 -0700", "commit_message": "Updates the video link to a high definition video (#967)", "files_name": ["CHANGELOG.md", "docs/index.rst"]}, {"commit_id": "d31969108d462c544f41aba4581a0d84a1e75d6f", "commit_date": "Tue May 2 14:26:40 2023 -0700", "commit_message": "Update links in documentation (#969)", "files_name": ["CHANGELOG.md", "FAQ.md", "docs/index.rst"]}, {"commit_id": "1416d47cba95428e3a22b22d105d39aa9c08d904", "commit_date": "Mon Oct 30 21:32:46 2023 -0400", "commit_message": "Audiobook Support and CI Workflow Update (#1036)", "files_name": [".github/workflows/pythonapp.yml", "CHANGELOG.md", "spotipy/client.py", "tests/integration/non_user_endpoints/test.py"]}], "parents": [{"commit_id_before": "262e7a0443ece48ce6825f97ad9a3ed205ceb725", "url_before": "https://api.github.com/repos/spotipy-dev/spotipy/commits/262e7a0443ece48ce6825f97ad9a3ed205ceb725", "html_url_before": "https://github.com/spotipy-dev/spotipy/commit/262e7a0443ece48ce6825f97ad9a3ed205ceb725"}], "details": [{"raw_url": "https://github.com/spotipy-dev/spotipy/raw/b1db0b63d90eae40af32d7ee4c760c2fd581a1b4/CHANGELOG.md", "code": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## Unreleased\n\n// Add new changes below this line\n\n### Added\n\n- Add alternative module installation instruction to README\n- Added Comment to README - Getting Started for user to add URI to app in Spotify Developer Dashboard. \n- Added playlist_add_tracks.py to example folder\n\n### Changed\n\n- Modified docstring for playlist_add_items() to accept \"only URIs or URLs\",\n  with intended deprecation for IDs in v3\n\n### Fixed\n\n- Path traversal vulnerability that may lead to type confusion in URI handling code\n- Update contributing.md\n\n### Removed\n\n## [2.22.0] - 2022-12-10\n\n### Added\n\n- Integration tests via GHA (non-user endpoints)\n- Unit tests for new releases, passing limit parameter with minimum and maximum values of 1 and 50\n- Unit tests for categories, omitting country code to test global releases\n- Added `CODE_OF_CONDUCT.md`\n\n### Fixed\n\n- Incorrect `category_id` input for test_category\n- Assertion value for `test_categories_limit_low` and `test_categories_limit_high`\n- Pin Github Actions Runner to Ubuntu 20 for Py27\n- Fixed potential error where `found` variable in `test_artist_related_artists` is undefined if for loop never evaluates to true\n- Fixed false positive test `test_new_releases` which looks up the wrong property of the JSON response object and always evaluates to true\n\n## [2.21.0] - 2022-09-26\n\n### Added\n\n- Added `market` parameter to `album` and `albums` to address ([#753](https://github.com/plamere/spotipy/issues/753)\n- Added `show_featured_artists.py` to `/examples`.\n- Expanded contribution and license sections of the documentation.\n- Added `FlaskSessionCacheHandler`, a cache handler that stores the token info in a flask session.\n- Added Python 3.10 in GitHub Actions\n\n### Fixed\n\n- Updated the documentation to specify ISO-639-1 language codes.\n- Fix `AttributeError` for `text` attribute of the `Response` object\n- Require redis v3 if python2.7 (fixes readthedocs)\n\n## [2.20.0] - 2022-06-18\n\n### Added\n\n- Added `RedisCacheHandler`, a cache handler that stores the token info in Redis.\n- Changed URI handling in `client.Spotify._get_id()` to remove qureies if provided by error.\n- Added a new parameter to `RedisCacheHandler` to allow custom keys (instead of the default `token_info` key)\n- Simplify check for existing token in `RedisCacheHandler`\n\n### Changed\n\n- Removed Python 3.5 and added Python 3.9 in Github Action\n\n## [2.19.0] - 2021-08-12\n\n### Added\n\n- Added `MemoryCacheHandler`, a cache handler that simply stores the token info in memory as an instance attribute of this class.\n- If a network request returns an error status code but the response body cannot be decoded into JSON, then fall back on decoding the body into a string.\n- Added `DjangoSessionCacheHandler`, a cache handler that stores the token in the session framework provided by Django. Web apps using spotipy with Django can directly use this for cache handling.\n\n### Fixed\n\n- Fixed a bug in `CacheFileHandler.__init__`: The documentation says that the username will be retrieved from the environment, but it wasn't.\n- Fixed a bug in the initializers for the auth managers that produced a spurious warning message if you provide a cache handler and you set a value for the \"SPOTIPY_CLIENT_USERNAME\" environment variable.\n- Use generated MIT license and fix license type in `pip show`\n\n## [2.18.0] - 2021-04-13\n\n### Added\n\n- Enabled using both short and long IDs for playlist_change_details\n- Added a cache handler to `SpotifyClientCredentials`\n- Added the following endpoints\n    - `Spotify.current_user_saved_episodes`\n    - `Spotify.current_user_saved_episodes_add`\n    - `Spotify.current_user_saved_episodes_delete`\n    - `Spotify.current_user_saved_episodes_contains`\n    - `Spotify.available_markets`\n\n### Changed\n\n- Add support for a list of scopes rather than just a comma separated string of scopes\n\n### Fixed\n\n- Fixed the bugs in `SpotifyOAuth.refresh_access_token` and `SpotifyPKCE.refresh_access_token` which raised the incorrect exception upon receiving an error response from the server. This addresses #645.\n- Fixed a bug in `RequestHandler.do_GET` in which the non-existent `state` attribute of `SpotifyOauthError` is accessed. This bug occurs when the user clicks \"cancel\" in the permissions dialog that opens in the browser.\n- Cleaned up the documentation for `SpotifyClientCredentials.__init__`, `SpotifyOAuth.__init__`, and `SpotifyPKCE.__init__`.\n\n## [2.17.1] - 2021-02-28\n\n### Fixed\n\n- `allowed_methods` requires urllib3>=1.26.0\n\n## [2.17.0] - 2021-02-28\n\n### Changed\n\n- moved os.remove(session_cache_path()) inside try block to avoid TypeError on app.py example file\n- A warning will no longer be emitted when the cache file does not exist at the specified path\n- The docs for the `auth` parameter of `Spotify.init` use the term \"access token\" instead of \"authorization token\"\n- Changed docs for `search` to mention that you can provide multiple types to search for\n- The query parameters of requests are now logged\n- Deprecate specifing `cache_path` or `username` directly to `SpotifyOAuth`, `SpotifyPKCE`, and `SpotifyImplicitGrant` constructors, instead directing users to use the `CacheFileHandler` cache handler\n- Removed requirement for examples/app.py to specify port multiple times (only SPOTIPY_REDIRECT_URI needs to contain the port)\n\n### Added\n\n- Added log messages for when the access and refresh tokens are retrieved and when they are refreshed\n- Support `market` optional parameter in `track`\n- Added CacheHandler abstraction to allow users to cache tokens in any way they see fit\n\n### Fixed\n\n- Fixed Spotify.user_playlist_reorder_tracks calling Spotify.playlist_reorder_tracks with an incorrect parameter order\n- Fixed deprecated Urllib3 `Retry(method_whitelist=...)` in favor of `Retry(allowed_methods=...)`\n\n## [2.16.1] - 2020-10-24\n\n### Fixed\n\n- playlist_tracks example code no longer prints extra characters on final loop iteration\n- SpotifyException now thrown when a request fails & has no response ([#571](https://github.com/plamere/spotipy/issues/571), [#581](https://github.com/plamere/spotipy/issues/581))\n- Added scope, `playlist-read-private`, to examples that access user playlists using the spotipy api: current_user_playlists() ([#591](https://github.com/plamere/spotipy/issues/591))\n- Enable retries for POST, DELETE, PUT ([#577](https://github.com/plamere/spotipy/issues/577))\n\n### Changed\n\n- both inline and starting import lists are sorted using `isort` module\n- changed Max Retries exception code from 599 to 429\n\n## [2.16.0] - 2020-09-16\n\n### Added\n\n- `open_browser` can be passed to the constructors of `SpotifyOAuth` and `SpotifyPKCE` to make it easier to authorize in browserless environments\n\n## [2.15.0] - 2020-09-08\n\n### Added\n\n- `SpotifyPKCE.parse_auth_response_url`, mirroring that method in\n    `SpotifyOAuth`\n\n### Changed\n\n- Specifying a cache_path or username is now optional\n\n### Fixed\n\n- Using `SpotifyPKCE.get_authorization_url` will now generate a code\n    challenge if needed\n\n## [2.14.0] - 2020-08-29\n\n### Added\n\n- (experimental) Support to search multiple/all markets at once.\n- Support to test whether the current user is following certain\n    users or artists\n- Proper replacements for all deprecated playlist endpoints\n    (See https://developer.spotify.com/community/news/2018/06/12/changes-to-playlist-uris/ and below)\n- Allow for OAuth 2.0 authorization by instructing the user to open the URL in a browser instead of opening the browser.\n- Reason for 403 error in SpotifyException\n- Support for the PKCE Auth Flow\n- Support to advertise different language to Spotify\n- Added 'collaborative' parameter to user_playlist_create method.\n- Enforce CHANGELOG update on PR\n- Adds `additional_types` parameter to retrieve currently playing podcast episode\n- Support to get info about a single category\n\n### Deprecated\n\n- `user_playlist_change_details` in favor of `playlist_change_details`\n- `user_playlist_unfollow` in favor of `current_user_unfollow_playlist`\n- `user_playlist_add_tracks` in favor of `playlist_add_items`\n- `user_playlist_replace_tracks` in favor of `playlist_replace_items`\n- `user_playlist_reorder_tracks` in favor of `playlist_reorder_items`\n- `user_playlist_remove_all_occurrences_of_tracks` in favor of\n    `playlist_remove_all_occurrences_of_items`\n- `user_playlist_remove_specific_occurrences_of_tracks` in favor of\n    `playlist_remove_specific_occurrences_of_items`\n- `user_playlist_follow_playlist` in favor of\n    `current_user_follow_playlist`\n- `user_playlist_is_following` in favor of `playlist_is_following`\n- `playlist_tracks` in favor of `playlist_items`\n\n### Fixed\n\n- fixed issue where episode URIs were being converted to track URIs in playlist calls\n\n## [2.13.0] - 2020-06-25\n\n### Added\n\n- Added `SpotifyImplicitGrant` as an auth manager option. It provides\n    user authentication without a client secret but sacrifices the ability\n    to refresh the token without user input. (However, read the class\n    docstring for security advisory.)\n- Added built-in verification of the `state` query parameter\n- Added two new attributes: error and error_description to `SpotifyOauthError` exception class to show\n    authorization/authentication web api errors details.\n- Added `SpotifyStateError` subclass of `SpotifyOauthError`\n- Allow extending `SpotifyClientCredentials` and `SpotifyOAuth`\n- Added the market paramter to `album_tracks`\n\n### Deprecated\n\n- Deprecated `util.prompt_for_user_token` in favor of `spotipy.Spotify(auth_manager=SpotifyOAuth())`\n\n## [2.12.0] - 2020-04-26\n\n### Added\n\n- Added a method to update the auth token.\n\n### Fixed\n\n- Logging regression due to the addition of `logging.basicConfig()` which was unneeded.\n\n## [2.11.2] - 2020-04-19\n\n### Changed\n\n- Updated the documentation to give more details on the authorization process and reflect\n    2020 Spotify Application jargon and practices.\n\n- The local webserver is only started for localhost redirect_uri which specify a port,\n    i.e. it is started for `http://localhost:8080` or `http://127.0.0.1:8080`, not for `http://localhost`.\n\n### Fixed\n\n- Issue where using `http://localhost` as redirect_uri would cause the authorization process to hang.\n\n## [2.11.1] - 2020-04-11\n\n### Fixed\n\n- Fixed miscellaneous issues with parsing of callback URL\n\n## [2.11.0] - 2020-04-11\n\n### Added\n\n- Support for shows/podcasts and episodes\n- Added CONTRIBUTING.md\n\n### Changed\n\n- Client retry logic has changed as it now uses urllib3's `Retry` in conjunction with requests `Session`\n- The session is customizable as it allows for:\n    - status_forcelist\n    - retries\n    - status_retries\n    - backoff_factor\n- Spin up a local webserver to auto-fill authentication URL\n- Use session in SpotifyAuthBase\n- Logging used instead of print statements\n\n### Fixed\n\n- Close session when Spotipy object is unloaded\n- Propagate refresh token error\n\n## [2.10.0] - 2020-03-18\n\n### Added\n\n- Support for `add_to_queue`\n    - **Parameters:**\n        - track uri, id, or url\n        - device id. If None, then the active device is used.\n- Add CHANGELOG and LICENSE to released package\n\n## [2.9.0] - 2020-02-15\n\n### Added\n\n- Support `position_ms` optional parameter in `start_playback`\n- Add `requests_timeout` parameter to authentication methods\n- Make cache optional in `get_access_token`\n\n## [2.8.0] - 2020-02-12\n\n### Added\n\n- Support for `playlist_cover_image`\n- Support `after` and `before` parameter in `current_user_recently_played`\n- CI for unit tests\n- Automatic `token` refresh\n- `auth_manager` and `oauth_manager` optional parameters added to `Spotify`'s init.\n- Optional `username` parameter to be passed to `SpotifyOAuth`, to infer a `cache_path` automatically\n- Optional `as_dict` parameter to control `SpotifyOAuth`'s `get_access_token` output type. However, this is going to be deprecated in the future, and the method will always return a token string\n- Optional `show_dialog` parameter to be passed to `SpotifyOAuth`\n\n### Changed\n\n- Both `SpotifyClientCredentials` and `SpotifyOAuth` inherit from a common `SpotifyAuthBase` which handles common parameters and logics.\n\n## [2.7.1] - 2020-01-20\n\n### Changed\n\n- PyPi release mistake without pulling last merge first\n\n## [2.7.0] - 2020-01-20\n\n### Added\n\n- Support for `playlist_tracks`\n- Support for `playlist_upload_cover_image`\n\n### Changed\n\n- `user_playlist_tracks` doesn't require a user anymore (accepts `None`)\n\n### Deprecated\n\n- Deprecated `user_playlist` and `user_playlist_tracks`\n\n## [2.6.3] - 2020-01-16\n\n### Fixed\n\n- Fixed broken doc in 2.6.2\n\n## [2.6.2] - 2020-01-16\n\n### Fixed\n\n- Fixed broken examples in README, examples and doc\n\n### Changed\n\n- Allow session keepalive\n- Bump requests to 2.20.0\n\n## [2.6.1] - 2020-01-13\n\n### Fixed\n\n- Fixed inconsistent behaviour with some API methods when\n    a full HTTP URL is passed.\n- Fixed invalid calls to logging warn method\n\n### Removed\n\n- `mock` no longer needed for install. Only used in `tox`.\n\n## [2.6.0] - 2020-01-12\n\n### Added\n\n- Support for `playlist` to get a playlist without specifying a user\n- Support for `current_user_saved_albums_delete`\n- Support for `current_user_saved_albums_contains`\n- Support for `user_unfollow_artists`\n- Support for `user_unfollow_users`\n- Lint with flake8 using Github action\n\n### Changed\n\n- Fix typos in doc\n- Start following [SemVer](https://semver.org) properly\n\n## [2.5.0] - 2020-01-11\n\nAdded follow and player endpoints\n\n## [2.4.4] - 2017-01-04\n\nPython 3 fix\n\n## [2.4.3] - 2017-01-02\n\nFixed proxy issue in standard auth flow\n\n## [2.4.2] - 2017-01-02\n\nSupport getting audio features for a single track\n\n## [2.4.1] - 2017-01-02\n\nIncorporated proxy support\n\n## [2.4.0] - 2016-12-31\n\nIncorporated a number of PRs\n\n## [2.3.8] - 2016-03-31\n\nAdded recs, audio features, user top lists\n\n## [2.3.7] - 2015-08-10\n\nAdded current_user_followed_artists\n\n## [2.3.6] - 2015-06-03\n\nSupport for offset/limit with album_tracks API\n\n## [2.3.5] - 2015-04-28\n\nFixed bug in auto retry logic\n\n## [2.3.3] - 2015-04-01\n\nAadded client credential flow\n\n## [2.3.2] - 2015-03-31\n\nAdded auto retry logic\n\n## [2.3.0] - 2015-01-05\n\nAdded session support added by akx.\n\n## [2.2.0] - 2014-11-15\n\nAdded support for user_playlist_tracks\n\n## [2.1.0] - 2014-10-25\n\nAdded support for new_releases and featured_playlists\n\n## [2.0.2] - 2014-08-25\n\nMoved to spotipy at pypi\n\n## [1.2.0] - 2014-08-22\n\nUpgraded APIs and docs to make it be a real library\n\n## [1.310.0] - 2014-08-20\n\nAdded playlist replace and remove methods. Added auth tests. Improved API docs\n\n## [1.301.0] - 2014-08-19\n\nUpgraded version number to take precedence over previously botched release (sigh)\n\n## [1.50.0] - 2014-08-14\n\nRefactored util out of examples and into the main package\n\n## [1.49.0] - 2014-07-23\n\nSupport for \"Your Music\" tracks (add, delete, get), with examples\n\n## [1.45.0] - 2014-07-07\n\nSupport for related artists endpoint. Don't use cache auth codes when scope changes\n\n## [1.44.0] - 2014-07-03\n\nAdded show tracks.py example\n\n## [1.43.0] - 2014-06-27\n\nFixed JSON handling issue\n\n## [1.42.0] - 2014-06-19\n\nRemoved dependency on simplejson\n\n## [1.40.0] - 2014-06-12\n\nInitial public release.\n\n## [1.4.2] - 2014-06-21\n\nAdded support for retrieving starred playlists\n\n## [1.1.0] - 2014-06-17\n\nUpdates to match released API\n\n## [1.1.0] - 2014-05-18\n\nRepackaged for saner imports\n\n## [1.0.0] - 2017-04-05\n\nInitial release\n", "code_before": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## Unreleased\n\n// Add new changes below this line\n-   Modified docstring for playlist_add_items() to accept \"only URIs or URLs\",\n    with intended deprecation for IDs in v3\n\n### Added\n\n- Add alternative module installation instruction to README\n- Added Comment to README - Getting Started for user to add URI to app in Spotify Developer Dashboard. \n- Added playlist_add_tracks.py to example folder\n\n### Fixed\n\n- Update contributing.md\n\n### Removed\n\n## [2.22.0] - 2022-12-10\n\n### Added\n\n- Integration tests via GHA (non-user endpoints)\n- Unit tests for new releases, passing limit parameter with minimum and maximum values of 1 and 50\n- Unit tests for categories, omitting country code to test global releases\n- Added `CODE_OF_CONDUCT.md`\n\n### Fixed\n\n- Incorrect `category_id` input for test_category\n- Assertion value for `test_categories_limit_low` and `test_categories_limit_high`\n- Pin Github Actions Runner to Ubuntu 20 for Py27\n- Fixed potential error where `found` variable in `test_artist_related_artists` is undefined if for loop never evaluates to true\n- Fixed false positive test `test_new_releases` which looks up the wrong property of the JSON response object and always evaluates to true\n\n## [2.21.0] - 2022-09-26\n\n### Added\n\n- Added `market` parameter to `album` and `albums` to address ([#753](https://github.com/plamere/spotipy/issues/753)\n- Added `show_featured_artists.py` to `/examples`.\n- Expanded contribution and license sections of the documentation.\n- Added `FlaskSessionCacheHandler`, a cache handler that stores the token info in a flask session.\n- Added Python 3.10 in GitHub Actions\n\n### Fixed\n\n- Updated the documentation to specify ISO-639-1 language codes.\n- Fix `AttributeError` for `text` attribute of the `Response` object\n- Require redis v3 if python2.7 (fixes readthedocs)\n\n## [2.20.0] - 2022-06-18\n\n### Added\n\n- Added `RedisCacheHandler`, a cache handler that stores the token info in Redis.\n- Changed URI handling in `client.Spotify._get_id()` to remove qureies if provided by error.\n- Added a new parameter to `RedisCacheHandler` to allow custom keys (instead of the default `token_info` key)\n- Simplify check for existing token in `RedisCacheHandler`\n\n### Changed\n\n- Removed Python 3.5 and added Python 3.9 in Github Action\n\n## [2.19.0] - 2021-08-12\n\n### Added\n\n- Added `MemoryCacheHandler`, a cache handler that simply stores the token info in memory as an instance attribute of this class.\n- If a network request returns an error status code but the response body cannot be decoded into JSON, then fall back on decoding the body into a string.\n- Added `DjangoSessionCacheHandler`, a cache handler that stores the token in the session framework provided by Django. Web apps using spotipy with Django can directly use this for cache handling.\n\n### Fixed\n\n- Fixed a bug in `CacheFileHandler.__init__`: The documentation says that the username will be retrieved from the environment, but it wasn't.\n- Fixed a bug in the initializers for the auth managers that produced a spurious warning message if you provide a cache handler and you set a value for the \"SPOTIPY_CLIENT_USERNAME\" environment variable.\n- Use generated MIT license and fix license type in `pip show`\n\n## [2.18.0] - 2021-04-13\n\n### Added\n\n- Enabled using both short and long IDs for playlist_change_details\n- Added a cache handler to `SpotifyClientCredentials`\n- Added the following endpoints\n    - `Spotify.current_user_saved_episodes`\n    - `Spotify.current_user_saved_episodes_add`\n    - `Spotify.current_user_saved_episodes_delete`\n    - `Spotify.current_user_saved_episodes_contains`\n    - `Spotify.available_markets`\n\n### Changed\n\n- Add support for a list of scopes rather than just a comma separated string of scopes\n\n### Fixed\n\n- Fixed the bugs in `SpotifyOAuth.refresh_access_token` and `SpotifyPKCE.refresh_access_token` which raised the incorrect exception upon receiving an error response from the server. This addresses #645.\n- Fixed a bug in `RequestHandler.do_GET` in which the non-existent `state` attribute of `SpotifyOauthError` is accessed. This bug occurs when the user clicks \"cancel\" in the permissions dialog that opens in the browser.\n- Cleaned up the documentation for `SpotifyClientCredentials.__init__`, `SpotifyOAuth.__init__`, and `SpotifyPKCE.__init__`.\n\n## [2.17.1] - 2021-02-28\n\n### Fixed\n\n- `allowed_methods` requires urllib3>=1.26.0\n\n## [2.17.0] - 2021-02-28\n\n### Changed\n\n- moved os.remove(session_cache_path()) inside try block to avoid TypeError on app.py example file\n- A warning will no longer be emitted when the cache file does not exist at the specified path\n- The docs for the `auth` parameter of `Spotify.init` use the term \"access token\" instead of \"authorization token\"\n- Changed docs for `search` to mention that you can provide multiple types to search for\n- The query parameters of requests are now logged\n- Deprecate specifing `cache_path` or `username` directly to `SpotifyOAuth`, `SpotifyPKCE`, and `SpotifyImplicitGrant` constructors, instead directing users to use the `CacheFileHandler` cache handler\n- Removed requirement for examples/app.py to specify port multiple times (only SPOTIPY_REDIRECT_URI needs to contain the port)\n\n### Added\n\n- Added log messages for when the access and refresh tokens are retrieved and when they are refreshed\n- Support `market` optional parameter in `track`\n- Added CacheHandler abstraction to allow users to cache tokens in any way they see fit\n\n### Fixed\n\n- Fixed Spotify.user_playlist_reorder_tracks calling Spotify.playlist_reorder_tracks with an incorrect parameter order\n- Fixed deprecated Urllib3 `Retry(method_whitelist=...)` in favor of `Retry(allowed_methods=...)`\n\n## [2.16.1] - 2020-10-24\n\n### Fixed\n\n- playlist_tracks example code no longer prints extra characters on final loop iteration\n- SpotifyException now thrown when a request fails & has no response ([#571](https://github.com/plamere/spotipy/issues/571), [#581](https://github.com/plamere/spotipy/issues/581))\n- Added scope, `playlist-read-private`, to examples that access user playlists using the spotipy api: current_user_playlists() ([#591](https://github.com/plamere/spotipy/issues/591))\n- Enable retries for POST, DELETE, PUT ([#577](https://github.com/plamere/spotipy/issues/577))\n\n### Changed\n\n- both inline and starting import lists are sorted using `isort` module\n- changed Max Retries exception code from 599 to 429\n\n## [2.16.0] - 2020-09-16\n\n### Added\n\n- `open_browser` can be passed to the constructors of `SpotifyOAuth` and `SpotifyPKCE` to make it easier to authorize in browserless environments\n\n## [2.15.0] - 2020-09-08\n\n### Added\n\n- `SpotifyPKCE.parse_auth_response_url`, mirroring that method in\n    `SpotifyOAuth`\n\n### Changed\n\n- Specifying a cache_path or username is now optional\n\n### Fixed\n\n- Using `SpotifyPKCE.get_authorization_url` will now generate a code\n    challenge if needed\n\n## [2.14.0] - 2020-08-29\n\n### Added\n\n- (experimental) Support to search multiple/all markets at once.\n- Support to test whether the current user is following certain\n    users or artists\n- Proper replacements for all deprecated playlist endpoints\n    (See https://developer.spotify.com/community/news/2018/06/12/changes-to-playlist-uris/ and below)\n- Allow for OAuth 2.0 authorization by instructing the user to open the URL in a browser instead of opening the browser.\n- Reason for 403 error in SpotifyException\n- Support for the PKCE Auth Flow\n- Support to advertise different language to Spotify\n- Added 'collaborative' parameter to user_playlist_create method.\n- Enforce CHANGELOG update on PR\n- Adds `additional_types` parameter to retrieve currently playing podcast episode\n- Support to get info about a single category\n\n### Deprecated\n\n- `user_playlist_change_details` in favor of `playlist_change_details`\n- `user_playlist_unfollow` in favor of `current_user_unfollow_playlist`\n- `user_playlist_add_tracks` in favor of `playlist_add_items`\n- `user_playlist_replace_tracks` in favor of `playlist_replace_items`\n- `user_playlist_reorder_tracks` in favor of `playlist_reorder_items`\n- `user_playlist_remove_all_occurrences_of_tracks` in favor of\n    `playlist_remove_all_occurrences_of_items`\n- `user_playlist_remove_specific_occurrences_of_tracks` in favor of\n    `playlist_remove_specific_occurrences_of_items`\n- `user_playlist_follow_playlist` in favor of\n    `current_user_follow_playlist`\n- `user_playlist_is_following` in favor of `playlist_is_following`\n- `playlist_tracks` in favor of `playlist_items`\n\n### Fixed\n\n- fixed issue where episode URIs were being converted to track URIs in playlist calls\n\n## [2.13.0] - 2020-06-25\n\n### Added\n\n- Added `SpotifyImplicitGrant` as an auth manager option. It provides\n    user authentication without a client secret but sacrifices the ability\n    to refresh the token without user input. (However, read the class\n    docstring for security advisory.)\n- Added built-in verification of the `state` query parameter\n- Added two new attributes: error and error_description to `SpotifyOauthError` exception class to show\n    authorization/authentication web api errors details.\n- Added `SpotifyStateError` subclass of `SpotifyOauthError`\n- Allow extending `SpotifyClientCredentials` and `SpotifyOAuth`\n- Added the market paramter to `album_tracks`\n\n### Deprecated\n\n- Deprecated `util.prompt_for_user_token` in favor of `spotipy.Spotify(auth_manager=SpotifyOAuth())`\n\n## [2.12.0] - 2020-04-26\n\n### Added\n\n- Added a method to update the auth token.\n\n### Fixed\n\n- Logging regression due to the addition of `logging.basicConfig()` which was unneeded.\n\n## [2.11.2] - 2020-04-19\n\n### Changed\n\n- Updated the documentation to give more details on the authorization process and reflect\n    2020 Spotify Application jargon and practices.\n\n- The local webserver is only started for localhost redirect_uri which specify a port,\n    i.e. it is started for `http://localhost:8080` or `http://127.0.0.1:8080`, not for `http://localhost`.\n\n### Fixed\n\n- Issue where using `http://localhost` as redirect_uri would cause the authorization process to hang.\n\n## [2.11.1] - 2020-04-11\n\n### Fixed\n\n- Fixed miscellaneous issues with parsing of callback URL\n\n## [2.11.0] - 2020-04-11\n\n### Added\n\n- Support for shows/podcasts and episodes\n- Added CONTRIBUTING.md\n\n### Changed\n\n- Client retry logic has changed as it now uses urllib3's `Retry` in conjunction with requests `Session`\n- The session is customizable as it allows for:\n    - status_forcelist\n    - retries\n    - status_retries\n    - backoff_factor\n- Spin up a local webserver to auto-fill authentication URL\n- Use session in SpotifyAuthBase\n- Logging used instead of print statements\n\n### Fixed\n\n- Close session when Spotipy object is unloaded\n- Propagate refresh token error\n\n## [2.10.0] - 2020-03-18\n\n### Added\n\n- Support for `add_to_queue`\n    - **Parameters:**\n        - track uri, id, or url\n        - device id. If None, then the active device is used.\n- Add CHANGELOG and LICENSE to released package\n\n## [2.9.0] - 2020-02-15\n\n### Added\n\n- Support `position_ms` optional parameter in `start_playback`\n- Add `requests_timeout` parameter to authentication methods\n- Make cache optional in `get_access_token`\n\n## [2.8.0] - 2020-02-12\n\n### Added\n\n- Support for `playlist_cover_image`\n- Support `after` and `before` parameter in `current_user_recently_played`\n- CI for unit tests\n- Automatic `token` refresh\n- `auth_manager` and `oauth_manager` optional parameters added to `Spotify`'s init.\n- Optional `username` parameter to be passed to `SpotifyOAuth`, to infer a `cache_path` automatically\n- Optional `as_dict` parameter to control `SpotifyOAuth`'s `get_access_token` output type. However, this is going to be deprecated in the future, and the method will always return a token string\n- Optional `show_dialog` parameter to be passed to `SpotifyOAuth`\n\n### Changed\n\n- Both `SpotifyClientCredentials` and `SpotifyOAuth` inherit from a common `SpotifyAuthBase` which handles common parameters and logics.\n\n## [2.7.1] - 2020-01-20\n\n### Changed\n\n- PyPi release mistake without pulling last merge first\n\n## [2.7.0] - 2020-01-20\n\n### Added\n\n- Support for `playlist_tracks`\n- Support for `playlist_upload_cover_image`\n\n### Changed\n\n- `user_playlist_tracks` doesn't require a user anymore (accepts `None`)\n\n### Deprecated\n\n- Deprecated `user_playlist` and `user_playlist_tracks`\n\n## [2.6.3] - 2020-01-16\n\n### Fixed\n\n- Fixed broken doc in 2.6.2\n\n## [2.6.2] - 2020-01-16\n\n### Fixed\n\n- Fixed broken examples in README, examples and doc\n\n### Changed\n\n- Allow session keepalive\n- Bump requests to 2.20.0\n\n## [2.6.1] - 2020-01-13\n\n### Fixed\n\n- Fixed inconsistent behaviour with some API methods when\n    a full HTTP URL is passed.\n- Fixed invalid calls to logging warn method\n\n### Removed\n\n- `mock` no longer needed for install. Only used in `tox`.\n\n## [2.6.0] - 2020-01-12\n\n### Added\n\n- Support for `playlist` to get a playlist without specifying a user\n- Support for `current_user_saved_albums_delete`\n- Support for `current_user_saved_albums_contains`\n- Support for `user_unfollow_artists`\n- Support for `user_unfollow_users`\n- Lint with flake8 using Github action\n\n### Changed\n\n- Fix typos in doc\n- Start following [SemVer](https://semver.org) properly\n\n## [2.5.0] - 2020-01-11\n\nAdded follow and player endpoints\n\n## [2.4.4] - 2017-01-04\n\nPython 3 fix\n\n## [2.4.3] - 2017-01-02\n\nFixed proxy issue in standard auth flow\n\n## [2.4.2] - 2017-01-02\n\nSupport getting audio features for a single track\n\n## [2.4.1] - 2017-01-02\n\nIncorporated proxy support\n\n## [2.4.0] - 2016-12-31\n\nIncorporated a number of PRs\n\n## [2.3.8] - 2016-03-31\n\nAdded recs, audio features, user top lists\n\n## [2.3.7] - 2015-08-10\n\nAdded current_user_followed_artists\n\n## [2.3.6] - 2015-06-03\n\nSupport for offset/limit with album_tracks API\n\n## [2.3.5] - 2015-04-28\n\nFixed bug in auto retry logic\n\n## [2.3.3] - 2015-04-01\n\nAadded client credential flow\n\n## [2.3.2] - 2015-03-31\n\nAdded auto retry logic\n\n## [2.3.0] - 2015-01-05\n\nAdded session support added by akx.\n\n## [2.2.0] - 2014-11-15\n\nAdded support for user_playlist_tracks\n\n## [2.1.0] - 2014-10-25\n\nAdded support for new_releases and featured_playlists\n\n## [2.0.2] - 2014-08-25\n\nMoved to spotipy at pypi\n\n## [1.2.0] - 2014-08-22\n\nUpgraded APIs and docs to make it be a real library\n\n## [1.310.0] - 2014-08-20\n\nAdded playlist replace and remove methods. Added auth tests. Improved API docs\n\n## [1.301.0] - 2014-08-19\n\nUpgraded version number to take precedence over previously botched release (sigh)\n\n## [1.50.0] - 2014-08-14\n\nRefactored util out of examples and into the main package\n\n## [1.49.0] - 2014-07-23\n\nSupport for \"Your Music\" tracks (add, delete, get), with examples\n\n## [1.45.0] - 2014-07-07\n\nSupport for related artists endpoint. Don't use cache auth codes when scope changes\n\n## [1.44.0] - 2014-07-03\n\nAdded show tracks.py example\n\n## [1.43.0] - 2014-06-27\n\nFixed JSON handling issue\n\n## [1.42.0] - 2014-06-19\n\nRemoved dependency on simplejson\n\n## [1.40.0] - 2014-06-12\n\nInitial public release.\n\n## [1.4.2] - 2014-06-21\n\nAdded support for retrieving starred playlists\n\n## [1.1.0] - 2014-06-17\n\nUpdates to match released API\n\n## [1.1.0] - 2014-05-18\n\nRepackaged for saner imports\n\n## [1.0.0] - 2017-04-05\n\nInitial release\n", "patch": "@@ -8,17 +8,21 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n ## Unreleased\n \n // Add new changes below this line\n--   Modified docstring for playlist_add_items() to accept \"only URIs or URLs\",\n-    with intended deprecation for IDs in v3\n \n ### Added\n \n - Add alternative module installation instruction to README\n - Added Comment to README - Getting Started for user to add URI to app in Spotify Developer Dashboard. \n - Added playlist_add_tracks.py to example folder\n \n+### Changed\n+\n+- Modified docstring for playlist_add_items() to accept \"only URIs or URLs\",\n+  with intended deprecation for IDs in v3\n+\n ### Fixed\n \n+- Path traversal vulnerability that may lead to type confusion in URI handling code\n - Update contributing.md\n \n ### Removed", "file_path": "files/2023_1/631", "file_language": "md", "file_name": "CHANGELOG.md", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0}, {"raw_url": "https://github.com/spotipy-dev/spotipy/raw/b1db0b63d90eae40af32d7ee4c760c2fd581a1b4/spotipy%2Fclient.py", "code": "# -*- coding: utf-8 -*-\n\n\"\"\" A simple and thin Python library for the Spotify Web API \"\"\"\n\n__all__ = [\"Spotify\", \"SpotifyException\"]\n\nimport json\nimport logging\nimport re\nimport warnings\n\nimport requests\nimport six\nimport urllib3\n\nfrom spotipy.exceptions import SpotifyException\n\nlogger = logging.getLogger(__name__)\n\n\nclass Spotify(object):\n    \"\"\"\n        Example usage::\n\n            import spotipy\n\n            urn = 'spotify:artist:3jOstUTkEu2JkjvRdBA5Gu'\n            sp = spotipy.Spotify()\n\n            artist = sp.artist(urn)\n            print(artist)\n\n            user = sp.user('plamere')\n            print(user)\n    \"\"\"\n    max_retries = 3\n    default_retry_codes = (429, 500, 502, 503, 504)\n    country_codes = [\n        \"AD\",\n        \"AR\",\n        \"AU\",\n        \"AT\",\n        \"BE\",\n        \"BO\",\n        \"BR\",\n        \"BG\",\n        \"CA\",\n        \"CL\",\n        \"CO\",\n        \"CR\",\n        \"CY\",\n        \"CZ\",\n        \"DK\",\n        \"DO\",\n        \"EC\",\n        \"SV\",\n        \"EE\",\n        \"FI\",\n        \"FR\",\n        \"DE\",\n        \"GR\",\n        \"GT\",\n        \"HN\",\n        \"HK\",\n        \"HU\",\n        \"IS\",\n        \"ID\",\n        \"IE\",\n        \"IT\",\n        \"JP\",\n        \"LV\",\n        \"LI\",\n        \"LT\",\n        \"LU\",\n        \"MY\",\n        \"MT\",\n        \"MX\",\n        \"MC\",\n        \"NL\",\n        \"NZ\",\n        \"NI\",\n        \"NO\",\n        \"PA\",\n        \"PY\",\n        \"PE\",\n        \"PH\",\n        \"PL\",\n        \"PT\",\n        \"SG\",\n        \"ES\",\n        \"SK\",\n        \"SE\",\n        \"CH\",\n        \"TW\",\n        \"TR\",\n        \"GB\",\n        \"US\",\n        \"UY\"]\n\n    # Spotify URI scheme defined in [1], and the ID format as base-62 in [2].\n    #\n    # Unfortunately the IANA specification is out of date and doesn't include the new types\n    # show and episode. Additionally, for the user URI, it does not specify which characters\n    # are valid for usernames, so the assumption is alphanumeric which coincidentially are also\n    # the same ones base-62 uses.\n    # In limited manual exploration this seems to hold true, as newly accounts are assigned an\n    # identifier that looks like the base-62 of all other IDs, but some older accounts only have\n    # numbers and even older ones seemed to have been allowed to freely pick this name.\n    #\n    # [1] https://www.iana.org/assignments/uri-schemes/prov/spotify\n    # [2] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n    _regex_spotify_uri = r'^spotify:(?P<type>track|artist|album|playlist|show|episode|user):(?P<id>[0-9A-Za-z]+)$'\n\n    # Spotify URLs are defined at [1]. The assumption is made that they are all\n    # pointing to open.spotify.com, so a regex is used to parse them as well,\n    # instead of a more complex URL parsing function.\n    #\n    # [1] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n    _regex_spotify_url = r'^(http[s]?:\\/\\/)?open.spotify.com\\/(?P<type>track|artist|album|playlist|show|episode|user)\\/(?P<id>[0-9A-Za-z]+)(\\?.*)?$'\n\n    _regex_base62 = r'^[0-9A-Za-z]+$'\n\n    def __init__(\n        self,\n        auth=None,\n        requests_session=True,\n        client_credentials_manager=None,\n        oauth_manager=None,\n        auth_manager=None,\n        proxies=None,\n        requests_timeout=5,\n        status_forcelist=None,\n        retries=max_retries,\n        status_retries=max_retries,\n        backoff_factor=0.3,\n        language=None,\n    ):\n        \"\"\"\n        Creates a Spotify API client.\n\n        :param auth: An access token (optional)\n        :param requests_session:\n            A Requests session object or a truthy value to create one.\n            A falsy value disables sessions.\n            It should generally be a good idea to keep sessions enabled\n            for performance reasons (connection pooling).\n        :param client_credentials_manager:\n            SpotifyClientCredentials object\n        :param oauth_manager:\n            SpotifyOAuth object\n        :param auth_manager:\n            SpotifyOauth, SpotifyClientCredentials,\n            or SpotifyImplicitGrant object\n        :param proxies:\n            Definition of proxies (optional).\n            See Requests doc https://2.python-requests.org/en/master/user/advanced/#proxies\n        :param requests_timeout:\n            Tell Requests to stop waiting for a response after a given\n            number of seconds\n        :param status_forcelist:\n            Tell requests what type of status codes retries should occur on\n        :param retries:\n            Total number of retries to allow\n        :param status_retries:\n            Number of times to retry on bad status codes\n        :param backoff_factor:\n            A backoff factor to apply between attempts after the second try\n            See urllib3 https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n        :param language:\n            The language parameter advertises what language the user prefers to see.\n            See ISO-639-1 language code: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n        \"\"\"\n        self.prefix = \"https://api.spotify.com/v1/\"\n        self._auth = auth\n        self.client_credentials_manager = client_credentials_manager\n        self.oauth_manager = oauth_manager\n        self.auth_manager = auth_manager\n        self.proxies = proxies\n        self.requests_timeout = requests_timeout\n        self.status_forcelist = status_forcelist or self.default_retry_codes\n        self.backoff_factor = backoff_factor\n        self.retries = retries\n        self.status_retries = status_retries\n        self.language = language\n\n        if isinstance(requests_session, requests.Session):\n            self._session = requests_session\n        else:\n            if requests_session:  # Build a new session.\n                self._build_session()\n            else:  # Use the Requests API module as a \"session\".\n                self._session = requests.api\n\n    def set_auth(self, auth):\n        self._auth = auth\n\n    @property\n    def auth_manager(self):\n        return self._auth_manager\n\n    @auth_manager.setter\n    def auth_manager(self, auth_manager):\n        if auth_manager is not None:\n            self._auth_manager = auth_manager\n        else:\n            self._auth_manager = (\n                self.client_credentials_manager or self.oauth_manager\n            )\n\n    def __del__(self):\n        \"\"\"Make sure the connection (pool) gets closed\"\"\"\n        if isinstance(self._session, requests.Session):\n            self._session.close()\n\n    def _build_session(self):\n        self._session = requests.Session()\n        retry = urllib3.Retry(\n            total=self.retries,\n            connect=None,\n            read=False,\n            allowed_methods=frozenset(['GET', 'POST', 'PUT', 'DELETE']),\n            status=self.status_retries,\n            backoff_factor=self.backoff_factor,\n            status_forcelist=self.status_forcelist)\n\n        adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n        self._session.mount('http://', adapter)\n        self._session.mount('https://', adapter)\n\n    def _auth_headers(self):\n        if self._auth:\n            return {\"Authorization\": \"Bearer {0}\".format(self._auth)}\n        if not self.auth_manager:\n            return {}\n        try:\n            token = self.auth_manager.get_access_token(as_dict=False)\n        except TypeError:\n            token = self.auth_manager.get_access_token()\n        return {\"Authorization\": \"Bearer {0}\".format(token)}\n\n    def _internal_call(self, method, url, payload, params):\n        args = dict(params=params)\n        if not url.startswith(\"http\"):\n            url = self.prefix + url\n        headers = self._auth_headers()\n\n        if \"content_type\" in args[\"params\"]:\n            headers[\"Content-Type\"] = args[\"params\"][\"content_type\"]\n            del args[\"params\"][\"content_type\"]\n            if payload:\n                args[\"data\"] = payload\n        else:\n            headers[\"Content-Type\"] = \"application/json\"\n            if payload:\n                args[\"data\"] = json.dumps(payload)\n\n        if self.language is not None:\n            headers[\"Accept-Language\"] = self.language\n\n        logger.debug('Sending %s to %s with Params: %s Headers: %s and Body: %r ',\n                     method, url, args.get(\"params\"), headers, args.get('data'))\n\n        try:\n            response = self._session.request(\n                method, url, headers=headers, proxies=self.proxies,\n                timeout=self.requests_timeout, **args\n            )\n\n            response.raise_for_status()\n            results = response.json()\n        except requests.exceptions.HTTPError as http_error:\n            response = http_error.response\n            try:\n                json_response = response.json()\n                error = json_response.get(\"error\", {})\n                msg = error.get(\"message\")\n                reason = error.get(\"reason\")\n            except ValueError:\n                # if the response cannot be decoded into JSON (which raises a ValueError),\n                # then try to decode it into text\n\n                # if we receive an empty string (which is falsy), then replace it with `None`\n                msg = response.text or None\n                reason = None\n\n            logger.error(\n                'HTTP Error for %s to %s with Params: %s returned %s due to %s',\n                method, url, args.get(\"params\"), response.status_code, msg\n            )\n\n            raise SpotifyException(\n                response.status_code,\n                -1,\n                \"%s:\\n %s\" % (response.url, msg),\n                reason=reason,\n                headers=response.headers,\n            )\n        except requests.exceptions.RetryError as retry_error:\n            request = retry_error.request\n            logger.error('Max Retries reached')\n            try:\n                reason = retry_error.args[0].reason\n            except (IndexError, AttributeError):\n                reason = None\n            raise SpotifyException(\n                429,\n                -1,\n                \"%s:\\n %s\" % (request.path_url, \"Max Retries\"),\n                reason=reason\n            )\n        except ValueError:\n            results = None\n\n        logger.debug('RESULTS: %s', results)\n        return results\n\n    def _get(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n\n        return self._internal_call(\"GET\", url, payload, kwargs)\n\n    def _post(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"POST\", url, payload, kwargs)\n\n    def _delete(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"DELETE\", url, payload, kwargs)\n\n    def _put(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"PUT\", url, payload, kwargs)\n\n    def next(self, result):\n        \"\"\" returns the next result given a paged result\n\n            Parameters:\n                - result - a previously returned paged result\n        \"\"\"\n        if result[\"next\"]:\n            return self._get(result[\"next\"])\n        else:\n            return None\n\n    def previous(self, result):\n        \"\"\" returns the previous result given a paged result\n\n            Parameters:\n                - result - a previously returned paged result\n        \"\"\"\n        if result[\"previous\"]:\n            return self._get(result[\"previous\"])\n        else:\n            return None\n\n    def track(self, track_id, market=None):\n        \"\"\" returns a single track given the track's ID, URI or URL\n\n            Parameters:\n                - track_id - a spotify URI, URL or ID\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n\n        trid = self._get_id(\"track\", track_id)\n        return self._get(\"tracks/\" + trid, market=market)\n\n    def tracks(self, tracks, market=None):\n        \"\"\" returns a list of tracks given a list of track IDs, URIs, or URLs\n\n            Parameters:\n                - tracks - a list of spotify URIs, URLs or IDs. Maximum: 50 IDs.\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n\n        tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._get(\"tracks/?ids=\" + \",\".join(tlist), market=market)\n\n    def artist(self, artist_id):\n        \"\"\" returns a single artist given the artist's ID, URI or URL\n\n            Parameters:\n                - artist_id - an artist ID, URI or URL\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid)\n\n    def artists(self, artists):\n        \"\"\" returns a list of artists given the artist IDs, URIs, or URLs\n\n            Parameters:\n                - artists - a list of  artist IDs, URIs or URLs\n        \"\"\"\n\n        tlist = [self._get_id(\"artist\", a) for a in artists]\n        return self._get(\"artists/?ids=\" + \",\".join(tlist))\n\n    def artist_albums(\n        self, artist_id, album_type=None, country=None, limit=20, offset=0\n    ):\n        \"\"\" Get Spotify catalog information about an artist's albums\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n                - album_type - 'album', 'single', 'appears_on', 'compilation'\n                - country - limit the response to one particular country.\n                - limit  - the number of albums to return\n                - offset - the index of the first album to return\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\n            \"artists/\" + trid + \"/albums\",\n            album_type=album_type,\n            country=country,\n            limit=limit,\n            offset=offset,\n        )\n\n    def artist_top_tracks(self, artist_id, country=\"US\"):\n        \"\"\" Get Spotify catalog information about an artist's top 10 tracks\n            by country.\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n                - country - limit the response to one particular country.\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid + \"/top-tracks\", country=country)\n\n    def artist_related_artists(self, artist_id):\n        \"\"\" Get Spotify catalog information about artists similar to an\n            identified artist. Similarity is based on analysis of the\n            Spotify community's listening history.\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n        \"\"\"\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid + \"/related-artists\")\n\n    def album(self, album_id, market=None):\n        \"\"\" returns a single album given the album's ID, URIs or URL\n\n            Parameters:\n                - album_id - the album ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code\n        \"\"\"\n\n        trid = self._get_id(\"album\", album_id)\n        if market is not None:\n            return self._get(\"albums/\" + trid + '?market=' + market)\n        else:\n            return self._get(\"albums/\" + trid)\n\n    def album_tracks(self, album_id, limit=50, offset=0, market=None):\n        \"\"\" Get Spotify catalog information about an album's tracks\n\n            Parameters:\n                - album_id - the album ID, URI or URL\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n                - market - an ISO 3166-1 alpha-2 country code.\n\n        \"\"\"\n\n        trid = self._get_id(\"album\", album_id)\n        return self._get(\n            \"albums/\" + trid + \"/tracks/\", limit=limit, offset=offset, market=market\n        )\n\n    def albums(self, albums, market=None):\n        \"\"\" returns a list of albums given the album IDs, URIs, or URLs\n\n            Parameters:\n                - albums - a list of  album IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code\n        \"\"\"\n\n        tlist = [self._get_id(\"album\", a) for a in albums]\n        if market is not None:\n            return self._get(\"albums/?ids=\" + \",\".join(tlist) + '&market=' + market)\n        else:\n            return self._get(\"albums/?ids=\" + \",\".join(tlist))\n\n    def show(self, show_id, market=None):\n        \"\"\" returns a single show given the show's ID, URIs or URL\n\n            Parameters:\n                - show_id - the show ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code.\n                           The show must be available in the given market.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"show\", show_id)\n        return self._get(\"shows/\" + trid, market=market)\n\n    def shows(self, shows, market=None):\n        \"\"\" returns a list of shows given the show IDs, URIs, or URLs\n\n            Parameters:\n                - shows - a list of show IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only shows available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        tlist = [self._get_id(\"show\", s) for s in shows]\n        return self._get(\"shows/?ids=\" + \",\".join(tlist), market=market)\n\n    def show_episodes(self, show_id, limit=50, offset=0, market=None):\n        \"\"\" Get Spotify catalog information about a show's episodes\n\n            Parameters:\n                - show_id - the show ID, URI or URL\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only episodes available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"show\", show_id)\n        return self._get(\n            \"shows/\" + trid + \"/episodes/\", limit=limit, offset=offset, market=market\n        )\n\n    def episode(self, episode_id, market=None):\n        \"\"\" returns a single episode given the episode's ID, URIs or URL\n\n            Parameters:\n                - episode_id - the episode ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code.\n                           The episode must be available in the given market.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"episode\", episode_id)\n        return self._get(\"episodes/\" + trid, market=market)\n\n    def episodes(self, episodes, market=None):\n        \"\"\" returns a list of episodes given the episode IDs, URIs, or URLs\n\n            Parameters:\n                - episodes - a list of episode IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only episodes available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        tlist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._get(\"episodes/?ids=\" + \",\".join(tlist), market=market)\n\n    def search(self, q, limit=10, offset=0, type=\"track\", market=None):\n        \"\"\" searches for an item\n\n            Parameters:\n                - q - the search query (see how to write a query in the\n                      official documentation https://developer.spotify.com/documentation/web-api/reference/search/)  # noqa\n                - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied\n                          within each type, not on the total response.\n                - offset - the index of the first item to return\n                - type - the types of items to return. One or more of 'artist', 'album',\n                         'track', 'playlist', 'show', and 'episode'.  If multiple types are desired,\n                         pass in a comma separated string; e.g., 'track,album,episode'.\n                - market - An ISO 3166-1 alpha-2 country code or the string\n                           from_token.\n        \"\"\"\n        return self._get(\n            \"search\", q=q, limit=limit, offset=offset, type=type, market=market\n        )\n\n    def search_markets(self, q, limit=10, offset=0, type=\"track\", markets=None, total=None):\n        \"\"\" (experimental) Searches multiple markets for an item\n\n            Parameters:\n                - q - the search query (see how to write a query in the\n                      official documentation https://developer.spotify.com/documentation/web-api/reference/search/)  # noqa\n                - limit  - the number of items to return (min = 1, default = 10, max = 50). If a search is to be done on multiple\n                            markets, then this limit is applied to each market. (e.g. search US, CA, MX each with a limit of 10).\n                - offset - the index of the first item to return\n                - type - the types of items to return. One or more of 'artist', 'album',\n                         'track', 'playlist', 'show', or 'episode'. If multiple types are desired, pass in a comma separated string.\n                - markets - A list of ISO 3166-1 alpha-2 country codes. Search all country markets by default.\n                - total - the total number of results to return if multiple markets are supplied in the search.\n                          If multiple types are specified, this only applies to the first type.\n        \"\"\"\n        warnings.warn(\n            \"Searching multiple markets is an experimental feature. \"\n            \"Please be aware that this method's inputs and outputs can change in the future.\",\n            UserWarning,\n        )\n        if not markets:\n            markets = self.country_codes\n\n        if not (isinstance(markets, list) or isinstance(markets, tuple)):\n            markets = []\n\n        warnings.warn(\n            \"Searching multiple markets is poorly performing.\",\n            UserWarning,\n        )\n        return self._search_multiple_markets(q, limit, offset, type, markets, total)\n\n    def user(self, user):\n        \"\"\" Gets basic profile information about a Spotify User\n\n            Parameters:\n                - user - the id of the usr\n        \"\"\"\n        return self._get(\"users/\" + user)\n\n    def current_user_playlists(self, limit=50, offset=0):\n        \"\"\" Get current user playlists without required getting his profile\n            Parameters:\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n        \"\"\"\n        return self._get(\"me/playlists\", limit=limit, offset=offset)\n\n    def playlist(self, playlist_id, fields=None, market=None, additional_types=(\"track\",)):\n        \"\"\" Gets playlist by id.\n\n            Parameters:\n                - playlist - the id of the playlist\n                - fields - which fields to return\n                - market - An ISO 3166-1 alpha-2 country code or the\n                           string from_token.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\n            \"playlists/%s\" % (plid),\n            fields=fields,\n            market=market,\n            additional_types=\",\".join(additional_types),\n        )\n\n    def playlist_tracks(\n        self,\n        playlist_id,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n        additional_types=(\"track\",)\n    ):\n        \"\"\" Get full details of the tracks of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_items(playlist_id, ...,\"\n            \"additional_types=('track',))` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_items(playlist_id, fields, limit, offset,\n                                   market, additional_types)\n\n    def playlist_items(\n        self,\n        playlist_id,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n        additional_types=(\"track\", \"episode\")\n    ):\n        \"\"\" Get full details of the tracks and episodes of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\n            \"playlists/%s/tracks\" % (plid),\n            limit=limit,\n            offset=offset,\n            fields=fields,\n            market=market,\n            additional_types=\",\".join(additional_types)\n        )\n\n    def playlist_cover_image(self, playlist_id):\n        \"\"\" Get cover image of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\"playlists/%s/images\" % (plid))\n\n    def playlist_upload_cover_image(self, playlist_id, image_b64):\n        \"\"\" Replace the image used to represent a specific playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - image_b64 - image data as a Base64 encoded JPEG image string\n                    (maximum payload size is 256 KB)\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._put(\n            \"playlists/{}/images\".format(plid),\n            payload=image_b64,\n            content_type=\"image/jpeg\",\n        )\n\n    def user_playlist(self, user, playlist_id=None, fields=None, market=None):\n        warnings.warn(\n            \"You should use `playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n\n        \"\"\" Gets a single playlist of a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - fields - which fields to return\n        \"\"\"\n        if playlist_id is None:\n            return self._get(\"users/%s/starred\" % user)\n        return self.playlist(playlist_id, fields=fields, market=market)\n\n    def user_playlist_tracks(\n        self,\n        user=None,\n        playlist_id=None,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n    ):\n        warnings.warn(\n            \"You should use `playlist_tracks(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n\n        \"\"\" Get full details of the tracks of a playlist owned by a user.\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n        return self.playlist_tracks(\n            playlist_id,\n            limit=limit,\n            offset=offset,\n            fields=fields,\n            market=market,\n        )\n\n    def user_playlists(self, user, limit=50, offset=0):\n        \"\"\" Gets playlists of a user\n\n            Parameters:\n                - user - the id of the usr\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n        \"\"\"\n        return self._get(\n            \"users/%s/playlists\" % user, limit=limit, offset=offset\n        )\n\n    def user_playlist_create(self, user, name, public=True, collaborative=False, description=\"\"):\n        \"\"\" Creates a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - name - the name of the playlist\n                - public - is the created playlist public\n                - collaborative - is the created playlist collaborative\n                - description - the description of the playlist\n        \"\"\"\n        data = {\n            \"name\": name,\n            \"public\": public,\n            \"collaborative\": collaborative,\n            \"description\": description\n        }\n\n        return self._post(\"users/%s/playlists\" % (user,), payload=data)\n\n    def user_playlist_change_details(\n        self,\n        user,\n        playlist_id,\n        name=None,\n        public=None,\n        collaborative=None,\n        description=None,\n    ):\n        warnings.warn(\n            \"You should use `playlist_change_details(playlist_id, ...)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Changes a playlist's name and/or public/private state\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - name - optional name of the playlist\n                - public - optional is the playlist public\n                - collaborative - optional is the playlist collaborative\n                - description - optional description of the playlist\n        \"\"\"\n\n        return self.playlist_change_details(playlist_id, name, public,\n                                            collaborative, description)\n\n    def user_playlist_unfollow(self, user, playlist_id):\n        \"\"\" Unfollows (deletes) a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - name - the name of the playlist\n        \"\"\"\n        warnings.warn(\n            \"You should use `current_user_unfollow_playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n        return self.current_user_unfollow_playlist(playlist_id)\n\n    def user_playlist_add_tracks(\n        self, user, playlist_id, tracks, position=None\n    ):\n        warnings.warn(\n            \"You should use `playlist_add_items(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Adds tracks to a playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - a list of track URIs, URLs or IDs\n                - position - the position to add the tracks\n        \"\"\"\n        tracks = [self._get_uri(\"track\", tid) for tid in tracks]\n        return self.playlist_add_items(playlist_id, tracks, position)\n\n    def user_playlist_add_episodes(\n        self, user, playlist_id, episodes, position=None\n    ):\n        warnings.warn(\n            \"You should use `playlist_add_items(playlist_id, episodes)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Adds episodes to a playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - episodes - a list of track URIs, URLs or IDs\n                - position - the position to add the episodes\n        \"\"\"\n        episodes = [self._get_uri(\"episode\", tid) for tid in episodes]\n        return self.playlist_add_items(playlist_id, episodes, position)\n\n    def user_playlist_replace_tracks(self, user, playlist_id, tracks):\n        \"\"\" Replace all tracks in a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - the list of track ids to add to the playlist\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_replace_items(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_replace_items(playlist_id, tracks)\n\n    def user_playlist_reorder_tracks(\n        self,\n        user,\n        playlist_id,\n        range_start,\n        insert_before,\n        range_length=1,\n        snapshot_id=None,\n    ):\n        \"\"\" Reorder tracks in a playlist from a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - range_start - the position of the first track to be reordered\n                - range_length - optional the number of tracks to be reordered\n                                 (default: 1)\n                - insert_before - the position where the tracks should be\n                                  inserted\n                - snapshot_id - optional playlist's snapshot ID\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_reorder_items(playlist_id, ...)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_reorder_items(playlist_id, range_start,\n                                           insert_before, range_length,\n                                           snapshot_id)\n\n    def user_playlist_remove_all_occurrences_of_tracks(\n        self, user, playlist_id, tracks, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - the list of track ids to remove from the playlist\n                - snapshot_id - optional id of the playlist snapshot\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_remove_all_occurrences_of_items\"\n            \"(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_remove_all_occurrences_of_items(playlist_id,\n                                                             tracks,\n                                                             snapshot_id)\n\n    def user_playlist_remove_specific_occurrences_of_tracks(\n        self, user, playlist_id, tracks, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - an array of objects containing Spotify URIs of the\n                    tracks to remove with their current positions in the\n                    playlist.  For example:\n                        [  { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] },\n                        { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ]\n                - snapshot_id - optional id of the playlist snapshot\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_remove_specific_occurrences_of_items\"\n            \"(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = []\n        for tr in tracks:\n            ftracks.append(\n                {\n                    \"uri\": self._get_uri(\"track\", tr[\"uri\"]),\n                    \"positions\": tr[\"positions\"],\n                }\n            )\n        payload = {\"tracks\": ftracks}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"users/%s/playlists/%s/tracks\" % (user, plid), payload=payload\n        )\n\n    def user_playlist_follow_playlist(self, playlist_owner_id, playlist_id):\n        \"\"\"\n        Add the current authenticated user as a follower of a playlist.\n\n        Parameters:\n            - playlist_owner_id - the user id of the playlist owner\n            - playlist_id - the id of the playlist\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `current_user_follow_playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n        return self.current_user_follow_playlist(playlist_id)\n\n    def user_playlist_is_following(\n        self, playlist_owner_id, playlist_id, user_ids\n    ):\n        \"\"\"\n        Check to see if the given users are following the given playlist\n\n        Parameters:\n            - playlist_owner_id - the user id of the playlist owner\n            - playlist_id - the id of the playlist\n            - user_ids - the ids of the users that you want to check to see\n                if they follow the playlist. Maximum: 5 ids.\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_is_following(playlist_id, user_ids)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_is_following(playlist_id, user_ids)\n\n    def playlist_change_details(\n        self,\n        playlist_id,\n        name=None,\n        public=None,\n        collaborative=None,\n        description=None,\n    ):\n        \"\"\" Changes a playlist's name and/or public/private state,\n            collaborative state, and/or description\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - name - optional name of the playlist\n                - public - optional is the playlist public\n                - collaborative - optional is the playlist collaborative\n                - description - optional description of the playlist\n        \"\"\"\n\n        data = {}\n        if isinstance(name, six.string_types):\n            data[\"name\"] = name\n        if isinstance(public, bool):\n            data[\"public\"] = public\n        if isinstance(collaborative, bool):\n            data[\"collaborative\"] = collaborative\n        if isinstance(description, six.string_types):\n            data[\"description\"] = description\n        return self._put(\n            \"playlists/%s\" % (self._get_id(\"playlist\", playlist_id)), payload=data\n        )\n\n    def current_user_unfollow_playlist(self, playlist_id):\n        \"\"\" Unfollows (deletes) a playlist for the current authenticated\n            user\n\n            Parameters:\n                - name - the name of the playlist\n        \"\"\"\n        return self._delete(\n            \"playlists/%s/followers\" % (playlist_id)\n        )\n\n    def playlist_add_items(\n        self, playlist_id, items, position=None\n    ):\n        \"\"\" Adds tracks/episodes to a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - a list of track/episode URIs or URLs\n                - position - the position to add the tracks\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        return self._post(\n            \"playlists/%s/tracks\" % (plid),\n            payload=ftracks,\n            position=position,\n        )\n\n    def playlist_replace_items(self, playlist_id, items):\n        \"\"\" Replace all tracks/episodes in a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - list of track/episode ids to comprise playlist\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        payload = {\"uris\": ftracks}\n        return self._put(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_reorder_items(\n        self,\n        playlist_id,\n        range_start,\n        insert_before,\n        range_length=1,\n        snapshot_id=None,\n    ):\n        \"\"\" Reorder tracks in a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - range_start - the position of the first track to be reordered\n                - range_length - optional the number of tracks to be reordered\n                                 (default: 1)\n                - insert_before - the position where the tracks should be\n                                  inserted\n                - snapshot_id - optional playlist's snapshot ID\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        payload = {\n            \"range_start\": range_start,\n            \"range_length\": range_length,\n            \"insert_before\": insert_before,\n        }\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._put(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_remove_all_occurrences_of_items(\n        self, playlist_id, items, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks/episodes from the given playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - list of track/episode ids to remove from the playlist\n                - snapshot_id - optional id of the playlist snapshot\n\n        \"\"\"\n\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        payload = {\"tracks\": [{\"uri\": track} for track in ftracks]}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_remove_specific_occurrences_of_items(\n        self, playlist_id, items, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - an array of objects containing Spotify URIs of the\n                    tracks/episodes to remove with their current positions in\n                    the playlist.  For example:\n                        [  { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] },\n                        { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ]\n                - snapshot_id - optional id of the playlist snapshot\n        \"\"\"\n\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = []\n        for tr in items:\n            ftracks.append(\n                {\n                    \"uri\": self._get_uri(\"track\", tr[\"uri\"]),\n                    \"positions\": tr[\"positions\"],\n                }\n            )\n        payload = {\"tracks\": ftracks}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def current_user_follow_playlist(self, playlist_id):\n        \"\"\"\n        Add the current authenticated user as a follower of a playlist.\n\n        Parameters:\n            - playlist_id - the id of the playlist\n\n        \"\"\"\n        return self._put(\n            \"playlists/{}/followers\".format(playlist_id)\n        )\n\n    def playlist_is_following(\n        self, playlist_id, user_ids\n    ):\n        \"\"\"\n        Check to see if the given users are following the given playlist\n\n        Parameters:\n            - playlist_id - the id of the playlist\n            - user_ids - the ids of the users that you want to check to see\n                if they follow the playlist. Maximum: 5 ids.\n\n        \"\"\"\n        endpoint = \"playlists/{}/followers/contains?ids={}\"\n        return self._get(\n            endpoint.format(playlist_id, \",\".join(user_ids))\n        )\n\n    def me(self):\n        \"\"\" Get detailed profile information about the current user.\n            An alias for the 'current_user' method.\n        \"\"\"\n        return self._get(\"me/\")\n\n    def current_user(self):\n        \"\"\" Get detailed profile information about the current user.\n            An alias for the 'me' method.\n        \"\"\"\n        return self.me()\n\n    def current_user_playing_track(self):\n        \"\"\" Get information about the current users currently playing track.\n        \"\"\"\n        return self._get(\"me/player/currently-playing\")\n\n    def current_user_saved_albums(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the albums saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of albums to return (MAX_LIMIT=50)\n                - offset - the index of the first album to return\n                - market - an ISO 3166-1 alpha-2 country code.\n\n        \"\"\"\n        return self._get(\"me/albums\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_albums_add(self, albums=[]):\n        \"\"\" Add one or more albums to the current user's\n            \"Your Music\" library.\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._put(\"me/albums?ids=\" + \",\".join(alist))\n\n    def current_user_saved_albums_delete(self, albums=[]):\n        \"\"\" Remove one or more albums from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._delete(\"me/albums/?ids=\" + \",\".join(alist))\n\n    def current_user_saved_albums_contains(self, albums=[]):\n        \"\"\" Check if one or more albums is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._get(\"me/albums/contains?ids=\" + \",\".join(alist))\n\n    def current_user_saved_tracks(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the tracks saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/tracks\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_tracks_add(self, tracks=None):\n        \"\"\" Add one or more tracks to the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._put(\"me/tracks/?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_tracks_delete(self, tracks=None):\n        \"\"\" Remove one or more tracks from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._delete(\"me/tracks/?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_tracks_contains(self, tracks=None):\n        \"\"\" Check if one or more tracks is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._get(\"me/tracks/contains?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_episodes(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the episodes saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of episodes to return\n                - offset - the index of the first episode to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/episodes\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_episodes_add(self, episodes=None):\n        \"\"\" Add one or more episodes to the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._put(\"me/episodes/?ids=\" + \",\".join(elist))\n\n    def current_user_saved_episodes_delete(self, episodes=None):\n        \"\"\" Remove one or more episodes from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._delete(\"me/episodes/?ids=\" + \",\".join(elist))\n\n    def current_user_saved_episodes_contains(self, episodes=None):\n        \"\"\" Check if one or more episodes is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._get(\"me/episodes/contains?ids=\" + \",\".join(elist))\n\n    def current_user_saved_shows(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the shows saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of shows to return\n                - offset - the index of the first show to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/shows\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_shows_add(self, shows=[]):\n        \"\"\" Add one or more albums to the current user's\n            \"Your Music\" library.\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._put(\"me/shows?ids=\" + \",\".join(slist))\n\n    def current_user_saved_shows_delete(self, shows=[]):\n        \"\"\" Remove one or more shows from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._delete(\"me/shows/?ids=\" + \",\".join(slist))\n\n    def current_user_saved_shows_contains(self, shows=[]):\n        \"\"\" Check if one or more shows is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._get(\"me/shows/contains?ids=\" + \",\".join(slist))\n\n    def current_user_followed_artists(self, limit=20, after=None):\n        \"\"\" Gets a list of the artists followed by the current authorized user\n\n            Parameters:\n                - limit - the number of artists to return\n                - after - the last artist ID retrieved from the previous\n                          request\n\n        \"\"\"\n        return self._get(\n            \"me/following\", type=\"artist\", limit=limit, after=after\n        )\n\n    def current_user_following_artists(self, ids=None):\n        \"\"\" Check if the current user is following certain artists\n\n            Returns list of booleans respective to ids\n\n            Parameters:\n                - ids - a list of artist URIs, URLs or IDs\n        \"\"\"\n        idlist = []\n        if ids is not None:\n            idlist = [self._get_id(\"artist\", i) for i in ids]\n        return self._get(\n            \"me/following/contains\", ids=\",\".join(idlist), type=\"artist\"\n        )\n\n    def current_user_following_users(self, ids=None):\n        \"\"\" Check if the current user is following certain users\n\n            Returns list of booleans respective to ids\n\n            Parameters:\n                - ids - a list of user URIs, URLs or IDs\n        \"\"\"\n        idlist = []\n        if ids is not None:\n            idlist = [self._get_id(\"user\", i) for i in ids]\n        return self._get(\n            \"me/following/contains\", ids=\",\".join(idlist), type=\"user\"\n        )\n\n    def current_user_top_artists(\n        self, limit=20, offset=0, time_range=\"medium_term\"\n    ):\n        \"\"\" Get the current user's top artists\n\n            Parameters:\n                - limit - the number of entities to return\n                - offset - the index of the first entity to return\n                - time_range - Over what time frame are the affinities computed\n                  Valid-values: short_term, medium_term, long_term\n        \"\"\"\n        return self._get(\n            \"me/top/artists\", time_range=time_range, limit=limit, offset=offset\n        )\n\n    def current_user_top_tracks(\n        self, limit=20, offset=0, time_range=\"medium_term\"\n    ):\n        \"\"\" Get the current user's top tracks\n\n            Parameters:\n                - limit - the number of entities to return\n                - offset - the index of the first entity to return\n                - time_range - Over what time frame are the affinities computed\n                  Valid-values: short_term, medium_term, long_term\n        \"\"\"\n        return self._get(\n            \"me/top/tracks\", time_range=time_range, limit=limit, offset=offset\n        )\n\n    def current_user_recently_played(self, limit=50, after=None, before=None):\n        \"\"\" Get the current user's recently played tracks\n\n            Parameters:\n                - limit - the number of entities to return\n                - after - unix timestamp in milliseconds. Returns all items\n                          after (but not including) this cursor position.\n                          Cannot be used if before is specified.\n                - before - unix timestamp in milliseconds. Returns all items\n                           before (but not including) this cursor position.\n                           Cannot be used if after is specified\n        \"\"\"\n        return self._get(\n            \"me/player/recently-played\",\n            limit=limit,\n            after=after,\n            before=before,\n        )\n\n    def user_follow_artists(self, ids=[]):\n        \"\"\" Follow one or more artists\n            Parameters:\n                - ids - a list of artist IDs\n        \"\"\"\n        return self._put(\"me/following?type=artist&ids=\" + \",\".join(ids))\n\n    def user_follow_users(self, ids=[]):\n        \"\"\" Follow one or more users\n            Parameters:\n                - ids - a list of user IDs\n        \"\"\"\n        return self._put(\"me/following?type=user&ids=\" + \",\".join(ids))\n\n    def user_unfollow_artists(self, ids=[]):\n        \"\"\" Unfollow one or more artists\n            Parameters:\n                - ids - a list of artist IDs\n        \"\"\"\n        return self._delete(\"me/following?type=artist&ids=\" + \",\".join(ids))\n\n    def user_unfollow_users(self, ids=[]):\n        \"\"\" Unfollow one or more users\n            Parameters:\n                - ids - a list of user IDs\n        \"\"\"\n        return self._delete(\"me/following?type=user&ids=\" + \",\".join(ids))\n\n    def featured_playlists(\n        self, locale=None, country=None, timestamp=None, limit=20, offset=0\n    ):\n        \"\"\" Get a list of Spotify featured playlists\n\n            Parameters:\n                - locale - The desired language, consisting of a lowercase ISO\n                  639-1 alpha-2 language code and an uppercase ISO 3166-1 alpha-2\n                  country code, joined by an underscore.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - timestamp - A timestamp in ISO 8601 format:\n                  yyyy-MM-ddTHH:mm:ss. Use this parameter to specify the user's\n                  local time to get results tailored for that specific date and\n                  time in the day\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/featured-playlists\",\n            locale=locale,\n            country=country,\n            timestamp=timestamp,\n            limit=limit,\n            offset=offset,\n        )\n\n    def new_releases(self, country=None, limit=20, offset=0):\n        \"\"\" Get a list of new album releases featured in Spotify\n\n            Parameters:\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/new-releases\", country=country, limit=limit, offset=offset\n        )\n\n    def category(self, category_id, country=None, locale=None):\n        \"\"\" Get info about a category\n\n            Parameters:\n                - category_id - The Spotify category ID for the category.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n                - locale - The desired language, consisting of an ISO 639-1 alpha-2\n                  language code and an ISO 3166-1 alpha-2 country code, joined\n                  by an underscore.\n        \"\"\"\n        return self._get(\n            \"browse/categories/\" + category_id,\n            country=country,\n            locale=locale,\n        )\n\n    def categories(self, country=None, locale=None, limit=20, offset=0):\n        \"\"\" Get a list of categories\n\n            Parameters:\n                - country - An ISO 3166-1 alpha-2 country code.\n                - locale - The desired language, consisting of an ISO 639-1 alpha-2\n                  language code and an ISO 3166-1 alpha-2 country code, joined\n                  by an underscore.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/categories\",\n            country=country,\n            locale=locale,\n            limit=limit,\n            offset=offset,\n        )\n\n    def category_playlists(\n        self, category_id=None, country=None, limit=20, offset=0\n    ):\n        \"\"\" Get a list of playlists for a specific Spotify category\n\n            Parameters:\n                - category_id - The Spotify category ID for the category.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/categories/\" + category_id + \"/playlists\",\n            country=country,\n            limit=limit,\n            offset=offset,\n        )\n\n    def recommendations(\n        self,\n        seed_artists=None,\n        seed_genres=None,\n        seed_tracks=None,\n        limit=20,\n        country=None,\n        **kwargs\n    ):\n        \"\"\" Get a list of recommended tracks for one to five seeds.\n            (at least one of `seed_artists`, `seed_tracks` and `seed_genres`\n            are needed)\n\n            Parameters:\n                - seed_artists - a list of artist IDs, URIs or URLs\n                - seed_tracks - a list of track IDs, URIs or URLs\n                - seed_genres - a list of genre names. Available genres for\n                                recommendations can be found by calling\n                                recommendation_genre_seeds\n\n                - country - An ISO 3166-1 alpha-2 country code. If provided,\n                            all results will be playable in this country.\n\n                - limit - The maximum number of items to return. Default: 20.\n                          Minimum: 1. Maximum: 100\n\n                - min/max/target_<attribute> - For the tuneable track\n                    attributes listed in the documentation, these values\n                    provide filters and targeting on results.\n        \"\"\"\n        params = dict(limit=limit)\n        if seed_artists:\n            params[\"seed_artists\"] = \",\".join(\n                [self._get_id(\"artist\", a) for a in seed_artists]\n            )\n        if seed_genres:\n            params[\"seed_genres\"] = \",\".join(seed_genres)\n        if seed_tracks:\n            params[\"seed_tracks\"] = \",\".join(\n                [self._get_id(\"track\", t) for t in seed_tracks]\n            )\n        if country:\n            params[\"market\"] = country\n\n        for attribute in [\n            \"acousticness\",\n            \"danceability\",\n            \"duration_ms\",\n            \"energy\",\n            \"instrumentalness\",\n            \"key\",\n            \"liveness\",\n            \"loudness\",\n            \"mode\",\n            \"popularity\",\n            \"speechiness\",\n            \"tempo\",\n            \"time_signature\",\n            \"valence\",\n        ]:\n            for prefix in [\"min_\", \"max_\", \"target_\"]:\n                param = prefix + attribute\n                if param in kwargs:\n                    params[param] = kwargs[param]\n        return self._get(\"recommendations\", **params)\n\n    def recommendation_genre_seeds(self):\n        \"\"\" Get a list of genres available for the recommendations function.\n        \"\"\"\n        return self._get(\"recommendations/available-genre-seeds\")\n\n    def audio_analysis(self, track_id):\n        \"\"\" Get audio analysis for a track based upon its Spotify ID\n            Parameters:\n                - track_id - a track URI, URL or ID\n        \"\"\"\n        trid = self._get_id(\"track\", track_id)\n        return self._get(\"audio-analysis/\" + trid)\n\n    def audio_features(self, tracks=[]):\n        \"\"\" Get audio features for one or multiple tracks based upon their Spotify IDs\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs, maximum: 100 ids\n        \"\"\"\n        if isinstance(tracks, str):\n            trackid = self._get_id(\"track\", tracks)\n            results = self._get(\"audio-features/?ids=\" + trackid)\n        else:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n            results = self._get(\"audio-features/?ids=\" + \",\".join(tlist))\n        # the response has changed, look for the new style first, and if\n        # its not there, fallback on the old style\n        if \"audio_features\" in results:\n            return results[\"audio_features\"]\n        else:\n            return results\n\n    def devices(self):\n        \"\"\" Get a list of user's available devices.\n        \"\"\"\n        return self._get(\"me/player/devices\")\n\n    def current_playback(self, market=None, additional_types=None):\n        \"\"\" Get information about user's current playback.\n\n            Parameters:\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - `episode` to get podcast track information\n        \"\"\"\n        return self._get(\"me/player\", market=market, additional_types=additional_types)\n\n    def currently_playing(self, market=None, additional_types=None):\n        \"\"\" Get user's currently playing track.\n\n            Parameters:\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - `episode` to get podcast track information\n        \"\"\"\n        return self._get(\"me/player/currently-playing\", market=market,\n                         additional_types=additional_types)\n\n    def transfer_playback(self, device_id, force_play=True):\n        \"\"\" Transfer playback to another device.\n            Note that the API accepts a list of device ids, but only\n            actually supports one.\n\n            Parameters:\n                - device_id - transfer playback to this device\n                - force_play - true: after transfer, play. false:\n                               keep current state.\n        \"\"\"\n        data = {\"device_ids\": [device_id], \"play\": force_play}\n        return self._put(\"me/player\", payload=data)\n\n    def start_playback(\n        self, device_id=None, context_uri=None, uris=None, offset=None, position_ms=None\n    ):\n        \"\"\" Start or resume user's playback.\n\n            Provide a `context_uri` to start playback of an album,\n            artist, or playlist.\n\n            Provide a `uris` list to start playback of one or more\n            tracks.\n\n            Provide `offset` as {\"position\": <int>} or {\"uri\": \"<track uri>\"}\n            to start playback at a particular offset.\n\n            Parameters:\n                - device_id - device target for playback\n                - context_uri - spotify context uri to play\n                - uris - spotify track uris\n                - offset - offset into context by index or track\n                - position_ms - (optional) indicates from what position to start playback.\n                                Must be a positive number. Passing in a position that is\n                                greater than the length of the track will cause the player to\n                                start playing the next song.\n        \"\"\"\n        if context_uri is not None and uris is not None:\n            logger.warning(\"Specify either context uri or uris, not both\")\n            return\n        if uris is not None and not isinstance(uris, list):\n            logger.warning(\"URIs must be a list\")\n            return\n        data = {}\n        if context_uri is not None:\n            data[\"context_uri\"] = context_uri\n        if uris is not None:\n            data[\"uris\"] = uris\n        if offset is not None:\n            data[\"offset\"] = offset\n        if position_ms is not None:\n            data[\"position_ms\"] = position_ms\n        return self._put(\n            self._append_device_id(\"me/player/play\", device_id), payload=data\n        )\n\n    def pause_playback(self, device_id=None):\n        \"\"\" Pause user's playback.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._put(self._append_device_id(\"me/player/pause\", device_id))\n\n    def next_track(self, device_id=None):\n        \"\"\" Skip user's playback to next track.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._post(self._append_device_id(\"me/player/next\", device_id))\n\n    def previous_track(self, device_id=None):\n        \"\"\" Skip user's playback to previous track.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._post(\n            self._append_device_id(\"me/player/previous\", device_id)\n        )\n\n    def seek_track(self, position_ms, device_id=None):\n        \"\"\" Seek to position in current track.\n\n            Parameters:\n                - position_ms - position in milliseconds to seek to\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(position_ms, int):\n            logger.warning(\"Position_ms must be an integer\")\n            return\n        return self._put(\n            self._append_device_id(\n                \"me/player/seek?position_ms=%s\" % position_ms, device_id\n            )\n        )\n\n    def repeat(self, state, device_id=None):\n        \"\"\" Set repeat mode for playback.\n\n            Parameters:\n                - state - `track`, `context`, or `off`\n                - device_id - device target for playback\n        \"\"\"\n        if state not in [\"track\", \"context\", \"off\"]:\n            logger.warning(\"Invalid state\")\n            return\n        self._put(\n            self._append_device_id(\n                \"me/player/repeat?state=%s\" % state, device_id\n            )\n        )\n\n    def volume(self, volume_percent, device_id=None):\n        \"\"\" Set playback volume.\n\n            Parameters:\n                - volume_percent - volume between 0 and 100\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(volume_percent, int):\n            logger.warning(\"Volume must be an integer\")\n            return\n        if volume_percent < 0 or volume_percent > 100:\n            logger.warning(\"Volume must be between 0 and 100, inclusive\")\n            return\n        self._put(\n            self._append_device_id(\n                \"me/player/volume?volume_percent=%s\" % volume_percent,\n                device_id,\n            )\n        )\n\n    def shuffle(self, state, device_id=None):\n        \"\"\" Toggle playback shuffling.\n\n            Parameters:\n                - state - true or false\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(state, bool):\n            logger.warning(\"state must be a boolean\")\n            return\n        state = str(state).lower()\n        self._put(\n            self._append_device_id(\n                \"me/player/shuffle?state=%s\" % state, device_id\n            )\n        )\n\n    def queue(self):\n        \"\"\" Gets the current user's queue \"\"\"\n        return self._get(\"me/player/queue\")\n\n    def add_to_queue(self, uri, device_id=None):\n        \"\"\" Adds a song to the end of a user's queue\n\n            If device A is currently playing music and you try to add to the queue\n            and pass in the id for device B, you will get a\n            'Player command failed: Restriction violated' error\n            I therefore recommend leaving device_id as None so that the active device is targeted\n\n            :param uri: song uri, id, or url\n            :param device_id:\n                the id of a Spotify device.\n                If None, then the active device is used.\n\n        \"\"\"\n\n        uri = self._get_uri(\"track\", uri)\n\n        endpoint = \"me/player/queue?uri=%s\" % uri\n\n        if device_id is not None:\n            endpoint += \"&device_id=%s\" % device_id\n\n        return self._post(endpoint)\n\n    def available_markets(self):\n        \"\"\" Get the list of markets where Spotify is available.\n            Returns a list of the countries in which Spotify is available, identified by their\n            ISO 3166-1 alpha-2 country code with additional country codes for special territories.\n        \"\"\"\n        return self._get(\"markets\")\n\n    def _append_device_id(self, path, device_id):\n        \"\"\" Append device ID to API path.\n\n            Parameters:\n                - device_id - device id to append\n        \"\"\"\n        if device_id:\n            if \"?\" in path:\n                path += \"&device_id=%s\" % device_id\n            else:\n                path += \"?device_id=%s\" % device_id\n        return path\n\n    def _get_id(self, type, id):\n        uri_match = re.search(Spotify._regex_spotify_uri, id)\n        if uri_match is not None:\n            uri_match_groups = uri_match.groupdict()\n            if uri_match_groups['type'] != type:\n                # TODO change to a ValueError in v3\n                raise SpotifyException(400, -1, \"Unexpected Spotify URI type.\")\n            return uri_match_groups['id']\n\n        url_match = re.search(Spotify._regex_spotify_url, id)\n        if url_match is not None:\n            url_match_groups = url_match.groupdict()\n            if url_match_groups['type'] != type:\n                raise SpotifyException(400, -1, \"Unexpected Spotify URL type.\")\n            # TODO change to a ValueError in v3\n            return url_match_groups['id']\n\n        # Raw identifiers might be passed, ensure they are also base-62\n        if re.search(Spotify._regex_base62, id) is not None:\n            return id\n\n        # TODO change to a ValueError in v3\n        raise SpotifyException(400, -1, \"Unsupported URL / URI.\")\n\n    def _get_uri(self, type, id):\n        if self._is_uri(id):\n            return id\n        else:\n            return \"spotify:\" + type + \":\" + self._get_id(type, id)\n\n    def _is_uri(self, uri):\n        return re.search(Spotify._regex_spotify_uri, uri) is not None\n\n    def _search_multiple_markets(self, q, limit, offset, type, markets, total):\n        if total and limit > total:\n            limit = total\n            warnings.warn(\n                \"limit was auto-adjusted to equal {} as it must not be higher than total\".format(\n                    total),\n                UserWarning,\n            )\n\n        results = {}\n        first_type = type.split(\",\")[0] + 's'\n        count = 0\n\n        for country in markets:\n            result = self._get(\n                \"search\", q=q, limit=limit, offset=offset, type=type, market=country\n            )\n            results[country] = result\n\n            count += len(result[first_type]['items'])\n            if total and count >= total:\n                break\n            if total and limit > total - count:\n                # when approaching `total` results, adjust `limit` to not request more\n                # items than needed\n                limit = total - count\n\n        return results\n", "code_before": "# -*- coding: utf-8 -*-\n\n\"\"\" A simple and thin Python library for the Spotify Web API \"\"\"\n\n__all__ = [\"Spotify\", \"SpotifyException\"]\n\nimport json\nimport logging\nimport warnings\n\nimport requests\nimport six\nimport urllib3\n\nfrom spotipy.exceptions import SpotifyException\n\nlogger = logging.getLogger(__name__)\n\n\nclass Spotify(object):\n    \"\"\"\n        Example usage::\n\n            import spotipy\n\n            urn = 'spotify:artist:3jOstUTkEu2JkjvRdBA5Gu'\n            sp = spotipy.Spotify()\n\n            artist = sp.artist(urn)\n            print(artist)\n\n            user = sp.user('plamere')\n            print(user)\n    \"\"\"\n    max_retries = 3\n    default_retry_codes = (429, 500, 502, 503, 504)\n    country_codes = [\n        \"AD\",\n        \"AR\",\n        \"AU\",\n        \"AT\",\n        \"BE\",\n        \"BO\",\n        \"BR\",\n        \"BG\",\n        \"CA\",\n        \"CL\",\n        \"CO\",\n        \"CR\",\n        \"CY\",\n        \"CZ\",\n        \"DK\",\n        \"DO\",\n        \"EC\",\n        \"SV\",\n        \"EE\",\n        \"FI\",\n        \"FR\",\n        \"DE\",\n        \"GR\",\n        \"GT\",\n        \"HN\",\n        \"HK\",\n        \"HU\",\n        \"IS\",\n        \"ID\",\n        \"IE\",\n        \"IT\",\n        \"JP\",\n        \"LV\",\n        \"LI\",\n        \"LT\",\n        \"LU\",\n        \"MY\",\n        \"MT\",\n        \"MX\",\n        \"MC\",\n        \"NL\",\n        \"NZ\",\n        \"NI\",\n        \"NO\",\n        \"PA\",\n        \"PY\",\n        \"PE\",\n        \"PH\",\n        \"PL\",\n        \"PT\",\n        \"SG\",\n        \"ES\",\n        \"SK\",\n        \"SE\",\n        \"CH\",\n        \"TW\",\n        \"TR\",\n        \"GB\",\n        \"US\",\n        \"UY\"]\n\n    def __init__(\n        self,\n        auth=None,\n        requests_session=True,\n        client_credentials_manager=None,\n        oauth_manager=None,\n        auth_manager=None,\n        proxies=None,\n        requests_timeout=5,\n        status_forcelist=None,\n        retries=max_retries,\n        status_retries=max_retries,\n        backoff_factor=0.3,\n        language=None,\n    ):\n        \"\"\"\n        Creates a Spotify API client.\n\n        :param auth: An access token (optional)\n        :param requests_session:\n            A Requests session object or a truthy value to create one.\n            A falsy value disables sessions.\n            It should generally be a good idea to keep sessions enabled\n            for performance reasons (connection pooling).\n        :param client_credentials_manager:\n            SpotifyClientCredentials object\n        :param oauth_manager:\n            SpotifyOAuth object\n        :param auth_manager:\n            SpotifyOauth, SpotifyClientCredentials,\n            or SpotifyImplicitGrant object\n        :param proxies:\n            Definition of proxies (optional).\n            See Requests doc https://2.python-requests.org/en/master/user/advanced/#proxies\n        :param requests_timeout:\n            Tell Requests to stop waiting for a response after a given\n            number of seconds\n        :param status_forcelist:\n            Tell requests what type of status codes retries should occur on\n        :param retries:\n            Total number of retries to allow\n        :param status_retries:\n            Number of times to retry on bad status codes\n        :param backoff_factor:\n            A backoff factor to apply between attempts after the second try\n            See urllib3 https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n        :param language:\n            The language parameter advertises what language the user prefers to see.\n            See ISO-639-1 language code: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n        \"\"\"\n        self.prefix = \"https://api.spotify.com/v1/\"\n        self._auth = auth\n        self.client_credentials_manager = client_credentials_manager\n        self.oauth_manager = oauth_manager\n        self.auth_manager = auth_manager\n        self.proxies = proxies\n        self.requests_timeout = requests_timeout\n        self.status_forcelist = status_forcelist or self.default_retry_codes\n        self.backoff_factor = backoff_factor\n        self.retries = retries\n        self.status_retries = status_retries\n        self.language = language\n\n        if isinstance(requests_session, requests.Session):\n            self._session = requests_session\n        else:\n            if requests_session:  # Build a new session.\n                self._build_session()\n            else:  # Use the Requests API module as a \"session\".\n                self._session = requests.api\n\n    def set_auth(self, auth):\n        self._auth = auth\n\n    @property\n    def auth_manager(self):\n        return self._auth_manager\n\n    @auth_manager.setter\n    def auth_manager(self, auth_manager):\n        if auth_manager is not None:\n            self._auth_manager = auth_manager\n        else:\n            self._auth_manager = (\n                self.client_credentials_manager or self.oauth_manager\n            )\n\n    def __del__(self):\n        \"\"\"Make sure the connection (pool) gets closed\"\"\"\n        if isinstance(self._session, requests.Session):\n            self._session.close()\n\n    def _build_session(self):\n        self._session = requests.Session()\n        retry = urllib3.Retry(\n            total=self.retries,\n            connect=None,\n            read=False,\n            allowed_methods=frozenset(['GET', 'POST', 'PUT', 'DELETE']),\n            status=self.status_retries,\n            backoff_factor=self.backoff_factor,\n            status_forcelist=self.status_forcelist)\n\n        adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n        self._session.mount('http://', adapter)\n        self._session.mount('https://', adapter)\n\n    def _auth_headers(self):\n        if self._auth:\n            return {\"Authorization\": \"Bearer {0}\".format(self._auth)}\n        if not self.auth_manager:\n            return {}\n        try:\n            token = self.auth_manager.get_access_token(as_dict=False)\n        except TypeError:\n            token = self.auth_manager.get_access_token()\n        return {\"Authorization\": \"Bearer {0}\".format(token)}\n\n    def _internal_call(self, method, url, payload, params):\n        args = dict(params=params)\n        if not url.startswith(\"http\"):\n            url = self.prefix + url\n        headers = self._auth_headers()\n\n        if \"content_type\" in args[\"params\"]:\n            headers[\"Content-Type\"] = args[\"params\"][\"content_type\"]\n            del args[\"params\"][\"content_type\"]\n            if payload:\n                args[\"data\"] = payload\n        else:\n            headers[\"Content-Type\"] = \"application/json\"\n            if payload:\n                args[\"data\"] = json.dumps(payload)\n\n        if self.language is not None:\n            headers[\"Accept-Language\"] = self.language\n\n        logger.debug('Sending %s to %s with Params: %s Headers: %s and Body: %r ',\n                     method, url, args.get(\"params\"), headers, args.get('data'))\n\n        try:\n            response = self._session.request(\n                method, url, headers=headers, proxies=self.proxies,\n                timeout=self.requests_timeout, **args\n            )\n\n            response.raise_for_status()\n            results = response.json()\n        except requests.exceptions.HTTPError as http_error:\n            response = http_error.response\n            try:\n                json_response = response.json()\n                error = json_response.get(\"error\", {})\n                msg = error.get(\"message\")\n                reason = error.get(\"reason\")\n            except ValueError:\n                # if the response cannot be decoded into JSON (which raises a ValueError),\n                # then try to decode it into text\n\n                # if we receive an empty string (which is falsy), then replace it with `None`\n                msg = response.text or None\n                reason = None\n\n            logger.error(\n                'HTTP Error for %s to %s with Params: %s returned %s due to %s',\n                method, url, args.get(\"params\"), response.status_code, msg\n            )\n\n            raise SpotifyException(\n                response.status_code,\n                -1,\n                \"%s:\\n %s\" % (response.url, msg),\n                reason=reason,\n                headers=response.headers,\n            )\n        except requests.exceptions.RetryError as retry_error:\n            request = retry_error.request\n            logger.error('Max Retries reached')\n            try:\n                reason = retry_error.args[0].reason\n            except (IndexError, AttributeError):\n                reason = None\n            raise SpotifyException(\n                429,\n                -1,\n                \"%s:\\n %s\" % (request.path_url, \"Max Retries\"),\n                reason=reason\n            )\n        except ValueError:\n            results = None\n\n        logger.debug('RESULTS: %s', results)\n        return results\n\n    def _get(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n\n        return self._internal_call(\"GET\", url, payload, kwargs)\n\n    def _post(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"POST\", url, payload, kwargs)\n\n    def _delete(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"DELETE\", url, payload, kwargs)\n\n    def _put(self, url, args=None, payload=None, **kwargs):\n        if args:\n            kwargs.update(args)\n        return self._internal_call(\"PUT\", url, payload, kwargs)\n\n    def next(self, result):\n        \"\"\" returns the next result given a paged result\n\n            Parameters:\n                - result - a previously returned paged result\n        \"\"\"\n        if result[\"next\"]:\n            return self._get(result[\"next\"])\n        else:\n            return None\n\n    def previous(self, result):\n        \"\"\" returns the previous result given a paged result\n\n            Parameters:\n                - result - a previously returned paged result\n        \"\"\"\n        if result[\"previous\"]:\n            return self._get(result[\"previous\"])\n        else:\n            return None\n\n    def track(self, track_id, market=None):\n        \"\"\" returns a single track given the track's ID, URI or URL\n\n            Parameters:\n                - track_id - a spotify URI, URL or ID\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n\n        trid = self._get_id(\"track\", track_id)\n        return self._get(\"tracks/\" + trid, market=market)\n\n    def tracks(self, tracks, market=None):\n        \"\"\" returns a list of tracks given a list of track IDs, URIs, or URLs\n\n            Parameters:\n                - tracks - a list of spotify URIs, URLs or IDs. Maximum: 50 IDs.\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n\n        tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._get(\"tracks/?ids=\" + \",\".join(tlist), market=market)\n\n    def artist(self, artist_id):\n        \"\"\" returns a single artist given the artist's ID, URI or URL\n\n            Parameters:\n                - artist_id - an artist ID, URI or URL\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid)\n\n    def artists(self, artists):\n        \"\"\" returns a list of artists given the artist IDs, URIs, or URLs\n\n            Parameters:\n                - artists - a list of  artist IDs, URIs or URLs\n        \"\"\"\n\n        tlist = [self._get_id(\"artist\", a) for a in artists]\n        return self._get(\"artists/?ids=\" + \",\".join(tlist))\n\n    def artist_albums(\n        self, artist_id, album_type=None, country=None, limit=20, offset=0\n    ):\n        \"\"\" Get Spotify catalog information about an artist's albums\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n                - album_type - 'album', 'single', 'appears_on', 'compilation'\n                - country - limit the response to one particular country.\n                - limit  - the number of albums to return\n                - offset - the index of the first album to return\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\n            \"artists/\" + trid + \"/albums\",\n            album_type=album_type,\n            country=country,\n            limit=limit,\n            offset=offset,\n        )\n\n    def artist_top_tracks(self, artist_id, country=\"US\"):\n        \"\"\" Get Spotify catalog information about an artist's top 10 tracks\n            by country.\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n                - country - limit the response to one particular country.\n        \"\"\"\n\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid + \"/top-tracks\", country=country)\n\n    def artist_related_artists(self, artist_id):\n        \"\"\" Get Spotify catalog information about artists similar to an\n            identified artist. Similarity is based on analysis of the\n            Spotify community's listening history.\n\n            Parameters:\n                - artist_id - the artist ID, URI or URL\n        \"\"\"\n        trid = self._get_id(\"artist\", artist_id)\n        return self._get(\"artists/\" + trid + \"/related-artists\")\n\n    def album(self, album_id, market=None):\n        \"\"\" returns a single album given the album's ID, URIs or URL\n\n            Parameters:\n                - album_id - the album ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code\n        \"\"\"\n\n        trid = self._get_id(\"album\", album_id)\n        if market is not None:\n            return self._get(\"albums/\" + trid + '?market=' + market)\n        else:\n            return self._get(\"albums/\" + trid)\n\n    def album_tracks(self, album_id, limit=50, offset=0, market=None):\n        \"\"\" Get Spotify catalog information about an album's tracks\n\n            Parameters:\n                - album_id - the album ID, URI or URL\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n                - market - an ISO 3166-1 alpha-2 country code.\n\n        \"\"\"\n\n        trid = self._get_id(\"album\", album_id)\n        return self._get(\n            \"albums/\" + trid + \"/tracks/\", limit=limit, offset=offset, market=market\n        )\n\n    def albums(self, albums, market=None):\n        \"\"\" returns a list of albums given the album IDs, URIs, or URLs\n\n            Parameters:\n                - albums - a list of  album IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code\n        \"\"\"\n\n        tlist = [self._get_id(\"album\", a) for a in albums]\n        if market is not None:\n            return self._get(\"albums/?ids=\" + \",\".join(tlist) + '&market=' + market)\n        else:\n            return self._get(\"albums/?ids=\" + \",\".join(tlist))\n\n    def show(self, show_id, market=None):\n        \"\"\" returns a single show given the show's ID, URIs or URL\n\n            Parameters:\n                - show_id - the show ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code.\n                           The show must be available in the given market.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"show\", show_id)\n        return self._get(\"shows/\" + trid, market=market)\n\n    def shows(self, shows, market=None):\n        \"\"\" returns a list of shows given the show IDs, URIs, or URLs\n\n            Parameters:\n                - shows - a list of show IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only shows available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        tlist = [self._get_id(\"show\", s) for s in shows]\n        return self._get(\"shows/?ids=\" + \",\".join(tlist), market=market)\n\n    def show_episodes(self, show_id, limit=50, offset=0, market=None):\n        \"\"\" Get Spotify catalog information about a show's episodes\n\n            Parameters:\n                - show_id - the show ID, URI or URL\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only episodes available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"show\", show_id)\n        return self._get(\n            \"shows/\" + trid + \"/episodes/\", limit=limit, offset=offset, market=market\n        )\n\n    def episode(self, episode_id, market=None):\n        \"\"\" returns a single episode given the episode's ID, URIs or URL\n\n            Parameters:\n                - episode_id - the episode ID, URI or URL\n                - market - an ISO 3166-1 alpha-2 country code.\n                           The episode must be available in the given market.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        trid = self._get_id(\"episode\", episode_id)\n        return self._get(\"episodes/\" + trid, market=market)\n\n    def episodes(self, episodes, market=None):\n        \"\"\" returns a list of episodes given the episode IDs, URIs, or URLs\n\n            Parameters:\n                - episodes - a list of episode IDs, URIs or URLs\n                - market - an ISO 3166-1 alpha-2 country code.\n                           Only episodes available in the given market will be returned.\n                           If user-based authorization is in use, the user's country\n                           takes precedence. If neither market nor user country are\n                           provided, the content is considered unavailable for the client.\n        \"\"\"\n\n        tlist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._get(\"episodes/?ids=\" + \",\".join(tlist), market=market)\n\n    def search(self, q, limit=10, offset=0, type=\"track\", market=None):\n        \"\"\" searches for an item\n\n            Parameters:\n                - q - the search query (see how to write a query in the\n                      official documentation https://developer.spotify.com/documentation/web-api/reference/search/)  # noqa\n                - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied\n                          within each type, not on the total response.\n                - offset - the index of the first item to return\n                - type - the types of items to return. One or more of 'artist', 'album',\n                         'track', 'playlist', 'show', and 'episode'.  If multiple types are desired,\n                         pass in a comma separated string; e.g., 'track,album,episode'.\n                - market - An ISO 3166-1 alpha-2 country code or the string\n                           from_token.\n        \"\"\"\n        return self._get(\n            \"search\", q=q, limit=limit, offset=offset, type=type, market=market\n        )\n\n    def search_markets(self, q, limit=10, offset=0, type=\"track\", markets=None, total=None):\n        \"\"\" (experimental) Searches multiple markets for an item\n\n            Parameters:\n                - q - the search query (see how to write a query in the\n                      official documentation https://developer.spotify.com/documentation/web-api/reference/search/)  # noqa\n                - limit  - the number of items to return (min = 1, default = 10, max = 50). If a search is to be done on multiple\n                            markets, then this limit is applied to each market. (e.g. search US, CA, MX each with a limit of 10).\n                - offset - the index of the first item to return\n                - type - the types of items to return. One or more of 'artist', 'album',\n                         'track', 'playlist', 'show', or 'episode'. If multiple types are desired, pass in a comma separated string.\n                - markets - A list of ISO 3166-1 alpha-2 country codes. Search all country markets by default.\n                - total - the total number of results to return if multiple markets are supplied in the search.\n                          If multiple types are specified, this only applies to the first type.\n        \"\"\"\n        warnings.warn(\n            \"Searching multiple markets is an experimental feature. \"\n            \"Please be aware that this method's inputs and outputs can change in the future.\",\n            UserWarning,\n        )\n        if not markets:\n            markets = self.country_codes\n\n        if not (isinstance(markets, list) or isinstance(markets, tuple)):\n            markets = []\n\n        warnings.warn(\n            \"Searching multiple markets is poorly performing.\",\n            UserWarning,\n        )\n        return self._search_multiple_markets(q, limit, offset, type, markets, total)\n\n    def user(self, user):\n        \"\"\" Gets basic profile information about a Spotify User\n\n            Parameters:\n                - user - the id of the usr\n        \"\"\"\n        return self._get(\"users/\" + user)\n\n    def current_user_playlists(self, limit=50, offset=0):\n        \"\"\" Get current user playlists without required getting his profile\n            Parameters:\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n        \"\"\"\n        return self._get(\"me/playlists\", limit=limit, offset=offset)\n\n    def playlist(self, playlist_id, fields=None, market=None, additional_types=(\"track\",)):\n        \"\"\" Gets playlist by id.\n\n            Parameters:\n                - playlist - the id of the playlist\n                - fields - which fields to return\n                - market - An ISO 3166-1 alpha-2 country code or the\n                           string from_token.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\n            \"playlists/%s\" % (plid),\n            fields=fields,\n            market=market,\n            additional_types=\",\".join(additional_types),\n        )\n\n    def playlist_tracks(\n        self,\n        playlist_id,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n        additional_types=(\"track\",)\n    ):\n        \"\"\" Get full details of the tracks of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_items(playlist_id, ...,\"\n            \"additional_types=('track',))` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_items(playlist_id, fields, limit, offset,\n                                   market, additional_types)\n\n    def playlist_items(\n        self,\n        playlist_id,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n        additional_types=(\"track\", \"episode\")\n    ):\n        \"\"\" Get full details of the tracks and episodes of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - list of item types to return.\n                                     valid types are: track and episode\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\n            \"playlists/%s/tracks\" % (plid),\n            limit=limit,\n            offset=offset,\n            fields=fields,\n            market=market,\n            additional_types=\",\".join(additional_types)\n        )\n\n    def playlist_cover_image(self, playlist_id):\n        \"\"\" Get cover image of a playlist.\n\n            Parameters:\n                - playlist_id - the playlist ID, URI or URL\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._get(\"playlists/%s/images\" % (plid))\n\n    def playlist_upload_cover_image(self, playlist_id, image_b64):\n        \"\"\" Replace the image used to represent a specific playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - image_b64 - image data as a Base64 encoded JPEG image string\n                    (maximum payload size is 256 KB)\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        return self._put(\n            \"playlists/{}/images\".format(plid),\n            payload=image_b64,\n            content_type=\"image/jpeg\",\n        )\n\n    def user_playlist(self, user, playlist_id=None, fields=None, market=None):\n        warnings.warn(\n            \"You should use `playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n\n        \"\"\" Gets a single playlist of a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - fields - which fields to return\n        \"\"\"\n        if playlist_id is None:\n            return self._get(\"users/%s/starred\" % user)\n        return self.playlist(playlist_id, fields=fields, market=market)\n\n    def user_playlist_tracks(\n        self,\n        user=None,\n        playlist_id=None,\n        fields=None,\n        limit=100,\n        offset=0,\n        market=None,\n    ):\n        warnings.warn(\n            \"You should use `playlist_tracks(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n\n        \"\"\" Get full details of the tracks of a playlist owned by a user.\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - fields - which fields to return\n                - limit - the maximum number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code.\n        \"\"\"\n        return self.playlist_tracks(\n            playlist_id,\n            limit=limit,\n            offset=offset,\n            fields=fields,\n            market=market,\n        )\n\n    def user_playlists(self, user, limit=50, offset=0):\n        \"\"\" Gets playlists of a user\n\n            Parameters:\n                - user - the id of the usr\n                - limit  - the number of items to return\n                - offset - the index of the first item to return\n        \"\"\"\n        return self._get(\n            \"users/%s/playlists\" % user, limit=limit, offset=offset\n        )\n\n    def user_playlist_create(self, user, name, public=True, collaborative=False, description=\"\"):\n        \"\"\" Creates a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - name - the name of the playlist\n                - public - is the created playlist public\n                - collaborative - is the created playlist collaborative\n                - description - the description of the playlist\n        \"\"\"\n        data = {\n            \"name\": name,\n            \"public\": public,\n            \"collaborative\": collaborative,\n            \"description\": description\n        }\n\n        return self._post(\"users/%s/playlists\" % (user,), payload=data)\n\n    def user_playlist_change_details(\n        self,\n        user,\n        playlist_id,\n        name=None,\n        public=None,\n        collaborative=None,\n        description=None,\n    ):\n        warnings.warn(\n            \"You should use `playlist_change_details(playlist_id, ...)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Changes a playlist's name and/or public/private state\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - name - optional name of the playlist\n                - public - optional is the playlist public\n                - collaborative - optional is the playlist collaborative\n                - description - optional description of the playlist\n        \"\"\"\n\n        return self.playlist_change_details(playlist_id, name, public,\n                                            collaborative, description)\n\n    def user_playlist_unfollow(self, user, playlist_id):\n        \"\"\" Unfollows (deletes) a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - name - the name of the playlist\n        \"\"\"\n        warnings.warn(\n            \"You should use `current_user_unfollow_playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n        return self.current_user_unfollow_playlist(playlist_id)\n\n    def user_playlist_add_tracks(\n        self, user, playlist_id, tracks, position=None\n    ):\n        warnings.warn(\n            \"You should use `playlist_add_items(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Adds tracks to a playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - a list of track URIs, URLs or IDs\n                - position - the position to add the tracks\n        \"\"\"\n        tracks = [self._get_uri(\"track\", tid) for tid in tracks]\n        return self.playlist_add_items(playlist_id, tracks, position)\n\n    def user_playlist_add_episodes(\n        self, user, playlist_id, episodes, position=None\n    ):\n        warnings.warn(\n            \"You should use `playlist_add_items(playlist_id, episodes)` instead\",\n            DeprecationWarning,\n        )\n        \"\"\" Adds episodes to a playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - episodes - a list of track URIs, URLs or IDs\n                - position - the position to add the episodes\n        \"\"\"\n        episodes = [self._get_uri(\"episode\", tid) for tid in episodes]\n        return self.playlist_add_items(playlist_id, episodes, position)\n\n    def user_playlist_replace_tracks(self, user, playlist_id, tracks):\n        \"\"\" Replace all tracks in a playlist for a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - the list of track ids to add to the playlist\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_replace_items(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_replace_items(playlist_id, tracks)\n\n    def user_playlist_reorder_tracks(\n        self,\n        user,\n        playlist_id,\n        range_start,\n        insert_before,\n        range_length=1,\n        snapshot_id=None,\n    ):\n        \"\"\" Reorder tracks in a playlist from a user\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - range_start - the position of the first track to be reordered\n                - range_length - optional the number of tracks to be reordered\n                                 (default: 1)\n                - insert_before - the position where the tracks should be\n                                  inserted\n                - snapshot_id - optional playlist's snapshot ID\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_reorder_items(playlist_id, ...)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_reorder_items(playlist_id, range_start,\n                                           insert_before, range_length,\n                                           snapshot_id)\n\n    def user_playlist_remove_all_occurrences_of_tracks(\n        self, user, playlist_id, tracks, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - the list of track ids to remove from the playlist\n                - snapshot_id - optional id of the playlist snapshot\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_remove_all_occurrences_of_items\"\n            \"(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_remove_all_occurrences_of_items(playlist_id,\n                                                             tracks,\n                                                             snapshot_id)\n\n    def user_playlist_remove_specific_occurrences_of_tracks(\n        self, user, playlist_id, tracks, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - user - the id of the user\n                - playlist_id - the id of the playlist\n                - tracks - an array of objects containing Spotify URIs of the\n                    tracks to remove with their current positions in the\n                    playlist.  For example:\n                        [  { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] },\n                        { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ]\n                - snapshot_id - optional id of the playlist snapshot\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_remove_specific_occurrences_of_items\"\n            \"(playlist_id, tracks)` instead\",\n            DeprecationWarning,\n        )\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = []\n        for tr in tracks:\n            ftracks.append(\n                {\n                    \"uri\": self._get_uri(\"track\", tr[\"uri\"]),\n                    \"positions\": tr[\"positions\"],\n                }\n            )\n        payload = {\"tracks\": ftracks}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"users/%s/playlists/%s/tracks\" % (user, plid), payload=payload\n        )\n\n    def user_playlist_follow_playlist(self, playlist_owner_id, playlist_id):\n        \"\"\"\n        Add the current authenticated user as a follower of a playlist.\n\n        Parameters:\n            - playlist_owner_id - the user id of the playlist owner\n            - playlist_id - the id of the playlist\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `current_user_follow_playlist(playlist_id)` instead\",\n            DeprecationWarning,\n        )\n        return self.current_user_follow_playlist(playlist_id)\n\n    def user_playlist_is_following(\n        self, playlist_owner_id, playlist_id, user_ids\n    ):\n        \"\"\"\n        Check to see if the given users are following the given playlist\n\n        Parameters:\n            - playlist_owner_id - the user id of the playlist owner\n            - playlist_id - the id of the playlist\n            - user_ids - the ids of the users that you want to check to see\n                if they follow the playlist. Maximum: 5 ids.\n\n        \"\"\"\n        warnings.warn(\n            \"You should use `playlist_is_following(playlist_id, user_ids)` instead\",\n            DeprecationWarning,\n        )\n        return self.playlist_is_following(playlist_id, user_ids)\n\n    def playlist_change_details(\n        self,\n        playlist_id,\n        name=None,\n        public=None,\n        collaborative=None,\n        description=None,\n    ):\n        \"\"\" Changes a playlist's name and/or public/private state,\n            collaborative state, and/or description\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - name - optional name of the playlist\n                - public - optional is the playlist public\n                - collaborative - optional is the playlist collaborative\n                - description - optional description of the playlist\n        \"\"\"\n\n        data = {}\n        if isinstance(name, six.string_types):\n            data[\"name\"] = name\n        if isinstance(public, bool):\n            data[\"public\"] = public\n        if isinstance(collaborative, bool):\n            data[\"collaborative\"] = collaborative\n        if isinstance(description, six.string_types):\n            data[\"description\"] = description\n        return self._put(\n            \"playlists/%s\" % (self._get_id(\"playlist\", playlist_id)), payload=data\n        )\n\n    def current_user_unfollow_playlist(self, playlist_id):\n        \"\"\" Unfollows (deletes) a playlist for the current authenticated\n            user\n\n            Parameters:\n                - name - the name of the playlist\n        \"\"\"\n        return self._delete(\n            \"playlists/%s/followers\" % (playlist_id)\n        )\n\n    def playlist_add_items(\n        self, playlist_id, items, position=None\n    ):\n        \"\"\" Adds tracks/episodes to a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - a list of track/episode URIs or URLs\n                - position - the position to add the tracks\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        return self._post(\n            \"playlists/%s/tracks\" % (plid),\n            payload=ftracks,\n            position=position,\n        )\n\n    def playlist_replace_items(self, playlist_id, items):\n        \"\"\" Replace all tracks/episodes in a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - list of track/episode ids to comprise playlist\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        payload = {\"uris\": ftracks}\n        return self._put(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_reorder_items(\n        self,\n        playlist_id,\n        range_start,\n        insert_before,\n        range_length=1,\n        snapshot_id=None,\n    ):\n        \"\"\" Reorder tracks in a playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - range_start - the position of the first track to be reordered\n                - range_length - optional the number of tracks to be reordered\n                                 (default: 1)\n                - insert_before - the position where the tracks should be\n                                  inserted\n                - snapshot_id - optional playlist's snapshot ID\n        \"\"\"\n        plid = self._get_id(\"playlist\", playlist_id)\n        payload = {\n            \"range_start\": range_start,\n            \"range_length\": range_length,\n            \"insert_before\": insert_before,\n        }\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._put(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_remove_all_occurrences_of_items(\n        self, playlist_id, items, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks/episodes from the given playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - list of track/episode ids to remove from the playlist\n                - snapshot_id - optional id of the playlist snapshot\n\n        \"\"\"\n\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = [self._get_uri(\"track\", tid) for tid in items]\n        payload = {\"tracks\": [{\"uri\": track} for track in ftracks]}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def playlist_remove_specific_occurrences_of_items(\n        self, playlist_id, items, snapshot_id=None\n    ):\n        \"\"\" Removes all occurrences of the given tracks from the given playlist\n\n            Parameters:\n                - playlist_id - the id of the playlist\n                - items - an array of objects containing Spotify URIs of the\n                    tracks/episodes to remove with their current positions in\n                    the playlist.  For example:\n                        [  { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] },\n                        { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ]\n                - snapshot_id - optional id of the playlist snapshot\n        \"\"\"\n\n        plid = self._get_id(\"playlist\", playlist_id)\n        ftracks = []\n        for tr in items:\n            ftracks.append(\n                {\n                    \"uri\": self._get_uri(\"track\", tr[\"uri\"]),\n                    \"positions\": tr[\"positions\"],\n                }\n            )\n        payload = {\"tracks\": ftracks}\n        if snapshot_id:\n            payload[\"snapshot_id\"] = snapshot_id\n        return self._delete(\n            \"playlists/%s/tracks\" % (plid), payload=payload\n        )\n\n    def current_user_follow_playlist(self, playlist_id):\n        \"\"\"\n        Add the current authenticated user as a follower of a playlist.\n\n        Parameters:\n            - playlist_id - the id of the playlist\n\n        \"\"\"\n        return self._put(\n            \"playlists/{}/followers\".format(playlist_id)\n        )\n\n    def playlist_is_following(\n        self, playlist_id, user_ids\n    ):\n        \"\"\"\n        Check to see if the given users are following the given playlist\n\n        Parameters:\n            - playlist_id - the id of the playlist\n            - user_ids - the ids of the users that you want to check to see\n                if they follow the playlist. Maximum: 5 ids.\n\n        \"\"\"\n        endpoint = \"playlists/{}/followers/contains?ids={}\"\n        return self._get(\n            endpoint.format(playlist_id, \",\".join(user_ids))\n        )\n\n    def me(self):\n        \"\"\" Get detailed profile information about the current user.\n            An alias for the 'current_user' method.\n        \"\"\"\n        return self._get(\"me/\")\n\n    def current_user(self):\n        \"\"\" Get detailed profile information about the current user.\n            An alias for the 'me' method.\n        \"\"\"\n        return self.me()\n\n    def current_user_playing_track(self):\n        \"\"\" Get information about the current users currently playing track.\n        \"\"\"\n        return self._get(\"me/player/currently-playing\")\n\n    def current_user_saved_albums(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the albums saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of albums to return (MAX_LIMIT=50)\n                - offset - the index of the first album to return\n                - market - an ISO 3166-1 alpha-2 country code.\n\n        \"\"\"\n        return self._get(\"me/albums\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_albums_add(self, albums=[]):\n        \"\"\" Add one or more albums to the current user's\n            \"Your Music\" library.\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._put(\"me/albums?ids=\" + \",\".join(alist))\n\n    def current_user_saved_albums_delete(self, albums=[]):\n        \"\"\" Remove one or more albums from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._delete(\"me/albums/?ids=\" + \",\".join(alist))\n\n    def current_user_saved_albums_contains(self, albums=[]):\n        \"\"\" Check if one or more albums is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - albums - a list of album URIs, URLs or IDs\n        \"\"\"\n        alist = [self._get_id(\"album\", a) for a in albums]\n        return self._get(\"me/albums/contains?ids=\" + \",\".join(alist))\n\n    def current_user_saved_tracks(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the tracks saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of tracks to return\n                - offset - the index of the first track to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/tracks\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_tracks_add(self, tracks=None):\n        \"\"\" Add one or more tracks to the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._put(\"me/tracks/?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_tracks_delete(self, tracks=None):\n        \"\"\" Remove one or more tracks from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._delete(\"me/tracks/?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_tracks_contains(self, tracks=None):\n        \"\"\" Check if one or more tracks is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs\n        \"\"\"\n        tlist = []\n        if tracks is not None:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n        return self._get(\"me/tracks/contains?ids=\" + \",\".join(tlist))\n\n    def current_user_saved_episodes(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the episodes saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of episodes to return\n                - offset - the index of the first episode to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/episodes\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_episodes_add(self, episodes=None):\n        \"\"\" Add one or more episodes to the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._put(\"me/episodes/?ids=\" + \",\".join(elist))\n\n    def current_user_saved_episodes_delete(self, episodes=None):\n        \"\"\" Remove one or more episodes from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._delete(\"me/episodes/?ids=\" + \",\".join(elist))\n\n    def current_user_saved_episodes_contains(self, episodes=None):\n        \"\"\" Check if one or more episodes is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - episodes - a list of episode URIs, URLs or IDs\n        \"\"\"\n        elist = []\n        if episodes is not None:\n            elist = [self._get_id(\"episode\", e) for e in episodes]\n        return self._get(\"me/episodes/contains?ids=\" + \",\".join(elist))\n\n    def current_user_saved_shows(self, limit=20, offset=0, market=None):\n        \"\"\" Gets a list of the shows saved in the current authorized user's\n            \"Your Music\" library\n\n            Parameters:\n                - limit - the number of shows to return\n                - offset - the index of the first show to return\n                - market - an ISO 3166-1 alpha-2 country code\n\n        \"\"\"\n        return self._get(\"me/shows\", limit=limit, offset=offset, market=market)\n\n    def current_user_saved_shows_add(self, shows=[]):\n        \"\"\" Add one or more albums to the current user's\n            \"Your Music\" library.\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._put(\"me/shows?ids=\" + \",\".join(slist))\n\n    def current_user_saved_shows_delete(self, shows=[]):\n        \"\"\" Remove one or more shows from the current user's\n            \"Your Music\" library.\n\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._delete(\"me/shows/?ids=\" + \",\".join(slist))\n\n    def current_user_saved_shows_contains(self, shows=[]):\n        \"\"\" Check if one or more shows is already saved in\n            the current Spotify user\u2019s \u201cYour Music\u201d library.\n\n            Parameters:\n                - shows - a list of show URIs, URLs or IDs\n        \"\"\"\n        slist = [self._get_id(\"show\", s) for s in shows]\n        return self._get(\"me/shows/contains?ids=\" + \",\".join(slist))\n\n    def current_user_followed_artists(self, limit=20, after=None):\n        \"\"\" Gets a list of the artists followed by the current authorized user\n\n            Parameters:\n                - limit - the number of artists to return\n                - after - the last artist ID retrieved from the previous\n                          request\n\n        \"\"\"\n        return self._get(\n            \"me/following\", type=\"artist\", limit=limit, after=after\n        )\n\n    def current_user_following_artists(self, ids=None):\n        \"\"\" Check if the current user is following certain artists\n\n            Returns list of booleans respective to ids\n\n            Parameters:\n                - ids - a list of artist URIs, URLs or IDs\n        \"\"\"\n        idlist = []\n        if ids is not None:\n            idlist = [self._get_id(\"artist\", i) for i in ids]\n        return self._get(\n            \"me/following/contains\", ids=\",\".join(idlist), type=\"artist\"\n        )\n\n    def current_user_following_users(self, ids=None):\n        \"\"\" Check if the current user is following certain users\n\n            Returns list of booleans respective to ids\n\n            Parameters:\n                - ids - a list of user URIs, URLs or IDs\n        \"\"\"\n        idlist = []\n        if ids is not None:\n            idlist = [self._get_id(\"user\", i) for i in ids]\n        return self._get(\n            \"me/following/contains\", ids=\",\".join(idlist), type=\"user\"\n        )\n\n    def current_user_top_artists(\n        self, limit=20, offset=0, time_range=\"medium_term\"\n    ):\n        \"\"\" Get the current user's top artists\n\n            Parameters:\n                - limit - the number of entities to return\n                - offset - the index of the first entity to return\n                - time_range - Over what time frame are the affinities computed\n                  Valid-values: short_term, medium_term, long_term\n        \"\"\"\n        return self._get(\n            \"me/top/artists\", time_range=time_range, limit=limit, offset=offset\n        )\n\n    def current_user_top_tracks(\n        self, limit=20, offset=0, time_range=\"medium_term\"\n    ):\n        \"\"\" Get the current user's top tracks\n\n            Parameters:\n                - limit - the number of entities to return\n                - offset - the index of the first entity to return\n                - time_range - Over what time frame are the affinities computed\n                  Valid-values: short_term, medium_term, long_term\n        \"\"\"\n        return self._get(\n            \"me/top/tracks\", time_range=time_range, limit=limit, offset=offset\n        )\n\n    def current_user_recently_played(self, limit=50, after=None, before=None):\n        \"\"\" Get the current user's recently played tracks\n\n            Parameters:\n                - limit - the number of entities to return\n                - after - unix timestamp in milliseconds. Returns all items\n                          after (but not including) this cursor position.\n                          Cannot be used if before is specified.\n                - before - unix timestamp in milliseconds. Returns all items\n                           before (but not including) this cursor position.\n                           Cannot be used if after is specified\n        \"\"\"\n        return self._get(\n            \"me/player/recently-played\",\n            limit=limit,\n            after=after,\n            before=before,\n        )\n\n    def user_follow_artists(self, ids=[]):\n        \"\"\" Follow one or more artists\n            Parameters:\n                - ids - a list of artist IDs\n        \"\"\"\n        return self._put(\"me/following?type=artist&ids=\" + \",\".join(ids))\n\n    def user_follow_users(self, ids=[]):\n        \"\"\" Follow one or more users\n            Parameters:\n                - ids - a list of user IDs\n        \"\"\"\n        return self._put(\"me/following?type=user&ids=\" + \",\".join(ids))\n\n    def user_unfollow_artists(self, ids=[]):\n        \"\"\" Unfollow one or more artists\n            Parameters:\n                - ids - a list of artist IDs\n        \"\"\"\n        return self._delete(\"me/following?type=artist&ids=\" + \",\".join(ids))\n\n    def user_unfollow_users(self, ids=[]):\n        \"\"\" Unfollow one or more users\n            Parameters:\n                - ids - a list of user IDs\n        \"\"\"\n        return self._delete(\"me/following?type=user&ids=\" + \",\".join(ids))\n\n    def featured_playlists(\n        self, locale=None, country=None, timestamp=None, limit=20, offset=0\n    ):\n        \"\"\" Get a list of Spotify featured playlists\n\n            Parameters:\n                - locale - The desired language, consisting of a lowercase ISO\n                  639-1 alpha-2 language code and an uppercase ISO 3166-1 alpha-2\n                  country code, joined by an underscore.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - timestamp - A timestamp in ISO 8601 format:\n                  yyyy-MM-ddTHH:mm:ss. Use this parameter to specify the user's\n                  local time to get results tailored for that specific date and\n                  time in the day\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/featured-playlists\",\n            locale=locale,\n            country=country,\n            timestamp=timestamp,\n            limit=limit,\n            offset=offset,\n        )\n\n    def new_releases(self, country=None, limit=20, offset=0):\n        \"\"\" Get a list of new album releases featured in Spotify\n\n            Parameters:\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/new-releases\", country=country, limit=limit, offset=offset\n        )\n\n    def category(self, category_id, country=None, locale=None):\n        \"\"\" Get info about a category\n\n            Parameters:\n                - category_id - The Spotify category ID for the category.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n                - locale - The desired language, consisting of an ISO 639-1 alpha-2\n                  language code and an ISO 3166-1 alpha-2 country code, joined\n                  by an underscore.\n        \"\"\"\n        return self._get(\n            \"browse/categories/\" + category_id,\n            country=country,\n            locale=locale,\n        )\n\n    def categories(self, country=None, locale=None, limit=20, offset=0):\n        \"\"\" Get a list of categories\n\n            Parameters:\n                - country - An ISO 3166-1 alpha-2 country code.\n                - locale - The desired language, consisting of an ISO 639-1 alpha-2\n                  language code and an ISO 3166-1 alpha-2 country code, joined\n                  by an underscore.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/categories\",\n            country=country,\n            locale=locale,\n            limit=limit,\n            offset=offset,\n        )\n\n    def category_playlists(\n        self, category_id=None, country=None, limit=20, offset=0\n    ):\n        \"\"\" Get a list of playlists for a specific Spotify category\n\n            Parameters:\n                - category_id - The Spotify category ID for the category.\n\n                - country - An ISO 3166-1 alpha-2 country code.\n\n                - limit - The maximum number of items to return. Default: 20.\n                  Minimum: 1. Maximum: 50\n\n                - offset - The index of the first item to return. Default: 0\n                  (the first object). Use with limit to get the next set of\n                  items.\n        \"\"\"\n        return self._get(\n            \"browse/categories/\" + category_id + \"/playlists\",\n            country=country,\n            limit=limit,\n            offset=offset,\n        )\n\n    def recommendations(\n        self,\n        seed_artists=None,\n        seed_genres=None,\n        seed_tracks=None,\n        limit=20,\n        country=None,\n        **kwargs\n    ):\n        \"\"\" Get a list of recommended tracks for one to five seeds.\n            (at least one of `seed_artists`, `seed_tracks` and `seed_genres`\n            are needed)\n\n            Parameters:\n                - seed_artists - a list of artist IDs, URIs or URLs\n                - seed_tracks - a list of track IDs, URIs or URLs\n                - seed_genres - a list of genre names. Available genres for\n                                recommendations can be found by calling\n                                recommendation_genre_seeds\n\n                - country - An ISO 3166-1 alpha-2 country code. If provided,\n                            all results will be playable in this country.\n\n                - limit - The maximum number of items to return. Default: 20.\n                          Minimum: 1. Maximum: 100\n\n                - min/max/target_<attribute> - For the tuneable track\n                    attributes listed in the documentation, these values\n                    provide filters and targeting on results.\n        \"\"\"\n        params = dict(limit=limit)\n        if seed_artists:\n            params[\"seed_artists\"] = \",\".join(\n                [self._get_id(\"artist\", a) for a in seed_artists]\n            )\n        if seed_genres:\n            params[\"seed_genres\"] = \",\".join(seed_genres)\n        if seed_tracks:\n            params[\"seed_tracks\"] = \",\".join(\n                [self._get_id(\"track\", t) for t in seed_tracks]\n            )\n        if country:\n            params[\"market\"] = country\n\n        for attribute in [\n            \"acousticness\",\n            \"danceability\",\n            \"duration_ms\",\n            \"energy\",\n            \"instrumentalness\",\n            \"key\",\n            \"liveness\",\n            \"loudness\",\n            \"mode\",\n            \"popularity\",\n            \"speechiness\",\n            \"tempo\",\n            \"time_signature\",\n            \"valence\",\n        ]:\n            for prefix in [\"min_\", \"max_\", \"target_\"]:\n                param = prefix + attribute\n                if param in kwargs:\n                    params[param] = kwargs[param]\n        return self._get(\"recommendations\", **params)\n\n    def recommendation_genre_seeds(self):\n        \"\"\" Get a list of genres available for the recommendations function.\n        \"\"\"\n        return self._get(\"recommendations/available-genre-seeds\")\n\n    def audio_analysis(self, track_id):\n        \"\"\" Get audio analysis for a track based upon its Spotify ID\n            Parameters:\n                - track_id - a track URI, URL or ID\n        \"\"\"\n        trid = self._get_id(\"track\", track_id)\n        return self._get(\"audio-analysis/\" + trid)\n\n    def audio_features(self, tracks=[]):\n        \"\"\" Get audio features for one or multiple tracks based upon their Spotify IDs\n            Parameters:\n                - tracks - a list of track URIs, URLs or IDs, maximum: 100 ids\n        \"\"\"\n        if isinstance(tracks, str):\n            trackid = self._get_id(\"track\", tracks)\n            results = self._get(\"audio-features/?ids=\" + trackid)\n        else:\n            tlist = [self._get_id(\"track\", t) for t in tracks]\n            results = self._get(\"audio-features/?ids=\" + \",\".join(tlist))\n        # the response has changed, look for the new style first, and if\n        # its not there, fallback on the old style\n        if \"audio_features\" in results:\n            return results[\"audio_features\"]\n        else:\n            return results\n\n    def devices(self):\n        \"\"\" Get a list of user's available devices.\n        \"\"\"\n        return self._get(\"me/player/devices\")\n\n    def current_playback(self, market=None, additional_types=None):\n        \"\"\" Get information about user's current playback.\n\n            Parameters:\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - `episode` to get podcast track information\n        \"\"\"\n        return self._get(\"me/player\", market=market, additional_types=additional_types)\n\n    def currently_playing(self, market=None, additional_types=None):\n        \"\"\" Get user's currently playing track.\n\n            Parameters:\n                - market - an ISO 3166-1 alpha-2 country code.\n                - additional_types - `episode` to get podcast track information\n        \"\"\"\n        return self._get(\"me/player/currently-playing\", market=market,\n                         additional_types=additional_types)\n\n    def transfer_playback(self, device_id, force_play=True):\n        \"\"\" Transfer playback to another device.\n            Note that the API accepts a list of device ids, but only\n            actually supports one.\n\n            Parameters:\n                - device_id - transfer playback to this device\n                - force_play - true: after transfer, play. false:\n                               keep current state.\n        \"\"\"\n        data = {\"device_ids\": [device_id], \"play\": force_play}\n        return self._put(\"me/player\", payload=data)\n\n    def start_playback(\n        self, device_id=None, context_uri=None, uris=None, offset=None, position_ms=None\n    ):\n        \"\"\" Start or resume user's playback.\n\n            Provide a `context_uri` to start playback of an album,\n            artist, or playlist.\n\n            Provide a `uris` list to start playback of one or more\n            tracks.\n\n            Provide `offset` as {\"position\": <int>} or {\"uri\": \"<track uri>\"}\n            to start playback at a particular offset.\n\n            Parameters:\n                - device_id - device target for playback\n                - context_uri - spotify context uri to play\n                - uris - spotify track uris\n                - offset - offset into context by index or track\n                - position_ms - (optional) indicates from what position to start playback.\n                                Must be a positive number. Passing in a position that is\n                                greater than the length of the track will cause the player to\n                                start playing the next song.\n        \"\"\"\n        if context_uri is not None and uris is not None:\n            logger.warning(\"Specify either context uri or uris, not both\")\n            return\n        if uris is not None and not isinstance(uris, list):\n            logger.warning(\"URIs must be a list\")\n            return\n        data = {}\n        if context_uri is not None:\n            data[\"context_uri\"] = context_uri\n        if uris is not None:\n            data[\"uris\"] = uris\n        if offset is not None:\n            data[\"offset\"] = offset\n        if position_ms is not None:\n            data[\"position_ms\"] = position_ms\n        return self._put(\n            self._append_device_id(\"me/player/play\", device_id), payload=data\n        )\n\n    def pause_playback(self, device_id=None):\n        \"\"\" Pause user's playback.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._put(self._append_device_id(\"me/player/pause\", device_id))\n\n    def next_track(self, device_id=None):\n        \"\"\" Skip user's playback to next track.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._post(self._append_device_id(\"me/player/next\", device_id))\n\n    def previous_track(self, device_id=None):\n        \"\"\" Skip user's playback to previous track.\n\n            Parameters:\n                - device_id - device target for playback\n        \"\"\"\n        return self._post(\n            self._append_device_id(\"me/player/previous\", device_id)\n        )\n\n    def seek_track(self, position_ms, device_id=None):\n        \"\"\" Seek to position in current track.\n\n            Parameters:\n                - position_ms - position in milliseconds to seek to\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(position_ms, int):\n            logger.warning(\"Position_ms must be an integer\")\n            return\n        return self._put(\n            self._append_device_id(\n                \"me/player/seek?position_ms=%s\" % position_ms, device_id\n            )\n        )\n\n    def repeat(self, state, device_id=None):\n        \"\"\" Set repeat mode for playback.\n\n            Parameters:\n                - state - `track`, `context`, or `off`\n                - device_id - device target for playback\n        \"\"\"\n        if state not in [\"track\", \"context\", \"off\"]:\n            logger.warning(\"Invalid state\")\n            return\n        self._put(\n            self._append_device_id(\n                \"me/player/repeat?state=%s\" % state, device_id\n            )\n        )\n\n    def volume(self, volume_percent, device_id=None):\n        \"\"\" Set playback volume.\n\n            Parameters:\n                - volume_percent - volume between 0 and 100\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(volume_percent, int):\n            logger.warning(\"Volume must be an integer\")\n            return\n        if volume_percent < 0 or volume_percent > 100:\n            logger.warning(\"Volume must be between 0 and 100, inclusive\")\n            return\n        self._put(\n            self._append_device_id(\n                \"me/player/volume?volume_percent=%s\" % volume_percent,\n                device_id,\n            )\n        )\n\n    def shuffle(self, state, device_id=None):\n        \"\"\" Toggle playback shuffling.\n\n            Parameters:\n                - state - true or false\n                - device_id - device target for playback\n        \"\"\"\n        if not isinstance(state, bool):\n            logger.warning(\"state must be a boolean\")\n            return\n        state = str(state).lower()\n        self._put(\n            self._append_device_id(\n                \"me/player/shuffle?state=%s\" % state, device_id\n            )\n        )\n\n    def queue(self):\n        \"\"\" Gets the current user's queue \"\"\"\n        return self._get(\"me/player/queue\")\n\n    def add_to_queue(self, uri, device_id=None):\n        \"\"\" Adds a song to the end of a user's queue\n\n            If device A is currently playing music and you try to add to the queue\n            and pass in the id for device B, you will get a\n            'Player command failed: Restriction violated' error\n            I therefore recommend leaving device_id as None so that the active device is targeted\n\n            :param uri: song uri, id, or url\n            :param device_id:\n                the id of a Spotify device.\n                If None, then the active device is used.\n\n        \"\"\"\n\n        uri = self._get_uri(\"track\", uri)\n\n        endpoint = \"me/player/queue?uri=%s\" % uri\n\n        if device_id is not None:\n            endpoint += \"&device_id=%s\" % device_id\n\n        return self._post(endpoint)\n\n    def available_markets(self):\n        \"\"\" Get the list of markets where Spotify is available.\n            Returns a list of the countries in which Spotify is available, identified by their\n            ISO 3166-1 alpha-2 country code with additional country codes for special territories.\n        \"\"\"\n        return self._get(\"markets\")\n\n    def _append_device_id(self, path, device_id):\n        \"\"\" Append device ID to API path.\n\n            Parameters:\n                - device_id - device id to append\n        \"\"\"\n        if device_id:\n            if \"?\" in path:\n                path += \"&device_id=%s\" % device_id\n            else:\n                path += \"?device_id=%s\" % device_id\n        return path\n\n    def _get_id(self, type, id):\n        fields = id.split(\":\")\n        if len(fields) >= 3:\n            if type != fields[-2]:\n                logger.warning('Expected id of type %s but found type %s %s',\n                               type, fields[-2], id)\n            return fields[-1].split(\"?\")[0]\n        fields = id.split(\"/\")\n        if len(fields) >= 3:\n            itype = fields[-2]\n            if type != itype:\n                logger.warning('Expected id of type %s but found type %s %s',\n                               type, itype, id)\n            return fields[-1].split(\"?\")[0]\n        return id\n\n    def _get_uri(self, type, id):\n        if self._is_uri(id):\n            return id\n        else:\n            return \"spotify:\" + type + \":\" + self._get_id(type, id)\n\n    def _is_uri(self, uri):\n        return uri.startswith(\"spotify:\") and len(uri.split(':')) == 3\n\n    def _search_multiple_markets(self, q, limit, offset, type, markets, total):\n        if total and limit > total:\n            limit = total\n            warnings.warn(\n                \"limit was auto-adjusted to equal {} as it must not be higher than total\".format(\n                    total),\n                UserWarning,\n            )\n\n        results = {}\n        first_type = type.split(\",\")[0] + 's'\n        count = 0\n\n        for country in markets:\n            result = self._get(\n                \"search\", q=q, limit=limit, offset=offset, type=type, market=country\n            )\n            results[country] = result\n\n            count += len(result[first_type]['items'])\n            if total and count >= total:\n                break\n            if total and limit > total - count:\n                # when approaching `total` results, adjust `limit` to not request more\n                # items than needed\n                limit = total - count\n\n        return results\n", "patch": "@@ -6,6 +6,7 @@\n \n import json\n import logging\n+import re\n import warnings\n \n import requests\n@@ -96,6 +97,29 @@ class Spotify(object):\n         \"US\",\n         \"UY\"]\n \n+    # Spotify URI scheme defined in [1], and the ID format as base-62 in [2].\n+    #\n+    # Unfortunately the IANA specification is out of date and doesn't include the new types\n+    # show and episode. Additionally, for the user URI, it does not specify which characters\n+    # are valid for usernames, so the assumption is alphanumeric which coincidentially are also\n+    # the same ones base-62 uses.\n+    # In limited manual exploration this seems to hold true, as newly accounts are assigned an\n+    # identifier that looks like the base-62 of all other IDs, but some older accounts only have\n+    # numbers and even older ones seemed to have been allowed to freely pick this name.\n+    #\n+    # [1] https://www.iana.org/assignments/uri-schemes/prov/spotify\n+    # [2] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n+    _regex_spotify_uri = r'^spotify:(?P<type>track|artist|album|playlist|show|episode|user):(?P<id>[0-9A-Za-z]+)$'\n+\n+    # Spotify URLs are defined at [1]. The assumption is made that they are all\n+    # pointing to open.spotify.com, so a regex is used to parse them as well,\n+    # instead of a more complex URL parsing function.\n+    #\n+    # [1] https://developer.spotify.com/documentation/web-api/#spotify-uris-and-ids\n+    _regex_spotify_url = r'^(http[s]?:\\/\\/)?open.spotify.com\\/(?P<type>track|artist|album|playlist|show|episode|user)\\/(?P<id>[0-9A-Za-z]+)(\\?.*)?$'\n+\n+    _regex_base62 = r'^[0-9A-Za-z]+$'\n+\n     def __init__(\n         self,\n         auth=None,\n@@ -1940,20 +1964,28 @@ def _append_device_id(self, path, device_id):\n         return path\n \n     def _get_id(self, type, id):\n-        fields = id.split(\":\")\n-        if len(fields) >= 3:\n-            if type != fields[-2]:\n-                logger.warning('Expected id of type %s but found type %s %s',\n-                               type, fields[-2], id)\n-            return fields[-1].split(\"?\")[0]\n-        fields = id.split(\"/\")\n-        if len(fields) >= 3:\n-            itype = fields[-2]\n-            if type != itype:\n-                logger.warning('Expected id of type %s but found type %s %s',\n-                               type, itype, id)\n-            return fields[-1].split(\"?\")[0]\n-        return id\n+        uri_match = re.search(Spotify._regex_spotify_uri, id)\n+        if uri_match is not None:\n+            uri_match_groups = uri_match.groupdict()\n+            if uri_match_groups['type'] != type:\n+                # TODO change to a ValueError in v3\n+                raise SpotifyException(400, -1, \"Unexpected Spotify URI type.\")\n+            return uri_match_groups['id']\n+\n+        url_match = re.search(Spotify._regex_spotify_url, id)\n+        if url_match is not None:\n+            url_match_groups = url_match.groupdict()\n+            if url_match_groups['type'] != type:\n+                raise SpotifyException(400, -1, \"Unexpected Spotify URL type.\")\n+            # TODO change to a ValueError in v3\n+            return url_match_groups['id']\n+\n+        # Raw identifiers might be passed, ensure they are also base-62\n+        if re.search(Spotify._regex_base62, id) is not None:\n+            return id\n+\n+        # TODO change to a ValueError in v3\n+        raise SpotifyException(400, -1, \"Unsupported URL / URI.\")\n \n     def _get_uri(self, type, id):\n         if self._is_uri(id):\n@@ -1962,7 +1994,7 @@ def _get_uri(self, type, id):\n             return \"spotify:\" + type + \":\" + self._get_id(type, id)\n \n     def _is_uri(self, uri):\n-        return uri.startswith(\"spotify:\") and len(uri.split(':')) == 3\n+        return re.search(Spotify._regex_spotify_uri, uri) is not None\n \n     def _search_multiple_markets(self, q, limit, offset, type, markets, total):\n         if total and limit > total:", "file_path": "files/2023_1/632", "file_language": "py", "file_name": "spotipy/client.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
