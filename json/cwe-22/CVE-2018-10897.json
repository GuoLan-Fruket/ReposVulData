{"index": 3067, "cve_id": "CVE-2018-10897", "cwe_id": ["CWE-59", "CWE-22"], "cve_language": "Python", "cve_description": "A directory traversal issue was found in reposync, a part of yum-utils, where reposync fails to sanitize paths in remote repository configuration files. If an attacker controls a repository, they may be able to copy files outside of the destination directory on the targeted system via path traversal. If reposync is running with heightened privileges on a targeted system, this flaw could potentially result in system compromise via the overwriting of critical system files. Version 1.1.31 and older are believed to be affected.", "cvss": "8.1", "publish_date": "August 1, 2018", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "7554c0133eb830a71dc01846037cc047d0acbc2c", "commit_message": "reposync: refactor: sanitize remote_path usage\n\nFor better readability (remote_path == relativepath).", "commit_date": "2018-07-19T13:21:25Z", "project": "rpm-software-management/yum-utils", "url": "https://api.github.com/repos/rpm-software-management/yum-utils/commits/7554c0133eb830a71dc01846037cc047d0acbc2c", "html_url": "https://github.com/rpm-software-management/yum-utils/commit/7554c0133eb830a71dc01846037cc047d0acbc2c", "windows_before": [{"commit_id": "1943805f247e4c292d36089d02bd06c6e791bb11", "commit_date": "Thu Apr 26 08:25:35 2018 -0700", "commit_message": "Remove plugins/pkgtorrent/LICENSE missed in commit 59d1f26", "files_name": ["plugins/pkgtorrent/LICENSE"]}, {"commit_id": "0585dfce81c3c75d866d1223c079f7f0fef88244", "commit_date": "Wed Apr 18 17:44:09 2018 -0700", "commit_message": "Ship a disabled configuration file by default", "files_name": ["plugins/pkgtorrent/client/yum-torrent.conf"]}, {"commit_id": "59d1f268793f58bc4ace2f99339a1f0b7740d1a6", "commit_date": "Fri Mar 30 13:47:18 2018 -0700", "commit_message": "License fixes", "files_name": ["plugins/pkgtorrent/PATENTS", "plugins/pkgtorrent/README.md", "plugins/pkgtorrent/client/yum-torrent.py", "plugins/pkgtorrent/server/pkgtorrent-service.py"]}, {"commit_id": "1d40f029cc2567001ac02a8d03f44f4c1a408dbe", "commit_date": "Wed Jan 31 13:37:02 2018 -0800", "commit_message": "Address comments by @dmnks", "files_name": ["docs/pkgtorrent-service.8", "plugins/pkgtorrent/README.md", "plugins/pkgtorrent/server/pkgtorrent-service.conf", "plugins/pkgtorrent/server/pkgtorrent-service.py", "yum-utils.spec"]}, {"commit_id": "57b73c377cd5bd75aa0873ba87418ac9020925a8", "commit_date": "Mon Aug 29 14:15:30 2016 -0700", "commit_message": "Introduce pkgtorrent to yum-utils", "files_name": ["README", "docs/pkgtorrent-service.8", "docs/pkgtorrent-service.conf.5", "docs/yum-torrent.1", "docs/yum-torrent.conf.5", "plugins/pkgtorrent/LICENSE", "plugins/pkgtorrent/PATENTS", "plugins/pkgtorrent/README.md", "plugins/pkgtorrent/client/yum-torrent.conf", "plugins/pkgtorrent/client/yum-torrent.py", "plugins/pkgtorrent/server/pkgtorrent-service.conf", "plugins/pkgtorrent/server/pkgtorrent-service.py", "yum-utils.spec"]}, {"commit_id": "1814b652ff6b2a014c49e650d1d626a54ea7acc3", "commit_date": "Tue Nov 21 16:20:16 2017 +0100", "commit_message": "Merge pull request #35 from dmnks/bz1127783", "files_name": ["eed646cdac71afe76f249996a2a90e10f6ae9b43 - Fri Nov 3 13:14:51 2017 +0100 : refactor: transaction-actions: remove matched", "plugins/post-transaction-actions/post-transaction-actions.py", "plugins/pre-transaction-actions/pre-transaction-actions.py"]}, {"commit_id": "0ec965aa927f60a19ef6b0a57b583a1e6042c93a", "commit_date": "Fri Nov 3 12:53:01 2017 +0100", "commit_message": "transaction-actions: fix file glob matching. BZ 1127783", "files_name": ["plugins/post-transaction-actions/post-transaction-actions.py", "plugins/post-transaction-actions/sample.action", "plugins/pre-transaction-actions/pre-transaction-actions.py", "plugins/pre-transaction-actions/sample.action"]}, {"commit_id": "2147df31f5b6cabbb6a0358a1ce30959e667e2d8", "commit_date": "Mon Oct 30 13:00:18 2017 +0100", "commit_message": "Merge pull request #30 from dmnks/bz1349433", "files_name": ["39413fea8eaffeed75d4026ce0585f74510dc283 - Mon Oct 30 12:58:48 2017 +0100 : Merge pull request #31 from dmnks/bz1333353", "aea55954107041cb29aff6b21383d0c6db2d5aec - Mon Oct 30 12:57:25 2017 +0100 : Merge pull request #32 from dmnks/bz1437636", "6b875f1789ab60f1b3cd8bbd7d93549cbfadd2f2 - Mon Oct 30 12:56:06 2017 +0100 : Merge pull request #33 from dmnks/bz1470647", "c39fc92e6482a3d42f7a74ab46af4f44b2650f62 - Fri Oct 27 16:12:05 2017 +0200 : Add pre-transaction-actions plugin. BZ 1470647", "plugins/pre-transaction-actions/pre-transaction-actions.conf", "plugins/pre-transaction-actions/pre-transaction-actions.py", "plugins/pre-transaction-actions/sample.action", "yum-utils.spec"]}, {"commit_id": "aa41c15a3a5214d5b423989c5077ac5567f236f5", "commit_date": "Tue Oct 24 10:47:01 2017 +0200", "commit_message": "yum-builddep: add --define option. BZ 1437636", "files_name": ["docs/yum-builddep.1", "yum-builddep.py"]}, {"commit_id": "a488eb302bc9d9609e3f95490ec14c8cf737b87d", "commit_date": "Tue Oct 24 11:10:46 2017 +0200", "commit_message": "docs: yum-builddep: add --target to man", "files_name": ["docs/yum-builddep.1"]}, {"commit_id": "56c7eacd9d0ad9237d05e1393c12d5059edb2c7a", "commit_date": "Mon Oct 23 15:33:13 2017 +0200", "commit_message": "verifytree: fix handling of missing comps. BZ 1333353", "files_name": ["verifytree.py"]}, {"commit_id": "b586ff502946fbd3271db8370cb546f696c51cfd", "commit_date": "Fri Oct 20 19:47:36 2017 +0200", "commit_message": "verifytree: handle no @core group gracefully. BZ 1349433", "files_name": ["verifytree.py"]}, {"commit_id": "febdb1df6c1eb537826ae6f76cdadecbe23447d8", "commit_date": "Fri Oct 20 14:01:37 2017 +0200", "commit_message": "yumdownloader: fix crash on broken srpm metadata.", "files_name": ["yumdownloader.py"]}, {"commit_id": "c8ba789ff4544b8b84e4cbcf3e3a5753532f623c", "commit_date": "Fri Oct 20 13:57:35 2017 +0200", "commit_message": "Merge pull request #25 from dmnks/bz1445751", "files_name": ["f6f203252d06820ba452f380c76f637e2e73ff5b - Fri Oct 20 13:57:03 2017 +0200 : Merge pull request #20 from dmnks/bz1428210", "b7377828321daa991166e8b1b8198198e71a9bc5 - Fri Oct 20 13:56:16 2017 +0200 : Merge pull request #28 from dmnks/bz1455318", "4594bbc623b68bea6522047fb6267069c8ad94c8 - Wed Oct 11 20:23:06 2017 +0200 : package-cleanup: update man page", "docs/package-cleanup.1", "package-cleanup.py"]}, {"commit_id": "27784822a342debd3ecfa04686a35f2e7e576023", "commit_date": "Wed Oct 11 19:26:38 2017 +0200", "commit_message": "package-cleanup: don't remove required dupes. BZ 1455318", "files_name": ["package-cleanup.py"]}, {"commit_id": "61232e9f66cc64fffa8517678b6cf224d44b02ef", "commit_date": "Wed Jul 12 16:27:53 2017 +0200", "commit_message": "yum-debug-dump: improve repo failure handling. BZ 1445751", "files_name": ["yum-debug-dump.py"]}, {"commit_id": "fb8f8b33d847d4816f97342b23a89b58368bb73a", "commit_date": "Wed Jun 21 17:03:06 2017 -0300", "commit_message": "Fix warning when gpgcheck return code is >2", "files_name": ["reposync.py"]}, {"commit_id": "f62ca0e78ff5b087c0cb49d858e040a5c5284eeb", "commit_date": "Mon Jun 5 20:29:10 2017 +0200", "commit_message": "fastestmirror: move the logic before MD retrieval. BZ 1428210", "files_name": ["plugins/fastestmirror/fastestmirror.py"]}, {"commit_id": "094a57bd9a641d6acc0636c9b31f7c39be720f2f", "commit_date": "Mon Mar 6 13:33:11 2017 +0100", "commit_message": "Merge pull request #19 from dmnks/bz1403015", "files_name": ["3379beb97c78493f60b287ef274c2c8d30e925b1 - Mon Feb 27 17:43:50 2017 +0100 : yum-config-manager: improve docs. BZ 1403015", "docs/yum-config-manager.1", "yum-config-manager.py"]}, {"commit_id": "4cd3ad8d2a6b4771338b8c58a232060a3e64114d", "commit_date": "Fri Feb 24 18:26:31 2017 +0100", "commit_message": "yum-config-manager: only select exact matches from --setopt. BZ 1403015", "files_name": ["yum-config-manager.py"]}, {"commit_id": "3db7d31e1e76f04c8f59a7fb8402d3964d42e9d3", "commit_date": "Mon Feb 27 17:16:33 2017 +0400", "commit_message": "typo in docs", "files_name": ["plugins/priorities/README"]}, {"commit_id": "a1df95280deed133e5ba210e303f35e7676857c3", "commit_date": "Wed Feb 22 12:23:42 2017 +0100", "commit_message": "Merge pull request #17 from dmnks/bz1406891", "files_name": ["7a94cf4434107bfcb32e60420af2106b993c7381 - Thu Feb 16 17:47:53 2017 +0100 : docs: verify: fix wording. BZ 1406891", "docs/yum-verify.1"]}, {"commit_id": "4a66681d1a27eb32480e002e888c9b5a925dbeff", "commit_date": "Thu Feb 2 13:24:53 2017 +0100", "commit_message": "Merge pull request #5 from jaymzh/removenewdupes", "files_name": ["94ccb480c8356559b16448b1a7dee0784dc4dd61 - Fri Dec 9 11:52:54 2016 +0300 : add to yum-builddep support of .nosrc.rpm", "yum-builddep.py"]}, {"commit_id": "f62551849e0f8c5cc3151d78af0975fad831e8ed", "commit_date": "Tue Oct 18 10:31:11 2016 +0200", "commit_message": "yum-plugin-verify: set exit status to 1 in case of problems.", "files_name": ["plugins/verify/verify.py"]}, {"commit_id": "866d85e0ecc57cba1866c76d9d080a20b0cf3ccd", "commit_date": "Thu Aug 4 12:13:03 2016 +0200", "commit_message": "Merge pull request #13 from dmnks/bz1192946-v2", "files_name": ["932194fbafe72d78fea2853a8025721c62765003 - Thu Aug 4 12:09:53 2016 +0200 : Fix a typo in docs", "docs/needs-restarting.1"]}, {"commit_id": "5e66f41e303146381158d18da226e4f9af0ac401", "commit_date": "Wed Aug 3 16:45:32 2016 +0200", "commit_message": "Merge pull request #12 from dmnks/bz1192946-v2", "files_name": ["feb458ecfa22d9575f6aad50d2b7b589e43aa7bd - Tue Jul 26 15:51:16 2016 +0200 : needs-restarting: simplify the reboothint option", "docs/needs-restarting.1", "needs-restarting.py"]}, {"commit_id": "306d82fb98911f3ce89f744ac2205c81024dea96", "commit_date": "Tue Jul 26 13:51:15 2016 +0200", "commit_message": "Revert \"needs-restarting: add option for reboot hint. BZ 1192946\"", "files_name": ["docs/needs-restarting.1", "needs-restarting.py"]}, {"commit_id": "a99d7e0f95fccb4912d979677c5d7691e9d2274c", "commit_date": "Wed Jul 20 14:57:23 2016 +0200", "commit_message": "Merge pull request #11 from dmnks/bz1296282", "files_name": ["2705bdf9f741ddefd908eb16bf99001347378551 - Fri Jul 8 18:56:33 2016 +0200 : verifytree: don't fail with versioned docdirs", "verifytree.py"]}, {"commit_id": "e721c52ab8fd9a239817471f3e0c2f939d08459e", "commit_date": "Wed Jun 29 15:11:00 2016 +0200", "commit_message": "Merge pull request #10 from dmnks/bz1296282", "files_name": ["2c2b824cb827b14b4f6f994dc3dfc5e4ae31c4e9 - Wed Jun 22 16:47:21 2016 +0200 : verifytree: use local comps schema. BZ 1296282", "verifytree.py"]}, {"commit_id": "04f43637e723dc8d4fd94b3ba73fc27469f76237", "commit_date": "Wed Jun 22 16:45:17 2016 +0200", "commit_message": "Revert \"verifytree: use current url of comps schema. BZ 1296282\"", "files_name": ["verifytree.py"]}, {"commit_id": "8048d25bf3225b8ddd7d0a90b050bce2cc716e2a", "commit_date": "Tue Jun 21 14:24:12 2016 +0200", "commit_message": "debuginfo-install: also respect provides when testing for installonly.", "files_name": ["debuginfo-install.py"]}, {"commit_id": "337a50ad4552a8bfc9f9dfdff69ce59fe872c18f", "commit_date": "Tue Jun 21 13:36:45 2016 +0200", "commit_message": "Merge pull request #7 from dmnks/bz1335587", "files_name": ["b7271d67c1e425fa5494e1642273d6d54a8372b6 - Tue May 17 15:51:53 2016 +0200 : needs-restarting: add option to list services. BZ 1335587", "docs/needs-restarting.1", "needs-restarting.py"]}, {"commit_id": "331f6577b710c6f81849d554dd90850cc73b93b1", "commit_date": "Tue May 24 15:02:22 2016 +0200", "commit_message": "Merge pull request #8 from dmnks/bz1192946", "files_name": ["03fb4815b216b512878575ea4b7f1a2ac36cc301 - Thu May 19 13:15:20 2016 +0200 : needs-restarting: add option for reboot hint. BZ 1192946", "docs/needs-restarting.1", "needs-restarting.py"]}, {"commit_id": "84988d6ae0e3d6dad07cde3701a69f7717cf8962", "commit_date": "Fri May 13 12:19:33 2016 +0200", "commit_message": "yum-config-manager: document syntax for enabling/disabling all repos.", "files_name": ["docs/yum-config-manager.1"]}, {"commit_id": "76ecdc4733f9718a64f580d367658f6029fdde97", "commit_date": "Mon May 2 14:16:06 2016 -0400", "commit_message": "Merge pull request #6 from dmnks/bz1296282", "files_name": ["6148eb6bb60d4649a765eadad66f5098cb212973 - Mon May 2 16:00:12 2016 +0200 : verifytree: use current url of comps schema. BZ 1296282", "verifytree.py"]}, {"commit_id": "c08a67e9923ea9c095d62ccb931c0b8a589e4b1e", "commit_date": "Tue Mar 1 18:08:32 2016 +0100", "commit_message": "yum-builddep: mention the workaround for arched srpms in the man page. BZ#1156057", "files_name": ["docs/yum-builddep.1"]}, {"commit_id": "2f1605f65e6bc24d6a2515b99f1486085f281a49", "commit_date": "Tue Mar 1 16:18:39 2016 +0100", "commit_message": "debuginfo-install: install debuginfo only for the latest installed version of installonly package. BZ#1293707", "files_name": ["debuginfo-install.py"]}, {"commit_id": "f84a2dbcc28312105246fac51771481640759da5", "commit_date": "Thu Jul 2 11:40:55 2015 -0700", "commit_message": "Add option to remove newest dupes instead of oldest dupes", "files_name": ["package-cleanup.py"]}, {"commit_id": "834a4ff4f2752631252cff4e3b2ba87bee62965b", "commit_date": "Thu Dec 10 16:24:18 2015 +0100", "commit_message": "yum-plugin-priorities: get all obsoletes, not just the newest. BZ#1269414", "files_name": ["plugins/priorities/priorities.py"]}, {"commit_id": "28782e5901234a4070bf3a0a7e5bc2c04fe0cff5", "commit_date": "Thu Oct 29 21:38:14 2015 -0400", "commit_message": "Merge pull request #3 from tyll/wildcard", "files_name": ["94e7e28cdf9efbf386cae2c6b6ce340f6a2c2fe5 - Thu Oct 29 21:12:20 2015 +0100 : Support wildcards in repo specification", "repoclosure.py"]}, {"commit_id": "de57723e5ca85a35fe7ad870278f456d95a398af", "commit_date": "Thu Oct 29 21:08:13 2015 +0100", "commit_message": "Remove trailing whitespace from repoclosure", "files_name": ["repoclosure.py"]}, {"commit_id": "d03fce57c1fa3f9dff6fdd9867cbcaf66df9f841", "commit_date": "Fri Oct 9 15:16:33 2015 +0200", "commit_message": "ovl plugin: run at init_hook stage", "files_name": ["plugins/ovl/ovl.py"]}, {"commit_id": "2ad45e5c1763362d8f64f435f83b55d2d38319a8", "commit_date": "Fri Sep 4 17:12:39 2015 +0200", "commit_message": "yum-ovl: add manpage to the spec file", "files_name": ["docs/Makefile", "yum-utils.spec"]}, {"commit_id": "2173e73e8169556a0bffc49864adf9ddc06c80d5", "commit_date": "Fri Sep 4 16:47:12 2015 +0200", "commit_message": "Merge pull request #2 from shaded-enmity/ovl-manpage", "files_name": ["3980742eb6477c5bd5366222fb033cfc5c95d260 - Fri Sep 4 10:38:32 2015 +0200 : Added manpage description and reference to rpmdb", "docs/yum-ovl.1"]}, {"commit_id": "6f43c2e1aff0ee0746685778544f7b05d2ef78a1", "commit_date": "Thu Sep 3 18:09:58 2015 +0200", "commit_message": "Add manpage, remove file-system check", "files_name": ["docs/yum-ovl.1", "plugins/ovl/ovl.py"]}, {"commit_id": "49e05a7f5bb7fe54e5cf072940677afae7949e1e", "commit_date": "Thu Sep 3 17:40:50 2015 +0200", "commit_message": "Merge branch 'master' of github.com:rpm-software-management/yum-utils", "files_name": ["11e4a7386e2e351e0ff5f8d89663eb66220a6100 - Tue Aug 4 12:18:49 2015 +0200 : ovl plugin: remove redundant debuglevel check", "plugins/ovl/ovl.py"]}, {"commit_id": "5cd70d30bcdbd544e086a1aa3e7522c89bbd893a", "commit_date": "Tue Aug 4 12:00:37 2015 +0200", "commit_message": "ovl plugin: change copy-up strategy, execute when root fs is mounted OverlayFS, add logging. Patch by Pavel Odvody.", "files_name": ["plugins/ovl/ovl.py"]}], "windows_after": [{"commit_id": "6a8de061f8fdc885e74ebe8c94625bf53643b71c", "commit_date": "Thu Jul 19 15:17:37 2018 +0200", "commit_message": "reposync: prevent path traversal. BZ 1552328", "files_name": ["docs/reposync.1", "reposync.py"]}, {"commit_id": "a792d21b55337add2327d1c7d6d000862c717eef", "commit_date": "Tue Jul 24 09:48:33 2018 +0200", "commit_message": "Merge pull request #43 from dmnks/bz1552328", "files_name": ["dffc13e99ccfc7a4c113b64a573613cde97922bc - Fri Aug 3 11:51:14 2018 +0200 : bencode: add original doc text", "plugins/pkgtorrent/server/pkgtorrent-service.py"]}, {"commit_id": "dfbeb83afeea4119fb3ed04d469d299ae414e39f", "commit_date": "Fri Aug 3 11:57:12 2018 +0200", "commit_message": "Merge branch 'malmond77-pkgtorrent'", "files_name": ["c01c1bab3b3530e04d9cb13bcf03d6f1a95a7f33 - Fri Jun 22 22:39:30 2018 +0200 : repotrack: add --repofrompath option. BZ 1506205", "docs/repotrack.1", "repotrack.py"]}, {"commit_id": "bcbf9557078fecb1aa5497d4f04699cf5bb70dc7", "commit_date": "Tue Mar 26 22:10:24 2019 +0100", "commit_message": "Merge pull request #42 from dmnks/bz1506205", "files_name": ["1a8322bec4710c32b2b7c3eedbd739206c4f07be - Mon Apr 1 12:32:49 2019 +0200 : Merge pull request #15 from Frodox/bz-1298632", "17ebbf6247116100612fe588238f1c31258c6197 - Tue Aug 13 09:05:31 2019 +0200 : Merge pull request #21 from phess/master", "12dc3da81c8b200fbac15e8fd70d777ff4bb57dc - Mon Nov 25 09:59:23 2019 +0100 : Merge pull request #18 from Frodox/patch-1", "6b78b2fb43aa1df99e8696e6ecd99ecbc5351785 - Wed Feb 12 13:30:18 2020 +0100 : Add deprecation notice", "README"]}, {"commit_id": "75019dd26cc93e2fb47932f81e472ab9fcf72e6e", "commit_date": "Mon May 28 16:49:10 2018 +0200", "commit_message": "docs: fix versionlock", "files_name": ["docs/yum-versionlock.1"]}, {"commit_id": "119b3e8c44d022a799ee3ba023f467791c86d9b0", "commit_date": "Mon May 28 16:55:50 2018 +0200", "commit_message": "versionlock: add hint and \"status\" subcommand. BZ 1497351", "files_name": ["docs/yum-versionlock.1", "docs/yum-versionlock.conf.5", "plugins/versionlock/versionlock.conf", "plugins/versionlock/versionlock.py"]}, {"commit_id": "a7f87793bb4b4a46deee23bfda4e21ebaedd4f80", "commit_date": "Wed Feb 12 15:51:39 2020 +0100", "commit_message": "Merge pull request #41 from dmnks/bz1497351", "files_name": ["2b3ca070854986b7101a8abc3afec5b5c263a1a3 - Fri Jun 22 23:59:03 2018 +0200 : yum-config-manager: add-repo: fix dummy URL. BZ 1493489", "yum-config-manager.py"]}, {"commit_id": "46ae0cbbd7598ce926975aae4ab98de4ec3f0443", "commit_date": "Fri Aug 17 13:17:15 2018 +0200", "commit_message": "yum-config-manager: add-repo: return 1 on failure", "files_name": ["yum-config-manager.py"]}, {"commit_id": "48d0ed1e7deebd5862482a7bb1c331a92122d5cc", "commit_date": "Fri Aug 17 17:45:48 2018 +0200", "commit_message": "yum-config-manager: add-repo: don't create empty files", "files_name": ["yum-config-manager.py"]}, {"commit_id": "1d830f38bee812209d2f22bd9c2a18c53547d57a", "commit_date": "Fri Aug 17 19:36:30 2018 +0200", "commit_message": "yum-config-manager: add-repo: validate URL", "files_name": ["yum-config-manager.py"]}, {"commit_id": "6e3d4bde1e5616f10ca6f893300baaa329c70935", "commit_date": "Wed Feb 12 15:53:56 2020 +0100", "commit_message": "Merge pull request #44 from dmnks/bz1493489", "files_name": ["9f50c4fcb982064aefc9af1a5a8968332d967b6c - Tue Mar 26 21:03:30 2019 +0100 : Handle RepoStorage.retrieveAllMD() exceptions. BZ 1476701", "reposync.py", "repotrack.py"]}, {"commit_id": "6b9b0b565d16a4bec0bd70604c3607d94cf5e741", "commit_date": "Wed Feb 12 15:55:21 2020 +0100", "commit_message": "Merge pull request #54 from dmnks/bz1476701", "files_name": ["acdcdd33c1af3f8113c9d2b9bdb33ccc620a7833 - Mon Sep 9 15:05:27 2019 +0200 : needs-restarting: clarify exit code. BZ 1630197", "docs/needs-restarting.1", "needs-restarting.py"]}, {"commit_id": "a2add9c8a7c27c4b32ea14f47d1c913e599fc70a", "commit_date": "Wed Feb 12 15:56:45 2020 +0100", "commit_message": "Merge pull request #56 from dmnks/bz1630197", "files_name": ["50a7ed61378a33e3074a46dc2e3d9afbc3c826d6 - Tue Sep 10 14:25:49 2019 +0200 : repotrack: fix --repofrompath. BZ 1659588", "repotrack.py"]}, {"commit_id": "919257338e9018a5ddd37fbd85bbb0bd28193007", "commit_date": "Wed Feb 12 15:59:27 2020 +0100", "commit_message": "Merge pull request #57 from dmnks/bz1659588", "files_name": ["793e92289f0f070fad10f4e401e4492559df022a - Tue Sep 10 18:48:19 2019 +0200 : repotrack: copy local packages. BZ 1463723", "repotrack.py"]}, {"commit_id": "32ad85e0b1bbf9ef08b5e38254b5d3bdb6afe1f7", "commit_date": "Wed Feb 12 16:00:36 2020 +0100", "commit_message": "Merge pull request #58 from dmnks/bz1463723", "files_name": ["90bdf6ca23a953ad40ae811f1e4e377a725e7365 - Wed Mar 11 12:33:40 2020 +0100 : needs-restarting: add kernel-rt to REBOOTPKGS. BZ 1806060", "needs-restarting.py"]}, {"commit_id": "05db7ef501fc9d6698935bcc039c83c0761c3be2", "commit_date": "Wed Mar 11 15:20:30 2020 +0100", "commit_message": "Merge pull request #63 from dmnks/bz1806060", "files_name": []}], "parents": [{"commit_id_before": "1814b652ff6b2a014c49e650d1d626a54ea7acc3", "url_before": "https://api.github.com/repos/rpm-software-management/yum-utils/commits/1814b652ff6b2a014c49e650d1d626a54ea7acc3", "html_url_before": "https://github.com/rpm-software-management/yum-utils/commit/1814b652ff6b2a014c49e650d1d626a54ea7acc3"}], "details": [{"raw_url": "https://github.com/rpm-software-management/yum-utils/raw/7554c0133eb830a71dc01846037cc047d0acbc2c/reposync.py", "code": "#!/usr/bin/python -tt\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n# copyright 2006 Duke University\n# author seth vidal\n\n# sync all or the newest packages from a repo to the local path\n# TODO:\n#     have it print out list of changes\n#     make it work with mirrorlists (silly, really)\n#     man page/more useful docs\n#     deal nicely with a package changing but not changing names (ie: replacement)\n\n# criteria\n# if a package is not the same and smaller then reget it\n# if a package is not the same and larger, delete it and get it again\n# always replace metadata files if they're not the same.\n\n\n\n\n\nimport os\nimport sys\nimport shutil\nimport stat\n\nfrom optparse import OptionParser\nfrom urlparse import urljoin\n\nfrom yumutils.i18n import _\n\nimport yum\nimport yum.Errors\nfrom yum.packageSack import ListPackageSack\nimport rpmUtils.arch\nimport logging\nfrom urlgrabber.progress import TextMeter, TextMultiFileMeter\nimport urlgrabber\n\nclass RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts\n\ndef localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache\n\ndef parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)\n\n\ndef main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                rpmname = os.path.basename(pkg.remote_path)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.remote_path)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            pkg.localpath = os.path.join(local_repo_path, pkg.remote_path)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)\n\nif __name__ == \"__main__\":\n    main()\n", "code_before": "#!/usr/bin/python -tt\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n# copyright 2006 Duke University\n# author seth vidal\n\n# sync all or the newest packages from a repo to the local path\n# TODO:\n#     have it print out list of changes\n#     make it work with mirrorlists (silly, really)\n#     man page/more useful docs\n#     deal nicely with a package changing but not changing names (ie: replacement)\n\n# criteria\n# if a package is not the same and smaller then reget it\n# if a package is not the same and larger, delete it and get it again\n# always replace metadata files if they're not the same.\n\n\n\n\n\nimport os\nimport sys\nimport shutil\nimport stat\n\nfrom optparse import OptionParser\nfrom urlparse import urljoin\n\nfrom yumutils.i18n import _\n\nimport yum\nimport yum.Errors\nfrom yum.packageSack import ListPackageSack\nimport rpmUtils.arch\nimport logging\nfrom urlgrabber.progress import TextMeter, TextMultiFileMeter\nimport urlgrabber\n\nclass RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts\n\ndef localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache\n\ndef parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)\n\n\ndef main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                rpmname = os.path.basename(remote)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                local = local_repo_path + '/' + remote\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                local = os.path.join(local_repo_path, remote)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.relativepath)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            rpmfn = pkg.remote_path\n            pkg.localpath = os.path.join(local_repo_path, rpmfn)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)\n\nif __name__ == \"__main__\":\n    main()\n", "patch": "@@ -221,8 +221,7 @@ def main():\n \n             download_set = {}\n             for pkg in download_list:\n-                remote = pkg.returnSimple('relativepath')\n-                rpmname = os.path.basename(remote)\n+                rpmname = os.path.basename(pkg.remote_path)\n                 download_set[rpmname] = 1\n \n             for pkg in current_pkgs:\n@@ -269,8 +268,7 @@ def main():\n         remote_size = 0\n         if not opts.urls:\n             for pkg in download_list:\n-                remote = pkg.returnSimple('relativepath')\n-                local = local_repo_path + '/' + remote\n+                local = os.path.join(local_repo_path, pkg.remote_path)\n                 sz = int(pkg.returnSimple('packagesize'))\n                 if os.path.exists(local) and os.path.getsize(local) == sz:\n                     continue\n@@ -282,10 +280,9 @@ def main():\n         download_list.sort(key=lambda pkg: pkg.name)\n         if opts.urls:\n             for pkg in download_list:\n-                remote = pkg.returnSimple('relativepath')\n-                local = os.path.join(local_repo_path, remote)\n+                local = os.path.join(local_repo_path, pkg.remote_path)\n                 if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n-                    print urljoin(pkg.repo.urls[0], pkg.relativepath)\n+                    print urljoin(pkg.repo.urls[0], pkg.remote_path)\n             continue\n \n         # create dest dir\n@@ -294,8 +291,7 @@ def main():\n \n         # set localpaths\n         for pkg in download_list:\n-            rpmfn = pkg.remote_path\n-            pkg.localpath = os.path.join(local_repo_path, rpmfn)\n+            pkg.localpath = os.path.join(local_repo_path, pkg.remote_path)\n             pkg.repo.copy_local = True\n             pkg.repo.cache = 0\n             localdir = os.path.dirname(pkg.localpath)", "file_path": "files/2018_8\\73", "file_language": "py", "file_name": "reposync.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 1, "llm_check": 0, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": 0, "function_before": [{"function": "class RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts", "target": 0}, {"function": "def localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache", "target": 0}, {"function": "def parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)", "target": 0}, {"function": "def main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                rpmname = os.path.basename(remote)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                local = local_repo_path + '/' + remote\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                remote = pkg.returnSimple('relativepath')\n                local = os.path.join(local_repo_path, remote)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.relativepath)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            rpmfn = pkg.remote_path\n            pkg.localpath = os.path.join(local_repo_path, rpmfn)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)", "target": 0}], "function_after": [{"function": "class RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts", "target": 0}, {"function": "def localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache", "target": 0}, {"function": "def parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)", "target": 0}, {"function": "def main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                rpmname = os.path.basename(pkg.remote_path)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.remote_path)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            pkg.localpath = os.path.join(local_repo_path, pkg.remote_path)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)", "target": 0}]}], "outdated": 1, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
