{"index": 2466, "cve_id": "CVE-2017-14695", "cwe_id": ["CWE-22"], "cve_language": "Python", "cve_description": "Directory traversal vulnerability in minion id validation in SaltStack Salt before 2016.3.8, 2016.11.x before 2016.11.8, and 2017.7.x before 2017.7.2 allows remote minions with incorrect credentials to authenticate to a master via a crafted minion ID.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12791.", "cvss": "9.8", "publish_date": "October 24, 2017", "AV": "NETWORK", "AC": "NETWORK", "PR": "NONE", "UI": "NONE", "S": "UNCHANGED", "C": "HIGH", "I": "HIGH", "A": "HIGH", "commit_id": "80d90307b07b3703428ecbb7c8bb468e28a9ae6d", "commit_message": "Don't allow path separators in minion ID", "commit_date": "2017-10-03T22:19:25Z", "project": "saltstack/salt", "url": "https://api.github.com/repos/saltstack/salt/commits/80d90307b07b3703428ecbb7c8bb468e28a9ae6d", "html_url": "https://github.com/saltstack/salt/commit/80d90307b07b3703428ecbb7c8bb468e28a9ae6d", "windows_before": [{"commit_id": "5f8b5e1a0f23fe0f2be5b3c3e04199b57a53db5b", "commit_date": "Fri Aug 25 14:15:58 2017 -0500", "commit_message": "Do not allow IDs with null bytes in decoded payloads", "files_name": ["salt/crypt.py", "salt/transport/tcp.py", "salt/transport/zeromq.py"]}, {"commit_id": "478dd6e65af58a302f818d6cfb207da6b82d45d0", "commit_date": "Tue Oct 3 14:12:28 2017 -0700", "commit_message": "Merge branch 'develop' into unit-test-sdb", "files_name": ["3468e9c38f67ef14b9653f0dbc13f1903b76e93b - Tue Oct 3 16:55:36 2017 -0400 : Merge pull request #43866 from mahesh21/develop", "eb599307fcdb74ba1e7dac020cc344de0364f6e3 - Tue Oct 3 14:31:50 2017 -0600 : Merge branch 'develop' into develop", "916ce3d006d1f7395b647e8cb8e745b84c889f7d - Tue Oct 3 13:37:26 2017 -0600 : Show all nodes if no resource_group specified", "salt/cloud/clouds/azurearm.py"]}, {"commit_id": "6057cb036e7051142e4f73e5eb1af280ecd084ca", "commit_date": "Tue Oct 3 12:16:47 2017 -0700", "commit_message": "Merge branch 'develop' into unit-test-sdb", "files_name": ["484220e177cdeb4ed37d8b7e64982127ec8baff0 - Tue Oct 3 15:03:27 2017 -0400 : Merge pull request #43870 from basepi/azurefs", "820a542a8d633e1929c0413d7dcae9efae53157f - Tue Oct 3 15:01:26 2017 -0400 : Merge pull request #43882 from kunal-bajpai/fix_couchbase_returner", "bf44919d399665a43d6df9e0b295ca8619de8ace - Tue Oct 3 11:54:04 2017 -0700 : Merge branch 'develop' into develop", "e3b2857285b7585026ddc0153fd88d79939be93f - Tue Oct 3 11:50:29 2017 -0700 : Merge branch '2016.11' into 2016.11local", "ea6d5259b30460fd67e1e3659b86154f47e7529e - Tue Oct 3 10:52:14 2017 -0700 : Merge branch 'develop' into unit-test-sdb", "a0d08598bf245a3ea29600998c9e3d5633b3fc80 - Wed Oct 4 04:44:57 2017 +1100 : dco fix", "salt/modules/win_pkg.py"]}, {"commit_id": "9467899fc616f30291e55f873a33b72c50772043", "commit_date": "Wed Oct 4 04:34:18 2017 +1100", "commit_message": "Merge remote branch 'upstream/2016.11' into 2016.11_43417_Backport_and_Fixes", "files_name": ["6dc180fd0ed86f5f0a3920f2b97885c6b407c5ec - Wed Oct 4 04:32:57 2017 +1100 : doco fixes", "salt/modules/win_pkg.py"]}, {"commit_id": "87d676f08a5b0d0aed303dbef6d6e2f98ebc69ee", "commit_date": "Fri Sep 29 15:03:56 2017 -0400", "commit_message": "add -n with netstat so we don't resolve", "files_name": ["pkg/rpm/salt-minion"]}, {"commit_id": "a6483b1b39705401fc6143a7abab13d046bd55de", "commit_date": "Tue Oct 3 13:28:31 2017 -0400", "commit_message": "Merge pull request #43841 from bloomberg/update-netstat", "files_name": ["607f9b95d5370f3948668a4470cf1385d99b4e13 - Tue Oct 3 13:25:41 2017 -0400 : Merge branch 'develop' into develop", "88f2c0ef97ca4a30276b494e88e89f54e732c89e - Tue Oct 3 11:18:24 2017 -0600 : Add doc for new requirement", "salt/cloud/clouds/azurearm.py"]}, {"commit_id": "223a1eea83e7b8c8fc3dca96aa45af52235ae3a4", "commit_date": "Tue Oct 3 11:11:42 2017 -0600", "commit_message": "Fix object_to_dict in azure", "files_name": ["salt/utils/msazure.py"]}, {"commit_id": "046fcce6fbc8fa74fc3d3943ccdf8b13747a4c4b", "commit_date": "Tue Oct 3 09:56:51 2017 -0700", "commit_message": "Merge branch 'develop' into develop", "files_name": ["aebe76b6f8ba52caa570bd9a54b1b274e100bbaf - Tue Oct 3 12:56:44 2017 -0400 : Fix issue with using roster_defaults with flat or cloud rosters. fixes #43449 fixes #43643", "salt/roster/cloud.py", "salt/roster/flat.py"]}, {"commit_id": "2496a42ea43a86e394706b6c1073bc2d37745421", "commit_date": "Wed Oct 4 03:25:56 2017 +1100", "commit_message": "lint fix", "files_name": ["salt/modules/win_pkg.py"]}, {"commit_id": "4b882d4272b1954801c2389676883733f4121c52", "commit_date": "Tue Oct 3 12:25:07 2017 -0400", "commit_message": "Merge pull request #43869 from terminalmage/issue43522", "files_name": ["7d5a121265ef7c3765fb266911bf2490428357e4 - Tue Oct 3 10:22:18 2017 -0600 : Skip unit tests under Python3 until loader is fixed", "tests/unit/modules/test_vagrant.py"]}, {"commit_id": "b7dae5adddc9a33f4ee0bea7bd91748418e1f699", "commit_date": "Tue Oct 3 12:18:27 2017 -0400", "commit_message": "Bump with statements in one level", "files_name": ["tests/unit/modules/test_status.py"]}, {"commit_id": "6034b36bf6eff5ea6da02fbb9e08435653799c2b", "commit_date": "Tue Oct 3 09:07:35 2017 -0700", "commit_message": "Merge branch 'develop' into unit-test-sdb", "files_name": ["8c671fd0c16e3feb8698842c1d107e8f4ac75a37 - Tue Oct 3 10:07:28 2017 -0600 : Update SaltConf banner per Rhett's request", "doc/_themes/saltstack2/static/images/DOCBANNER.jpg"]}, {"commit_id": "667bd38a69a53e29f80a1a213c36b8f002c3582a", "commit_date": "Tue Oct 3 09:50:40 2017 -0600", "commit_message": "Merge branch 'develop' into fix_couchbase_returner", "files_name": ["cbf7acc44dab9282249270706e69f2ae1452eb65 - Tue Oct 3 09:39:18 2017 -0600 : Merge pull request #43834 from alexbleotu/tests-gh", "aeea10f2b9ef2244d9caf48b85bc8f17825365cd - Tue Oct 3 09:09:35 2017 -0600 : Merge branch 'develop' into azurefs", "73fd7d91cc611d95a7b61677306b36975914a0b9 - Tue Oct 3 18:48:03 2017 +0530 : Handle possible KeyError in couchbase.get_load", "salt/returners/couchbase_return.py"]}, {"commit_id": "dd0b3388cf2a1af0b32e61471de23c2e2d2209f1", "commit_date": "Tue Oct 3 14:00:51 2017 +0200", "commit_message": "Merge pull request #43868 from rallytime/bp-43847", "files_name": ["47af4ae38a272ad066ab2229c0d4447e8ec7d1ca - Tue Oct 3 13:59:28 2017 +0200 : Merge pull request #43871 from rallytime/update-release-notes", "d28aa20c74c00625c7bccf04479174bd48c96dff - Tue Oct 3 12:08:34 2017 +0200 : survey runner bugfix", "salt/runners/survey.py"]}, {"commit_id": "b6723030f86f149d56be1d458bc774faec5a9538", "commit_date": "Tue Oct 3 12:07:46 2017 +0200", "commit_message": "Merge branch 'develop' of https://github.com/netzmacher/salt into develop", "files_name": ["ab7ca0c3a879e020d0f43acda2120b910d0fa9e9 - Tue Oct 3 12:07:03 2017 +0200 : Merge pull request #43860 from eyj/jid_queue", "2c937fbe19dd874fa91c9d7c4848c39e8f28f687 - Tue Oct 3 19:52:03 2017 +1100 : Merge remote branch 'upstream/2016.11' into 2016.11_43417_Backport_and_Fixes", "c9c8c48a4d63a8450b82402414a6f07040385bd5 - Tue Oct 3 17:32:16 2017 +1100 : all remove/install commands are passed to cmd.exe /s /c and commands are passed as strings to cmdmod", "salt/modules/win_pkg.py"]}, {"commit_id": "c6b2e1e35b062bb24a128e0d56bc8fc328d5d35d", "commit_date": "Mon Oct 2 21:36:41 2017 -0600", "commit_message": "update tests to match improved module", "files_name": ["tests/unit/modules/test_vagrant.py"]}, {"commit_id": "05392bc664d0efcfe79695507d068913c4d5a841", "commit_date": "Mon Oct 2 21:15:16 2017 -0600", "commit_message": "cloud friendly vagrant destroy", "files_name": ["salt/modules/vagrant.py"]}, {"commit_id": "f96740d278f3707c06410795851b1faf6b4df225", "commit_date": "Mon Oct 2 21:07:27 2017 -0600", "commit_message": "use recommended source for TMP directory", "files_name": ["tests/unit/utils/test_sdb.py"]}, {"commit_id": "b3e9b708295e9ae4e0880b7520b3ef799449164c", "commit_date": "Mon Oct 2 18:03:27 2017 -0400", "commit_message": "Merge branch 'develop' into develop", "files_name": ["1a9f12fd67583fde75d0cdb4be804335b19a82df - Fri Sep 29 12:12:54 2017 -0400 : Detect OpenBSD guest running under VMM(4)", "doc/topics/releases/oxygen.rst", "salt/grains/core.py"]}, {"commit_id": "2337904656e5b935ff330bf1cee5a54299439960", "commit_date": "Mon Oct 2 17:18:30 2017 -0400", "commit_message": "Add updated release notes to 2017.7.2 branch", "files_name": ["doc/topics/releases/2017.7.2.rst"]}, {"commit_id": "38dbd55412001fff33509f690b3f94a00bd294fe", "commit_date": "Mon Oct 2 16:52:00 2017 -0400", "commit_message": "Merge pull request #43860 from eyj/jid_queue", "files_name": ["36b0b1174b8c3742c8a08a9d62a5e1916325574d - Mon Oct 2 16:44:52 2017 -0400 : Merge pull request #43854 from keesbos/2017.7", "71793e4440a5f1ea400767df3aab45d29f2b7192 - Mon Oct 2 15:46:54 2017 -0400 : Merge branch 'develop' into develop", "2fa7fe5ee552bea19f2df3a28566c67105589645 - Mon Oct 2 13:46:36 2017 -0600 : Add hash cache invalidation to azurefs", "salt/fileserver/azurefs.py"]}, {"commit_id": "fe28b0d4fb7c63bde2d5ec928cd85c384e9b11fe", "commit_date": "Mon Oct 2 14:42:40 2017 -0500", "commit_message": "Only join cmd if it's not a string", "files_name": ["salt/modules/cmdmod.py"]}, {"commit_id": "8a1ae5c465a5069c286ce22771f8ff43d763928f", "commit_date": "Mon Oct 2 15:40:09 2017 -0400", "commit_message": "Merge pull request #43862 from dwiest/patch-1", "files_name": ["e21d8e9583bba816b6ebc8c9bed379fb4790dfa4 - Mon Oct 2 11:40:00 2017 -0500 : Use six.iterkeys() instead of dict.keys()", "salt/states/module.py"]}, {"commit_id": "c297ae55575a790637f1dd5d780ce324a027744d", "commit_date": "Fri Sep 29 17:15:18 2017 -0500", "commit_message": "Improve failures for module.run states", "files_name": ["tests/unit/states/test_module.py"]}, {"commit_id": "782e67c199afb51bec10e93fcd65f9af59972247", "commit_date": "Sun Oct 1 10:59:09 2017 +0200", "commit_message": "Lint", "files_name": ["salt/states/module.py"]}, {"commit_id": "a6c2d78518bf9e6b9d26cdbd4e245e762ab65def", "commit_date": "Sun Oct 1 00:39:37 2017 +0200", "commit_message": "Fix typo found by @s0undt3ch", "files_name": ["salt/states/module.py"]}, {"commit_id": "0cac15e502d1565c718ebb289fb95c6e67dcdf10", "commit_date": "Sat Sep 30 22:41:30 2017 +0200", "commit_message": "Fix to module.run [WIP]", "files_name": ["salt/states/module.py"]}, {"commit_id": "c81e8457b8cfd011105c257f83e81b961352a642", "commit_date": "Mon Oct 2 15:25:02 2017 -0400", "commit_message": "Merge pull request #43847 from cachedout/module_run_compare", "files_name": ["2bccf228baba98ef3a29b132ba94ac3c4cb9900d - Mon Oct 2 12:18:11 2017 -0600 : fix code-lint complaint", "tests/unit/utils/test_sdb.py"]}, {"commit_id": "bd3d457903e9b79fca10ce17252ea411c75fca1d", "commit_date": "Mon Oct 2 14:13:40 2017 -0400", "commit_message": "Fix TypeError: 'NoneType' object is not iterable during list_networks function.", "files_name": ["salt/cloud/clouds/azurearm.py"]}, {"commit_id": "dee0d318c1ffa3456ab951fed82f9be702283e8e", "commit_date": "Mon Oct 2 11:14:09 2017 -0600", "commit_message": "use .get incase attrs are disabled on the filesystem", "files_name": ["salt/modules/file.py"]}, {"commit_id": "aef2b180ee2e425a636b39573e60a7e554ac60c7", "commit_date": "Mon Oct 2 10:11:21 2017 -0700", "commit_message": "Merge branch 'develop' into unit-test-sdb", "files_name": ["6c20e146c3a310699fa76933310a3e06ebbaa6ed - Mon Oct 2 10:10:53 2017 -0700 : Lint Fixes", "tests/unit/utils/test_sdb.py"]}, {"commit_id": "b11f8c8f292e5fa090f4cccb5841cf344ac4fd20", "commit_date": "Mon Oct 2 18:44:06 2017 +0200", "commit_message": "Merge pull request #17 from terminalmage/pr-43847", "files_name": ["93eaba7c54d280a8598d083f8d6b5a1fea8dc95e - Mon Oct 2 11:40:00 2017 -0500 : Use six.iterkeys() instead of dict.keys()", "salt/states/module.py"]}, {"commit_id": "dbeeb0e917a5bf23d8f4c33a83d2159d9e7f2802", "commit_date": "Mon Oct 2 12:33:27 2017 -0400", "commit_message": "fixes #38452 atomicfile only copies mode and not user/group perms", "files_name": ["salt/utils/atomicfile.py"]}, {"commit_id": "5d56a03a6723c046cd6d3f004e4b59bf396845ac", "commit_date": "Fri Sep 29 17:15:18 2017 -0500", "commit_message": "Improve failures for module.run states", "files_name": ["tests/unit/states/test_module.py"]}, {"commit_id": "22792e56cc4f06e92b7973c4819ac4d2534153a2", "commit_date": "Mon Oct 2 09:48:27 2017 -0600", "commit_message": "lint, style, and Windows fixes", "files_name": ["tests/unit/utils/test_sdb.py"]}, {"commit_id": "76cd070e2d6b231dad876dca7a9df8785efc757e", "commit_date": "Mon Oct 2 10:15:02 2017 -0500", "commit_message": "Fixed Jinja typo in faq.rst", "files_name": ["doc/faq.rst"]}, {"commit_id": "df9317ed390ecc130309c6d925c87ec61b88b02f", "commit_date": "Mon Oct 2 16:53:05 2017 +0200", "commit_message": "Merge pull request #43836 from rallytime/stale-config-update", "files_name": ["71780beb5a072158616080606a7fc64526279078 - Mon Oct 2 16:40:22 2017 +0200 : Merge branch '2017.7' into module_run_compare", "638aa96afff9b528fcdcd326ade85b6fce801ebb - Mon Oct 2 16:34:22 2017 +0200 : Merge pull request #43852 from amalleo25/patch-2", "5df8e597961eba4887a668b2b18df55b734a603f - Fri Sep 29 13:58:11 2017 +0300 : Add OpsGenie's execution and state modules", "doc/ref/modules/all/index.rst", "doc/ref/modules/all/salt.modules.opsgenie.rst", "doc/ref/states/all/index.rst", "doc/ref/states/all/salt.states.opsgenie.rst", "salt/modules/opsgenie.py", "salt/states/opsgenie.py"]}, {"commit_id": "993ea72f753f994e27982d90fde211fe91936d5f", "commit_date": "Fri Sep 16 13:07:06 2016 +0200", "commit_message": "Use dsn if specified as all recent raven libraries can init via dsn", "files_name": ["salt/log/handlers/sentry_mod.py"]}, {"commit_id": "325a2f301e4630b6568b88c545373c156e5befe0", "commit_date": "Mon Oct 17 14:40:47 2016 +0200", "commit_message": "Activate jid_queue also for SingleMinions to workaround 0mq reconnection issues", "files_name": ["salt/minion.py"]}, {"commit_id": "508dda8a168448582bdb459a4a7016a4a98ec083", "commit_date": "Thu Jan 5 10:22:14 2017 +0100", "commit_message": "Improve sentry message for aggregation", "files_name": ["salt/returners/sentry_return.py"]}, {"commit_id": "53886e323dcd34379ad9d24ac4402d0ad4a820b9", "commit_date": "Mon Oct 10 13:18:07 2016 +0200", "commit_message": "Consider result to be success if no state failed", "files_name": ["salt/returners/sentry_return.py"]}, {"commit_id": "dd19b2d36d921b17766bb018d0b85decf6c2d27f", "commit_date": "Tue Jun 7 19:19:22 2016 +0200", "commit_message": "Consider result \"success\" as sufficient for non error return", "files_name": ["salt/returners/sentry_return.py"]}, {"commit_id": "41ca410946a705c4bc6a019869869464d3877684", "commit_date": "Thu Jun 2 12:39:44 2016 +0200", "commit_message": "Add http tranport option for sentry", "files_name": ["salt/returners/sentry_return.py"]}, {"commit_id": "fba9c9a935a6e81784e0b52a0caab65df4526b1a", "commit_date": "Mon Oct 2 09:14:49 2017 +0200", "commit_message": "Map __env__ in git_pillar before sanity checks", "files_name": ["salt/pillar/git_pillar.py"]}, {"commit_id": "d4551ab63fffcbd1c6fef017a46b4ebce337c528", "commit_date": "Sun Oct 1 21:06:11 2017 -0400", "commit_message": "Update joyent.py", "files_name": ["salt/cloud/clouds/joyent.py"]}, {"commit_id": "900af71f056432e44810add83a0371f7759714db", "commit_date": "Sun Oct 1 20:35:17 2017 -0400", "commit_message": "Merge branch 'develop' into fix_returner_core", "files_name": ["c67db52c731f0cefecaee3377dd036df221c5e94 - Sun Oct 1 18:56:58 2017 -0400 : Merge branch 'develop' into issue36942", "111df31057d8e488a9b56db5ce16511b944c7427 - Sun Oct 1 16:59:28 2017 -0400 : Fix english error in jinja_sls_env documentation", "doc/ref/configuration/master.rst"]}, {"commit_id": "470265ee03095701032cdb3940dae7c1d42e5531", "commit_date": "Sun Oct 1 15:47:03 2017 -0400", "commit_message": "Merge branch 'pr41538' into issue36942", "files_name": ["19dcfcf1a0766a7efde64c9d8999fa385e4cc22e - Sun Oct 1 14:23:41 2017 -0400 : Add jinja_env and jinja_sls_env master configuration options documentation", "conf/master", "conf/suse/master", "doc/ref/configuration/master.rst"]}, {"commit_id": "9f25a1c2dd6a136e24bf4cdc8189ad8a1329f4d3", "commit_date": "Sun Oct 1 10:14:26 2017 -0400", "commit_message": "Merge pull request #43503 from The-Loeki/high-out-by_id", "files_name": ["08463ba153b5d50c148a593c5f24a9535c31995b - Sun Oct 1 10:11:11 2017 -0400 : Merge branch 'develop' into bugs/43003_group_syndic_develop", "8cf38f4065b723e39618c425783750a07b975319 - Sun Oct 1 10:08:23 2017 -0400 : Merge pull request #42820 from cenkalti/fix-cmd_iter", "a2161efda36ecc2133076c5a92980fb0885d7f5e - Sun Oct 1 10:07:52 2017 -0400 : Merge pull request #43707 from terminalmage/issue43373", "c208f0ac39d7f479ba897384f9c627757d7e7da4 - Sun Oct 1 08:17:43 2017 -0400 : Merge branch 'develop' into develop", "2beeb3930295f2731a63a75d43740f7a37d0c542 - Sun Oct 1 07:53:22 2017 -0400 : Merge branch 'develop' of github.com:kkoch986/salt into develop", "57a624d86bf6e47302adbfe39b50e90b19f2aa8b - Sun Oct 1 07:32:33 2017 -0400 : Add support for tagging newly created DigitalOcean droplets."]}], "windows_after": [{"commit_id": "3a06a9807d0726ad4b6e44f6cf5b9e9eefa841f7", "commit_date": "Tue Oct 3 16:25:29 2017 -0600", "commit_message": "Merge remote-tracking branch 'origin/develop' into develop", "files_name": ["04a23f9f9ba6b0323c29ff80b0a7193256d75660 - Tue Oct 3 16:20:04 2017 -0600 : Add container_ref to specify device creation and network dvs maping", "salt/cloud/clouds/vmware.py"]}, {"commit_id": "51eca1a6bdc3d374538feb174160c2f8a6e9ee67", "commit_date": "Tue Oct 3 16:13:54 2017 -0600", "commit_message": "enable tox for tests", "files_name": [".gitignore", "tox.ini"]}, {"commit_id": "83a3678cef854b2fa0ee0d790b5b984cbe942218", "commit_date": "Tue Oct 3 17:24:05 2017 -0600", "commit_message": "provide mocked unit tests", "files_name": ["salt/modules/vagrant.py", "tests/unit/modules/test_vagrant.py"]}, {"commit_id": "67a701de7c4ee9ee98162ca378d70423a6971e7c", "commit_date": "Tue Oct 3 23:23:17 2017 -0600", "commit_message": "lint PEP-8", "files_name": ["tests/unit/modules/test_vagrant.py"]}, {"commit_id": "13f29b401028e6019b6faadf8c99586efb512d85", "commit_date": "Wed Oct 4 10:41:58 2017 +0300", "commit_message": "Merge branch 'develop' into opsgenie-modules", "files_name": ["96ab662c9a6cf492ea2816d5fef60c89fee3af47 - Wed Oct 4 17:31:16 2017 +0800 : Merge branch 'develop' into issues/42512", "bd04b29e9ab65d621e81f20f8a89d05db942f0cb - Wed Oct 4 12:42:34 2017 +0200 : Encode tags as utf-8, retry policy readout", "salt/modules/boto_asg.py"]}, {"commit_id": "4c121c36ca84b9de897d4591c7510cd550850afa", "commit_date": "Mon Oct 2 11:27:19 2017 +0200", "commit_message": "Remove duplicate six import, change wording of log string", "files_name": ["salt/returners/sentry_return.py"]}, {"commit_id": "0a9acba6257a079ffce0ccc43b7d657cd18dfbde", "commit_date": "Thu Nov 24 15:37:23 2016 +0100", "commit_message": "Add missing delete_on_termination passthrough. Adapt docs.", "files_name": ["salt/states/boto_lc.py"]}, {"commit_id": "2ab7549d488332a6bb5f9f102461e9999e1bfd64", "commit_date": "Wed Oct 4 09:08:29 2017 -0400", "commit_message": "Merge pull request #43884 from UtahDave/2016.11local", "files_name": ["a5abe33e1ca04a41498ff2230cb045e5c672ced8 - Wed Oct 4 07:10:12 2017 -0600 : Merge pull request #43828 from rallytime/merge-2017.7", "703824882086511964468ea6fd1b0cb5d8340de2 - Wed Oct 4 09:08:15 2017 -0600 : Merge pull request #43899 from gtmanfred/2017.7", "73947e310309dd09a07cfe0e1aeebe936c33b76d - Wed Oct 4 09:10:47 2017 -0600 : lint (again!) blank lines can have no spaces", "tests/unit/modules/test_vagrant.py"]}, {"commit_id": "4c1b50fb5af33d1815ae0e75e8ea51b1ea8491a9", "commit_date": "Wed Oct 4 09:14:20 2017 -0600", "commit_message": "Add space after comma", "files_name": ["salt/returners/pgjsonb.py"]}, {"commit_id": "01a0ea8a61d09a2836983dcd4f0216cf2b8635d4", "commit_date": "Wed Oct 4 11:37:14 2017 -0400", "commit_message": "Merge pull request #43864 from gtmanfred/develop", "files_name": ["9730c5da1793ab876aa6e9f201f0b71a0135969a - Wed Oct 4 18:00:54 2017 +0200 : Make sure volume exists before querying", "salt/cloud/clouds/ec2.py"]}, {"commit_id": "042e092ac85bc3e66bbab9fc8abb13fdb74e9f03", "commit_date": "Wed Oct 4 12:01:14 2017 -0500", "commit_message": "Don't put unserializable dict.keys() into state return", "files_name": ["salt/states/module.py"]}, {"commit_id": "0dc3c4ef1cab6b9b4cfd0f990d3139ce1b8b2a8c", "commit_date": "Wed Oct 4 12:57:55 2017 -0400", "commit_message": "Skip some vsphere tests if pyvmomi library is not installed", "files_name": ["tests/unit/modules/test_vsphere.py"]}, {"commit_id": "2dbee2b0fc27fc9ad85ec8f3a3a233d86124db71", "commit_date": "Wed Oct 4 20:50:03 2017 +0200", "commit_message": "survey runner bugfix", "files_name": ["salt/runners/survey.py"]}, {"commit_id": "d29218e04378ca733333b18b6cabafbc59a0b342", "commit_date": "Wed Oct 4 20:52:21 2017 +0200", "commit_message": "Merge branch 'develop' into develop", "files_name": ["ae03b70b19317252df4167f26fd0fc2fca9ced46 - Wed Oct 4 20:55:38 2017 +0200 : survey runner bugfix", "salt/runners/survey.py"]}, {"commit_id": "f7fc4a37545b0087f639dfb7e57a58953adf0347", "commit_date": "Wed Oct 4 20:56:02 2017 +0200", "commit_message": "Merge branch 'develop' of https://github.com/netzmacher/salt into develop", "files_name": ["0d2b0e6732e39f431d5e0d46df704dad0cb3635a - Wed Oct 4 14:15:36 2017 -0500 : Fixed saltstack/salt#43912", "salt/modules/firewalld.py", "salt/states/firewalld.py"]}, {"commit_id": "15b8b8a9f46fbb1940ef6ca204584244dab0fbca", "commit_date": "Thu Oct 5 00:49:17 2017 +0200", "commit_message": "Fix typo in salt-cloud scaleway documentation", "files_name": ["doc/topics/cloud/scaleway.rst"]}, {"commit_id": "3e41cb3a9bc066aa8f82c4d42f521db3f200070b", "commit_date": "Thu Oct 5 09:08:08 2017 +0200", "commit_message": "Added missing requisites to stateconf renderer", "files_name": ["salt/renderers/stateconf.py"]}, {"commit_id": "1b93f251a9faeebca4b38e68902ef51f66590803", "commit_date": "Thu Oct 5 11:00:13 2017 +0300", "commit_message": "Merge branch 'develop' into opsgenie-modules", "files_name": ["6bac5dcf7ae72087de2ecc3a966b840cc4d39a8b - Thu Oct 5 11:08:33 2017 +0200 : Fixed lint error (additional space after coma)", "salt/renderers/stateconf.py"]}, {"commit_id": "b99fd0ad64663c4b54c77723a4f05fa319162172", "commit_date": "Thu Oct 5 16:28:27 2017 +0530", "commit_message": "Create dirs if not exists", "files_name": ["salt/config/__init__.py"]}, {"commit_id": "4126bd9a096b0acd96785fbf6752c683a3f12bf0", "commit_date": "Thu Oct 5 14:28:30 2017 +0200", "commit_message": "Merge branch 'develop' into boto_asg", "files_name": ["19a40f1af21e869bef69f94ac49ca300b6ce241c - Thu Oct 5 14:28:38 2017 +0200 : Merge branch 'develop' into sentry_mod", "995e9cb608dcf7ff136cbfcca8decd39f14c0b12 - Thu Oct 5 14:28:47 2017 +0200 : Merge branch 'develop' into boto_lc", "6be256c310e758e649140caaa5a9c3f7d1fd1f58 - Thu Oct 5 14:28:56 2017 +0200 : Merge branch 'develop' into sentry_return", "a9dc04fb7f136a0f5af7d72012743bdb66a5c135 - Thu Oct 5 08:51:16 2017 -0400 : Lint: disable the unused-import check", "tests/unit/modules/test_vsphere.py"]}, {"commit_id": "b25df9106bf61733d334f0b1e5de5a00b48f0fde", "commit_date": "Thu Oct 5 08:56:11 2017 -0400", "commit_message": "Merge pull request #43894 from techhat/azurerg", "files_name": ["865bf0fa9bf47ef2653b62350ed51c73ab7bba4d - Thu Oct 5 08:59:11 2017 -0400 : Merge pull request #43907 from richardsimko/develop", "f62e8ca87f6fa46432b933a98d77d6593c083226 - Wed Oct 4 18:00:54 2017 +0200 : Make sure volume exists before querying", "salt/cloud/clouds/ec2.py"]}, {"commit_id": "4a77560646b50d48270d59e7078d301e6eee5f84", "commit_date": "Thu Oct 5 09:51:38 2017 -0600", "commit_message": "Don't try to modify dict while looping through it", "files_name": ["salt/cloud/__init__.py"]}, {"commit_id": "eaca3291e2f0711397de1799efb5643bbc94627f", "commit_date": "Thu Oct 5 12:09:40 2017 -0400", "commit_message": "Merge branch '2016.11' into '2017.7'", "files_name": ["7f004adca10e66cb1686cd2987b4b16d9d5a14aa - Thu Oct 5 19:02:55 2017 +0200 : survey runner bugfix", "salt/runners/survey.py"]}, {"commit_id": "37d7f1392643f4a4a8d4d429498e44002c20df2a", "commit_date": "Thu Oct 5 10:25:24 2017 -0700", "commit_message": "Merge branch 'develop' into vagrant-module", "files_name": ["9a0773542d38932da2480a1d1e69c1899b447ec0 - Thu Oct 5 10:30:37 2017 -0700 : Merge branch 'develop' into unit-test-sdb", "c0fa06a16d49147b3cd659761bb11350bad4e7d4 - Thu Oct 5 13:43:52 2017 -0400 : INFRA-5669 - wow, what a stupid error to make...", "salt/modules/boto_asg.py"]}, {"commit_id": "a00c3a3afe37931c84a86fba0dd7ed2c7e099a44", "commit_date": "Thu Oct 5 13:45:20 2017 -0400", "commit_message": "Merge branch 'develop' into infra5669", "files_name": ["4a942b75e907cdef9e8ad18a6539335376a79667 - Thu Oct 5 14:52:09 2017 -0400 : Merge pull request #43878 from netzmacher/develop", "f880ac4c0892ff03962d1d35d994dc0064c3e8b1 - Thu Oct 5 14:57:59 2017 -0400 : Merge pull request #43916 from dereckson/fix-typo-cloud-scaleway", "49202d71e2a153431bcb43d037e6db2fa79bb482 - Thu Oct 5 14:58:31 2017 -0400 : Merge pull request #43911 from eradman/vsphere_tests", "e1b470061d58f584905c94715e69e2406694ee06 - Thu Oct 5 15:06:30 2017 -0400 : Merge branch 'develop' into fix_id_cache", "7d174172a00c54f8469d284d0ac026b1730ab168 - Thu Oct 5 15:33:55 2017 -0400 : Merge pull request #43886 from techhat/azuredict", "29d8cf4f26bfaa8b646e3654858f1576aae429bd - Thu Oct 5 14:54:04 2017 -0500 : Fix typo in log message", "salt/fileserver/roots.py"]}, {"commit_id": "4c5af8cc9669475c1ac69e197a69b9e344acbf94", "commit_date": "Thu Oct 5 13:01:01 2017 -0700", "commit_message": "Merge branch 'develop' into unit-test-sdb", "files_name": ["4fcd4709eabebc433cd7bdf34c98ee8b4f875b85 - Thu Oct 5 16:07:35 2017 -0400 : Merge pull request #43934 from rallytime/merge-2017.7", "7785919437a60dcfc9c58383383367c9a8c00ff7 - Thu Oct 5 16:09:23 2017 -0400 : Merge pull request #43829 from rallytime/merge-develop", "9ac3f2ea7b58b19b450eb96f3e9ca61a7e35390c - Thu Oct 5 16:09:57 2017 -0400 : Merge pull request #43888 from rallytime/bp-43841", "a7a59868c87437ca2aa130f32dc8870d71bead65 - Thu Oct 5 16:10:15 2017 -0400 : Merge pull request #43927 from rallytime/bp-43907", "31a641ce74835f89f136282d88e0b07199342987 - Thu Oct 5 16:19:37 2017 -0400 : Merge branch 'develop' into panos-2017-9-26", "395c0c424d99686d8a29e24ddc857eafb748b95d - Thu Oct 5 16:28:40 2017 -0400 : Merge branch '2017.7' into cached_pilarenv", "1a718eb1ed8d6b33e4a5cf5b59ee48614bb1de3e - Thu Oct 5 16:33:46 2017 -0400 : Merge pull request #43910 from terminalmage/issue43605", "7d3ece7a3267972a2c06a41a05048cd88062e273 - Thu Oct 5 22:42:22 2017 +0200 : Adapted documentation of delete_on_termination parameter", "salt/states/boto_lc.py"]}, {"commit_id": "7d66ab9ac10dff9c087dfcb3154c97a1295eced0", "commit_date": "Thu Oct 5 22:42:39 2017 +0200", "commit_message": "Merge remote-tracking branch 'origin/boto_lc' into boto_lc", "files_name": ["3d7340b371e80b1ec63c3ad78a7317a3a604e96c - Thu Oct 5 22:42:56 2017 +0200 : Merge branch 'develop' into boto_lc", "53509e8d4625089b08733be16b8a31e8a8246f97 - Thu Oct 5 15:35:13 2017 -0700 : Merge branch 'develop' into unit-test-sdb", "254dac7723d7a2d63d34f7f3b774626ec39a007c - Thu Oct 5 16:47:32 2017 -0600 : Fix `unit.utils.test_utils` for Windows", "tests/unit/utils/test_utils.py"]}, {"commit_id": "9b717bdd88294c7d926aeb803fa0a8ca082b9836", "commit_date": "Fri Oct 6 00:47:33 2017 +0200", "commit_message": "added cores,cpulimit and rootfs lxc params", "files_name": ["salt/cloud/clouds/proxmox.py"]}, {"commit_id": "d4d639189bebc4c20cc7cc2131b1ad134cf73788", "commit_date": "Fri Oct 6 00:53:44 2017 +0200", "commit_message": "fix missing space after cores in lxc section", "files_name": ["salt/cloud/clouds/proxmox.py"]}, {"commit_id": "fefd28d896457ee12bc00247e84702c9170c8e15", "commit_date": "Thu Oct 5 19:04:05 2017 -0400", "commit_message": "Add futureproofing to roster_defaults to support roster dictionary options", "files_name": ["salt/roster/cache.py", "salt/roster/cloud.py", "salt/roster/clustershell.py", "salt/roster/flat.py", "salt/roster/range.py", "salt/roster/scan.py"]}, {"commit_id": "ac23b5cfe7b40b6a881c3070a2ba9255dfd2def4", "commit_date": "Thu Oct 5 19:11:16 2017 -0400", "commit_message": "Merge pull request #43859 from eyj/boto_lc", "files_name": ["bd9f5d73fb8daa6a1733abb75c064f5a4bc2d0e8 - Thu Oct 5 16:12:48 2017 -0700 : Merge branch 'develop' into unit-test-sdb", "a8f1750323ecb87d23eef06af159d835fe76de92 - Thu Oct 5 19:20:04 2017 -0400 : Merge pull request #43939 from terminalmage/fix-typo", "aa3309ef5920db2c5ed8b26b8e142da1c84c49e0 - Thu Oct 5 13:37:27 2017 -0500 : Move several functions from salt.utils to salt.utils.user", "salt/auth/__init__.py", "salt/auth/pam.py", "salt/client/__init__.py", "salt/client/mixins.py", "salt/cloud/cli.py", "salt/config/__init__.py", "salt/crypt.py", "salt/daemons/masterapi.py", "salt/key.py", "salt/master.py", "salt/minion.py", "salt/modules/file.py", "salt/modules/mac_user.py", "salt/modules/npm.py", "salt/modules/pw_user.py", "salt/modules/rabbitmq.py", "salt/modules/solaris_user.py", "salt/modules/useradd.py", "salt/modules/win_file.py", "salt/runner.py", "salt/states/user.py", "salt/utils/__init__.py", "salt/utils/gitfs.py", "salt/utils/parsers.py", "salt/utils/user.py", "salt/utils/verify.py", "tests/integration/modules/test_linux_acl.py", "tests/unit/modules/test_pw_user.py", "tests/unit/modules/test_useradd.py"]}, {"commit_id": "0cf411671eec7de2c8f259a1e6f1f071614e76b0", "commit_date": "Wed Oct 4 15:50:50 2017 +1100", "commit_message": "Check the `key_text` option doesn't conflict with any other options", "files_name": ["salt/states/pkgrepo.py"]}, {"commit_id": "b7edddd215f52dfc59525bf761691b53755cce6e", "commit_date": "Fri Oct 6 12:20:46 2017 +1100", "commit_message": "Document `key_text` option in pkgrepo state", "files_name": ["salt/states/pkgrepo.py"]}, {"commit_id": "be91fbb7b78a7ad0213d96e1a05790ba0d96e662", "commit_date": "Fri Oct 6 09:05:42 2017 +0200", "commit_message": "Debug log added when throttled by API", "files_name": ["salt/modules/boto_asg.py"]}, {"commit_id": "d930d9943694b729c9cfca60f7249f678b6adddc", "commit_date": "Fri Oct 6 09:06:00 2017 +0200", "commit_message": "Merge remote-tracking branch 'origin/boto_asg' into boto_asg", "files_name": ["18be75feb49d795bf659efda4eefe30af2be40d0 - Fri Oct 6 09:06:39 2017 +0200 : Merge branch 'develop' into boto_asg", "ac56945f585b94038392941c9ee0bf51af7a8316 - Fri Oct 6 10:24:47 2017 +0200 : Merge branch 'develop' into add-missing-param-lxc-proxmox-driver", "08f59a0962eda069c45024ca54ab99081a155524 - Fri Oct 6 00:53:44 2017 +0200 : fix missing space after cores in lxc section", "salt/cloud/clouds/proxmox.py"]}, {"commit_id": "6d36a9f9fa1d009c0bd05529bda524ebbd160633", "commit_date": "Fri Oct 6 10:34:17 2017 +0200", "commit_message": "Merge branch 'add-missing-param-lxc-proxmox-driver' of github.com:cavepopo/salt into add-missing-param-lxc-proxmox-driver", "files_name": ["4ce20bb2f71ebea339feeeaf07c6cf1af9861a30 - Fri Oct 6 13:10:34 2017 +0200 : [log/sentry] avoid KeyError: 'SENTRY_PROJECT'", "salt/log/handlers/sentry_mod.py"]}, {"commit_id": "89200ff28e9183f0923563321f98fc8efb6bd57d", "commit_date": "Fri Oct 6 13:18:16 2017 +0200", "commit_message": "rebase from 2017.7.2", "files_name": ["salt/renderers/stateconf.py"]}, {"commit_id": "63961cc7d9fd6a0fdbcb06972afd8b6c0659c91c", "commit_date": "Wed Sep 27 11:14:40 2017 +0200", "commit_message": "Copy git ssh-id-wrapper to /tmp only if necessary (Fixes #10582, Fixes #19532)", "files_name": ["salt/modules/git.py"]}, {"commit_id": "d136650b31dbf45eb1bdc1610f90e9709d515cb4", "commit_date": "Fri Oct 6 09:42:42 2017 -0400", "commit_message": "Merge pull request #43938 from terminalmage/salt.utils.user", "files_name": ["11e577b9cedd908ddc3a5c79003c6d532d2f4679 - Fri Oct 6 07:55:04 2017 -0600 : Add deps message to __virtual__()", "salt/cloud/clouds/azurearm.py"]}], "parents": [{"commit_id_before": "5f8b5e1a0f23fe0f2be5b3c3e04199b57a53db5b", "url_before": "https://api.github.com/repos/saltstack/salt/commits/5f8b5e1a0f23fe0f2be5b3c3e04199b57a53db5b", "html_url_before": "https://github.com/saltstack/salt/commit/5f8b5e1a0f23fe0f2be5b3c3e04199b57a53db5b"}], "details": [{"raw_url": "https://github.com/saltstack/salt/raw/80d90307b07b3703428ecbb7c8bb468e28a9ae6d/salt%2Futils%2Fverify.py", "code": "# -*- coding: utf-8 -*-\n'''\nA few checks to make sure the environment is sane\n'''\nfrom __future__ import absolute_import\n\n# Original Author: Jeff Schroeder <jeffschroeder@computer.org>\n\n# Import python libs\nimport os\nimport re\nimport sys\nimport stat\nimport errno\nimport socket\nimport logging\n\n# Import third party libs\ntry:\n    import win32file\nexcept ImportError:\n    import resource\n\n# Import salt libs\nfrom salt.log import is_console_configured\nfrom salt.log.setup import LOG_LEVELS\nfrom salt.exceptions import SaltClientError, SaltSystemExit, \\\n    CommandExecutionError\nimport salt.defaults.exitcodes\nimport salt.utils\n\nlog = logging.getLogger(__name__)\n\n\ndef zmq_version():\n    '''\n    ZeroMQ python bindings >= 2.1.9 are required\n    '''\n    try:\n        import zmq\n    except Exception:\n        # Return True for local mode\n        return True\n    ver = zmq.__version__\n    # The last matched group can be None if the version\n    # is something like 3.1 and that will work properly\n    match = re.match(r'^(\\d+)\\.(\\d+)(?:\\.(\\d+))?', ver)\n\n    # Fallthrough and hope for the best\n    if not match:\n        msg = \"Using untested zmq python bindings version: '{0}'\".format(ver)\n        if is_console_configured():\n            log.warning(msg)\n        else:\n            sys.stderr.write(\"WARNING {0}\\n\".format(msg))\n        return True\n\n    major, minor, point = match.groups()\n\n    if major.isdigit():\n        major = int(major)\n    if minor.isdigit():\n        minor = int(minor)\n\n    # point very well could be None\n    if point and point.isdigit():\n        point = int(point)\n\n    if major == 2 and minor == 1:\n        # zmq 2.1dev could be built against a newer libzmq\n        if \"dev\" in ver and not point:\n            msg = 'Using dev zmq module, please report unexpected results'\n            if is_console_configured():\n                log.warning(msg)\n            else:\n                sys.stderr.write(\"WARNING: {0}\\n\".format(msg))\n            return True\n        elif point and point >= 9:\n            return True\n    elif major > 2 or (major == 2 and minor > 1):\n        return True\n\n    # If all else fails, gracefully croak and warn the user\n    log.critical('ZeroMQ python bindings >= 2.1.9 are required')\n    if 'salt-master' in sys.argv[0]:\n        msg = ('The Salt Master is unstable using a ZeroMQ version '\n               'lower than 2.1.11 and requires this fix: http://lists.zeromq.'\n               'org/pipermail/zeromq-dev/2011-June/012094.html')\n        if is_console_configured():\n            log.critical(msg)\n        else:\n            sys.stderr.write('CRITICAL {0}\\n'.format(msg))\n    return False\n\n\ndef lookup_family(hostname):\n    '''\n    Lookup a hostname and determine its address family. The first address returned\n    will be AF_INET6 if the system is IPv6-enabled, and AF_INET otherwise.\n    '''\n    # If lookups fail, fall back to AF_INET sockets (and v4 addresses).\n    fallback = socket.AF_INET\n    try:\n        hostnames = socket.getaddrinfo(\n            hostname or None, None, socket.AF_UNSPEC, socket.SOCK_STREAM\n        )\n        if not hostnames:\n            return fallback\n        h = hostnames[0]\n        return h[0]\n    except socket.gaierror:\n        return fallback\n\n\ndef verify_socket(interface, pub_port, ret_port):\n    '''\n    Attempt to bind to the sockets to verify that they are available\n    '''\n\n    addr_family = lookup_family(interface)\n    for port in pub_port, ret_port:\n        sock = socket.socket(addr_family, socket.SOCK_STREAM)\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            sock.bind((interface, int(port)))\n        except Exception as exc:\n            msg = 'Unable to bind socket {0}:{1}'.format(interface, port)\n            if exc.args:\n                msg = '{0}, error: {1}'.format(msg, str(exc))\n            else:\n                msg = '{0}, this might not be a problem.'.format(msg)\n            msg += '; Is there another salt-master running?'\n            if is_console_configured():\n                log.warning(msg)\n            else:\n                sys.stderr.write('WARNING: {0}\\n'.format(msg))\n            return False\n        finally:\n            sock.close()\n\n    return True\n\n\ndef verify_files(files, user):\n    '''\n    Verify that the named files exist and are owned by the named user\n    '''\n    if salt.utils.is_windows():\n        return True\n    import pwd  # after confirming not running Windows\n    try:\n        pwnam = pwd.getpwnam(user)\n        uid = pwnam[2]\n    except KeyError:\n        err = ('Failed to prepare the Salt environment for user '\n               '{0}. The user is not available.\\n').format(user)\n        sys.stderr.write(err)\n        sys.exit(salt.defaults.exitcodes.EX_NOUSER)\n\n    for fn_ in files:\n        dirname = os.path.dirname(fn_)\n        try:\n            if dirname:\n                try:\n                    os.makedirs(dirname)\n                except OSError as err:\n                    if err.errno != errno.EEXIST:\n                        raise\n            if not os.path.isfile(fn_):\n                with salt.utils.fopen(fn_, 'w+') as fp_:\n                    fp_.write('')\n\n        except IOError as err:\n            if os.path.isfile(dirname):\n                msg = 'Failed to create path {0}, is {1} a file?'.format(fn_, dirname)\n                raise SaltSystemExit(msg=msg)\n            if err.errno != errno.EACCES:\n                raise\n            msg = 'No permissions to access \"{0}\", are you running as the correct user?'.format(fn_)\n            raise SaltSystemExit(msg=msg)\n\n        except OSError as err:\n            msg = 'Failed to create path \"{0}\" - {1}'.format(fn_, err)\n            raise SaltSystemExit(msg=msg)\n\n        stats = os.stat(fn_)\n        if uid != stats.st_uid:\n            try:\n                os.chown(fn_, uid, -1)\n            except OSError:\n                pass\n    return True\n\n\ndef verify_env(dirs, user, permissive=False, pki_dir='', skip_extra=False):\n    '''\n    Verify that the named directories are in place and that the environment\n    can shake the salt\n    '''\n    if salt.utils.is_windows():\n        return win_verify_env(dirs, permissive, pki_dir, skip_extra)\n    import pwd  # after confirming not running Windows\n    try:\n        pwnam = pwd.getpwnam(user)\n        uid = pwnam[2]\n        gid = pwnam[3]\n        groups = salt.utils.get_gid_list(user, include_default=False)\n\n    except KeyError:\n        err = ('Failed to prepare the Salt environment for user '\n               '{0}. The user is not available.\\n').format(user)\n        sys.stderr.write(err)\n        sys.exit(salt.defaults.exitcodes.EX_NOUSER)\n    for dir_ in dirs:\n        if not dir_:\n            continue\n        if not os.path.isdir(dir_):\n            try:\n                cumask = os.umask(18)  # 077\n                os.makedirs(dir_)\n                # If starting the process as root, chown the new dirs\n                if os.getuid() == 0:\n                    os.chown(dir_, uid, gid)\n                os.umask(cumask)\n            except OSError as err:\n                msg = 'Failed to create directory path \"{0}\" - {1}\\n'\n                sys.stderr.write(msg.format(dir_, err))\n                sys.exit(err.errno)\n\n        mode = os.stat(dir_)\n        # If starting the process as root, chown the new dirs\n        if os.getuid() == 0:\n            fmode = os.stat(dir_)\n            if fmode.st_uid != uid or fmode.st_gid != gid:\n                if permissive and fmode.st_gid in groups:\n                    # Allow the directory to be owned by any group root\n                    # belongs to if we say it's ok to be permissive\n                    pass\n                else:\n                    # chown the file for the new user\n                    os.chown(dir_, uid, gid)\n            for subdir in [a for a in os.listdir(dir_) if 'jobs' not in a]:\n                fsubdir = os.path.join(dir_, subdir)\n                if '{0}jobs'.format(os.path.sep) in fsubdir:\n                    continue\n                for root, dirs, files in os.walk(fsubdir):\n                    for name in files:\n                        if name.startswith('.'):\n                            continue\n                        path = os.path.join(root, name)\n                        try:\n                            fmode = os.stat(path)\n                        except (IOError, OSError):\n                            pass\n                        if fmode.st_uid != uid or fmode.st_gid != gid:\n                            if permissive and fmode.st_gid in groups:\n                                pass\n                            else:\n                                # chown the file for the new user\n                                os.chown(path, uid, gid)\n                    for name in dirs:\n                        path = os.path.join(root, name)\n                        fmode = os.stat(path)\n                        if fmode.st_uid != uid or fmode.st_gid != gid:\n                            if permissive and fmode.st_gid in groups:\n                                pass\n                            else:\n                                # chown the file for the new user\n                                os.chown(path, uid, gid)\n        # Allow the pki dir to be 700 or 750, but nothing else.\n        # This prevents other users from writing out keys, while\n        # allowing the use-case of 3rd-party software (like django)\n        # to read in what it needs to integrate.\n        #\n        # If the permissions aren't correct, default to the more secure 700.\n        # If acls are enabled, the pki_dir needs to remain readable, this\n        # is still secure because the private keys are still only readable\n        # by the user running the master\n        if dir_ == pki_dir:\n            smode = stat.S_IMODE(mode.st_mode)\n            if smode != 448 and smode != 488:\n                if os.access(dir_, os.W_OK):\n                    os.chmod(dir_, 448)\n                else:\n                    msg = 'Unable to securely set the permissions of \"{0}\".'\n                    msg = msg.format(dir_)\n                    if is_console_configured():\n                        log.critical(msg)\n                    else:\n                        sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    if skip_extra is False:\n        # Run the extra verification checks\n        zmq_version()\n\n\ndef check_user(user):\n    '''\n    Check user and assign process uid/gid.\n    '''\n    if salt.utils.is_windows():\n        return True\n    if user == salt.utils.get_user():\n        return True\n    import pwd  # after confirming not running Windows\n    try:\n        pwuser = pwd.getpwnam(user)\n        try:\n            if hasattr(os, 'initgroups'):\n                os.initgroups(user, pwuser.pw_gid)  # pylint: disable=minimum-python-version\n            else:\n                os.setgroups(salt.utils.get_gid_list(user, include_default=False))\n            os.setgid(pwuser.pw_gid)\n            os.setuid(pwuser.pw_uid)\n\n            # We could just reset the whole environment but let's just override\n            # the variables we can get from pwuser\n            if 'HOME' in os.environ:\n                os.environ['HOME'] = pwuser.pw_dir\n\n            if 'SHELL' in os.environ:\n                os.environ['SHELL'] = pwuser.pw_shell\n\n            for envvar in ('USER', 'LOGNAME'):\n                if envvar in os.environ:\n                    os.environ[envvar] = pwuser.pw_name\n\n        except OSError:\n            msg = 'Salt configured to run as user \"{0}\" but unable to switch.'\n            msg = msg.format(user)\n            if is_console_configured():\n                log.critical(msg)\n            else:\n                sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n            return False\n    except KeyError:\n        msg = 'User not found: \"{0}\"'.format(user)\n        if is_console_configured():\n            log.critical(msg)\n        else:\n            sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n        return False\n    return True\n\n\ndef list_path_traversal(path):\n    '''\n    Returns a full list of directories leading up to, and including, a path.\n\n    So list_path_traversal('/path/to/salt') would return:\n        ['/', '/path', '/path/to', '/path/to/salt']\n    in that order.\n\n    This routine has been tested on Windows systems as well.\n    list_path_traversal('c:\\\\path\\\\to\\\\salt') on Windows would return:\n        ['c:\\\\', 'c:\\\\path', 'c:\\\\path\\\\to', 'c:\\\\path\\\\to\\\\salt']\n    '''\n    out = [path]\n    (head, tail) = os.path.split(path)\n    if tail == '':\n        # paths with trailing separators will return an empty string\n        out = [head]\n        (head, tail) = os.path.split(head)\n    while head != out[0]:\n        # loop until head is the same two consecutive times\n        out.insert(0, head)\n        (head, tail) = os.path.split(head)\n    return out\n\n\ndef check_path_traversal(path, user='root', skip_perm_errors=False):\n    '''\n    Walk from the root up to a directory and verify that the current\n    user has access to read each directory. This is used for  making\n    sure a user can read all parent directories of the minion's  key\n    before trying to go and generate a new key and raising an IOError\n    '''\n    for tpath in list_path_traversal(path):\n        if not os.access(tpath, os.R_OK):\n            msg = 'Could not access {0}.'.format(tpath)\n            if not os.path.exists(tpath):\n                msg += ' Path does not exist.'\n            else:\n                current_user = salt.utils.get_user()\n                # Make the error message more intelligent based on how\n                # the user invokes salt-call or whatever other script.\n                if user != current_user:\n                    msg += ' Try running as user {0}.'.format(user)\n                else:\n                    msg += ' Please give {0} read permissions.'.format(user)\n\n            # We don't need to bail on config file permission errors\n            # if the CLI\n            # process is run with the -a flag\n            if skip_perm_errors:\n                return\n            # Propagate this exception up so there isn't a sys.exit()\n            # in the middle of code that could be imported elsewhere.\n            raise SaltClientError(msg)\n\n\ndef check_max_open_files(opts):\n    '''\n    Check the number of max allowed open files and adjust if needed\n    '''\n    mof_c = opts.get('max_open_files', 100000)\n    if sys.platform.startswith('win'):\n        # Check the Windows API for more detail on this\n        # http://msdn.microsoft.com/en-us/library/xt874334(v=vs.71).aspx\n        # and the python binding http://timgolden.me.uk/pywin32-docs/win32file.html\n        mof_s = mof_h = win32file._getmaxstdio()\n    else:\n        mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n\n    accepted_keys_dir = os.path.join(opts.get('pki_dir'), 'minions')\n    accepted_count = len(os.listdir(accepted_keys_dir))\n\n    log.debug(\n        'This salt-master instance has accepted {0} minion keys.'.format(\n            accepted_count\n        )\n    )\n\n    level = logging.INFO\n\n    if (accepted_count * 4) <= mof_s:\n        # We check for the soft value of max open files here because that's the\n        # value the user chose to raise to.\n        #\n        # The number of accepted keys multiplied by four(4) is lower than the\n        # soft value, everything should be OK\n        return\n\n    msg = (\n        'The number of accepted minion keys({0}) should be lower than 1/4 '\n        'of the max open files soft setting({1}). '.format(\n            accepted_count, mof_s\n        )\n    )\n\n    if accepted_count >= mof_s:\n        # This should never occur, it might have already crashed\n        msg += 'salt-master will crash pretty soon! '\n        level = logging.CRITICAL\n    elif (accepted_count * 2) >= mof_s:\n        # This is way too low, CRITICAL\n        level = logging.CRITICAL\n    elif (accepted_count * 3) >= mof_s:\n        level = logging.WARNING\n        # The accepted count is more than 3 time, WARN\n    elif (accepted_count * 4) >= mof_s:\n        level = logging.INFO\n\n    if mof_c < mof_h:\n        msg += ('According to the system\\'s hard limit, there\\'s still a '\n                'margin of {0} to raise the salt\\'s max_open_files '\n                'setting. ').format(mof_h - mof_c)\n\n    msg += 'Please consider raising this value.'\n    log.log(level=level, msg=msg)\n\n\ndef clean_path(root, path, subdir=False):\n    '''\n    Accepts the root the path needs to be under and verifies that the path is\n    under said root. Pass in subdir=True if the path can result in a\n    subdirectory of the root instead of having to reside directly in the root\n    '''\n    if not os.path.isabs(root):\n        return ''\n    if not os.path.isabs(path):\n        path = os.path.join(root, path)\n    path = os.path.normpath(path)\n    if subdir:\n        if path.startswith(root):\n            return path\n    else:\n        if os.path.dirname(path) == os.path.normpath(root):\n            return path\n    return ''\n\n\ndef valid_id(opts, id_):\n    '''\n    Returns if the passed id is valid\n    '''\n    try:\n        if any(x in id_ for x in ('/', '\\\\', '\\0')):\n            return False\n        return bool(clean_path(opts['pki_dir'], id_))\n    except (AttributeError, KeyError, TypeError):\n        return False\n\n\ndef safe_py_code(code):\n    '''\n    Check a string to see if it has any potentially unsafe routines which\n    could be executed via python, this routine is used to improve the\n    safety of modules suct as virtualenv\n    '''\n    bads = (\n            'import',\n            ';',\n            'subprocess',\n            'eval',\n            'open',\n            'file',\n            'exec',\n            'input')\n    for bad in bads:\n        if code.count(bad):\n            return False\n    return True\n\n\ndef verify_log(opts):\n    '''\n    If an insecre logging configuration is found, show a warning\n    '''\n    level = LOG_LEVELS.get(str(opts.get('log_level')).lower(), logging.NOTSET)\n\n    if level < logging.INFO:\n        log.warning('Insecure logging configuration detected! Sensitive data may be logged.')\n\n\ndef win_verify_env(dirs, permissive=False, pki_dir='', skip_extra=False):\n    '''\n    Verify that the named directories are in place and that the environment\n    can shake the salt\n    '''\n    import salt.utils.win_functions\n    import salt.utils.win_dacl\n\n    # Get the root path directory where salt is installed\n    path = dirs[0]\n    while os.path.basename(path) not in ['salt', 'salt-tests-tmpdir']:\n        path, base = os.path.split(path)\n\n    # Create the root path directory if missing\n    if not os.path.isdir(path):\n        os.makedirs(path)\n\n    # Set permissions to the root path directory\n    current_user = salt.utils.win_functions.get_current_user()\n    if salt.utils.win_functions.is_admin(current_user):\n        try:\n            # Make the Administrators group owner\n            # Use the SID to be locale agnostic\n            salt.utils.win_dacl.set_owner(path, 'S-1-5-32-544')\n\n        except CommandExecutionError:\n            msg = 'Unable to securely set the owner of \"{0}\".'.format(path)\n            if is_console_configured():\n                log.critical(msg)\n            else:\n                sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n        if not permissive:\n            try:\n                # Get a clean dacl by not passing an obj_name\n                dacl = salt.utils.win_dacl.dacl()\n\n                # Add aces to the dacl, use the GUID (locale non-specific)\n                # Administrators Group\n                dacl.add_ace('S-1-5-32-544', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # System\n                dacl.add_ace('S-1-5-18', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # Owner\n                dacl.add_ace('S-1-3-4', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n\n                # Save the dacl to the object\n                dacl.save(path, True)\n\n            except CommandExecutionError:\n                msg = 'Unable to securely set the permissions of ' \\\n                      '\"{0}\".'.format(path)\n                if is_console_configured():\n                    log.critical(msg)\n                else:\n                    sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    # Create the directories\n    for dir_ in dirs:\n        if not dir_:\n            continue\n        if not os.path.isdir(dir_):\n            try:\n                os.makedirs(dir_)\n            except OSError as err:\n                msg = 'Failed to create directory path \"{0}\" - {1}\\n'\n                sys.stderr.write(msg.format(dir_, err))\n                sys.exit(err.errno)\n\n        # The PKI dir gets its own permissions\n        if dir_ == pki_dir:\n            try:\n                # Make Administrators group the owner\n                salt.utils.win_dacl.set_owner(path, 'S-1-5-32-544')\n\n                # Give Admins, System and Owner permissions\n                # Get a clean dacl by not passing an obj_name\n                dacl = salt.utils.win_dacl.dacl()\n\n                # Add aces to the dacl, use the GUID (locale non-specific)\n                # Administrators Group\n                dacl.add_ace('S-1-5-32-544', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # System\n                dacl.add_ace('S-1-5-18', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # Owner\n                dacl.add_ace('S-1-3-4', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n\n                # Save the dacl to the object\n                dacl.save(dir_, True)\n\n            except CommandExecutionError:\n                msg = 'Unable to securely set the permissions of \"{0}\".'\n                msg = msg.format(dir_)\n                if is_console_configured():\n                    log.critical(msg)\n                else:\n                    sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    if skip_extra is False:\n        # Run the extra verification checks\n        zmq_version()\n", "code_before": "# -*- coding: utf-8 -*-\n'''\nA few checks to make sure the environment is sane\n'''\nfrom __future__ import absolute_import\n\n# Original Author: Jeff Schroeder <jeffschroeder@computer.org>\n\n# Import python libs\nimport os\nimport re\nimport sys\nimport stat\nimport errno\nimport socket\nimport logging\n\n# Import third party libs\ntry:\n    import win32file\nexcept ImportError:\n    import resource\n\n# Import salt libs\nfrom salt.log import is_console_configured\nfrom salt.log.setup import LOG_LEVELS\nfrom salt.exceptions import SaltClientError, SaltSystemExit, \\\n    CommandExecutionError\nimport salt.defaults.exitcodes\nimport salt.utils\n\nlog = logging.getLogger(__name__)\n\n\ndef zmq_version():\n    '''\n    ZeroMQ python bindings >= 2.1.9 are required\n    '''\n    try:\n        import zmq\n    except Exception:\n        # Return True for local mode\n        return True\n    ver = zmq.__version__\n    # The last matched group can be None if the version\n    # is something like 3.1 and that will work properly\n    match = re.match(r'^(\\d+)\\.(\\d+)(?:\\.(\\d+))?', ver)\n\n    # Fallthrough and hope for the best\n    if not match:\n        msg = \"Using untested zmq python bindings version: '{0}'\".format(ver)\n        if is_console_configured():\n            log.warning(msg)\n        else:\n            sys.stderr.write(\"WARNING {0}\\n\".format(msg))\n        return True\n\n    major, minor, point = match.groups()\n\n    if major.isdigit():\n        major = int(major)\n    if minor.isdigit():\n        minor = int(minor)\n\n    # point very well could be None\n    if point and point.isdigit():\n        point = int(point)\n\n    if major == 2 and minor == 1:\n        # zmq 2.1dev could be built against a newer libzmq\n        if \"dev\" in ver and not point:\n            msg = 'Using dev zmq module, please report unexpected results'\n            if is_console_configured():\n                log.warning(msg)\n            else:\n                sys.stderr.write(\"WARNING: {0}\\n\".format(msg))\n            return True\n        elif point and point >= 9:\n            return True\n    elif major > 2 or (major == 2 and minor > 1):\n        return True\n\n    # If all else fails, gracefully croak and warn the user\n    log.critical('ZeroMQ python bindings >= 2.1.9 are required')\n    if 'salt-master' in sys.argv[0]:\n        msg = ('The Salt Master is unstable using a ZeroMQ version '\n               'lower than 2.1.11 and requires this fix: http://lists.zeromq.'\n               'org/pipermail/zeromq-dev/2011-June/012094.html')\n        if is_console_configured():\n            log.critical(msg)\n        else:\n            sys.stderr.write('CRITICAL {0}\\n'.format(msg))\n    return False\n\n\ndef lookup_family(hostname):\n    '''\n    Lookup a hostname and determine its address family. The first address returned\n    will be AF_INET6 if the system is IPv6-enabled, and AF_INET otherwise.\n    '''\n    # If lookups fail, fall back to AF_INET sockets (and v4 addresses).\n    fallback = socket.AF_INET\n    try:\n        hostnames = socket.getaddrinfo(\n            hostname or None, None, socket.AF_UNSPEC, socket.SOCK_STREAM\n        )\n        if not hostnames:\n            return fallback\n        h = hostnames[0]\n        return h[0]\n    except socket.gaierror:\n        return fallback\n\n\ndef verify_socket(interface, pub_port, ret_port):\n    '''\n    Attempt to bind to the sockets to verify that they are available\n    '''\n\n    addr_family = lookup_family(interface)\n    for port in pub_port, ret_port:\n        sock = socket.socket(addr_family, socket.SOCK_STREAM)\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            sock.bind((interface, int(port)))\n        except Exception as exc:\n            msg = 'Unable to bind socket {0}:{1}'.format(interface, port)\n            if exc.args:\n                msg = '{0}, error: {1}'.format(msg, str(exc))\n            else:\n                msg = '{0}, this might not be a problem.'.format(msg)\n            msg += '; Is there another salt-master running?'\n            if is_console_configured():\n                log.warning(msg)\n            else:\n                sys.stderr.write('WARNING: {0}\\n'.format(msg))\n            return False\n        finally:\n            sock.close()\n\n    return True\n\n\ndef verify_files(files, user):\n    '''\n    Verify that the named files exist and are owned by the named user\n    '''\n    if salt.utils.is_windows():\n        return True\n    import pwd  # after confirming not running Windows\n    try:\n        pwnam = pwd.getpwnam(user)\n        uid = pwnam[2]\n    except KeyError:\n        err = ('Failed to prepare the Salt environment for user '\n               '{0}. The user is not available.\\n').format(user)\n        sys.stderr.write(err)\n        sys.exit(salt.defaults.exitcodes.EX_NOUSER)\n\n    for fn_ in files:\n        dirname = os.path.dirname(fn_)\n        try:\n            if dirname:\n                try:\n                    os.makedirs(dirname)\n                except OSError as err:\n                    if err.errno != errno.EEXIST:\n                        raise\n            if not os.path.isfile(fn_):\n                with salt.utils.fopen(fn_, 'w+') as fp_:\n                    fp_.write('')\n\n        except IOError as err:\n            if os.path.isfile(dirname):\n                msg = 'Failed to create path {0}, is {1} a file?'.format(fn_, dirname)\n                raise SaltSystemExit(msg=msg)\n            if err.errno != errno.EACCES:\n                raise\n            msg = 'No permissions to access \"{0}\", are you running as the correct user?'.format(fn_)\n            raise SaltSystemExit(msg=msg)\n\n        except OSError as err:\n            msg = 'Failed to create path \"{0}\" - {1}'.format(fn_, err)\n            raise SaltSystemExit(msg=msg)\n\n        stats = os.stat(fn_)\n        if uid != stats.st_uid:\n            try:\n                os.chown(fn_, uid, -1)\n            except OSError:\n                pass\n    return True\n\n\ndef verify_env(dirs, user, permissive=False, pki_dir='', skip_extra=False):\n    '''\n    Verify that the named directories are in place and that the environment\n    can shake the salt\n    '''\n    if salt.utils.is_windows():\n        return win_verify_env(dirs, permissive, pki_dir, skip_extra)\n    import pwd  # after confirming not running Windows\n    try:\n        pwnam = pwd.getpwnam(user)\n        uid = pwnam[2]\n        gid = pwnam[3]\n        groups = salt.utils.get_gid_list(user, include_default=False)\n\n    except KeyError:\n        err = ('Failed to prepare the Salt environment for user '\n               '{0}. The user is not available.\\n').format(user)\n        sys.stderr.write(err)\n        sys.exit(salt.defaults.exitcodes.EX_NOUSER)\n    for dir_ in dirs:\n        if not dir_:\n            continue\n        if not os.path.isdir(dir_):\n            try:\n                cumask = os.umask(18)  # 077\n                os.makedirs(dir_)\n                # If starting the process as root, chown the new dirs\n                if os.getuid() == 0:\n                    os.chown(dir_, uid, gid)\n                os.umask(cumask)\n            except OSError as err:\n                msg = 'Failed to create directory path \"{0}\" - {1}\\n'\n                sys.stderr.write(msg.format(dir_, err))\n                sys.exit(err.errno)\n\n        mode = os.stat(dir_)\n        # If starting the process as root, chown the new dirs\n        if os.getuid() == 0:\n            fmode = os.stat(dir_)\n            if fmode.st_uid != uid or fmode.st_gid != gid:\n                if permissive and fmode.st_gid in groups:\n                    # Allow the directory to be owned by any group root\n                    # belongs to if we say it's ok to be permissive\n                    pass\n                else:\n                    # chown the file for the new user\n                    os.chown(dir_, uid, gid)\n            for subdir in [a for a in os.listdir(dir_) if 'jobs' not in a]:\n                fsubdir = os.path.join(dir_, subdir)\n                if '{0}jobs'.format(os.path.sep) in fsubdir:\n                    continue\n                for root, dirs, files in os.walk(fsubdir):\n                    for name in files:\n                        if name.startswith('.'):\n                            continue\n                        path = os.path.join(root, name)\n                        try:\n                            fmode = os.stat(path)\n                        except (IOError, OSError):\n                            pass\n                        if fmode.st_uid != uid or fmode.st_gid != gid:\n                            if permissive and fmode.st_gid in groups:\n                                pass\n                            else:\n                                # chown the file for the new user\n                                os.chown(path, uid, gid)\n                    for name in dirs:\n                        path = os.path.join(root, name)\n                        fmode = os.stat(path)\n                        if fmode.st_uid != uid or fmode.st_gid != gid:\n                            if permissive and fmode.st_gid in groups:\n                                pass\n                            else:\n                                # chown the file for the new user\n                                os.chown(path, uid, gid)\n        # Allow the pki dir to be 700 or 750, but nothing else.\n        # This prevents other users from writing out keys, while\n        # allowing the use-case of 3rd-party software (like django)\n        # to read in what it needs to integrate.\n        #\n        # If the permissions aren't correct, default to the more secure 700.\n        # If acls are enabled, the pki_dir needs to remain readable, this\n        # is still secure because the private keys are still only readable\n        # by the user running the master\n        if dir_ == pki_dir:\n            smode = stat.S_IMODE(mode.st_mode)\n            if smode != 448 and smode != 488:\n                if os.access(dir_, os.W_OK):\n                    os.chmod(dir_, 448)\n                else:\n                    msg = 'Unable to securely set the permissions of \"{0}\".'\n                    msg = msg.format(dir_)\n                    if is_console_configured():\n                        log.critical(msg)\n                    else:\n                        sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    if skip_extra is False:\n        # Run the extra verification checks\n        zmq_version()\n\n\ndef check_user(user):\n    '''\n    Check user and assign process uid/gid.\n    '''\n    if salt.utils.is_windows():\n        return True\n    if user == salt.utils.get_user():\n        return True\n    import pwd  # after confirming not running Windows\n    try:\n        pwuser = pwd.getpwnam(user)\n        try:\n            if hasattr(os, 'initgroups'):\n                os.initgroups(user, pwuser.pw_gid)  # pylint: disable=minimum-python-version\n            else:\n                os.setgroups(salt.utils.get_gid_list(user, include_default=False))\n            os.setgid(pwuser.pw_gid)\n            os.setuid(pwuser.pw_uid)\n\n            # We could just reset the whole environment but let's just override\n            # the variables we can get from pwuser\n            if 'HOME' in os.environ:\n                os.environ['HOME'] = pwuser.pw_dir\n\n            if 'SHELL' in os.environ:\n                os.environ['SHELL'] = pwuser.pw_shell\n\n            for envvar in ('USER', 'LOGNAME'):\n                if envvar in os.environ:\n                    os.environ[envvar] = pwuser.pw_name\n\n        except OSError:\n            msg = 'Salt configured to run as user \"{0}\" but unable to switch.'\n            msg = msg.format(user)\n            if is_console_configured():\n                log.critical(msg)\n            else:\n                sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n            return False\n    except KeyError:\n        msg = 'User not found: \"{0}\"'.format(user)\n        if is_console_configured():\n            log.critical(msg)\n        else:\n            sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n        return False\n    return True\n\n\ndef list_path_traversal(path):\n    '''\n    Returns a full list of directories leading up to, and including, a path.\n\n    So list_path_traversal('/path/to/salt') would return:\n        ['/', '/path', '/path/to', '/path/to/salt']\n    in that order.\n\n    This routine has been tested on Windows systems as well.\n    list_path_traversal('c:\\\\path\\\\to\\\\salt') on Windows would return:\n        ['c:\\\\', 'c:\\\\path', 'c:\\\\path\\\\to', 'c:\\\\path\\\\to\\\\salt']\n    '''\n    out = [path]\n    (head, tail) = os.path.split(path)\n    if tail == '':\n        # paths with trailing separators will return an empty string\n        out = [head]\n        (head, tail) = os.path.split(head)\n    while head != out[0]:\n        # loop until head is the same two consecutive times\n        out.insert(0, head)\n        (head, tail) = os.path.split(head)\n    return out\n\n\ndef check_path_traversal(path, user='root', skip_perm_errors=False):\n    '''\n    Walk from the root up to a directory and verify that the current\n    user has access to read each directory. This is used for  making\n    sure a user can read all parent directories of the minion's  key\n    before trying to go and generate a new key and raising an IOError\n    '''\n    for tpath in list_path_traversal(path):\n        if not os.access(tpath, os.R_OK):\n            msg = 'Could not access {0}.'.format(tpath)\n            if not os.path.exists(tpath):\n                msg += ' Path does not exist.'\n            else:\n                current_user = salt.utils.get_user()\n                # Make the error message more intelligent based on how\n                # the user invokes salt-call or whatever other script.\n                if user != current_user:\n                    msg += ' Try running as user {0}.'.format(user)\n                else:\n                    msg += ' Please give {0} read permissions.'.format(user)\n\n            # We don't need to bail on config file permission errors\n            # if the CLI\n            # process is run with the -a flag\n            if skip_perm_errors:\n                return\n            # Propagate this exception up so there isn't a sys.exit()\n            # in the middle of code that could be imported elsewhere.\n            raise SaltClientError(msg)\n\n\ndef check_max_open_files(opts):\n    '''\n    Check the number of max allowed open files and adjust if needed\n    '''\n    mof_c = opts.get('max_open_files', 100000)\n    if sys.platform.startswith('win'):\n        # Check the Windows API for more detail on this\n        # http://msdn.microsoft.com/en-us/library/xt874334(v=vs.71).aspx\n        # and the python binding http://timgolden.me.uk/pywin32-docs/win32file.html\n        mof_s = mof_h = win32file._getmaxstdio()\n    else:\n        mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n\n    accepted_keys_dir = os.path.join(opts.get('pki_dir'), 'minions')\n    accepted_count = len(os.listdir(accepted_keys_dir))\n\n    log.debug(\n        'This salt-master instance has accepted {0} minion keys.'.format(\n            accepted_count\n        )\n    )\n\n    level = logging.INFO\n\n    if (accepted_count * 4) <= mof_s:\n        # We check for the soft value of max open files here because that's the\n        # value the user chose to raise to.\n        #\n        # The number of accepted keys multiplied by four(4) is lower than the\n        # soft value, everything should be OK\n        return\n\n    msg = (\n        'The number of accepted minion keys({0}) should be lower than 1/4 '\n        'of the max open files soft setting({1}). '.format(\n            accepted_count, mof_s\n        )\n    )\n\n    if accepted_count >= mof_s:\n        # This should never occur, it might have already crashed\n        msg += 'salt-master will crash pretty soon! '\n        level = logging.CRITICAL\n    elif (accepted_count * 2) >= mof_s:\n        # This is way too low, CRITICAL\n        level = logging.CRITICAL\n    elif (accepted_count * 3) >= mof_s:\n        level = logging.WARNING\n        # The accepted count is more than 3 time, WARN\n    elif (accepted_count * 4) >= mof_s:\n        level = logging.INFO\n\n    if mof_c < mof_h:\n        msg += ('According to the system\\'s hard limit, there\\'s still a '\n                'margin of {0} to raise the salt\\'s max_open_files '\n                'setting. ').format(mof_h - mof_c)\n\n    msg += 'Please consider raising this value.'\n    log.log(level=level, msg=msg)\n\n\ndef clean_path(root, path, subdir=False):\n    '''\n    Accepts the root the path needs to be under and verifies that the path is\n    under said root. Pass in subdir=True if the path can result in a\n    subdirectory of the root instead of having to reside directly in the root\n    '''\n    if not os.path.isabs(root):\n        return ''\n    if not os.path.isabs(path):\n        path = os.path.join(root, path)\n    path = os.path.normpath(path)\n    if subdir:\n        if path.startswith(root):\n            return path\n    else:\n        if os.path.dirname(path) == os.path.normpath(root):\n            return path\n    return ''\n\n\ndef clean_id(id_):\n    '''\n    Returns if the passed id is clean.\n    '''\n    if re.search(r'\\.\\.\\{sep}'.format(sep=os.sep), id_):\n        return False\n    return True\n\n\ndef valid_id(opts, id_):\n    '''\n    Returns if the passed id is valid\n    '''\n    try:\n        return bool(clean_path(opts['pki_dir'], id_)) and clean_id(id_)\n    except (AttributeError, KeyError, TypeError) as e:\n        return False\n\n\ndef safe_py_code(code):\n    '''\n    Check a string to see if it has any potentially unsafe routines which\n    could be executed via python, this routine is used to improve the\n    safety of modules suct as virtualenv\n    '''\n    bads = (\n            'import',\n            ';',\n            'subprocess',\n            'eval',\n            'open',\n            'file',\n            'exec',\n            'input')\n    for bad in bads:\n        if code.count(bad):\n            return False\n    return True\n\n\ndef verify_log(opts):\n    '''\n    If an insecre logging configuration is found, show a warning\n    '''\n    level = LOG_LEVELS.get(str(opts.get('log_level')).lower(), logging.NOTSET)\n\n    if level < logging.INFO:\n        log.warning('Insecure logging configuration detected! Sensitive data may be logged.')\n\n\ndef win_verify_env(dirs, permissive=False, pki_dir='', skip_extra=False):\n    '''\n    Verify that the named directories are in place and that the environment\n    can shake the salt\n    '''\n    import salt.utils.win_functions\n    import salt.utils.win_dacl\n\n    # Get the root path directory where salt is installed\n    path = dirs[0]\n    while os.path.basename(path) not in ['salt', 'salt-tests-tmpdir']:\n        path, base = os.path.split(path)\n\n    # Create the root path directory if missing\n    if not os.path.isdir(path):\n        os.makedirs(path)\n\n    # Set permissions to the root path directory\n    current_user = salt.utils.win_functions.get_current_user()\n    if salt.utils.win_functions.is_admin(current_user):\n        try:\n            # Make the Administrators group owner\n            # Use the SID to be locale agnostic\n            salt.utils.win_dacl.set_owner(path, 'S-1-5-32-544')\n\n        except CommandExecutionError:\n            msg = 'Unable to securely set the owner of \"{0}\".'.format(path)\n            if is_console_configured():\n                log.critical(msg)\n            else:\n                sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n        if not permissive:\n            try:\n                # Get a clean dacl by not passing an obj_name\n                dacl = salt.utils.win_dacl.dacl()\n\n                # Add aces to the dacl, use the GUID (locale non-specific)\n                # Administrators Group\n                dacl.add_ace('S-1-5-32-544', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # System\n                dacl.add_ace('S-1-5-18', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # Owner\n                dacl.add_ace('S-1-3-4', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n\n                # Save the dacl to the object\n                dacl.save(path, True)\n\n            except CommandExecutionError:\n                msg = 'Unable to securely set the permissions of ' \\\n                      '\"{0}\".'.format(path)\n                if is_console_configured():\n                    log.critical(msg)\n                else:\n                    sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    # Create the directories\n    for dir_ in dirs:\n        if not dir_:\n            continue\n        if not os.path.isdir(dir_):\n            try:\n                os.makedirs(dir_)\n            except OSError as err:\n                msg = 'Failed to create directory path \"{0}\" - {1}\\n'\n                sys.stderr.write(msg.format(dir_, err))\n                sys.exit(err.errno)\n\n        # The PKI dir gets its own permissions\n        if dir_ == pki_dir:\n            try:\n                # Make Administrators group the owner\n                salt.utils.win_dacl.set_owner(path, 'S-1-5-32-544')\n\n                # Give Admins, System and Owner permissions\n                # Get a clean dacl by not passing an obj_name\n                dacl = salt.utils.win_dacl.dacl()\n\n                # Add aces to the dacl, use the GUID (locale non-specific)\n                # Administrators Group\n                dacl.add_ace('S-1-5-32-544', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # System\n                dacl.add_ace('S-1-5-18', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n                # Owner\n                dacl.add_ace('S-1-3-4', 'grant', 'full_control',\n                             'this_folder_subfolders_files')\n\n                # Save the dacl to the object\n                dacl.save(dir_, True)\n\n            except CommandExecutionError:\n                msg = 'Unable to securely set the permissions of \"{0}\".'\n                msg = msg.format(dir_)\n                if is_console_configured():\n                    log.critical(msg)\n                else:\n                    sys.stderr.write(\"CRITICAL: {0}\\n\".format(msg))\n\n    if skip_extra is False:\n        # Run the extra verification checks\n        zmq_version()\n", "patch": "@@ -480,22 +480,15 @@ def clean_path(root, path, subdir=False):\n     return ''\n \n \n-def clean_id(id_):\n-    '''\n-    Returns if the passed id is clean.\n-    '''\n-    if re.search(r'\\.\\.\\{sep}'.format(sep=os.sep), id_):\n-        return False\n-    return True\n-\n-\n def valid_id(opts, id_):\n     '''\n     Returns if the passed id is valid\n     '''\n     try:\n-        return bool(clean_path(opts['pki_dir'], id_)) and clean_id(id_)\n-    except (AttributeError, KeyError, TypeError) as e:\n+        if any(x in id_ for x in ('/', '\\\\', '\\0')):\n+            return False\n+        return bool(clean_path(opts['pki_dir'], id_))\n+    except (AttributeError, KeyError, TypeError):\n         return False\n \n ", "file_path": "files/2017_10/25", "file_language": "py", "file_name": "salt/utils/verify.py", "outdated_file_modify": 1, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}, {"raw_url": "https://github.com/saltstack/salt/raw/80d90307b07b3703428ecbb7c8bb468e28a9ae6d/tests%2Funit%2Futils%2Ftest_verify.py", "code": "# -*- coding: utf-8 -*-\n'''\nTest the verification routines\n'''\n\n# Import Python libs\nfrom __future__ import absolute_import\nimport getpass\nimport os\nimport sys\nimport stat\nimport shutil\nimport resource\nimport tempfile\nimport socket\n\n# Import Salt Testing libs\nfrom tests.support.unit import skipIf, TestCase\nfrom tests.support.paths import TMP\nfrom tests.support.helpers import (\n    requires_network,\n    TestsLoggingHandler\n)\nfrom tests.support.mock import (\n    MagicMock,\n    patch,\n    NO_MOCK,\n    NO_MOCK_REASON\n)\n\n# Import salt libs\nimport salt.utils\nfrom salt.utils.verify import (\n    check_user,\n    verify_env,\n    verify_socket,\n    zmq_version,\n    check_max_open_files,\n    valid_id,\n    log,\n    verify_log,\n)\n\n# Import 3rd-party libs\nfrom salt.ext.six.moves import range  # pylint: disable=import-error,redefined-builtin\n\n\nclass TestVerify(TestCase):\n    '''\n    Verify module tests\n    '''\n\n    def test_valid_id_exception_handler(self):\n        '''\n        Ensure we just return False if we pass in invalid or undefined paths.\n        Refs #8259\n        '''\n        opts = {'pki_dir': '/tmp/whatever'}\n        self.assertFalse(valid_id(opts, None))\n\n    def test_valid_id_pathsep(self):\n        '''\n        Path separators in id should make it invalid\n        '''\n        opts = {'pki_dir': '/tmp/whatever'}\n        # We have to test both path separators because os.path.normpath will\n        # convert forward slashes to backslashes on Windows.\n        for pathsep in ('/', '\\\\'):\n            self.assertFalse(valid_id(opts, pathsep.join(('..', 'foobar'))))\n\n    def test_zmq_verify(self):\n        self.assertTrue(zmq_version())\n\n    def test_zmq_verify_insufficient(self):\n        import zmq\n        with patch.object(zmq, '__version__', '2.1.0'):\n            self.assertFalse(zmq_version())\n\n    def test_user(self):\n        self.assertTrue(check_user(getpass.getuser()))\n\n    def test_no_user(self):\n        # Catch sys.stderr here since no logging is configured and\n        # check_user WILL write to sys.stderr\n        class FakeWriter(object):\n            def __init__(self):\n                self.output = \"\"\n\n            def write(self, data):\n                self.output += data\n        stderr = sys.stderr\n        writer = FakeWriter()\n        sys.stderr = writer\n        # Now run the test\n        self.assertFalse(check_user('nouser'))\n        # Restore sys.stderr\n        sys.stderr = stderr\n        if writer.output != 'CRITICAL: User not found: \"nouser\"\\n':\n            # If there's a different error catch, write it to sys.stderr\n            sys.stderr.write(writer.output)\n\n    @skipIf(sys.platform.startswith('win'), 'No verify_env Windows')\n    def test_verify_env(self):\n        root_dir = tempfile.mkdtemp(dir=TMP)\n        var_dir = os.path.join(root_dir, 'var', 'log', 'salt')\n        verify_env([var_dir], getpass.getuser())\n        self.assertTrue(os.path.exists(var_dir))\n        dir_stat = os.stat(var_dir)\n        self.assertEqual(dir_stat.st_uid, os.getuid())\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXU, stat.S_IRWXU)\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXG, 40)\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXO, 5)\n\n    @requires_network(only_local_network=True)\n    def test_verify_socket(self):\n        self.assertTrue(verify_socket('', 18000, 18001))\n        if socket.has_ipv6:\n            # Only run if Python is built with IPv6 support; otherwise\n            # this will just fail.\n            try:\n                self.assertTrue(verify_socket('::', 18000, 18001))\n            except socket.error as serr:\n                # Python has IPv6 enabled, but the system cannot create\n                # IPv6 sockets (otherwise the test would return a bool)\n                # - skip the test\n                #\n                # FIXME - possibly emit a message that the system does\n                # not support IPv6.\n                pass\n\n    @skipIf(True, 'Skipping until we can find why Jenkins is bailing out')\n    def test_max_open_files(self):\n        with TestsLoggingHandler() as handler:\n            logmsg_dbg = (\n                'DEBUG:This salt-master instance has accepted {0} minion keys.'\n            )\n            logmsg_chk = (\n                '{0}:The number of accepted minion keys({1}) should be lower '\n                'than 1/4 of the max open files soft setting({2}). According '\n                'to the system\\'s hard limit, there\\'s still a margin of {3} '\n                'to raise the salt\\'s max_open_files setting. Please consider '\n                'raising this value.'\n            )\n            logmsg_crash = (\n                '{0}:The number of accepted minion keys({1}) should be lower '\n                'than 1/4 of the max open files soft setting({2}). '\n                'salt-master will crash pretty soon! According to the '\n                'system\\'s hard limit, there\\'s still a margin of {3} to '\n                'raise the salt\\'s max_open_files setting. Please consider '\n                'raising this value.'\n            )\n\n            mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n            tempdir = tempfile.mkdtemp(prefix='fake-keys')\n            keys_dir = os.path.join(tempdir, 'minions')\n            os.makedirs(keys_dir)\n\n            mof_test = 256\n\n            resource.setrlimit(resource.RLIMIT_NOFILE, (mof_test, mof_h))\n\n            try:\n                prev = 0\n                for newmax, level in ((24, None), (66, 'INFO'),\n                                      (127, 'WARNING'), (196, 'CRITICAL')):\n\n                    for n in range(prev, newmax):\n                        kpath = os.path.join(keys_dir, str(n))\n                        with salt.utils.fopen(kpath, 'w') as fp_:\n                            fp_.write(str(n))\n\n                    opts = {\n                        'max_open_files': newmax,\n                        'pki_dir': tempdir\n                    }\n\n                    check_max_open_files(opts)\n\n                    if level is None:\n                        # No log message is triggered, only the DEBUG one which\n                        # tells us how many minion keys were accepted.\n                        self.assertEqual(\n                            [logmsg_dbg.format(newmax)], handler.messages\n                        )\n                    else:\n                        self.assertIn(\n                            logmsg_dbg.format(newmax), handler.messages\n                        )\n                        self.assertIn(\n                            logmsg_chk.format(\n                                level,\n                                newmax,\n                                mof_test,\n                                mof_h - newmax,\n                            ),\n                            handler.messages\n                        )\n                    handler.clear()\n                    prev = newmax\n\n                newmax = mof_test\n                for n in range(prev, newmax):\n                    kpath = os.path.join(keys_dir, str(n))\n                    with salt.utils.fopen(kpath, 'w') as fp_:\n                        fp_.write(str(n))\n\n                opts = {\n                    'max_open_files': newmax,\n                    'pki_dir': tempdir\n                }\n\n                check_max_open_files(opts)\n                self.assertIn(logmsg_dbg.format(newmax), handler.messages)\n                self.assertIn(\n                    logmsg_crash.format(\n                        'CRITICAL',\n                        newmax,\n                        mof_test,\n                        mof_h - newmax,\n                    ),\n                    handler.messages\n                )\n                handler.clear()\n            except IOError as err:\n                if err.errno == 24:\n                    # Too many open files\n                    self.skipTest('We\\'ve hit the max open files setting')\n                raise\n            finally:\n                shutil.rmtree(tempdir)\n                resource.setrlimit(resource.RLIMIT_NOFILE, (mof_s, mof_h))\n\n    @skipIf(NO_MOCK, NO_MOCK_REASON)\n    def test_verify_log(self):\n        '''\n        Test that verify_log works as expected\n        '''\n        message = 'Insecure logging configuration detected! Sensitive data may be logged.'\n\n        mock_cheese = MagicMock()\n        with patch.object(log, 'warning', mock_cheese):\n            verify_log({'log_level': 'cheeseshop'})\n            mock_cheese.assert_called_once_with(message)\n\n        mock_trace = MagicMock()\n        with patch.object(log, 'warning', mock_trace):\n            verify_log({'log_level': 'trace'})\n            mock_trace.assert_called_once_with(message)\n\n        mock_none = MagicMock()\n        with patch.object(log, 'warning', mock_none):\n            verify_log({})\n            mock_none.assert_called_once_with(message)\n\n        mock_info = MagicMock()\n        with patch.object(log, 'warning', mock_info):\n            verify_log({'log_level': 'info'})\n            self.assertTrue(mock_info.call_count == 0)\n", "code_before": "# -*- coding: utf-8 -*-\n'''\nTest the verification routines\n'''\n\n# Import Python libs\nfrom __future__ import absolute_import\nimport getpass\nimport os\nimport sys\nimport stat\nimport shutil\nimport resource\nimport tempfile\nimport socket\n\n# Import Salt Testing libs\nfrom tests.support.unit import skipIf, TestCase\nfrom tests.support.paths import TMP\nfrom tests.support.helpers import (\n    requires_network,\n    TestsLoggingHandler\n)\nfrom tests.support.mock import (\n    MagicMock,\n    patch,\n    NO_MOCK,\n    NO_MOCK_REASON\n)\n\n# Import salt libs\nimport salt.utils\nfrom salt.utils.verify import (\n    check_user,\n    verify_env,\n    verify_socket,\n    zmq_version,\n    check_max_open_files,\n    valid_id,\n    log,\n    verify_log,\n)\n\n# Import 3rd-party libs\nfrom salt.ext.six.moves import range  # pylint: disable=import-error,redefined-builtin\n\n\nclass TestVerify(TestCase):\n    '''\n    Verify module tests\n    '''\n\n    def test_valid_id_exception_handler(self):\n        '''\n        Ensure we just return False if we pass in invalid or undefined paths.\n        Refs #8259\n        '''\n        opts = {'pki_dir': '/tmp/whatever'}\n        self.assertFalse(valid_id(opts, None))\n\n    def test_zmq_verify(self):\n        self.assertTrue(zmq_version())\n\n    def test_zmq_verify_insufficient(self):\n        import zmq\n        with patch.object(zmq, '__version__', '2.1.0'):\n            self.assertFalse(zmq_version())\n\n    def test_user(self):\n        self.assertTrue(check_user(getpass.getuser()))\n\n    def test_no_user(self):\n        # Catch sys.stderr here since no logging is configured and\n        # check_user WILL write to sys.stderr\n        class FakeWriter(object):\n            def __init__(self):\n                self.output = \"\"\n\n            def write(self, data):\n                self.output += data\n        stderr = sys.stderr\n        writer = FakeWriter()\n        sys.stderr = writer\n        # Now run the test\n        self.assertFalse(check_user('nouser'))\n        # Restore sys.stderr\n        sys.stderr = stderr\n        if writer.output != 'CRITICAL: User not found: \"nouser\"\\n':\n            # If there's a different error catch, write it to sys.stderr\n            sys.stderr.write(writer.output)\n\n    @skipIf(sys.platform.startswith('win'), 'No verify_env Windows')\n    def test_verify_env(self):\n        root_dir = tempfile.mkdtemp(dir=TMP)\n        var_dir = os.path.join(root_dir, 'var', 'log', 'salt')\n        verify_env([var_dir], getpass.getuser())\n        self.assertTrue(os.path.exists(var_dir))\n        dir_stat = os.stat(var_dir)\n        self.assertEqual(dir_stat.st_uid, os.getuid())\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXU, stat.S_IRWXU)\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXG, 40)\n        self.assertEqual(dir_stat.st_mode & stat.S_IRWXO, 5)\n\n    @requires_network(only_local_network=True)\n    def test_verify_socket(self):\n        self.assertTrue(verify_socket('', 18000, 18001))\n        if socket.has_ipv6:\n            # Only run if Python is built with IPv6 support; otherwise\n            # this will just fail.\n            try:\n                self.assertTrue(verify_socket('::', 18000, 18001))\n            except socket.error as serr:\n                # Python has IPv6 enabled, but the system cannot create\n                # IPv6 sockets (otherwise the test would return a bool)\n                # - skip the test\n                #\n                # FIXME - possibly emit a message that the system does\n                # not support IPv6.\n                pass\n\n    @skipIf(True, 'Skipping until we can find why Jenkins is bailing out')\n    def test_max_open_files(self):\n        with TestsLoggingHandler() as handler:\n            logmsg_dbg = (\n                'DEBUG:This salt-master instance has accepted {0} minion keys.'\n            )\n            logmsg_chk = (\n                '{0}:The number of accepted minion keys({1}) should be lower '\n                'than 1/4 of the max open files soft setting({2}). According '\n                'to the system\\'s hard limit, there\\'s still a margin of {3} '\n                'to raise the salt\\'s max_open_files setting. Please consider '\n                'raising this value.'\n            )\n            logmsg_crash = (\n                '{0}:The number of accepted minion keys({1}) should be lower '\n                'than 1/4 of the max open files soft setting({2}). '\n                'salt-master will crash pretty soon! According to the '\n                'system\\'s hard limit, there\\'s still a margin of {3} to '\n                'raise the salt\\'s max_open_files setting. Please consider '\n                'raising this value.'\n            )\n\n            mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)\n            tempdir = tempfile.mkdtemp(prefix='fake-keys')\n            keys_dir = os.path.join(tempdir, 'minions')\n            os.makedirs(keys_dir)\n\n            mof_test = 256\n\n            resource.setrlimit(resource.RLIMIT_NOFILE, (mof_test, mof_h))\n\n            try:\n                prev = 0\n                for newmax, level in ((24, None), (66, 'INFO'),\n                                      (127, 'WARNING'), (196, 'CRITICAL')):\n\n                    for n in range(prev, newmax):\n                        kpath = os.path.join(keys_dir, str(n))\n                        with salt.utils.fopen(kpath, 'w') as fp_:\n                            fp_.write(str(n))\n\n                    opts = {\n                        'max_open_files': newmax,\n                        'pki_dir': tempdir\n                    }\n\n                    check_max_open_files(opts)\n\n                    if level is None:\n                        # No log message is triggered, only the DEBUG one which\n                        # tells us how many minion keys were accepted.\n                        self.assertEqual(\n                            [logmsg_dbg.format(newmax)], handler.messages\n                        )\n                    else:\n                        self.assertIn(\n                            logmsg_dbg.format(newmax), handler.messages\n                        )\n                        self.assertIn(\n                            logmsg_chk.format(\n                                level,\n                                newmax,\n                                mof_test,\n                                mof_h - newmax,\n                            ),\n                            handler.messages\n                        )\n                    handler.clear()\n                    prev = newmax\n\n                newmax = mof_test\n                for n in range(prev, newmax):\n                    kpath = os.path.join(keys_dir, str(n))\n                    with salt.utils.fopen(kpath, 'w') as fp_:\n                        fp_.write(str(n))\n\n                opts = {\n                    'max_open_files': newmax,\n                    'pki_dir': tempdir\n                }\n\n                check_max_open_files(opts)\n                self.assertIn(logmsg_dbg.format(newmax), handler.messages)\n                self.assertIn(\n                    logmsg_crash.format(\n                        'CRITICAL',\n                        newmax,\n                        mof_test,\n                        mof_h - newmax,\n                    ),\n                    handler.messages\n                )\n                handler.clear()\n            except IOError as err:\n                if err.errno == 24:\n                    # Too many open files\n                    self.skipTest('We\\'ve hit the max open files setting')\n                raise\n            finally:\n                shutil.rmtree(tempdir)\n                resource.setrlimit(resource.RLIMIT_NOFILE, (mof_s, mof_h))\n\n    @skipIf(NO_MOCK, NO_MOCK_REASON)\n    def test_verify_log(self):\n        '''\n        Test that verify_log works as expected\n        '''\n        message = 'Insecure logging configuration detected! Sensitive data may be logged.'\n\n        mock_cheese = MagicMock()\n        with patch.object(log, 'warning', mock_cheese):\n            verify_log({'log_level': 'cheeseshop'})\n            mock_cheese.assert_called_once_with(message)\n\n        mock_trace = MagicMock()\n        with patch.object(log, 'warning', mock_trace):\n            verify_log({'log_level': 'trace'})\n            mock_trace.assert_called_once_with(message)\n\n        mock_none = MagicMock()\n        with patch.object(log, 'warning', mock_none):\n            verify_log({})\n            mock_none.assert_called_once_with(message)\n\n        mock_info = MagicMock()\n        with patch.object(log, 'warning', mock_info):\n            verify_log({'log_level': 'info'})\n            self.assertTrue(mock_info.call_count == 0)\n", "patch": "@@ -58,6 +58,16 @@ def test_valid_id_exception_handler(self):\n         opts = {'pki_dir': '/tmp/whatever'}\n         self.assertFalse(valid_id(opts, None))\n \n+    def test_valid_id_pathsep(self):\n+        '''\n+        Path separators in id should make it invalid\n+        '''\n+        opts = {'pki_dir': '/tmp/whatever'}\n+        # We have to test both path separators because os.path.normpath will\n+        # convert forward slashes to backslashes on Windows.\n+        for pathsep in ('/', '\\\\'):\n+            self.assertFalse(valid_id(opts, pathsep.join(('..', 'foobar'))))\n+\n     def test_zmq_verify(self):\n         self.assertTrue(zmq_version())\n ", "file_path": "files/2017_10/26", "file_language": "py", "file_name": "tests/unit/utils/test_verify.py", "outdated_file_modify": 0, "outdated_file_before": 0, "outdated_file_after": 0, "llm_check": 1, "static_check": 0, "static": {"rats": [false, []], "semgrep": [false, []]}, "target": -1, "function_before": [], "function_after": []}], "outdated": 0, "cwe_descripiton": "", "cwe_consequence": "", "cwe_method": "", "cwe_solution": ""}
